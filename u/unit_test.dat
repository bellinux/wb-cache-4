500|7457|Public
5|$|Many alpha, beta, and release-candidates {{are also}} {{released}} as previews and for testing before final releases. Although {{there is a}} rough schedule for each release, this is often pushed back, if the code is not ready. The development team monitors {{the state of the}} code by running the large <b>unit</b> <b>test</b> suite during development, and using the BuildBot continuous integration system.|$|E
5|$|The {{concept of}} {{electric}} potential is {{closely linked to}} that of the electric field. A small charge placed within an electric field experiences a force, and to have brought that charge to that point against the force requires work. The electric potential at any point is defined as the energy required to bring a <b>unit</b> <b>test</b> charge from an infinite distance slowly to that point. It is usually measured in volts, and one volt is the potential for which one joule of work must be expended to bring a charge of one coulomb from infinity. This definition of potential, while formal, has little practical application, and a more useful concept is that of electric potential difference, and is the energy required to move a unit charge between two specified points. An electric field has the special property that it is conservative, which means that the path taken by the test charge is irrelevant: all paths between two specified points expend the same energy, and thus a unique value for potential difference may be stated. The volt is so strongly identified as the unit of choice for measurement and description of electric potential difference that the term voltage sees greater everyday usage.|$|E
25|$|He {{began to}} pilot Cessna L-19 Bird Dogs and de Havilland Canada DHC-2 Beavers in Alaska for {{military}} topographic studies. His first overseas flying assignment was to Wheelus Air Base in Tripoli, Libya. There he mapped the desert for two years, flying de Havilland Canada DHC-3 Otter, Beaver, Birddog and OH-23 Raven aircraft as an instructor pilot and <b>unit</b> <b>test</b> pilot.|$|E
50|$|The Visual Studio <b>Unit</b> <b>Testing</b> Framework {{describes}} Microsoft's {{suite of}} <b>unit</b> <b>testing</b> tools as integrated into some versions of Visual Studio 2005 and later. The <b>unit</b> <b>testing</b> framework {{is defined in}} Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll. <b>Unit</b> <b>tests</b> created with the <b>unit</b> <b>testing</b> framework can be executed in Visual Studio or, using MSTest.exe, from a command line.|$|R
40|$|Although <b>unit</b> <b>testing</b> is {{essential}} for programming, current languages only barely support the developer in composing <b>unit</b> <b>tests</b> into new ones or in navigating between <b>unit</b> <b>tests</b> and their corresponding methods under test. We have taken several Smalltalk programs and analyzed the relationships between <b>unit</b> <b>tests</b> and methods under test, and the relationships amongst <b>unit</b> <b>tests.</b> First results indicate that most <b>unit</b> <b>tests</b> can be seen or at least decomposed into commands which focus on single methods, and that large portions of <b>unit</b> <b>tests</b> overlap each other. But these relationships between <b>unit</b> <b>tests</b> and methods under test are not reflected in current languages. We therefore first conceptually extend the meta-model of Smalltalk with one-method commands so that <b>unit</b> <b>tests</b> become both composable and navigable. Then we introduce a first lightweight implementation of this meta model using method comments to differentiate between the several test phases of existing XUnit test case methods. 1...|$|R
40|$|In {{spite of}} the utility of <b>unit</b> <b>tests,</b> most R package {{developers}} do not write them. exampletestr {{makes it easier to}} start writing <b>unit</b> <b>tests</b> by creating shells/skeletons of <b>unit</b> <b>tests</b> based on the examples in the user's package documentation. When completed, these <b>unit</b> <b>tests</b> test whether said examples run correctly. By combining the functionality of exampletestr with that of covr, having ensured that their examples adequately demonstrate the features of their package, the developer can have much of the work of constructing a comprehensive set of <b>unit</b> <b>tests</b> done for them...|$|R
500|$|According to Ranaut, she was [...] "stubborn and rebellious" [...] {{while growing}} up: [...] "If {{my father would}} gift my brother a plastic gun and get a doll for me, I would not accept that. I {{questioned}} the discrimination." [...] She did not subscribe to the stereotypes that were expected of her and experimented with fashion from a young age, often pairing up accessories and clothes that would seem [...] "bizarre" [...] to her neighbours. Ranaut was educated at the DAV School in Chandigarh, where she pursued science as her core subject, remarking that she was [...] "very studious" [...] and [...] "always paranoid about [...] results". She initially intended {{to become a doctor}} on the insistence of her parents. However, a failed <b>unit</b> <b>test</b> in chemistry during her twelfth grade led Ranaut to reconsider her career prospects and despite preparing for the All India Pre Medical Test, she did not turn up for the exam. Determined to find her [...] "space and freedom", she relocated to Delhi at the age of sixteen. Her decision not to pursue medicine led to constant feuding with her parents and her father refused to sponsor a pursuit he considered to be aimless.|$|E
2500|$|At {{the heart}} of BDD is a {{rethinking}} of the approach to the unit testing and acceptance testing that naturally arise with these issues. For example, BDD suggests that <b>unit</b> <b>test</b> names be whole sentences starting with a conditional verb ("should" [...] in English for example) and should be written in order of business value. Acceptance tests should be written using the standard agile framework of a user story: [...] "As a [...] I want [...] so that [...] ". Acceptance criteria should be written in terms of scenarios and implemented as classes: Given , when , then [...]|$|E
2500|$|Selenium Remote Control (RC) is a server, {{written in}} Java, that accepts {{commands}} for the browser via HTTP. RC {{makes it possible}} to write automated tests for a web application in any programming language, which allows for better integration of Selenium in existing <b>unit</b> <b>test</b> frameworks. To make writing tests easier, Selenium project currently provides client drivers for PHP, Python, Ruby, [...]NET, Perl and Java. The Java driver can also be used with JavaScript (via the Rhino engine). An instance of selenium RC server is needed to launch html test case - which means that the port should be different for each parallel run. However, for Java/PHP test case only one Selenium RC instance needs to be running continuously.|$|E
50|$|<b>Unit</b> <b>testing</b> is the {{cornerstone}} of extreme programming, which relies on an automated <b>unit</b> <b>testing</b> framework. This automated <b>unit</b> <b>testing</b> framework can be either third party, e.g., xUnit, or created within the development group.|$|R
5000|$|<b>Unit</b> <b>testing</b> is {{provided}} {{as an integral}} part of Laravel, which itself contains <b>unit</b> <b>tests</b> that detect and prevent regressions in the framework. <b>Unit</b> <b>tests</b> can be run through the provided [...] command-line utility.|$|R
50|$|The PHP <b>Unit</b> <b>Testing</b> Framework {{is one of}} the xUnit {{family of}} <b>unit</b> <b>testing</b> frameworks. A variety of assertions are available.|$|R
50|$|Test {{methods are}} {{declared}} as such by decorating a <b>unit</b> <b>test</b> method with the TestMethod attribute. The attribute {{is used to}} identify methods that contain <b>unit</b> <b>test</b> code. Best practices state that <b>unit</b> <b>test</b> methods should contain only <b>unit</b> <b>test</b> code.|$|E
5000|$|Recurring Bug Pattern - Expose a bug via a <b>unit</b> <b>test.</b> Run that <b>unit</b> <b>test</b> {{as part of}} a {{standard}} build from that moment on. This ensure that the bug will not recur.|$|E
50|$|The <b>unit</b> <b>test</b> {{design is}} {{developed}} in this stage.|$|E
40|$|<b>Unit</b> <b>tests</b> are popular, {{but it is}} an art {{to write}} {{them in a way that}} {{specifies}} a program’s behavior well and it is laborious to write enough of them to have confidence in the correctness of an implementation. Symbolic execution is an approach that can help. We describe techniques for <b>unit</b> <b>testing</b> based on symbolic execution. These techniques can be used to increase code coverage by finding relevant variations of existing <b>unit</b> <b>tests,</b> and they can be used to generate <b>unit</b> <b>tests</b> from an implementation automatically when no prior <b>unit</b> <b>tests</b> exist. The adoption of symbolic analysis techniques in commercial testing tools has already begun. ...|$|R
40|$|Research Questions: What are the {{relationships}} between <b>unit</b> <b>tests</b> and between <b>unit</b> <b>tests</b> and methods under test? What can be gained by making this relationships explicit? How does the concept of method examples compare with other possible techniques to relate this entities? Significant problems and current solutions: (1.) Missing explicit relationships between <b>unit</b> <b>tests</b> and methods under test {{make it difficult to}} trace which features are thoroughly tested and hinder navigability between <b>unit</b> <b>tests</b> and their methods under test. xUnit uses a naming convention which is brittle when it comes to renaming the methods and classes under test. (2.) Schuh et al. [1] introduce the concept of ObjectMother to compose complex test scenarios. (3.) Failing <b>unit</b> <b>tests</b> are presented randomly and not in a meaningful order. [2] Definition: A method example tests a single method and returns the resulting receiver, parameters and potential return value of its method under test. Approach: Show which kind of relations between <b>unit</b> <b>tests</b> and between <b>unit</b> <b>tests</b> and method under tests exist. Correlate the <b>unit</b> <b>tests</b> of the base system of Squeak by decomposing them into method examples. Show, that the single concept of method examples enables navigation and traceability between <b>unit</b> <b>tests</b> and methods under test, provides concrete types for the methods under test, fits well together with traits [3]...|$|R
40|$|This paper {{presents}} a dependency injection based, <b>unit</b> <b>testing</b> methodology for <b>unit</b> <b>testing</b> components, or actors, involved in discrete event based computer network simulation via an xUnit testing framework. The fundamental purpose of discrete event based computer network simulation is verification of networking protocols used in physical–not simulated–networks. Thus, use of rigorous <b>unit</b> <b>testing</b> and test driven development methodologies mitigates risk of modeling the wrong system. We validate the methodology through {{the design and}} implementation of OPNET-Unit, an xUnit style <b>unit</b> <b>testing</b> application for an actor oriented discrete event based network simulation environment, OPNET Modeler...|$|R
5000|$|Specify a {{profiling}} {{tool for the}} development/component <b>unit</b> <b>test</b> environment ...|$|E
5000|$|In a <b>unit</b> <b>test,</b> mock objects can {{simulate}} {{the behavior of}} complex, real objects and are therefore useful when a real object is impractical or impossible to incorporate into a <b>unit</b> <b>test.</b> If an object has {{any of the following}} characteristics, it may be useful to use a mock object in its place: ...|$|E
5000|$|Winter Vacation (After 2nd <b>Unit</b> <b>Test)</b> - In December - January ...|$|E
40|$|<b>Unit</b> <b>tests</b> are a {{vital part}} of several {{software}} development practices and processes such as Test-First Programming, Extreme Programming and Test-Driven Development. This article shortly presents the software quality and testing concepts as well as an introduction to an automated <b>unit</b> <b>testing</b> framework for PHP web based applicationssoftware quality, continuous integration, <b>unit</b> <b>testing...</b>|$|R
50|$|<b>Unit</b> <b>testing</b> is also {{critical}} {{to the concept of}} Emergent Design. As emergent design is heavily dependent upon refactoring, <b>unit</b> <b>tests</b> are an integral component.|$|R
5000|$|<b>Unit</b> <b>testing</b> and {{integration}} testing. One {{study found that}} the average defect detection rates of <b>unit</b> <b>testing</b> {{and integration}} testing are 30% and 35% respectively.|$|R
50|$|API Sanity Checker is an {{automatic}} <b>unit</b> <b>test</b> generator for C/C++ shared libraries.|$|E
50|$|See the <b>unit</b> <b>test</b> {{cases in}} the example C++ {{implementation}} below for more examples.|$|E
50|$|These {{individual}} objectives may {{be fulfilled}} by <b>unit</b> <b>test</b> framework tools, stubs or drivers.|$|E
40|$|Abstract. In {{software}} engineering, {{the notion}} of <b>unit</b> <b>testing</b> was successfully introduced and applied. <b>Unit</b> <b>tests</b> are easy manageable tests for small parts of a program – single units. They proved especially useful to capture unwanted changes and side effects during {{the maintenance of a}} program, and they grow with the evolution of the program. Ontologies behave quite differently than program units. As there is no information hiding in ontology engineering, and thus no black box components, at first the idea of <b>unit</b> <b>testing</b> for ontologies seems not applicable. In this paper we motivate the need for <b>unit</b> <b>testing,</b> describe the adaptation to the <b>unit</b> <b>testing</b> approach, and give use cases and examples. ...|$|R
5000|$|Some {{programming}} languages directly support <b>unit</b> <b>testing.</b> Their grammar {{allows the}} direct declaration of <b>unit</b> <b>tests</b> without importing a library (whether third party or standard). Additionally, the boolean {{conditions of the}} <b>unit</b> <b>tests</b> can be expressed in the same syntax as boolean expressions used in non-unit test code, such as {{what is used for}} [...] and [...] statements.|$|R
50|$|PHP <b>Unit</b> <b>Testing</b> Framework is a <b>unit</b> <b>testing</b> {{framework}} that enables developers to discover bugs {{and in turn}} drive down {{the costs associated with}} developing PHP software.|$|R
50|$|When {{software}} is developed using a test-driven approach, {{the combination of}} writing the <b>unit</b> <b>test</b> to specify the interface plus the refactoring activities performed after the test is passing, may {{take the place of}} formal design. Each <b>unit</b> <b>test</b> {{can be seen as a}} design element specifying classes, methods, and observable behaviour. The following Java example will help illustrate this point.|$|E
5000|$|Test in the small: a {{test that}} checks a single {{function}} or class (<b>Unit</b> <b>test)</b> ...|$|E
5000|$|Specify an {{automated}} tool for driving server-side unit (components) for the development/component <b>unit</b> <b>test</b> environment ...|$|E
40|$|This thesis {{explains}} what <b>unit</b> <b>testing</b> is and why <b>unit</b> <b>testing</b> for ontologies is a helpful process for an ontological engineer {{in order to}} verify an ontology. In {{the course of that}} we clarify what an ontology is and present some common methodologies for ontological engineering. In a first step we define exactly in which state of the development process <b>unit</b> <b>testing</b> can be helpful. <b>Unit</b> <b>testing</b> is highly dependent on the used logical language, which is underlying the used ontology language. Therefore, in a second step, we examine some logical languages and detail those cases where the use of <b>unit</b> <b>testing</b> makes sense in order to avoid engineering mistakes. The theoretical results of this thesis are used to implement a <b>unit</b> <b>testing</b> prototype for WSML-Flight and WSML-Rule ontologies, based on Eclipse. Acknowledgements First, I thank my advisor Holger Lausen. He tought me how to write a thesis and guided me into the right direction. Furthermore, I would like to than...|$|R
40|$|Developers use <b>unit</b> <b>testing</b> {{to improve}} the quality of {{software}} systems. Current development tools for <b>unit</b> <b>testing</b> help with automating test execution, with reporting results, and with generating test stubs. However, they offer no aid for designing tests aimed specifically at exercising the effects of changes to a program. This paper describes a <b>unit</b> <b>testing</b> tool that makes writing <b>unit</b> <b>tests</b> Easier and more efficient by introducing an open source <b>unit</b> <b>testing</b> tool for the. NET Framework. <b>Unit</b> <b>testing</b> is tightly associated with test-driven development (TDD), refactoring, and other practices from agile software development approaches such as Extreme Programming or Scrum [19, 20]. The tool provides developers with the Standard <b>unit</b> <b>testing</b> features such as test, fixture, setup, teardown, ignores, expected exception, etc. The tool has an easy graphical user interface to facilitate to the user the testing process. The tool also has a lot of advanced features like the Recipes which make the user able to combine several test assemblies into one test suite plus the Search capabilities across tests, output, and statistics and also generates Statistics per test to create performance base line and grouping tests by categories for execution and works with any. Net language...|$|R
50|$|The book {{illustrates}} {{the use of}} <b>unit</b> <b>testing</b> {{as part of the}} methodology, including examples in Java and Python. One section includes using test-driven development to develop a <b>unit</b> <b>testing</b> framework.|$|R
