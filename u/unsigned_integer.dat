112|133|Public
25|$|Java lacks native <b>unsigned</b> <b>integer</b> types. Unsigned {{data are}} often {{generated}} from programs written in C {{and the lack}} of these types prevents direct data interchange between C and Java. Unsigned large numbers are also used in many numeric processing fields, including cryptography, which can make Java less convenient to use for these tasks.|$|E
25|$|QuickTime 7.5.5 {{and earlier}} {{are known to}} have a list of {{significant}} vulnerabilities that allow a remote attacker to execute arbitrary code or cause a denial of service (out-of-bounds memory access and application crash) on a targeted system. The list includes six types of buffer overflow, data conversion, signed vs <b>unsigned</b> <b>integer</b> mismatch, and uninitialized memory pointer.|$|E
25|$|MIPS I has {{instructions}} for signed and <b>unsigned</b> <b>integer</b> multiplication and division. These instructions source their operands from two GPRs and write their results {{to a pair}} of 32-bit registers called HI and LO, since they may execute separately from (and concurrently with) the other CPU instructions. For multiplication, the high- and low-order halves of the 64-bit product is written to HI and LO (respectively). For division, the quotient is written to LO and the remainder to HI. To access the results, a pair of instructions (Move from HI and Move from LO) is provided to copy the contents of HI or LO to a GPR. These instructions are interlocked: reads of HI and LO do not proceed past an unfinished arithmetic instruction that will write to HI and LO. Another pair of instructions (Move to HI or Move to LO) copies the contents of a GPR to HI and LO. These instructions are used to restore HI and LO to their original state after exception handling. Instructions that read HI or LO must be separated by two instructions that do not write to HI or LO.|$|E
5000|$|All variables, {{except for}} byte_of_data, are 64-bit <b>unsigned</b> <b>integers.</b>|$|R
5000|$|MVA, multi-value {{attributes}} (variable-length {{lists of}} 32-bit <b>unsigned</b> <b>integers).</b>|$|R
5000|$|Word: Bitwise {{operations}} on <b>unsigned</b> <b>integers</b> (or machine words). Normally implemented {{directly by the}} compiler ...|$|R
2500|$|Most {{computer}} systems represent negative integers using two's complement. In such systems, −1 is represented using a bit pattern of all ones. For example, an 8-bit signed integer using two's complement would represent −1 as the bitstring [...] "11111111", or [...] "FF" [...] in hexadecimal (base 16). If {{interpreted as an}} <b>unsigned</b> <b>integer,</b> the same bitstring of n ones represents 2n−1, the largest possible value that n bits can hold. For example, the 8-bit string [...] "11111111" [...] above represents 28−1=255.|$|E
5000|$|... uint - The uint (<b>Unsigned</b> <b>Integer)</b> {{data type}} is a 32-bit <b>unsigned</b> <b>integer</b> between 0 and 4,294,967,295.|$|E
5000|$|Support for <b>unsigned</b> <b>integer</b> {{data types}} {{commonly}} used in other languages ...|$|E
25|$|Any {{computer}} programming language or software package {{that is used}} to compute D mod 97 directly must have the ability to handle integers of more than 30 digits. In practice, this can only be done by software that either supports arbitrary-precision arithmetic or that can handle 220 bit (<b>unsigned)</b> <b>integers,</b> is equal to 1.7 × 1066, from which it can be inferred that 220 bit <b>unsigned</b> <b>integers</b> can accommodate all <b>unsigned</b> <b>integers</b> of 66 digits. features that are often not standard. If the application software in use does not provide the ability to handle integers of this size, the modulo operation can be performed in a piece-wise manner (as is the case with the UN CEFACT TBG5 Javascript program).|$|R
5000|$|Logical shift: a logic zero is {{shifted into}} the operand. This {{is used to}} shift <b>unsigned</b> <b>integers.</b>|$|R
50|$|Variations of {{this method}} replace XOR with any other group operation, such as {{addition}} on 32-bit <b>unsigned</b> <b>integers.</b>|$|R
5000|$|... bslbf: bit string, left bit first uimsbf: <b>unsigned</b> <b>integer,</b> most {{significant}} bit first ...|$|E
5000|$|Used {{to store}} the left half of the 128-bit result of <b>unsigned</b> <b>integer</b> multiplication.|$|E
5000|$|The number 4,294,967,295, {{equivalent}} to the hexadecimal value FFFF,FFFF, is the maximum value for a 32-bit <b>unsigned</b> <b>integer</b> in computing. It is therefore the maximum value for a variable declared as an <b>unsigned</b> <b>integer</b> ( [...] , [...] , or [...] ) in many programming languages running on modern computers. The presence of the value may reflect an error, overflow condition, or missing value.|$|E
5|$|September 22, 2009: The {{identifier}} {{exceeded the}} limit for 32-bit <b>unsigned</b> <b>integers</b> (4,294,967,296 total messages) again breaking some third-party clients.|$|R
50|$|Protocol Buffers use {{the same}} {{encoding}} for <b>unsigned</b> <b>integers,</b> but encode signed integers by prepending the sign as the least significant bit.|$|R
5000|$|The {{register}} {{width of}} a processor determines the range of values that can be represented. Typical binary register widths for <b>unsigned</b> <b>integers</b> include: ...|$|R
5000|$|... an <b>unsigned</b> <b>integer</b> type {{which is}} the type of the result of the [...] operator.|$|E
5000|$|For a given UQm.n format, {{using an}} m+n bit <b>unsigned</b> <b>integer</b> {{container}} with n fractional bits: ...|$|E
5000|$|The next 4 bytes is an 32-bit <b>unsigned</b> <b>integer</b> for the {{geometry}} type, as described below: ...|$|E
50|$|The {{relation}} between numbers and bit patterns is chosen for convenience in computer manipulation; eight bytes stored in computer memory {{may represent a}} 64-bit real, two 32-bit reals, or four signed or <b>unsigned</b> <b>integers,</b> or {{some other kind of}} data that fits into eight bytes. The only difference is how the computer interprets them. If the computer stored four <b>unsigned</b> <b>integers</b> and then read them back from memory as a 64-bit real, it almost always would be a perfectly valid real number, though it would be junk data.|$|R
50|$|Windows uses 32-bit <b>unsigned</b> <b>integers</b> as exit codes, {{although}} the command interpreter treats them as signed. If a process fails initialization, a Windows system error code may be returned.|$|R
25|$|Below {{are three}} {{reasonably}} fast C functions, two for performing modular multiplication {{and one for}} modular exponentiation on <b>unsigned</b> <b>integers</b> not larger than 63 bits, without overflow of the transient operations.|$|R
50|$|Generates a new VBO {{and returns}} its ID number as an <b>unsigned</b> <b>integer.</b> Id 0 is reserved.|$|E
5000|$|The size of {{the largest}} <b>unsigned</b> <b>integer</b> or address in {{computers}} with 24-bit registers or data buses.|$|E
5000|$|... 4294967295 - Maximum 32-bit <b>unsigned</b> <b>integer</b> (FFFFFFFF16), perfect totient number, {{product of}} the five prime Fermat numbers..|$|E
50|$|The {{following}} algorithm, {{the binary}} {{version of the}} famous long division, will divide N by D, placing the quotient in Q and the remainder in R. All values are treated as <b>unsigned</b> <b>integers.</b>|$|R
5000|$|The {{range of}} <b>unsigned</b> <b>integers</b> {{that can be}} {{represented}} in 24 bits is 0 to 16,777,215 ( [...] in hexadecimal). The range of signed integers that can be represented in 24 bits is −8,388,608 to 8,388,607.|$|R
50|$|Java {{does not}} support C/C++ style pointer arithmetic, where object {{addresses}} and <b>unsigned</b> <b>integers</b> (usually long integers) can be used interchangeably. This allows the garbage collector to relocate referenced objects and ensures type safety and security.|$|R
5000|$|... index: an <b>unsigned</b> <b>integer</b> that {{identifies}} a data value {{from the others}} that may exist for this handle.|$|E
5000|$|... (C99) - maximum {{possible}} {{value of}} <b>unsigned</b> <b>integer</b> types: unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long ...|$|E
50|$|A {{means of}} {{comparing}} two sequence numbers i1 and i2 (the <b>unsigned</b> <b>integer</b> representations of sequence numbers s1 and s2) is presented.|$|E
5000|$|Supported datatypes: 8, 16, 32, and 64 bit signed or <b>unsigned</b> <b>integers,</b> float, double, decimal (BCD), {{fixed or}} variable-length {{character}} or wide character, binary or character large objects (blobs), date, time, timestamp, guid/uuid, and db_addr (database address—aka, rowid).|$|R
50|$|Perl {{has three}} typedefs that handle Perl's three main data types: Scalar Value (SV), Array Value (AV), Hash Value (HV). Perl uses a special typedef {{for the simple}} signed <b>integer</b> type (IV), <b>unsigned</b> <b>integers</b> (UV), {{floating}} point numbers (NV) and strings (PV).|$|R
50|$|Extended range {{specifications}} give {{rules for}} scalars that lie outside {{the range of}} -maxint..maxint. It is implementation-specific as to just how large a number is possible, but Pascaline defines a series of standard types that exploit the extended ranges, including linteger for double-range <b>integers,</b> cardinal for <b>unsigned</b> <b>integers,</b> and lcardinal for <b>unsigned</b> double range <b>integers.</b> Pascaline also defines new limits for these types, as maxlint, maxcrd, and maxlcrd.|$|R
