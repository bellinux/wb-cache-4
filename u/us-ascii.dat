57|0|Public
25|$|The first 128 {{characters}} (<b>US-ASCII)</b> {{need one}} byte. The next 1,920 characters need two bytes to encode, which covers {{the remainder of}} almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters {{in the rest of}} the Basic Multilingual Plane, which contains virtually all characters in common use including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).|$|E
25|$|Whenever possible, Gutenberg {{releases}} {{are available}} in plain text, mainly using <b>US-ASCII</b> character encoding but frequently extended to ISO-8859-1 (needed to represent accented characters in French and Scharfes s in German, for example). Besides being copyright-free, the requirement for a Latin (character set) text version of the release has been a criterion of Michael Hart's since the founding of Project Gutenberg, as he believes this is the format {{most likely to be}} readable in the extended future. Out of necessity, this criterion has had to be extended further for the sizable collection of texts in East Asian languages such as Chinese and Japanese now in the collection, where UTF-8 is used instead.|$|E
5000|$|They {{may include}} non-ASCII {{characters}} outside the 0-127 <b>US-ASCII</b> range.|$|E
5000|$|According to , the {{original}} [...] definition of SMTP limits Internet Mail tolines (1000 characters or less) of 7-bit <b>US-ASCII</b> characters.|$|E
50|$|XML is, by default, encoded as UTF-8, and all XML {{processors}} must {{at least}} support UTF-8 (including <b>US-ASCII</b> by definition) and UTF-16.|$|E
50|$|For {{the first}} few decades of email {{networks}} (1971 to the early 1990s),most email messages were plain text in the 7-bit <b>US-ASCII</b> character set.|$|E
5000|$|U+0020-U+007E: {{these are}} all the {{non-control}} characters in the Basic Latin block (the [...] "graphic" [...] subset of <b>US-ASCII),</b> and excludes the last C0 control; ...|$|E
50|$|Later {{the format}} of email {{messages}} was re-definedin order to supportmessages that are not entirely <b>US-ASCII</b> text(text messages in character setsother than US-ASCII,and non-text messages,such as audio and images).|$|E
50|$|As {{with all}} {{encodings}} apart from <b>US-ASCII,</b> when using Unicode text in email, MIME {{must be used}} to specify that a Unicode transformation format is being used for the text.|$|E
5000|$|In other {{languages}} {{that do not}} have the letter as part of the regular alphabet or in limited character sets such as <b>US-ASCII,</b> Ä is frequently replaced with the two-letter combination [...] "Ae".|$|E
50|$|If the User Configured Passphrase/Key is used, {{the user}} needs to type/remember only one {{sequence}} of <b>US-ASCII</b> characters (between 8 and 63) and the ALME will derive different security passwords {{for the different}} technologies through SHA-256 function.|$|E
5000|$|ASCII is the {{traditional}} name for the encoding system; the Internet Assigned Numbers Authority (IANA) prefers the updated name <b>US-ASCII,</b> which clarifies that this system {{was developed in the}} US and based on the typographical symbols predominantly in use there.) ...|$|E
50|$|The <b>US-ASCII</b> {{character}} set and other variants of ISO/IEC 646 contains 95 graphic characters. It is comparable with a (Latin script) typewriter and insufficient for a quality typography. But high availability and robustness of ASCII character encoding prompted computer users to invent ASCII substitutes for various glyphs.|$|E
5000|$|Simplified example: 90 <b>US-ASCII</b> {{characters}} {{could be}} arranged into nine non-overlapping sets of 10 characters. Thus unambiguous strings of nine characters could set {{the color of}} each pixel by its XPM palette index with up to 109 = [...] colors (compare to GIF, which supports only 256).|$|E
5000|$|... quoted-printable - used {{to encode}} {{arbitrary}} octet sequences {{into a form}} that satisfies the rules of 7bit. Designed to be efficient and mostly human readable when used for text data consisting primarily of <b>US-ASCII</b> characters but also containing {{a small proportion of}} bytes with values outside that range.|$|E
50|$|Applications using UTF-8 as a default {{encoding}} may {{achieve a}} greater degree of interoperability because of its widespread use and backward compatibility with <b>US-ASCII.</b> UTF-8 also has the ability to be directly recognised by a simple algorithm, so that well written software should be able to avoid mixing UTF-8 up with other encodings.|$|E
5000|$|EUC-TW is a variable-width {{encoding}} {{that supports}} <b>US-ASCII</b> and 16 planes of CNS 11643, {{each of which}} is 94x94. It is a rarely used encoding for traditional Chinese characters as used in Taiwan. Big5 is much more common. A character in <b>US-ASCII</b> (G0, code set 0) is encoded as a single byte in GL( [...] 0x21-0x7E) and a character in CNS 11643 plane 1 (code set 1) is encoded as two bytes in GR (0xA1-0xFE). A character in plane 1 through 16 of CNS 11643 (code set 2) is encoded as four bytes with the first byte always being 0x8E(Single Shift 2) and the second byte indicating the plane (the plane number is obtained by subtracting 0xA0 from the second byte). The third and fourth bytes are in GR (0xA1-0xFE). Note that the plane 1 of CNS 11643 is encoded twice as code set 1 and a part of code set 2. UTF-8 is becoming more common than EUC-TW, as with most code pages.|$|E
5000|$|KOI-7 N0 (КОИ-7 Н0) is {{identical}} to the IRV set in ISO 646:1983. Compared to <b>US-ASCII,</b> the dollar sign ("$") at codepoint 24hex) was replaced by the universal currency sign [...] "¤", but this wasn't maintained in all cases, in particular not {{after the fall of the}} Iron Curtain. Likewise, the IRV set in ISO/IEC 646:1991 also changed the character back to a dollar sign.|$|E
50|$|In RFC 1557, {{a method}} known as ISO-2022-KR for a 7-bit {{encoding}} of Korean characters in email was described. Where 8 bits are allowed, the EUC-KR encoding is preferred. These two encodings combine <b>US-ASCII</b> (ISO 646) with the Korean standard KS X 1001:1992 (previously named KS C 5601:1987). In North Korea, a separate character set called KPS 9566 is in use, which is rather similar to KS X 1001.|$|E
50|$|The ISO-2022 {{definitions}} of the ISO-8859-X character sets are specific fixed combinations of the components that form ISO-2022. Specifically the lower control characters (C0) the <b>US-ASCII</b> character set (in GL) and the upper control characters (C1) are standard and the high characters (GR) are defined {{for each of the}} ISO-8859-X variants; for example ISO-8859-1 is defined by the combination of ISO-IR-1, ISO-IR-6, ISO-IR-77 and ISO-IR-100 with no shifts or character changes allowed.|$|E
50|$|The W3C Internationalisation Activity assures that web {{technology}} {{works in}} all languages, scripts, and cultures. Beginning in 2004 or 2005, Unicode gained ground and eventually in December 2007 surpassed both ASCII and Western European as the Web's {{most frequently used}} character encoding. Originally RFC 3986 allowed resources to be identified by URI in a subset of <b>US-ASCII.</b> RFC 3987 allows more characters—any character in the Universal Character Set—and now a resource can be identified by IRI in any language.|$|E
5000|$|DKIM {{currently}} features two canonicalization algorithms, {{simple and}} relaxed, {{neither of which}} is MIME-aware. [...] Mail servers can legitimately convert to a different character set, and often document this with X-MIME-Autoconverted header fields. In addition, servers in certain circumstances have to rewrite the MIME structure, thereby altering the preamble, the epilogue, and entity boundaries, any of which breaks DKIM signatures. Only plain text messages written in <b>us-ascii,</b> provided that MIME header fields are not signed, enjoy the robustness that end-to-end integrity requires.|$|E
5000|$|... 30 — type tag {{indicating}} SEQUENCE 13 — {{length in}} octets of value that follows 02 — type tag indicating INTEGER 01 — length in octets of value that follows 05 — value (5) 16 — type tag indicating IA5String [...] (IA5 means the full 7-bit ISO 646 set, including variants, [...] but is generally <b>US-ASCII)</b> 0e — length in octets of value that follows 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — value ("Anybody there?") ...|$|E
5000|$|A {{common use}} of escape {{sequences}} {{is in fact}} to remove control characters found in a binary data stream {{so that they will}} not cause their control function by mistake. In this case, the control character is replaced by a defined [...] "escape character" [...] (which need not be the <b>US-ASCII</b> escape character) and another character; after exiting the context where the control character would have caused an action, the sequence is recognized and replaced by the removed character. To transmit the [...] "escape character" [...] itself, two copies are sent.|$|E
50|$|To {{represent}} multiple character sets, the ISO/IEC 2022 character encodings include escape sequences which {{indicate the}} character set for characters which follow. The escape sequences are registered with ISO {{and follow the}} patterns defined within the standard. These character encodings require data to be processed sequentially in a forward direction since the correct interpretation of the data depends on previously encountered escape sequences. Note, however, that other standards such as ISO-2022-JP may impose extra conditions such as the current character set is reset to <b>US-ASCII</b> {{before the end of}} a line.|$|E
5000|$|Literal text is {{specified}} {{through the}} use of a string enclosed in quotation marks (...) [...] These strings are case-insensitive, and the character set used is (<b>US-)ASCII.</b> Therefore, the string [...] will match “abc”, “Abc”, “aBc”, “abC”, “ABc”, “AbC”, “aBC”, and “ABC”. RFC 7405 added a syntax for case-sensitive strings: [...] will only match [...] "aBc". Prior to that, a case-sensitive string could only be specified by listing the individual characters: to match “aBc”, the definition would be [...] A string can also be explicitly specified as case-insensitive with a [...] prefix.|$|E
50|$|Email header fields can be multi-line, {{and each}} line {{should be at}} most 78 {{characters}} long and in no event more than 998 characters long. Header fields defined by RFC 5322 can only contain <b>US-ASCII</b> characters; for encoding characters in other sets, a syntax specified in RFC 2047 can be used. Recently the IETF EAI working group has defined some standards track extensions, replacing previous experimental extensions, to allow UTF-8 encoded Unicode characters to be used within the header. In particular, this allows email addresses to use non-ASCII characters. Such addresses are supported by Google and Microsoft products, and promoted by some governments.|$|E
50|$|The WHOIS {{protocol}} was not written {{with an international}} audience in mind. A WHOIS server and/or client cannot determine the text encoding in effect for the query or the database content. Many servers were originally using <b>US-ASCII</b> and Internationalization concerns weren't taken into consideration until much later. This might impact the usability or usefulness of the WHOIS protocol in countries outside the USA. In the case of internationalized domain names {{it is the responsibility}} of the client application to perform the translation of the domain name between its native language script and the DNS name in punycode.|$|E
50|$|The first 128 {{characters}} (<b>US-ASCII)</b> {{need one}} byte. The next 1,920 characters need two bytes to encode, which covers {{the remainder of}} almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters {{in the rest of}} the Basic Multilingual Plane, which contains virtually all characters in common use including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).|$|E
5000|$|All {{commands}} {{and response}} are initially {{assumed to be}} in <b>US-ASCII</b> encoding for historical reasons, unless the client explicitly asks for 8-bit (ISO-8859-1) encoding. As a result, only characters between 0x20 and 0x7E are initially sent by the server in raw form. Other characters, if present in entries, will be escaped using the [...] defined [...] "Quoted-Printable" [...] encoding. The initial request from the client is a text base keyword optionally followed {{by one or more}} parameters as defined in the [...] The server then responds to the request. The following example response to a status request is provided by the RFC memo.|$|E
5000|$|C trigraphs {{were created}} {{to solve this problem}} for ANSI C, {{although}} their late introduction and inconsistent implementation in compilers limited their use. Many programmers kept their computers on <b>US-ASCII,</b> so plain-text in Swedish, German etc. (for example, in e-mail or Usenet) contained [...] "{, }" [...] and similar variants in the middle of words, something those programmers got used to. For example, a Swedish programmer mailing another programmer asking if they should go for lunch, could get [...] "N{ jag har sm|rg}sar" [...] as the answer, which should be [...] "Nä jag har smörgåsar" [...] meaning [...] "No I've got sandwiches".|$|E
50|$|MIME, {{the modern}} {{standard}} of E-mail format, forbids encoding of headers using byte values above the ASCII range. Although MIME allows encoding the message body in various character sets (broader than ASCII), the underlying transmission infrastructure (SMTP, the main E-mail transfer standard) {{is still not}} guaranteed to be 8-bit clean. Therefore, a non-trivial content transfer encoding has to be applied in case of doubt. Unfortunately base64 has a disadvantage of making even <b>US-ASCII</b> characters unreadable in non-MIME clients. On the other hand, UTF-8 combined with quoted-printable produces a very size-inefficient format requiring 6 - 9 bytes for non-ASCII characters from the BMP and 12 bytes for characters outside the BMP.|$|E
50|$|Whenever possible, Gutenberg {{releases}} {{are available}} in plain text, mainly using <b>US-ASCII</b> character encoding but frequently extended to ISO-8859-1 (needed to represent accented characters in French and Scharfes s in German, for example). Besides being copyright-free, the requirement for a Latin (character set) text version of the release has been a criterion of Michael Hart's since the founding of Project Gutenberg, as he believes this is the format {{most likely to be}} readable in the extended future. Out of necessity, this criterion has had to be extended further for the sizable collection of texts in East Asian languages such as Chinese and Japanese now in the collection, where UTF-8 is used instead.|$|E
50|$|The {{structure}} of EUC {{is based on}} the ISO-2022 standard, which specifies a way to represent character sets containing a maximum of 94 characters, or 8836 (942) characters, or 830584 (943) characters, as sequences of 7-bit codes. Only ISO-2022 compliant character sets can have EUC forms. Up to four coded character sets (referred to as G0, G1, G2, and G3 or as code sets 0, 1, 2, and 3) can be represented with the EUC scheme. G0 is almost always an ISO-646 compliant coded character set (e.g. US-ASCII/KS X 1003/ISO 646:KR in EUC-KR and US-ASCII/the lower half of JIS X 0201 in EUC-JP) that is invoked on GL (i.e. with the most significant bit cleared). An exception from <b>US-ASCII</b> is that 0x5C (backslash) is a Yen sign i EUC-JP and a Won sign i EUC-KR.|$|E
5000|$|Standard <b>US-ASCII,</b> 0x20-0x7F, is {{included}} in the Spectrum character set except that code point 0x5E is an up-arrow (↑) instead of a caret (^), 0x60 is the pound sign (£) instead of the grave accent (`), and 0x7F is the copyright sign (©) instead of the control character [...] Note that the use of 0x5E as ↑ was also the case in the older 1963 version of ASCII. The £ sign was not mapped to 0x23 as in the British variant of ASCII (ISO-646-GB), allowing both the pound sign and the number sign (#) simultaneously. The ↑ character is the exponentiation operator in Spectrum's BASIC, just like the ^ it replaces compared to ASCII-1967 is used for exponentiation in many other dialects of BASIC and other programming languages.|$|E
50|$|IBM {{introduced}} eight-bit extended ASCII codes on {{the original}} IBM PC and later produced variations for different languages and cultures. IBM called such character sets code pages and assigned numbers to both those they themselves invented {{as well as many}} invented and used by other manufacturers. Accordingly, character sets are very often indicated by their IBM code page number. In ASCII-compatible code pages, the lower 128 characters maintained their standard <b>US-ASCII</b> values, and different pages (or sets of characters) could be made available in the upper 128 characters. DOS computers built for the North American market, for example, used code page 437, which included accented characters needed for French, German, and a few other European languages, as well as some graphical line-drawing characters. The larger character set made it possible to create documents in a combination of languages such as English and French (though French computers usually use code page 850), but not, for example, in English and Greek (which required code page 737).|$|E
