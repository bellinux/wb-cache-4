323|3232|Public
25|$|Client/server {{networking}} {{allows a}} program on a computer, called a client, to connect via a network to another computer, called a server. Servers offer (or host) various services to other network computers and users. These services are usually provided through ports or numbered access points beyond the server's IP address. Each port number is usually associated with a maximum of one running program, {{which is responsible for}} handling requests to that port. A daemon, being a <b>user</b> <b>program,</b> can in turn access the local hardware resources of that computer by passing requests to the operating system kernel.|$|E
25|$|Special gates between {{rings are}} {{provided}} to allow an outer ring to access an inner ring's resources in a predefined manner, {{as opposed to}} allowing arbitrary usage. Correctly gating access between rings can improve security by preventing programs from one ring or privilege level from misusing resources intended for programs in another. For example, spyware running as a <b>user</b> <b>program</b> in Ring 3 should be prevented from turning on a web camera without informing the user, since hardware access should be a Ring 1 function reserved for device drivers. Programs such as web browsers running in higher numbered rings must request access to the network, a resource restricted to a lower numbered ring.|$|E
2500|$|... : The Pulsed Field Facility at Los Alamos National Laboratory in Los Alamos, New Mexico, is one {{of three}} campuses of the National High Magnetic Field Laboratory (NHMFL), the other two being at Florida State University, Tallahassee and the University of Florida. The Pulsed Field Facility at Los Alamos National Laboratory {{operates}} an international <b>user</b> <b>program</b> for research in high magnetic fields.|$|E
50|$|During execution, <b>user</b> <b>{{programs}}</b> are swapped to fixed-head drum memory. When not executing, <b>user</b> <b>programs</b> {{are stored}} on moving-head cartridge- or pack-loaded disk storage. Privileged users can also store {{programs on the}} much-faster drum. The hard drive was backed up to magnetic tape.|$|R
40|$|Abstract. Traditional {{operating}} systems {{protect themselves from}} <b>user</b> <b>programs</b> with a privilege level facility of CPUs. One problem of the protection-by-hardware approach is that system calls become very slow because heavy operations are required to safely switch the privilege levels of <b>user</b> <b>programs.</b> To solve the problem, we design an operating system that protects itself with a type theory. In our approach, <b>user</b> <b>programs</b> are written in a typed assembly language and the kernel performs typechecking before executing the <b>programs.</b> Then, the <b>user</b> <b>programs</b> can be executed in the kernel mode, because the kernel knows that the typechecked programs do not violate safety of the kernel. Thus, system calls become mere function calls and can be invoked very quickly. We implemented Kernel Mode Linux (KML) that realizes our approach. Several benchmarks show effectiveness of KML. ...|$|R
40|$|The paper {{discusses}} some {{trends in}} end <b>user</b> <b>programming</b> (EUP) and takes {{inspiration from the}} discussions in a panel and in a vertical session on research evaluation within the second Search Computing workshop. We discuss the controversial successes and failures in this field and we elaborate on which facilities could foster adoption of end <b>user</b> <b>programming.</b> We discuss various dimensions of end <b>user</b> <b>programming,</b> including vertical versus horizontal language definition, declarative versus imperative approaches. We exemplify our discussion in the realistic scenario of research evaluation by comparing the Search Computing and ResEval approaches. © 2011 Springer-Verlag...|$|R
50|$|LANSCE's <b>User</b> <b>Program</b> {{ensures the}} {{research}} it oversees represents {{the cutting edge}} of nuclear and materials science and technology. The <b>User</b> <b>Program</b> {{plays a key role in}} training the next generation of top scientists, attracting the best graduate students, postdoctoral researchers, and early-career scientists (defined as those less than 40 years old).|$|E
5000|$|A {{system call}} from a <b>user</b> <b>program</b> leads to a switch to kernel mode.|$|E
5000|$|MIMCO (compiler) - compiles the <b>user</b> <b>program</b> {{and creates}} an in-core array of instructions, ...|$|E
5000|$|The {{interfaces}} used by <b>user</b> <b>programs</b> are {{the cleanest}} of all. <b>User</b> <b>programs</b> may never refer directly to any system control block (neither for reference nor change), because the virtual memory segment(s) that contain system control blocks (the system segments) {{are removed from}} a job's virtual address space when a <b>user</b> mode <b>program</b> is running. The subroutine interfaces available to <b>user</b> <b>programs</b> are also used by most {{other parts of the}} system (system mode programs, CLSs, ...) even through components running in system mode do have access to the [...] "system" [...] virtual memory segment(s). Transitions from user mode to system mode and back are managed by a special protected set of subroutine interfaces known as [...] "the gate" [...] (initially developed at Wayne State University).|$|R
5000|$|... 1K byte of RAM, {{used both}} for display memory and <b>user</b> <b>programs</b> ...|$|R
40|$|Memory Management Units (MMUs) are {{traditionally}} used by operating systems to implement disk-paged virtual memory. Some operating systems allow <b>user</b> <b>programs</b> {{to specify the}} protection level (inaccessible, readonly. read-write) of pages, and allow <b>user</b> <b>programs</b> t. o handle protection violations. bur. these mechanisms are not. always robust, efficient, or well-mat. ched {{to the needs of}} applications...|$|R
50|$|While two of {{the cars}} gave rides to {{visitors}} at the New York World's Fair and another went on a worldwide tour, 50 of them were lent {{to the general public}} as part of a <b>user</b> <b>program.</b> Chrysler found that the distinctive sound of the Turbine Car's engine, which was reminiscent of a jet aircraft engine, was positively received by approximately 60% of those involved in the <b>user</b> <b>program</b> but disliked by roughly 20% of their fellow users. The <b>user</b> <b>program</b> also helped identify a variety of problems and shortcomings, including starter malfunction at high altitudes, the difficulty of mastering the car's unusual eight-step starting procedure for some users caused mistakes which occasionally resulted in engine damage, and its relatively unimpressive acceleration. Nonetheless, the turbine engines were remarkably durable in comparison to contemporary internal combustion piston engines. It is not known how many <b>user</b> <b>program</b> participants made the mistake of using leaded gasoline; the tetraethyl lead in it left debilitating deposits within the engine. It was the one fuel Chrysler recommended not be used; it was also by far the easiest one to obtain. Fuels commonly used by the public participating in the <b>user</b> <b>program</b> included diesel and house heating oil. In total, more than 1,000,000 mi were accumulated in testing by the 50 cars given to the public, which were driven by a total of 203 users. Furthermore, operational downtime stood at 4% early in the <b>user</b> <b>program,</b> but was reduced to just 1% {{by the end of the}} program.|$|E
5000|$|Now {{suppose that}} the <b>user</b> <b>program</b> {{successfully}} executes the following statement:int fd = open("/etc/passwd", O_RDWR); ...|$|E
5000|$|<b>User</b> <b>program</b> level {{components}} that are stand-alone programs and read/write data from files or pipes.|$|E
40|$|In IOTA, two {{successive}} {{processes are}} involved {{to obtain a}} drawing as asked from a <b>user's</b> <b>program.</b> The first process is loaded with the <b>user's</b> <b>program</b> and creates a file containing {{the description of the}} drawing. The second process runs independently from the <b>user's</b> <b>program</b> and generates the drawing on the display device it is driving. The general organization of the system is given first, followed by a partial description of the language used to describe the drawing. Some problems raised by the organization are then discussed; finally, a comparison is made between IOTA and other softwares and the amount of experience necessary. © 1978. SCOPUS: ar. jinfo:eu-repo/semantics/publishe...|$|R
50|$|<b>User</b> <b>programs</b> {{written in}} C, C++, or Fortran can access PVM through {{provided}} library routines.|$|R
50|$|Unlike TR-DOS, iS-DOS is a RAM-based {{operating}} system, {{which reduces}} amount of memory for <b>user</b> <b>programs.</b>|$|R
50|$|The {{extended}} memory scheme let existing programs handle increased memory with minimal changes. For example, 4K FOCAL normally had about 3K of code with only 1K {{left over for}} <b>user</b> <b>program</b> and data. With a few patches, FOCAL could use a second 4K field for <b>user</b> <b>program</b> and data. Moreover, additional 4K fields could be allocated to separate users, turning 4K FOCAL into a multi-user timesharing system.|$|E
5000|$|CANCEL (C), {{to cancel}} a spooled report, or a session, or the job queue(***), or a <b>user</b> <b>program.</b>|$|E
5000|$|Jumping to {{the proper}} {{location}} in the <b>user</b> <b>program</b> to restart that program indicated by its new state.|$|E
5000|$|... iS-DOS Chic is {{a version}} {{developed}} for Nemo KAY. It provides more memory for <b>user</b> <b>programs.</b>|$|R
50|$|MINIMOP was {{implemented}} as a multithreaded (sub-programmed in ICL terminology) <b>user</b> level <b>program</b> {{running on the}} standard executive (low level operating system) of the ICL 1900. The program under control facilities of executive were used to run <b>user</b> <b>programs</b> under MINIMOP. All user I/O operations were trapped by MINIMOP and emulated rather than accessing real peripherals. As memory was at a premium <b>user</b> <b>programs</b> would be swapped out of memory whenever they needed to wait (for input or output) or {{when they reached the}} end of their time slice.|$|R
40|$|The {{main purpose}} of an {{operating}} system is to supply the <b>user</b> <b>programs</b> with persistent, simple and enough powerful service interface. However for practical use of the system it is often necessary to know {{the current state of}} the system, how much resources the system is using and which <b>user</b> <b>programs</b> consume the biggest portion of them. In the thesis we discuss the possibilities of the operating system monitoring in common. For HelenOS system (which was missing any monitoring facility) such interface was created. Next to the monitoring services we designed and implemented a simple statistical pro ler. Both the <b>user</b> <b>programs</b> and the whole operating system can be pro led. Two userspace applications were created for this purpose...|$|R
50|$|User {{programs}} {{are restricted to}} use only a contiguous area of main memory. The portion of memory to which an executing program has access {{is controlled by the}} RA (Relative Address) and FL (Field Length) registers which are not accessible to the <b>user</b> <b>program.</b> When a <b>user</b> <b>program</b> tries to read or write a word in central memory at address a, the processor will first verify that a is between 0 and FL-1. If it is, the processor accesses the word in central memory at address RA+a. This process is known as base-bound relocation; each <b>user</b> <b>program</b> sees core memory as a contiguous block words with length FL, starting with address 0; in fact the program may be anywhere in the physical memory. Using this technique, each <b>user</b> <b>program</b> can be moved ("relocated") in main memory by the operating system, as long as the RA register reflects its position in memory. A <b>user</b> <b>program</b> which attempts to access memory outside the allowed range (that is, with an address which is not less than FL) will trigger an interrupt, and will be terminated by the operating system. When this happens, the operating system may create a core dump which records the contents of the program's memory and registers in a file, allowing the developer of the program a means to know what happened. Note the distinction with virtual memory systems; in this case, the entirety of a process's addressable space must be in core memory, must be contiguous, and its size cannot be larger than the real memory capacity.|$|E
50|$|Some file systems accept {{data for}} storage as {{a stream of}} bytes which are {{collected}} and stored in a manner efficient for the media. When a program retrieves the data, it specifies {{the size of a}} memory buffer and the file system transfers data from the media to the buffer. A runtime library routine may sometimes allow the <b>user</b> <b>program</b> to define a record based on a library call specifying a length. When the <b>user</b> <b>program</b> reads the data, the library retrieves data via the file system and returns a record.|$|E
50|$|The TSS {{contains}} 6 {{fields for}} specifying the new stack pointer when a privilege level change happens. The field SS0 contains the stack segment selector for CPL=0, {{and the field}} ESP0/RSP0 contains the new ESP/RSP value for CPL=0. When an interrupt happens in protected (32-bit) mode, the x86 CPU will look in the TSS for SS0 and ESP0 and load their values into SS and ESP respectively. This allows for the kernel to use a different stack than the <b>user</b> <b>program,</b> and also have this stack be unique for each <b>user</b> <b>program.</b>|$|E
50|$|In {{monolithic}} kernels, {{a driver}} {{can write to}} any word of memory and thus accidentally corrupt <b>user</b> <b>programs.</b>|$|R
50|$|There are six {{libraries}} in the ROM, {{which could}} be loaded to RAM and used and edited as <b>user</b> <b>programs.</b>|$|R
5000|$|Vulnerabilities caused purely by {{errors in}} <b>user</b> <b>programs</b> (for example {{improper}} construction of SQL queries leading to SQL injection vulnerabilities) ...|$|R
5000|$|The name [...] "shell" [...] for a {{command-line}} interpreter and {{the concept}} of making the shell a <b>user</b> <b>program</b> outside of the operating system kernel were introduced in Unix's precursor Multics.|$|E
5000|$|Marking {{the start}} of a job was a punched card that started with [...] Any card that started with [...] was a command to the Supervisor and could not be used as <b>user</b> <b>program</b> or data. Other {{commands}} included [...] to execute the Disk Utility Program (to delete files or add the file in the temporary area to the file collection) and [...] to execute a named program from disk. If a <b>user</b> <b>program</b> tried to read a command card, the standard card reader routine would signal end-of-input to the program and save that card's content for the Supervisor.|$|E
5000|$|In computing, the User Programmatic Interface (UPI), {{also known}} as the <b>User</b> <b>Program</b> Interface, {{consists}} of a set of C-language software [...] APIs which provide the lowest-level API-based interface to the Oracle database.|$|E
50|$|A central module {{executed}} the <b>user</b> <b>programs,</b> taking {{input from}} the temporary input files and writing program output to temporary files.|$|R
5000|$|COMPASS CP is the {{assembly}} language for the CP (Central Processor), the processor running <b>user</b> <b>programs.</b> See CDC 6600 CP architecture.|$|R
5000|$|The {{process of}} {{limiting}} {{access to the}} resources of an AIS (Automated Information System) to authorized <b>users,</b> <b>programs,</b> processes, or other systems.|$|R
