36|34|Public
25|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and <b>unconditional</b> <b>branch</b> instructions use the branch instruction format, while the jump instructions use the memory instruction format.|$|E
25|$|TC (transfer control): An <b>unconditional</b> <b>branch</b> to {{the address}} {{specified}} by the instruction. The return address was automatically stored in the Q register, so the TC instruction {{could be used for}} subroutine calls.|$|E
25|$|At {{the level}} of machine {{language}} or assembly language, control flow instructions usually work by altering the program counter. For some central processing units (CPUs), the only control flow instructions available are conditional or <b>unconditional</b> <b>branch</b> instructions, also termed jumps.|$|E
5000|$|...u (--unconditional-branches): When branch probabilities are given, {{include those}} of <b>unconditional</b> <b>branches.</b> <b>Unconditional</b> <b>branches</b> are {{normally}} not interesting.|$|R
2500|$|... <b>unconditional</b> <b>branches</b> (BC) & branch-and-link (BALC) with a 26-bit offset, ...|$|R
5000|$|Conditional and <b>unconditional</b> <b>branches</b> (BRA, Bcc - BEQ, BNE, BHI, BLO, BMI, BPL, etc.) ...|$|R
25|$|Unconditional {{branches}} {{update the}} program counter {{with a new}} address computed {{in the same way}} as conditional branches. They also save the address of the instruction following the <b>unconditional</b> <b>branch</b> to a register. There are two such instructions, and they differ only in the hints provided for the branch prediction hardware.|$|E
25|$|The Monroe Epic {{programmable}} calculator {{came on the}} market in 1967. A large, printing, desk-top unit, with an attached floor-standing logic tower, it could be programmed to perform many computer-like functions. However, the only branch instruction was an implied <b>unconditional</b> <b>branch</b> (GOTO) {{at the end of the}} operation stack, returning the program to its starting instruction. Thus, it was not possible to include any conditional branch (IF-THEN-ELSE) logic. During this era, the absence of the conditional branch was sometimes used to distinguish a {{programmable calculator}} from a computer.|$|E
2500|$|Continuation at a {{different}} statement (<b>unconditional</b> <b>branch</b> or jump) ...|$|E
5000|$|Control hazards {{are caused}} by {{conditional}} and <b>unconditional</b> <b>branching.</b> The classic RISC pipeline resolves branches in the decode stage, which means the branch resolution recurrence is two cycles long. There are three implications: ...|$|R
50|$|The MK-52's {{programming}} commands are typed {{into the}} MK-52 in programming mode and are then executed. The MK-52 is fully {{capable of being}} programmed to manage memory and to use both conditional and <b>unconditional</b> <b>branching.</b>|$|R
5000|$|<b>Unconditional</b> <b>branching</b> {{is assured}} only if [...] {{initially}} contains 0 (or a value {{less than the}} integer stored in [...] ). A follow-up instruction is required to clear [...] after the branching, assuming that the content of [...] must be maintained as 0.|$|R
5000|$|The JMP {{instruction}} performs an <b>unconditional</b> <b>branch</b> to anywhere {{within the}} 8192 word program memory ...|$|E
5000|$|Branching [...] - [...] skip or branch on condition, branch <b>unconditional,</b> <b>branch</b> {{and store}} program counter (conditional and unconditional), add to index {{register}} and skip on test ...|$|E
50|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and <b>unconditional</b> <b>branch</b> instructions use the branch instruction format, while the jump instructions use the memory instruction format.|$|E
5000|$|...b (--branch-probabilities): Write branch {{frequencies}} to {{the output}} file, and write branch summary info {{to the standard}} output. This option allows you to see how often each branch in your program was taken. <b>Unconditional</b> <b>branches</b> will not be shown, unless the -u option is given.|$|R
40|$|Abstract: In {{this paper}} we discuss {{the issue of the}} minimal {{instruction}} set necessary for universal computation. Our computing model is a machine consisting of a processor with a single n-bit register and a separate memory of n-bit words. We show that four simple instructions are su cient in order to evaluate any computable function. Such reduction of the instruction set can only be achieved by exploiting the properties of selfmodifying programs. Then we prove that, surprisingly, conditional branching can be substituted by <b>unconditional</b> <b>branching.</b> This is the main result of this paper. Therefore any computable function can be computed using only the instructions LOAD, STORE, INC and GOTO (<b>unconditional</b> <b>branching).</b> We also show that externally stored looping programs using indirect addressing and no branches are as powerful as conventional computer programs...|$|R
40|$|In {{this paper}} we discuss {{the issue of the}} minimal {{instruction}} set necessary for universal computation. Our computing model is a machine consisting of a processor with a single n-bit register and a separate memory of n-bit words. We show that four simple instructions are sufficient in order to evaluate any computable function. Such reduction of the instruction set can only be achieved by exploiting the properties of selfmodifying programs. Then we prove that, surprisingly, conditional branching can be substituted by <b>unconditional</b> <b>branching.</b> This is the main result of this paper. Therefore any computable function can be computed using only the instructions LOAD, STORE, INC and GOTO (<b>unconditional</b> <b>branching).</b> We also show that externally stored looping programs using indirect addressing and no branches are as powerful as conventional computer programs. Categories: F. 1. 1, Models of Computation, Self-Modifying Machines, C. 1 Processor Architectures. 1 The computing model In theoretical co [...] ...|$|R
5000|$|... (transfer control): An <b>unconditional</b> <b>branch</b> to {{the address}} {{specified}} by the instruction. The return address was automatically stored in the Q register, so the [...] instruction {{could be used for}} subroutine calls.|$|E
5000|$|PIC cores have skip instructions, {{which are}} used for {{conditional}} execution and branching. The skip instructions are [...] "skip if bit set" [...] and [...] "skip if bit not set". Because cores before PIC18 had only <b>unconditional</b> <b>branch</b> instructions, conditional jumps are implemented by a conditional skip (with the opposite condition) followed by an <b>unconditional</b> <b>branch.</b> Skips are also of utility for conditional execution of any immediate single following instruction. It is possible to skip skip instructions. For example, the instruction sequence [...] "skip if A; skip if B; C" [...] will execute C if A is true or if B is false.|$|E
5000|$|In either case, the {{modifications}} may {{be performed}} {{directly to the}} machine code instructions themselves, by overlaying new instructions over the existing ones (for example: altering a compare and branch to an <b>unconditional</b> <b>branch</b> or alternatively a 'NOP').|$|E
50|$|Fewer jumps {{by using}} {{straight}} line code, also called branch-free code: Less complicated code. Jumps (conditional or <b>unconditional</b> <b>branches)</b> {{interfere with the}} prefetching of instructions, thus slowing down code. Using inlining or loop unrolling can reduce branching, {{at the cost of}} increasing binary file size by the length of the repeated code. This tends to merge several basic blocks into one.|$|R
50|$|All processors, {{including}} TTA processors, include {{control flow}} instructions that alter the program counter, {{which are used}} to implement subroutines, if-then-else, for-loop, etc.The assembly language for TTA processors typically includes control flow instructions such as <b>unconditional</b> <b>branches</b> (JUMP), conditional relative branches (BNZ), subroutine call (CALL), conditional return (RETNZ), etc. that look {{the same as the}} corresponding assembly language instructions for other processors.|$|R
50|$|The HP Voyager series {{calculator}} are keystroke programmable, {{meaning that}} it can remember and later execute sequences of keystrokes to solve particular problems {{of interest to the}} user. These keystroke programs, in addition to performing any operation normally available on the keyboard, can also make use of conditional and <b>unconditional</b> <b>branching</b> and looping instructions, allowing programs to perform repetitive operations and make decisions.|$|R
50|$|At {{the level}} of machine {{language}} or assembly language, control flow instructions usually work by altering the program counter. For some central processing units (CPUs), the only control flow instructions available are conditional or <b>unconditional</b> <b>branch</b> instructions, also termed jumps.|$|E
5000|$|In {{computer}} architecture, {{a branch}} target predictor {{is the part}} of a processor that predicts the target of a taken conditional branch or an <b>unconditional</b> <b>branch</b> instruction before the target of the branch instruction is computed by the execution unit of the processor.|$|E
5000|$|Alternative code {{might involve}} testing a [...] "flag" [...] each time through. The <b>unconditional</b> <b>branch</b> is {{slightly}} {{faster than a}} compare instruction, as well as reducing the overall path length. In later operating systems for programs residing in protected storage this technique {{could not be used}} and so changing the pointer to the subroutine would be used instead. The pointer would reside in dynamic storage and could be altered at will after the first pass to bypass the OPEN (having to load a pointer first instead of a direct branch & link to the subroutine would add N instructions to the path length - but there would be a corresponding reduction of N for the <b>unconditional</b> <b>branch</b> that would no longer be required).|$|E
40|$|MCL is an {{optimization}} {{control language}} {{associated with the}} recently published MERLIN optimization package. It is developed so as to aid in constructing effective minimization strategies. It is very simple and easy to master. Supports Fortran-like operations, conditional and <b>unconditional</b> <b>branching,</b> multidimensional arrays, loops, statement functions, I/O operations and offers quite a few intrinsic functions. MERLIN has been further developed too, so that now it can be driven by the object code produced by the MCL compiler...|$|R
50|$|The HP 35s is keystroke-programmable, {{meaning that}} it can {{remember}} and later execute sequences of keystrokes to solve particular problems {{of interest to the}} user. Program keystrokes are fully merged: functions accessed via shift keys or menus are recorded as one keystroke, not two or more. These keystroke programs, in addition to performing any operation normally available on the keyboard, can also make use of conditional and <b>unconditional</b> <b>branching</b> and looping instructions, allowing programs to perform repetitive operations and make decisions.|$|R
5000|$|... <b>un{{conditional}}</b> and conditional <b>branches,</b> both {{direct and}} indirect ...|$|R
5000|$|The B opcode, if {{followed}} by a three-character operand, was a simple <b>unconditional</b> <b>branch</b> to the indicated address. If a fourth operand character was present (making five characters total including the opcode), this made it a conditional branch. This [...] "modifier" [...] character specified the condition to be tested.|$|E
50|$|Unconditional {{branches}} {{update the}} program counter {{with a new}} address computed {{in the same way}} as conditional branches. They also save the address of the instruction following the <b>unconditional</b> <b>branch</b> to a register. There are two such instructions, and they differ only in the hints provided for the branch prediction hardware.|$|E
50|$|The {{instruction}} set {{does not contain}} conditional branch instructions. Instead, it contains conditional skip instructions which cause the following instruction to be ignored. A conditional skip followed by an <b>unconditional</b> <b>branch</b> performs a conditional branch. The skip instructions test any bit of any register. The ALU status register is one possibility.|$|E
50|$|A {{variety of}} {{situations}} {{can cause a}} pipeline stall, including jumps (conditional and <b>unconditional</b> <b>branches)</b> and data cache misses.Some processors have a instruction set architecture with certain features designed to reduce the impact of pipeline stalls -- delay slot, conditional instructions such as FCMOV and branch prediction, etc.Some processors {{spend a lot of}} energy and transistors in the microarchitecture on features designed to reduce the impact of pipeline stalls -- branch prediction and speculative execution, out-of-order execution, etc.Some optimizing compilers try to reduce the impact of pipeline stalls by replacing some jumps with branch-free code, often at the cost of increasing the binary file size.|$|R
50|$|There {{are three}} types of <b>un{{conditional}}</b> and conditional <b>branching</b> in the 1802, Short and Long, and Skips.|$|R
40|$|AbstractWe {{consider}} {{the problem of}} simplifying the control structure of programs that manipulate numbers. In particular, we examine some simple programming language constructs which have sufficient computational power to eliminate all or most branching instructions (e. g. ‘while’, ‘if-then-else’ and ‘goto’ constructs) from such programs. We show that the operation of integer division by 2 is of considerable importance in this context. We also show that integer division by 2 cannot be computed by any loop-free program over the set of rational instructions, and hence {{that the power of}} integer division by 2 is, in a sense, greater than that of the conditional and <b>unconditional</b> <b>branching</b> instructions. We also investigate the power of indirect addressing in simplifying the control structure of programs over numerical inputs...|$|R
