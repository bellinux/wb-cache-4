6|249|Public
2500|$|There was no {{division}} instruction (but various division subroutines were supplied) {{and no way}} {{to directly}} load a number into the accumulator (a [...] "sTore and zero accumulator" [...] instruction followed by an [...] "Add" [...] instruction were necessary for this). [...] There was no <b>unconditional</b> <b>jump</b> <b>instruction,</b> nor was there a procedure call instruction- it {{had not yet been}} invented.|$|E
5000|$|If {{particular}} implementation {{stops the}} computer if it encounters an unknown opcode or it implements additional <b>unconditional</b> <b>jump</b> <b>instruction</b> with opcode [...] "111aaaaa", then such behaviour {{can be used}} as follows: ...|$|E
5000|$|Previously {{executed}} {{instructions were}} saved in an eight-word cache, called the [...] "stack". In-stack jumps were quicker than out-of-stack jumps because no memory fetch was required. The stack was flushed by an <b>unconditional</b> <b>jump</b> <b>instruction,</b> so unconditional jumps {{at the ends}} of loops were conventionally written as conditional jumps that would always succeed.|$|E
30|$|Programming of the {{proposed}} embedded ASIP includes three types of instructions. The first type is the ordinary classes like program flow <b>instructions</b> (conditional and <b>unconditional</b> <b>jumps),</b> move <b>instructions,</b> real, and complex ADD/SUB instructions, interfacing control instructions (external reads, output set). The second type is optimized instructions to facilitate the implementation of synchronization subsystem tasks {{as well as other}} algorithms {{in different parts of the}} engine. The third type is vector instructions.|$|R
5000|$|In the x86 {{assembly}} language, the '''''' <b>instruction</b> performs an <b>unconditional</b> <b>jump.</b> Such an <b>instruction</b> transfers {{the flow}} of execution by changing the instruction pointer register. There {{are a number of}} different opcodes that perform a jump; depending on whether the processor is in real mode or protected mode, and an override instruction is used, the instructions may take 16-bit, 32-bit, or segment:offset pointers.|$|R
25|$|The control {{instructions}} {{consist of}} conditional and <b>unconditional</b> branches, and <b>jumps.</b> The conditional and unconditional branch instructions use the branch instruction format, while the <b>jump</b> <b>instructions</b> use the memory instruction format.|$|R
5000|$|There was no {{division}} instruction (but various division subroutines were supplied) {{and no way}} {{to directly}} load a number into the accumulator (a [...] "sTore and zero accumulator" [...] instruction followed by an [...] "Add" [...] instruction were necessary for this). There was no <b>unconditional</b> <b>jump</b> <b>instruction,</b> nor was there a procedure call instruction - it {{had not yet been}} invented.|$|E
40|$|We {{present a}} {{light-weight}} event tracing toolkit for realtime operating systems on the Intel x 86 platform. Our approach is wait-free, multiprocessor-safe, and introduces very low overhead. Only a single <b>unconditional</b> <b>jump</b> <b>instruction</b> {{is required to}} distinguish between enabled and disabled events. As a case study, we trace the locking behavior of the Linux kernel. Our results provide {{strong support for the}} wide-spread assumption that short non-nested critical sections are the common case in practice. ...|$|E
40|$|Abstract We {{present a}} {{light-weight}} event tracing toolkit for real-time operating systems on the Intel x 86 platform. Our approach is wait-free, multiprocessor-safe, and intro-duces very low overhead. Only a single <b>unconditional</b> <b>jump</b> <b>instruction</b> {{is required to}} distinguish between en-abled and disabled events. As a case study, we traced the locking behavior of the Linux kernel and severalsoft real-time multimedia applications. Our results provide {{strong support for the}} wide-spread assumption thatshort non-nested critical sections are the common case in practice. 1 Introduction When developing operating systems and embedded sys-tems, event tracing facilities are an essential tool. Such facilities allow developers to trace the behavior of thesystem being developed by collecting performance and state data while the system in question executes for lateroffline analysis. The ability to better understand observed behaviors and to obtain high-resolution timinginformation greatly helps to both debug failures and improve performance. Thus, {{it is not surprising that}} therehas been considerable recent interest in tracing frameworks [5, 7, 11, 19, 20]. Prior work. For general-purpose operating systems,powerful and flexible solutions have been developed an...|$|E
5000|$|BES (sr. Bezuslovni Skok, en. <b>Unconditional</b> <b>Jump)</b> {{performs}} an <b>unconditional</b> <b>jump</b> to {{the address}} specified by the parameter ...|$|R
50|$|<b>Unconditional</b> <b>jumps</b> uses Goto and Lbl to operate.|$|R
40|$|This study evaluates {{a global}} {{optimization}} technique that avoids <b>unconditional</b> <b>jumps</b> by replicating code. When {{implemented in the}} back-end of an optimizing compiler, this technique can be generalized to work on almost all instances of <b>unconditional</b> <b>jumps,</b> including those generated from conditional statements and unstructured loops. The replication method {{is based on the}} idea of finding a replacement for each <b>unconditional</b> <b>jump</b> which minimizes the growth in code size. This is achieved by choosing the shortest sequence of instructions as a replacement. Measurements taken from a variety of programs showed that not only the number of executed instructions decreased, but also that the total cache work was reduced (except for small caches) despite increases in code size. Pipelined and superscalar machines may also benefit from an increase in the average basic block size. 1 Introduction <b>Unconditional</b> <b>jumps</b> occur often in programs. Depending on the environment, execution frequencies between 4 [...] ...|$|R
40|$|Abstract. We study {{sequential}} {{programs that}} are instruction sequences with direct and indirect <b>jump</b> <b>instructions.</b> The intuition is that indirect <b>jump</b> <b>instructions</b> are <b>jump</b> <b>instructions</b> where {{the position of the}} <b>instruction</b> to <b>jump</b> to is the content of some memory cell. We consider several kinds of indirect <b>jump</b> <b>instructions.</b> For each kind, we define the meaning of programs with indirect <b>jump</b> <b>instructions</b> of that kind by means of a translation into programs without indirect <b>jump</b> <b>instructions.</b> For each kind, the intended behaviour of a program with indirect <b>jump</b> <b>instructions</b> of that kind under execution is the behaviour of the translated program under execution on interaction with some memory device...|$|R
50|$|This example {{shows how}} to create three more useful {{instructions:}} clear, <b>unconditional</b> <b>jump,</b> and copy.|$|R
40|$|We study {{sequential}} {{programs that}} are instruction sequences with direct and indirect <b>jump</b> <b>instructions.</b> The intuition is that indirect <b>jump</b> <b>instructions</b> are <b>jump</b> <b>instructions</b> where {{the position of the}} <b>instruction</b> to <b>jump</b> to is the content of some memory cell. We consider several kinds of indirect <b>jump</b> <b>instructions.</b> For each kind, we define the meaning of programs with indirect <b>jump</b> <b>instructions</b> of that kind by means of a translation into programs without indirect <b>jump</b> <b>instructions.</b> For each kind, the intended behaviour of a program with indirect <b>jump</b> <b>instructions</b> of that kind under execution is the behaviour of the translated program under execution on interaction with some memory device. Comment: 23 pages; typos corrected, phrasing improved, reference replace...|$|R
5000|$|<b>Jump</b> <b>instructions</b> - 2 {{kinds of}} <b>Jump</b> <b>instructions</b> which reload ANTIC's program counter (3-byte instructions) ...|$|R
50|$|There {{are three}} control flow {{constructs}} in PROMELA. They are the case selection, the repetition and the <b>unconditional</b> <b>jump.</b>|$|R
5000|$|Even better, the [...] "tweaked" [...] {{pseudocode}} example, {{that may}} be performed automatically by some optimizing compilers, eliminating <b>unconditional</b> <b>jumps</b> altogether.|$|R
5000|$|For example: {{the most}} {{expanded}} set would include each unique instruction {{from the three}} sets, plus <b>unconditional</b> <b>jump</b> J (z) i.e.: ...|$|R
5000|$|... { Increment (r), Decrement (r), Clear (r); Copy (rj,rk), {{conditional}} Jump if {{contents of}} r=0, conditional <b>Jump</b> if rj=rk, <b>unconditional</b> <b>Jump,</b> HALT } ...|$|R
50|$|To avoid {{unnecessary}} {{loading of}} branch prediction electronics, (and therefore unnecessary pipeline stalls) the comparing branch codes {{should never be}} used for <b>unconditional</b> <b>jumps.</b>|$|R
50|$|Group 4 is {{conditional}} and <b>unconditional</b> <b>jumps.</b> Functions 40 - 43 jump to {{the first}} instruction of a pair, and 44 - 47 to the second.|$|R
50|$|When Goto n (where n is {{an integer}} in 0-9) is executed, {{the program will}} jump to Lbl n. Loops can be created with <b>unconditional</b> <b>jumps.</b>|$|R
5000|$|Note {{that only}} one type of [...] "jump" [...] - a {{conditional}} GOTO - is specified; for an <b>unconditional</b> <b>jump</b> a string of GOTO's must test each symbol.|$|R
5000|$|Machine level branch {{instructions}} are sometimes called <b>jump</b> <b>instructions.</b> Machine level <b>jump</b> <b>instructions</b> typically have <b>unconditional</b> and conditional forms where the latter {{may be taken}} or not taken depending on some condition.|$|R
5000|$|The Programma 101 {{was able}} to {{calculate}} the basic four arithmetic functions (addition, subtraction, multiplication, and division), plus square root, absolute value, and fractional part. It was equipped with memory registers with features such as clear, transfer, and exchange, plus printing and halt for input. There were 16 <b>jump</b> <b>instructions</b> and 16 conditional <b>jump</b> <b>instructions.</b> Its features of conditional <b>jump</b> <b>instructions,</b> an alphanumeric programming language, an internal memory, and a data storage system define it as a [...] "computer". Thirty-two label statements were available as destinations for the <b>jump</b> <b>instructions</b> and/or the four start keys (V, W, Y, Z). Routines on magnetic cards could be used without knowledge of programming.|$|R
40|$|Instruction {{sequences}} {{with direct}} and indirect <b>jump</b> <b>instructions</b> are as expressive as instruction sequences with direct <b>jump</b> <b>instructions</b> only. We show that, in the case where the number of instructions is not bounded, there exist instruction sequences of the former kind from which elimination of indirect <b>jump</b> <b>instructions</b> is possible without a super-linear increase of their maximal internal delay on execution only {{at the cost of}} a super-linear increase of their length...|$|R
40|$|Instruction {{sequences}} {{with direct}} and indirect <b>jump</b> <b>instructions</b> are as expressive as instruction sequences with direct <b>jump</b> <b>instructions</b> only. We show that, in the case where the number of instructions is not bounded, {{we are faced with}} increases of the maximal internal delays of instruction sequences on execution that are not bounded by a linear function if we strive for acceptable increases of the lengths of instruction sequences on elimination of indirect <b>jump</b> <b>instructions.</b> Comment: 10 pages, definition of maximal internal delay and theorem 1 are stated more precise; presentation improve...|$|R
50|$|The x86 {{assembly}} has an <b>unconditional</b> <b>jump</b> operation, , {{which can}} take an immediate address, a register or an indirect address as a parameter (note that most RISC processors only support a link register or short immediate displacement for jumping).|$|R
50|$|A local branch {{predictor}} has {{a separate}} history buffer for each conditional <b>jump</b> <b>instruction.</b> It may use a two-level adaptive predictor. The history buffer is separate for each conditional <b>jump</b> <b>instruction,</b> while the pattern history table may be separate {{as well or}} it may be shared between all conditional jumps.|$|R
50|$|This {{definition}} is more general than the intuitive one in some ways. For example, it allows <b>unconditional</b> <b>jumps</b> to labels not targeted by other jumps. This definition embodies the properties that make basic blocks {{easy to work}} with when constructing an algorithm.|$|R
5000|$|Conditional and <b>unconditional</b> <b>jumps</b> {{as well as}} subroutines were {{supported}}. The FX-502P series supported 10 {{labels for}} programs and subroutines called P0 [...]. P9. Each program or subroutine could have up to 10 local labels called LBL0 [...]. LBL9 for jumps and branches.|$|R
5000|$|Initially, {{register}} #2 contains [...] "2". Registers #0, #1 and #3 {{are empty}} (contain [...] "0"). Register #0 remains unchanged throughout calculations {{because it is}} used for the <b>unconditional</b> <b>jump.</b> Register #1 is a scratch pad. The program begins with instruction 1.|$|R
40|$|History-based branch {{direction}} predictors for conditional branches {{are shown}} to be highly accurate. Indirect branches however, are hard to predict as they may have multiple targets corresponding to a single indirect branch instruction. We propose the Value Based BTB Indexing (VBBI), a correlation-based target address prediction scheme for indirect <b>jump</b> <b>instructions.</b> For each static hard-topredict indirect <b>jump</b> <b>instruction,</b> the compiler identifies a ‘hint instruction’, whose output value strongly correlates with the target address of the indirect <b>jump</b> <b>instruction.</b> At run time, multiple target addresses of the indirect <b>jump</b> <b>instruction</b> are stored and subsequently accessed from the BTB at different indices computed using the <b>jump</b> <b>instruction</b> PC and the hint instruction output values. In case the hint instruction has not finished its execution when the <b>jump</b> <b>instruction</b> is fetched, a second and more accurate target address prediction is made when the hint instruction output is available, thus reducing the jump misprediction penalty. We compare our design to the regular BTB design and the best previously proposed indirect jump predictor, the tagged target cache (TTC). Our evaluation shows that the VBBI scheme improves the indirect jump target prediction accuracy by 48 % and 18 %, compared with the baseline BTB and TTC designs, respectively. This results in average performance improvement of 16. 4 % over the baseline BTB scheme, and 13 % improvement over the TTC predictor. Out of this performance improvement 2 % is contributed by target prediction overriding which is accurate 96 % of the time. ...|$|R
5000|$|But {{he admits}} {{the model is}} easier if he adds some pseudo-instructions O- [...] (combined 0 [...] and - [...] ) and [...] "go(n)". He builds [...] "go(n)" [...] out of the {{register}} w pre-set to 0, so that O- (w, (n)) is an <b>unconditional</b> <b>jump.</b>|$|R
2500|$|... index <b>jump</b> <b>instructions</b> with no delay slot {{designed}} to support large absolute addresses.|$|R
