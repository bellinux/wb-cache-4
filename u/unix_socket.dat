14|88|Public
5000|$|Remote {{controllable}} through cmus-remote program (<b>UNIX</b> <b>socket</b> or TCP/IP) ...|$|E
5000|$|The Unix command fuser {{is used to}} show which {{processes}} are using a specified file, file system, or <b>unix</b> <b>socket.</b> For example, to check process IDs and users accessing a USB drive:$ fuser -m -u /mnt/usb1/mnt/usb1: 1347c(root) 1348c(guido) 1349c(guido) ...|$|E
5000|$|Running as a FastCGI daemon {{listening}} on a <b>Unix</b> <b>socket,</b> {{ready to}} be used by any Web server with FastCGI support:$ plackup -s FCGI-listen /tmp/fcgi.sock app.psgiFastCGI: manager (pid 3336): initializedFastCGI: manager (pid 3336): server (pid 3337) startedFastCGI: server (pid 3337): initializedA working Hello world application run as a one-liner:$ plackup -e 'sub { => [...] "text/plain", }'HTTP::Server::PSGI: Accepting connections at http://0:5000/ ...|$|E
50|$|The API for <b>Unix</b> domain <b>sockets</b> {{is similar}} to that of an Internet socket, but rather than using an {{underlying}} network protocol, all communication occurs entirely within the operating system kernel. <b>Unix</b> domain <b>sockets</b> use the file system as their address name space. Processes reference <b>Unix</b> domain <b>sockets</b> as file system inodes, so two processes can communicate by opening the same socket.|$|R
50|$|Netlink socket {{family is}} a Linux kernel {{interface}} used for inter-process communication (IPC) between both the kernel and userspace processes, and between different userspace processes, in a way similar to the <b>Unix</b> domain <b>sockets.</b> Similarly to the <b>Unix</b> domain <b>sockets,</b> and unlike INET sockets, Netlink communication cannot traverse host boundaries. However, while the <b>Unix</b> domain <b>sockets</b> use the file system namespace, Netlink processes are addressed by process identifiers (PIDs).|$|R
5000|$|Implemented by mod_fcgid. This module {{used to be}} third-party, but {{was granted}} to the ASF as an Apache HTTP Server subproject in 2009, shepherded by Chris Darroch. It only {{supports}} <b>UNIX</b> <b>sockets,</b> no TCP sockets.|$|R
50|$|A SPICE client {{connection}} to a remote desktop server consists of multiple data channels, {{each of which is}} run over a separate TCP or <b>UNIX</b> <b>socket</b> connection. A data channel can be designated to operate in either clear-text, or TLS modes, allowing the administrator to tradeoff the security level vs performance. The TLS mode provides strong encryption of all traffic transmitted on the data channel.|$|E
40|$|Although many data {{communications}} courses are taught with no programming content, courses designed for computer science majors should include experience in algorithmically manipulating {{data to be}} communicated. Many {{data communications}} courses with a programming component make use of serial ports on PCs while some others deal with detailed network layer projects. <b>UNIX</b> <b>socket</b> programming allows the students {{to deal with the}} same issues and problems, but in a context that {{is more likely to be}} useful and that is more interesting. In addition, if socket classes are used with C++, only as much detail of socket operation as desired need be presented...|$|E
40|$|This report {{presents}} the results of an investigative effort that focuses on a first step toward providing a distributed framework for Linda system processes. In particular, we discuss the restructuring of the kernel "process" to support Tuple Space access through <b>UNIX</b> <b>socket</b> calls, rather than through shared memory primitives based on semaphore usage. A description of the restructured system and the rationale for such restructuring is presented first. Most intriguing, however, are the latter sections that discuss the ramifications and insights gained from our particular approach to system redesign, i. e., the unnecessary serialization of Tuple Space access, redundant memory copies, being victimized by the UNIX scheduler...|$|E
5000|$|The ØMQ message {{queueing}} library provides so-called sockets (a kind of generalization {{over the}} traditional IP and <b>Unix</b> <b>sockets)</b> which require indicating a messaging pattern to be used, and are optimized for each pattern. The basic ØMQ patterns are: ...|$|R
50|$|WAMP {{requires}} a reliable, ordered, full-duplex message channel as a transport layer, and by default uses Websocket. However, implementations can use other transports matching these characteristics {{and communicate with}} WAMP over e.g. raw <b>sockets,</b> <b>Unix</b> <b>sockets</b> or HTTP long poll.|$|R
50|$|A <b>Unix</b> domain <b>socket</b> or IPC socket (inter-process {{communication}} socket) is a {{data communications}} endpoint for exchanging data between processes executing {{on the same}} host operating system. Like named pipes, <b>Unix</b> domain <b>sockets</b> support transmission of a reliable stream of bytes (SOCK_STREAM, compare to TCP). In addition, they support ordered and reliable transmission of datagrams (SOCK_SEQPACKET, compare to SCTP), or unordered and unreliable transmission of datagrams (SOCK_DGRAM, compare to UDP). The <b>Unix</b> domain <b>socket</b> facility is a standard component of POSIX operating systems.|$|R
40|$|Tightly-coupled {{parallel}} {{machines are}} being replaced with clusters of workstations connected by communication networks yielding relatively long latencies, but ever-higher bandwidth (e. g., Ethernet, FDDI, HiPPI, ATM). However, it isvery {{difficult to make}} parallel programs based on fine-grain aggregate operations execute efficiently using a network that is optimized for point-to-point block transfers. TTL_PAPERS augments a cluster of PCs or workstations with the minimum hardware needed to provide very low latency barrier synchronization and aggregate communication. For example, UNIX user processes within a TTL_PAPERS cluster can perform a barrier synchronization in 2. 5 microseconds, including all software overhead. This is four orders of magnitude faster than using <b>UNIX</b> <b>socket</b> connections over anEthernet. This paper presents the TTL_PAPERS principles of operation, implementation issues, lowlevel software interface, and measured performance of the basic operations...|$|E
40|$|The ParaStation {{communication}} fabric {{provides a}} high-speed communication network with user-level access to enable efficient parallel computing on workstation clusters. The architecture, implemented on off-the-shelf workstations coupled by the ParaStation communication hardware, removes the kernel and common network protocols from the communication path while still providing full protection in a multiuser, multiprogramming environment. The programming interface presented by ParaStation {{consists of a}} <b>UNIX</b> <b>socket</b> emulation and widely used parallel programming environments like PVM, P 4, and MPI. This allows porting {{a wide range of}} client/server and parallel applications to the ParaStation architecture. The first implementation of ParaStation using Digital 's AlphaGeneration workstations achieves a communication latency as low as 2 : 5 ¯s (process-to-process) and a sustained bandwidth of more than 10 Mbyte/s per process. Benchmarks using PVM on ParaStation demonstrate real application performa [...] ...|$|E
40|$|The {{purpose of}} this study was to design and {{implement}} multimedia presentation authoring and browsing in multimedia database systems, based on a two-tier client/server architecture. The major approaches included: (i) Build a client/server multimedia presentation authoring and browsing environment; (ii) Allow query-by-image image retrieval and domain-based browsing through the User Datagram Protocol (UDP) between the Java socket at the client and the <b>Unix</b> <b>socket</b> at the server; (iii) Allow the multimedia presentation authoring by unifying the temporal, spatial and spatio-temporal relations among various media items into Multimedia Augmented Transition Network (MATN) model; (iv) Support the user interaction during the authoring process; (v) Visualize the presentation based on the created MATN models. As a result, this methodology provided users a flexible environment for heterogeneous media data retrieval and multimedia presentation authoring in multimedia database systems...|$|E
2500|$|... ifsock (server for sockets interface): Helps with <b>UNIX</b> domain <b>socket</b> addresses.|$|R
5000|$|Other {{parts of}} the API include utility {{routines}} and wrappers around existing APIs for ease of use. Utility routines perform such actions as file system and network I/O through , , and [...] and endianness translation (Byte Order Utilities). Some examples of wrapper routines include those for Core Foundation's wrapper routines for <b>Unix</b> <b>sockets,</b> the CFSocket API.|$|R
5000|$|IPC with <b>socket</b> sharing, using <b>Unix</b> domain <b>sockets</b> or named pipes (Windows) ...|$|R
40|$|ParaStation is a {{communications}} fabric for connecting off-the-shelf workstations into a supercomputer. The fabric employs technology used in massively parallel machines and scales up to 4096 nodes. ParaStation's user-level message passing software preserves the low latency {{of the fabric}} by taking the operating system out of the communication path, while still providing full protection in a multiprogramming environment. The programming interface presented by ParaStation consists of a <b>UNIX</b> <b>socket</b> emulation and widely used parallel programming environments such as PVM, P 4, and MPI. Implementations of ParaStation using various platforms, such as Digital 's AlphaGeneration workstations and Linux PCs, achieve end-to-end (process-toprocess) latencies as low as 2 ¯s and a sustained bandwidth of up to 15 Mbyte/s per channel, even with small packets. Benchmarks using PVM on ParaStation demonstrate real application performance of 1 GFLOP on an 8 -node cluster. Keywords: Workstation Cluster, Parall [...] ...|$|E
40|$|Pseudo Aircraft Systems (PAS) is a {{computerized}} flight dynamics and piloting {{system designed to}} provide a high fidelity multi-aircraft real-time simulation environment to support Air Traffic Control research. PAS is composed of three major software components that run on a network of computer workstations. Functionality is distributed among these components to allow the system to execute fast enough to support real-time operation. PAS workstations are linked by an Ethernet Local Area Network, and standard <b>UNIX</b> <b>socket</b> protocol is used for data transfer. Each component of PAS is controlled and operated using a custom designed Graphical User Interface. Each of these is composed of multiple windows, and many of the windows and sub-windows are used in several of the components. Aircraft models and piloting logic are sophisticated and realistic and provide complex maneuvering and navigational capabilities. PAS will continually be enhanced with new features and improved capabilities to support ongoing and future Air Traffic Control system development...|$|E
40|$|Developing {{software}} for networked applications is hard and developing reusable {{software for}} networked applications is even harder. First, {{there are the}} complexities inherent to distributed systems, such as optimally mapping application services onto hardware nodes, synchronizing service initialization, and ensuring availability while masking partial failures. These complexities can stymie even experienced software developers because they arise from fundamental challenges {{in the domain of}} network programming. Unfortunately, developers must master the accidental complexities, such as low-level and non-portable programming interfaces and the use of function-oriented design techniques that require tedious and error-prone revisions as requirements and/or platforms evolve. These complexities arise largely from limitations with the software tools and techniques applied historically by developers of networked software. Despite the use of object-oriented technologies in many domains, such as graphical user interfaces and productivity tools, much networked software still uses C-level operating system (OS) application programmatic interfaces (APIs), such as the <b>UNIX</b> <b>socket</b> API or the Windows threading API. Many accidental complexities of networked programmin...|$|E
5000|$|Netperf: Another {{bandwidth}} measurement {{tool that}} supports TCP, UDP, DLPI, <b>Unix</b> Domain <b>Sockets</b> and SCTP.|$|R
5000|$|Stream {{connections}} across <b>Unix</b> domain <b>sockets</b> {{carry the}} attacker's IP address with them (on 2.4 only) ...|$|R
5000|$|Loadable modules, {{providing}} {{among other}} things: full TCP and <b>Unix</b> domain <b>socket</b> controls, an FTP client, and extended math functions.|$|R
40|$|ED-MEDIA 2000 : World Conference on Educational Multimedia, Hypermedia & Telecommunications, June 26 - July 1, 2000, Montreal, Canada. This paper {{describes}} an Web-based speech input and its application system, WebSPEAC system, for {{digital signal processing}} online courses. The final goal of the development is to facilitate Web-based speech input for students and also the creation of sophisticated signal processing CGI programs for non-technical designers. The WebSPEAC system consists of WebSPEAC server and the client. The server is a CGI program and generates a task specific multipart document in the MIME message format "multipart/mixed" so as to enable students {{to communicate with the}} server naturally, i. e., without needless clickings. WebSPEAC client is a helper program executed from Web browser. The client is used to only record user's voice and automatically send it back to WebSPEAC server through <b>UNIX</b> <b>socket</b> connections. In this paper， two examples of on-line course content using WebSPEAC system for a digital speech signal processing are demonstrated in order to show how WebSPEAC system works...|$|E
40|$|The X-Windows Process Validation Table (PVT) Widget Class (Class is {{used here}} in the object-oriented-programming sense of the word) was devised to simplify the task of {{implementing}} network registration services for Information Sharing Protocol (ISP) graphical-user-interface (GUI) computer programs. Heretofore, ISP PVT programming tasks have required many method calls to identify, query, and interpret the connections and messages exchanged between a client and a PVT server. Normally, programmers have utilized direct access to <b>UNIX</b> <b>socket</b> libraries to implement the PVT protocol queries, necessitating the use of many lines of source code to perform frequent tasks. Now, the X-Windows PVT Widget Class encapsulates ISP client server network registration management tasks {{within the framework of}} an X Windows widget. Use of the widget framework enables an X Windows GUI program to interact with PVT services in an abstract way and {{in the same manner as}} that of other graphical widgets, making it easier to program PVT clients. Wrapping the PVT services inside the widget framework enables a programmer to treat a PVT server interface as though it were a GUI. Moreover, an alternate subclass could implement another service in a widget of the same type. This program was written by Matthew R. Barry of United Space Alliance for Johnson Space Center. For further information, contact the Johnson Technology Transfer Office at (281) 483 - 3809. MSC- 23582 Shuttle Data Center File- Processing Tool in Java A Java-language computer program has been written to facilitate mining of data in files in the Shuttle Data Center (SDC) archives. This program can be executed on a variety of workstations or via Web-browser programs. This program is partly similar to prior C-language programs used for the same purpose, while differing from those programs in that it exploits the platform-neutrality of Java in implementing several features that are important for analysis of large sets of time-series data. The program supports regular expression queries of SDC archive files, reads the files, interleaves the time-stamped samples according to a chosen output, then transforms the results into that format. A user can choose among a variety of output file formats that are useful for diverse purposes, including plotting, Markov modeling, multivariate density estimation, and wavelet multiresolution analysis, as well as for playback of data in support of simulation and testing...|$|E
50|$|Preservation of {{the lock}} status on open file {{descriptors}} passed to another process using a <b>Unix</b> domain <b>socket</b> is implementation dependent.|$|R
50|$|The MySQL server {{supports}} {{the use of}} different transport layers for connections. Connections use TCP/IP, <b>Unix</b> domain <b>sockets</b> or Windows named pipes.|$|R
50|$|OpenSSI {{provides}} internode {{access to}} all the standard Linux inter-process communication mechanisms, shared memory, semaphores, SYSV message queues, pipes and <b>Unix</b> domain <b>sockets.</b>|$|R
40|$|International audienceThis paper {{presents}} a communication {{system designed to}} allow efficient process migration in a cluster. The proposed system is generic enough to allow the migration {{of any kind of}} stream: socket, pipe, char devices. Communicating processes using IP or <b>Unix</b> <b>sockets</b> are transparently migrated with our mechanisms and they can still efficiently communicate after migration. The designed communication system is implemented as part of Kerrighed, a single system image operating system for a cluster based on Linux. Preliminary performance results are presented...|$|R
50|$|Other socket {{types are}} {{implemented}} over other transport protocols, such as Systems Network Architecture (SNA). See also <b>Unix</b> domain <b>sockets</b> (UDS), for internal inter-process communication.|$|R
50|$|Single IPC space:The {{standard}} UnixWare IPC mechanisms (shared memory, semaphores, message queues, <b>Unix</b> domain <b>sockets)</b> {{were all}} available for communication between processes running on any node.|$|R
5000|$|OpenXPKI {{is mostly}} written in Perl. The {{software}} is separated into a server process and several client implementations which {{communicate with the}} server via <b>Unix</b> Domain <b>Sockets.</b>|$|R
5000|$|In {{addition}} to sending data, processes may send file descriptors across a <b>Unix</b> domain <b>socket</b> connection using the [...] and [...] system calls. This allows the sending processes {{to grant the}} receiving process access to a file descriptor for which the receiving process otherwise does not have access. [...] This {{can be used to}} implement a rudimentary form of capability-based security. For example, this allows the Clam AntiVirus scanner to run as an unprivileged daemon on Linux and BSD, yet still read any file sent to the daemon's <b>Unix</b> domain <b>socket.</b>|$|R
5000|$|... #Caption: Process A and B have a {{one-to-one}} D-Bus connection using [...] over an <b>Unix</b> domain <b>socket.</b> They {{can use it}} {{to exchange}} messages directly. In this scenario bus names are not required.|$|R
5000|$|The {{hostname}} [...] has {{a special}} meaning. It is bound {{to the use of}} <b>Unix</b> domain <b>sockets.</b> It is not possible to open a TCP/IP connection using the hostname [...] you must use [...] instead.|$|R
