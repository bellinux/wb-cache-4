985|6938|Public
25|$|The module and <b>unit</b> <b>testing</b> tool Tessy {{relies on}} this extension.|$|E
25|$|<b>Unit</b> <b>testing</b> {{involves}} {{writing a}} test for every function (unit) that a program is to perform.|$|E
25|$|CTE 2 {{was later}} {{licensed}} to Razorcat for inclusion with the module and <b>unit</b> <b>testing</b> tool Tessy.|$|E
50|$|Test {{methods are}} {{declared}} as such by decorating a <b>unit</b> <b>test</b> method with the TestMethod attribute. The attribute {{is used to}} identify methods that contain <b>unit</b> <b>test</b> code. Best practices state that <b>unit</b> <b>test</b> methods should contain only <b>unit</b> <b>test</b> code.|$|R
40|$|Parameterized <b>unit</b> <b>tests</b> {{extend the}} current {{industry}} practice of using closed <b>unit</b> <b>tests</b> defined as parameterless methods. Parameterized <b>unit</b> <b>tests</b> separate two concerns: 1) They specify the external {{behavior of the}} involved methods for all test arguments. 2) Test cases can be re-obtained as traditional closed <b>unit</b> <b>tests</b> by instantiating the parameterized <b>unit</b> <b>tests.</b> Symbolic execution and constraint solving {{can be used to}} automatically choose a minimal set of inputs that exercise a parameterized <b>unit</b> <b>test</b> with respect to possible code paths of the implementation. In addition, parameterized <b>unit</b> <b>tests</b> can be used as symbolic summaries which allows symbolic execution to scale for arbitrary abstraction levels. We have developed a prototype tool which computes test cases from parameterized <b>unit</b> <b>tests.</b> We report on its first use testing parts of the. NET base class library...|$|R
40|$|Parameterized <b>unit</b> <b>tests</b> {{extend the}} current {{industry}} practice of using closed <b>unit</b> <b>tests</b> defined as parameterless methods. Traditional closed <b>unit</b> <b>tests</b> are re-obtained by instantiating the parameterized <b>unit</b> <b>tests.</b> We {{have developed the}} prototype tool Unit Meister, which uses symbolic execution and constraint solving to automatically compute a minimal set of inputs that exercise a parameterized <b>unit</b> <b>test</b> given certain coverage criteria. In addition, the parameterized <b>unit</b> <b>tests</b> {{can be used as}} symbolic summaries during symbolic execution, which allows our approach to scale for arbitrary abstraction levels. Unit Meister has a command-line interface, and is als...|$|R
25|$|The {{system of}} <b>unit</b> <b>testing</b> {{continues}} and in Year 8 boys sit {{two sets of}} exams {{in preparation for the}} transfer to the Upper School.|$|E
25|$|Debugging tactics {{can involve}} {{interactive}} debugging, control flow analysis, <b>unit</b> <b>testing,</b> integration testing, log file analysis, monitoring at the application or system level, memory dumps, and profiling.|$|E
25|$|Such a {{specification}} may exactly {{specify the}} behavior of the component being tested, but is less meaningful to a business user. As a result, specification-based testing is seen in BDD practice as a complement to story-based testing and operates at a lower level. Specification testing is often seen as a replacement for free-format <b>unit</b> <b>testing.</b>|$|E
40|$|Current <b>unit</b> <b>test</b> {{frameworks}} present broken <b>unit</b> <b>tests</b> in {{an arbitrary}} order, but developers {{want to focus}} on the most specific ones first. We have therefore inferred a partial order of <b>unit</b> <b>tests</b> corresponding to a coverage hierarchy of their sets of covered method signatures: When several <b>unit</b> <b>tests</b> in this coverage hierarchy break, we can guide the developer to the test calling the smallest number of methods. Our experiments with four case studies indicate that this partial order is semantically meaningful, since faults that cause a <b>unit</b> <b>test</b> to break generally cause less specific <b>unit</b> <b>tests</b> to break as well...|$|R
40|$|In {{spite of}} the utility of <b>unit</b> <b>tests,</b> most R package {{developers}} do not write them. exampletestr {{makes it easier to}} start writing <b>unit</b> <b>tests</b> by creating shells/skeletons of <b>unit</b> <b>tests</b> based on the examples in the user's package documentation. When completed, these <b>unit</b> <b>tests</b> test whether said examples run correctly. By combining the functionality of exampletestr with that of covr, having ensured that their examples adequately demonstrate the features of their package, the developer can have much of the work of constructing a comprehensive set of <b>unit</b> <b>tests</b> done for them...|$|R
5000|$|... lime <b>unit</b> <b>tests</b> use the [...] {{object to}} make assertions. The {{following}} is a basic example lime <b>unit</b> <b>test</b> to test PHP's built-in [...] function.|$|R
25|$|Final {{product testing}} may {{actually}} be counterproductive if, for example, a solid lead button is tested {{as part of a}} larger product. When tested separately, the button would fail, but when mixed together with the other inputs, the final total lead content may fall below the standard. Thus, <b>unit</b> <b>testing</b> would result in certifying the safety of a product which has unsafe components that could be swallowed by a child.|$|E
25|$|Difficult to unit test: Drupal 7 doesn't follow MVC {{framework}} and stores {{all of its}} configurations in database and as a result, <b>unit</b> <b>testing</b> the code without touching the database becomes extremely difficult. As a result, developers have resorted to using integration testing frameworks such as Red Test or behavior-driven development framework such as Behat and Codeception. Drupal 8 has taken a great stride in {{making it easier for}} developers to write unit-testable code.|$|E
500|$|Python {{has a large}} {{standard}} library, commonly {{cited as}} one of Python's greatest strengths, providing tools suited to many tasks. This is deliberate and {{has been described as}} a [...] "batteries included" [...] Python philosophy. For Internet-facing applications, many standard formats and protocols (such as MIME and HTTP) are supported. Modules for creating graphical user interfaces, connecting to relational databases, generating pseudorandom numbers, arithmetic with arbitrary precision decimals, manipulating regular expressions, and doing <b>unit</b> <b>testing</b> are also included.|$|E
40|$|Research Questions: What are the {{relationships}} between <b>unit</b> <b>tests</b> and between <b>unit</b> <b>tests</b> and methods under test? What can be gained by making this relationships explicit? How does the concept of method examples compare with other possible techniques to relate this entities? Significant problems and current solutions: (1.) Missing explicit relationships between <b>unit</b> <b>tests</b> and methods under test {{make it difficult to}} trace which features are thoroughly tested and hinder navigability between <b>unit</b> <b>tests</b> and their methods under test. xUnit uses a naming convention which is brittle when it comes to renaming the methods and classes under test. (2.) Schuh et al. [1] introduce the concept of ObjectMother to compose complex test scenarios. (3.) Failing <b>unit</b> <b>tests</b> are presented randomly and not in a meaningful order. [2] Definition: A method example tests a single method and returns the resulting receiver, parameters and potential return value of its method under test. Approach: Show which kind of relations between <b>unit</b> <b>tests</b> and between <b>unit</b> <b>tests</b> and method under tests exist. Correlate the <b>unit</b> <b>tests</b> of the base system of Squeak by decomposing them into method examples. Show, that the single concept of method examples enables navigation and traceability between <b>unit</b> <b>tests</b> and methods under test, provides concrete types for the methods under test, fits well together with traits [3]...|$|R
50|$|<b>Unit</b> <b>Tests</b> are {{a regular}} feature. In 2015, {{with the new}} {{principal}} BR. Solomon Morris, the <b>unit</b> <b>test</b> is held two times each term.|$|R
40|$|A {{parameterized}} <b>unit</b> <b>test</b> is the straightforward {{generalization of}} a <b>unit</b> <b>test</b> by allowing parameters. Parameterized <b>unit</b> <b>tests</b> make {{statements about the}} code’s behavior for an entire set of possible input values, instead of just a single exemplary input value. This document contains common patterns for parameterized <b>unit</b> <b>tests.</b> The patterns are written with automatic test input generation tools in mind, such as Microsoft Pex, which can determine all—or at least many—relevant test inputs that trigger the possible cases of the parameterized <b>unit</b> <b>test</b> and the code-under-test. This guide is Technical Level 400. To {{take advantage of this}} content, you should be experienced with the concepts and capabilities discussed in these documents...|$|R
2500|$|Chrome is {{internally}} {{tested with}} <b>unit</b> <b>testing,</b> [...] "automated user interface testing of scripted user actions", fuzz testing, {{as well as}} WebKit's layout tests (99% of which Chrome is claimed to have passed), and against commonly accessed websites inside the Google index within 20–30 minutes.|$|E
2500|$|Visual Studio 2017 offers new {{features}} like support for EditorConfig (a coding style enforcement framework), NGen support, [...]NET Core and Docker toolset (Preview), and Xamarin 4.3 (Preview). It also has XAML Editor, improved IntelliSense, live <b>unit</b> <b>testing,</b> debugging enhancement and better IDE experience and productivity.|$|E
2500|$|The {{legislation}} {{requires that}} every manufacturer {{of a product}} subject to a consumer product safety rule will provide a [...] "General Conformity Certificate" [...] (GCC) to certify, based on <b>unit</b> <b>testing</b> or a reasonable testing program, that the product complies with all safety rules. This requirement was imposed on every product manufactured on or after 12 November 2008. The certificate must: ...|$|E
5000|$|... @test nodes create <b>unit</b> <b>tests.</b> Leo executes {{the body}} of an @test node as a <b>unit</b> <b>test,</b> without the body having to create an {{explicit}} subclass of Python's UnitTest.TestCase class.|$|R
50|$|In test-driven {{development}} (TDD), {{which is}} frequently {{used in both}} extreme programming and scrum, <b>unit</b> <b>tests</b> are created before the code itself is written. When the tests pass, that code is considered complete. The same <b>unit</b> <b>tests</b> are run against that function frequently as the larger code base is developed either as the code is changed or via an automated process with the build. If the <b>unit</b> <b>tests</b> fail, it {{is considered to be}} a bug either in the changed code or the <b>tests</b> themselves. The <b>unit</b> <b>tests</b> then allow the location of the fault or failure to be easily traced. Since the <b>unit</b> <b>tests</b> alert the development team of the problem before handing the code off to testers or clients, it is still early in the development process.|$|R
5000|$|Recurring Bug Pattern - Expose a bug via a <b>unit</b> <b>test.</b> Run that <b>unit</b> <b>test</b> {{as part of}} a {{standard}} build from that moment on. This ensure that the bug will not recur.|$|R
2500|$|Specification testing tools like RSpec and JDave are {{somewhat}} different in nature from tools like JBehave. Since {{they are seen}} as alternatives to basic <b>unit</b> <b>testing</b> tools like JUnit, these tools tend to favor forgoing the separation of story and testing code and prefer embedding the specification directly in the test code instead. For example, an RSpec test for a hashtable might look like this: ...|$|E
2500|$|At {{the heart}} of BDD is a {{rethinking}} of the approach to the <b>unit</b> <b>testing</b> and acceptance testing that naturally arise with these issues. For example, BDD suggests that unit test names be whole sentences starting with a conditional verb ("should" [...] in English for example) and should be written in order of business value. Acceptance tests should be written using the standard agile framework of a user story: [...] "As a [...] I want [...] so that [...] ". Acceptance criteria should be written in terms of scenarios and implemented as classes: Given , when , then [...]|$|E
2500|$|Manufacturers {{also note}} both the {{difficulty}} and the apparently contradictory mandate to perform <b>unit</b> <b>testing.</b> An apparel manufacturer, for example, might use a single mill product such as organic cotton cloth {{coupled with a}} few organic dyes and {{a few pieces of}} hardware such as zippers or buttons. Those can be combined in limitless ways and in various sizes. Testing all of the final products generally provides no more information than would testing the individual inputs (or [...] "components"), but is vastly more expensive. [...] In response to this criticism, the CPSC added Rule 1109, known as the [...] "Component Part Testing Rule", that allows U.S. importers to rely on suppliers to meet testing requirements, so long as “due care” is used {{to make sure that the}} supplier has in fact complied with requirements.|$|E
5000|$|Parameterized <b>unit</b> <b>tests</b> (PUTs) are {{tests that}} take parameters. Unlike {{traditional}} <b>unit</b> <b>tests,</b> {{which are usually}} closed methods, PUTs take any set of parameters. PUTs have been supported by TestNG, JUnit and various [...]NET test frameworks. Suitable parameters for the <b>unit</b> <b>tests</b> may be supplied manually {{or in some cases}} are automatically generated by the test framework. Testing tools like QuickCheck exist to generate test inputs for PUTs.|$|R
50|$|Smoke {{tests can}} be broadly {{categorized}} as functional <b>tests</b> or as <b>unit</b> <b>tests.</b> Functional tests exercise the complete program with various inputs. <b>Unit</b> <b>tests</b> exercise individual functions, subroutines, or object methods. Functional tests may comprise a scripted series of program inputs, possibly even with an automated mechanism for controlling mouse movements. <b>Unit</b> <b>tests</b> {{can be implemented}} either as separate functions within the code itself, or else as a driver layer that links to the code without altering the code being tested.|$|R
50|$|<b>Unit</b> <b>tests</b> are {{so named}} because they each <b>test</b> one <b>unit</b> of code. A complex module may have a {{thousand}} <b>unit</b> <b>tests</b> and a simple module may have only ten. The <b>unit</b> <b>tests</b> used for TDD should never cross process boundaries in a program, let alone network connections. Doing so introduces delays that make tests run slowly and discourage developers from running the whole suite. Introducing dependencies on external modules or data also turns <b>unit</b> <b>tests</b> into integration tests. If one module misbehaves in a chain of interrelated modules, {{it is not so}} immediately clear where to look for the cause of the failure.|$|R
2500|$|Moore's first {{assignment}} {{after graduation}} was the Infantry Officer Basic Course at Fort Benning, Georgia {{which was a}} six-week course. During the basic course he applied for the airborne jump school at Fort Benning, however, he was not selected and was instead assigned to the [...] three-week jump school held at the 11th Airborne Division in Tokyo, Japan. His first assignment out of jump school was with the 187th Glider Infantry Regiment at Camp Crawford near Sapporo, Japan from 1945 until 1948. After a seven-month stint as company commander, he was assigned as Camp Crawford's construction officer and responsible {{for all of the}} construction improvements being made at the camp. In June 1948 he was reassigned to the 82nd Airborne Division, at Fort Bragg. He volunteered to join the Airborne Test Section, a special <b>unit</b> <b>testing</b> experimental parachutes, and he made the first of some 150 jumps with the section {{over the next two years}} on November 17, 1948. Over the course of his career, he became a master parachutist with over 300 jumps.|$|E
50|$|The Visual Studio <b>Unit</b> <b>Testing</b> Framework {{describes}} Microsoft's {{suite of}} <b>unit</b> <b>testing</b> tools as integrated into some versions of Visual Studio 2005 and later. The <b>unit</b> <b>testing</b> framework {{is defined in}} Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll. Unit tests created with the <b>unit</b> <b>testing</b> framework can be executed in Visual Studio or, using MSTest.exe, from a command line.|$|E
50|$|<b>Unit</b> <b>testing</b> is the {{cornerstone}} of extreme programming, which relies on an automated <b>unit</b> <b>testing</b> framework. This automated <b>unit</b> <b>testing</b> framework can be either third party, e.g., xUnit, or created within the development group.|$|E
40|$|Utilizing {{recursive}} mean adjustment (RMA) {{we provide}} two unit root tests: the covariate RMA <b>unit</b> root <b>test</b> and the panel feasible generalized RMA <b>unit</b> root <b>test.</b> The proposed panel <b>unit</b> root <b>tests</b> are precise and powerful, especially when TÂ >Â N. Recursive detrending Dynamic factors Panel <b>unit</b> root <b>test</b> Covariate <b>unit</b> root <b>test</b> Cross section dependence...|$|R
40|$|This book {{explains}} in detail how to implement <b>unit</b> <b>tests</b> using two very popular open source Java technologies: JUnit and Mockito. It presents {{a range of}} techniques necessary to write high quality <b>unit</b> <b>tests</b> - e. g. mocks, parametrized tests and matchers. It also discusses trade-offs related to the choices {{we have to make}} when dealing with some real-life code issues. The book stresses the importance of writing readable and maintainable <b>unit</b> <b>tests,</b> and puts a lot of stress on code quality. It shows how to achieve testable code and to eliminate common mistakes by following the Test Driven Development approach. Every topic discussed in the book is illustrated with code examples, and each chapter is accompanied by some exercises. By reading this book you will: Grasp the role and purpose of <b>unit</b> <b>tests</b> Write high-quality, readable and maintainable <b>unit</b> <b>tests</b> Learn how to use JUnit and Mockito (but also other useful tools) Avoid common pitfalls when writing <b>unit</b> <b>tests</b> Recognize bad <b>unit</b> <b>tests,</b> and fix them in no time Develop code following the Test Driven Development (TDD) approach Use mocks, stubs and test-spies intelligently Measure the quality of your tests using code coverage and mutation testing Learn how to improve your tests' code so it is an asset and not a burden Test collections, expected exceptions, time-dependent methods and much more Customize test reports so that they show you what you really need to know Master tools and techniques your team members have never even heard of (priceless!) :) Nowadays every developer is expected to write <b>unit</b> <b>tests.</b> While simple in theory, in practice writing high-quality <b>unit</b> <b>tests</b> can {{turn out to be a}} real challenge. This book will help...|$|R
3000|$|... 2 Mock {{objects are}} objects created during a <b>unit</b> <b>test.</b> They mock the {{behavior}} of another object. Usually, {{they are used to}} isolate the <b>unit</b> <b>test</b> from other classes. More information about it can be found on [35].|$|R
