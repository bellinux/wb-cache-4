323|1112|Public
5|$|PHP has {{received}} criticism due to lacking native Unicode support {{at the core}} language level, instead only supporting byte strings. In 2005, a project headed by Andrei Zmievski was initiated to bring native Unicode support throughout PHP, by embedding the International Components for Unicode (ICU) library, and representing text strings as UTF-16 internally. Since this would cause major changes both to the internals of the language and to <b>user</b> <b>code,</b> it was planned to release this as version 6.0 of the language, along with other major features then in development.|$|E
2500|$|Many kernels provide {{implementation}} of [...] "capabilities", i.e. {{objects that are}} provided to <b>user</b> <b>code</b> which allow limited access to an underlying object managed by the kernel. [...] A common example occurs in file handling: a file is a representation of information stored on a permanent storage device. [...] The kernel {{may be able to}} perform many different operations (e.g. read, write, delete or execute the file contents) but a user level application may only be permitted to perform some of these operations (e.g. it may only be allowed to read the file). [...] A common {{implementation of}} this is for the kernel to provide an object to the application (typically called a [...] "file handle") which the application may then invoke operations on, the validity of which the kernel checks at the time the operation is requested. Such a system may be extended to cover all objects that the kernel manages, and indeed to objects provided by other user applications.|$|E
2500|$|...NET Framework {{includes}} a garbage collector (GC) which runs periodically, {{on a separate}} thread from the application's thread, that enumerates all the unusable objects and reclaims the memory allocated to them. It is a non-deterministic, compacting, mark-and-sweep garbage collector. GC runs only when a set amount of memory has been used or there is enough pressure for memory on the system. Since it is not guaranteed when the conditions to reclaim memory are reached, GC runs are non-deterministic. Each [...]NET application has a set of roots, which are pointers to objects on the managed heap (managed objects). These include references to static objects and objects defined as local variables or method parameters currently in scope, and objects referred to by CPU registers. When GC runs, it pauses the application and then, for each object {{referred to in the}} root, it recursively enumerates all the objects reachable from the root objects and marks them as reachable. It uses CLI metadata and reflection to discover the objects encapsulated by an object, and then recursively walk them. It then enumerates all the objects on the heap (which were initially allocated contiguously) using reflection. All objects not marked as reachable are garbage. This is the mark phase. Since the memory held by garbage is of no consequence, it is considered free space. However, this leaves chunks of free space between objects which were initially contiguous. The objects are then compacted together to make free space on the managed heap contiguous again. Any reference to an object invalidated by moving the object is updated by GC to reflect the new location. The application is resumed after garbage collection ends. The latest version of [...]NET framework uses concurrent garbage collection along with <b>user</b> <b>code,</b> making pauses unnoticeable, because it is done in the background.|$|E
40|$|Spreading {{codes are}} used to {{distinguish}} users and spread the signal to occupy much wider band width than the minimum required band width. Spreading codes are also called as <b>user</b> <b>codes.</b> Walsh, Gold and Kasami codes are the popularly used Binary (2 -level) <b>user</b> <b>codes.</b> This paper proposes new multi level spreading codes constructed using ternary and quaternary Gray and Inverse Gray codes for multiuser Direct Sequence Code Division Multiple Access systems. Multi level spreading codes discussed in this paper are non zero mean, varying power codes. An attempt is made to analyze these multi level <b>user</b> <b>codes</b> through correlation properties. The methodology explained in this paper allows to generate 3 -level <b>user</b> <b>codes</b> of length- 6 and 4 -level <b>user</b> <b>codes</b> of length- 8. It also allows generation of codes whose lengths are even multiples of the codes of length 6 and length 8. The auto and cross correlation properties and bit error rate performance of these codes and their comparison with those of Walsh and Gold codes are presented in this paper...|$|R
50|$|Note (4): In Drizzle the <b>user</b> <b>codes</b> {{functions}} and procedures in C++.|$|R
5000|$|A {{hierarchy}} of C/C++ library functions {{that can be}} used from the <b>user's</b> <b>code.</b>|$|R
50|$|<b>User</b> <b>code</b> {{annotation}} are optional in the PACT programming model. They {{allow the}} developer {{to make certain}} behaviors of her/his <b>user</b> <b>code</b> explicit to the optimizer. The PACT optimizer can utilize that information to obtain more efficient execution plans. However, it will not impact the correctness of the result if a valid annotation was not attached to the <b>user</b> <b>code.</b> On the other hand, invalidly specified annotations might cause the computation of wrong results. In the following, we list the current set of available Output Contracts.|$|E
5000|$|Millicode {{can provide}} a complex {{instruction}} {{as if it were}} a subroutine, making <b>user</b> <b>code</b> smaller.|$|E
50|$|The CoGroup Input Contract {{works on}} two inputs as well. It {{can be seen}} as a Reduce on two inputs. On each input, the records are grouped by key (such as Reduce does) and handed to the <b>user</b> <b>code.</b> In {{contrast}} to Match, the <b>user</b> <b>code</b> is also called for a key if only one input has a pair with it (see blue key in example below).|$|E
50|$|Note (2): In Derby, H2, LucidDB, and CUBRID, <b>users</b> <b>code</b> {{functions}} and procedures in Java.|$|R
40|$|A {{new class}} of {{multiple}} access algorithms for systems without feedback is introduced and analyzed. A finite population of users is assumed, where each user transmits a packet R times within the next N time slots (and all packets have an equal length of one slot). To improve the performance achieved by randomly selecting these R slots, <b>user</b> <b>codes</b> are invoked such that any two users will only transmit simultaneously in at most one slot, i. e., 2 -(N, R, 1) designs. We argue that in most cases, the set of <b>user</b> <b>codes</b> can be generated easily using cyclic designs and provide a method to select T <b>user</b> <b>codes</b> from the set of <b>user</b> <b>codes</b> SN,R in case the user population consists of T |SN,R|, can still benefit from these <b>user</b> <b>codes</b> in two different manners. Closed formulas that express the success probability of a packet are provided for all population setups. Finally, a comparison with the random selection strategy demonstrates the performance gain realized by the new multiple access algorithms and some engineering rules to optimize the performance are provided. Multiple access algorithms without feedback were first developed during the early 1980 s by Massey [1]. In this setting, a set of M users shares a time-slotted random access channel. The idea was to assig...|$|R
5000|$|... #Caption: The GPI-Space core {{plus the}} domain {{specific}} HPC-modules for seismic make up SDPA to execute <b>user</b> <b>codes.</b>|$|R
50|$|The Google Charts service {{differs from}} the older service {{provided}} by the (now deprecated) Google Chart API (the names are similar and easily confused). Google Charts {{does not support the}} HTTP request method, and is thus not backward-compatible with <b>user</b> <b>code</b> for the Google Charts API. Upgrading legacy <b>user</b> <b>code</b> from Google Chart API to Google Charts thus requires a complete rewrite of the HTTP semantics in JavaScript.|$|E
5000|$|Similar to MapReduce, {{arbitrary}} <b>user</b> <b>code</b> is handed {{and executed}} by PACTs. However, PACT generalizes {{a couple of}} MapReduce's concepts: ...|$|E
5000|$|Process URI {{requests}} that do {{not result}} in a file request, e.g., executing a hook into <b>user</b> <b>code,</b> before continuing below.|$|E
30|$|In {{the case}} of SC CDMA ZP system of the Figure 3, it was {{observed}} that the receiver restored some of the orthogonality between <b>user</b> <b>codes,</b> resulting in good signal to interference-plus-noise ratio, which in turn results in enhanced BER. For {{the case of}} SC CDMA CP of the Figure 2, the same receiver could not restore the orthogonality between <b>user</b> <b>codes,</b> resulting in poor signal to interference-plus-noise ratio and then in worst BER.|$|R
5|$|Collaboration on {{computing}} waveforms with Dennis on the TX-0 led to Samson {{writing the}} Harmony Compiler with which PDP-1 <b>users</b> <b>coded</b> music.|$|R
50|$|Orthogonal {{variable}} {{spreading factor}} (OVSF) is an implementation of Code {{division multiple access}} (CDMA) where before each signal is transmitted, the signal is spread over a wide spectrum range {{through the use of}} a <b>user's</b> <b>code.</b> Users' codes are carefully chosen to be mutually orthogonal to each other.|$|R
5000|$|... extensibility: A {{user can}} extend the {{framework}} - usually by selective overriding; or programmers can add specialized <b>user</b> <b>code</b> to provide specific functionality.|$|E
50|$|In the {{following}} example (using Symbolics Genera) the user tries to open a file in a Lisp function test called from the Read-Eval-Print-LOOP (REPL), when the file does not exist. The Lisp system presents four restarts. The user selects the Retry OPEN using a different pathname restart and enters a different pathname (lispm-init.lisp instead of lispm-int.lisp). The <b>user</b> <b>code</b> does not contain any error handling code. The whole error handling and restart code {{is provided by the}} Lisp system, which can handle and repair the error without terminating the <b>user</b> <b>code.</b>|$|E
50|$|ILNumerics is {{distributed}} {{as an extension}} to Visual Studio. It adds a tool window to the IDE for the graphical inspection of mathematical objects while stepping through <b>user</b> <b>code.</b>|$|E
50|$|MIMEDefang <b>users</b> <b>code</b> their {{filtering}} {{policies in}} Perl, using the infrastructure provided by mimedefang.pl. They don't {{need to worry}} about thread synchronizations because each Perl filter is a separate single-threaded process.|$|R
50|$|Working with Jack Dennis on the TX-0 at MIT Building 26, he {{developed}} {{an interest in}} computing waveforms to synthesize music. For the PDP-1 he wrote the Harmony Compiler with which PDP-1 <b>users</b> <b>coded</b> music.|$|R
30|$|So, for ZP systems, {{the maximum}} {{diversity}} gain is achieved {{independent of the}} choice of the <b>user</b> <b>codes,</b> the precoding matrix and the number of users on the system, provided that GC is full column rank.|$|R
50|$|The F# type system {{supports}} units of measure checking for numbers. The units of measure feature integrates with F# type inference to require minimal type annotations in <b>user</b> <b>code.</b>|$|E
5000|$|Partial classes, {{a method}} of {{defining}} some parts of a class in one file and then adding more definitions later; particularly useful for integrating <b>user</b> <b>code</b> with auto-generated code ...|$|E
50|$|The {{language}} makes {{distinction between}} read-time, compile-time, load-time and run-time, and allows <b>user</b> <b>code</b> to also make this distinction {{to perform the}} wanted type of processing at the wanted step.|$|E
5000|$|Fortran 2008's sync images {{statement}} doesn't {{provide a}} safe synchronization space. As a result, synchronization operations in <b>user's</b> <b>code</b> that are pending when a library call is made can interfere with synchronization in the library call.|$|R
50|$|Corona Textmate Bundle is {{designed}} to help TextMate <b>users</b> <b>code</b> Corona SDK applications more quickly. It contains a large number of autocomplete terms, commands, and snippets for access to various Corona APIs using the standard TextMate keyboard/menu shortcuts.|$|R
40|$|Abstract—In {{this paper}} we study a {{multiple}} access system without feedback supporting multiple carriers for delay critical applications {{with a small}} loss tolerance. In such a system, users transmits R times within the next N timeslots, {{in order to improve}} their success probability. In an earlier work [1], we considered the same problem in a single carrier system and demonstrated that the distribution of properly designed <b>user</b> <b>codes</b> significantly improved the success probability over a random selection strategy. These <b>user</b> <b>codes,</b> that determine the R slots used for transmission, corresponded to so-called 2 -(N; R; 1) designs. Mainly motivated by DVB-RCS satellite systems, this paper considers a system with multiple carriers with the limitation that at any time, at most one slot, and thus carrier, can be used by a single user. We introduce two static and four dynamic slot assignment schemes and under some mild assumptions provide closed form formulas for the success probability in each of these systems. For the last dynamic scheme we will show how group divisible designs are the multi-carrier equivalent of the 2 -(N; R; 1) designs of the single carrier system and provide a simple procedure to construct these <b>user</b> <b>codes.</b> Finally, we compare all of the proposed assignment schemes and show that the group divisible designs are superior, especially for large population sizes. Some engineering rules with respect to their usage are also provided. For two of the dynamic schemes we also compare two different strategies in case there are not enough <b>user</b> <b>codes</b> available for all users. I...|$|R
5000|$|The JavaFX SDK: runtime tools. Graphics, media web services, {{and rich}} text libraries. Java FX 1.x also {{included}} JavaFX compiler, {{which is now}} obsolete as JavaFX <b>user</b> <b>code</b> is written in Java.|$|E
50|$|The use of kernel threads {{simplifies}} <b>user</b> <b>code</b> {{by moving}} {{some of the}} most complex aspects of threading into the kernel. The program does not need to schedule threads or explicitly yield the processor. <b>User</b> <b>code</b> can be written in a familiar procedural style, including calls to blocking APIs, without starving other threads. However, kernel threading may force a context switch between threads at any time, and thus expose race hazards and concurrency bugs that would otherwise lie latent. On SMP systems, this is further exacerbated because kernel threads may literally execute on separate processors in parallel.|$|E
50|$|This is a {{traditional}} design. The library manages a set of n-dimensional scalar arrays, which the <b>user</b> <b>code</b> may access to perform updates. The library handles the synchronization of the boundaries (dubbed ghost zone or halo). The advantage of this interface is that the <b>user</b> <b>code</b> may loop over the arrays, which {{makes it easy to}} integrate legacy codes. The disadvantage is that the library can not handle cache blocking (as this has to be done within the loops)or wrapping of the code for accelerators (e.g. via CUDA or OpenCL). Notable implementations include Cactus, a physics problem solving environment, and waLBerla.|$|E
50|$|Updates to the Code are {{published}} weekly to the nigp.com site for download by <b>users.</b> <b>Codes</b> requested directly from users are typically delivered via extract files to the user, with general {{release of the}} new codes in the weekly website update.|$|R
50|$|This freedom allows using CEGUI in {{any kind}} of {{resource}} management system or operating environment. Input is expected to be gathered by the <b>user's</b> <b>code,</b> possibly filtered as the user sees fit, and then passed to CEGUI for window processing.|$|R
3000|$|..., in (2), only {{includes}} the active {{users in the}} communications system (note {{that the number of}} possible <b>user</b> <b>codes</b> can be very high). Then, the problem of the detection of the notes played in a window of the available waveform, becomes the problem of deciding if [...]...|$|R
