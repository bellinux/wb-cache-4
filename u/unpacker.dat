15|10|Public
50|$|Although {{archiving}} {{with the}} RAR format is proprietary, RarLab supplies as copyrighted freeware the C++ source {{code of the}} current UnRAR <b>unpacker,</b> with a license allowing it {{to be used in}} any software, thus enabling others to produce software capable of unpacking, but not creating, RAR archives.|$|E
5000|$|The Unarchiver is a {{free data}} {{decompression}} utility, which supports more formats than Archive Utility (formerly known as BOMArchiveHelper), the built-in archive <b>unpacker</b> program in OS X. It can also handle filenames in foreign character sets, created with non-English versions of other operating systems. The latest version requires Mac OS X v10.3.9 or higher. The Unarchiver does not compress files. The corresponding command line utilities [...] and [...] run on Microsoft Windows, Linux, and Mac OS X.|$|E
40|$|Abstract—An {{important}} {{application of}} binary-level reverse engineering is in reconstructing the internal logic of computer malware. Most malware code is distributed in encrypted (or “packed”) form; at runtime, an <b>unpacker</b> routine transforms {{this to the}} original executable form of the code, which is then executed. Most of the existing work on analysis of such programs focuses on detecting unpacking and extracting the unpacked code. However, this does not shed any light on the functionality of different portions of the code so obtained, and in particular does not distinguish between code that performs unpacking and code that does not; identifying such functionality can be helpful for reverse engineering the code. This paper describes a technique for identifying and extracting the <b>unpacker</b> code in a self-modifying program. Our algorithm uses offline analysis of a dynamic instruction trace both to identify the point(s) where unpacking occurs and to identify and extract the corresponding <b>unpacker</b> code. Keywords-reverse engineering; binary analysis; malware analysis; self-modifying code I...|$|E
40|$|With {{the advance}} of packing techniques, a few generic and {{automatic}} <b>unpackers</b> have been proposed. These <b>unpackers</b> are designed to automatically unpack packed binaries without specific knowledge of the packing techniques used. In this paper, we present an automatic packer with which packed malware forges spurious unpacking behaviors that lead to a denial-of-service attack on host-based generic <b>unpackers.</b> We present the design, implementation, and evaluation of the proposed packer and malware produced using the proposed packer, and show the success of denial-of-service attacks on host-based generic <b>unpackers...</b>|$|R
40|$|Packing is a {{very popular}} {{technique}} for obfuscating programs, and malware in particular. In order to successfully detect packed malware, dynamic unpacking techniques have been proposed in literature. Dynamic <b>unpackers</b> execute and monitor a packed program, and try to guess when the original code {{of the program is}} available unprotected in memory. The major drawback of dynamic <b>unpackers</b> is the performance overhead they introduce. To reduce the overhead and make it possible to perform dynamic unpacking at end-hosts, researches have proposed real-time <b>unpackers</b> that operate at a coarser granularity, namely OmniUnpack and Justin. In this paper, we present a simple compile-time packing algorithm that maximizes the cost of unpacking and minimizes the amount of program code that can be automatically recovered by real-time coarse grained <b>unpackers.</b> The evaluation shows that the real-time dynamic <b>unpackers</b> are totally ineffective against this algorithm. 1...|$|R
40|$|Abstract. In this paper, we {{tackle the}} problem of {{compression}} and decompression of PE-files (portable executable file format in MS Windows). We analyze decompression methods used in the PE-file <b>unpackers.</b> Based on that, we design a new decompression method, which however uses standard decompression algorithms. Finally, we compare various standard decompression methods to our method and analyze and comment the results {{that we were able}} to achieve...|$|R
40|$|Executable files packing is {{a process}} used for {{compression}} or protection of these files. The behavior of the packed executable file is difficult to analyze, therefore the packed file needs to be unpacked at first. This work deals with the design and implementation of a generic <b>unpacker</b> {{that is part of}} the decompilation chain in the AVG's Retargetable Decompiler. The goal of this work is to create the generic <b>unpacker</b> of executable files, which would be easily extensible, platform and architecture independent, and its ouput would be decompilable. The heuristic analyses are proposed and implemented to achieve the decompilability of the ouput. The results are comparable with the other unpackers used in practice...|$|E
40|$|International audienceWe {{propose to}} extend the toolbox of reverse {{engineers}} beyond disassemblers, debuggers and emulators. Using dynamic binary instrumentation, it is very simple to write advanced tools such as automatic unpackers, system call tracers and deobfuscators. Based on our experiments, DBI is suitable for malware analysis. In this presentation, we will present a simple and accurate automatic <b>unpacker</b> integrated with IDA Pro and a Javascript deobfuscator, all written using DBI techniques...|$|E
40|$|Executable packing is {{the most}} common {{technique}} used by computer virus writers to obfuscate malicious code and evade detection by anti-virus software. Universal unpackers have been proposed that can detect and extract encrypted code from packed executables, therefore potentially revealing hidden viruses that can then be detected by traditional signature-based anti-virus software. However, universal unpackers are computationally expensive and scanning large collections of executables looking for virus infections may take several hours or even days. In this paper we apply pattern recognition techniques for fast detection of packed executables. The objective is to efficiently and accurately distinguish between packed and non-packed executables, so that only executables detected as packed will be sent to an universal <b>unpacker,</b> thus saving a significant amount of processing time. We show that our system achieves very high detection accuracy of packed executables with a low average processing time...|$|E
40|$|Bugfixes: 	You {{could get}} a traceback with some <b>unpackers</b> (not Vagrant) on some {{packages}} that explicitely pack the / directory 	Some environment variables prevented running, such as bash exported functions. Features: 	Remove setup directory if setup fails, so you can run setup again without gettin target directory exists 	Add [...] set-env and [...] pass-env to run Downloads: 	reprozip (tarball) 	reprounzip (wheel, tarball) 	reprounzip-docker (wheel, tarball) 	reprounzip-vagrant (wheel, tarball) 	reprounzip-vistrails (wheel, tarball) 	Windows installer (Python 2. 7, reprounzip and plugins) 	Mac Installer 1. 0. 2 (Python 2. 7, reprounzip and plugins) (1. 0. 3 building [...] . ...|$|R
40|$|Reverse {{engineering}} {{is defined by}} Chikosfky and Cross as the process of analyzing a subject system to identify the system’s components and their relationships, and to create representations of the system in another form or {{at a higher level}} of abstraction. The process of reverse {{engineering is}} accomplished using specific tools that, for the 32 -bit Microsoft Windows environment, are categorized as hex editors, disassemblers/debuggers, decompilers, or related technologies such as code obfuscators, <b>unpackers,</b> and PE editors. An evaluation of each tool is provided that identifies its domain of applicability and usability...|$|R
40|$|Abstract—Every day {{thousands}} of malware are released on-line. The {{vast majority of}} these malware employ some kind of obfuscation ranging from simple XOR encryption, to more sophisticated anti-analysis, packing and encryption techniques. Universal <b>unpackers</b> or code emulation systems can unpack the file and reveal its hidden code. However, these methods are very time consuming when compared to static analysis. Moreover, considering {{the large amount of}} new malware being produced daily, it is not practical to solely depend on dynamic analysis methods. Therefore, finding a way to filter the samples and delegate only obfuscated and suspicious ones to more rigorous tests would significantly improve the overall scanning process. In this paper, we show that entropy-based detection for encrypte...|$|R
40|$|Malware is a {{pervasive}} problem in both personal computing devices and distributed computing systems. Identification of malware variants {{and their families}} others a great benefit in early detection resulting in a reduction of the analyses time needed. In order to classify malware, most of the current approaches {{are based on the}} analysis of the unpacked and unencrypted binaries. However, most of the unpacking solutions in the literature have a low unpacking rate. This results in a low contribution towards the identification of transferred code and re-used code. To develop a new malware analysis solution based on clusters of binary code sections, it is required to focus on increasing of the unpacking rate of malware samples to extend the underlying code database. In this paper, we present a new approach of analysing malware by integrating Ether <b>Unpacker</b> into the plugin-based malware analysis tool, Ragpicker. We also evaluate our approach against real-world malware patterns...|$|E
40|$|International audienceThere is an {{increasing}} interest in Graphics Processing Units for general-purpose programming, due to their processing power and massively parallel design. Therefore, most consumer graphics hardware are now fully programmable using either Nvidia's CUDA toolkit or AMD/ATI Stream SDK. This presentation will give an analysis of how the GPU {{can be used by}} malware as an anti-reverse engineering platform, with examples using the CUDA technology. With CUDA, the GPU is fully programmable in C, but the resulting device program can't be debugged because Nvidia's GPUs do not support this feature natively. As a result, a malware analyst has to use static analysis against the device code {{in order to understand the}} malware. But this task is harder with GPU code than with traditional binaries since the source of a CUDA program is compiled to undocumented microcode (and therefore unsupported by standard disassemblers such as IDA Pro). Finally, this presentation will also assess the technical feasability of an <b>unpacker</b> written fully in device code...|$|E
40|$|Packing an {{executable}} originally {{referred to}} the compression of the file to reduce its size on disk. Nowadays, packing also introduces encryption and anti-debug techniques to protect executables from reverse engineering. This explains why packers are extensively used in creating new malware variants which are not detected by traditional signature-based anti-malware tools. Although universal unpackers exist for extracting the executable code from packed files, they often rely on methods based on dynamic analysis, thus making them computationally expensive and time consuming. Hence, {{it is important to}} detect packed executables beforehand to avoid unnecessary computations so that only protected executables need be sent to the <b>unpacker</b> before further analysis. In this paper, we propose a new technique for fast identification of packed executables by analyzing only the raw binary data. We extract bigram-based features on packed and unpacked executables and use a support vector machine for training and testing. Experimental results reveal that we are able to correctly identify packed executables with a high detection rate in the range of 95 %- 98 % for a variety of packers and crypters...|$|E
40|$|Analyzing and {{detection}} of “malicious software ” (malware), such as viruses, worms and botnet clients, whether fully automated or human assisted {{is a critical}} step in defending against the threat such malware poses. The challenge will be more when malware writers misuse the novel idea of software packing, to bypass detection from malware analyzers and antivirus software. As a matter of fact, nowadays 80 % malware is often transmitted in packed or encrypted form to prevent examination by anti-virus software [1]. To analyze new malware, researchers typically resort to automatic and dynamic code analysis techniques to unpack the code for examination. Unfortunately, these dynamic techniques are susceptible {{to a variety of}} anti-monitoring defenses, as well as “time bombs ” or “logic bombs, ” which can be slow and tedious to identify and disable. This thesis work, compares and benchmark currently existing automatic malware unpacking techniques, and explores new approaches to design automated malware <b>unpackers.</b> It basically starts by assessing research works related to malware analysis and detection, and focus on packed malware analysis techniques...|$|R
40|$|Malware lineage {{studies the}} {{evolutionary}} relationships among malware and has important applications for malware analysis. A persistent limitation of prior malware lineage approaches {{is to consider}} every input sample a separate malware version. This is problematic since a majority of malware are packed and the packing process produces many polymorphic variants (i. e., executables with different file hash) of the same malware version. Thus, many samples correspond to the same malware version and {{it is challenging to}} identify distinct malware versions from polymorphic variants. This problem does not manifest in prior malware lineage approaches because they work on synthetic malware, malware that are not packed, or packed malware for which <b>unpackers</b> are available. In this work, we propose a novel malware lineage approach that works on malware samples collected in the wild. Given a set of malware executables from the same family, for which no source code is available and which may be packed, our approach produces a lineage graph where nodes are versions of the family and edges describe the relationships between versions. To enable our malware lineage approach, we propose the first technique to identify the versions of a malware family and a scalable code indexing technique for determining shared functions between any pair of input samples. We have evaluated the accuracy of our approach on 13 open-source programs and have applied it to produce lineage graphs for 10 popular malware families. Our malware lineage graphs achieve on average a 26 times reduction from number of input samples to number of versions...|$|R
40|$|In {{almost all}} cases of today's {{malicious}} software, executable packers or-crypters {{are used in}} order to obfuscate code and data. In some cases <b>unpackers</b> and dumpers are available. In very few cases they actually work on packed malware executables due to modifications of internal structures such as the PE header. In the following example an unknown binary is loaded into IDA Pro 1. The code at the entry point of the executable looks like this: Fig. 1 A segment named “UPX 1 ”, an invalid import address table and an empty list of strings are an indicator for a packed file. UPX 2 however, can not unpack the file because internal structures have been modified. This technique often is used by malware authors to make unpacking and reverse engineering harder. The first step now is to obtain a readable representation of the packed executable. A good and quick start in achieving this is to run the executable and dump the previously packed segment(s), once they have been unpacked. Preferably, the dump should be made right after the executable has been completely unpacked in memory. This often is the case after the original entry point (OEP) has been reached. Finding the OEP isn't always trivial and can be a time consuming process because you need to single step through the code. Using the IDA Pro SDK, a plugin named EPF 3 (Entry Point Finder) has been created, aimed towards automating the process of finding the original entry point. An isolated environment (a virtual machine for example) is used to carefully Fig. 2 run the executable in IDA Pro's debugger. Figure 2 shows the extended instruction pointer (EIP) pointing to a “pusha ” mnemonic. This statement is used as the first instruction to “back up ” the content of all standard registers. Many executable compressors use a “popa ” instruction {{at the end of}} their code to restore the previously saved state. This behavior can be exploited by the EPF plugin; the plugin offers an option to let the IDA Pro debugger trace code until a specific mnemonic is reached. Fig. 3 After the EPF plugin has been started and configured, the process can be resumed (be careful, don't run malware on your host system!). After a few seconds, the process is paused and EPF turned off. The following message appears: Fig. 4 The code at EIP points to a “popa ” mnemonic followed by a jump and the end o...|$|R
40|$|Abstract—Retargetable machine-code {{decompilation}} is {{used for}} a platform-independent transformation of executable files into a high level language (HLL) representation (e. g., C language). It is a complex task that must deal {{with a lot of}} different platform-specific features and missing information. Accurate preprocessing of input executable files is one of the necessary prerequisites in order to achieve the best results. Furthermore, we can use gathered information to achieve higher quality of decompila-tion. This paper presents an extended version of our previous system for an accurate code preprocessing. It is implemented as a generic preprocessing system that consists of a precise compiler and packer detector, plugin-based <b>unpacker,</b> converter into an internal platform-independent file format, and debugging information gathering library. We also describe an utilization of the collected information in a problem of automatic data-type reconstruction. This system has been adopted and tested in an existing retargetable decompiler. According to our experimental results, the proposed retargetable solution is fully competitive with existing platform-dependent tools. Keywords–reverse engineering, decompilation, packer detection, unpacking, executable file, Lissom...|$|E
30|$|G. Suarez-Tangil et al.’s work (2016) {{proposes to}} analyze the {{behavioral}} differences be- tween the original app and some automatically repackaged versions of it, however, when a new variant was packed by an unknown tool, their approach can no longer work because it has not analyzed the differences yet. Z. Shehu et al.’s work (2016) proposes to compute a execution fingerprint of an obfuscated app, and compare it to an available database of fingerprints of known malwares to discover possible matches, however, this matches can be easily confused by varied packers and benigns. J. Calvet et al.’s work (2012) proposes a method for identifying cryptographic functions, K. Coogan et al.’s work (2009) proposes to identify the transition points in the code where execution transitions from <b>unpacker</b> code to the unpacked code, P. Royal et al.’s work (2006) proposes a tool named PolyUnpacker which observes the sequences of packed or hidden code in a malware can be made self-identifying when its runtime execution is checked against its static code model. However, these unpacking techniques cannot always be helpful since not all packers can be unpacked.|$|E
40|$|In this work, {{we propose}} Malware Collection Booster (McBoost), a fast {{statistical}} malware detection tool that {{is intended to}} improve the scalability of existing malware collection and analysis approaches. Given a large collection of binaries that may contain both hitherto unknown malware and benign executables, McBoost reduces the overall time of analysis by classifying and filtering out the least suspicious binaries and passing only the most suspicious ones to a detailed binary analysis process for signature extraction. The McBoost framework consists of a classifier specialized in detecting whether an executable is packed or not, a universal <b>unpacker</b> based on dynamic binary analysis, and a classifier specialized in distinguishing between malicious or benign code. We developed a proof-of-concept version of McBoost and evaluated it on 5, 586 malware and 2, 258 benign programs. McBoost has an accuracy of 87. 3 %, and an Area Under the ROC curve (AUC) equal to 0. 977. Our evaluation also shows that McBoost reduces the overall time of analysis to only a fraction (e. g., 13. 4 %) of the computation time {{that would otherwise be}} required to analyze large sets of mixed malicious and benign executables. ...|$|E
40|$|This thesis {{presents}} {{the development and}} test of a free-streaming readout chain for the Time of Flight (TOF) Wall of the Compressed Baryonic Matter (CBM) experiment. In order {{to contribute to the}} exploration of the phase diagram of strongly interacting matter, CBM aims at the measurement of rare probes, whose yields and phase space distributions are significantly influenced by their environment. Many of the possible signals, of which the antiprotons was investigated within this thesis, require an excellent Particle Identification (PID) and a new readout paradigm called free-streaming. In CBM, the PID for charged particles is provided by a TOF wall based on Multi-gap Resistive Plate Chambers (MRPC). Within the thesis, a central component of the TOF readout chain, the free-streaming ASIC-TDC, was evaluated and pushed from the prototype level to a close to final design, for which it could be demonstrated that it fulfill all the CBM requirements: resolution, rate capability and stability. Additionally, the CBM TOF software in the CBMROOT software framework was reorganized to merge the processing and analysis of real and simulated data. A data <b>unpacker</b> and a realistic digitizer were implemented with a common output data format. The digitizer was used to estimate the data rates and number of components in a free-streaming readout chain for the full wall...|$|E
40|$|Abstract — The attackers do {{not want}} their Malicious {{software}} (or malwares) to be reviled by anti-virus analyzer. In order to conceal their malware, malware programmers are getting utilize the anti reverse engineering techniques and code changing techniques such as the packing, encoding and encryption techniques. Malware writers have learned that signature based detectors can be easily evaded by “packing ” the malicious payload in layers of compression or encryption. State-of-the-art malware detectors have adopted both static and dynamic techniques to recover the payload of packed malware, but unfortunately such techniques are highly ineffective. If the malware is packed or encrypted, then {{it is very difficult}} to analyze. Therefore, to prevent the harmful effects of malware and to generate signatures for malware detection, the packed and encrypted executable codes must initially be unpacked. The first step of unpacking is to detect the packed executable files. The objective is to efficiently and accurately distinguish between packed and non-packed executables, so that only executables detected as packed will be sent to an general <b>unpacker,</b> thus saving a significant amount of processing time. The generic method of this paper show that it achieves very high detection accuracy of packed executables with a low average processing time. In this paper, a packed file detection technique based on complexity measured by several algorithms, and it has tested using a packed and unpacked dataset of file type. exe. The preliminary results are very promising where achieved high accuracy with enough performance. Where it achieved about 96 % detection rate on packed files and 93 % detection rate on unpacked files. The experiments also demonstrate that this generic technique can effectively prepared to detect unknown, obfuscated malware and cannot be evaded by known evade techniques. without the capacity of detecting the new unknown virus, the virus deformation, and packed virus. Among these techniques, executable packing is the most common due to the availability of several open source and commercial executable packer...|$|E
40|$|Code {{obfuscation}} {{techniques are}} increasingly being used in software for such reasons as protecting trade secret algorithms from competitors and deterring license tampering by those wishing to use the software for free. However, these techniques have also grown in popularity in less legitimate areas, such as protecting malware from detection and reverse engineering. This work examines two such techniques - packing and virtualization-obfuscation - and presents new behavioral approaches to analysis that may be relevant to security analysts {{whose job it is}} to defend against malicious code. These approaches are robust against variations in obfuscation algorithms, such as changing encryption keys or virtual instruction byte code. Packing refers to the process of encrypting or compressing an executable file. This process "scrambles" the bytes of the executable so that byte-signature matching algorithms commonly used by anti-virus programs are ineffective. Standard static analysis techniques are similarly ineffective since the actual byte code of the program is hidden until after the program is executed. Dynamic analysis approaches exist, but are vulnerable to dynamic defenses. We detail a static analysis technique that starts by identifying the code used to "unpack" the executable, then uses this <b>unpacker</b> to generate the unpacked code in a form suitable for static analysis. Results show we are able to correctly unpack several encrypted and compressed malware, while still handling several dynamic defenses. Virtualization-obfuscation is a technique that translates the original program into virtual instructions, then builds a customized virtual machine for these instructions. As with packing, the byte-signature of the original program is destroyed. Furthermore, static analysis of the obfuscated program reveals only the structure of the virtual machine, and dynamic analysis produces a dynamic trace where original program instructions are intermixed, and often indistinguishable from, virtual machine instructions. We present a dynamic analysis approach whereby all instructions that affect the external behavior of the program are identified, thus building an approximation of the original program that is observationally equivalent. We achieve good results at both identifying instructions from the original program, as well as eliminating instructions known to be part of the virtual machine...|$|E

