10|10000|Public
50|$|Apple Dylan {{includes}} a user interface framework, written in Dylan by Mike Lockwood. The framework is tightly integrated with a WYSIWYG interface builder code-named Meccano, written by Robin Mair. The interface builder is linked into an application, allowing users to switch between Edit and Run modes while the application is running. “Decorators” are represented as graphical objects {{that can be}} dragged onto a <b>user</b> <b>interface</b> <b>object</b> to modify its behavior or appearance via object composition.|$|E
40|$|Recently, {{computers}} {{have been widely}} used in almost all fields of education. Our approach to computer aided education is mainly concerned with programming. Here, it is intended to teach the Pascal language for problem solving in a visual manner. In this project, we have used an object oriented approach for the implementation of an educational tool for programming. The paper mainly discusses the topics related to computer aided education, <b>user</b> <b>interface,</b> <b>object</b> oriented programming and ongoing research related to the project. © 1989...|$|E
40|$|Abstract — The {{fundamental}} unit of large scale software construction is the component. A component {{is the fundamental}} <b>user</b> <b>interface</b> <b>object</b> in Java. Everything {{you see on the}} display in a java application is a component. The ability to let users drag a component from the Interface and drop into your application is almost a requirement of a modern, commercial user interface. The CBD approach brings high component reusability and easy maintainability, and reduces time-to-market. This paper describes the component repository which provides functionality for component reuse process through the drag and drop mechanism and it’s influences on the reusable components [...] (Abstract...|$|E
50|$|Interface Builder {{provides}} palettes, or collections, of <b>user</b> <b>interface</b> <b>objects</b> to an Objective-C developer. These <b>user</b> <b>interface</b> <b>objects</b> contain {{items like}} text fields, data tables, sliders, and pop-up menus. Interface Builder's palettes are completely extensible, meaning any developer can develop new objects and add palettes to Interface Builder.|$|R
5000|$|<b>User</b> <b>interface</b> <b>objects</b> {{should not}} know about the embellishments ...|$|R
5000|$|In {{the context}} of what users are trying to do, all the <b>user</b> <b>interface</b> <b>objects</b> fit {{together}} into a coherent overall representation.|$|R
40|$|This article {{introduces}} a novel human computer interaction device, {{developed in the}} scope of a Master’s Thesis. The device allows continuous localized interaction by providing a malleable interaction surface. Diverse multi-finger as well as multi-handed manipulations can be applied. Furthermore, the device acts as a tangible <b>user</b> <b>interface</b> <b>object,</b> integrated into a tangible comput-ing framework called tDesk. Software to convert the malleable element’s shape into an internal surface representation has been developed. Malleable interactions are applied to a new Model-based Sonification approach for exploratory data analysis. High-dimensional data are acoustically explored via their informative interaction sound in result to the user’s excitation...|$|E
40|$|A two {{dimensional}} demonstration program, GAS, {{has been developed}} for the solution of landfill gas (LFG) flow problems on a personal computer (PC). The program combines a Windows™ graphical <b>user</b> <b>interface,</b> <b>object</b> oriented programming (OOP) techniques, and finite element modeling (FEM) to demonstrate the practicality of performing LFG flow modeling on the PC. GAS is demonstrated on a sample LFG problem consisting of a landfill, one gas extraction well, the landfill liner, cap, and surrounding soil. Analyses of the program results are performed for successively finer grid resolutions. Element flux imbalance, execution time, and required memory are characterized {{as a function of}} grid resolution...|$|E
40|$|The {{fundamental}} unit of large scale software construction is the component. A component {{is the fundamental}} <b>user</b> <b>interface</b> <b>object</b> in Java. Everything {{you see on the}} display in a java application is a component. The ability to let users drag a component from the Interface and drop into your application is almost a requirement of a modern, commercial user interface. The CBD approach brings high component reusability and easy maintainability, and reduces time-to-market. This paper describes the component repository which provides functionality for component reuse process through the drag and drop mechanism and it's influences on the reusable componentsComment: 8 pages, 6 figures, International Journal on Computer Science and Engineering (IJCSE...|$|E
5000|$|Microsoft.MSAGL.Drawing.dll, a device-independent {{implementation}} of graphs as graphical <b>user</b> <b>interface</b> <b>objects,</b> {{with all kinds}} of graphical attributes, and support for interface events such as mouse actions; ...|$|R
5000|$|Data Director Toolkit: Ideal for the Human Factors and Prototyping communities, this toolkit connects {{multiple}} data sources, such as math models or simulation data, to <b>user</b> <b>interface</b> <b>objects</b> with no programming ...|$|R
50|$|HPE Unified Functional Testing may not {{recognize}} customized <b>user</b> <b>interface</b> <b>objects</b> and other complex objects. Users can define {{these types of}} objects as virtual objects. HPE Unified Functional Testing does not support virtual objects for analog recording or recording in low-level mode.|$|R
40|$|Presented at the 12 th International Conference on Auditory Display (ICAD), London, UK, June 20 - 23, 2006. This article {{introduces}} a novel human computer interaction device, {{developed in the}} scope of a Master's Thesis. The device allows continuous localized interaction by providing a malleable interaction surface. Diverse multi-finger as well as multi-handed manipulations can be applied. Furthermore, the device acts as a tangible <b>user</b> <b>interface</b> <b>object,</b> integrated into a tangible computing framework called tDesk. Software to convert the malleable element's shape into an internal surface representation has been developed. Malleable interactions are applied to a new Modelbased Sonification approach for exploratory data analysis. Highdimensional data are acoustically explored via their informative interaction sound in result to the user's excitation...|$|E
40|$|Object-Oriented {{design is}} viewed as a {{promising}} approach for handing a wide variety of design problems. However, little work has been done to date on developing object-oriented design systems that can handle a variety of design problems. This paper describes an Object-Oriented Design System (OODS) that uses an object-oriented formalism called Design with Objects (DwO). The background to DwO is described including the DwO design model, the other design objects in DwO, the use of DwO methods and the resulting design process OODS: AN OBJECT-ORIENTED DESIGN SYSTEM – AN EXAMPLE OF ELECTRONICS ASSEMBLIES models. The decomposition of objects in OODS is then described, followed by a description of the configuration system object and the <b>user</b> <b>interface</b> <b>object.</b> The implementation of OODS is then detailed. This implementation uses the Internet to communicate between OODS and users, and with databases that may be geographically scattered. The uses of OODS is illustrated by a description of an example application that involves the design of electronics assemblies. The contributions of this paper are threefold. First, a new object-oriented design formalism is presented. Second, an implementation architecture for this formalism is described, and, third, an example application is presented showing how this approach can be used. 1...|$|E
40|$|Component {{technology}} {{can provide the}} reuse option to the end user given a workable model and implementation platform. Figure 1. Gentle slope to customization in a drawing program. Direct activation is accomplished by holding down a modifier key while performing the normal interaction gesture on a <b>user</b> <b>interface</b> <b>object.</b> All components (menus, menu items, and graphical shapes) can be customized in the same uniform way. The saved data is stored in an initialization file and reinstated when the program is restarted [5]. Figure 2. The application here allows the user to search for documents in different sections of a groupware. In tailoring mode both visual and non-visual components are displayed. These components can be grouped into assemblies and integrated by connecting input and output ports. Empty circles indicate input ports and filled circles indicate output ports. Figure 3. The TailorClient allows for modifying a composition in three different views. The upper view displays only the visual components and allows for resizing and positioning them. The other views present the interaction between components (bottom right) and an abstract tree view of the nesting structure (bottom left). The views are all synchronized, meaning any change made to the composition in either of the views is immediately updated in the other views. 1 The FlexiBeans component model is based on JavaBeans. Extensions were made in order to incorporate the specific requirements of EUD. For instance, the FlexiBeans component model allows for typed and named event-based communication. Furthermore, an additional pull mechanism has been created to render the composition of component...|$|E
25|$|Some environments use {{the methods}} of 3D {{graphics}} to project virtual three dimensional <b>user</b> <b>interface</b> <b>objects</b> onto the screen. These are often shown in use in science fiction films (see below for examples). As the processing power of computer graphics hardware increases, this becomes less of an obstacle to a smooth user experience.|$|R
40|$|This paper {{describes}} {{the design and}} implementation of the <b>user</b> <b>interface</b> for a prototype immersive VRML 2 browser, with particular reference to the planning and viewpoint movement aspects of navigation in the virtual environment. Rather than being hard-coded in the browser, the <b>user</b> <b>interface</b> <b>objects</b> are part of the virtual environment itself (i. e. stored in the VRML scene graph). Advantages of this “first-class <b>user</b> <b>interface</b> ” are described, and implications for an open, extensible approach to <b>user</b> <b>interface</b> evolution and browser implementation are considered...|$|R
40|$|We have {{augmented}} <b>user</b> <b>interface</b> <b>objects</b> (i. e. windows, menus, buttons, sliders, etc.) with preconditions {{that determine}} their visibility and their enabled/disabled status and postconditions that are asserted when certain actions are {{performed on the}} object. Postconditions are associated with each functionally different action on the object. Attaching pre- and postconditions to <b>interface</b> <b>objects</b> provides several useful features, such as selective enabling of controls, rapid prototyping, and automatic generation of explanations and help text...|$|R
40|$|This {{paper is}} {{organized}} as follows. Section 2 presents the framework idea and {{the technical aspects}} of framework-based software development. In section 3, we lead through a scenario showing how a financial institution might tackle its software needs for supporting financial instruments trading. Simply adopting the techniques and technical guidelines associated with framework-based development will not make use of the full potential of the approach. What is needed are radical changes in the way software development is organized, managed and valued. This is the issue of Section 4. Section 5 summarizes the cornerstones of framework-base development. - 13 - 2 Technical Aspects of Frameworks An object-oriented system is a society of objects. A designer distributes required functionality among cooperating objects. If a task is sufficiently complex it is implemented by several objects working together as a team. In such a system, each member has its assigned role. Objects collaborate by sending messages to one another. The set of messages that an object understands is called its protocol. For example, a <b>user</b> <b>interface</b> <b>object</b> might ask a password broker object whether the character sequence the user just typed in is a valid password. The password broker object may not have enough data on its own to answer this request, but it knows of a few password database objects. One of them will certainly have an answer. 2. 1 Frameworks Every software system has functionality that is specific with respect to the problem it tries to solve. However, looking at several applications at once we also find that they have some functionality (or set of roles) in common. This recurring functionality is termed the generic part of an application. The functionality needed to provide one particular sol [...] ...|$|E
50|$|The KNM server {{contains}} the configuration and <b>user</b> <b>interface.</b> Remote <b>objects</b> are managed {{the same way}} as locally tested objects to simplify administration.|$|R
40|$|<b>User</b> <b>interfaces</b> {{that allow}} the direct {{manipulation}} of conceptual objects with adequate semantic feedback are not sufficiently supported by the <b>user</b> <b>interface</b> tools of today. We have designed a layered architecture for <b>user</b> <b>interface</b> <b>objects</b> based upon {{the definition of a}} three dimensional object space for object manipulation. In this space the usual user centered events are replaced by a logical manipulation "feel" which is symmetrically applied from one object to another. We also consider the consequences of having multiple views of one object in such anobject space. An example class definition in C++ gives an example of how to work with our objects...|$|R
40|$|One of {{the main}} tasks in {{developing}} distributed collaborative systems is to support synchronization processes. The Coupled Objects paradigm {{has emerged as a}} way to easily support these processes by dynamically coupling arbitrary <b>user</b> <b>interface</b> <b>objects</b> between heterogeneous applications. In this article we present an architecture for developing distributed collaborative applications using HTML 5 and show its usage through the design and implementation of a series of collaborative systems in different scenarios. The experience of developing and using this architecture has shown that it is easy to use, robust and has good performance...|$|R
50|$|A major {{update to}} Max/MSP/Jitter, Max 5, was {{released}} in 2008. It included a revamped <b>user</b> <b>interface</b> and new <b>objects.</b>|$|R
40|$|The central {{research}} issue {{addressed by}} {{this paper is}} how we can design computer interfaces that better support human attention and better maintain the fluency of work. To accomplish this we propose to use semi-transparent <b>user</b> <b>interface</b> <b>objects.</b> This paper reports on an experimental evaluation which provides both valuable insights into design parameters and suggests a systematic evaluation methodology. For this study, we used a variablytransparent tool palette superimposed over different background content, combining text, wire-frame or line art images, and solid images. The experiment explores the issue of focused attention and interference, by varying both visual distinctiveness and levels of transparency...|$|R
40|$|The Dirt 1 <b>user</b> <b>interface</b> builder {{provides}} an interactive {{editor for the}} rapid-prototyping and iterative development of <b>user</b> <b>interfaces</b> using the Xt Toolkit under the X Window System 2. <b>User</b> <b>interfaces</b> are created interactively by the direct manipulation of <b>user</b> <b>interface</b> <b>objects</b> (also called Widgets) such as push buttons, menus and scroll bars. Each object contains attributes (or resources) that describe its look and feel; these attributes are also modified interactively. Whilst building a <b>user</b> <b>interface</b> using Dirt the designer can use objects are soon as he creates them. This encourages exploration of the available objects. Dirt generates all the source code required for the designed <b>user</b> <b>interface</b> and separates the <b>user</b> <b>interface</b> definition from the application code. Collections of objects can be created as Templates, allowing generic dialog boxes etc. to be developed and copied into interfaces. This {{can be used to}} promote a consistent design style and allow design reu [...] ...|$|R
40|$|In {{this paper}} we {{investigate}} {{the use of}} scene graphs as a general approach for implementing two-dimensional (2 D) graphical applications, and in particular Zoomable <b>User</b> <b>Interfaces</b> (ZUIs). Scene graphs are typically found in three-dimensional (3 D) graphics packages such as Sun's Java 3 D and SGI's OpenInventor. They have not been widely adopted by 2 D graphical <b>user</b> <b>interface</b> toolkits. To explore the effectiveness of scene graph techniques, we have developed Jazz, a general-purpose 2 D scene graph toolkit. Jazz is implemented in Java using Java 2 D, and runs on all platforms that support Java 2. This paper describes Jazz and the lessons we learned using Jazz for ZUIs. It also discusses how 2 D scene graphs {{can be applied to}} other application areas. Keywords Zoomable <b>User</b> <b>Interfaces</b> (ZUIs), Animation, Graphics, <b>User</b> <b>Interface</b> Management Systems (UIMS), Pad++, Jazz. INTRODUCTION Today's Graphical <b>User</b> <b>Interface</b> (GUI) toolkits contain a wide range of built-in <b>user</b> <b>interface</b> <b>objects</b> (also kno [...] ...|$|R
40|$|This paper {{describes}} {{the design and}} implementation of the <b>user</b> <b>interface</b> for a prototype immersive VRML 2 browser, with particular reference to the planning and viewpoint movement aspects of navigation in the virtual environment. Rather than being hard-coded in the browser, the <b>user</b> <b>interface</b> <b>objects</b> are part of the virtual environment itself (i. e. stored in the VRML scene graph). Advantages of this "first-class user interface" are described, and implications for an open, extensible approach to <b>user</b> <b>interface</b> evolution and browser implementation are considered. KEYWORDS VRML 2; immersive browser; first-class user interface; navigation techniques; <b>user</b> <b>interface</b> metaphors. 1. INTRODUCTION While the VRML specification and the browsers which implement it have both evolved rapidly {{over the past couple of}} years, the 2 D mouse-based interaction techniques typically provided by browsers are still considered unsatisfactory by many users. Moreover, when we turn to the problem of creating a brow [...] ...|$|R
40|$|Redisplay after {{a change}} to {{an object in}} a {{traditional}} structured graphics environment only affects the modified object and any objects that intersect it on the screen. For <b>user</b> <b>interface</b> components such as Xt widgets, redisplay may involve recomputing the layout of other <b>user</b> <b>interface</b> <b>objects.</b> Fresco unifies structured graphics and <b>user</b> <b>interface</b> components under a common base abstraction, which provides a simple, powerful model but complicates the redisplay problem. As part of the Fresco implementation, we have implemented a general redisplay algorithm that recomputes layout when necessary but minimizes the cost of performing transformations when updating a structured graphics hierarchy. Our implementation can also run redisplay as a separate thread, allowing independent application threads to trigger screen update. Introduction Fresco is a <b>user</b> <b>interface</b> system that has three distinguishing features with respect to Xt and many other systems. First, the Fresco specification uses a [...] ...|$|R
50|$|There {{are several}} ways <b>users</b> learn <b>interface</b> <b>objects</b> and actions such as demonstrations, sessions, or trial and error sessions. When these objects and actions have logical {{structure}} that {{can be related to}} other familiar task objects and actions, this knowledge becomes stable in the user's memory.|$|R
40|$|We have {{augmented}} <b>user</b> <b>interface</b> <b>objects</b> (i. e. windows, menus, buttons, sliders, etc.) with preconditions {{that determine}} their visibility and their enabled/disabled status and postconditions that are asserted when certain actions are {{performed on the}} object. Postconditions are associated with each functionally different action on the object. Attaching pre- and postconditions to <b>interface</b> <b>objects</b> provides several useful features, such as selective enabling of controls, rapid prototyping, and automatic generation of explanations and help text. Introduction Several techniques {{can be used to}} describe the dialogue of an application. Some of the best known techniques are transition diagrams, grammars and event languages. As discussed by Green [GREE 86], the event model has a greater descriptive power than the former two. A particularly useful form of the event model is to associate pre- and postconditions with dialogue components (actions and/or <b>interface</b> <b>objects).</b> The preconditions of a dia [...] ...|$|R
40|$|Interactive {{applications}} on the World-Wide Web {{are supported}} by the CGI interface, which allows transferring information from the browser to programs invoked by the server. Information is obtained through fillout forms embedded in documents written in the HTML language and rendered by the browser as collections of <b>user</b> <b>interface</b> <b>objects.</b> While the World-Wide Web {{is based on the}} stateless HTTP protocol, state can be simulated by encoding it in the information transmitted between browser and server. Many interactive applications have a finite number of states and perform state transitions based on the user's response. Finite state machines are a suitable modeling technique for <b>user</b> <b>interfaces</b> of such applications. We are developing W++, an object-oriented application framework that assists in writing interactive, state-based web applications. The framework consists of classes for applications, states, and <b>user</b> <b>interface</b> components. Keywords World-Wide Web; HTML forms; CGI programs; int [...] ...|$|R
40|$|Abstract: This paper {{presents}} {{an approach to}} model business processes and associated <b>user</b> <b>interfaces</b> in a declarative way, relying on constraints. An UML-based meta-model to define processes, activities and user-interface objects is proposed. Connecting activities and <b>user</b> <b>interface</b> <b>objects</b> in an integrated model allows expressing interdependencies and mutual effects. Flexible execution logic for workflows and UI control flows are specified by OCL invariants. The model is constructed for the UML tool USE. Using object snapshots, USE can animate and validate business scenarios. Snapshots represent states of a process and a UI at specific times. Such animation enables business process and UI designers to discuss sensible scenarios on basis of the flexible declarative models. The intention is to create validated concrete process models in connection with UI elements that will {{provide a basis for}} the system implementation...|$|R
50|$|There is an {{overlap with}} the naked objects pattern, in that both are {{concerned}} with creating generic <b>interfaces</b> to domain <b>objects</b> models. But while the latter creates some kind of <b>user</b> <b>interface,</b> Restful <b>Objects</b> creates an API - specifically a Restful API. The first two frameworks to implement the Restful Objects standard were both built on top of existing frameworks that implement the Naked Objects pattern.|$|R
50|$|Tapestry {{emphasizes}} simplicity, ease of use, and developer productivity. It {{adheres to}} the Convention over Configuration paradigm, eliminating almost all XML configuration. Tapestry uses a modular approach to web development, {{by having a}} strong binding between each <b>user</b> <b>interface</b> component (<b>object)</b> on the web page and its corresponding Java class. This component-based architecture borrows many ideas from WebObjects.|$|R
5000|$|The CUA {{guidelines}} {{stated that}} 'In an object-oriented <b>user</b> <b>interface,</b> the <b>objects</b> that a user works with {{do not necessarily}} correspond to the objects, or modules of code, that a programmer used to create the product.' [...] The basic design methods described in CUA were refined further into the OVID method which used UML to model the interface.|$|R
50|$|Zooming <b>User</b> <b>Interface</b> - Some <b>objects</b> {{drawn on}} the canvas adjust their display based on the zoom-level. This results in a less {{detailed}} view when zoomed out and additional information when zoomed in.|$|R
