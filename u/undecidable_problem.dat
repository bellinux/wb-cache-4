162|259|Public
25|$|A {{real number}} is called computable if there exists an {{algorithm}} that yields its digits. Because {{there are only}} countably many algorithms, but an uncountable number of reals, almost all real numbers fail to be computable. Moreover, the equality of two computable numbers is an <b>undecidable</b> <b>problem.</b> Some constructivists accept the existence of only those reals that are computable. The set of definable numbers is broader, but still only countable.|$|E
25|$|A {{reduction}} can {{be demonstrated}} to this problem from the well-known <b>undecidable</b> <b>problem</b> of determining whether a Turing machine accepts a particular input (the halting problem). The reduction uses {{the concept of a}} computation history, a string describing an entire computation of a Turing machine. A CFG can be constructed that generates all strings that are not accepting computation histories for a particular Turing machine on a particular input, and thus it will accept all strings only if the machine doesn't accept that input.|$|E
2500|$|The typical {{method of}} proving {{a problem to}} be {{undecidable}} is with the technique of reduction. [...] To do this, it is sufficient to show that if {{a solution to the}} new problem were found, it could be used to decide an <b>undecidable</b> <b>problem</b> by transforming instances of the <b>undecidable</b> <b>problem</b> into instances of the new problem. [...] Since we already know that no method can decide the old problem, no method can decide the new problem either. Often the new problem is reduced to solving the halting problem. (Note: the same technique is used to demonstrate that a problem is NP complete, only in this case, rather than demonstrating that there is no solution, it demonstrates there is no polynomial time solution, assuming P ≠ NP).|$|E
50|$|Many, if {{not most}} all, <b>undecidable</b> <b>problems</b> in {{mathematics}} can be posed as word problems; see the list of <b>undecidable</b> <b>problems</b> for many examples.|$|R
50|$|<b>Undecidable</b> <b>problems</b> can {{be related}} to {{different}} topics, such as logic, abstract machines or topology. Note that since there are uncountably many <b>undecidable</b> <b>problems,</b> any list, even one of infinite length, is necessarily incomplete.|$|R
50|$|The halting {{problem is}} an {{important}} undecidable decision problem; for more examples, see list of <b>undecidable</b> <b>problems.</b>|$|R
2500|$|Hilbert's {{problem is}} not {{concerned}} with finding the solutions. It only asks whether, in general, we can decide whether one or more solutions exist. The {{answer to this question}} is negative, in the sense that no [...] "process can be devised" [...] for answering that question. In modern terms, Hilbert's 10th problem is an <b>undecidable</b> <b>problem.</b> Although it is unlikely that Hilbert had conceived of such a possibility, before going on to list the problems, he did presciently remark: ...|$|E
2500|$|Although quantum {{computers}} may {{be faster}} than classical computers for some problem types, those described above can't solve any problem that classical computers can't already solve. A Turing machine can simulate these quantum computers, so such a quantum computer could never solve an <b>undecidable</b> <b>problem</b> like the halting problem. The existence of [...] "standard" [...] quantum computers does not disprove the Church–Turing thesis. It {{has been speculated}} that theories of quantum gravity, such as M-theory or loop quantum gravity, may allow even faster computers to be built. Currently, defining computation in such theories is an open problem due {{to the problem of}} time, i.e., there currently exists no obvious way to describe what it means for an observer to submit input to a computer and later receive output.|$|E
2500|$|Type safety {{contributes}} to program correctness, but can only guarantee correctness {{at the cost}} of making the type checking itself an <b>undecidable</b> <b>problem.</b> [...] In a type system with automated type checking a program may prove to run incorrectly yet be safely typed, and produce no compiler errors. Division by zero is an unsafe and incorrect operation, but a type checker running at compile time only doesn't scan for division by zero in most languages, and then it is left as a runtime error. To prove the absence of these more-general-than-types defects, other kinds of formal methods, collectively known as program analyses, are in common use. Alternatively, a sufficiently expressive type system, such as in dependently typed languages, can prevent these kinds of errors (for example, expressing the type of non-zero numbers). [...] In addition software testing is an empirical method for finding errors that the type checker cannot detect.|$|E
40|$|Recent {{work has}} {{examined}} how <b>undecidable</b> <b>problems</b> can arise in quantum information science. We augment this by introducing three new <b>undecidable</b> <b>problems</b> stated {{in terms of}} tensor networks. These relate to ideas of Penrose about the physicality of a spin-network representing a physical process, closed timelike curves, and Boolean relation theory. Seemingly slight modifications of the constraints on the topology or the tensor families generating the networks leads to problems that transition from decidable, to undecidable to even always satisfiable. Comment: 5 pages, 4 figures, RevTeX 4 -...|$|R
30|$|Unfortunately, both {{constraint}} set satisfiability and simplification are in general <b>undecidable</b> <b>problems</b> [6], {{and the use}} of computable functions for solving these problems may cause non-termination of type inference.|$|R
50|$|Higman's {{embedding}} theorem also {{implies the}} Novikov-Boone theorem (originally proved in the 1950s by other methods) {{about the existence}} of a finitely presented group with algorithmically <b>undecidable</b> word <b>problem.</b> Indeed, it is fairly easy to construct a finitely generated recursively presented group with <b>undecidable</b> word <b>problem.</b> Then any finitely presented group that contains this group as a subgroup will have <b>undecidable</b> word <b>problem</b> as well.|$|R
50|$|Note; It is an <b>undecidable</b> <b>problem</b> {{to decide}} whether a given string can be {{generated}} by a given W-grammar.|$|E
5000|$|... {{any number}} that encodes the {{solution}} of the halting problem (or any other <b>undecidable</b> <b>problem)</b> according to a chosen encoding scheme.|$|E
50|$|By {{the second}} definition, any {{decision}} {{problem can be}} shown to be decidable by exhibiting an algorithm for it that terminates on all inputs. An <b>undecidable</b> <b>problem</b> is a problem that is not decidable.|$|E
40|$|Optimization and {{decision}} problems, Reductions, Turing Machine as an acceptor {{and as an}} enumerator—Techniques of Turing Machine construction – parallel tracks and storage in control, subroutine Turing Machine, Church-Turing thesis, Variants of Turing Machine – multitape, nondeterministic—their equivalences with other models. Properties of recursively enumerable and recursive sets. Relations between unrestricted grammars and Turing Machines. Linear Bounded Automata —relation with Context Sensitive Languages Enumeration of Turing Machines, existence of <b>undecidable</b> <b>problems,</b> <b>Undecidable</b> <b>problems</b> involving Turing Machines and CFG’s. Universal Turing Machine {{as a model of}} general purpose computer, Post Correspondence Problem – Applications, valid and invalid computations of Turing Machines. Time and Space complexity of Turing Machines, NP-completeness...|$|R
40|$|It is {{well known}} that if G admits a f. g. {{subgroup}} H with a weaklyaperiodic SFT (resp. an <b>undecidable</b> domino <b>problem),</b> then Gitself has a weakly aperiodic SFT (resp. an <b>undecidable</b> domino <b>problem).</b> We prove that we can replace the property "H is a subgroup of G"by "H acts translation-like on G", provided H is finitely presented. In particular:* If G_ 1 and G_ 2 are f. g. infinite groups, then G_ 1 × G_ 2 has a weakly aperiodic SFT (and actually a <b>undecidable</b> domino <b>problem).</b> In particular the Grigorchuk group has an <b>undecidable</b> domino <b>problem.</b> * Every infinite f. g. p-group admits a weakly aperiodic SFT...|$|R
2500|$|There {{are many}} known {{examples}} of <b>undecidable</b> <b>problems</b> from ordinary mathematics. The word problem for groups was proved algorithmically unsolvable by Pyotr Novikov in 1955 and independently by W. Boone in 1959. [...] The busy beaver problem, developed by Tibor Radó in 1962, is another well-known example.|$|R
50|$|P/poly {{contains}} both P and BPP (Adlemans theorem). It {{also contains}} some undecidable problems, {{such as the}} unary version of every <b>undecidable</b> <b>problem,</b> including the halting problem. Because of that, it is not contained in DTIME (f(n)) or NTIME (f(n)) for any f.|$|E
5000|$|FIFO bounds can be mathematically derived {{in design}} to avoid FIFO overflows. This is however not {{possible}} for all KPNs. It is an <b>undecidable</b> <b>problem</b> to test whether a KPN is strictly bounded by [...] Moreover, in practical situations, the bound may be data dependent.|$|E
50|$|The typical {{method of}} proving {{a problem to}} be {{undecidable}} is with the technique of reduction. To do this, it is sufficient to show that if {{a solution to the}} new problem were found, it could be used to decide an <b>undecidable</b> <b>problem</b> by transforming instances of the <b>undecidable</b> <b>problem</b> into instances of the new problem. Since we already know that no method can decide the old problem, no method can decide the new problem either. Often the new problem is reduced to solving the halting problem. (Note: the same technique is used to demonstrate that a problem is NP complete, only in this case, rather than demonstrating that there is no solution, it demonstrates there is no polynomial time solution, assuming P ≠ NP).|$|E
40|$|The {{purpose of}} this paper is to show that for any {{positive}} integer n, there exists no algorithm which decides for each non-cooperative n-person game in strategic form with partially computable payoff functions whether it has a pure Nash equilibrium or not. Copyright Springer-Verlag Berlin/Heidelberg 2004 <b>Undecidable</b> <b>problems,</b> Non-cooperative games.,...|$|R
50|$|Some {{abstract}} {{problems have}} been rigorously proved to be unsolvable, such as squaring the circle and trisecting the angle using only the compass and straightedge constructions of classical geometry, and solving the general quintic equation algebraically. Also provably unsolvable are so-called <b>undecidable</b> <b>problems,</b> such as the halting problem for Turing machines.|$|R
40|$|A more {{extensive}} and theoretical {{treatment of the}} material in 6. 045 J/ 18. 400 J, emphasizing computability and computational complexity theory. Regular and context-free languages. Decidable and <b>undecidable</b> <b>problems,</b> reducibility, recursive function theory. Time and space measures on computation, completeness, hierarchy theorems, inherently complex problems, oracles, probabilistic computation, and interactive proof systems...|$|R
5000|$|In {{computability theory}} and {{computational}} complexity theory, an <b>undecidable</b> <b>problem</b> {{is a decision}} problem {{for which it is}} known to be impossible to construct a single algorithm that always leads to a correct yes-or-no answer. The halting problem is an example: there is no algorithm that correctly determines whether arbitrary programs eventually halt when run.|$|E
5000|$|It {{was shown}} by [...] {{that it is}} an <b>undecidable</b> <b>problem</b> to determine, given a finite {{presentation}} of a group, whether the group is Hopfian. Unlike the undecidability of many properties of groups this is not a consequence of the Adian-Rabin theorem, because Hopficity is not a Markov property, as was shown by [...]|$|E
50|$|Meanwhile, {{it became}} clear that W-grammars are indeed too powerful.They {{describe}} precisely all recursively enumerable languages, which makes parsing impossible in general: it is an <b>undecidable</b> <b>problem</b> to decide whether a given string can be generated by a given W-grammar. Their use must be seriously constrained when used for automatic parsing or translation. Restricted and modified variants of W-grammars were developed to address this, e.g.|$|E
50|$|Generic case {{complexity}} {{is similar}} to average-case complexity. However, there are some significant differences.Generic case complexity is a direct measure {{of the performance of}} an algorithm on most inputs while average case complexitygives a measure of the balance between easy and difficult instances. In addition Generic-case complexity naturally applies to <b>undecidable</b> <b>problems.</b>|$|R
50|$|Other {{topics in}} Moore's {{research}} includemodeling <b>undecidable</b> <b>problems</b> by physical systems,phase transitions in random instances of the Boolean satisfiability problem,the unlikelihood {{of success in}} the search for extraterrestrial intelligence due to the indistinguishability of advanced signaling technologies from random noise,the inability of certain types of quantum algorithm to solve graph isomorphism,and attack-resistant quantum cryptography.|$|R
25|$|The halting {{problem is}} {{historically}} {{important because it}} was one of the first problems to be proved undecidable. (Turing's proof went to press in May 1936, whereas Alonzo Church's proof of the undecidability of a problem in the lambda calculus had already been published in April 1936 (Church, 1936).) Subsequently, many other <b>undecidable</b> <b>problems</b> have been described.|$|R
50|$|A {{real number}} is called computable if there exists an {{algorithm}} that yields its digits. Because {{there are only}} countably many algorithms, but an uncountable number of reals, almost all real numbers fail to be computable. Moreover, the equality of two computable numbers is an <b>undecidable</b> <b>problem.</b> Some constructivists accept the existence of only those reals that are computable. The set of definable numbers is broader, but still only countable.|$|E
5000|$|Hilbert's {{problem is}} not {{concerned}} with finding the solutions. It only asks whether, in general, we can decide whether one or more solutions exist. The {{answer to this question}} is negative, in the sense that no [...] "process can be devised" [...] for answering that question. In modern terms, Hilbert's 10th problem is an <b>undecidable</b> <b>problem.</b> Although it is unlikely that Hilbert had conceived of such a possibility, before going on to list the problems, he did presciently remark: ...|$|E
50|$|The {{most common}} proof for the undecidability of PCP {{describes}} {{an instance of}} PCP that can simulate the computation of an arbitrary Turing machine on a particular input. A match will occur {{if and only if}} the input would be accepted by the Turing machine. Because deciding if a Turing machine will accept an input is a basic <b>undecidable</b> <b>problem,</b> PCP cannot be decidable either. The following discussion is based on Michael Sipsers textbook Introduction to the Theory of Computation.|$|E
5000|$|So-called Oracle {{machines}} {{have access}} to various [...] "oracles" [...] which provide the solution to specific <b>undecidable</b> <b>problems.</b> For example, the Turing machine may have a [...] "halting oracle" [...] which answers immediately whether a given Turing machine will ever halt on a given input. These machines are a central topic of study in recursion theory.|$|R
40|$|In this master thesis the {{hierarchy}} of automata and related languages is presented. First, the concepts, associated with recognizable and unrecognizable languages are introduced, followed by further introduction of a subclass of recognized languages; these are decidable languages. By means of decidable and undecidable languages the concept of decidable and <b>undecidable</b> <b>problems</b> was translated and strictly defined. The following examples of <b>undecidable</b> <b>problems</b> are described in detail: the Turing's halting problem, the Post correspondence problem, the busy beaver problem and the Hilbert's tenth problem. In {{the frame of the}} master thesis, a web application which is searching for concrete solutions of the Post correspondence problem, was developed. The programming environment of the application and the interpretation of the source code with instructions for its using are described in detail. An example for the usage of the application at teaching, for example in a computer club, is presented...|$|R
40|$|International audienceWe give in {{this paper}} a logical {{characterization}} for unambiguous Context Free Languages, in the vein of descriptive complexity. A fragment of the logic characterizing context free languages given by Lautemann, Schwentick and Thérien [18] based on implicit definability is used for this aim. We obtain a new connection between two <b>undecidable</b> <b>problems,</b> a logical one and a language theoretical one...|$|R
