7452|0|Public
5|$|Both type {{categories}} are extensible with <b>user-defined</b> types.|$|E
5|$|This {{situation}} improved as COBOL adopted more features. COBOL-74 added subprograms, giving programmers {{the ability}} to control the data each part of the program could access. COBOL-85 then added nested subprograms, allowing programmers to hide subprograms. Further control over data and code came in 2002 when object-oriented programming, <b>user-defined</b> functions and <b>user-defined</b> data types were included.|$|E
5|$|C# is more type safe than C++. The only {{implicit}} conversions {{by default}} {{are those that}} are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any <b>user-defined</b> conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default.|$|E
5|$|Players can add non-Steam {{games to}} their libraries, {{allowing}} {{the game to}} be easily accessed from the Steam client and providing support where possible for Steam Overlay features. The Steam interface allows for <b>user-defined</b> shortcuts to be added. In this way, third-party modifications and games not purchased through the Steam Store can use Steam features. Valve sponsors and distributes some modifications free-of-charge; and modifications that use Steamworks can also use VAC, Friends, the server browser, and any Steam features supported by their parent game. For most games launched from Steam, the client provides an in-game overlay that can be accessed by a keystroke. From the overlay, the user can access his or her Steam Community lists and participate in chat, manage selected Steam settings, and access a built-in web browser without having to exit the game. Since the beginning of February 2011 as a beta version, the overlay also allows players to take screenshots of the games in process; it automatically stores these and allows the player to review, delete, or share them during or after his or her game session. As a full version on February 24, 2011, this feature was reimplemented so that users could share screenshots on websites of Facebook, Twitter, and Reddit straight from a user's screenshot manager.|$|E
25|$|Extensibility in {{the form}} of <b>user-defined</b> functions.|$|E
25|$|In {{systems that}} support <b>user-defined</b> phrases, users can even define their own {{abbreviations}} {{that might not}} follow standard pinyin rules.|$|E
25|$|Semantic colorization: Improved syntax coloring, various <b>user-defined</b> or default {{colors for}} C++ syntax such as macros, enumerations, typenames and functions.|$|E
25|$|X also lacks native {{support for}} <b>user-defined</b> stored {{procedures}} on the X server, {{in the manner}} of NeWS there is no Turing-complete scripting facility. Various desktop environments may thus offer their own (usually mutually incompatible) facilities.|$|E
25|$|Most modern {{input method}} {{implementations}} would adjust {{the positions of}} word candidates in the candidate list based on prior usage statistics. In addition, the input method would also support <b>user-defined</b> phrases via a user dictionary.|$|E
25|$|Gaiji can {{be either}} <b>user-defined</b> {{characters}} or system-specific characters. Both are a problem for information interchange, as the codepoint used to represent an external character will not be consistent from one computer or operating system to another.|$|E
25|$|XML {{also has}} the concept of schema. This permits strong typing, <b>user-defined</b> types, {{predefined}} tags, and formal structure, allowing for formal validation of an XML stream in a portable way. There is, however, an IETF draft proposal for a schema system for JSON.|$|E
25|$|Many players support {{multilingual}} {{display in}} English, French, Spanish, German, Italian, Chinese, Japanese and Korean. They support Winamp playlists and allow repeat, shuffle play and programmable functions. Several preset and one <b>user-defined</b> EQ settings are included, plus a built-in FM tuner.|$|E
25|$|Control {{messages}} {{are used to}} communicate between the aircraft and its base, with messages either standardized according to ARINC Standard 633, or <b>user-defined</b> in accordance with ARINC Standard 618. The contents of such messages can be OOOI events, flight plans, weather information, equipment health, status of connecting flights, etc.|$|E
25|$|Tandem mass {{spectrometry}} enables {{a variety of}} experimental sequences. Many commercial mass spectrometers are designed to expedite the execution of such routine sequences as selected reaction monitoring (SRM) and precursor ion scanning. In SRM, the first analyzer allows only a single mass through and the second analyzer monitors for multiple <b>user-defined</b> fragment ions. SRM is most often used with scanning instruments where the second mass analysis event is duty cycle limited. These experiments are used to increase specificity of detection of known molecules, notably in pharmacokinetic studies. Precursor ion scanning refers to monitoring for a specific loss from the precursor ion. The first and second mass analyzers scan across the spectrum as partitioned by a <b>user-defined</b> m/z value. This experiment is used to detect specific motifs within unknown molecules.|$|E
25|$|The exact {{relationship}} between TTM and TRAC is unknown. The TTM documentation {{indicates that it}} was derived from GAP and GPM. In any case, {{the description of the}} characteristics of TRAC also apply to TTM. However, by removing the syntactic distinction between built-in and <b>user-defined</b> function, TTM would appear to be a much cleaner language.|$|E
25|$|PWI {{measures}} {{how well}} a process fits into a <b>user-defined</b> process limit known as the specification limit. The specification limit is the tolerance allowed for the process and may be statistically determined. Industrially, these specification limits are known as the process window, and values that a plotted inside or outside this window are known as the process window index.|$|E
25|$|Kenneth E. Iverson used {{primitives}} {{based on}} Curry's combinators in his J programming language, {{a successor to}} APL. This enabled what Iverson called tacit programming, that is, programming in functional expressions containing no variables, along with powerful tools for working with such programs. It turns out that tacit programming is possible in any APL-like language with <b>user-defined</b> operators.|$|E
25|$|Although SpeedScript did {{not include}} a {{built-in}} spell checker, additional utilities were soon published. In December 1985, SpeedCheck was published in Compute!'s Gazette. This external utility accepted SpeedScript files (as well as those from compatible word processors, such as PaperClip) and spell-checked them against a <b>user-defined</b> dictionary. An enhanced 80-column version for the C128, SpeedCheck 128, was published in September 1988.|$|E
25|$|Precision Biosciences, another {{biotechnology}} company, {{has developed}} a fully rational design process called Directed Nuclease Editor (DNE) which is capable of creating engineered meganucleases that target and modify a <b>user-defined</b> location in a genome. In 2012 researchers at Bayer CropScience used DNE to incorporate a gene sequence into the DNA of cotton plants, targeting it precisely to a predetermined site.|$|E
25|$|There is no {{official}} codepoint definition for the euro sign in this modified character set. The HP49/50 series of calculators {{use a different}} character set based on ECMA-94 / ISO 8859-1 which includes the euro symbol. When printing to the HP82240A printer via a <b>user-defined</b> translation vector defined in the PRTPAR variable, the euro sign could be translated to f.e. codepoint 128 (0x80). Mapping the euro sign to code point 186 (0xBA) as in HPRoman-9 would be another choice.|$|E
25|$|The Burroughs/Unisys APLB {{interpreter}} (1982) was {{the first}} to use dynamic incremental compilation to produce code for an APL-specific virtual machine. It recompiled on-the-fly as identifiers changed their functional meanings. In addition to removing parsing and some error checking from the main execution path, such compilation also streamlines the repeated entry and exit of <b>user-defined</b> functional operands. This avoids the stack setup and take-down for function calls made by APL's built-in operators such as Reduce and Each.|$|E
25|$|Availability of {{high-resolution}} X-ray crystallographic {{measurements of}} complete molecular structures provides {{information about the}} type and location of all atoms that forms the protein. In BioMOCA the protein atoms are modeled as static point charges embedded in a finite volume inaccessible to the ions and associated with a <b>user-defined</b> dielectric coefficient. Moreover, a number of force-field parameters are available that provide information about the charge and radii of atoms in different amino-acid groups. The conjunction of the molecular structure and force fields provide the coordinates, radii, and charge of each atom in the protein channel. BioMOCA uses such information in the standard PQR (Position-Charge-Radius) format to map the protein system onto a rectangular grid.|$|E
25|$|Virtual {{entities}} {{may contain}} and {{be controlled by}} assorted attributes, such as transform values (location, orientation, and scale) stored in an object's transformation matrix. Animation is the change of an attribute over time. Multiple methods of achieving animation exist; the rudimentary form {{is based on the}} creation and editing of keyframes, each storing a value at a given time, per attribute to be animated. The 2D/3D graphics software will change with each keyframe, creating an editable curve of a value mapped over time, in which results in animation. Other methods of animation include procedural and expression-based techniques: the former consolidates related elements of animated entities into sets of attributes, useful for creating particle effects and crowd simulations; the latter allows an evaluated result returned from a <b>user-defined</b> logical expression, coupled with mathematics, to automate animation in a predictable way (convenient for controlling bone behavior beyond what a hierarchy offers in skeletal system set up).|$|E
500|$|The C++11 {{standard}} has {{enhanced the}} allocator interface to allow [...] "scoped" [...] allocators, so that containers with [...] "nested" [...] memory allocations, such as vector of strings or {{a map of}} lists of sets of <b>user-defined</b> types, can ensure that all memory is sourced from the container's allocator.|$|E
500|$|Each COBOL {{program is}} made up of four basic lexical items: words, literals, picture character-strings (see [...] ) and separators. Words include {{reserved}} words and <b>user-defined</b> identifiers. They are up to 31 characters long and may include letters, digits, hyphens and underscores. Literals include numerals (e.g. [...] ) and strings (e.g. [...] ). Separators include the space character and commas and semi-colons followed by a space.|$|E
500|$|In lieu of {{function}} pointers, functions in PHP can be referenced by a string containing their name. In this manner, normal PHP functions can be used, for example, as callbacks or within function tables. <b>User-defined</b> functions may be created {{at any time}} without being prototyped. Functions may be defined inside code blocks, permitting a run-time {{decision as to whether}} or not a function should be defined. There is a function_exists function that determines whether a function with a given name has already been defined. Function calls must use parentheses, with the exception of zero-argument class constructor functions called with the PHP operator new, in which case [...] parentheses are optional.|$|E
500|$|The ISO SQL {{implementation}} of Null {{is the subject}} of criticism, debate and calls for change. [...] In The Relational Model for Database Management: Version 2, Codd suggested that the SQL {{implementation of}} Null was flawed and should be replaced by two distinct Null-type markers. [...] The markers he proposed were to stand for [...] "Missing but Applicable" [...] and [...] "Missing but Inapplicable", known as A-values and I-values, respectively. [...] Codd's recommendation, if accepted, would have required the implementation of a four-valued logic in SQL. [...] Others have suggested adding additional Null-type markers to Codd's recommendation to indicate even more reasons that a data value might be [...] "Missing", increasing the complexity of SQL's logic system. [...] At various times, proposals have also been put forth to implement multiple <b>user-defined</b> Null markers in SQL. [...] Because of the complexity of the Null-handling and logic systems required to support multiple Null markers, none of these proposals have gained widespread acceptance.|$|E
500|$|Other {{promising}} {{methods of}} structural alignment are local structural alignment methods. These provide comparison of pre-selected parts of proteins (e.g. binding sites, <b>user-defined</b> structural motifs) [...] against binding sites or whole-protein structural databases. The MultiBind and MAPPIS servers [...] allow {{the identification of}} common spatial arrangements of physicochemical properties such as H-bond donor, acceptor, aliphatic, aromatic or hydrophobic {{in a set of}} user provided protein binding sites defined by interactions with small molecules (MultiBind) or in a set of user-provided protein–protein interfaces (MAPPIS). Others provide comparison of entire protein structures [...] against a number of user submitted structures or against a large database of protein structures in reasonable time (ProBiS). Unlike global alignment approaches, local structural alignment approaches are suited to detection of locally conserved patterns of functional groups, which often appear in binding sites and have significant involvement in ligand binding. As an example, comparing G-Losa, a local structure alignment tool, with TM-align, a global structure alignment based method. While G-Losa predicts drug-like ligands’ positions in single-chain protein targets more precisely than TM-align, the overall success rate of TM-align is better.|$|E
2500|$|Text mode: 40×25 characters; 256 <b>user-defined</b> chars (8×8 pixels, or 4×8 in {{multicolor}} mode); or extended background color; 64 <b>user-defined</b> chars with 4 background colors, 4-bit color RAM defines {{foreground color}} ...|$|E
2500|$|In Perl 4 and earlier, it was {{effectively}} required to call <b>user-defined</b> subroutines ...|$|E
2500|$|C++ {{provides}} more than 35 operators, covering basic arithmetic, bit manipulation, indirection, comparisons, logical operations and others. Almost all operators can be overloaded for <b>user-defined</b> types, {{with a few}} notable exceptions such as member access (. and [...]*) {{as well as the}} conditional operator. The rich set of overloadable operators is central to making <b>user-defined</b> types in C++ seem like built-in types.|$|E
2500|$|In Perl 5, it {{can still}} be used to modify the way <b>user-defined</b> subroutines are called ...|$|E
2500|$|... control – deploy this {{implementation}} and {{by use of}} <b>user-defined</b> dashboards monitor the improvement in real time and feed the performance information back into the simulation model {{in preparation for the}} next improvement iteration ...|$|E
2500|$|Input and {{construct}} molecular interaction networks from raw interaction files (SIF format) containing lists of protein–protein and/or protein–DNA interaction pairs. [...] For yeast and other model organisms, large sources of pairwise interactions {{are available through}} the BIND and TRANSFAC databases. <b>User-defined</b> interaction types are also supported.|$|E
2500|$|Structures {{are more}} {{commonly}} known as structs. Structs are <b>user-defined</b> value types that are declared using the [...] keyword. They {{are very similar to}} classes but are more suitable for lightweight types. Some important syntactical differences between a [...] and a [...] are presented later in this article.|$|E
2500|$|... {{functions}} or {{from physical}} parameters. SGNSim can generate ensembles of GRNs within {{a set of}} <b>user-defined</b> parameters, such as topology. It {{can also be used}} to model specific GRNs and systems of chemical reactions. Genetic perturbations such as gene deletions, gene over-expression, insertions, frame shift mutations can also be modeled as well.|$|E
