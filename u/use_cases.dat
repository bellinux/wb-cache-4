7967|10000|Public
5|$|A {{new series}} of tests {{designed}} to evaluate performance in SLS <b>use</b> <b>cases</b> was initiated in 2017.|$|E
5|$|All these {{distributions}} have no or {{only minor}} changes {{when compared with}} the original FreeBSD base system. The main difference to the original FreeBSD is that they come with pre-installed and pre-configured software for specific <b>use</b> <b>cases.</b> This can be compared with Linux distributions, which are all binary compatible because they use the same kernel and also use the same basic tools, compilers and libraries, while coming with different applications, configurations and branding.|$|E
25|$|<b>Use</b> <b>cases</b> {{are widely}} used system {{analysis}} modeling tools for identifying and expressing the functional requirements of a system. Each use case is a business scenario or event for which the system must provide a defined response. <b>Use</b> <b>cases</b> evolved from object-oriented analysis.|$|E
3000|$|Step identifier: The <b>use</b> <b>case</b> {{template}} <b>uses</b> {{the step}} identifier of the <b>use</b> <b>case</b> to describe variants in <b>use</b> <b>case</b> scenarios; [...]...|$|R
40|$|This paper {{describes}} how refactoring {{as a concept}} can be broadened to apply to <b>use</b> <b>case</b> models. A metamodel for <b>use</b> <b>case</b> modeling is described in detail, which represents our perspec- tive on <b>use</b> <b>case</b> formalization. This metamodel allows us to define several categories of <b>use</b> <b>case</b> refactorings that help us discover and organize <b>use</b> <b>case</b> refactorings. A list of current refactorings is given. Finally, we illustrate the concept of <b>use</b> <b>case</b> refactorings with a simple example...|$|R
40|$|<b>Use</b> <b>case</b> models {{capture and}} {{describe}} the functional requirements of a software system. A <b>use</b> <b>case</b> driven development process, where a <b>use</b> <b>case</b> model is the principal basis for constructing an object-oriented design, is recommended when applying UML. There are, however, some problems with <b>use</b> <b>case</b> driven development processes and alternative ways of applying a <b>use</b> <b>case</b> model have been proposed. One alternative is to apply the <b>use</b> <b>case</b> model in a responsibility-driven process {{as a means to}} validate the design model. We wish to study how a <b>use</b> <b>case</b> model best can be applied in an object-oriented development process and have conducted a pilot experiment with 26 students as subjects to compare a <b>use</b> <b>case</b> driven process against...|$|R
25|$|Software engineering. Paraconsistent logic {{has been}} {{proposed}} {{as a means for}} dealing with the pervasive inconsistencies among the documentation, <b>use</b> <b>cases,</b> and code of large software systems.|$|E
25|$|Google has {{developed}} several variations of Android for specific <b>use</b> <b>cases,</b> including Android Wear for wearable {{devices such as}} wrist watches, Android TV for televisions, Android Auto for cars, and Brillo, later renamed Android Things, for smart devices and Internet of things.|$|E
25|$|In August 2017, 500 apps {{were removed}} from Google Play after {{security}} firm Lookout discovered that the apps contained an SDK that allowed for malicious advertising. The apps had been collectively downloaded over 100 million times, and consisted {{of a wide variety}} of <b>use</b> <b>cases,</b> including health, weather, photo-editing, Internet radio and emoji.|$|E
40|$|<b>Use</b> <b>case</b> {{model is}} subject to changes {{throughout}} the software development life cycle. Impacts of these changes affect directly the requirements and consequently the resulted system. Scrapping and replacing <b>use</b> <b>case</b> is expensive; {{in this paper we}} proposed a solution that integrates changes in <b>use</b> <b>case</b> in requirement phase. This solution combines independent enhancements to some version of a <b>use</b> <b>case</b> into a new version that include the enhancements and the old <b>use</b> <b>case.</b> CASE tool implementation and experimental evaluation of the proposed approach showed promising results in terms of software development time saving and better <b>use</b> <b>case</b> models integrity...|$|R
40|$|<b>Use</b> <b>case</b> modeling, {{including}} <b>use</b> <b>case</b> diagrams and <b>use</b> <b>case</b> specifications, {{is commonly}} applied to structure and document requirements. <b>Use</b> <b>case</b> specifications are usually structured, textual documents complying {{with a certain}} <b>use</b> <b>case</b> template. However, because <b>use</b> <b>case</b> specifications remain essentially textual, ambiguity is inevitably introduced. In this paper, we propose a <b>use</b> <b>case</b> modeling approach, which is composed {{of a set of}} well-defined restriction rules and a <b>use</b> <b>case</b> template. The goal is two-fold: (1) restrict the way users can document <b>use</b> <b>case</b> specifications in order to reduce ambiguity and (2) facilitate automated analysis in order to provide tool support to derive initial analysis models, which in UML are typically composed of class diagrams, interaction diagrams, and possibly other types of diagrams and constraints. Though the proposed restriction rules and template are based on a clear rationale, two main questions need to be investigated. Do users find them too restrictive or impractical in certain situations? Second, do the rules and template have a positive, significant impact {{on the quality of the}} resulting analysis models? To investigate these questions, we performed and report on a controlled experiment, which evaluates the restriction rules and <b>use</b> <b>case</b> template in terms of whether they are easy to apply while developing <b>use</b> <b>case</b> models and whether they help obtain higher quality analysis models in terms of correctness, completeness, redundancy, and understandability. Results show that, the restriction rules are overall easy to apply and that our <b>use</b> <b>case</b> modeling approach result in significant improvements regarding the correctness of derived class diagrams and the understandability of <b>use</b> <b>case</b> specifications...|$|R
40|$|<b>Use</b> <b>case</b> {{models are}} widely used in {{software}} engineering. It is important to improve the understandability and maintainability of <b>use</b> <b>case</b> models. Refactoring is a behavior-preserving transformation. The research shows that refactoring as a concept can be broadened to apply to <b>use</b> <b>case</b> models to improve their understandability, changeability, reusability and traceability. In this thesis a <b>use</b> <b>case</b> metamodel is described for <b>use</b> <b>case</b> modeling in detail. Then some refactoring rules for the <b>use</b> <b>case</b> metamodel are defined and implemented. Based on the Drawlets framework, a prototype tool is implemented for defining the <b>use</b> <b>case</b> models and applying refactorings to the models. A case study is also presented to illustrate the practical use of these refactorings. The experience shows that the tool facilitates the refactoring process greatly...|$|R
25|$|The World Wide Web Consortium {{also has}} an XML Binary Characterization Working Group doing {{preliminary}} research into <b>use</b> <b>cases</b> and properties for a binary encoding of XML Information Set. The working group is not chartered to produce any official standards. Since XML is by definition text-based, ITU-T and ISO are using the name Fast Infoset for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 and ISO/IEC 24824-1).|$|E
25|$|Control of an {{automated}} teller machine (ATM) {{is an example of}} an interactive process in which a computer will perform a logic derived response to a user selection based on information retrieved from a networked database. The ATM process has similarities with other online transaction processes. The different logical responses are called scenarios. Such processes are typically designed with the aid of <b>use</b> <b>cases</b> and flowcharts, which guide the writing of the software code.|$|E
25|$|The most {{significant}} improvement is to incorporate feed-forward control with {{knowledge about the}} system, and using the PID only to control error. Alternatively, PIDs can be modified in more minor ways, such as by changing the parameters (either gain scheduling in different <b>use</b> <b>cases</b> or adaptively modifying them based on performance), improving measurement (higher sampling rate, precision, and accuracy, and low-pass filtering if necessary), or cascading multiple PID controllers.|$|E
5000|$|A misuse case diagram {{is created}} {{together}} with a corresponding <b>use</b> <b>case</b> diagram. The model introduces 2 new important entities (in addition to those from the traditional <b>use</b> <b>case</b> model, <b>use</b> <b>case</b> and actor: ...|$|R
5000|$|... #Caption: Single <b>use</b> <b>case</b> in {{a fictitious}} hotel <b>using</b> <b>use</b> <b>case</b> diagram notation.|$|R
40|$|Deliverable D 5. 4 {{purpose is}} to {{document}} the final set of requirements for <b>Use</b> <b>Case</b> # 1 (Network Intrusion Detection) jointly with the design, implementation and validation of its corresponding prototype. Additionally, updates in the <b>Use</b> <b>Case</b> requirements are also shown. The ONTIC <b>Use</b> <b>Case</b> development and implementation follows a customized version of the Scrum Agile methodology (as described in deliverable D 5. 1 [3]); therefore, the requirements are described as user stories. The different sections in the document provide:Introduction of <b>Use</b> <b>Case</b> # 1 {{in terms of their}} application in CSP environments, operational goals and machine learning algorithms (section 7) <b>Use</b> <b>case</b> # 1 specification is described in section 8). Definitions of Done (DoD) are provided in (Annex A) <b>Use</b> <b>case</b> # 1 design is detailed in section 9. <b>Use</b> <b>case</b> # 1 implementation details are documented in section 10. <b>Use</b> <b>case</b> # 1 testing documentation is shown in section 1...|$|R
25|$|SD card {{speed is}} customarily rated by its {{sequential}} {{read or write}} speed. The sequential performance aspect is the most relevant for storing and retrieving large files (relative to block sizes internal to the flash memory), such as images and multimedia. Small data (such as file names, sizes and timestamps) falls under the much lower speed limit of random access, which can be the limiting factor in some <b>use</b> <b>cases.</b>|$|E
25|$|Dan North has {{developed}} a number of frameworks that support BDD (including JBehave and RBehave), whose operation {{is based on the}} template that he suggested for recording user stories. These tools use a textual description for <b>use</b> <b>cases</b> and several other tools (such as CBehave) have followed suit. However, this format is not required and so there are other tools that use other formats as well. For example, Fitnesse (which is built around decision tables), has also been used to roll out BDD.|$|E
25|$|Due to the flexibility, customizability {{and free}} and {{open-source}} nature of Linux, it becomes possible to highly tune Linux {{for a specific}} purpose. There are two main methods for creating a specialized Linux distribution: building from scratch or from a general-purpose distribution as a base. The distributions often {{used for this purpose}} include Debian, Fedora, Ubuntu (which is itself based on Debian), Arch Linux, Gentoo, and Slackware. In contrast, Linux distributions built from scratch do not have general-purpose bases; instead, they focus on the JeOS philosophy by including only necessary components and avoiding resource overhead caused by components considered redundant in the distribution's <b>use</b> <b>cases.</b>|$|E
5000|$|... "Tuleap <b>Use</b> <b>Case</b> on Savoir Faire Linux," [...] <b>Use</b> <b>Case</b> of Tuleap usage by the Ring_(software) ...|$|R
40|$|An {{approach}} for guiding {{the construction of}} <b>use</b> <b>case</b> specifications is presented. A <b>use</b> <b>case</b> specification comprises contextual information of the <b>use</b> <b>case,</b> its change history, the complete graph of possible pathways, attached requirements and open issues. The proposed approach delivers a <b>use</b> <b>case</b> specification as an unambiguous natural language text. This is done by a stepwise and guided process which progressively transforms initial and partial natural language descriptions of scenarios into well structured, integrated <b>use</b> <b>case</b> specifications. The basis of the approach {{is a set of}} linguistic patterns and linguistic structures. The former constitutes the deep structure of the <b>use</b> <b>case</b> specification whereas the latter corresponds to the surface structures. The paper presents the <b>use</b> <b>case</b> model, the linguistic basis and the guided process along with the associated guidelines and support rules. The process is illustrated with the automated teller machine (ATM) case study...|$|R
40|$|Doctor of Philosophy(PhDWe {{present and}} assess the novel thesis that a {{language}} commonly accepted for requirement elicitation is worth using for configuration of business process automation systems. We suggest that Cockburn's well accepted requirements elicitation language - the written <b>use</b> <b>case</b> language, with a few extensions, ought {{to be used as}} a workflow modelling language. We evaluate our thesis by studying in detail an industrial implementation of a workflow engine whose workflow modelling language is our extended written <b>use</b> <b>case</b> language; by surveying the variety of business processes that can be expressed by our extended written <b>use</b> <b>case</b> language; and by empirically assessing the readability of our extended written <b>use</b> <b>case</b> language. Our contribution is sixfold: (i) an architecture with which a workflow engine whose workflow modelling language is an extended written <b>use</b> <b>case</b> language can be built, configured, used and monitored; (ii) a detailed study of an industrial implementation of <b>use</b> <b>case</b> oriented workflow engine; (iii) assessment of the expressive power of the extended written <b>use</b> <b>case</b> language which is based on a known pattern catalogue; (iv) another assessments of the expressive power of the extended written <b>use</b> <b>case</b> language which is based on an equivalence to a formal model that is known to be expressive; (v) an empirical evaluation in industrial context of the readability of our extended written <b>use</b> <b>case</b> language in comparison to the readability of the incumbent graphical languages; and (vi) reflections upon the state of the art, methodologies, our results, and opportunities for further research. Our conclusions are that a workflow engine whose workflow modelling language is an extended written <b>use</b> <b>case</b> language can be built, configured, used and monitored; that in an environment that calls upon an extended written <b>use</b> <b>case</b> language as a workflow modelling language, the transition between the modelling and verification state, enactment state, and monitoring state is dynamic; that a <b>use</b> <b>case</b> oriented workflow engine was implemented in industrial settings and that the approach was well accepted by management, workflow configuration officers and workflow participants alike; that the extended written <b>use</b> <b>case</b> language is quite expressive, as much as the incumbent graphical languages; and that in industrial context an extended written <b>use</b> <b>case</b> language is an efficient communication device amongst stakeholders...|$|R
25|$|Software {{functional}} {{quality is}} defined as conformance to explicitly stated functional requirements, identified for example using Voice of the Customer analysis (part of the Design for Six Sigma toolkit and/or documented through <b>use</b> <b>cases)</b> {{and the level of}} satisfaction experienced by end-users. The latter is referred as to as usability and is concerned with how intuitive and responsive the user interface is, how easily simple and complex operations can be performed, and how useful error messages are. Typically, software testing practices and tools ensure that a piece of software behaves in compliance with the original design, planned user experience and desired testability, i.e. a piece of software's disposition to support acceptance criteria.|$|E
500|$|Enterprise licensees {{may use the}} Windows 10 Enterprise Long-term Servicing Branch (LTSB) edition. LTSB {{milestones}} of Windows 10 {{are designed}} for long-term deployments in specialized environments, and only receive quality of life updates (i.e. security patches). Each LTSB milestone is given a full, 10-year support lifecycle. Due to Microsoft's intended <b>use</b> <b>cases</b> for LTSB builds, certain features, including most Cortana functionality, Windows Store, and bundled apps, are excluded from LTSB. Microsoft director Stella Chernyak explained that [...] "we have businesses [...] may have mission-critical environments where we respect the fact they want to test and stabilize the environment for a long time." ...|$|E
500|$|In The C++ Programming Language, Bjarne Stroustrup, on {{the other}} hand, argues that the [...] "apparently raconian {{restriction}} against per-object information in allocators is not particularly serious", pointing out that most allocators do not need state, and have better performance without it. He mentions three <b>use</b> <b>cases</b> for custom allocators, namely, memory pool allocators, shared memory allocators, and garbage collected memory allocators. He presents an allocator implementation that uses an internal memory pool for fast allocation and deallocation of small chunks of memory, but notes that such an optimization may already be performed by the allocator provided by the implementation.|$|E
50|$|An abuse case diagram {{is created}} {{together}} with a corresponding <b>use</b> <b>case</b> diagram, {{but not in the}} same diagram (different from Misuse case). There is no new terminology or special symbols introduced for abuse case diagrams. They are drawn with the same symbols as a <b>use</b> <b>case</b> diagram.To distinguish between the two, the <b>use</b> <b>case</b> diagram and abuse case diagrams are kept separate, and related. Hence abuse cases do not appear in the <b>use</b> <b>case</b> diagrams and vice versa.|$|R
5000|$|Every Role of a <b>use</b> <b>case</b> {{is played}} by an object {{determined}} by the Context {{at the start of}} the <b>use</b> <b>case</b> enactment; ...|$|R
40|$|<b>Use</b> <b>case</b> models {{capture and}} {{describe}} the functional requirements of a software system. A <b>use</b> <b>case</b> driven development process, where a <b>use</b> <b>case</b> model is the principal basis for constructing an object-oriented design, is recommended when applying UML. There are, however, some problems with <b>use</b> <b>case</b> driven development processes and alternative ways of applying a <b>use</b> <b>case</b> model have been proposed. One alternative is to apply the <b>use</b> <b>case</b> model in a responsibility-driven process {{as a means to}} validate the design model. We wish to study how a <b>use</b> <b>case</b> model best can be applied in an object-oriented development process and have conducted a pilot experiment with 26 students as subjects to compare a <b>use</b> <b>case</b> driven process against a responsibility-driven process in which a <b>use</b> <b>case</b> model is applied to validate the design model. Each subject was given detailed guidelines on one of the two processes, and used those to construct design models consisting of class and sequence diagrams. The resulting class diagrams were evaluated with regards to realism, that is, how well they satisfied the requirements, size and number of errors. The results show that the validation process produced more realistic class diagrams, but with a larger variation in the number of classes. This indicates that the <b>use</b> <b>case</b> driven process gave more, but not always more appropriate, guidance on how to construct a class diagram The experiences from this pilot experiment were also used to improve the experimental design, and the design of a follow-up experiment is presented...|$|R
500|$|Accessories can be {{connected}} to a Wii Remote through a proprietary port {{at the base of}} the controller, such as the bundled Nunchuk — a handheld unit with an accelerometer, analog stick, and two trigger buttons.An expansion accessory known as Wii MotionPlus augments the Wii Remote's existing sensors with gyroscopes to allow for finer motion detection; the MotionPlus functionality was later incorporated into a revision of the controller known as Wii Remote Plus. At E3 2009, Nintendo also presented a [...] "Vitality Sensor" [...] accessory that could be used to measure a player's pulse. In a 2013 Q, Satoru Iwata revealed that the Vitality Sensor had been shelved, as internal testing found that the device did not work with all users, and its <b>use</b> <b>cases</b> were too narrow.|$|E
2500|$|The {{identification}} of test relevant aspects usually follows the (functional) specification (e.g. requirements, <b>use</b> <b>cases</b> …) {{of the system}} under test.|$|E
2500|$|Fusidic acid {{is being}} tested for {{indications}} beyond skin infections. [...] There is evidence from compassionate <b>use</b> <b>cases</b> that fusidic acid may be effective {{in the treatment of}} patients with prosthetic joint-related chronic osteomyelitis.|$|E
40|$|For {{many years}} systems {{engineers}} have produced traditional system requirements specifications containing shall-statement requirements. The rapid adoption of <b>use</b> <b>case</b> modeling for capturing functional requirements {{in the software}} community has caused systems engineers to examine the utility of <b>use</b> <b>case</b> models for capturing system-level functional requirements. A transition from traditional shall-statement requirements to <b>use</b> <b>case</b> modeling has raised some issues and questions. This paper advocates a hybrid requirements process in which <b>use</b> <b>case</b> modeling and traditional shall-statement requirements are applied together to effectively express both functional and nonfunctional requirements for complex, hierarchical systems. This paper also presents a practical method for extracting requirements from the <b>use</b> <b>case</b> text to produce a robust requirements specification. © 2004 Wiley Periodicals, Inc...|$|R
40|$|This paper proposes an {{approach}} to translating a <b>use</b> <b>case</b> diagram into an executable context-aware ambients. The requirements of a context-aware system is captured and represented in an extension of UML <b>use</b> <b>case</b> diagrams called context-aware <b>use</b> <b>case</b> diagrams. Then an algorithm is proposed that translate a context-aware <b>use</b> <b>case</b> diagram into a process in the Calculus of Context-aware Ambients (CCA). This process can then be analysed using the CCA simulator. The proposed approach is evaluated using a real-word example of a context-aware collision avoidance system...|$|R
5000|$|DCI allows {{an object}} {{to take on}} one or more Roles during a <b>use</b> <b>case</b> enactment. In other words, an object is re-bound to Role {{identifiers}} on each <b>use</b> <b>case</b> enactment. These Roles infer an interface, {{referred to as the}} Role type. Each object is [...] "re-cast" [...] (in the theatrical sense) anew on every <b>use</b> <b>case.</b> Though a Role is bound only to a single object, an object may play several Roles. For example, a HeadWaiter may be involved in a <b>use</b> <b>case</b> to count all the occupants of the restaurant during a fire inspection, and will play the Person Role as well as the HeadWaiter Role. The single object supports the behaviors of both Roles necessary to carry out the <b>use</b> <b>case.</b>|$|R
