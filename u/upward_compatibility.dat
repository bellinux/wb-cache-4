30|4|Public
50|$|The macros for serialization, exceptions, and RTTI predated {{availability}} {{of these features}} in Microsoft C++ {{by a number of}} years. 32-bit versions of MFC, for Windows NT 3.1 and later Windows operating systems, used compilers that implemented the language features and updated the macros to simply wrap the language features instead of providing customized implementations, realizing <b>upward</b> <b>compatibility.</b>|$|E
5000|$|Oracle Database 12c Standard Edition 2 (SE2): {{intended}} for small- to medium-sized implementations, this edition comes with Real Application Clusters option included, a reduced set of database features, and the licensing restriction {{to run on}} servers or clusters with a maximum of 2 sockets total and capped to use a maximum of 16 concurrent user threads. Oracle positions SE2 as a starter edition, stressing complete <b>upward</b> <b>compatibility</b> and ease of upgrade to the more costly Enterprise Edition.|$|E
5000|$|In 1980-1983, Tandem {{attempted}} to re-design its entire {{hardware and software}} stack to put its NonStop methods on a stronger foundation than its inherited HP 3000 traits. Rainbow's hardware was a 32-bit register-file machine that aimed {{to be better than}} a VAX. For reliable programming, the main programming language was [...] "TPL", a subset of Ada. At that time, people barely understood how to compile Ada to unoptimized code. There was no migration path for existing NonStop system software coded in TAL. The OS and database and Cobol compilers were entirely redesigned. Customers would see it as a totally disjoint product line requiring all-new software from them. The software side of this ambitious project took much longer than planned. The hardware was already obsolete and out-performed by TXP before its software was ready, so the Rainbow project was abandoned. All subsequent efforts emphasized <b>upward</b> <b>compatibility</b> and easy migration paths.|$|E
40|$|We {{investigate}} languages {{recognized by}} well structured transition systems (WSTS) with <b>upward</b> (resp. downward) <b>compatibility.</b> We show that under mild assumptions every two disjoint WSTS languages are regular separable, i. e., {{there exists a}} regular language containing {{one of them and}} disjoint from the other. In particular, if a language, as well as its complement, are both recognized by a WSTS, then they are necessarily regular...|$|R
40|$|This paper {{explores the}} {{robustness}} of the one-dimensional screening model {{with respect to}} {{increasing the number of}} instruments and the number of characteristics. We study a case of nonlinear pricing (2 instruments (2 routes on which the airline provides customers with services), 2 characteristics (demand of services on these routes) and two values per characteristic (a low or a high demand of services on these routes)) and we show that none of the conclusions of the one-dimensional analysis remain valid. In particular, <b>upward</b> incentive <b>compatibility</b> constraint may be binding at the optimum. As a consequence, they may be distortion {{at the top of the}} distribution. In addition to this, we show that the optimal solution often requires bundling, while it is sometimes optimal for the monopolist to produce only one good or to exclude some buyers from the market. This means that the monopolist cannot fully apply his monopoly power and is better off selling two goods independently. We define all possible solutions in the case of a quadratic cost function for a uniform distribution of agent types and demonstrate that the range of services proposed by an airline is often larger than the corresponding range in demand. ...|$|R
5000|$|NURBS {{got started}} with seminal work at Boeing and SDRC (Structural Dynamics Research Corporation), a leading company in {{mechanical}} computer-aided engineering in the 1980s and '90's. [...] The history of NURBS at Boeing {{goes back to}} 1979 when Boeing began to staff up {{for the purpose of}} developing their own comprehensive CAD/CAM system, TIGER, to support the wide variety of applications needed by their various aircraft and aerospace engineering groups. Three basic decisions were critical to establishing an environment conducive to the development of NURBS. The first was Boeing’s need to develop their own in-house geometry capability. Boeing had special, rather sophisticated, surface geometry needs, especially for wing design, that could not be found in any commercially available CAD/CAM system. As a result, the TIGER Geometry Development Group was established in 1979 and strongly supported for many years. The second decision critical to NURBS development was the removal of the constraint of <b>upward</b> geometrical <b>compatibility</b> with the two systems in use at Boeing at that time. One of these systems had evolved {{as a result of the}} iterative process inherent to wing design. The other was best suited for adding the constraints imposed by manufacturing such as cylindrical and planar regions. The third decision was simple but crucial and added the ‘R’ to ‘NURBS’. Circles were to be represented exactly: no cubic approximations would be allowed.|$|R
50|$|The {{title of}} the book focuses on Ken Olsen's major career success, namely his {{successful}} introduction of the minicomputer for small to medium businesses. It is therefore ironic that he failed to see that the next major innovation would be a smaller, personal, home-based computer. To his credit, the massive success of his early minicomputers was such that he was kept busy with improvements to his Programmed Data Processor productline, attempting <b>upward</b> <b>compatibility</b> from the PDP-1 onwards, producing the highly successful PDP-8, and PDP-10. One of his chief engineers, Edson de Castro, left after failing to get permission to design a 16-bit version of the 8-bit PDP-8 and founded Data General. Both men then competed to create a 32-bit version. This competition is well documented in the book The Soul of a New Machine by Tracy Kidder. The VAX became the cash cow for Digital Equipment, and the successful collaboration with Xerox and Intel on the introduction of a local area network solution called Ethernet resulted in a decade of successful growth for the company.|$|E
50|$|Initially MikroSim was {{developed}} to be a processor simulation software to be widely available in educational areas. Since MikroSim operability starts {{on the basis of}} microcode development, defined as a sequence of micro instructions (microcoding) for a virtual control unit, the software’s intention is on first approach a microcode simulator with various levels of abstractions including the ability of CPU simulators and instruction set emulators. In the current software revision it is feasible for a microcode controlled virtual application to operate on own coded instruction sets. With MikroSim typical and well-known concepts in the area of computer engineering like computer architecture and instruction set architecture are non-specifically treated, which have been established {{since the early days of}} the information era and being still valid. In this fashion the simulation software gains a timeless, free didactical benefit without being restricted on special developments of the past and in the future. The detailed documentation and the bilingual application’s graphical user interface (GUI) in German and English, as well as the software’s <b>upward</b> <b>compatibility</b> given to some extent by Microsoft’s operating system Windows, are reasons for being a well-established, valuable e-learning tool in the field of computer engineering since 1992 for educational use.|$|E
5000|$|Without a VisiCalc-like {{killer app}} {{for the home}} [...] "There is no {{compelling}} reason, based on what's available in software, to convince families to" [...] spend $2,000 on a computer, one computer-store chain manager said. IBM was unfamiliar with the consumer market but hoped that customers {{would be willing to}} pay more for a product with, as an industry expert said, [...] "those three letters". Popular Mechanics warned that at $669 and $1,269, PCjr [...] "has been priced out of those markets ... almost any other computer in those price ranges is a better buy", such as the Coleco Adam. Gantz agreed, stating that [...] "inasmuch as it goes after the home market, PCjr goes to a very price-sensitive crowd." [...] Unlike IBM's traditional corporate customers, he wrote, [...] "the home computer crowd has no notion of concepts like <b>upward</b> <b>compatibility,</b> software availability, or the importance of vendor stability"; such customers usually bought the C64, which gained in popularity. The PCjr cost more than twice as much as the C64 and the Atari 8-bit family, while inferior to both and the IIe for games. Imagic stated that the C64 was [...] "a lot faster and it sells for one third the price", Sierra's Williams predicted that [...] "There's no way our game Frogger will ever look as good on the PCjr as it does on the Commodore 64 or the Atari", and Spinnaker Software said that [...] "for its level of performance it is simply the most expensive machine on the market".|$|E
40|$|We {{introduce}} SOWL QL, a {{query language}} for spatio-temporal information in ontologies. Buildingupon SOWL (Spatio-Temporal OWL), an ontology for handling spatio-temporal information in OWL, SOWL QL supports querying over qualitative spatio-temporal information (expressed using natural language expressions such as “before”, “after”, “north of”, “south of”) {{rather than merely}} quantitative information (exact dates, times, locations). SOWL QL extends SPARQL with a powerful set of temporal and spatial operators, including temporal Allen topological, spatial directional and topological operations or combinations of the above. SOWL QL maintains simplicity of expression and also, <b>upward</b> and downward <b>compatibility</b> with SPARQL. Query translation in SOWL QL yields SPARQL queries implying that, querying spatio-temporal ontologies using SPARQL is still feasible but suffers from several drawbacks {{the most important of}} them being that, queries in SPARQL become particularly complicated and users must be familiar with the underlying spatio-temporal representation (the “N-ary relations” or the “ 4 D-fluents” approach in this work). Finally, querying in SOWL QL is supported by the SOWL reasoner which {{is not part of the}} standard SPARQL translation. The run-time performance of SOWL QL has been assessed experimentally in a real data setting. A critical analysis of its performance is also presented...|$|R
40|$|Migrating {{applications}} from conventional to temporal database management technology has received scant {{mention in the}} research literature. This paper formally defines three increasingly restrictive notions of <b>upward</b> <b>compatibility</b> which capture properties of a temporal SQL with respect to conventional SQL that, when satisfied, provide for a smooth migration of legacy applications to a temporal system. The notions of <b>upward</b> <b>compatibility</b> dictate the semantics of conventional SQL statements and constrain the semantics of extensions to these statements. The paper evaluates the seven extant temporal extensions to SQL, {{all of which are}} shown to complicate migration through design decisions that violate {{one or more of these}} notions. We then outline how SQL [...] 92 can be systematically extended to become a temporal query language that satisfies all three notions. 1 Introduction A wide range of database applications manage time-varying information. These include financial applications such as por [...] ...|$|E
40|$|The Lisp {{interface}} to Jack {{will allow}} general programming of Jack internals and should simplify {{all forms of}} Jack development. It will be distributed with Jack- 5. 7 and will allow users without source code to extend or modify Jack, and users with source code to have a high-level, object-oriented, interactive prototyping environment. After prototyping in lisp, developers can rewrite their code in C++ if speed is crucial, otherwise, code can be left in lisp to simplify maintenance and to insure <b>upward</b> <b>compatibility</b> with future Jack versions...|$|E
40|$|Includes bibliographical references. The Common Business Oriented Language, COBOL, will {{celebrate}} its 30 th anniversary in April of next year. The new standard for COBOL compilers, hereafter called COBOL 85, {{was announced in}} September of 1985 {{after seven years of}} deliberation. This new version of the world's most popular language presents many new improvements which will serve to further promote the efficiency of COBOL's data processing capabilities. However, nothing can be gained without sacrifice. By improving the programming efficiency this new standard had to give up complete <b>upward</b> <b>compatibility.</b> B. S. (Bachelor of Science...|$|E
40|$|Migrating {{applications}} from conventional to temporal database management technology has received scant {{mention in the}} research literature. This paper formally denes three increasingly restrictive notions of <b>upward</b> <b>compatibility</b> which capture properties of a temporal SQL with respect to conventional SQL that, when satised, provide for a smooth migration of legacy applications to a temporal system. The notions of <b>upward</b> <b>compatibility</b> dictate the semantics of conventional SQL statements and constrain the semantics of extensions to these statements. The paper evaluates the seven extant temporal extensions to SQL, {{all of which are}} shown to complicate migration through design decisions that violate {{one or more of these}} notions. We then outline how SQL{ 92 can be systematically extended to become a temporal query language that satises all three notions. Zumammenfassung Die Migration konventioneller Anwendungen hin zu Anwendungen die auf temporaler Daten-banktechnologie basieren wurde bis anhin nur am Rande behandelt. Der vorliegende Beitrag de niert drei Eigenschaften einer in Bezug auf SQL aufwarts-kompatiblen zeitlichen Erweiterung von SQL die, falls erfullt, einen nahtlosen Ubergang garantieren. Die Eigenschaften legen die Semantik herkommlicher SQL-Befehle fest und sie schranken die Semantik sprachlicher Er-weiterungen ein. Der Beitrag evaluiert sieben zeitliche Erweiterungen von SQL und zeigt auf, dass in allen Fallen eine nahtlose Migration durch Designentscheide die Eigenschaften einer aufwarts-kompatiblen Sprache nicht berucksichtigen erschwert wird. Abschliessend zeigen wir wie SQL systematisch erweitert werden kann, so dass alle drei Eigenschaften erfullt werden...|$|E
40|$|Class {{evolution}} {{is a normal}} aspect of themaintenance of object-orientedprograms. While class {{evolution is}} closely related to the schema evolution problems faced by traditional database systems, there are two fundamental differences important for this discussion. First, the fact that class definitions are frequently shared directly in multiple applications rather than shared via “cut-and-paste ” as in relational database schemas implies that modifying a class may impact many programs, and the class maintainer may not even be aware of all affected programs. This difference motivates the need for <b>upward</b> <b>compatibility</b> so that programs using a modified class can continue to do so unaffected by the changes. Second, the fact that classes are more loosely connected than the relations in a relational database schema offers hope that we can address evolution in a more modular manner than with traditional databases. Many evolution systems take this to an extreme and treat evolution as a problem only involving individual classes, However, a maintenance activity might simultaneously affect multiple classes and require a more unified solution than is possible when considering each class’s evolution in isolation. In this paper, we discuss our approach to <b>upward</b> <b>compatibility</b> and changes involving multiple classes. Before doing so, we identify the basic tenets upon which our ideas of class evolution are based. These tenets are not meant as absolutes, but they certainly bias the research directions that we have taken. The basi...|$|E
40|$|Most {{database}} {{applications are}} designed according the ANSI/SPARC architecture. When it is used, {{a large amount}} of semantics of data may be lost during the transformation from the conceptual model to a logical model. As a consequence exchanging/integrating various databases or generating user interfaces for data access become difficult. Ontologies seem an interesting solution to solve these problems, since they allow making explicit the semantics of data. In this paper, we propose an ontology-based approach for designing database applications, and then, for representing explicitly the semantics of data within the database. It consists in extending the ANSI/SPARC architecture with the ontological level. Note that this extension may also be added to existing applications designed according to the ANSI/SPARC architecture, since it preserves an <b>upward</b> <b>compatibility.</b> ...|$|E
40|$|Abstract—We {{show how}} to extend {{temporal}} support of SQL to the Turing-complete portion of SQL, that of persistent stored modules (PSM). Our approach requires minor new syntax beyond that already in SQL/Temporal {{to define and}} to invoke PSM procedures and functions, thereby extending the current, sequenced, and non-sequenced semantics of queries to such routines. Temporal <b>upward</b> <b>compatibility</b> (existing applications work as before when one or more tables are rendered temporal) is ensured. We provide a transformation that converts Temporal SQL/PSM to conventional SQL/PSM. To support sequenced evaluation of stored functions and procedures, we define two different slicing approaches, maximal slicing and per-statement slicing. We compare these approaches empirically using a comprehensive benchmark and provide a heuristic for choosing between them. I...|$|E
40|$|This paper {{presents}} Tempos, a set {{of models}} and languages intended to seamlessly extend the ODMG object database standard with temporal functionalities. The proposed models exploit object-oriented technology to meet some important, yet traditionally neglected design criteria, related to legacy code migration and representation independence. Tempos has been fully formalized both at the syntactical and the semantical level and implemented {{on top of the}} O 2 DBMS. Its suitability in regard to applications' requirements has been validated through concrete case studies from various contexts. Keywords: temporal databases, temporal data models, temporal query languages, time representation, <b>upward</b> <b>compatibility,</b> object-oriented databases, ODMG R'esum'e Ce document pr'esente Tempos : un ensemble de mod`eles et de langages con¸cus pour 'etendre le standard pour Bases de Donn'ees `a objets ODMG, par des fonctionnalit'es temporelles. Les mod`eles d'ecrits exploitent les possibilit'es de la tech [...] ...|$|E
40|$|For {{almost ten}} years, Make {{has been a}} most {{important}} tool for development and maintenance of software systems. Its general usefulness and the simple formalism of the Makefile made Make {{one of the most}} popular UNIX+tools. However,with the increased upcoming of software production environments, there is a growing awareness for the matter of softwareconfiguration management which unveiled a number of shortcomings of Make. Particularly the lack of support for version control and project organization imposed a hard limit on the suitability of Make for more complex development and maintenance applications. Recently,several programs have been developed to tackle some of the problems not sufficiently solved by Make. shape, the system described in this paper,integrates a sophisticated version control system with a significantly improved Make functionality, while retaining full <b>upward</b> <b>compatibility</b> with Makefiles. shape's procedure of identifying appropriate component versions that together fo [...] ...|$|E
40|$|In this paper, {{we present}} a new scalar {{architecture}} for high-speed vector processing. Without using cache memory, the proposed architecture tolerates main memory access latency by introducing slide-windowed floating-point registers with data preloading feature and pipelined memory. The architecture can hold <b>upward</b> <b>compatibility</b> with existing scalar architectures. In the new architecture, software can control the window structure. This is the advantage compared with our previous work of registerwindows. Because of this advantage, registers are utilized more flexibly and computational efficiency is largely enhanced. Furthermore, this flexibility helps the compiler to generate efficient object codes easily. We have evaluated its performance on Livermore Fortran Kernels. The evaluation {{results show that the}} proposed architecture reduces the penalty of main memory access better than an ordinary scalar processor and a processor with cache prefetching. The proposed architecture with 64 regist [...] ...|$|E
40|$|Abstract-Software {{configuration}} management (SCM) is an emerging discipline. An {{important aspect of}} realizing SCM is the task of maintaining the configurations of evolving software systems. In this paper, we provide an approach to resolving some ofthe conceptual and technical problems in maintaining configurations of evolving software systems. The approach provides a formal basis for existing notions of system architecture. The formal properties of this view of configurations provide the underpinnings for a rigorous notion of system integrity, and mechanisms to control the evolution of configurations. This approach is embodied in a language, NuMIL, to describe software system configurations, and a prototype environment to maintain software system configurations. We believe that the approach and the prototype environment offer a firm base to maintain software system configurations and, therefore, to implement SCM. Index Terms-Configuration, module and subsystem families, module and subsystem interfaces, software configuration maintenance system, <b>upward</b> <b>compatibility.</b> I...|$|E
40|$|Code {{optimization}} {{and scheduling}} for superscalar and superpipelined processors often increase the register requirement of programs. For existing instruction sets {{with a small}} to moderate number of registers, this increased register requirement can be a factor that limits the e ectiveness of the compiler. In this paper, we introduce a new architectural method for adding a set of extended registers into an architecture. Using a novel concept of connection, this method allows the data stored in the extended registers to be accessed by instructions that apparently reference core registers. Furthermore, we address the technical issues involved in applying the new method toanarchitecture: instruction set extension, procedure call convention, context switching considerations, <b>upward</b> <b>compatibility,</b> e cient implementation, compiler support, and performance. Experimental results based onaprototype compiler and execution driven simulation show that the proposed method can signi cantly improve the performance of superscalar processors with a small or moderate number of registers. ...|$|E
40|$|The aim of {{this paper}} is to discuss {{metaclass}} composability and the related problems. We define inter-metalevel versus intra-metalevel composition, and downward versus <b>upward</b> <b>compatibility.</b> After analysing Smalltalk, SOM and Classtalk solutions, we present our latest research themes dealing with explicit metaclass composition. 1 Introduction In the context of class-based languages that manipulate classes as regular objects, metaclasses 1 are used to describe both the structural definition and the behavior of their instances (i. e., the classes). Software built using both classes and metaclasses is organized into an architecture of several (meta) levels of abstraction. Each (meta) level describes and controls the lower one, to which it is causally connected. The design and the reuse of such systems raise the problem of composition between and in the different (meta) levels. In section 2, we distinguish two different aspects associated to the metaclass composition problem. The first one [...] ...|$|E
40|$|Many {{applications}} of object-oriented systems {{benefit from the}} ability to make objects persistent. To be fully effective, this persistence must be provided {{in such a way as}} to allow both the database of persistent objects and the applications to evolve. As they evolve, <b>upward</b> <b>compatibility</b> must be maintained so that new versions of applications can continue to use existing persistent objects and vice versa. This implies that a persistent object system must be able to handle type mismatches between objects in secondary storage and objects in an application program. In this paper, we formalize some of the categories of type mismatches that can occur as a result of application program and database evolution. We show how the concept of an object manager can be used to resolve many of the mismatches in these categories. Finally, we discuss how object managers have been incorporated into a particular persistent object system under development at Rensselaer Polytechnic Institute. 1. Introduc [...] ...|$|E
40|$|This paper {{outlines}} {{a family}} of generic earth pointing satellites. The smallest configuration is sized to fit a Get Away Special (GAS) container (2. 5 cubic feet). The basic core of the largest member is sized to be scout launch vehicle compatible (18 cubic feet). The smallest member can easily accommodate 125 pounds of payload and generate 200 watts of electrical power. The largest can carry 500 pounds of payload and generate 1 Kilowatt of power. This family of earth pointing satellites is based on modular components that allow <b>upward</b> <b>compatibility.</b> To keep cost per unit volume low, tried and proven components are used which reduce testing of the integrated satellite. The modular design and standardization of power, and command and telemetry functions allow for ease of integration and system level checkout. The family limitations and their solutions are discussed as well as tradeoffs of various structural fabrication methods (metallic vs. composite vs. plastic) ...|$|E
40|$|This {{document}} proposes fourteen characters {{used in the}} Japanese educational field, {{and discusses}} the rationale for their inclusion. The final daraft Japanese Industrial Standard, JIS X 0213 developed in Japan, {{and it will be}} published {{by the end of this}} year. The new standard will include all characters in this proposal, so the adoption of them is very important in the view to keep <b>upward</b> <b>compatibility</b> with the Japanese products. The proposed characters are mainly used in the phonetic field. They also appear in the school text books. Nine Latin characters are pre-composed with accent mark. Five symbols and four combining characters come from the official IPA reference. UCS’s IPA repertoire is completed by including these characters. Rest two are arrows that are often used to denote the accent of a word. The characters proposed to be added here are given below, with proposed code positions. The proposal summary form is appended thereafter...|$|E
40|$|The global {{leadership}} {{shown by the}} International Hydrographic Organization (IHO) in leading {{the development and implementation}} of international standards for the paper navigational chart has been successfully carried over into the digital domain. This has been demonstrated by the acceptance and use of the S 57 and S 52 data standards for Electronic Navigational Charts (ENCs). The IHO has also been careful to ensure that S 57 and S 52 retain <b>upward</b> <b>compatibility</b> with other emerging international standards for geospatial data. The first part of the paper reviews the position and status of S 57 in re lation to this new standards environment. The second part of the paper considers the influence of the Internet which is having a major influence on the emerging geospa-tial data infrastructures that are being built in a number of countries and impacting the distribution and use of geospatial data, and will also provide opportunities for, and have an effect on the provision of data by hydrographic offices...|$|E
30|$|Runtime {{models have}} been widely used in {{different}} systems to support self-repair [33], dynamic adaption [34], data manipulation [35], etc. We have made lots of {{research in the area of}} model driven engineering. For a given meta-model and a given set of management interfaces, SM@RT [14],[15] can automatically generate the code for mapping models to interfaces with good enough runtime performance. In addition, for the situation of incomplete formalized of modeling languages, our previous work [36] has provided an MOF meta-model extension mechanism with support for <b>upward</b> <b>compatibility</b> and automatically generates a model transformation for model integration, and the work implemented on architecture-level fault tolerance [37] can also compensate for this to a degree. We have tried to construct the runtime model of a real-world Cloud and develop management programs in a modeling language [22],[38]. The approach in this paper is built on our previous works. In addition, the approach is not intrusive, that is, neither instructs non-manageable systems nor extends inadequate APIs. Therefore, it is a general-purpose approach and is capable to interwork with other similar works like Pi-ADL [39].|$|E
40|$|This paper {{presents}} TEMPOS 1, a set {{of models}} and languages intended to seamlessly extend the ODMG object database standard with temporal functionalities. The proposed models exploit objectoriented technology to meet some important, yet traditionally neglected design criteria, related to legacy code migration and representation independence. Two complementary ways for accessing temporal data are offered: a query language and a visual browser. The former one, namely TEMPOQL, {{is an extension of}} OQL supporting the manipulation of histories regardless of their representations, by composition of functional constructs. Thereby, the abstraction principle of object-orientation is fulfilled, and the functional nature of OQL is enforced. The visual browser on the other hand, offers operators which support several time-related interactive navigation tasks, such as studying a snapshot of a collection of objects at a given instant, or detecting and examining changes within temporal attributes and relationships. TEMPOS models and languages have been fully formalized both at the syntactical and the semantical level and have been implemented on top of the O 2 DBMS. Their suitability with regard to applications' requirements has been validated through concrete case studies. Index terms: temporal databases, temporal data models, temporal query languages, time representation, <b>upward</b> <b>compatibility,</b> object-oriented databases, ODMG. ...|$|E
40|$|The Unix File System(UFS) has {{historically}} offered a shared-memory consistency model. The lack of concurrency control makes this model susceptible to read/write conflicts, i. e., unexpected read/write sharing between two different processes. For example, the update of a header file by one user while another user is performing a long-runningmake can cause inconsistencies in the compilation results. In practice, read/write conflicts are rare for two reasons. First, {{the window of}} vulnerability is relatively small because read/write conflicts only occur when the executions of two processes overlap. Second, they are often prevented via explicit user-level coordination. However, the advent of mobile computing makes read/write conflicts a realistic threat to data integrity. Mobile computing is characterized by periods of disconnection and intermittent connectivity[11]. Such communication disturbances greatly widen the window of vulnerability from {{the life span of}} a process to the duration of a disconnection. They also significantly reduce the effectiveness of explicit user-level coordination, especially when disconnections are made transparent to users. How can we preserve <b>upward</b> <b>compatibility</b> with the large body of existing Unix software, while offering improved consistency in a mobile computing environment? This position paper puts forth our solution, a new transaction model called isolation only transaction (IOT) ...|$|E
40|$|Rights to {{individual}} papers {{remain with the}} author or the author's employer. Permission is granted for noncommercial reproduction of the work for educational or research purposes. This copyright notice must {{be included in the}} reproduced paper. USENIX acknowledges all trademarks herein. Library Interface Versioning in Solaris and Linux Shared libraries in Solaris and Linux use a versioning technique which allows the link editor to record an application’s dependency on a particular release level of the library. The versioning mechanism operates {{at the level of the}} library’s GLOBAL symbol names—a finer granularity than simply associating a version number with the library itself. In Solaris, this mechanism has also been used to provide a means for the system-supplied shared libraries to define their application interface: to declare specifically which of their symbols are intended for application use (and are stable from one release to the next), and which are internal to the system’s implementation (and hence subject to incompatible change). This paper describes the library symbol-versioning technology in Linux and Solaris, the ways in which it is used to support <b>upward</b> <b>compatibility</b> for existing compiled applications from one release of Solaris to the next, and the potential for similar mechanisms to be applied in Linux versioned shared libraries. ...|$|E
40|$|Writing {{distributed}} applications {{is difficult because}} the programmer has to explicitly juggle many quite different concerns, including application functionality, distribution structure, fault tolerance, security, open computing, and others. An important goal is to separate the application functionality from the other concerns. This article presents one step towards that goal. We show how to integrate mutable pointers into a design that separates functionality, distribution structure, and fault tolerance. Mutable pointers, as a realization of explicit state, are an important data type that forms the basis for object-oriented programming. We start by defining mutable pointers in a centralized fault-free system. We then refine this definition by successively adding a distribution model and a failure model. The resulting semantics can be implemented efficiently and is a sufficient base to build nontrivial abstractions for fault tolerance. The design presented here is fully implemented {{as part of the}} Mozart Programming System (see [URL] 1 Introduction There are two basic ways to build a platform for distributed application development. Either one starts with an existing language, and adds functionality in terms of library functions, or one designs the language in tandem with the platform. The first approach is indicated for commercial developments, to maintain <b>upward</b> <b>compatibility</b> with existing investments. This approach is taken by CORBA 1 and Java 2. The second approach is indicated for research purposes, to investigate what is appropriate in a language for distributed programming. This article gives an example of the second approach...|$|E
40|$|We {{propose a}} timed {{extension}} of LOTOS, denoted TLOTOS, which is upward {{compatible with the}} standard LOTOS. It means first that a timed behaviour expression which does not use any language extension {{will have the same}} semantics as in standard LOTOS. In addition, we have pushed this <b>upward</b> <b>compatibility</b> one step beyond by requiring and obtaining that all the familiar equivalence laws of standard LOTOS be preserved e. g. B [] B approximately B, B [] stop approximately B. This is needed {{in order to keep the}} intuition of a standard LOTOS user unchanged. TLOTOS has been mainly inspired by other approaches such as Moller Tofts's TCCS (Temporal CCS), Hennessy Regan's TPL (Temporal Process Language) and Nicollin Sifakis's ATP (Algebra of Timed Processes). Our model is not strictly asynchronous (like standard LOTOS, CCS, CSP, ACP) nor strictly synchronous (like SCCS, CIRCAL, Meije). For compatibility and simplicity, we decided to keep the model asynchronous for a large part and, for dealing with time, to introduce a `'synchronous part'' by way of a new basic `'synchronous'' or timed action in the asynchronous semantic model. The design of our TLOTOS is presented together with other possible design alternatives which are all rejected according to our compatibility or expressive power requirements. The solution that we obtain is simple and satifactory, and its operational semantics is presented in depth. Two examples are provided to illustrate the use of TLOTOS. Peer reviewe...|$|E
40|$|In {{conventional}} {{object oriented}} programming languages, objects are transient, that is they are destroyed upon program termination. Storing objects using explicit file access methods may cause objects to lose their manipulation and access semantics since the objects with different declarations may have the same storage representation. In this work persistence is added to C++ in DOS environment through a preprocessor and a class library developed in C++, such that the access and manipulation semantics of objects are preserved. The new language is called C**. The disk management of objects declared as persistent are automatically handled by the system through a virtual memory management emulation. Persistency is implemented as a storage class that is completely orthogonal to type. In other words, persistency is a property of objects, not their classes. Language changes are kept to a minimum, thus among the existing persistent C++ implementations, C* * requires the minimum coding effort. Furthermore objects of any complexity with arbitrary level of pointer indirections to any type of object is supported. As a result, objects are stored on disk as they are represented in memory. <b>Upward</b> <b>compatibility</b> with C++ is preserved. The hybrid object identifier (OID) mechanism implemented in C* * enables dynamic clustering and reduction in the object table size. Although {{there are several other}} persistent C++ implementations, the implementation technique of C** is original in that it provides the user with transparent type modifications and uses operator overloading extensively in realizing persistency. To {{the best of our knowledge}} C* * is the first persistent C++ implementation on DOS with persistence as a storage class...|$|E

