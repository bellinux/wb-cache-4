37|2636|Public
50|$|Another common hybrid is {{to start}} with a {{register}} machine architecture, and add another memory address mode which emulates the push or pop operations of stack machines: 'memaddress = reg; reg += instr.displ'. This was first used in DEC's PDP-11 minicomputer. This feature was carried forward in VAX computers and in Motorola 6800 and M68000 microprocessors. This allowed the use of simpler stack methods in early compilers. It also efficiently supported virtual machines <b>using</b> <b>stack</b> interpreters or threaded code. However, this feature did not help the register machine's own code to become as compact as pure stack machine code. Also, the execution speed was less than when compiling well to the register architecture. It is faster to change the top-of-stack pointer only occasionally (once per call or return) rather than constantly stepping it up and down throughout each program statement, and it is even faster to avoid memory references entirely.|$|E
5000|$|This {{explains}} why, typically, languages that natively support closures {{also use}} garbage collection. The alternatives are manual memory management of non-local variables (explicitly allocating on the heap and freeing when done), or, if <b>using</b> <b>stack</b> allocation, for the language {{to accept that}} certain use cases will lead to undefined behaviour, due to dangling pointers to freed automatic variables, as in lambda expressions in C++11 or nested functions in GNU C. The funarg problem (or [...] "functional argument" [...] problem) describes the difficulty of implementing functions as first class objects in a stack-based programming language such as C or C++. Similarly in D version 1, {{it is assumed that}} the programmer knows what to do with delegates and automatic local variables, as their references will be invalid after return from its definition scope (automatic local variables are on the stack) - this still permits many useful functional patterns, but for complex cases needs explicit heap allocation for variables. D version 2 solved this by detecting which variables must be stored on the heap, and performs automatic allocation. Because D uses garbage collection, in both versions, {{there is no need to}} track usage of variables as they are passed.|$|E
50|$|In the 1970s, Burroughs Corporation was {{organized}} into three divisions {{with very different}} product line architectures for high-end, mid-range, and entry-level business computer systems. Each division's product line grew from a different concept for how to optimize a computer's instruction set for particular programming languages.The Burroughs Large Systems Group designed large mainframes <b>using</b> <b>stack</b> machine instruction sets with dense syllables and 48-bit data words. The first such design was the B5000 in 1961. It was optimized for running ALGOL 60 extremely well, using simple compilers. It evolved into the B5500. Subsequent major redesigns include the B6500/B6700 line and its successors, and the separate B8500 line. 'Burroughs Large Systems' referred {{to all of these}} product lines together, in contrast to the COBOL-optimized Medium Systems (B2000, B3000, B4000) or the flexible-architecture Small Systems (B1000). Founded in the 1880s, Burroughs was the oldest continuously operating entity in computing, but by the late 1950s its computing equipment was still limited to electromechanical accounting machines such as the Sensimatic; as such it had nothing to compete with its traditional rivals IBM and NCR who had started to produce larger-scale computers, or with recently founded Univac. While in 1956 it branded as the B205 a machine produced by a company it bought, its first internally developed machine, the B5000, was designed in 1961 and Burroughs sought to address its late entry in the market with the strategy of a completely different design based on the most advanced computing ideas available at the time. While the B5000 architecture is dead, it inspired the B6500 (and subsequent B6700 & B7700). Computers using that architecture are still in production as the Unisys ClearPath Libra servers which run an evolved but compatible version of the MCP operating system first introduced with the B6700. The third and largest line, the B8500, had no commercial success. In addition to a proprietary CMOS processor design Unisys also uses Intel Xeon processors and runs MCP, Microsoft Windows and Linux operating systems on their Libra servers.|$|E
500|$|Another {{application}} {{cited by}} [...] concerns sorting permutations <b>using</b> <b>stacks.</b>|$|R
5|$|Invader {{also makes}} indoor mosaics <b>using</b> <b>stacks</b> of Rubik's Cubes, and QR code mosaic works.|$|R
50|$|A {{multi-layer}} CCD is a CCD {{image sensor}} that captures true RGB <b>using</b> <b>stacked</b> CCD sensor layers.|$|R
40|$|A scalar metric for {{temporal}} locality is proposed. The metric {{is based}} on LRU stack distance. This paper shows that the cache hit rate can be estimated based on the proposed metric (an error of a few percents can be expected). The metric alleviates high-level memory system outlining and enables <b>using</b> <b>stack</b> processing in run-time locality analysis. 1...|$|E
40|$|We {{present a}} transition-based parser that jointly {{produces}} syntactic and semantic dependencies. It learns {{a representation of}} the entire algorithm state, <b>using</b> <b>stack</b> long short-term memories. Our greedy inference algorithm has linear time, including feature extraction. On the CoNLL 2008 [...] 9 English shared tasks, we obtain the best published parsing performance among models that jointly learn syntax and semantics. Comment: 13 pages, 5 figures, accepted to CoNLL 201...|$|E
40|$|Exceptions are an {{important}} feature of modern programming languages, but their compilation has traditionally been viewed as an advanced topic. In this article we show that the basic method of compiling exceptions <b>using</b> <b>stack</b> unwinding can be explained and verified both simply and precisely, using elementary functional programming techniques. In particular, we develop a compiler for a small language with exceptions, together with a proof of its correctness...|$|E
50|$|Mac OS {{was one of}} the {{earliest}} commercially successful examples of an GUI which <b>used</b> <b>stacking</b> windows.|$|R
5000|$|... #Caption: The {{partially}} <b>used</b> <b>stack</b> interchange over I&#8209;84. SR&#8209;9 traffic {{can be seen}} {{using the}} flyover to access westbound I&#8209;84.|$|R
50|$|The final {{strategy}} is to <b>use</b> <b>stacked</b> headings by adding subheadings underneath main headings, much like in this Wikipedia article itself.|$|R
40|$|Summary. We {{introduce}} an {{implementation of}} Xord- an XSLT processing frame-work which {{enables us to}} design and implement efficient algorithms for clearly char-acterized classes of XSLT transformations with known memory requirements. Within the framework, we design and implement a streaming algorithm <b>using</b> <b>stack</b> of the size proportional to {{the depth of the}} input document and associate it with the class of simple order-preserving and branch-disjoint transformations. The framework pro-vides an unified interface to the underlying algorithms and acts as a standard XSLT processor. ...|$|E
40|$|Security in Java {{depends on}} an access control {{mechanism}} specified operationally in terms of run-time stack inspection. We give a denotational semantics in "eager" form, and show that it {{is equivalent to the}} "lazy" semantics <b>using</b> <b>stack</b> inspection. We give a static analysis of safety, i. e., the absence of security errors, that is significantly simpler than previous proposals. We identify several program transformations {{that can be used to}} remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the "eager" semantics...|$|E
40|$|Security in Java {{depends on}} an access control {{mechanism}} specied operationally in terms of run-time stack inspection. We give a denotational semantics in " form, and show that it {{is equivalent to the}} " semantics <b>using</b> <b>stack</b> inspection. We give a static analysis of safety, i. e., the absence of security errors, that is signicantly simpler than previous proposals. We identify several program transformations {{that can be used to}} remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the " semantics. This material is based upon work supported by the National Science Foundation under Grants EIA- 9806835 and INT- 9813854. A Simple Semantics and Static Analysis for Java Security Anindya Banerjee a; 1 a Stevens Institute of Technology, Hoboken, NJ 07030 USA David A. Naumann b; 2 b Stevens Institute of Technology, Hoboken, NJ 07030 USA Abstract Security in Java depends on an {{access control mechanism}} specied operationally in terms of run-time stack inspection. We give a denotational semantics in " form, and show that it is equivalent to the " semantics <b>using</b> <b>stack</b> inspection. We give a static analysis of safety, i. e., the absence of security errors, that is signi- cantly simpler than previous proposals. We identify several program transformations that can be used to remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the " semantics. ...|$|E
40|$|Sorting organizes {{information}} for optimal usage and is desirable {{in many different}} fields. Noted computer scientist Donald Knuth first considered <b>using</b> <b>stacks</b> of infinite depth as a powerful means to sort data. We extend this work to consider stack-sortable permutations <b>using</b> <b>stacks</b> of specified finite depths. We characterize patterns that sortable permutations must avoid and derive a handy enumeration formula. Further generalizations include the introduction of multiple stacks and {{the analysis of the}} resulting counting sequences...|$|R
50|$|Part of the SMAWK {{algorithm}} {{for finding}} the row minima of a monotone matrix <b>uses</b> <b>stacks</b> {{in a similar}} way to Graham scan.|$|R
40|$|Abstract — In this paper, {{we review}} {{different}} classification methods for emotion recognition from EEG and perform a de-tailed comparison {{of these methods}} on a relatively larger dataset of 45 experiments. We propose to combine the classifiers <b>using</b> <b>stacking</b> to improve the emotion recognition accuracies. Exper-imental {{results show that the}} combination of classifiers <b>using</b> <b>stacking</b> can achieve higher average accuracies than that with-out stacking methods. The weights derived from the classifiers are investigated to extract the relevant features and present their biological interpretation as critical brain areas and critical fre-quency bands...|$|R
40|$|The {{ability to}} display and inspect powder {{diffraction}} data {{quickly and efficiently}} is {{a central part of}} the data analysis process. Whilst many computer programs are capable of displaying powder data, their focus is typically on structure solution. The research proposes a lightweight powder diffraction visualization program with the capability of fast ren dering to compare powder data sets. Based on the success of the earlier version and user requests, Jpowder has been extended to display powder diffraction datasets <b>using</b> <b>stack</b> plot, which options to use meta-data for crystallographic powder diffraction data in XML format. Such stack plots allows crystallographers to identify phase transitions in mate rials. </p...|$|E
40|$|The Java {{virtual machine}} and the. NET common {{language}} runtime feature an {{access control mechanism}} specified operationally in terms of run-time stack inspection. We give a denotational semantics in "eager" form, and show that it {{is equivalent to the}} "lazy" semantics <b>using</b> <b>stack</b> inspection. We give a static analysis of safety, i. e., the absence of security errors, that is simpler than previous proposals. We identify several program transformations {{that can be used to}} remove run-time checks. We give complete, detailed proofs for safety of the analysis and for the transformations, exploiting compositionality of the eager semantics. Comment: In Proceedings Festschrift for Dave Schmidt, arXiv: 1309. 455...|$|E
30|$|Stack Overflow is a community-driven Q&A website used by {{developers}} who post {{and answer questions}} related to computer programming (Bhat, 2014) (approximately 14  M questions and 19  M answers 3). This repository’s questions and answers may receive users’ votes (against/in favor of). Such votes become reputation points that allow developer to have some privileges, such as releasing restrictions on creating a publication and editing questions and answers from other users. Another privilege mechanism involves the assignment of badges, i.e. developer achievements while <b>using</b> <b>Stack</b> Overflow. Developers can get badges from several activities, for instance, a developer can receive a badge if he/she has asked a question that reached {{more than a thousand}} visits.|$|E
5000|$|GEM 1.1 predated Microsoft Windows and <b>used</b> <b>stacking,</b> {{allowing}} all {{windows to}} overlap. As {{a result of}} a lawsuit by Apple, GEM was forced to remove the stacking capabilities.|$|R
50|$|As of 2008, many {{common rail}} and unit {{injection}} systems already employ new injectors <b>using</b> <b>stacked</b> piezoelectric wafers {{in lieu of}} a solenoid, giving finer control of the injection event.|$|R
50|$|Programmers {{commonly}} <b>use</b> <b>stack</b> tracing during interactive and post-mortem debugging. End-users {{may see a}} {{stack trace}} displayed {{as part of an}} error message, which the user can then report to a programmer.|$|R
40|$|The {{duration}} {{of time for}} which each application locks each shared resource is critically important in composing multiple independently-developed applications upon a shared "open" platform. In a companion paper, we formally defined and studied the concept of resource hold time (RHT) - the largest length of time that may elapse between the instant that an application system locks a resource and the instant that it subsequently releases the resource. We extend the discussion and results from to systems scheduled using static-priority scheduling algorithms, with resource access arbitrated <b>using</b> <b>stack</b> resource policy (SRP), or priority ceiling protocol (PCP). We present a method to compute resource hold times for every resource, and an algorithm to decrease them without changing the semantics of the application or compromising application feasibility...|$|E
40|$|We {{studied the}} problem of searching answers for {{questions}} on a Question-and-Answer Website from knowledge bases. A number of research efforts had been developed <b>using</b> <b>Stack</b> Overflow data, which is available for the public. Surprisingly, only a few papers tried to improve the search for better answers. Furthermore, current approaches for searching a Question-and-Answer Website are usually limited to the question database, which is usually the website own content. We showed it is feasible to use knowledge bases as sources for answers. We implemented both vector-space and topic-space representations for our datasets and compared these distinct techniques. Finally, we proposed a hybrid ranking approach that took advantage of a machine-learned classifier to incorporate the tag information into the ranking and showed that {{it was able to}} improve the retrieval performance...|$|E
40|$|The {{duration}} {{of time for}} which each application locks each shared resource is critically important in composing multiple independently-developed applications upon a shared “open ” platform. In a companion paper [13], we formally defined and studied the concept of resource hold time (RHT) — the largest length of time that may elapse between the instant that an application system locks a resource and the instant that it subsequently releases the resource. We extend the discussion and results from [13] to systems scheduled using static-priority scheduling algorithms, with resource access arbitrated <b>using</b> <b>Stack</b> Resource Policy (SRP), or Priority Ceiling Protocol (PCP). We present a method to compute resource hold times for every resource, and an algorithm to decrease them without changing the semantics of the application or compromising application feasibility. ...|$|E
50|$|Some {{computing}} environments <b>use</b> <b>stacks</b> in {{ways that}} may make them vulnerable to security breaches and attacks. Programmers working in such environments must take special care to avoid the pitfalls of these implementations.|$|R
50|$|Windows has <b>used</b> <b>stacking</b> {{ever since}} Windows 2.0, with the {{addition}} of overlapping windows. Prior to that, MS windows used a Tiling window manager. This window manager has remained virtually unchanged since then.|$|R
50|$|Calculators {{employing}} reverse Polish notation <b>use</b> a <b>stack</b> {{structure to}} hold values. Expressions {{can be represented}} in prefix, postfix or infix notations and conversion from one form to another may be accomplished <b>using</b> a <b>stack.</b> Many compilers <b>use</b> a <b>stack</b> for parsing the syntax of expressions, program blocks etc. before translating into low level code. Most programming languages are context-free languages, allowing them to be parsed with stack based machines.|$|R
40|$|A {{compiler}} translates and/or compiles {{a program}} {{written in a}} suitable source language into an equivalent target language {{through a number of}} stages. Starting with recognition of token through target code generation provide a basis for communication interface between a user and a processor in significant amount of time. A new approach GLAP model for design and time complexity analysis of lexical analyzer is proposed in this paper. In the model different steps of tokenizer (generation of tokens) through lexemes, and better input system implementation have been introduced. Disk access and state machine driven Lex are also reflected in the model towards its complete utility. The model also introduces generation of parser. Implementation of symbol table and its interface <b>using</b> <b>stack</b> is another innovation of the model in acceptance with both theoretically and in implementation widely...|$|E
40|$|A {{widely shared}} {{belief in the}} {{software}} engineering community is that stack traces are much sought after by developers to support them in debugging. But limited empirical evidence is available to confirm the value of stack traces to developers. In this paper, we seek to provide such evidence by conducting an empirical study on the usage of stack traces by developers from the ECLIPSE project. Our results provide strong evidence to this effect and also throws light {{on some of the}} patterns in bug fixing <b>using</b> <b>stack</b> traces. We expect the findings of our study to further emphasize the importance of adding stack traces to bug reports and that in the future, software vendors will provide more support in their products to help general users make such information available when filing bug reports. © 2010 IEEE...|$|E
40|$|Particulate {{asbestos}} {{matter is}} withdrawn isokinetically {{from the source}} and collected on a polycarbonate membrane filter maintained at stack temperature. The particulate asbestos is analyzed by microscopic techniques. 1. 2 Applicability: This method applies to the determination of particulate asbestos emissions from stationary sources, <b>using</b> <b>stack</b> sampling and electron microscopy. Using light microscopy, this method gives an index of airborne asbestos fibers for a known source of asbestos fibers; it will not differentiate between asbestos and other fibers. This method is not applicable to stacks that contain liquid droplets or are saturated with water vapor. In addition, this method shall {{not be used as}} written if the projected cross-sectional area of the probe extension-filter holder assembly covers more than 5 percent of the stack cross-sectional area (see Section 4. 1. 2). This method also applies to determining asbesto...|$|E
30|$|This section {{covers the}} {{experimental}} procedures and results. To ease reading, we divide the experimental results into two subsections, one for accuracy {{for each type}} of network models, and the other one for results <b>using</b> <b>stacked</b> ensembles.|$|R
30|$|This {{article is}} {{organized}} as follows: {{the next section}} outlines the general methodology of <b>using</b> <b>stacked</b> NNs for merging multi-sensor datasets, then the successful application of this methodology to total ozone data is presented and finally the conclusions are given.|$|R
40|$|The {{emergence}} of stacks as a hardware device in stack machines implies {{the recognition of}} the importance of <b>using</b> <b>stacks</b> in different computer applications and the need to make use of them in others. This paper <b>uses</b> <b>stacks</b> to solve the sorting problem. Two stack-based sorting algorithms are introduced. The first is based upon sorting by the insertion technique, whereas the second is based upon sorting by the exchange technique. Their analysis and performance are derived when <b>stack</b> computers are <b>used</b> to run them. A comparison study with other sorting algorithms is pre-sented. This study shows that both algorithms have the best performance with a wide margin relative to other sorting algorithms when <b>stack</b> computers are <b>used.</b> 1...|$|R
