211|400|Public
25|$|Allows {{an object}} to draw itself directly, without passing a DataObject to the container. For objects that support both DataObject and this interface, the <b>underlying</b> <b>implementation</b> is usually shared.|$|E
50|$|When {{contracts}} are designed {{in a manner}} that they are based on the <b>underlying</b> <b>implementation</b> details e.g. data models used within the underlying database, this results in a negative form of coupling that needs to be avoided. This way, a change in the <b>underlying</b> <b>implementation</b> will require a corresponding change in the service contract. This type of coupling can be reduced with the introduction of a façade component in between the service logic and its implementation as advocated by the Service Façade design pattern.|$|E
50|$|Random vectors {{are often}} used as the <b>underlying</b> <b>implementation</b> of various types of {{aggregate}} random variables, e.g. a random matrix, random tree, random sequence, random process, etc.|$|E
40|$|We {{present the}} Image Processing Library and Toolbox, IPLT, {{in the context}} of a {{collaborative}} electron microscopy processing effort, which has driven the evolution of our software architecture over the last years. The high-level interface design as well as the <b>underlying</b> <b>implementations</b> are described to demonstrate the flexibility of the IPLT framework. It aims to support the wide range of skills and interests of methodologically oriented scientists who wish to implement their ideas and algorithms as processing code...|$|R
40|$|Sensor {{networks}} are rather challenging to deploy, program, and debug. Current programming languages for these platforms {{suffer from a}} significant semantic gap between their specifications and <b>underlying</b> <b>implementations.</b> This fact precludes the development of (type-) safe applications, which would potentially simplify the task of programming and debugging deployed networks. In this paper we define a core calculus for programming sensor networks and propose {{to use it as}} an assembly language for developing type-safe, high-level programming languages...|$|R
50|$|Mechanism :An <b>underlying</b> GSSAPI <b>implementation</b> that {{provides}} actual names, tokens and credentials. Known mechanisms include Kerberos, NTLM, Distributed Computing Environment (DCE), SESAME, SPKM, LIPKEY.|$|R
50|$|Allows {{an object}} to draw itself directly, without passing a DataObject to the container. For objects that support both DataObject and this interface, the <b>underlying</b> <b>implementation</b> is usually shared.|$|E
50|$|In {{software}} development, a leaky abstraction is {{an abstraction}} that exposes details {{and limitations of}} its <b>underlying</b> <b>implementation</b> to its users that should ideally be hidden away. Leaky abstractions are considered problematic, since the purpose of abstractions is to manage complexity by concealing unnecessary details from the user.|$|E
50|$|OpenVX {{is based}} on a {{connected}} graph of vision nodes that can execute the preferred chain of operations. It is possible to optimize the <b>underlying</b> <b>implementation</b> through various techniques, for example: acceleration on various processing units or dedicated hardware. This architecture facilitates applications programmed in OpenVX on different systems with different power and performance, including battery-sensitive, vision-enabled, wearable displays.|$|E
30|$|Service-oriented {{architecture}} is an architectural style that steers {{all aspects of}} creating and using services throughout their lifecycle, as well as defining and providing the infrastructure that allows heterogeneous applications to exchange data. This communication usually involves the participation in business processes, which are loosely coupled to their <b>underlying</b> <b>implementations.</b> SOA represents a model in which functionality is decomposed into distinct units (services) that can be distributed over a network and can be combined together and reused to create business applications [13].|$|R
5000|$|... #Subtitle level 2: Technological <b>implementations</b> (<b>underlying</b> technology) ...|$|R
50|$|NOTE - Plug-in {{components}} communicate only via {{standard service}} interfaces through a common infrastructure. The service framework is itself layered and {{independent of the}} <b>underlying</b> infrastructure <b>implementation.</b>|$|R
50|$|UMM enables {{to capture}} {{business}} knowledge {{independent of the}} <b>underlying</b> <b>implementation</b> technology, like Web Services or ebXML. The goal is to specify a global choreography of a business collaboration serving as an “agreement” between the participating partners in the respective collaboration. Each business partner derives in turn its local orchestration, enabling {{the configuration of the}} business partner’s system for the use within a service-oriented architecture (SOA).|$|E
50|$|Shell scripts often {{serve as}} an initial stage in {{software}} development, and are often subject to conversion later to a different <b>underlying</b> <b>implementation,</b> most commonly being converted to Perl, Python, or C. The interpreter directive allows the implementation detail to be fully hidden inside the script, rather than being exposed as a filename extension, and provides for seamless reimplementation in different languages with no impact on end users.|$|E
5000|$|Fortress {{was also}} {{designed}} to be both highly parallel and have rich functionality contained within libraries, drawing from Java. For example, the [...] loop construct was a parallel operation, which would not necessarily iterate in a strictly linear manner, depending on the <b>underlying</b> <b>implementation.</b> However, the [...] construct was a library function and could be replaced by another version of the programmer's liking rather than being built into the language.|$|E
40|$|Abstract. Notio [1] is a Java API for {{constructing}} conceptual graph tools and systems. Rather than attempting {{to provide a}} comprehensive toolset, Notio attempts to address the widely varying needs of the CG community by providing a platform {{for the development of}} tools and applications. It is, first and foremost, an API specification for which different <b>underlying</b> <b>implementations</b> may be constructed. A pure Java reference implementation is currently available for development and evaluation of the API, and to guide future implementations. An overview of the motivation, design, and features of Notio is provided...|$|R
5000|$|CIAO also {{provides}} an {{implementation of the}} DDS4CCM standard which integrates DDS as publish-subscribe middleware into the component model. The CIAO DDS4CCM implementation supports RTI DDS and OpenDDS as <b>underlying</b> DDS <b>implementations</b> ...|$|R
40|$|Abstract. Classes play a {{dual role}} in {{mainstream}} statically-typed object-oriented languages, serving as both object generators and object types. In such languages, inheritance implies subtyping. In contrast, the theoretical language community has viewed this linkage as {{a mistake and}} has focused on subtyping relationships determined by the structure of object types, without regard to their <b>underlying</b> <b>implementations.</b> In this paper, we explore why inheritance-based subtyping relations are useful and we present an extension to the MOBY programming language that supports both inheritance-based and structural subtyping relations. In addition, we present a formal accounting of this extension. ...|$|R
50|$|Automation was {{designed}} with {{the ease of}} scripting in mind, so controllers often provide languages such as Visual Basic for Applications to end users, allowing them to control automation objects via scripts. Automation objects are often written in conventional languages such as C++, where C++ attributes {{can be used to}} simplify development, Languages such as Visual Basic and Borland Delphi also provides a convenient syntax for Automation which hides the complexity of the <b>underlying</b> <b>implementation.</b>|$|E
50|$|The Web Audio API {{specification}} {{developed by}} W3C describes a high-level JavaScript API for processing and synthesizing audio in web applications. The primary paradigm {{is of an}} audio routing graph, where a number of AudioNode objects are connected together to define the overall audio rendering. The actual processing will primarily {{take place in the}} <b>underlying</b> <b>implementation</b> (typically optimized Assembly / C / C++ code), but direct JavaScript processing and synthesis is also supported.|$|E
50|$|Alternatively, it is {{possible}} to virtualize disk and tape targets. Rather than representing an actual physical device, an emulated virtual device is presented. The <b>underlying</b> <b>implementation</b> can deviate drastically from the presented target as is done with virtual tape library (VTL) products. VTLs use disk storage for storing data written to virtual tapes. As with actual physical devices, virtual targets are presented by using iSCSI target software, external bridges, or controllers internal to the device enclosure.|$|E
40|$|Classes play a dual rôle in {{mainstream}} statically-typed object-oriented languages, serving as both object generators and object types. In such languages, inheritance implies subtyping. In contrast, the theoretical language community has viewed this linkage as {{a mistake and}} has focused on subtyping relationships determined by the structure of object types, without regard to their <b>underlying</b> <b>implementations.</b> In this paper, we explore why inheritance-based subtyping relations are useful, and we describe two different approaches to extending the  ¢¡¤£¦ ¥ programming language with inheritance-based subtyping relations. In addition, we present a typed object calculus that supports both structural and inheritance-based subtyping, and which provides a formal accounting of our extensions to  ¢¡¤£¦...|$|R
50|$|Clozure CL is also {{commonly}} {{used as an}} <b>underlying</b> Common Lisp <b>implementation</b> for the ACL2 theorem prover.|$|R
50|$|Torch is an {{open source}} machine {{learning}} library, a scientific computing framework, and a script language based on the Lua programming language. It provides {{a wide range of}} algorithms for deep machine learning, and uses the scripting language LuaJIT, and an <b>underlying</b> C <b>implementation.</b>|$|R
50|$|Amazon DynamoDB is a {{fully managed}} {{proprietary}} NoSQL database services that {{is offered by}} Amazon.com {{as part of the}} Amazon Web Services portfolio. DynamoDB exposes a similar data model and derives its name from Dynamo, but has a different <b>underlying</b> <b>implementation.</b> Dynamo had a multi-master design requiring the client to resolve version conflicts and DynamoDB uses synchronous replication across multiple datacenters for high durability and availability. DynamoDB was announced by Amazon CTO Werner Vogels on January 18, 2012.|$|E
5000|$|The service-orientation design {{paradigm}} emphasizes service reuse as {{dictated by}} the service reusability design principle. Under this paradigm of a heavily reused services, reliability becomes critical to ensure service longevity. In turn, service reliability depends on the service's operational control of service logic and <b>underlying</b> <b>implementation</b> resources to reduce dependence on external resources over which it {{has little or no}} control such as shared service logic or a shared database, which may not be available when required by the service.|$|E
50|$|The Java Naming and Directory Interface (JNDI) is a Java API for a {{directory}} service that allows Java software clients {{to discover and}} look up data and objects via a name. Like all Java APIs that interface with host systems, JNDI is independent of the <b>underlying</b> <b>implementation.</b> Additionally, it specifies a service provider interface (SPI) that allows directory service implementations to be plugged into the framework. It may make use of a server, a flat file, or a database; the choice {{is up to the}} vendor.|$|E
40|$|This International Standard {{defines a}} {{conceptual}} schema for observations, and for features involved in sampling when making observations. These provide {{models for the}} exchange of information describing observation acts and their results, both within and between different scientific and technical communities. Observations commonly involve sampling of an ultimate feature of interest. This International Standard defines {{a common set of}} sampling feature types classified primarily by topological dimension, as well as samples for ex-situ observations. The schema includes relationships between sampling features (sub-sampling, derived samples). This International Standard concerns only externally visible interfaces and places no restriction on the <b>underlying</b> <b>implementations</b> other than what is needed to satisfy the interface specifications in the actual situation. JRC. DDG. H. 6 -Spatial data infrastructure...|$|R
30|$|To enable floating-point (FP) signal {{processing}} applications in low-power mobile devices, we propose lightweight floating-point arithmetic. It offers {{a wider range}} of precision/power/speed/area trade-offs, but is wrapped in forms that hide the complexity of the <b>underlying</b> <b>implementations</b> from both multimedia software designers and hardware designers. Libraries implemented in C++ and Verilog provide flexible and robust floating-point units with variable bit-width formats, multiple rounding modes and other features. This solution bridges the design gap between software and hardware, and accelerates the design cycle from algorithm to chip by avoiding the translation to fixed-point arithmetic. We demonstrate the effectiveness of the proposed scheme using the inverse discrete cosine transform (IDCT), in the context of video coding, as an example. Further, we implement lightweight floating-point IDCT into hardware and demonstrate the power and area reduction.|$|R
40|$|As global {{labor costs}} {{increase}} and product life cycles decrease, there is {{renewed interest in}} research in automated manufacturing systems that can be reliably and rapidly configured. Inspired by Turing’s abstractions for computing, Algorithmic Automation explores mathematical abstractions and algorithms that allow the functionality of assembly lines and manufacturing automation systems to be designed independent of their <b>underlying</b> <b>implementations.</b> Abstractions based on minimal sets of geometric primitives can provide the foundation for formal specification, analysis, design, optimization, and verification. Algorithmic Automation is characterized by: (1) formal specification of sets of admissible inputs (eg, polyhedra) and operations (eg, parallel-jaw grasps), (2) complete algorithms that compute all solutions or terminate with a report that no solution exists, and (3) bounds on complexity {{as a function of}} input size. This extended abstract summarizes selected results and open problems...|$|R
50|$|The goal of an SOA is {{to provide}} a {{separation}} between the interface of a service and its <b>underlying</b> <b>implementation</b> such that consumers (applications) can interoperate across the widest set of service providers (implementations) and providers can easily be swapped on-the-fly without modification to application code. Using this architectural style preserves the software development investment as underlying technologies and mechanisms evolve and allows enterprises to incorporate externally developed application software without the cost of a porting effort to achieve interoperability with an existing computing infrastructure.|$|E
50|$|A true model-driven {{environment}} {{model is}} {{a central part of}} an ECO application. The developer alters the model and the changes are applied automatically to the <b>underlying</b> <b>implementation.</b> This allows developers to concentrate on the problem domain model instead of drowning in the implementation specifics. In particular {{there is no need to}} take care of database design which makes ECO applications more object-oriented and less database-oriented. Model construction in ECO is done in visual UML editor. The corresponding code is generated on the fly in either C# or Delphi.NET languages.|$|E
50|$|Forth {{relies heavily}} on {{explicit}} use of a data stack and reverse Polish notation (RPN or postfix notation), commonly used in calculators from Hewlett-Packard. In RPN, the operator is placed after its operands, {{as opposed to the}} more common infix notation where the operator is placed between its operands. Postfix notation makes the language easier to parse and extend; Forth's flexibility makes a static BNF grammar inappropriate, and it does not have a monolithic compiler. Extending the compiler only requires writing a new word, instead of modifying a grammar and changing the <b>underlying</b> <b>implementation.</b>|$|E
40|$|Abstract. Generalized {{algebraic}} {{data types}} (GADTs) allow to write sophisticated, type-safe programs and transformations. But not many languages, respectively their <b>underlying</b> <b>implementations,</b> support GADTs. We show that Pottier's and Gauthier's polymorphic typed defunctionalization, {{which was supposed}} to rely on GADTs, can actually be represented in Haskell 98. Our results help to get a better understanding of GADTs and we identify sufficient conditions under which we can replace GADTs with features available in standardized languages such as Haskell 98. 1 Introduction Generalized algebraic data types (GADTs) are an extension of (boxed) existen-tial types [12]. In contrast to algebraic data types we may refine the type of a GADT depending on the particular constructor. The power behind GADTs isthat we can make use of these type refinements when pattern matching over a GADT...|$|R
40|$|To enable floating-point (FP) signal {{processing}} applications in low-power mobile devices, we propose lightweight floating-point arithmetic. It offers {{a wider range}} of precision/power/speed/area tradeoffs, but is wrapped in forms that hide the complexity of the <b>underlying</b> <b>implementations</b> from both multimedia software designers and hardware designers. Libraries implemented in C and Verilog provide flexible and robust floating-point units with variable bit-width formats, multiple rounding modes and other features. This solution bridges the design gap between software and hardware, and accelerates the design cycle from algorithm to chip by avoiding the translation to fixed-point arithmetic. We demonstrate the effectiveness of the proposed scheme using the inverse discrete cosine transform (IDCT), in the context of video coding, as an example. Further, we implement lightweight floating-point IDCT into hardware and demonstrate the power and area reduction...|$|R
40|$|The Partitioned Global Address Space model {{combines}} {{the expression of}} data locality in SPMD applications, which is crucial to achieving good parallel performance, with the relative simplicity of the Distributed Shared Memory model. C++ currently lacks language support for PGAS semantics; however, C++ is an excellent host language for implementing Domain-Specific Embedded Languages (DSELs). Leveraging these capabilities of C++, we have implemented the Partitioned Global Property Map, a DSEL library supporting PGAS semantics, polymorphic parti-tioned global data structures, {{and a number of}} useful exten-sions. The Partitioned Global Property Map library utilizes template meta-programming to allow direct mapping at compile-time of high-level semantics to efficient <b>underlying</b> <b>implementations.</b> It combines flexible/extensible semantics, high performance, and portability across different low-level communication interfaces to allow PGAS programs to be expressed in C++. 1...|$|R
