11|36|Public
5000|$|... val y = x; stdIn:1.9 Error: <b>unbound</b> <b>variable</b> or constructor: x ...|$|E
5000|$|... in {{the second}} clause. X is an <b>unbound</b> <b>variable,</b> while a is a bound value (term). Unifying the two {{produces}} the substitution ...|$|E
5000|$|... {{except for}} two special [...] "hook macros" [...] that {{implement}} <b>unbound</b> <b>variable</b> lookup and function calls, instead of these, new forms are provided to ...|$|E
40|$|A novel {{scheme for}} {{representing}} <b>unbound</b> <b>variables</b> was proposed by Taylor: that aliased <b>unbound</b> <b>variables</b> are represented as circular chains of cells. Unfortunately, few details were given on its implementation and the involved trade offs. We compare the proposed scheme {{to that of}} Warren's abstract machine, and find that Taylor's scheme (a) leads to increased trailing, (b) makes stack allocation more difficult, (c) requires more expensive copying of heap cells at times, and (d) has a more expensive variable binding mechanism. On the positive side, a very strong advantage is that Taylor's scheme entirely dispenses with pointer chain dereferencing. We conclude by enumerating the data flow properties a global analyzer should find in order to eliminate these difficulties. 1 Introduction Taylor presented an intriguing representation of <b>unbound</b> logic <b>variables</b> in his thesis [5]. The standard WAM scheme [9] represents variables as pointers and <b>unbound</b> <b>variables</b> as self-pointers. Variable bi [...] ...|$|R
5000|$|If any <b>unbound</b> <b>variables</b> {{which were}} bound in the unified predicates also occur in other predicates {{in the two}} clauses, replace them with their bound values (terms) there as well.|$|R
5000|$|That is, {{variable}} reference, abstractions, application, and constant. A variable reference [...] {{is bound}} {{if it is}} inside of an abstraction binding [...] A term is closed {{if there are no}} <b>unbound</b> <b>variables.</b>|$|R
5000|$|When {{the program}} {{encounters}} an <b>unbound</b> <b>variable</b> it {{waits for a}} value. For example, below, the thread will wait until both X and Y are bound to a value before showing the value of Z.thread [...] Z = X+Y {Browse Z}endthread X = 40 endthread Y = 2 end ...|$|E
50|$|Various {{programming}} languages have various different scoping {{rules for}} {{different kinds of}} declarations and identifiers. Such scoping rules have a large effect on language semantics and, consequently, on the behavior and correctness of programs. In languages like C++, accessing an <b>unbound</b> <b>variable</b> does not have well-defined semantics and may result in undefined behavior, similar to referring to a dangling pointer; and declarations or identifiers used outside their scope will generate syntax errors.|$|E
5000|$|A first-order {{formula is}} {{built out of}} atomic {{formulas}} such as R(f(x,y),z) or y = x + 1 {{by means of the}} Boolean connectives [...] and prefixing of quantifiers [...] or [...] A sentence is a formula in which each occurrence of a variable is in the scope of a corresponding quantifier. Examples for formulas are φ (or φ(x) to mark the fact that at most x is an <b>unbound</b> <b>variable</b> in φ) and ψ defined as follows: ...|$|E
5000|$|A {{statement}} may be meaningless if {{its terms}} are undefined, {{or if it}} contains <b>unbound</b> <b>variables.</b> For instance, the sentence [...] "All X have Y" [...] is meaningless unless the terms X and Y are defined (or bound).|$|R
5000|$|In partial {{evaluation}}, evaluation {{may continue}} {{into the body}} of a function that has not been applied. Any sub-expressions that do not contain <b>unbound</b> <b>variables</b> are evaluated, and function applications whose argument values are known may be reduced. In the presence of side-effects, complete partial evaluation may produce unintended results; for this reason, systems that support partial evaluation tend to do so only for [...] "pure" [...] expressions (expressions without side-effects) within functions.|$|R
40|$|The {{analytical}} inductive {{programming system}} IGOR II is an implemented prototype for constructing recursive functional programs from few non-recursive, possibly non-ground example equations describing {{a subset of}} the input/output (I/O) behaviour of a function. Starting from an initial, overly general program hypothesis, stepwise several refinement operators are applied which compute successor hypotheses. Organised as an uniformed-cost search, the hypothesis with the lowest costs is developed and replaced by its successors until the best does not contain any <b>unbound</b> <b>variables...</b>|$|R
5000|$|The terms {{parameter}} and argument {{are sometimes}} used interchangeably, and the context {{is used to}} distinguish the meaning. The term parameter (sometimes called formal parameter) {{is often used to}} refer to the variable as found in the function definition, while argument (sometimes called actual parameter) refers to the actual input passed. For example, if one defines a function as , then [...] is the parameter, while if it called by [...] then [...] is the argument. In both cases a parameter is an (<b>unbound)</b> <b>variable,</b> while the argument {{can be thought of as}} a value or variable, depending on the calling convention. In case of call by value, one can think of the argument as a value (properly, as the value of the argument) - for example, [...] and [...] are equivalent calls - while in call by reference one can think of the argument as a variable in the calling context.|$|E
40|$|Machine (WAM), so that ages of {{variable}} bindings {{can be easily}} found using this new representation. The age of a variable bound to a ground term will be the youngest choice point suchthatbacktracking to that choice point can make that variable an <b>unbound</b> <b>variable</b> again. In other words, the age of a variable bound to a ground term will be {{the age of the}} youngest one of bindings causing that variable to be bound to that ground term. Variable ages are used in the process of guring out backtracking points in an intelligent backtracking schema. We also introduce an algorithm to compute variable ages and justi cations why itworks. ...|$|E
40|$|PLASM (Programming LAnguage for Solid Modelling) is a prototype, high level, user oriented, {{functional}} design language currently being {{developed at the}} University of Rome “La Sapienza”. A PLASM “program” is the symbolic definition of a complex of variational polyhedra depending on some <b>unbound</b> <b>variable,</b> and therefore allows for the description of {{a whole set of}} geometric solutions to a design problem. In our view the language should be used, possibly with the assistance of a graphical user interface, both in the first steps of the design process as well in the detailed design. In the paper the guide-lines are shown for the preliminary definition of the syntax of the language. The paper also contains the definition of some new and very powerful solid operators...|$|E
50|$|The {{fundamental}} {{problem is that}} HLLCAs only simplify the code generation step of compilers, which is typically a relatively small part of compilation, and a questionable use of computing power (transistors and microcode). At the minimum tokenization is required, and typically syntactic analysis and basic semantic checks (<b>unbound</b> <b>variables)</b> will still be performed - {{so there is no}} benefit to the front end - and optimization requires ahead-of-time analysis - so there is no benefit to the middle end.|$|R
50|$|Function {{scope is}} {{significantly}} more complicated if functions are first-class objects {{and can be}} created locally to a function and then returned. In this case any variables in the nested function that are not local to it (<b>unbound</b> <b>variables</b> in the function definition, that resolve to variables in an enclosing context) create a closure, as not only the function itself, but also its environment (of variables) must be returned, and then potentially called in a different context. This requires significantly more support from the compiler, and can complicate program analysis.|$|R
40|$|Abstract. The paper {{shows an}} {{implementation}} model {{to support the}} execution of the Basic Andorra Model on distributed memory systems. A model for exploiting dependent AND parallelism in Prolog programs on distributed systems is also proposed, as well as {{the way in which it}} has to be combined with an OR parallel model. A mechanism for dealing with <b>unbound</b> <b>variables</b> in a distributed environment is proposed. In the current implementation, the arrangement of workers in the system in order to mix both models is done in a static way at the beginning of computation...|$|R
40|$|We {{present a}} new method to {{represent}} variable bindings in the Warren Abstract Machine (WAM), so that ages of variable bindings {{can be easily}} found using this new representation in our intelligent backtracking schema. The age of a variable bound to a non-variable term will be the youngest choice point such that backtracking to that choice point can make that variable an <b>unbound</b> <b>variable</b> again. In other words, the age of a variable bound to a non-variable term will be {{the age of the}} youngest one of bindings causing that variable to be bound to that non-variable term. The procedure backtracking point is the choice point of the procedure being currently executed or the choice point of its first ancestor having a choice point. Variable ages and procedure backtracking points are used in the process of figuring out backtracking points in our intelligent backtracking schema. Our intelligent backtracking schema performs much better than results of other intelligent backtracking methods in the l [...] ...|$|E
40|$|Abstract. Parameterized runtime {{monitoring}} formalisms allow predicates to bind free {{variables to}} values during the program’s execution. Some runtime monitoring tools, like J-LO, increase the formalism’s expressiveness by allowing predicates to query variables already during the matching process. This is problematic because, if no special care is taken, the predicate’s evaluation {{may need to}} query a variable {{that has not yet}} been bound, rendering the entire formula meaningless. In this paper we present a syntactic checking algorithm that recognizes meaningless formulas in future-time linear temporal logic. The algorithm assures that a predicate accesses a potentially <b>unbound</b> <b>variable</b> only when the truth value of this predicate cannot possibly impact the truth value of the entire formula at the time the predicate is being evaluated. Our approach allows users to specify a wide range of meaningful parameterized logic formulas, {{while at the same time}} forbidding such formulas that would otherwise have an unclear semantics due to insu cient bindings. We have implemented the checking algorithm in the J-LO runtime verification tool. ...|$|E
5000|$|Logic {{programming}} languages such as Prolog don't {{even have}} return values. Instead, <b>unbound</b> logical <b>variables</b> {{are used as}} output parameters, to be unified with values constructed in a predicate call.|$|R
40|$|Abstract We {{present a}} new {{approach}} for dealing with binders when formalising a logi-cal meta-theory. Our approach is similar to Pollack-McKinna’s locally named approach with parameters for locally <b>unbound</b> <b>variables</b> and we introduce for this purpose the so-called notion of destined substitution. This approach {{has been used to}} formalise in Coq a proof of Kripke-based semantical cut-elimination for minimal first-order predi-cate logic. We also investigated how constants and free variables could be merged in such a formalisation. Using parameters for locally <b>unbound</b> <b>variables</b> allows us to talk about well-formed terms and formulae without an extra syntax. Merging constants and free variables sim-plifies the process of formalisation in a significant way. The destined substitution opens a possibility of using simple structural induction where it is not accepted. We explain how to avoid the depth induction principle which is based on the complexity of formu-lae and seems to be essential when two sorts of variables are used for formalisation. Furthermore, we compare three equivalent ways of quantification: Cofinite, All-Fresh, and the traditional One-Fresh style. Finally, there is a meta-mathematical discussion on the meaning of free variables, bound variables, and constants. We tried to make all the statements as acceptable as possible for logicians while keeping the computational contents and the conciseness of the semantical cut-elimination as simple as possible. Keywords Formalisation with binders · locally named approach · normalisation by evaluation · intuitionistic predicate logic · Coq Grants or other note...|$|R
40|$|Abstract. We {{study the}} {{semantics}} of SPARQL queries with optional matching features under entailment regimes. We {{argue that the}} normative semantics may lead to answers that are {{in conflict with the}} intuitive mean-ing of optional matching, where <b>unbound</b> <b>variables</b> naturally represent unknown information. We propose an extension of the SPARQL algebra that addresses these issues and is compatible with any entailment regime satisfying the minimal requirements given in the normative specification. We then study the complexity of query evaluation and show that our extension comes at no cost for regimes with an entailment relation of reasonable complexity. Finally, we show that our semantics preserves the known properties of optional matching that are commonly exploited for static analysis and optimisation. ...|$|R
40|$|A formal {{consideration}} {{in this paper}} is given for the essential notations to characterize the object that is distinguished in a problem domain. The distinct object is represented by another idealized object, which is a schematic element. When {{the existence of an}} element is significant, then a class of these partial elements is dropped down into actual, potential and virtual objects. The potential objects are gathered into the variable domains which are the extended ranges for <b>unbound</b> <b>variables.</b> The families of actual objects are shown to be parameterized with the types and events. The transitions between events are shown to be driven by the scripts. A computational framework arises which is described by the commutative diagrams. Key words: concept, data object, event, individual, metadata object, state, script, type, variable domai...|$|R
40|$|AbstractA {{method is}} {{presented}} for executing PROLOG programs which avoids almost all unnecessary occur-checks. The method {{is based on}} a dynamic classification of the context in which logical variables occur. No static global analysis of the PROLOG program is required to detect the places where an occur-check has to be made. The presented method has also an important side benefit. It considerably cuts down on the number of memory references during the execution of PROLOG programs. Furthermore, in most cases it avoids “trailing” and “untrailing” of <b>unbound</b> <b>variables</b> altogether. Due to this fact the employed method actually speeds up PROLOG execution. The method is discussed in terms of an actual implementation based on the Warren abstract PROLOG instruction set. However, the method should be applicable to other implementation models as well. No assumptions are made with respect to particular hardware...|$|R
40|$|Abstract. In {{this paper}} we propose {{off-line}} and on-line extensions to the Resource Constrained Project Scheduling Problem. The off-line ex-tension is a variant of RCPSP with time lags and uncertain, bounded activity durations. In this context we improve over our previous work pre-sented in [12] by proposing an incremental flow computation for finding minimal conflict sets {{and a set of}} filtering rules for cumulative constraint propagation. The on-line extension is based instead on considering an on-line semantics such as the Self-Timed Execution and take it into ac-count in the scheduling process. Adding the on-line aspect to the prob-lem makes the CSP framework no longer suitable. We have extended the CSP framework to take into account general search decisions and aux-iliary <b>unbound</b> <b>variables.</b> An extensive set of experimental results show an improvement of up to two orders of magnitude over our previous approach. 1 Introduction...|$|R
40|$|Stratified {{institutions}} and elementary homomorphismsInternational audienceFor conventional logic institutions, when one extends the sentences to contain open sentences, their satisfaction is then parameterized. For instance, in the ﬁrst-order logic, the satisfaction is parameterized by the valuation of <b>unbound</b> <b>variables,</b> while in modal logics it is further by possible worlds. This paper proposes a uniform treatment of such parameterization of the satisfaction relation within the abstract setting of logics as institutions, by deﬁning the new notion of stratiﬁed institutions. In this new framework, {{the notion of}} elementary model homomorphisms is deﬁned independently of an internal stratiﬁcation or elementary diagrams. At this level of abstraction, a general Tarski style study of connectives is developed. This is an abstract uniﬁed approach to the usual Boolean connectives, to quantiﬁers, and to modal connectives. A general theorem subsuming Tarski's elementary chain theorem is then proved for stratiﬁed institutions with this new notion of connectives...|$|R
40|$|We {{report on}} a {{technique}} for interfacing an untyped logic language to a statically poly morphically typed functional language Our key insight is that polymorphic types {{can be interpreted as}} need to know speci cations on function arguments This leads to a crite rion for liberally yet safely invoking the functional language to reduce application terms as required during uni cation in the logic language This method called P	uni cation enriches the capabilities of each language while retaining the integrity of their individual semantics and implementation technologies An experimental test has been successfully performed whereby a Horn clause logic programming HCLP interpreter written in Common Lisp was interfaced to the Standard ML of New Jersey system The latter implementation was employed i on untyped or dynamically typed data even though it is statically typed ii lazily even though it is strict and iii on alien HCLP terms such as <b>unbound</b> <b>variables</b> without the slightest modi catio...|$|R
40|$|Communicated by J. L. Fiadeiro www. elsevier. com/locate/ipl For {{conventional}} logic institutions, {{when one}} extends the sentences to contain open sentences, their satisfaction is then parameterized. For instance, in the first-order logic, the satisfaction is parameterized by the valuation of <b>unbound</b> <b>variables,</b> while in modal logics it is further by possible worlds. This paper proposes a uniform treatment of such parameterization of the satisfaction relation within the abstract setting of logics as institutions, by defining the new notion of stratified institutions. In this new framework, {{the notion of}} elementary model homomorphisms is defined independently of an internal stratification or elementary diagrams. At this level of abstraction, a general Tarski style study of connectives is developed. This is an abstract unified approach to the usual Boolean connectives, to quantifiers, and to modal connectives. A general theorem subsuming Tarski’s elementary chain theorem is then proved for stratified institutions with this new notion of connectives...|$|R
40|$|Semistructured data {{occur in}} {{situations}} where information lacks a homogeneous structure and is incomplete. Yet, up to now the incompleteness of information has not been reflected by special features of query languages. Our goal is to investigate the principles of queries that allow for incomplete answers. We do not present, however, a concrete query language. Queries over classical structured data models contain a number of variables and constraints on these variables. An answer is a binding of the variables by elements of the database such that the constraints are satisfied. In the present paper, we loosen this concept {{in so far as}} we allow also answers that are partial, that is, not all variables in the query are bound by such an answer. Partial answers make it necessary to refine the model of query evaluation. The first modification relates to the satisfaction of constraints: under some circumstances we consider constraints involving <b>unbound</b> <b>variables</b> as satisfied. Second, in o [...] ...|$|R
2500|$|In a type , {{the symbol}} [...] is the {{quantifier}} binding the type variables [...] in the monotype [...] The variables [...] are called quantified and any occurrence of a quantified type variable in [...] is called bound and all <b>unbound</b> type <b>variables</b> in [...] are called free. Like in the lambda calculus, {{the notion of}} free and bound variables {{is essential for the}} understanding of the meaning of types.|$|R
40|$|Access {{control is}} key to {{limiting}} the actions of users in an application and attribute-based policy languages such as XACML allow to express {{a wide range of}} access rules. As these policy languages become more widely used, policies grow both in size and complexity. Modularity and reuse are key to specifying and managing such policies effectively. Ideally, complex or domain-specific policy patterns are defined once and afterwards instantiated by security experts in their application-specific policies. However, current policy languages such as XACML provide only limited features for modularity and reuse. To address this issue, we introduce policy templates as part of a novel attribute-based policy language called STAPL. Policy templates are policies containing <b>unbound</b> <b>variables</b> that can be specified when instantiating the template in another policy later on. STAPL supports four types of policy templates with increasing complexity and expressiveness. This paper illustrates how these policy templates can be used to define reusable policy patterns and validates that policy templates are an effective means to simplify the specification of large and complex attribute-based policies. status: publishe...|$|R
40|$|Semistructured data {{occur in}} {{situations}} where information lacks a homoge-neous structure and is incomplete. Yet, up to now the incompleteness of infor-mation has not been re ected by special features of query languages. Our goal is to investigate the principles of queries that allow for incomplete answers. We do not present, however, a concrete query language. Queries over classical structured data models contain a number of variables and constraints on these variables. An answer is a binding of the variables by elements of the database such that the constraints are satised. In the pres-ent paper, we loosen this concept {{in so far as}} we allow also answers that are partial, that is, not all variables in the query are bound by such an answer. Partial answers make it necessary to rene the model of query evaluation. The rst modication relates to the satisfaction of constraints: under some circumstances we consider constraints involving <b>unbound</b> <b>variables</b> as satised. Second, in order to prevent a proliferation of answers, we only accept answer...|$|R
40|$|Regression {{analysis}} {{includes many}} techniques for modeling and analyzing {{the relationship between}} a dependent variable and one or more independent variables. Linear and nonlinear regression models has widely used in many fields of applied science. One of the frequency problems in regression analysis is multicollinearity problem between the explanatory variables. If there is no linear (approximately linear) relationship between the regressors, they are said to be orthogonal. In the case of orthogonal variables, statistical inference on the model is quite reliable. But in real life, fully <b>unbound</b> <b>variables</b> which are explaining the dependent variable are likely to be very low. When the explanatory variables are not orthogonal, then least squares parameter estimation method will not provide a suitable convergence, and deviations from reality will ocur. For the linear model, many techniques were developed for the multicollinearity problem (Hoerl, AE (1962), Hoerl AE and Kennard RW (1968. 1970)), but for nonlinear models there has not been any conclusive work yet. In this study, multicollinearity in nonlinear models will be analyzed and a remedy for the problem will be given...|$|R
40|$|In the Tractatus Wittgenstein {{argued that}} there are metaphysical truths. But these are ineffable, for metaphysical {{sentences}} try to say {{what can only be}} shown. Accordingly, they are pseudo-propositions because they are ill-formed. In the Investigations he no longer thought that metaphysical propositions are pseudo-propositions, but argued that they are either nonsense or norms of descriptions. Popper criticized Wittgenstein's ideas and argued that metaphysical truths are effable. Yet it is by now clear that he misunderstood Wittgenstein's arguments (namely that metaphysical propositions are ill-formed because they employ <b>unbound</b> <b>variables)</b> and misguidedly thought that Wittgenstein used the principle of verification for distinguishing empirical propositions from metaphysical propositions. Because Popper developed his philosophy in part as a critique of Wittgenstein's philosophy, this invites the question of whether these misunderstandings have consequences for his own philosophy. I discuss this question and argue that Popper's attempt to distinguish metaphysics and science {{with the aid of a}} criterion of testability is from Wittgenstein's perspective misguided. The main problem facing Popper's philosophy is that alleged metaphysical propositions are not theoretical propositions but rules for descriptions (in the misleading guise of empirical propositions). If Wittgenstein's ideas are correct, then metaphysical problems are not scientific but grammatical problems which can only be resolved through conceptual investigations...|$|R
5000|$|The {{declarative}} concurrent {{model can}} be extended with message passing via simple semantics:declarelocal Stream Port in Port = {NewPort Stream} {Send Port 1} % Stream is now 1|_ ('_' indicates an <b>unbound</b> and unnamed <b>variable)</b> {Send Port 2} % Stream is now 1|2|_ ... {Send Port n} % Stream is now 1|2| [...]. |n|_end ...|$|R
