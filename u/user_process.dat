137|2802|Public
25|$|Typical {{computer}} systems today use hardware-enforced rules about what programs {{are allowed to}} access what data. The processor monitors the execution and stops a program that violates a rule (e.g., a <b>user</b> <b>process</b> that is about to read or write to kernel memory, and so on). In systems that lack support for capabilities, processes are isolated from each other by using separate address spaces. Calls from user processes into the kernel are regulated by requiring them {{to use one of}} the above-described system call methods.|$|E
500|$|Plan 9 {{can support}} POSIX {{applications}} and can emulate the Berkeley socket interface through the ANSI/POSIX Environment (APE) that implements an interface close to ANSI C and POSIX, with some common extensions (the native Plan 9 C interfaces conform to neither standard). It {{also includes a}} POSIX-compatible shell. APE's authors claim to have used it to port the X Window System (X11) to Plan 9, although they do not ship X11 [...] "because supporting it properly is too big a job". Some Linux binaries {{can be used with}} the help of a [...] "linuxemu" [...] (Linux emulator) application; however, it is still a work in progress. Vice versa, the vx32 virtual machine allows a slightly modified Plan 9 kernel to run as a <b>user</b> <b>process</b> in Linux, supporting unmodified Plan 9 programs.|$|E
2500|$|The {{method of}} invoking the kernel {{function}} varies from kernel to kernel. If memory isolation is in use, {{it is impossible}} for a <b>user</b> <b>process</b> to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are: ...|$|E
5000|$|... <b>user</b> <b>processes</b> {{involve the}} {{invocation}} of application software ...|$|R
40|$|The paper {{presents}} a new analysis method {{for a class}} of concurrent systems which are formed of several interacting components with the same structure. The model for these systems is composed of a control process {{and a set of}} homogeneous <b>user</b> <b>processes.</b> The control and <b>user</b> <b>processes</b> are modeled by finite labeled state transition systems which interact by means of enabling functions and triggering mechanisms. Based on this structure, an analysis method is presented which allows system properties, derived by reachability analysis for a finite number of <b>user</b> <b>processes,</b> to be generalized to an arbitrary number of <b>user</b> <b>processes.</b> A procedure for the automatic verification of properties such as mutual exclusion and absence of deadlocks is presented and is then used to provide {{for the first time a}} fully automated verification of the Lamport's fast mutual exclusion algorithm...|$|R
40|$|The CPU time {{allocated}} to <b>user</b> <b>processes</b> is rendered inaccurate by an unexpectedly and frequently occurring interrupt and a bottom half that consumes most interrupt processing time. Additionally, {{when the time}} consumed in the kernel mode greatly fluctuates with interrupt processing, the scheduler cannot distribute CPU time to <b>user</b> <b>processes</b> normally. This problem can dramatically distort the stable execution time of <b>user</b> <b>processes.</b> In addition, such time-sensitive applications as multimedia players cannot provide consistent quality. To overcome this stolen-time problem, we propose a bottom half scheduling approach that dynamically restricts the maximum time consumed by bottom halves. In this paper, we implement our proposed scheme in Linux 2. 4. In addition, we show that the fluctuation of CPU time {{allocated to}} <b>user</b> <b>processes</b> by stolen-time can be shrunk with our proposed scheme by means of experiments using a multimedia application. 1...|$|R
5000|$|To {{understand}} the difference, consider two interacting programs, one feeding a file to another. Under Aleph {{the data from}} the provider would have to be copied 2kB at a time (due to features of the Eclipse) into the <b>user</b> <b>process.</b> Under Accent the data simply [...] "appeared" [...] in the <b>user</b> <b>process</b> for the cost of a few instructions sent to the MMU. Only if the <b>user</b> <b>process</b> changed the data would anything need to be copied, and even then, only the portions of the data that actually changed.|$|E
50|$|In {{the message}} passing approach, the <b>user</b> <b>process</b> {{constructs}} a message, {{that describes the}} desired service. Then it uses a trusted send function to pass the message to a trusted OS process. The send function serves the same purpose as the trap; that is, it carefully checks the message, switches the processor to kernel mode, and then delivers the message to a process that implements the target functions. Meanwhile, the <b>user</b> <b>process</b> waits for {{the result of the}} service request with a message receive operation. When the OS process completes the operation, it sends a message back to the <b>user</b> <b>process.</b>|$|E
5000|$|... a {{connection}} {{refers to the}} pathway linking a <b>user</b> <b>process</b> to an Oracle instance ...|$|E
5000|$|Alina {{inspects}} the <b>user's</b> <b>processes</b> {{with the}} help of Windows API calls: ...|$|R
5000|$|Suppose that, in a <b>user</b> <b>process's</b> memory space, {{there exists}} the {{following}} string: ...|$|R
40|$|In todayâ€™s multicomputers, {{software}} overhead {{dominates the}} message-passing latency cost. We designed two multicomputer network interfaces that signif~cantiy reduce this overhead. Both support vMual-memory-mapped communication, allowing <b>user</b> <b>processes</b> to communicate without expensive buffer management and without making system calls across the protection boundary separating <b>user</b> <b>processes</b> from {{the operating system}} kerneL Here we compare the two interfaces and discuss the performance trade-offs between them...|$|R
50|$|For VMS, P0 {{was used}} for <b>user</b> <b>process</b> space, P1 for process stack, S0 for the {{operating}} system, and S1 was reserved.|$|E
5000|$|Where an X display {{manager is}} employed, a login session is {{considered}} to be the lifetime of a designated <b>user</b> <b>process</b> that the display manager invokes.|$|E
5000|$|The {{architecture}} of the network interface has been developed to offload the entire task of interprocessor communication from the main processor, and to avoid the overhead of system calls for <b>user</b> <b>process</b> to <b>user</b> <b>process</b> messaging. QsNetII is designed for use within SMP systems [...] - [...] multiple, concurrent processes can utilise the network interface without any task switching overhead. A I/O processor offloads protocol handling from the main CPU. Local memory on the PCI card provides storage for buffers, translation tables and I/O adapter code. All the PCI bandwidth is available to data communication.|$|E
5000|$|An {{advanced}} {{software interrupt}} facility that allowed <b>user</b> <b>processes</b> to operate asynchronously, using complex interrupt handling mechanisms.|$|R
5000|$|A general {{mechanism}} for implementing virtual devices in software running in <b>user</b> <b>processes</b> (which were called [...] "jobs" [...] in ITS).|$|R
50|$|The Clipper-powered Orions ran OTS version 2.x, a port of the 4.2BSD UNIX {{with some}} additions. This was not notably {{reliable}} or secure, {{and had a}} tendency to 'forget' <b>process</b> <b>user</b> IDs, randomly leaving <b>user</b> <b>processes</b> running as root.|$|R
5000|$|... "The lengthy of {{the lead}} <b>user</b> <b>process</b> can prevent this {{methodology}} from being applied effectively in industries with really short term innovation cycles or where quick turnaround from research to market delivery is required;" ...|$|E
50|$|MSS {{software}} development started in 1990 before MSS hardware was available by applying paravirtualization techniques to VxWorks and running each CP or FP application payload on Sun SPARC workstations, each as a Unix <b>user</b> <b>process.</b>|$|E
5000|$|Kevin Herbert, later {{working for}} DEC, added an undocumented {{feature in the}} 90's to allow a user to enter ^F to see a list of open files the <b>user</b> <b>process</b> had, {{complete}} with blocks in use and file sizes ...|$|E
5000|$|Access Control (PR.AC): Access to {{assets and}} {{associated}} facilities {{is limited to}} authorized <b>users,</b> <b>processes,</b> or devices, and to authorized activities and transactions.|$|R
50|$|Another {{reason for}} {{performance}} challenges are because IPS technologies dynamic signatures make inspection applications {{need to run}} <b>user</b> <b>processes</b> outside of the operating system kernel to avoid outages incurred from kernel reloads or system reboots. <b>User</b> <b>processes</b> typically suffer from higher overhead due to their separation from the governing operating systems' memory and process management policies. Firewall technologies traditionally run {{as part of the}} operating system kernel. The performance concerns are reduced due to tight coupling with operating system internals.|$|R
50|$|All I/O {{operations}} were initiated by a privileged supervisor process, {{known as the}} executive. <b>User</b> <b>processes</b> communicated with executive using extracodes, instructions that caused a trap into the executive when run. Executive would then communicate with the appropriate peripheral via the Standard Interface, using functions not available to <b>user</b> <b>processes.</b> The subsequent data transfers would then occur across this interface, autonomously without further program involvement. The conclusion of the transfers (or error if any) would similarly be indicated back to the executive.|$|R
50|$|As an {{authoring}} language, TUTOR {{began with}} only minimal memory resources {{and only the}} crudest tools for manipulating them. Each <b>user</b> <b>process</b> had a private data segment of 150 variables, and shared common blocks could be attached, allowing interuser communication through shared memory.|$|E
5000|$|Agrawala's work {{focuses on}} the design of visual {{interfaces}} that help a <b>user</b> <b>process</b> digital information, often using cognitive design concepts. For instance, LineDrive, a program developed by Agrawala, creates route maps that resemble hand-drawn maps, adapting cognitive and map-making techniques to help a computer <b>user</b> <b>process</b> information on a route. This work was the focus of his 2002 Ph.D. dissertation, [...] "Visualizing Route Maps". He has also adapted cognitive science into visual interfaces for complex 3D models. Agrawala has also developed a system that creates step-by-step assembly instructions for complex machines, using the idea of exploded views to help the user understand the spatial relationships between elements. His user-centric approach is viewed as having broad applicability in the fields of computer graphics and user interfaces.|$|E
5000|$|The {{method of}} invoking the kernel {{function}} varies from kernel to kernel. If memory isolation is in use, {{it is impossible}} for a <b>user</b> <b>process</b> to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are: ...|$|E
40|$|In {{this paper}} {{we present a}} {{framework}} in which issues such as mobility and security {{in the presence of}} firewalls can be studied. The framework is based on a simple language where mobility is expressed as atomic actions and the behaviour of a firewall is described as logical formulae. We also separate the role of co-ordinators from normal <b>user</b> <b>processes.</b> Co-ordinators can reconfigure firewalls based on the behaviour of the <b>user</b> <b>processes</b> as well as the behaviour of other co-ordinators...|$|R
50|$|Thus, to {{interact}} with an application running in part as a daemon (in another <b>process),</b> a <b>user's</b> <b>process</b> simply performed a normal procedure-call instruction to a code segment to which it had dynamically linked (a code segment that implemented some operation associated with the daemon). The code in that segment could then modify data maintained and used in the daemon. When the action necessary to commence the request was completed, a simple procedure return instruction returned control of the <b>user's</b> <b>process</b> to the <b>user's</b> code.|$|R
5000|$|PCLSRing, a {{mechanism}} providing what appeared (to <b>user</b> <b>processes)</b> to be quasi-atomic, safely-interruptible system calls. No process could ever observe any process (including itself) {{in the middle}} of executing any system call.|$|R
50|$|MINIX 1.5, {{released}} in 1991, included support for MicroChannel IBM PS/2 systems {{and was also}} ported to the Motorola 68000 and SPARC architectures, supporting the Atari ST, Commodore Amiga, Apple Macintosh and Sun Microsystems SPARCstation computer platforms. A version of MINIX running as a <b>user</b> <b>process</b> under SunOS was also available.|$|E
50|$|A notable {{feature of}} the series was the {{hardware}} support for running multiple processes - every process ran in an independent address space, enforced by datum and limit registers. No <b>user</b> <b>process</b> could access the memory of any other process. Later models added paging hardware, allowing true virtual memory with the GEORGE 4 operating system.|$|E
5000|$|Some {{computer}} systems extended this mechanism to multiple segments, {{such as the}} i bank and d bank for instructions and data on the UNIVAC 1100 series computers or the separation of memory on the DEC PDP-10 system into a read/write [...] "low" [...] segment for the <b>user</b> <b>process</b> and a read-only [...] "high" [...] segment for sharable code.|$|E
5000|$|NIST defines identity-based {{security}} {{policies as}} policies [...] "based on the identities and/or {{attributes of the}} object (system resource) being accessed and of the subject (user, group of <b>users,</b> <b>process,</b> or device) requesting access." ...|$|R
30|$|Workload Extraction. A <b>user</b> <b>processes</b> the {{gathered}} data from Step 2 or Step 3 into {{a sequence of}} workload measurements. The DBLModeller tool can automate this step for P 6 Spy or Oracle query logs [27].|$|R
50|$|This {{identifies}} {{an object}} {{along with a}} set of access rights. It, however, is still not a capability because the <b>user</b> <b>process's</b> possession of these values says nothing about whether that access would actually be legitimate.|$|R
