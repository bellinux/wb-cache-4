933|1258|Public
5|$|Luke 4:17 it has {{the textual}} variant καὶ ἀνοίξας τὸ βιβλίον (and opened the book) {{together}} with the manuscripts A, B, L, W, 33, 892, 1195, 1241, ℓ 547, syrs, h, pal, and copsa, bo, against variant καὶ ἀναπτύξας τὸ βιβλίον (and <b>unrolled</b> the book) supported by א, Dc, K, Δ, Θ, Π, Ψ, f1, f13, 28, 565, 700, 1009, and 1010.|$|E
5|$|A viral {{marketing}} campaign was employed for the film. After {{the revelation of}} the first teaser trailer, in August2009, the film's official website featured only an animation of Cobb's spinning top. In December, the top toppled over and the website opened the online game Mind Crime, which upon completion revealed Inceptions poster. The rest of the campaign <b>unrolled</b> after WonderCon in April2010, where Warner gave away promotional T-shirts featuring the PASIV briefcase used to create the dream space, and had a QR code linking to an online manual of the device. Mind Crime also received a stage2 with more resources, including a hidden trailer for the movie. More pieces of {{viral marketing}} began to surface before Inceptions release, such as a manual filled with bizarre images and text sent to Wired magazine, and the online publication of posters, ads, phone applications, and strange websites all related to the film. Warner also released an online prequel comic, Inception: The Cobol Job.|$|E
5|$|Leslie takes {{possession}} of the jinniyah and asks for his brother {{to be returned to}} life. Anson is returned, but in a decaying state, complete with injuries from the crash. Leslie's second wish is for Anson to talk, which results in Anson screaming {{at the top of his}} lungs and telling his brother that he is cold. Back at the morgue, Scully finds the body has disappeared and Mulder suspects it is because of Leslie's wish. They go to the Stokes residence and Anson blows the house up trying to light the stove in an attempt to warm up. Mulder questions Jenn, the jinniyah, who says she's 500 years old. According to her, she gained her powers after wishing for great power and long life from another genie. She also says that Mulder <b>unrolled</b> her so he now has three wishes of his own. Mulder wishes for peace on earth and she wipes out the entire human population. With his second wish, Mulder undoes his first wish. Mulder then writes down his third wish to be very specific. However, just before making the final wish, Scully helps Mulder realize that the power of a genie should not be used to force people to be good, and so he ultimately wishes for Jenn to be free.|$|E
40|$|The {{influence}} of light, gibberellic acid, and abscisic acid on <b>unrolling</b> of etiolated barley leaf segments was investigated. Gibberellic acid stimulated <b>unrolling</b> of both illuminated and nonilluminated leaf segments. In contrast, abscisic acid prevented light-stimulated <b>unrolling</b> and abolished the slight <b>unrolling</b> of segments maintained in the dark...|$|R
40|$|International audienceThis paper {{improves}} {{our previous}} research effort [1] by providing an efficient method for kernel loop <b>unrolling</b> minimisation {{in the case}} of already scheduled loops, where circular lifetime intervals are known. When loops are software pipelined, the number of values simultaneously alive becomes exactly known giving better opportunities for kernel loop <b>unrolling.</b> Furthermore, fixing circular lifetime intervals allows us to reduce the algorithmic complexity of our method compared to [1] by computing a new research space for minimal kernel loop <b>unrolling.</b> The meeting graph (MG) [3] is one of the frameworks proposed in the literature which models loop <b>unrolling</b> and register allocation together in a common formal framework for software pipelined loops. Although MG significantly improves loop register allocation, the computed loop <b>unrolling</b> may lead to unpractical code growth. This work proposes to minimise the loop <b>unrolling</b> degree in the meeting graph by making an adaptation of the approach described in [1]. We explain how to reduce the research space for minimal kernel loop <b>unrolling</b> in the context of MG, yielding to a reduced algorithmic complexity. Furthermore, our experiments on SPEC 2000, SPEC 2006, MEDIABENCH and FFMPEG show that in concrete cases the loop <b>unrolling</b> minimisation is very fast and the minimal loop <b>unrolling</b> degree for 75 % of the optimised loops is equal to 1 (i. e. no <b>unroll),</b> while it is equal to 7 when the software pipelining (SWP) schedule is not fixed...|$|R
40|$|Many media {{processors}} [28, 7, 14, 8, 18, 27], {{used for}} computing intensive embedded applications, are VLIW architectures {{that rely on}} the compiler to exploit Instruction Level Parallelism. Loop <b>unrolling</b> is generally used to expose instruction parallelism but computing the <b>unrolling</b> factor is very difficult as instruction cache misses and spill code can cancel the expected benefit of the transformation. Moreover increasing the code size directly impacts on the embedded system cost. In this paper, we propose a method, called UFC (<b>Unrolling</b> Factor computation under Constraints) to compute <b>unrolling</b> factors of set of loops while taking into account code size, a major issue for embedded systems. Keywords: Loop <b>Unrolling,</b> Iterative compilation, Code optimization, Feedback directed compilation, Instruction level parallelism. ...|$|R
25|$|The {{mapping of}} meridians to {{vertical}} lines can be visualized by imagining a cylinder whose axis {{coincides with the}} Earth's axis of rotation. This cylinder is wrapped around the Earth, projected onto, and then <b>unrolled.</b>|$|E
25|$|In 1922, the Irish Free State {{took over}} a network of public roads which {{required}} major improvements. Most road surfaces were made up of undressed and <b>unrolled</b> water-bound macadam which did not use tar as a sealant.|$|E
25|$|An <b>unrolled</b> {{linked list}} is a linked list {{in which each}} node {{contains}} an array of data values. This leads to improved cache performance, since more list elements are contiguous in memory, and reduced memory overhead, because less metadata needs to be stored for each element of the list.|$|E
40|$|Loop <b>unrolling</b> is a {{well-known}} compiler optimization {{that can lead to}} significant performance improvements. When used in High Level Synthesis (HLS) <b>unrolling</b> can affect the controller complexity and delay. We study the effect of the loop <b>unrolling</b> factor on the delay of controllers generated during HLS. We propose a technique to predict controller delay {{as a function of the}} loop <b>unrolling</b> factor, and use this prediction with other search space pruning methods to automatically determine the optimal loop <b>unrolling</b> factor that results in a controller whose delay fits into a specified time budget, without an exhaustive exploration. Experimental results indicate delay predictions that are close to measured delays, yet significantly faster than exhaustive synthesis. ...|$|R
40|$|This paper {{presents}} modulo <b>unrolling</b> without <b>unrolling</b> (mod-ulo <b>unrolling</b> WU), {{a method}} for message aggregation for parallel loops in message passing programs that use affine ar-ray accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. Messages incur a non-trivial run time overhead, a significant component of which is independent {{of the size of}} the message. Therefore, aggregating messages improves performance. Our optimiza-tion for message aggregation is based on a technique known as modulo <b>unrolling,</b> pioneered by Barua [3], whose purpose was to ensure a statically predictable single tile number for each memory reference for tiled architectures, such as the MIT Raw Machine [18]. Modulo <b>unrolling</b> WU applies to data that is distributed in a cyclic or block-cyclic manner. I...|$|R
40|$|This work {{presents}} modulo <b>unrolling</b> without <b>unrolling</b> (modulo <b>unrolling</b> WU), {{a method}} for message aggregation for parallel loops in message passing programs that use affine array accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. Messages incur a non-trivial run time overhead, a significant component of which is independent {{of the size of}} the message. Therefore, aggregating messages improves performance. Our optimization for message aggregation is based on a technique known as modulo <b>unrolling,</b> pioneered by Barua [1] whose purpose was to ensure a statically predictable single tile number for each memory reference for tiled architectures, such as the MIT Raw Machine [2]. Modulo <b>unrolling</b> WU applies to data that is distributed in a cyclic or block-cyclic manner. In this paper, we adapt the aforementioned modulo <b>unrolling</b> technique to the difficult problem of efficiently compiling PGAS languages to message passing architectures. When applied to loops and data distributed cyclically or block-cyclically, modulo <b>unrolling</b> WU can decide when to aggregate messages thereby reducing the overall message count and runtime for a particular loop. Compared to other methods, modulo <b>unrolling</b> WU greatly simplifies the complex problem of automatic code generation of message passing code. It also results in substantial performance improvements in both runtime and communication compared to the non-optimized Chapel compiler. To implement this optimization in Chapel, we modify the Cyclic distribution module's follower iterator and the Block Cyclic distribution module's leader and follower iterators, as opposed to creating a traditional compiler transformation. Results were collected that compare the performance of Chapel programs optimized with modulo <b>unrolling</b> WU and Chapel programs using the existing Chapel data distributions. Data collected on a ten-locale cluster show that on average, modulo <b>unrolling</b> WU used with Chapel's Cyclic distribution results in 64 percent fewer messages and a 36 percent decrease in runtime for our suite of benchmarks. Similarly, modulo <b>unrolling</b> WU used with Chapel's Block Cyclic distribution results in 72 percent fewer messages and a 53 percent decrease in runtime. Finally, the results from three different scaling experiments suggest that the greatest improvements from modulo <b>unrolling</b> WU occur when parallel follower iterator chunks of work contain the greatest number of data elements...|$|R
25|$|In Luke 4:17 it has textual variant {{and opened}} the book {{together}} with the Greek manuscripts A, B, L, W, Ξ, 33, 892, 1195, 1241, ℓ 547, syrs, h, pal, copbo, against variant and <b>unrolled</b> the book supported by א, Dc, K, Δ, Θ, Π, Ψ, f1, f13, 28, 565, 700, 1009, 1010 and many other manuscripts.|$|E
25|$|On 17 July 1991, Manser climbed unaided {{to the top}} of 30-foot high {{lamp post}} outside of the G7 media centre in London. After {{reaching}} the top, he <b>unrolled</b> a banner that displayed a message about the plight of Sarawak rainforests. He chained himself to the lamp post {{for two and a half}} hours. His protest also coincided with protests by Earth First! and the London Rainforest Action Group. Police used a hoist to reach the top of the lamp post and cut his chains. Manser climbed down the lamp post without force at 1:40 PM. He was then taken to the Bow street police station and held until the G7 summit ended at 6:30 PM, when he was released without being charged with an offense.|$|E
25|$|Clement Greenberg {{included}} {{the work of}} both Morris Louis and Kenneth Noland in a show that he did at the Kootz Gallery in the early 1950s. Clem {{was the first to}} see their potential. He invited them up to New York in 1953, I think it was, to Helen's studio to see a painting that she had just done called Mountains and Sea, a very, very beautiful painting, which was in a sense, out of Pollock and out of Gorky. It also {{was one of the first}} stain pictures, one of the first large field pictures in which the stain technique was used, perhaps the first one. Louis and Noland saw the picture <b>unrolled</b> on the floor of her studio and went back to Washington, DC., and worked together for a while, working at the implications of this kind of painting.|$|E
40|$|This {{dissertation}} {{presents a}} machine learning {{solution to the}} compiler optimisation problem focused on a particular program transformation: loop <b>unrolling.</b> Loop <b>unrolling</b> is a very straightforward but powerful code transformation mainly used to improve Instruction Level Parallelism and to reduce the overhead due to loop control. However, loop <b>unrolling</b> can also be detrimental, for example, when the instruction cache is degraded due {{to the size of}} the loop body. Additionally, the effect of the interactions between loop <b>unrolling</b> and other program transformations is unknown. Consequently, determining when and how <b>unrolling</b> should be applied remains a challenge for compiler writers and researchers. This project works under the assumption that the effect of loop <b>unrolling</b> on the execution times of programs can be learnt based on past examples. Therefore, a regression approach able to learn the improvement in performance of loops under <b>unrolling</b> is presented. This novel approach differs from previous work ([Monsifrot et al., 2002] and [Stephenson and Amarasinghe, 2004]) because it does not formulate the problem as a classification task but as a regression solution. Great effort has been invested in the generation of clean and reliable data in order to make it suitable for learning. Two different regression algorithms have bee...|$|R
40|$|We {{introduce}} Approximate <b>Unrolling,</b> a loop optimization {{that reduces}} execution {{time and energy}} consumption, exploiting the existence of code regions that can endure some degree of approximation while still producing acceptable results. This work focuses on a specific kind of forgiving region: counted loops that map a given functions over the elements of an array. Approximate <b>Unrolling</b> transforms loops {{in a similar way}} Loop <b>Unrolling</b> does. However, unlike its exact counterpart, our optimization does not <b>unroll</b> loops by adding exact copies of the loop's body. Instead, it adds interpolations. We describe our experimental implementation of Approximate <b>Unrolling</b> in the Server (C 2) Compiler of the Open-JDK Hotspot JVM. The choice to implement our technique directly in the compiler reduced Phase Order problems and transformation overhead. It also proved that our technique could actually improve the performance of a production-ready compiler. Using our modified version of the compiler, we perform several experiments showing that Approximate <b>Unrolling</b> is able reduce execution time and energy consumption of the generated code by a factor of 50 % with minimal accuracy losses...|$|R
40|$|International audienceSoftware {{pipelining}} is {{a powerful}} technique to expose fine-grain parallelism, but it results in variables staying alive across more than one kernel iteration. It requires periodic register allocation and is challenging for code generation: {{the lack of a}} reliable solution currently restricts the applicability of software pipelining. The classical software solution that does not alter the computation throughput consists in <b>unrolling</b> the loop a posteriori [12], [11]. However, the resulting <b>unrolling</b> degree is often unacceptable and may reach absurd levels. Alternatively, loop <b>unrolling</b> can be avoided thanks to software register renaming. This is achieved through the insertion of move operations, but this may increase the initiation interval (II) which nullifies the benefits of software pipelining. This article aims at tightly controling the post-pass loop <b>unrolling</b> necessary to generate code. We study the potential of live range splitting to reduce kernel loop <b>unrolling,</b> introducing additional move instructions without inscreasing the II. We provide a complete formalisation of the problem, an algorithm, and extensive experiments. Our algorithm yields low <b>unrolling</b> degrees in most cases [...] with no increase of the II...|$|R
25|$|While {{most of the}} Dead Sea Scrolls {{were found}} by Bedouins, the Copper Scroll was {{discovered}} by an archaeologist. The scroll, on two rolls of copper, was found on March 14, 1952 {{at the back of}} Cave 3 at Qumran. It was the last of 15 scrolls discovered in the cave, and is thus referred to as 3Q15. The corroded metal could not be <b>unrolled</b> by conventional means and so the Jordanian government sent it to Manchester University's College of Technology in England on the recommendation of English archaeologist and Dead Sea Scrolls scholar John Marco Allegro for it to be cut into sections, allowing the text to be read. He arranged for the university's Professor H. Wright Baker to cut the sheets into 23 strips in 1955 and 1956. It then became clear that the rolls were part of the same document. Allegro, who had supervised the opening of the scroll, transcribed its contents immediately.|$|E
25|$|During the Edo period (1603–1868) {{there was}} a flourishing of the visual and {{performance}} arts particularly through proliferation of ukiyo-e ("pictures of the floating world"). Etoki once again became popular during the later eighteenth century as storytellers began to set up on street corners with an <b>unrolled</b> scroll hanging from a pole. In the Meiji Period (1868–1912) tachi-e ("stand-up pictures"), {{similar to those in}} the Edo period, were told by performers who manipulated flat-paper cut-outs of figures mounted on wooden poles (similar to the shadow puppets of Indonesia and Malaysia). The Zen priest Nishimura is also credited to have used these pictures during sermons to entertain children. Another form of etoki was the Japanese modified stereoscope imported from the Netherlands. Much smaller in size, six engravings of landscapes and everyday scenes would be placed one behind the other on top of the device and lowered when required so that the viewer, who looked at them through a lens, could experience the illusion of space created by this device. The artistic and technological developments of the Edo and Meiji periods can be linked to the establishment of kamishibai.|$|E
500|$|In Luke 4:17 Alexandrinus has textual variant [...] (opened) {{together}} with the manuscripts B, L, W, Ξ, 33, 892, 1195, 1241, ℓ 547, syrs, syrh, syrpal, copsa, copbo, against variant ἀναπτύξας (<b>unrolled)</b> supported by א, Dc, K, Δ, Θ, Π, Ψ, f1, f13, 28, 565, 700, 1009, 1010 and other manuscripts.|$|E
40|$|A {{well-known}} code transformation {{for improving}} the execution performance of a program is loop <b>unrolling.</b> The most obvious benefit of <b>unrolling</b> a loop is that the transformed loop usually, but not always, requires fewer instruction executions than the original loop. The reduction in instruction executions comes from two sources: the number of branch instructions executed is reduced, and the index variable is modified fewer times. In addition, for architectures with features designed to exploit instruction-level parallelism, loop <b>unrolling</b> can expose greater levels of instructionlevel parallelism. Loop <b>unrolling</b> is an effective code transformation often improving the execution performance of programs that {{spend much of their}} execution time in loops by ten to thirty percent. Possibly because of the effectiveness of a simple application of loop <b>unrolling,</b> it has not been studied as extensively as other code improvements such as register allocation or common subexpression elimination. The r [...] ...|$|R
50|$|Manual (or static) loop <b>unrolling</b> {{involves}} the programmer analyzing the loop and interpreting the iterations into {{a sequence of}} instructions which will reduce the loop overhead. This {{is in contrast to}} dynamic <b>unrolling</b> which is accomplished by the compiler.|$|R
40|$|In {{the primary}} leaf {{sections}} of etiolated wheat (Triticum aestivum L.) seedlings, red light-induced <b>unrolling</b> {{is accompanied by}} an increase in incorporation of 14 C-leucine into protein. By differential centrifugation, the <b>unrolling</b> response was found to be closely related to incorporation of the amino acid into the supernatant fraction (105, 000 g). Cycloheximide and chloramphenicol inhibit both leaf <b>unrolling</b> and synthesis of the supernatant protein, although chloramphenicol exerts its effect more strongly on the fraction which presumably contains the plastids. In a barley (Hordeum vulgare L.) albino mutant completely devoid of ribulose diphosphate carboxylase activity, only incorporation of 14 C-leucine into the supernatant fraction is substantially promoted by red light. This mutant exhibits the photoresponse of leaf <b>unrolling...</b>|$|R
500|$|Firefighters {{were among}} the first to respond to the disaster, rushing to Mont-Blanc to attempt to {{extinguish}} the blaze before the explosion even occurred. They also played a role after the blast, with fire companies arriving to assist from across Halifax, and by the end of the day from as far away as Amherst, Nova Scotia (...) and Moncton, New Brunswick (...) on relief trains. Halifax Fire Department's West Street Station 2 was the first to arrive at Pier 6 with the crew of the Patricia, the first motorized fire engine in Canada. In the final moments before the explosion, hoses were being <b>unrolled</b> as the fire spread to the docks. Nine members of the Halifax Fire Department lost their lives performing their duty that day.|$|E
500|$|Travelling with Irwin was Ensign Robert Dale, who {{had somehow}} {{acquired}} Yagan's head. According to the historian Paul Turnbull, Dale {{appears to have}} persuaded Irwin to let him have the head as an [...] "anthropological curiosity". After arriving in London, Dale tried to sell the head to scientists, approaching a number of anatomists and phrenologists. His price of ₤20 failed to find a buyer, so he made an agreement with Thomas Pettigrew for the exclusive use of the head for 18 months. Pettigrew, a surgeon and antiquarian, was {{well known in the}} London social scene for holding private parties at which he <b>unrolled</b> and autopsied Egyptian mummies. He displayed the head on a table in front of a panoramic view of King George Sound reproduced from Dale's sketches. For effect, the head was adorned with a fresh corded headband and feathers of the red-tailed black cockatoo.|$|E
500|$|On the {{afternoon}} of this day I was taking a walk with the steward of the convent in the neighbourhood, and as we returned, towards sunset, he begged me to take some refreshment {{with him in his}} cell. Scarcely had he entered the room, when, resuming our former subject of conversation, he said: [...] "And I, too, have read a Septuagint" [...] – i.e. a copy of the Greek translation made by the Seventy. And so saying, he took down from {{the corner of the room}} a bulky kind of volume, wrapped up in a red cloth, and laid it before me. I <b>unrolled</b> the cover, and discovered, to my great surprise, not only those very fragments which, fifteen years before, I had taken out of the basket, but also other parts of the Old Testament, the New Testament complete, and, in addition, the Epistle of Barnabas and a part of the Shepherd of Hermas.|$|E
40|$|Program loops {{are notorious}} for their {{optimization}} potential on modern high-performance architectures. Compilers aim at their aggressive transformation to achieve large improvements of the program performance. In particular, the optimization loop <b>unrolling</b> has shown in the past decades to be highly effective achieving significant increases of the average-case performance. In this paper, we present loop <b>unrolling</b> that is tailored towards real-time systems. Our novel optimization is driven by worst-case execution time (WCET) information to effectively minimize the program’s worst-case behavior. To exploit maximal optimization potential, the determination of a suitable <b>unrolling</b> factor is based on precise loop iteration counts provided by a static loop analysis. In addition, our heuristics avoid adverse effects of <b>unrolling</b> which result from instruction cache overflows and the generation of additional spill code. Results on 45 real-life benchmarks demonstrate that aggressive loop <b>unrolling</b> can yield WCET reductions of up to 13. 7 % over simple, naive approaches employed by many production compilers. 1...|$|R
40|$|Instruction-level code parallelization {{increases}} the register pressure and renders the register allocation phase crucial. In {{the case of}} software pipelined loops, <b>unrolling</b> has to be performed when variables are alive during more than one iteration resulting in code size increases. Loop <b>unrolling</b> also influences the register pressure. LoRA is a package that implements several algorithms for trading the register pressure against code size. In LoRA either the register pressure or the <b>unrolling</b> degree can be constrained. We explain the different strategies used in LoRA and show experimental results on a large benchmark of loops. Our experiments show that in concrete cases the <b>unrolling</b> degree can be kept reasonable although the worst case is exponential {{in the number of}} registers thought...|$|R
40|$|International audienceModulo Variable Expansion (MVE) [1] {{used with}} soft- ware {{pipelining}} (SWP) may sacrifice the register optimality (MAXLIVE) {{and in general}} may lead to unnecessary spills or move operations negating the benefits of SWP. In con- trast, bigger loop <b>unrolling</b> can be performed to meet the MAXLIVE registers requirement [2, 3]. However, the de- gree of <b>unrolling</b> should be minimised to control code size and hence I-cache performance. In our previous work, we designed a post-pass <b>unrolling</b> algorithm which minimises the <b>unrolling</b> degree while ad- justing the length of reuse circuits through the usage of ad- ditional (free) registers [4]. In this paper, we complete our study with an improved algorithm for minimising kernel loop <b>unrolling</b> resulting from cyclic register allocation {{in the presence of}} multiple register types showing that considering all register types in conjunction provides a lower <b>unrolling</b> degree than considering each register type in isolation. In ad- dition, we integrate our solution within a real world embed- ded system compiler: st 200 cc for the ST 2 xx family of VLIW embedded processors and compare it to MVE. Our large set of experiments on both high performance and embed- ded benchmarks (SPEC 2000, SPEC 2006, MEDIABENCH and FFMPEG) demonstrates the practical applicability and the benefits of our approach...|$|R
500|$|Ten {{thousand}} {{copies of}} The Story of Miss Moppet were released in a panorama format priced at a shilling in November 1906, and another 10,000 copies in December 1906. There were no subsequent printings in the panorama format. The strip folded accordion-fashion into a grey cloth wallet measuring [...] When opened, the panorama strip measured [...] As Lear writes, Potter [...] "experimented with a panorama format of fourteen pictures on one long {{strip of paper}} which folded into a wallet tied with a ribbon". Lear explains that the format [...] "although popular with readers was ultimately unsuccessful, because shopkeepers found them difficult to keep folded". Potter referred to this fact late in life when she said, [...] "Bad Rabbit and Moppet were originally printed on long strips—The shops sensibly refused to stock them because they got <b>unrolled</b> and so bad to fold up again". MacDonald {{points out that the}} fragile panorama format was inappropriate for very young children.|$|E
500|$|During {{a period}} of {{aggressive}} acquisition intended to establish the international prestige of Britain's collection, it was acquired for the National Gallery in 1860 in Milan from the Guicciardi family by Charles Lock Eastlake for just over £120, along {{with a number of}} other Netherlandish works. Eastlake's notes mention that the works were [...] "originally in the possession of the Foscari family". The Foscaris were a wealthy Venetian family which included Francesco Foscari who was Doge of Venice at the time the work was painted; the dramatic story of him and his son is told in Lord Byron's play The Two Foscari, and Verdi's opera I due Foscari. There is no documentary evidence to substantiate the claim that the painting came from the Foscari [...] collection, and some art historians believe that representatives of the Guicciardis invented this provenance to impress Eastlake. Lorne Campbell considers the provenance [...] "probable", noting that a descendant, Fergio Foscari (1732–1811), an ambassador to Saint Petersburg, squandered his fortune and may have been forced into selling pictures belonging to the family. Campbell speculates that the painting was produced on commission for export to Venice, noting that <b>unrolled</b> linen would have been easier to transport than canvas, and that the row of holes just below the upper border could be explained if it had been stretched, mounted and framed by someone other than Bouts or a member of his workshop.|$|E
2500|$|... 1989 Gershman, A., Morozov, A.: Several <b>Unrolled</b> Questions In Surgical Management Of Staghorn Nephrolythiasis. Journal of Urology, Moscow.|$|E
40|$|Modulo Variable Expansion (MVE) [1] {{used with}} {{software}} pipelining (SWP) may sacrifice the register optimality (MAXLIVE) {{and in general}} may lead to unnecessary spills or move operations negating the benefits of SWP. In contrast, bigger loop <b>unrolling</b> can be performed to meet the MAXLIVE registers requirement [2, 3]. However, the degree of <b>unrolling</b> should be minimised to control code size and hence I-cache performance. In our previous work, we designed a post-pass <b>unrolling</b> algorithm which minimises the <b>unrolling</b> degree while adjusting the length of reuse circuits through the usage of additional (free) registers [4]. In this paper, we complete our study with an improved algorithm for minimising kernel loop <b>unrolling</b> resulting from cyclic register allocation {{in the presence of}} multiple register types showing that considering all register types in conjunction provides a lower <b>unrolling</b> degree than considering each register type in isolation. In addition, we integrate our solution within a real world embedded system compiler: st 200 cc for the ST 2 xx family of VLIW embedded processors and compare it to MVE. Our large set of experiments on both high performance and embedded benchmarks (SPEC 2000, SPEC 2006, MEDIABENCH and FFMPEG) demonstrates the practical applicability and the benefits of our approach...|$|R
40|$|The {{development}} of embedded applications typically faces memory and/or execution time con-straints. In {{order to improve}} performance advanced compilers may use code transformations. There are cases where code transformations are not automatically applied and {{it is up to}} the devel-oper to manually apply them. One of the most relevant code transformations is Loop <b>Unrolling.</b> It is a widely studied transformation and it is able to improve the performance of many loops. It is easily implemented and its applicability is always legal. The main goal of this dissertation is to propose an approach to help developers decide about the application of Loop <b>Unrolling</b> and about the <b>unroll</b> factor to use. We propose an approach that uses a set of heuristics, based on char-acteristics extracted from the source code of the loops being analyzed, to suggest loops for Loop <b>Unrolling.</b> These heuristics are based on characteristics that likely lead to performance gains when Loop <b>Unrolling</b> is applied, but also on characteristics that can make a loop inadequate for Loop <b>Unrolling.</b> The approach consists in software extensions of an existent source-to-source tool to extract features and on a software tool implementing the heuristics. To validate and evaluate the proposed approach we developed a prototype that targets th...|$|R
50|$|One odd {{group of}} vining plants is the fern genus Lygodium, called {{climbing}} ferns. The stem does not climb, {{but rather the}} fronds (leaves) do. The fronds <b>unroll</b> from the tip, and theoretically never stop growing; they can form thickets as they <b>unroll</b> over other plants, rockfaces, and fences.|$|R
