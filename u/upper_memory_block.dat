1|1236|Public
50|$|Specifications were {{developed}} to allow access to additional memory. The first was the Expanded Memory Specification (EMS) which originally allowed memory on an add-on card to be accessed via a 64 KB page frame in the reserved upper memory area. 80386 and later systems could use a virtual 8086 mode (V86) mode memory manager like EMM386 to create expanded memory from extended memory without the need of an add-on card. The second specification was the Extended Memory Specification (XMS) for 80286 and later systems. This provided a way to copy data to and from extended memory, access to the 65520-byte High Memory Area (HMA) directly above the first megabyte of memory and the <b>Upper</b> <b>Memory</b> <b>Block</b> (UMB) area. Generally XMS support was provided by HIMEM.SYS or a V86 mode memory manager like QEMM or 386MAX which also supported EMS.|$|E
50|$|<b>Upper</b> <b>memory</b> <b>blocks</b> can {{be created}} by mapping {{extended}} <b>memory</b> into the <b>upper</b> <b>memory</b> area when running in virtual x86 mode. This is similar to how expanded memory can be emulated using extended memory so this method of providing <b>upper</b> <b>memory</b> <b>blocks</b> is usually provided by the expanded memory manager (for example EMM386). Ironically the application programming interface for managing the <b>upper</b> <b>memory</b> <b>blocks</b> is specified in the eXtended Memory Specification.|$|R
50|$|BlueMax was {{a special}} version {{designed}} for the IBM PS/2 with ROM compression {{to get the most}} of the <b>Upper</b> <b>Memory</b> <b>Blocks.</b>|$|R
50|$|Additionally, on Intel 80386 machines, DR DOS's EMS memory manager {{allowed the}} OS to load DOS device drivers into <b>upper</b> <b>memory</b> <b>blocks,</b> further freeing base memory. For more {{information}} on this, see the article on the <b>Upper</b> <b>Memory</b> Area (UMA).|$|R
50|$|The third line loads the EMM386 memory manager, which emulates {{expanded}} memory. The {{command line}} argument RAM allows {{the use of}} the <b>upper</b> <b>memory</b> area. Another argument that can be given to EMM386.EXE is NOEMS, which allows use of the <b>upper</b> <b>memory</b> area without emulating expanded memory. The NOEMS switch also frees up more <b>upper</b> <b>memory</b> <b>blocks.</b>|$|R
50|$|The {{extended}} memory manager is {{also responsible for}} managing allocations in the high memory area (HMA) and the <b>upper</b> <b>memory</b> area (UMA; {{also referred to as}} <b>upper</b> <b>memory</b> <b>blocks</b> or UMBs). In practice the <b>upper</b> <b>memory</b> area will be provided by the expanded memory manager (EMM), after which DOS will try to allocate them all and manage them itself.|$|R
5000|$|Software {{expanded}} memory managers in general offered additional, but closely related functionality. Notably, they could create ordinary memory in unused {{parts of the}} <b>upper</b> <b>memory</b> area (UMA) (the high 384 kB of real mode address space) called <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs) and provided tools for loading small programs, typically TSRs inside ("LOADHI" [...] or [...] "LOADHIGH").|$|R
25|$|As DOS {{applications}} grew {{larger and}} more complex in the late 1980s, it became common practice to free up conventional memory by moving the device drivers and TSR programs into <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs) in the <b>upper</b> <b>memory</b> area (UMA) at boot, {{in order to maximize}} the conventional memory available for applications. This had the advantage of not requiring hardware changes, and preserved application compatibility.|$|R
50|$|The {{next stage}} in the {{evolution}} of DOS was for the operating system to use <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs) and the high memory area (HMA). This occurred with the release of DR DOS 5.0 in 1990. DR DOS' built-in memory manager, EMM386.EXE, could perform most of the basic functionality of QEMM and comparable programs.|$|R
50|$|However, {{even with}} video RAM, the ROM BIOS and I/O ports for {{expansion}} cards, {{much of this}} 384 KB of address space was unused. As the 640 KB memory restriction became ever more of an obstacle, techniques were found to fill the empty areas with RAM. These areas were referred to as <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs).|$|R
25|$|Hardware {{expansion}} boards {{could use}} any of the <b>upper</b> <b>memory</b> area for ROM addressing, so the <b>upper</b> <b>memory</b> <b>blocks</b> were of variable size and in different locations for each computer, depending on the hardware installed. Some windows of <b>upper</b> <b>memory</b> could be large and others small. Loading drivers and TSRs high would pick a block and try to fit the program into it, until a block was found where it fit, or it would go into conventional memory.|$|R
5000|$|Windows 95 and Windows 98 now analyze CONFIG.SYS {{and load}} MSDOS real mode drivers. Windows ME ignores this.If the CONFIG.SYS file does not exist, the IO.SYS file loads drivers: IFSHLP.SYS, HIMEM.SYS and [...] SETVER.EXE. Windows {{reserves}} all <b>upper</b> <b>memory</b> <b>blocks</b> (UMB) for Windows 95 operating system use or for expanded memory EMS.Windows 95 and Windows 98 execute COMMAND.COM to process AUTOEXEC.BAT. It loads terminate and stay resident (TSR) programs into memory. Windows ME ignores this step.|$|R
50|$|Extended memory {{should not}} be {{confused}} with expanded memory, an earlier method for expanding the IBM PC's memory capacity beyond 640 kB (655,360 bytes) using an expansion card with bank switched memory modules. Because of the available support for expanded memory in popular applications, device drivers were developed that emulated expanded memory using extended memory. Later two additional methods were developed allowing direct access to a small portion of extended memory from real mode. These memory areas are referred to as the high memory area (HMA) and the <b>upper</b> <b>memory</b> area (UMA; also referred to as <b>upper</b> <b>memory</b> <b>blocks</b> or UMBs).|$|R
50|$|The AllCard, an add-on memory {{management}} unit for XT-class computers, allowed normal memory to be mapped into the 0xA0000-EFFFF address range, giving up to 952 KB for DOS programs. Programs such as Lotus 1-2-3, which accessed video memory directly, needed to be patched to handle this memory layout. Therefore, the 640 KB barrier was removed {{at the cost of}} software compatibility. This usage of the <b>upper</b> <b>memory</b> area is different from using <b>upper</b> <b>memory</b> <b>blocks,</b> which was used to free conventional memory by moving device drivers and TSRs into the upper 384 KB of the 1 MB address space, but left the amount of addressable memory (640 KB) intact.|$|R
50|$|DOS 5 {{debuted in}} June 1991. This {{is one of}} the biggest {{upgrades}} of DOS in its history. DOS 5 supported the use of the High Memory Area (HMA) and <b>Upper</b> <b>Memory</b> <b>Blocks</b> (UMBs) on 80286 and later systems to reduce its conventional memory usage. Also all DOS commands now supported the /? option to display command syntax. Aside from IBM's PC DOS, MS-DOS was the only other version available as OEM editions vanished since by this time PCs were 100% compatible so customizations for hardware differences were no longer necessary.|$|R
50|$|The {{original}} DOS API in 86-DOS and MS-DOS 1.0 {{was designed}} to be functionally compatible with CP/M. Files were accessed using file control blocks (FCBs). The DOS API was greatly extended in MS-DOS 2.0 with several Unix concepts, including file access using file handles, hierarchical directories and device I/O control. In DOS 3.1, network redirector support was added. In MS-DOS 3.31, the INT 25h/26h functions were enhanced to support hard disks greater than 32 MB. MS-DOS 5 added support for using <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs). After MS-DOS 5, the DOS API was unchanged for the successive standalone releases of DOS.|$|R
2500|$|The {{design of}} the {{original}} IBM PC placed the Color Graphics Adapter (CGA) memory map and other hardware in the 384 KB <b>upper</b> <b>memory</b> area (UMA). The need for more RAM grew faster than the needs of hardware to utilize the reserved addresses, which resulted in RAM eventually being mapped into these unused upper areas to utilize all available addressable space. This introduced a reserved [...] "hole" [...] (or several holes) into the set of addresses occupied by hardware {{that could be used}} for arbitrary data. Avoiding such a hole was difficult and ugly and not supported by DOS or most programs that could run on it. Later, space between the holes would be used as <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs).|$|R
50|$|To make maximum use of {{extended}} memory on Intel 80386 processors, by transforming it into expanded <b>memory</b> and <b>upper</b> <b>memory</b> <b>blocks</b> (UMBs) accessible to DESQview and other real-mode programs, Quarterdeck developed a sophisticated memory manager. Owing to the foresight of its marketing manager, Quarterdeck marketed it {{as a separate}} product, QEMM-386 (Quarterdeck Expanded Memory Manager 386). It became more popular than DESQview itself, and sold steadily for many years, generating over US$150 million in sales from 1987 through 1994. After {{the release of the}} Intel Pentium processor, the 386 in QEMM was dropped. The combination package of DESQview and QEMM-386 was called DESQview 386 (DV386).|$|R
50|$|DR DOS 5.0 was {{the first}} DOS to {{integrate}} such functionality into the base OS (loading device drivers into <b>upper</b> <b>memory</b> <b>blocks</b> was possible using third-party software like QEMM). This allowed it, on a 386 system, to provide significantly more free conventional memory than any other DOS. Once drivers for a mouse, multimedia hardware and a network stack were loaded, an MS-DOS machine typically might only have 300 to 400 KB of free conventional memory - too little to run much late-1980s software. DR DOS 5.0, with a little manual tweaking, could load all this and still keep all of its conventional memory free - allowing for some necessary DOS data structures, as much as 620 KB out of the 640 KB.|$|R
5000|$|Microsoft {{released}} comparable but simpler memory {{managers of}} its own - HIMEM.SYS for XMS and EMM386.EXE for EMS with MS-DOS 4.01 in 1989; earlier Windows/386 2.1 included a built-in EMM which offered EMS to DOS windows during Windows sessions only. These versions could not yet create <b>Upper</b> <b>Memory</b> <b>Blocks.</b> Digital Research's DR DOS 5.0 (1990) was the first non-vendor-specific DOS to offer the UMB technology, incorporating a 386-mode XMS/EMS manager also called EMM386. It could also allocate some of the video memory or EMS memory as UMB memory. MS-DOS finally offered UMBs in 1991 with version 5.0. MS-DOS's EMM386 required HIMEM to be loaded first, while DR-DOS's EMM386 fulfilled both roles and did not need a separate XMS driver, which was still provided but only needed on 80286-based machines (originally named HIDOS.SYS, later HIMEM.SYS). If an XMS driver was loaded before DR-DOS EMM386, it would use this instead of the built-in XMS manager. Using an external and possibly customized XMS driver could help overcome issues with BIOS memory reporting functions causing the memory manager not to see all available memory, and on machines using non-standard gate-A20 switching methods, whereas using the internal XMS driver EMM386 {{could take advantage of}} speed-optimized 32-bit code for the XMS driver and relocate all but a tiny stub of the XMS driver into Extended Memory. DR-DOS EMM386 could fill [...] "free" [...] areas with UMBs or map RAM over unused ROM areas in virtual mode, provide support for DPMI (and - in some special issues - DPMS), and load the support for pre-emptive multitasking and multithreading components of the operating system.|$|R
5000|$|EMM386.EXE can map <b>memory</b> into unused <b>blocks</b> in the <b>upper</b> <b>memory</b> area (UMA), {{allowing}} device {{drivers and}} TSRs to be [...] "loaded high", preserving conventional memory.|$|R
50|$|To avoid fragmentation, µC/OS-II allows {{applications}} to obtain fixed-sized <b>memory</b> <b>blocks</b> from a partition {{made of a}} contiguous memory area. All <b>memory</b> <b>blocks</b> are the same size, and the partition contains an integral number of blocks. Allocation and deallocation of these <b>memory</b> <b>blocks</b> is done in constant time and is a deterministic system.|$|R
50|$|The 640 KiB limit imposed great {{complexity}} on {{hardware and}} software intended to circumvent it; the physical memory in a machine could be organised as a combination of base or conventional <b>memory,</b> <b>upper</b> <b>memory,</b> high memory (not the same as <b>upper</b> <b>memory),</b> extended memory, and expanded memory, all handled in different ways.|$|R
40|$|Abstract: Since modern {{programmable}} devices contain embedded <b>memory</b> <b>blocks,</b> {{there exists}} a possibility to implement Finite State Machines (FSM) using such blocks. The size of the memory available in programmable devices is limited, though. The paper presents a general method for the synthesis of sequential circuits using embedded <b>memory</b> <b>blocks.</b> The method {{is based on the}} serial decomposition concept and relies on decomposing the <b>memory</b> <b>block</b> into two blocks: a combinational address modifier and a smaller <b>memory</b> <b>block.</b> An appropriately chosen decomposition strategy may allow reducing the required memory size at the cost of additional logic cells for address modifier implementation. This makes possible implementation of FSMs that exceed available memory by using embedded <b>memory</b> <b>blocks</b> and additional programmable logic...|$|R
50|$|Many systems impose {{restrictions}} {{on the size of}} the thread-local <b>memory</b> <b>block,</b> in fact often rather tight limits. On the other hand, if a system can provide at least a memory address (pointer) sized variable thread-local, then this allows the use of arbitrarily sized <b>memory</b> <b>blocks</b> in a thread-local manner, by allocating such a <b>memory</b> <b>block</b> dynamically and storing the memory address of that block in the thread-local variable.|$|R
5000|$|The handle can {{for example}} be {{implemented}} with an [...] The module can interpret the handle internally by dividing it into pool index, <b>memory</b> <b>block</b> index and a version. The pool and <b>memory</b> <b>block</b> index allow fast {{access to the}} corresponding block with the handle, while the version, which is incremented at each new allocation, allows detection of handles whose <b>memory</b> <b>block</b> is already freed (caused by handles retained too long).|$|R
40|$|Abstract — Memory leaks {{are caused}} by allocating <b>memory</b> <b>blocks</b> and not {{releasing}} them after their last use. In most modern programs, dynamic data structures are used quite extensively. In this case, only knowing the allocation site of leaked <b>memory</b> <b>blocks,</b> as reported by most current tools, is often not enough to fix said leaks. It {{is also possible that}} all pointers to a <b>memory</b> <b>block</b> were overwritten during the execution of a program, in which case more information is required as well. In this paper we describe an approach which uses a combination of dynamic instrumentation and garbage collection techniques to keep track of all <b>memory</b> <b>blocks</b> and their referring pointers. At the end of the execution, we can inform the user where exactly the last pointer to a <b>memory</b> <b>block</b> has been lost, as well as where this pointer was created. Another possibility is tracking a specific <b>memory</b> <b>block</b> during the life time of an execution and reporting the creation and destruction of all references to it. All this can be done without the need for recompilation or relinking. I...|$|R
40|$|Abstract—Cache locking is an {{effective}} technique to improve timing predictability in real-time systems. In static cache locking, the locked <b>memory</b> <b>blocks</b> remain unchanged throughout the program execution. Thus static locking may not be effective for large programs where multiple <b>memory</b> <b>blocks</b> are competing for few cache lines available for locking. In comparison, dynamic cache locking overcomes cache space limitation through time-multiplexing of locked <b>memory</b> <b>blocks.</b> Prior dynamic locking technique partitions the program into regions and takes indepen-dent locking decisions for each region. We propose a flexible loop-based dynamic cache locking approach. We not only select the <b>memory</b> <b>blocks</b> to be locked but also the locking points (e. g., loop level). We judiciously allow <b>memory</b> <b>blocks</b> from the same loop to be locked at different program points for WCET improvement. We design a constraint-based approach that incorporates a global view {{to decide on the}} number of locking slots at each loop entry point and then select the <b>memory</b> <b>blocks</b> to be locked for each loop. Experimental evaluation shows that our dynamic cache locking approach achieves substantial improvement of WCET compared to prior techniques. I...|$|R
40|$|Current FPGAs include large <b>blocks</b> of <b>memory</b> {{that require}} {{separate}} address generation circuits. This not only uses logic resources surrounding the <b>memory</b> <b>blocks,</b> but also results in unnecessary routing congestions. This paper proposes {{the integration of}} the address generation circuit into the <b>block</b> <b>memory</b> to form an Autonomous <b>Memory</b> <b>Block</b> (AMB). Quantitative comparison between using AMB and conventional FPGA <b>block</b> <b>memory</b> architectures demonstrates that this approach is promising. 1...|$|R
50|$|Free the {{formerly}} allocated <b>memory</b> <b>block.</b>|$|R
50|$|Each <b>memory</b> <b>block</b> {{when first}} {{referenced}} causes a compulsory miss. This {{implies that the}} number of compulsory misses is the number of distinct <b>memory</b> <b>blocks</b> ever referenced. They are sometimes called cold misses too. Cold misses cannot be avoided unless the block is prefetched.|$|R
40|$|Modern FPLD {{devices have}} very complex structure. They combine PLA like structures, {{as well as}} FPGA and even memory-based structures. However lack of {{appropriate}} synthesis methods do not allow fully exploiting the possibilities the modern FPLDs offer. The paper presents a general method for the synthesis targeted to implementation of sequential circuits using embedded <b>memory</b> <b>blocks.</b> The method {{is based on the}} serial decomposition concept and relies on decomposing the <b>memory</b> <b>block</b> into two blocks: a combinational address modifier and a smaller <b>memory</b> <b>block.</b> An appropriately chosen decomposition strategy may allow reducing the required memory size at the cost of additional logic cells for address modifier implementation. This makes possible implementation of FSMs that exceed available memory by using embedded <b>memory</b> <b>blocks</b> and additional programmable logic...|$|R
5000|$|<b>Memory</b> <b>Blocks</b> {{have evolved}} to become {{individually}} hand crafted plaster tiles, measuring 6" [...] × 8" [...] × 1" [...] and finished to a porcelain-like quality, cracked to create an aged look and feel. [...] Some <b>memory</b> <b>blocks</b> are embellished with silver and gold leafing done by hand.|$|R
50|$|In {{this format}} the {{directory}} is decentralised and distributed among the caches that share a <b>memory</b> <b>block.</b> Different caches that share a <b>memory</b> <b>block</b> {{are arranged in}} the form of a binary tree. The cache that accesses a <b>memory</b> <b>block</b> first is the root node. Each <b>memory</b> <b>block</b> has the root node information (HEAD) and Sharing counter field (SC). The SC field has the number of caches that share the block. Each cache entry has pointers to the next sharing caches known as L-CHD and R-CHD. A condition for this directory is that the binary tree should be number balanced, i.e the number of nodes in the left sub tree must be equal to or one greater than the number of nodes in the right subtree. All the subtrees should also be number balanced.|$|R
50|$|On IBM XT computers, it was {{possible}} to add more memory to the motherboard and use a custom address decoder PROM to make it appear in the <b>upper</b> <b>memory</b> area http://www.textfiles.com/computers/pc869kb.txt. As with the 386-based <b>upper</b> <b>memory</b> described above, the extra RAM could be used to load TSR files, or as a RAM disk.|$|R
5000|$|<b>Memory</b> <b>Block</b> English Heritage, Liverpool Community Arts Projects (Liverpool 2004) ...|$|R
