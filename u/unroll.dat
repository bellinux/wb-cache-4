331|1858|Public
5|$|The {{writings}} of Confucius and Chinese tradition recount that, in the 27th century BCE, a silk worm's cocoon {{fell into the}} tea cup of the empress Leizu. Wishing to extract it from her drink, the 14-year-old girl began to <b>unroll</b> the thread of the cocoon.|$|E
5|$|Landing safely on the Moon, {{the astronomers}} {{get out of}} the capsule (without the need of space suits) and watch the Earth rise in the distance. Exhausted by their journey, they <b>unroll</b> their {{blankets}} and sleep. As they sleep, a comet passes, the Big Dipper appears with human faces peering out of each star, old Saturn leans out of a window in his ringed planet, and Phoebe, goddess of the Moon, appears seated in a crescent-moon swing. Phoebe causes a snowfall that awakens the astronomers, and they seek shelter in a cavern where they discover giant mushrooms. One astronomer opens his umbrella; it promptly takes root and turns into a giant mushroom itself.|$|E
25|$|If a user {{attempts}} to <b>unroll</b> the condom, but realizes {{they have it}} on the wrong side, then this condom should be discarded.|$|E
40|$|The {{influence}} of light, gibberellic acid, and abscisic acid on <b>unrolling</b> of etiolated barley leaf segments was investigated. Gibberellic acid stimulated <b>unrolling</b> of both illuminated and nonilluminated leaf segments. In contrast, abscisic acid prevented light-stimulated <b>unrolling</b> and abolished the slight <b>unrolling</b> of segments maintained in the dark...|$|R
50|$|By {{the middle}} of the 20th century, only 585 rolls or {{fragments}} had been completely <b>unrolled,</b> and 209 <b>unrolled</b> in part. Of the <b>unrolled</b> papyri, about 200 had been deciphered and published, and about 150 only deciphered.|$|R
40|$|Modulo {{scheduling}} is {{a method}} for overlapping successive iterations of a loop {{in order to find}} sufficient instruction-level parallelism to fully utilize high-issue-rate processors. The achieved throughput modulo scheduled loop depends on the resource requirements, the dependence pattern, and the register requirements of the computation in the loop body. Traditionally, <b>unrolling</b> followed by acyclic scheduling of the <b>unrolled</b> body has been an alternative to modulo scheduling. However, there are benefits to <b>unrolling</b> even if the loop is to be modulo scheduled. <b>Unrolling</b> can improve the throughput by allowing a smaller non-integral effective initiation interval to be achieved. After <b>unrolling,</b> optimizations {{can be applied to the}} loop that reduce both the resource requirements and the height of the critical paths. Together, <b>unrolling</b> and unrolling-based optimizations can enable the completion of multiple iterations per cycle in some cases. This paper describes the benefits of <b>unrolling</b> and [...] ...|$|R
25|$|Under {{reduces the}} risk that a toddler or a house pet, such as a dog or cat, will {{completely}} <b>unroll</b> the toilet paper when batting at the roll.|$|E
25|$|Nine tiny {{phylactery}} slips were rediscovered by the Israel Antiquities Authority (IAA) in 2014, {{after they}} had been stored unopened for six decades following their excavation in 1952. The IAA is preparing to <b>unroll</b> the phylacteries or tefillin once a safe procedure has been decided upon.|$|E
25|$|One way of {{describing}} a projection is first to project from the Earth's surface to a developable surface {{such as a}} cylinder or cone, and then to <b>unroll</b> the surface into a plane. While the first step inevitably distorts some properties of the globe, the developable surface can then be unfolded without further distortion.|$|E
40|$|Abstract. Loop <b>unrolling</b> is {{the main}} {{compiler}} technique that allows reconfigurable architectures achieve large degrees of parallelism. However, loop <b>unrolling</b> increases the area and can potentially {{have a negative impact}} on clock cycle time. In most embedded applications, the critical parameter is the throughput. Loop <b>unrolling</b> can therefore have contradictory effects on the throughput. As a consequence there exists, in general, a degree of <b>unrolling</b> that maximizes the throughput per unit area. This paper studies the effect of loop <b>unrolling</b> on the area, clock speed and throughput within the ROCCC, C to VHDL compilation framework. Our results indicate that due to the unique design of the ROCCC compilation framework, FPGA area either shrinks or increases at a very low rate for the first few times the loops are <b>unrolled.</b> This reduced area causes the clock cycle time to decrease and thus a great gain in throughput. Our results also show that there are different optimal <b>unrolling</b> factors for different programs. ...|$|R
40|$|Many media {{processors}} [28, 7, 14, 8, 18, 27], {{used for}} computing intensive embedded applications, are VLIW architectures {{that rely on}} the compiler to exploit Instruction Level Parallelism. Loop <b>unrolling</b> is generally used to expose instruction parallelism but computing the <b>unrolling</b> factor is very difficult as instruction cache misses and spill code can cancel the expected benefit of the transformation. Moreover increasing the code size directly impacts on the embedded system cost. In this paper, we propose a method, called UFC (<b>Unrolling</b> Factor computation under Constraints) to compute <b>unrolling</b> factors of set of loops while taking into account code size, a major issue for embedded systems. Keywords: Loop <b>Unrolling,</b> Iterative compilation, Code optimization, Feedback directed compilation, Instruction level parallelism. ...|$|R
40|$|Loop <b>unrolling</b> is a {{well-known}} compiler optimization {{that can lead to}} significant performance improvements. When used in High Level Synthesis (HLS) <b>unrolling</b> can affect the controller complexity and delay. We study the effect of the loop <b>unrolling</b> factor on the delay of controllers generated during HLS. We propose a technique to predict controller delay {{as a function of the}} loop <b>unrolling</b> factor, and use this prediction with other search space pruning methods to automatically determine the optimal loop <b>unrolling</b> factor that results in a controller whose delay fits into a specified time budget, without an exhaustive exploration. Experimental results indicate delay predictions that are close to measured delays, yet significantly faster than exhaustive synthesis. ...|$|R
25|$|Anyhow the heresies are at best novelties, {{and have}} no {{continuity}} with the teaching of Christ. Perhaps some heretics may claim Apostolic antiquity: we reply: Let them publish the origins of their churches and <b>unroll</b> the catalogue of their bishops till now from the Apostles or from some bishop appointed by the Apostles, as the Smyrnaeans count from Polycarp and John, and the Romans from Clement and Peter; let heretics invent something to match this.|$|E
25|$|Francia {{took several}} {{precautions}} against assassination. He would lock the Palace doors himself, <b>unroll</b> the cigars his sister made to ensure {{there was no}} poison, prepare his own yerba mate, and sleep with a pistol under his pillow. Even so, a maid tried to poison him {{with a piece of}} cake. No one could come within six paces of him, or even bear a cane near him. Whenever he would go out riding, he had all bushes and trees along the route uprooted so that assassins could not hide; all shutters had to be closed, and pedestrians had to prostrate before him as he passed.|$|E
25|$|At {{the behest}} of our leader Herzl, I came to Basle to make {{preparations}} for the Zionist Congress. Among many other problems that occupied me then was one that contained something of {{the essence of the}} Jewish problem. What flag would we hang in the Congress Hall? Then an idea struck me. We have a flag—and it is blue and white. The talith (prayer shawl) with which we wrap ourselves when we pray: that is our symbol. Let us take this Talith from its bag and <b>unroll</b> it before the eyes of Israel and the eyes of all nations. So I ordered a blue and white flag with the Shield of David painted upon it. That is how the national flag, that flew over Congress Hall, came into being.|$|E
40|$|This paper {{presents}} modulo <b>unrolling</b> without <b>unrolling</b> (mod-ulo <b>unrolling</b> WU), {{a method}} for message aggregation for parallel loops in message passing programs that use affine ar-ray accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. Messages incur a non-trivial run time overhead, a significant component of which is independent {{of the size of}} the message. Therefore, aggregating messages improves performance. Our optimiza-tion for message aggregation is based on a technique known as modulo <b>unrolling,</b> pioneered by Barua [3], whose purpose was to ensure a statically predictable single tile number for each memory reference for tiled architectures, such as the MIT Raw Machine [18]. Modulo <b>unrolling</b> WU applies to data that is distributed in a cyclic or block-cyclic manner. I...|$|R
40|$|This work {{presents}} modulo <b>unrolling</b> without <b>unrolling</b> (modulo <b>unrolling</b> WU), {{a method}} for message aggregation for parallel loops in message passing programs that use affine array accesses in Chapel, a Partitioned Global Address Space (PGAS) parallel programming language. Messages incur a non-trivial run time overhead, a significant component of which is independent {{of the size of}} the message. Therefore, aggregating messages improves performance. Our optimization for message aggregation is based on a technique known as modulo <b>unrolling,</b> pioneered by Barua [1] whose purpose was to ensure a statically predictable single tile number for each memory reference for tiled architectures, such as the MIT Raw Machine [2]. Modulo <b>unrolling</b> WU applies to data that is distributed in a cyclic or block-cyclic manner. In this paper, we adapt the aforementioned modulo <b>unrolling</b> technique to the difficult problem of efficiently compiling PGAS languages to message passing architectures. When applied to loops and data distributed cyclically or block-cyclically, modulo <b>unrolling</b> WU can decide when to aggregate messages thereby reducing the overall message count and runtime for a particular loop. Compared to other methods, modulo <b>unrolling</b> WU greatly simplifies the complex problem of automatic code generation of message passing code. It also results in substantial performance improvements in both runtime and communication compared to the non-optimized Chapel compiler. To implement this optimization in Chapel, we modify the Cyclic distribution module's follower iterator and the Block Cyclic distribution module's leader and follower iterators, as opposed to creating a traditional compiler transformation. Results were collected that compare the performance of Chapel programs optimized with modulo <b>unrolling</b> WU and Chapel programs using the existing Chapel data distributions. Data collected on a ten-locale cluster show that on average, modulo <b>unrolling</b> WU used with Chapel's Cyclic distribution results in 64 percent fewer messages and a 36 percent decrease in runtime for our suite of benchmarks. Similarly, modulo <b>unrolling</b> WU used with Chapel's Block Cyclic distribution results in 72 percent fewer messages and a 53 percent decrease in runtime. Finally, the results from three different scaling experiments suggest that the greatest improvements from modulo <b>unrolling</b> WU occur when parallel follower iterator chunks of work contain the greatest number of data elements...|$|R
40|$|Loop <b>unrolling</b> {{is one of}} {{the most}} {{promising}} paral-lelization techniques, because the nature of programs causes most of the processing time to be spent in their loops. <b>Unrolling</b> not only the innermost loop but also outer loops greatly expands the scope for reusing data and pnrullelizing instructions. Nested-loop <b>unrolling</b> is therefore a very effective way of obtaining a higher degree of parallelism, However, we need a method for measuring the eflciency of loop <b>unrolling</b> that takes account of both the reuse of data and the pamllelesm between instructions. This paper desc,ribes a heuristic algorithm for deciding the number of times and the di-rections in which loops should be <b>unrolled,</b> through the use of information such as dependence, reuse, and ma-chine resources. Our method is evaluated by applying benchmark tests. ...|$|R
25|$|Scrolls can {{be rolled}} {{in one of}} two ways. The first method is to wrap the scroll around a single core, similar to a modern roll of paper towels. While simple to construct, a single core scroll has a major disadvantage: in order to read text {{at the end of the}} scroll, the entire scroll must be unwound. This is {{partially}} overcome in the second method, which is to wrap the scroll around two cores, as in a Torah. With a double scroll, the text can be accessed from both beginning and end, and the portions of the scroll not being read can remain wound. This still leaves the scroll a sequential-access medium: to reach a given page, one generally has to <b>unroll</b> and re-roll many other pages.|$|E
25|$|The {{problems}} of making metal-coated, glass mirrors {{was due to}} the difficulties in making glass that was very clear, as most ancient glass was tinted green with iron. This was overcome when people began mixing soda, limestone, potash, manganese, and fern ashes with the glass. There was also no way for the ancients to make flat panes of glass with uniform thicknesses. The earliest methods for producing glass panes began in France, when people began blowing glass bubbles, and then spinning them rapidly to flatten them out into plates from which pieces could be cut. However, these pieces were still not uniform in thickness, so produced distorted images as well. A better method was to blow a cylinder of glass, cut off the ends, slice it down the center, and <b>unroll</b> it onto a flat hearth. This method produced the first mirror-quality glass panes, but it was very difficult and resulted in a lot of breakage. Even windows were primarily made of oiled paper or stained glass, until the mid-nineteenth century, due to the high cost of making clear, flat panes of glass.|$|E
25|$|Mitigating {{damage to}} the {{environment}} was a concern, as part of creating an authentic experience of the landscape, which was to <b>unroll</b> like a movie from the motorist's perspective. The median strip was therefore relatively narrow; trees were retained close to the highway and sometimes, for example in the oak forest near Dessau, in the median. In fact the driver's experience of the forest, assigned symbolic importance in German Romanticism and particularly under the Nazis, was maximized by avoiding straightaways in forested areas so that the driver remained enclosed by the trees as long as possible. To some extent the autobahn landscapers were influenced in this emphasis on the natural environment by the American parkways; Todt had a 1934 USDA bulletin on Roadside Improvement reprinted for his planners' use, and Nazi designers visited Westchester County to study them, {{about the same time}} that the Westchester County Parks Commission (WCPC) was partly overseeing the construction of what is today the Taconic State Parkway's southern stretches. But the Reichsautobahn aimed for a more natural, less parklike view from the road, and although in both countries using natively occurring plants in highway landscaping was important, the Americans selectively emphasized those with an attractive appearance. Also, the autobahn was at the time presented, by Todt and others, as an improvement to the natural landscape; Todt refused to avoid the Siebengebirge, a protected conservation area, arguing not only that the area should be opened up for visits but that the road would make it more beautiful. This was not the policy in the U.S., where, most famously, the Blue Ridge Parkway was designed to be narrow and unobtrusive. Cost had the opposite effect with respect to plantings than it did with respect to curves: the Reichsautobahn landscapers had performed pioneering analyses of local ecosystems that led them to plant intensively in order to reconstruct what they determined would have been naturally present at the site, but at the end of 1936, as a result of cost overruns as well as his personal philosophy, Todt severely curtailed plantings, calling for an emphasis on open views.|$|E
40|$|This {{dissertation}} {{presents a}} machine learning {{solution to the}} compiler optimisation problem focused on a particular program transformation: loop <b>unrolling.</b> Loop <b>unrolling</b> is a very straightforward but powerful code transformation mainly used to improve Instruction Level Parallelism and to reduce the overhead due to loop control. However, loop <b>unrolling</b> can also be detrimental, for example, when the instruction cache is degraded due {{to the size of}} the loop body. Additionally, the effect of the interactions between loop <b>unrolling</b> and other program transformations is unknown. Consequently, determining when and how <b>unrolling</b> should be applied remains a challenge for compiler writers and researchers. This project works under the assumption that the effect of loop <b>unrolling</b> on the execution times of programs can be learnt based on past examples. Therefore, a regression approach able to learn the improvement in performance of loops under <b>unrolling</b> is presented. This novel approach differs from previous work ([Monsifrot et al., 2002] and [Stephenson and Amarasinghe, 2004]) because it does not formulate the problem as a classification task but as a regression solution. Great effort has been invested in the generation of clean and reliable data in order to make it suitable for learning. Two different regression algorithms have bee...|$|R
40|$|International audienceSoftware {{pipelining}} is {{a powerful}} technique to expose fine-grain parallelism, but it results in variables staying alive across more than one kernel iteration. It requires periodic register allocation and is challenging for code generation: {{the lack of a}} reliable solution currently restricts the applicability of software pipelining. The classical software solution that does not alter the computation throughput consists in <b>unrolling</b> the loop a posteriori [12], [11]. However, the resulting <b>unrolling</b> degree is often unacceptable and may reach absurd levels. Alternatively, loop <b>unrolling</b> can be avoided thanks to software register renaming. This is achieved through the insertion of move operations, but this may increase the initiation interval (II) which nullifies the benefits of software pipelining. This article aims at tightly controling the post-pass loop <b>unrolling</b> necessary to generate code. We study the potential of live range splitting to reduce kernel loop <b>unrolling,</b> introducing additional move instructions without inscreasing the II. We provide a complete formalisation of the problem, an algorithm, and extensive experiments. Our algorithm yields low <b>unrolling</b> degrees in most cases [...] with no increase of the II...|$|R
40|$|This paper {{presents}} recursion <b>unrolling,</b> {{a technique}} {{for improving the}} performance of recursive computations. Conceptually, recursion <b>unrolling</b> inlines recursive calls to reduce control flow overhead and {{increase the size of}} the basic blocks in the computation, which in turn increases the effectiveness of standard compiler optimizations such as register allocation and instruction scheduling. We have identified two transformations that significantly improve the effectiveness of the basic recursion <b>unrolling</b> technique. Conditional fusion merges conditionals with identical expressions, considerably simplifying the control flow in <b>unrolled</b> procedures. Recursion re-rolling rolls back the recursive part of the procedure to ensure that a large <b>unrolled</b> base case is always executed, regardless of the input problem size. We have implemented our techniques and applied them to an important class of recursive programs, divide and conquer programs. Our experimental results show that recursion unro [...] ...|$|R
500|$|The word {{evolution}} (from the Latin evolutio, meaning [...] "to <b>unroll</b> like a scroll") {{was initially}} {{used to refer}} to embryological development; its first use in relation to development of species came in 1762, when Charles Bonnet used it for his concept of [...] "pre-formation," [...] in which females carried a miniature form of all future generations. The term gradually gained a more general meaning of growth or progressive development.|$|E
500|$|As {{with other}} ferns, the leaves develop in a circinate pattern. [...] They begin as small, tight spirals which <b>unroll</b> as the leaf matures. [...] At full {{maturity}} they are held erect with the leaflets unfolded, except in Pilularia whose leaves have no blade. [...] Temperate species are deciduous, losing their vegetative leaves in winter. [...] Tropical species may also lose their leaves {{during the dry}} season. These leaves are photosynthetic, and produce most of the food used by the plant.|$|E
500|$|The most similar {{species are}} two {{once thought to}} be part of P.involutus in Europe. Paxillus obscurosporus has larger fruit bodies than P.involutus, with caps up to [...] wide whose margins tend to <b>unroll</b> and flatten with age, and a layer of cream-coloured mycelia {{covering}} the base of its tapered stipe. P.validus, also known only from Europe, has caps up to [...] wide with a stipe that is more or less equal in width throughout its length. Found under broadleaved trees in parks, it can be reliably distinguished from P.involutus (and other Paxillus species) by the presence of crystals up to 2.5μm long in the rhizomorphs, as the crystals found in rhizomorphs of other Paxillus species do not exceed 0.5μm long.|$|E
40|$|A {{well-known}} code transformation {{for improving}} the execution performance of a program is loop <b>unrolling.</b> The most obvious benefit of <b>unrolling</b> a loop is that the transformed loop usually, but not always, requires fewer instruction executions than the original loop. The reduction in instruction executions comes from two sources: the number of branch instructions executed is reduced, and the index variable is modified fewer times. In addition, for architectures with features designed to exploit instruction-level parallelism, loop <b>unrolling</b> can expose greater levels of instructionlevel parallelism. Loop <b>unrolling</b> is an effective code transformation often improving the execution performance of programs that {{spend much of their}} execution time in loops by ten to thirty percent. Possibly because of the effectiveness of a simple application of loop <b>unrolling,</b> it has not been studied as extensively as other code improvements such as register allocation or common subexpression elimination. The r [...] ...|$|R
50|$|Manual (or static) loop <b>unrolling</b> {{involves}} the programmer analyzing the loop and interpreting the iterations into {{a sequence of}} instructions which will reduce the loop overhead. This {{is in contrast to}} dynamic <b>unrolling</b> which is accomplished by the compiler.|$|R
3000|$|... is {{used for}} the rubbersheet transform. Further local noise masks can be {{combined}} using e.g., majority voting (not executed). The segmentation tool from [10] {{is used for}} <b>unrolling</b> the iris image. It {{should also be noted that}} the mask-level fusion generates a mask which is used for <b>unrolling</b> the iris only. No noise or occlusion mask is generated and consequently all tests performed on the fusion are performed purely on the <b>unrolled</b> iris image without masking.|$|R
500|$|Mizoguchi {{told his}} cinematographer Kazuo Miyagawa {{that he wanted}} the film [...] "to <b>unroll</b> {{seamlessly}} like a scroll-painting". The Southern School of Chinese painting was particularly an inspiration the filmmakers aspired to. The film has been praised for its cinematography, such as the opening shot and the scene where Genjurō and Lady Wakasa have sex by a stream and the camera follows {{the flow of the}} water instead of lingering on the two lovers. Mizoguchi never personally handled the camera and did not participate in planning the lighting of his film. To achieve the appearance the filmmakers wanted, Miyagawa kept lighting low and filmed as near to sunset as circumstances would allow. Many of the shots were taken from cranes, with Miyagawa claiming in 1992 that these shots made up 70% of the film. Miyagawa also stated that this film was the only occasion in which Mizoguchi complimented him for his camera work.|$|E
2500|$|The Hapoel Tel Aviv Football Club, {{considered}} the [...] "standard bearer of the Israeli left", utilizes {{the image of}} Che Guevara {{in an array of}} ways. At home matches, fans <b>unroll</b> banners emblazoned with the face of Che Guevara.|$|E
2500|$|Jacques Doucet {{had seen}} the {{painting}} at the Salon d'Antin, yet remarkably seems to have purchased Les Demoiselles without asking Picasso to <b>unroll</b> it in his studio {{so that he could}} see it again. André Breton later described the transaction: ...|$|E
40|$|In {{the primary}} leaf {{sections}} of etiolated wheat (Triticum aestivum L.) seedlings, red light-induced <b>unrolling</b> {{is accompanied by}} an increase in incorporation of 14 C-leucine into protein. By differential centrifugation, the <b>unrolling</b> response was found to be closely related to incorporation of the amino acid into the supernatant fraction (105, 000 g). Cycloheximide and chloramphenicol inhibit both leaf <b>unrolling</b> and synthesis of the supernatant protein, although chloramphenicol exerts its effect more strongly on the fraction which presumably contains the plastids. In a barley (Hordeum vulgare L.) albino mutant completely devoid of ribulose diphosphate carboxylase activity, only incorporation of 14 C-leucine into the supernatant fraction is substantially promoted by red light. This mutant exhibits the photoresponse of leaf <b>unrolling...</b>|$|R
40|$|Program loops {{are notorious}} for their {{optimization}} potential on modern high-performance architectures. Compilers aim at their aggressive transformation to achieve large improvements of the program performance. In particular, the optimization loop <b>unrolling</b> has shown in the past decades to be highly effective achieving significant increases of the average-case performance. In this paper, we present loop <b>unrolling</b> that is tailored towards real-time systems. Our novel optimization is driven by worst-case execution time (WCET) information to effectively minimize the program’s worst-case behavior. To exploit maximal optimization potential, the determination of a suitable <b>unrolling</b> factor is based on precise loop iteration counts provided by a static loop analysis. In addition, our heuristics avoid adverse effects of <b>unrolling</b> which result from instruction cache overflows and the generation of additional spill code. Results on 45 real-life benchmarks demonstrate that aggressive loop <b>unrolling</b> can yield WCET reductions of up to 13. 7 % over simple, naive approaches employed by many production compilers. 1...|$|R
50|$|Loop <b>unrolling</b> {{attempts}} {{to reduce the}} overhead of conditional branching needed to check whether a loop is done, by executing a batch of loop bodies per iteration. To handle cases where the number of iterations is not divisible by the unrolled-loop increments, a common technique among assembly language programmers is to jump directly {{into the middle of}} the <b>unrolled</b> loop body to handle the remainder.Duff implemented this technique in C by using C's case label fall-through feature to jump into the <b>unrolled</b> body.|$|R
