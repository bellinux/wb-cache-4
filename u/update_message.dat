96|541|Public
25|$|Link State Acknowledgment: These {{messages}} provide reliability to the link-state exchange process, by explicitly acknowledging {{receipt of}} a Link State <b>Update</b> <b>message.</b>|$|E
50|$|Update {{messages}}. The ACM evaluates update messages {{based on}} the simulation’s <b>update</b> <b>message</b> filtering criteria that the simulation provides. As discussed in earlier, when an ACM receives an <b>update</b> <b>message</b> there are four possible outcomes: (1) the ACM discards the message, (2) the ACM sends the simulation a create message, (3) the ACM sends the simulation the <b>update</b> <b>message,</b> or (4) the ACM sends the simulation a delete message.|$|E
50|$|The DT {{contains}} the network {{view of the}} neighbors of a node. It contains a matrix where each element {{contains the}} distance and the penultimate node reported by a neighbor for a particular destination. The RT contains the up-to-date view of the network for all known destinations. It keeps the shortest distance, the predecessor node (penultimate node), the successor node (the next node to reach the destination), and a flag indicating {{the status of the}} path. The path status may be a simple path (correct), or a loop (error), or the destination node not marked (null). The LCT contains the cost (e.g., the number of hops to reach the destination) of relaying messages through each link. The cost of a broken link is infinity. It also contains the number of update periods (intervals between two successive periodic updates) passed since the last successful update was received from that link. This is done to detect links breaks. The MRL contains an entry for every <b>update</b> <b>message</b> that is to be retransmitted and maintains a counter for each entry. This counter is decremented after every retransmission of an <b>update</b> <b>message.</b> Each <b>update</b> <b>message</b> contains a list of updates. A node also marks each node in the RT that has to acknowledge the <b>update</b> <b>message</b> it transmitted. Once the counter reaches zero, the entries in the <b>update</b> <b>message</b> for which no acknowledgments have been received are to be retransmitted and the <b>update</b> <b>message</b> is deleted. Thus, a node detects a link break by the number of update periods missed since the last successful transmission. After receiving an <b>update</b> <b>message,</b> a node not only updates the distance for transmission neighbors but also checks the other neighbors’ distance, hence convergence is much faster than DSDV.|$|E
50|$|There can be many <b>update</b> <b>messages</b> {{during a}} session.|$|R
40|$|The Border Gateway Protocol (BGP) is an Inter-Autonomous System (AS) routing {{protocol}} currently {{used in the}} Internet. The Minimal Route Advertisement Interval (MRAI) plays {{a prominent role in}} convergence of the BGP. The previous studies have suggested using the adaptive MRAI and reusable timers to reduce the BGP convergence time. The adaptive MRAI timers perform well under the normal load of BGP <b>update</b> <b>messages.</b> However, a large number of BGP <b>update</b> <b>messages</b> may flood the Internet routers. In this thesis, we propose a new algorithm called MRAI with Flexible Load Dispersing (FLD-MRAI) that reduces the router 2 ̆ 7 s overhead by dispersing the load in case {{of a large number of}} BGP <b>update</b> <b>messages.</b> We examine the MRAI timers under both the normal and heavy loads of BGP <b>update</b> <b>messages.</b> The proposed algorithm is evaluated using the ns-BGP network simulator and topologies are derived from the BCNET BGP traffic and from various topology generators...|$|R
40|$|The {{problem of}} network {{bandwidth}} limitations is encountered {{in almost any}} distributed virtual environ-ment or networked game. In a typical client-server setup, where the virtual world is managed by a server and replicated by connected clients which visualize the scene, the server must repeatedly transmit <b>update</b> <b>messages</b> to the clients. By employing visibility information, the number of messages transmitted over the network can be reduced by sending each client only <b>update</b> <b>messages</b> for objects which are visible {{from the viewpoint of}} the client. The Priority Round-Robin algorithm is a scheduling technique that allows the server to manage the transmission of <b>update</b> <b>messages</b> for each client with a constant overhead, reducing overall computational cost to a linear effort. The server can employ visibility information to schedule all objects, and due to a heuristic activity monitoring the algorithm is able to achieve a graceful degradation of the system's performance, even if the behavior of objects is unpredictable. This makes the Priority Round-Robin algorithm well suited to schedule <b>update</b> <b>messages</b> regarding server-controlled objects as well as user-controlled avatars...|$|R
50|$|Link State Acknowledgment: These {{messages}} provide reliability to the link-state exchange process, by explicitly acknowledging {{receipt of}} a Link State <b>Update</b> <b>message.</b>|$|E
5000|$|If {{there is}} any error in the <b>Update</b> <b>message</b> then a Notification message {{is sent to the}} peer, and BGP {{transitions}} back to the Idle state.|$|E
50|$|When an <b>update</b> <b>message</b> is received, a node updates its {{distance}} table and reassesses the best route paths. It also carries out a consistency check with its neighbors, to help eliminate loops and speed up convergence.|$|E
5000|$|In this state, the peers send <b>Update</b> <b>messages</b> to {{exchange}} information about each route being advertised to the BGP peer.|$|R
40|$|Abstract. Since the {{distributed}} virtual environments {{are growing}} {{in size and}} in number of participants, the number of <b>update</b> <b>messages</b> that is exchanged between host computers is increasing dramatically, which makes the management of <b>update</b> <b>messages</b> difficult. Many filtering techniques in distributed virtual environments are presented {{to reduce the number}} of <b>update</b> <b>messages</b> and thus reduce the load on the hosts and the network to be able to scale in the number of participants. However, filtering <b>update</b> <b>messages</b> may cause a lack of realism because of the loss of significant messages. This paper describes the effect management, which is a filtering technique that seeks to maintain the quality of filtering offered by the existing techniques with respect to the number of exchanged messages while trying to assure a better realism of the application. The effect management associates to each virtual object of the environment an effect zone that delimits a part of the space inside which the object can be perceived by the entities present in the scene. Moreover, it associates to each entity a viewing zone that reflects its visual capacity. When the viewing zone of an entity overlaps the effect zone of an object, the entity will be able to see this object; it starts then to receive the <b>update</b> <b>messages</b> related to it. This technique allows a better realism of the distributed virtual reality applications and a higher scalability. ...|$|R
50|$|The LMI {{multicasting}} extension allows multicast {{groups to}} be assigned. Multicasting saves bandwidth by allowing routing <b>updates</b> and address-resolution <b>messages</b> {{to be sent}} only to specific groups of routers. The extension also transmits reports {{on the status of}} multicast groups in <b>update</b> <b>messages.</b>|$|R
5000|$|... v2.3.1.0Version 2.3.1.0 is {{the last}} stable version of Shareaza that {{supports}} Windows 9x. It followed 2 days after the new owners of the project domain (see the shareaza.com domain takeover) exploited the updating mechanism to emit a false <b>update</b> <b>message</b> to trick users into installing their fake Shareaza V4 client, and contained a fix for this issue.|$|E
5000|$|Nodes {{periodically}} exchange {{routing tables}} {{with their neighbors}} via update messages, or whenever the link state table changes. The MRL maintains a list of which neighbors are yet to acknowledged an <b>update</b> <b>message,</b> {{so they can be}} retransmitted if necessary. Where no change in the routing table, a node is required to transmit a 'hello' message to affirm its connectivity.|$|E
50|$|Finally, the {{subscriber}} {{has ended}} the session, {{and the client}} sends a termination message to the server containing the last Used-Units. The server can use the termination message to clear any related reservations made in the back-end balance management system. If the subscriber did not terminate the session himself but instead depleted his balance then the server would have responded earlier with reject to an <b>update</b> <b>message,</b> possibly telling the client/control-point to redirect traffic (this normally only makes sense for HTTP/WAP traffic).|$|E
30|$|Figure  16 {{shows the}} {{relationship}} between the number of mobile hosts (MHs) and the number of update packets needed for handover management of many MHs performed at the same time. As depicted by the figure, the number of <b>update</b> <b>messages</b> is increased if the number of old PoA from which MHs come is increased. But the number of <b>update</b> <b>messages</b> is not affected by the number of MHs coming from each of the old PoA. This is because the DMHP classify MHs into different groups based on the old PoA for each MH. Thus, the N-PoA exchanges only two update packets with the appropriate old PoA for each group irrespective of the number of MHs inside each group. For example, if all MHs come from two PoAs then only four <b>update</b> <b>messages</b> (packets) are needed, two packets for each group.|$|R
5000|$|... 5,101,348 “Method of Reducing the Amount of Information Included in Topology <b>Update</b> <b>Messages</b> in a Data Communications Network” with Arrowood et al., issued March 31, 1992 ...|$|R
40|$|Attaching digital {{signatures}} {{to state}} <b>update</b> <b>messages</b> in global distributed shared object (DSO) systems is not trivial. If the DSO {{consists of a}} number of autonomous local representative that use open, public networks for maintaining the state consistency, allowing a local representative to sign state <b>update</b> <b>messages</b> is not appropriate. More sophisticated schemes are required to prevent unauthorized state updates by malicious local representative or external parties. This paper examines the problem in detail, compares a number of possible solutions, and identies the most suitable one and demonstrates how the state <b>update</b> <b>messages</b> can be signed using the identied solution. 1. INTRODUCTION Assume a distributed shared object (DSO) consisting {{of a number of}} local objects (representatives), i. e. components that reside in a single address space and communicate with other local objects in dierent address spaces. To use the DSO for, say, delivering digital products (e. g. software package [...] ...|$|R
5000|$|Belief {{propagation}} is {{a fundamental}} algorithm for inference in graphical models in which nodes repeatedly pass and receive messages corresponding to the evaluation of conditional expectations. In the kernel embedding framework, the messages may be represented as RKHS functions and the conditional distribution embeddings {{can be applied to}} efficiently compute message updates. Given n samples of random variables represented by nodes in a Markov Random Field, the incoming message to node t from node u can be expressed as [...] if it assumed to lie in the RKHS. The kernel belief propagation <b>update</b> <b>message</b> from t to node s is then given by ...|$|E
50|$|A node {{does not}} need to have the {{complete}} path to the destination in its route cache to make use of a cache line. Instead, the message is routed towards the physical nearest node that makes progress in the virtual ring. When the message arrives at this intermediate node, that node adds information from its route cache to the source route. This step is repeated as needed. When the message arrives at the final destination, after path optimization (using Dijkstra's algorithm) a route <b>update</b> <b>message</b> is sent to the originator node, thus updating the originators route cache.This technique facilitates the usage of fixed size route caches, which limits the per-node state and makes SSR a viable option for low memory environments.|$|E
50|$|SIMNET {{used the}} concept of “dead reckoning” to {{correlate}} {{the positions of the}} objects and actors within the simulated environment. Duncan (Duke) Miller, the BBN SIMNET program manager, first used this term, which harks back to the earliest days of ship navigation, to explain how simulators were able to communicate state change information to each other while minimizing network traffic. Essentially, the approach involves calculating the current position of an object from its previous position and velocity (which is composed of vector and speed elements) (Pimental and Blau 1994). The SIMNET protocols provided that whenever the true state of a simulator deviated by more than a certain threshold from its state as computed by dead reckoning, the simulator was obligated to send out a new state <b>update</b> <b>message.</b>|$|E
40|$|The {{relevance}} of distributed virtual environments (DVE) and interactive 3 D worlds for entertaining and commercial purposes is steadily increasing. DVEs are typically implemented as traditional client/server based scenarios {{in which a}} central server system controls {{the state of the}} distributed data and sends <b>update</b> <b>messages</b> to all clients. In this paper we describe the benefits of a demand-driven approach for a DVE. A distributed operating system is used to host the DVE application. The common scene graph of the DVE resides in shared memory and offers direct access to the participating nodes – no explicit <b>update</b> <b>messages</b> are needed. The shared memory concept allows for an easier, more intuitive and less fault-prone way of creating distributed applications like a DVE and it offers inherent consistency and efficiency because the nodes do not have to process unneeded <b>update</b> <b>messages.</b> An existing prototype demonstrates the benefits resulting from this concept...|$|R
40|$|Abstract—In {{this paper}} we propose a new {{architecture}} based on Z-order curve and kd-tree that can efficiently handle issues related to <b>update</b> <b>messages</b> distribution to interested entities’ locations in a three-dimensional (3 D) virtual environments where locations are described in terms of 3 D coordinates. We also aim to minimize the number of routing hops in distribution of <b>update</b> <b>messages,</b> especially when <b>updates</b> are forwarded to a specific range of users/entities in the virtual environment. Our results are promising and show improvements in both of the objectives. Keywords:Virtual Environments, Massively MultiuserRouting, KD-Tre...|$|R
5000|$|Emergency-oriented instant {{messenger}} {{requires that}} the sender of the message {{have the ability to}} <b>update</b> <b>messages</b> that are appearing on users PC screens without the recipient needing to take any action.|$|R
5000|$|A {{new version}} of MIDI {{tentatively}} called [...] "HD Protocol" [...] or [...] "High-Definition Protocol" [...] has been under discussion since 2005, {{when it was announced}} as [...] "HD-MIDI". This new standard offers full backward compatibility with MIDI 1.0 and is intended to support higher-speed transports, allow plug-and-play device discovery and enumeration, and provide greater data range and resolution. The numbers of channels and controllers are to be increased and messages are to be simplified. Entirely new kinds of events will be supported, such as a Note <b>Update</b> <b>message</b> and Direct Pitch in the Note message which are aimed at guitar controllers. Proposed physical layer transports include Ethernet-based protocols such as RTP MIDI and Audio Video Bridging. The HD Protocol and a User Datagram Protocol (UDP)-based transport are under review by MMA's High-Definition Protocol Working Group (HDWG), which includes representatives from all sizes and types of companies.|$|E
50|$|ReplayTV was a {{brand of}} digital video {{recorder}} (DVR), a term synonymous with personal video recorder (PVR). It is a consumer video device which allows users to capture television programming to internal hard disk storage for later viewing (and time shifting). The first ReplayTV model was introduced in January 1999 during the Consumer Electronics Show in Las Vegas, {{at the same time}} as a competing DVR model from rival company TiVo. After the sale of assets to DirecTV, ReplayTV's only ongoing activity was maintenance of the electronic program guide service by D&M Holdings, which was to be discontinued on July 31, 2011. However, on July 29, 2011, a notice was placed on the ReplayTV website stating that service would be continued without interruption for lifetime subscribers and monthly subscribers may have a short interruption in service. On September 2, 2011, programming contact through the ReplayTV dialup system was terminated without any <b>update</b> <b>message</b> being sent to subscribers or posted on replaytv.com. DNNA filed for bankruptcy on July 20, 2015. EPG data from their servers ran out on July 15, 2015. Even with the end of support from DNNA, third party solutions are available to provide Electronic Program Guide data to Replays.|$|E
40|$|A {{correspondent}} host {{that needs}} to begin a real-time packet-data session with a mobile node sends a mobile IP binding request message to a home agent of the mobile node. The correspondent host does not send any further messages until it has received a binding <b>update</b> <b>message</b> {{in response to the}} binding request message. Upon receipt of the binding <b>update</b> <b>message,</b> the correspondent host knows a care-of address of the mobile node. A binding to the care-of address is created responsive to receipt of the binding <b>update</b> <b>message.</b> An RSVP PATH message is sent by the correspondent host responsive to receipt of the binding <b>update</b> <b>message.</b> The RSVP PATH message explicitly binds a data path of a packet flow to the mobile node. The correspondent host perceives a RSVP RESV message in response to the RSVP PATH message...|$|E
50|$|The HLR is {{a system}} which {{directly}} receives and processes MAP transactions and messages from elements in the GSM network, for example, the location <b>update</b> <b>messages</b> received as mobile phones roam around.|$|R
40|$|The route {{optimization}} {{operation in}} Mobile IP Version 6 (MIPv 6) allows direct routing from any correspondent node to any mobile node and thus eliminates {{the problem of}} "triangle routing" present in the base Mobile IP Version 4 (MIPv 4) protocol. Route optimization, however, requires that a mobile node constantly inform its correspondent nodes about its new care-of addresses by sending them binding <b>update</b> <b>messages.</b> Unauthenticated or malicious binding updates {{open the door for}} intruders to perform redirect attacks, i. e., malicious acts which redirect traffic from correspondent nodes to locations chosen by intruders. How to protect binding <b>update</b> <b>messages</b> to defend against redirect attacks is a challenging problem given the open environment in which MIPv 6 operates. In this paper, we first look at two solutions proposed by the IETF Mobile IP Working Group and point out their weaknesses. We then present a new protocol for securing binding <b>update</b> <b>messages.</b> We also show that our protocol achieves strong security {{and at the same time}} is highly scalable to wide spread deployment...|$|R
50|$|However, {{when the}} UE jumps {{back and forth}} between the {{previous}} and serving networks, the signalling overhead resulting from the frequent Location <b>Update</b> <b>messages</b> is substantial and the resulting traffic is burdensome to the network.|$|R
40|$|This paper {{presents}} a new mechanism, called BGP with root cause notification (BGP-RCN), that provides an upper bound of O(d) on routing convergence delay for BGP, where d is the network diameter {{as measured by}} the number of AS hops. BGP-RCN lets each routing <b>update</b> <b>message</b> carry the information about the specific cause which triggered the <b>update</b> <b>message.</b> Once a node v receives the first <b>update</b> <b>message</b> triggered by a link failure, v can avoid using any paths that have been obsoleted by the same failure. The basic approach in BGP-RCN is applicable to path vector routing protocols in general. Our analysis and simulation show that BGP-RCN can achieve substantial reduction in both BGP convergence time and the total number of intermediate route changes. Ó 2004 Elsevier B. V. All rights reserved...|$|E
30|$|In case of handoff, the MH {{will send}} an <b>update</b> <b>message</b> {{and wait for}} the first packet to arrive. Before the binding <b>update</b> <b>message</b> arrives the {{previous}} FA/THA (ROMIP/HH-MIP) or HA (MIP), packets will be sent to the previous location of the MH and will be lost. The longer the path that update messages need to travel, the larger the handoff latency resulting in more packet loss. Therefore, we measure the delivery distance of binding message as the handoff latency.|$|E
30|$|The latency {{due to the}} HIP MN {{sending the}} <b>update</b> <b>message</b> with a locator {{parameter}} (carried in the first UPDATE packet) to update the CNs, LLU 1 _CN.|$|E
3000|$|..., these {{neighboring}} nodes should {{report the}} <b>updated</b> <b>messages</b> to the sink. We {{call this the}} event rate, which {{is the sum of}} the departure rate from the node i to node j, and the arrival rate from the node [...]...|$|R
40|$|Boarder Gateway Protocol is an Exterior Gateway Protocol used between Autonomous Systems (ASes) to send update {{information}} upon {{changes in the}} network topology. Network reachability information is contained within BGP <b>update</b> <b>messages.</b> Recent trends in BGP anomaly detection systems employ machine learning techniques to mine network data. In the proposed approach, we consider diversity of anomalous events and the volume of BGP data to be processed. Creating efficient environment to access data is useful in collaborative research projects. We collect raw data, import BGP <b>update</b> <b>messages</b> into a database, issue appropriate SQL queries to extract features, and analyze query results. Obtained data {{may be used for}} machine learning modeling and development of BGP anomaly detection systems...|$|R
40|$|Synchronous {{collaboration}} in virtual reality spaces has specific requirements {{that differ from}} those of other application data, leading to a different communication approach. <b>Update</b> <b>messages</b> corresponding to the change in the state of a shared object must be communicated both reliably and in a timely manner among users. While a lot of research has been done in terms of transmission of <b>update</b> <b>messages</b> representing the motion of avatars and objects, very few works focus on collaboration itself. Here, we present an architecture that supports tightlycoupled collaborative tasks to be performed efficiently in virtual environments. The architecture consists of an application-general layer which is mapped into a communication protocol. An implementation is also presented as proof of concept...|$|R
