9|2|Public
50|$|An HPET chip {{consists}} of a 64-bit <b>up-counter</b> (main counter) counting at a frequency of at least 10 MHz, {{and a set of}} (at least three, up to 256) comparators. These comparators are 32- or 64-bit-wide. The HPET is programmed via a memory mapped I/O window that is discoverable via Advanced Configuration and Power Interface (ACPI). The HPET circuit in modern PCs is integrated into the southbridge chip.|$|E
5000|$|We {{will build}} the {{indirect}} CPY ( [...] i, q, d, φ [...] ) with the CASE operator. The {{address of the}} target register will be specified by the contents of register [...] "q"; once the CASE operator has determined what this number is, CPY will directly deposit {{the contents of the}} register with that number into register [...] "φ". We will need an additional register that we will call [...] "y"it serves as an <b>up-counter.</b>|$|E
5000|$|The {{following}} {{example is}} an <b>up-counter</b> with asynchronous reset, parallel load and configurable width. It demonstrates {{the use of}} the 'unsigned' type, type conversions between 'unsigned' and 'std_logic_vector' and VHDL generics. The generics are very close to arguments or templates in other traditional programming languages like C++.library IEEE;use IEEE.std_logic_1164.all;use IEEE.numeric_std.all; -- for the unsigned typeentity COUNTER is generic ( [...] WIDTH : in natural := 32); port ( [...] RST : in std_logic; CLK : in std_logic; LOAD : in std_logic; DATA : in std_logic_vector(WIDTH-1 downto 0); Q : out std_logic_vector(WIDTH-1 downto 0));end entity COUNTER;architecture RTL of COUNTER is signal CNT : unsigned(WIDTH-1 downto 0);begin process(RST, CLK) is begin if RST = '1' then CNT <= (others => '0'); elsif rising_edge(CLK) then if LOAD = '1' then CNT <= unsigned(DATA); -- type is converted to unsigned else CNT <= CNT + 1; end if; end if; end process; Q <= std_logic_vector(CNT); -- type is converted back to std_logic_vectorend architecture RTL; ...|$|E
40|$|This paper {{describes}} a hardware architectural {{design of a}} real-time counter based entropy coder at a register transfer level (RTL) computing model. The architecture {{is based on a}} lossless compression algorithm called Rice coding, which is optimal for an entropy range of bits per sample. The architecture incorporates a word-splitting scheme to extend the entropy coverage into a range of bits per sample. We have designed a data structure in a form of independent code blocks, allowing more robust compressed bitstream. The design focuses on an RTL computing model and architecture, utilizing 8 -bit buffers, adders, registers, loader-shifters, select-logics, down-counters, <b>up-counters,</b> and multiplexers. We have validated the architecture (both the encoder and the decoder) in a coprocessor for 8 bits/sample data on an FPGA Xilinx XC 4005, utilizing 61 % of F&G-CLBs, 34 % H-CLBs, 32 % FF-CLBs, and 68 % IO resources. On this FPGA implementation, the encoder and decoder can achieve 1. 74 Mbits/s and 2. 91 Mbits/s throughputs, respectively. The architecture allows pipelining, resulting in potentially maximum encoding throughput of 200 Mbit/s on typical real-time TTL implementations. In addition, it uses a minimum number of register elements. As a result, this architecture can result in low cost, low energy consumption and reduced silicon area realizations...|$|R
40|$|Abstract. This paper {{describes}} a hardware architectural {{design of a}} real-time counter based entropy coder at a register transfer level (RTL) computing model. The architecture {{is based on a}} lossless compression algorithm called Rice coding, which is optimal for an entropy range of 5. 25. 1 H bits per sample. The architecture incorporates a word-splitting scheme to extend the entropy coverage into a range of 5. 75. 1 H bits per sample. We have designed a data structure in a form of independent code blocks, allowing more robust compressed bitstream. The design focuses on an RTL computing model and architecture, utilizing 8 -bit buffers, adders, registers, loader-shifters, select-logics, down-counters, <b>up-counters,</b> and multiplexers. We have validated the architecture (both the encoder and the decoder) in a coprocessor for 8 bits/sample data on an FPGA Xilinx XC 4005, utilizing 61 % of F&G-CLBs, 34 % H-CLBs, 32 % FF-CLBs, and 68 % IO resources. On this FPGA implementation, the encoder and decoder can achieve 1. 74 Mbits/s and 2. 91 Mbits/s throughputs, respectively. The architecture allows pipelining, resulting in potentially maximum encoding throughput of 200 Mbit/s on typical real-time TTL implementations. In addition, it uses a minimum number of register elements. As a result, this architecture can result in low cost, low energy consumption and reduced silicon area realizations...|$|R
40|$|Abstract — Memory Built-In Self-Test (MBIST) {{has become}} a {{standard}} industrial practice. Its quality is mainly deter-mined by its fault detection capability {{in relationship to the}} the area overhead. The MBIST Address Generator (AG) is largely responsible for the fault detection capability, and has a significant contribution to the area overhead. This paper analyzes the properties and implementation aspects of several AGs. In addition, it presents a novel, very systematic, high-speed, low-power and low-overhead implementation, based on an <b>Up-counter</b> and a set of multiplexors...|$|E
40|$|A Threshold Logic Unit (TLU) is a {{mathematical}} function {{conceived as a}} crude model, or abstraction of biological neurons. Threshold logic units are the constitutive units in an artificial neural network. In this paper a positive clock-edge triggered T flip-flop is designed using Perceptron Learning Algorithm, which is a basic design algorithm of threshold logic units. Then this T flip-flop is used to design a two-bit <b>up-counter</b> that goes through the states 0, 1, 2, 3, 0, 1 … Ultimately, {{the goal is to}} show how to design simple logic units based on threshold logic based perceptron concepts...|$|E
40|$|In {{this work}} a {{simplified}} yet innovative approach {{was used to}} realize the digital function generator by adopting an analog device, a potential divider, to replace the Programmable Read Only Memory (PROM) stage and all its debacles, and a multiplexer to replace the Digital-to-Analog (DAC). The stepped voltage waveform obtained from the synthesis is passed through a low-pass filter (LPF) to achieve a high-purity sine wave. A corresponding 50 % duty cycle square wave {{was obtained from the}} <b>up-counter</b> used for switching the multiplexer. This was integrated to generate triangular wave. The output stage provided impedance matching of 50 Ω presented at a BNC output connector...|$|E
40|$|Memory Built-In Self-Test (MBIST) {{has become}} a {{standard}} engineering practice. Its excellence is mainly determined by its fault detection capacity {{in relationship to the}} area overhead. In the world of MBIST, memory accesses have to be applied at-speed, using Back-to-Back memory cycles. Systems require large, high speed memories, while current technology exhibits a large spread in implementation parameters, resulting in speed-related faults. Their detection is mandatory in today’s industry and requires non-linear algorithms such as Gal Pat, Gal Row and Gal Column, and a special Address Generator. The MBIST Address Generator is mainly responsible for the fault detection capability, and has an important contribution to the area overhead. The Address Generator is a key MBIST component. In order to detect speed-related faults, the Address Generator has to generate a large set of address sequences, with Back-to-Back cycles and the appropriate address transitions. This paper analyzes the properties and performance aspects of several Address Generator. In addition, a novel very systematic, high speed, low-power and low-overhead implementation is presented which is based on an <b>Up-counter</b> and a set of multiplexors. </p...|$|E
40|$|ARTICLE IN PRESS Self-timed {{logic design}} methods are {{developed}} using Threshold Combinational Reduction (TCR) within the NULL Convention Logic (NCL) paradigm. NCL logic functions are realized using 27 distinct transistor networks implementing {{the set of}} all functions of four or fewer variables, thus facilitating a variety of gatelevel optimizations. TCR optimizations are formalized for NCL and then assessed by comparing levels of gate delays, gate counts, transistor counts, and power utilization of the resulting designs. The methods are illustrated to produce (1) fundamental logic functions that are 2. 2 – 2. 3 times faster and require 40 – 45 % fewer transistors than conventional canonical designs, (2) a Full Adder with reduced critical path delay and transistor count over various alternative gate-level synthesis approaches, resulting in a circuit with at least 48 % fewer transistors, half as many gate delays to generate the carry output, and {{the same number of}} gate delays to generate the sum output, as its nearest competitors, and (3) time, space, and power optimized increment circuits for a 4 -bit <b>up-counter,</b> resulting in a throughput-optimized design that is 14 % and 82 % faster than area- and power-optimized designs, respectively, an area-optimized design that requires 22 % and 42 % fewer transistors than the speed- and power-optimized designs, respectively, and a power-optimized design that dissipates 63 % and 42 % less power than the speed- and area-optimized designs, respectively. Results demonstrate support for a variety of optimizations utilizing conventional Boolean minimization followed by table-driven gate substitutions, providing for an NCL design method that is readily automatable...|$|E
40|$|Abstract: In control applications, {{most of the}} {{physical}} systems require a real-time operation to interface high speed constraints; higher density programmable logic devices such as {{field programmable gate array}} (FPGA) can be used to integrate large amounts of logic in a single IC. This paper presents an Experimental implementation of digital logic designs on the Altera DE 2 board which presented as an educational and development board, in order to check the flexible implementation with FPGA and to get the better and safely ways to use these specifications during any design implementations. The implementation in this paper contains of two types of digital logic design, the first one is Digital <b>UP-counter</b> design which designed using Verilog language, the experimental results for this design displayed on the 7 -segment with the sequence of HEX 0 and HEX 1. The second design is the proportional-derivative (PD) fuzzy logic controller which contain of three parts, Fuzzifier, inference engine and Defuzzifier. The PD Fuzzy logic controller was designed using VHDL language. Groups of two membership function with 5 linguistics variable and rule table of 25 rules were used to generate the control surface of the PD fuzzy logic controller, and to generate the simulation before the implementation, these groups are stored in the memory blocks, this block is generated using MegaWizard Plug-in Manager provided by Altera Quartus II program, the design using MegaWizard is important to ensure the good design specifications, the surfaces with these groups compared with the same design using MATLAB. By subtracting both type of surfaces, a results have been obtained, these results proved that the FPGA-based fuzzy controller is very close to the software-based controller using MATLAB...|$|E

