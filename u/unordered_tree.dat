53|193|Public
5000|$|In graph theory, a {{recursive}} tree (i.e., <b>unordered</b> <b>tree)</b> is a non-planar labeled rooted tree. A size-n recursive tree {{is labeled}} by distinct integers 1, 2, ..., n, where the labels are strictly increasing {{starting at the}} root labeled 1. Recursive trees are non-planar, {{which means that the}} children of a particular node are not ordered. E.g. the following two size-three recursive trees are the same.|$|E
40|$|Abstract − An XML tree pattern query, {{represented}} as a labeled tree, is essentially a complex selection predicate on both structure and content of an XML. Tree pattern matching {{has been identified as}} a core operation in querying XML data. We distinguish between two kinds of tree pattern matchings: ordered and <b>unordered</b> <b>tree</b> matching. By the <b>unordered</b> <b>tree</b> matching, only ancestor/descendant and parent/child relationships are considered. By the ordered tree matching, however, the order of siblings has {{to be taken into account}} besides ancestor/descendant and parent/child relationships. While different fast algorithms for <b>unordered</b> <b>tree</b> matching are available, no efficient algorithm for ordered tree matching for XML data exists. In this paper, we discuss a new algorithm for processing ordered tree pattern queries, whose time complexity is polynomial. Key words: XML documents; tree pattern queries; tree matching; tree encoding; XB-trees...|$|E
30|$|We {{define the}} problem of extracting {{homomorphic}} and maximal homomorphic <b>unordered</b> <b>tree</b> patterns with descendant relationships from a single large data tree. This problem departs from previous ones which focus on mining-induced or embedded tree patterns from a set of small data trees.|$|E
40|$|Abstract—Frequent tree {{patterns}} {{have many}} applications in different domains such as XML document mining, user web log analysis, network routing and bioinformatics. In this paper, we first introduce three new tree encodings and accordingly present an efficient algorithm for finding frequent patterns from rooted <b>unordered</b> <b>trees</b> {{with the assumption}} that children of every node in database trees are identically labeled. Then, we generalize the method and propose the UITree algorithm to find frequent patterns from rooted <b>unordered</b> <b>trees</b> without any restriction. Compared to other algorithms in the literature, UItree manages occurrences of a candidate tree in database trees more efficiently. Our extensive experiments on both real and synthetic datasets show that UITree significantly outper-forms the most efficient existing works on mining <b>unordered</b> <b>trees.</b> Keywords-Frequent <b>tree</b> patterns, rooted <b>unordered</b> <b>trees,</b> tree encoding, candidate generation, frequency counting. I...|$|R
40|$|Abstract. Many {{knowledge}} representation mechanisms consist of linkbased structures; {{they may be}} studied formally by means of <b>unordered</b> <b>trees.</b> Here we consider the case where labels on the nodes are nonexistent or unreliable, and propose data mining processes focusing on just the link structure. We propose a representation of ordered trees, describe a combinatorial characterization and some properties, {{and use them to}} propose an efficient algorithm for mining frequent closed subtrees from a set of input trees. Then we focus on <b>unordered</b> <b>trees,</b> and show that intrinsic characterizations of our representation provide for a way of avoiding the repeated exploration of <b>unordered</b> <b>trees,</b> and then we give an efficient algorithm for mining frequent closed <b>unordered</b> <b>trees.</b> ...|$|R
40|$|Background]Measuring {{similarities}} between tree structured data {{is important for}} analysis of RNA secondary structures, phylogenetic trees, glycan structures, and vascular trees. The edit distance {{is one of the}} most widely used measures for comparison of tree structured data. However, it is known that computation of the edit distance for rooted <b>unordered</b> <b>trees</b> is NP-hard. Furthermore, there is almost no available software tool that can compute the exact edit distance for <b>unordered</b> <b>trees.</b> [Results]In this paper, we present a practical method for computing the edit distance between rooted <b>unordered</b> <b>trees.</b> In this method, the edit distance problem for <b>unordered</b> <b>trees</b> is transformed into the maximum clique problem and then efficient solvers for the maximum clique problem are applied. We applied the proposed method to similar structure search for glycan structures. The result suggests that our proposed method can efficiently compute the edit distance for moderate size <b>unordered</b> <b>trees.</b> It also suggests that the proposed method has the accuracy comparative to those by the edit distance for ordered trees and by an existing method for glycan search. [Conclusions]The proposed method is simple but useful for computation of the edit distance between <b>unordered</b> <b>trees.</b> The object code is available upon request...|$|R
40|$|Abstract In data {{integration}} applications, a join matches {{elements that are}} common to two data sources. Since ele-ments are represented slightly different in each source, an approximate join must be used to do the matching. For XML data, most existing approximate join strategies are based on some ordered tree matching technique, such as the tree edit distance. In data-centric XML, however, the sibling order is irrelevant, and two elements should match even if their subelement order varies. Thus, approximate joins for data-centric XML must leverage <b>unordered</b> <b>tree</b> matching tech-niques. This is computationally hard since the algorithms cannot rely on a predefined sibling order. In this paper, we give a solution for approximate joins based on <b>unordered</b> <b>tree</b> matching. The core of our solution are windowed pq-grams, which are small subtrees of a specific shape. We develop an efficient technique to generate windowed pq-grams in a three-step process: sort the tree, extend the sorted tree with dummy nodes, and decompose the extended tree into win-dowed pq-grams. The windowed pq-gram distance between two trees {{is the number of}} pq-grams that are in one tree decomposition only. We show that our distance is a pseudo-metric and empirically demonstrate that it effectively approx-imates the <b>unordered</b> <b>tree</b> edit distance. The approximate joi...|$|E
40|$|In data {{integration}} applications, a join matches {{elements that are}} common to two data sources. Since elements are represented slightly different in each source, an approximate join must be used to do the matching. For XML data, most existing approximate join strategies are based on some ordered tree matching technique, such as the tree edit distance. In data-centric XML, however, the sibling order is irrelevant, and two elements should match even if their subelement order varies. Thus, approximate joins for data-centric XML must leverage <b>unordered</b> <b>tree</b> matching techniques. This is computationally hard since the algorithms cannot rely on a predefined sibling order. In this paper, we give a solution for approximate joins based on <b>unordered</b> <b>tree</b> matching. The core of our solution are windowed pq-grams which are small subtrees of a specific shape. We develop an efficient technique to generate windowed pq-grams in a three-step process: sort the tree, extend the sorted tree with dummy nodes, and decompose the extended tree into windowed pq-grams. The windowed pq-grams distance between two trees {{is the number of}} pq-grams that are in one tree decomposition only. We show that our distance is a pseudo-metric and empirically demonstrate that it effectively approximates the <b>unordered</b> <b>tree</b> edit distance. The approximate join using windowed pq-grams can be efficiently implemented as an equality join on strings, which avoids the costly computation of the distance between every pair of input trees. Experiments with synthetic and real world data confirm the analytic results and show the effectiveness and efficiency of our technique...|$|E
30|$|To {{the best}} of our knowledge, direct mining of maximal {{embedded}} patterns has not been studied in the literature. We therefore use post-processing pruning which eliminates non-maximal patterns after computing all frequent embedded patterns. For this task, we implemented the <b>unordered</b> <b>tree</b> inclusion algorithm described in [12]. As our experiments show, the cost of this post-processing step is in general not significant compared to the frequent pattern mining cost.|$|E
40|$|Abstract Background Measuring {{similarities}} between tree structured data {{is important for}} analysis of RNA secondary structures, phylogenetic trees, glycan structures, and vascular trees. The edit distance {{is one of the}} most widely used measures for comparison of tree structured data. However, it is known that computation of the edit distance for rooted <b>unordered</b> <b>trees</b> is NP-hard. Furthermore, there is almost no available software tool that can compute the exact edit distance for <b>unordered</b> <b>trees.</b> Results In this paper, we present a practical method for computing the edit distance between rooted <b>unordered</b> <b>trees.</b> In this method, the edit distance problem for <b>unordered</b> <b>trees</b> is transformed into the maximum clique problem and then efficient solvers for the maximum clique problem are applied. We applied the proposed method to similar structure search for glycan structures. The result suggests that our proposed method can efficiently compute the edit distance for moderate size <b>unordered</b> <b>trees.</b> It also suggests that the proposed method has the accuracy comparative to those by the edit distance for ordered trees and by an existing method for glycan search. Conclusions The proposed method is simple but useful for computation of the edit distance between <b>unordered</b> <b>trees.</b> The object code is available upon request. </p...|$|R
40|$|Abstract. Recently, an {{algorithm}} called Freqt {{was introduced}} which enumerates all frequent induced subtrees in an ordered data tree. We propose a new algorithm for mining unordered frequent induced subtrees. We {{show that the}} complexity of enumerating <b>unordered</b> <b>trees</b> is not higher than the complexity of enumerating ordered trees; a strategy for determining the frequency of <b>unordered</b> <b>trees</b> is introduced. ...|$|R
40|$|Abstract. Link-based {{data may}} be studied {{formally}} {{by means of}} <b>unordered</b> <b>trees.</b> On a dataset formed by such link-based data, a natural notion of support-based closure can be immediately defined. Abstracting information from subsets of such data requires, first, a formal notion of intersection; second, {{deeper understanding of the}} notion of closure; and, third, efficient algorithms for computing intersections on <b>unordered</b> <b>trees.</b> We provide answers to these three questions. ...|$|R
40|$|International audienceA binary <b>unordered</b> <b>tree</b> is a tree {{where each}} {{internal}} node {{has two children}} and the relative order of the subtrees of a node is not important (i. e. two trees are different if they differ only in the respective ordering of subtrees of nodes). We present a new method to generate all binary rooted unordered trees with n internal nodes, without duplications, in O(log n) time...|$|E
30|$|Therefore, homomorphisms and {{homomorphic}} patterns {{display a}} number of advantages. First, they allow the extraction of patterns that cannot be extracted by embedded patterns. Second, extracted homomorphic patterns can be larger than embedded patterns. Finally, homomorphisms can be computed more efficiently than embeddings. Indeed, the problem of checking {{the existence of a}} homomorphism of an <b>unordered</b> <b>tree</b> pattern to a data tree is polynomial [13], while the corresponding problem for an embedding is NP-complete [12].|$|E
3000|$|Trees and {{inverted}} lists We consider rooted labeled trees, {{where each}} tree has a distinguished root node and a labeling function lb mapping nodes to labels. A tree is called ordered {{if it has}} a predefined left-to-right ordering among the children of each node. Otherwise, it is unordered. The size of a tree is defined as the number of its nodes. In this paper, unless otherwise specified, a tree pattern is a rooted, labeled, <b>unordered</b> <b>tree.</b>|$|E
40|$|Frequent tree {{patterns}} {{have many}} applications in different domains such as XML document mining, user web log analysis, network routing and bioinformatics. In this paper, we first introduce three new tree encodings and accordingly present an efficient algorithm for finding frequent patterns from rooted <b>unordered</b> <b>trees</b> {{with the assumption}} that children of every node in database trees are identically labeled. Then, we generalize the method and propose the UITree algorithm to find frequent patterns from rooted <b>unordered</b> <b>trees</b> without any restriction. Compared to other algorithms in the literature, UItree manages occurrences of a candidate tree in database trees more efficiently. Our extensive experiments on both real and synthetic datasets show that UITree significantly outperforms the most efficient existing works on mining <b>unordered</b> <b>trees.</b> status: publishe...|$|R
40|$|We {{consider}} learning tree patterns from queries extending our preceding work [Amoth, Cull, & Tadepalli, 1998]. The {{instances in}} this paper are <b>unordered</b> <b>trees</b> with nodes labeled by constant identifiers. The concepts are tree patterns and unions of <b>tree</b> patterns (<b>unordered</b> forests) with leaves labeled with constants or variables. A tree pattern matches any tree with its variables replaced with constant subtrees. A negative result for learning with equivalence and membership/subset queries is shown for <b>unordered</b> <b>trees</b> where a successful match requires {{the number of children}} in the pattern and instance to be the same. <b>Unordered</b> <b>trees</b> and forests are shown to be learnable with an alternative matching semantics that allows an instance to have extra children at each node...|$|R
40|$|A {{one-dimensional}} {{fragment of}} first-order logic is obtained by restricting quantification to blocks of existential quantifiers that leave at most one variable free. This fragment contains two-variable logic, {{and it is}} known that over words both formalisms have the same complexity and expressive power. Here we investigate the one-dimensional fragment over trees. We consider unranked <b>unordered</b> <b>trees</b> accessible by {{one or both of the}} descendant and child relations, as well as ordered trees equipped additionally with sibling relations. We show that over <b>unordered</b> <b>trees</b> the satisfiability problem is ExpSpace-complete when only the descendant relation is available and 2 ExpTime-complete with both the descendant and child or with only the child relation. Over ordered trees the problem remains 2 ExpTime-complete. Regarding expressivity, we show that over ordered <b>trees</b> and over <b>unordered</b> <b>trees</b> accessible by both the descendant and child the one-dimensional fragment is equivalent to the two-variable fragment with counting quantifiers...|$|R
40|$|We {{explore a}} method for quickly {{generating}} optimal CMOS functional circuits. The method is based upon an algebra we have derived that describes the composition of parallel-series graphs and their duals smultaneously, and as such, exactly describes the layout of CMOS functional circuits. The method is constructive; it creates the smallest components first, putting them together until the final circuit is realized. The constructed layout is representative of an <b>unordered</b> <b>tree</b> traversal, and is generated in time proportional {{to the number of}} input signals. Afte...|$|E
40|$|The tree {{inclusion}} problem is, {{given two}} node-labeled trees P and T (the "pattern tree" and the "text tree"), to locate every minimal subtree in T (if any) {{that can be}} obtained by applying a sequence of node insertion operations to P. The ordered tree inclusion problem is known to be solvable in polynomial time while the <b>unordered</b> <b>tree</b> inclusion problem is NP-hard. The currently fastest algorithm for the latter is from 1995 and runs in O(poly(m,n) · 2 ^ 2 d) = O^∗(4 ^d) time, where m and n are the sizes of the pattern and text trees, respectively, and d is the degree of the pattern tree. Here, we develop a new algorithm that improves the exponent 2 d to d by considering a particular type of ancestor-descendant relationships and applying dynamic programming, thus reducing the time complexity to O^∗(2 ^d). We then study restricted variants of the <b>unordered</b> <b>tree</b> inclusion problem where the number of occurrences of different node labels and/or the input trees' heights are bounded and show that although the problem remains NP-hard in many such cases, if the leaves of P are distinctly labeled and each label occurs at most c times in T then it can be solved in polynomial time for c = 2 and in O^∗(1. 8 ^d) time for c = 3. Comment: 13 pages, 8 figure...|$|E
40|$|In {{this thesis}} {{algorithms}} for checking isomorphism between trees are elaborated. Tree definition is provided, basic concepts of tree traversals are described, details of tree isomorphism algorithms are given, putting special attention {{and focus on}} <b>unordered</b> <b>tree</b> isomorphism, algorithm by Valiente as well as algorithm by Aho, Hopcroft and Ullman. Algorithms have been implemented and compared. Comparison was done upon the times needed {{for each of the}} algorithms to determine the isomorphism between randomly generated trees. Trees were classified in groups depending on the number of vertices and both algorithms were executed over each group of vertices...|$|E
40|$|Several {{classical}} schemes {{exist to}} represent trees as strings over a fixed alphabet; these {{are useful in}} many algorithmic and conceptual studies. Our previous work has proposed a representation of unranked trees as strings over a countable alphabet, and has shown how this representation is useful for canonizing <b>unordered</b> <b>trees</b> and for mining closed frequent trees, whether ordered or unordered. Here we propose a similar, simpler alternative and adapt some basic algorithmics to it; then we show empirical evidence of the usefulness of this representation for mining frequent closed <b>unordered</b> <b>trees</b> on real-life data. ...|$|R
40|$|Recognizable sets of unranked, <b>unordered</b> <b>trees</b> {{have been}} {{introduced}} in Courcelle [C 89] in a Myhill-Nerode [N 58] style of inverse homomorphisms of suitable finite magmas. This is equivalent of being the the union of some congruence classes of a congruence of finite index. We will add to the well-known concept of regular tree grammars a handling of nodes labeled with #. With this rather unconventional - but nevertheless natural - treatment of the "empty node" the class of languages generated by regular trees grammars becomes equivalent to Courcelles class of recognizable sets of unranked, <b>unordered</b> <b>trees...</b>|$|R
40|$|AbstractIn this paper, {{we propose}} the {{alignment}} of trees {{as a measure}} of the similarity between two labeled trees. Both ordered and <b>unordered</b> <b>trees</b> are considered. An algorithm is designed for ordered trees. The time complexity of this algorithm is O(|T 1 |·|T 2 ·(deg(T 1) + deg(T 2)) 2), where |T 1 | is the number of nodes in T 1 and deg(T 1) is the degree of T 1, i = 1. 2. The algorithm is faster than the best known algorithm for tree edit when deg(T 1) and deg(T 2) are smaller than the depths of T 1 and T 2. For <b>unordered</b> <b>trees,</b> we show that the alignment problem can be solved in polynomial time if the trees have a bounded degree and becomes MAX SNP-hard if one of the trees is allowed to have an arbitrary degree. In contrast, the edit problem for <b>unordered</b> <b>trees</b> is MAX SNP-hard even if both trees have a bounded degree (Zhang and Jiang, 1994). Finally, multiple alignment of trees is discussed...|$|R
40|$|This {{research}} {{is a step}} forward in discovering knowledge from databases of complex structure like tree or graph. Several data mining algorithms are developed based on a novel representation called Balanced Optimal Search for extracting implicit, unknown and potentially useful information like patterns, similarities and various relationships from tree data, which are also proved to be advantageous in analysing big data. This thesis focuses on analysing <b>unordered</b> <b>tree</b> data, which is robust to data inconsistency, irregularity and swift information changes, hence, {{in the era of}} big data it becomes a popular and widely used data model...|$|E
40|$|Abstract — In {{this article}} we propose a new hashing {{framework}} for tree-structured data. Our method maps an <b>unordered</b> <b>tree</b> into a multiset of simple wedge-shaped structures refered to as pivots. By coupling our pivot multisets {{with the idea of}} minwise hashing, we realize a fixed sized signature-sketch of the treestructured datum yielding an effective mechanism for hashing such data. We discuss several potential pivot structures and study some of the theoretical properties of such structures, and discuss their implications to tree edit distance and properties related to perfect hashing. We then empirically demonstrate the efficacy and efficiency of the overall approach on a range of real-world datasets and applications. I...|$|E
40|$|Querying {{heterogeneous}} {{collections of}} data-centric XML documents requires {{a combination of}} database languages and concepts used in information retrieval, in particular similarity search and ranking. In this paper we present an approach to find approximate answers to formal user queries. We reduce the problem of answering queries against XML document collections to the well-known <b>unordered</b> <b>tree</b> inclusion problem. We extend this problem to an optimization problem by applying a cost model to the embeddings. Thereby {{we are able to}} determine how close parts of the XML document match a user query. We present an e#cient algorithm that finds all approximate matches and ranks them according to their similarity to the query...|$|E
40|$|Abstract. In this paper, {{we study}} a {{frequent}} substructure discovery problem in semi-structured data. We present an efficient algorithm Unot that computes all frequent labeled <b>unordered</b> <b>trees</b> appearing {{in a large}} collection of data trees with frequency above a user-specified threshold. The keys of the algorithm are efficient enumeration of all <b>unordered</b> <b>trees</b> in canonical form and incremental computation of their occurrences. We then show that Unot discovers each frequent pattern T in O(kb 2 m) per pattern, where k {{is the size of}} T, b is the branching factor of the data trees, and m is the total number of occurrences of T in the data trees. ...|$|R
40|$|AbstractThe tree {{matching}} {{problem is}} considered of given labeled trees P and T, determining if the pattern tree P {{can be obtained}} from the text tree T by deleting degree-one and degree-two nodes and, in the case of <b>unordered</b> <b>trees,</b> by also permuting siblings. The constrained tree inclusion problem is more sensitive to the structure of the pattern tree than the general tree inclusion problem. Further, it can be solved in polynomial time for both <b>unordered</b> and ordered <b>trees.</b> Algorithms based on the restricted subtree homeomorphism algorithm of M. -J. Chung [J. Algorithms 8 (1) (1987) 106 – 112] are presented that solve the constrained tree inclusion problem in O(m 1. 5 n) time on <b>unordered</b> <b>trees</b> with m and n nodes, and in O(mn) time on ordered trees, using O(mn) additional space...|$|R
40|$|Mining {{frequent}} trees is {{very useful}} in domains like bioinformatics, web mining, mining semi-structured data, and so on. In this paper we introduce SLEUTH, an efficient algorithm for mining frequent, unordered, embedded subtrees in {{a database of}} labeled trees. The key contributions of our work are as follows: We give the first algorithm that enumerates all embedded, <b>unordered</b> <b>trees.</b> We propose a new equivalence class extension scheme to generate all candidate trees. We extend the notion of scope-list joins to compute frequency of <b>unordered</b> <b>trees.</b> We conduct performance evaluation on several synthetic and real datasets to show that SLEUTH is an efficient algorithm, which has performance comparable to TreeMiner, that mines only ordered trees...|$|R
40|$|<b>Unordered</b> <b>tree</b> {{is widely}} used for semi-structured data modeling, {{coverage}} pattern mining on it has benefit for finding frequent subtrees without redundant information, so that improve the efficiency of subsequent knowledge discovering. A coverage pattern mining method MCRP is proposed. Firstly, all candidate subtrees are generated {{on the basis of}} maximum prefix coding and edge extension. Then coverage patterns are output by introducing δ′- coverage concept. Compared with traditional algorithms such as mining frequent closed tree patterns and maximal frequent tree patterns, the proposed method can output fewer frequent subtrees in the case of preserving all the frequent subtree information, and has a certain superiority in processing efficiency...|$|E
40|$|Let G be an n-node graph. We {{address the}} problem of {{computing}} a maximum symmetric graph H from G by deleting nodes, deleting edges, and contracting edges. This NP-complete problem arises naturally from the objective of drawing G as symmetrically as possible. We show that its tractability for the special cases of G being a plane graph, an ordered tree, and an <b>unordered</b> <b>tree,</b> depends on the type of operations used to obtain H from G. Moreover, we give an O(log n) -approximation algorithm for the intractable case that H is obtained from a tree G by contracting edges. As a by-product, we give an O(log n) -approximation algorithm for an NP-complete edit-distance problem...|$|E
40|$|Abstract. Previous {{works in}} change {{detection}} on XML focused on de-tecting changes to text file using ordered and <b>unordered</b> <b>tree</b> model. These approaches are {{not suitable for}} detecting changes to large XML document as it {{requires a lot of}} memory to keep the two versions of XML documents in the memory. In this paper, we take a more conservative yet novel approach of using traditional relational database engines for detecting content changes of ordered large XML data. First, we store XML documents in RDBMS. Then, we detect the changes by using a set of SQL queries. Experimental results show that our approach has better scalability, better performance, and comparable result quality compared to the state-of-the-art approaches. ...|$|E
40|$|Abstract Background A bisection-type {{algorithm}} for the grammar-based {{compression of}} tree-structured data {{has been proposed}} recently. In this framework, an elementary ordered-tree grammar (EOTG) and an elementary unordered-tree grammar (EUTG) were defined, and an approximation algorithm was proposed. Results In this paper, we propose an integer programming-based method that finds the minimum context-free grammar (CFG) for a given string {{under the condition that}} at most two symbols appear on the right-hand side of each production rule. Next, we extend this method to find the minimum EOTG and EUTG grammars for given ordered and <b>unordered</b> <b>trees,</b> respectively. Then, we conduct computational experiments for the ordered and <b>unordered</b> artificial <b>trees.</b> Finally, we apply our methods to pattern extraction of glycan tree structures. Conclusions We propose integer programming-based methods that find the minimum CFG, EOTG, and EUTG for given strings, ordered and <b>unordered</b> <b>trees.</b> Our proposed methods for trees are useful for extracting patterns of glycan tree structures. </p...|$|R
40|$|In {{this paper}} we obtain a new {{polynomial}} time algorithm for testing isomorphism of graphs. This algorithm {{is based on the}} idea of associating a rooted, <b>unordered,</b> pseudo <b>tree</b> with given graphs and thus reducing the isomorphism problem for graphs to isomorphism problems for associated rooted, <b>unordered,</b> pseudo <b>trees.</b> We show that isomorphism of the rooted, <b>unordered,</b> pseudo <b>trees</b> associated with graphs and so in effect isomorphism of given two graphs can be tested in polynomial (quadratic) time. 1. Introduction: Th...|$|R
40|$|Extracting {{frequent}} subtrees {{from the}} tree structured data has important applications in Web mining. In this paper, we introduce a novel canonical form for rooted labelled <b>unordered</b> <b>trees</b> called the balanced-optimal-search canonical form (BOCF) that can handle the isomorphism problem efficiently. Using BOCF, we define a tree structure guided scheme based enumeration approach that systematically enumerates only the valid subtrees. Finally, we present the balanced optimal search tree miner (BOSTER) algorithm based on BOCF and the proposed enumeration approach, for finding frequent induced subtrees from a database of labelled rooted <b>unordered</b> <b>trees.</b> Experiments on the real datasets compare the efficiency of BOSTER over the two state-of-the-art algorithms for mining induced unordered subtrees, HybridTreeMiner and UNI 3. The results are encouraging...|$|R
