28|58|Public
5000|$|... {{the type}} of ptr_get0 (T) is ∀ l : addr [...] ( [...] T @ l | ptr( [...] l [...] ) [...] ) -> ( [...] T @ l | T) // see manual, section 7.1. <b>Safe</b> <b>Memory</b> Access through Pointers ...|$|E
5000|$|... xCORE devices can be {{programmed}} using C, C++, xC or native assembler. To help programmers access the real-time hardware features of xCORE devices some multicore language extensions for C have been added. These extensions form {{a programming language}} called xC which contains features for task based parallelism and communication, accurate timing and I/O, and <b>safe</b> <b>memory</b> management.|$|E
50|$|In 1988, {{researchers}} began investigating {{how to use}} regions for <b>safe</b> <b>memory</b> allocation {{by introducing}} the concept of region inference, where the creation and deallocation of regions, {{as well as the}} assignment of individual static allocation expressions to particular regions, is inserted by the compiler at compile-time. The compiler is able to do this {{in such a way that}} it can guarantee dangling pointers and leaks do not occur.|$|E
30|$|Device {{manufacturers}} reuse these specifications {{in their}} own ODDs by simply referencing them via object properties (e.g., ba:deviceManufacturer, ba:deviceTransceiver). This referencing eases the specification process, <b>safes</b> <b>memory,</b> and avoids duplicate specifications and inconsistencies.|$|R
5000|$|Growable regions {{support a}} form of <b>safe</b> manual <b>memory</b> {{management}} ...|$|R
50|$|Memory {{management}} in these portable virtual machines is addressed {{at a higher}} level of abstraction than in physical machines. Some virtual machines, such as the popular Java virtual machines (JVM), are involved with addresses {{in such a way as}} to require <b>safe</b> automatic <b>memory</b> management by allowing the virtual machine to trace pointer references, and disallow machine instructions from manually constructing pointers to memory. Other virtual machines, such as LLVM, are more like traditional physical machines, allowing direct use and manipulation of pointers. Common Intermediate Language (CIL) offers a hybrid in between, allowing both controlled use of memory (like the JVM, which allows <b>safe</b> automatic <b>memory</b> management), while also allowing an 'unsafe' mode that allows direct pointer manipulation in ways that can violate type boundaries and permission.|$|R
50|$|A more {{complicated}} but more effective {{solution is to}} implement <b>safe</b> <b>memory</b> reclamation (SMR). This is in effect lock-free garbage collection. The advantage of using SMR is the assurance a given pointer will exist only once {{at any one time}} in the data structure, thus the ABA problem is completely solved. (Without SMR, something like a freelist will be in use, to ensure that all data elements can be accessed safely (no memory access violations) even when they are no longer present in the data structure. With SMR, only elements actually currently in the data structure will be accessed).|$|E
40|$|This article {{describes}} a <b>safe</b> <b>memory</b> model construction and realization, creation a software component {{for working with}} <b>safe</b> <b>memory</b> in information security system. ??????????????? ?????? ?????????? ? ?????????? ?????? ?????????? ??????, ???????? ??????????? ??????????? ?????? ? ?????????? ??????? ? ???????? ?????? ??????????...|$|E
40|$|We {{extend the}} Faulty RAM model by Finocchi and Italiano (2008) {{by adding a}} <b>safe</b> <b>memory</b> of {{arbitrary}} size S, and we then derive tradeoffs between the performance of resilient algorithmic techniques {{and the size of}} the <b>safe</b> <b>memory.</b> Let δ and α denote, respectively, the maximum amount of faults which can happen during the execution of an algorithm and the actual number of occurred faults, with α≤δ. We propose a resilient algorithm for sorting n entries which requires O(n n+α (δ/S + S)) time and uses Θ(S) <b>safe</b> <b>memory</b> words. Our algorithm outperforms previous resilient sorting algorithms which do not exploit the available <b>safe</b> <b>memory</b> and require O(n n+ αδ) time. Finally, we exploit our sorting algorithm for deriving a resilient priority queue. Our implementation uses Θ(S) <b>safe</b> <b>memory</b> words and Θ(n) faulty memory words for storing n keys, and requires O(n + δ/S) amortized time for each insert and deletemin operation. Our resilient priority queue improves the O(n + δ) amortized time required by the state of the art. Comment: To appear in Theoretical Computer Science, 201...|$|E
40|$|A {{challenge}} for programming language {{research is to}} design and implement multi-threaded low-level languages providing static guarantees for memory safety and freedom from data races. Towards this goal, we present a concurrent language employing <b>safe</b> region-based <b>memory</b> management and hierarchical locking of regions. Both regions and locks are treated uniformly, and the language supports ownership transfer, early deallocation of regions and early release of locks in a safe manner. ...|$|R
50|$|A dataviewtype {{is similar}} to a datatype, but it is linear. With a dataviewtype, the {{programmer}} is allowed to explicitly free (or deallocate) in a <b>safe</b> manner the <b>memory</b> used for storing constructors associated with the dataviewtype.|$|R
6000|$|... "You do {{not know}} those men as I do. They plan all from the {{beginning}} and leave nothing to chance. The Señor Maxwell is a man of system, and he will have <b>safe</b> in his <b>memory</b> all the book could tell him." ...|$|R
40|$|International audienceWe {{present a}} {{so-called}} labelling method to insert cost annotations in a higher-order functional program, to certify their correctness {{with respect to}} a standard compilation chain to assembly code including <b>safe</b> <b>memory</b> management, and to reason on them in a higher-order Hoare logic...|$|E
40|$|We {{present a}} {{so-called}} labelling method to insert cost annotations in a higher-order functional program, to certify their correctness {{with respect to}} a standard compilation chain to assembly code including <b>safe</b> <b>memory</b> management, and to reason on them in a higher-order Hoare logic. Comment: Higher-Order and Symbolic Computation (2013...|$|E
40|$|Abstract. A {{significant}} problem of lock-free concurrent data structures {{in an environment}} without garbage collection is to ensure <b>safe</b> <b>memory</b> reclamation of objects that are removed from the data structure. An elegant {{solution to this problem}} is Michael’s hazard pointers method. The formal verification of concurrent algorithms with hazard pointers is yet challenging. This work presents a mechanized proof of the major correctness and progress aspects of a lock-free stack with hazard pointers. ...|$|E
40|$|Programming {{language}} – 8 {{years of}} R&D by IBM Research {{with support from}} DARPA/HPCS (PERCS) – modern object-oriented language • evolution of Java • strongly typed, <b>memory</b> <b>safe</b> (garbage collected), pre/postconditions, invariants • constructs for concurrency and distribution § � Focus on scale – HPC and Big Data – scalable productivity and performanc...|$|R
40|$|Abstract: We {{describe}} further {{modifications of}} the multigrid solver for 3 D frequency domain Maxwell equations in cylindrical geometry proposed in previous preprint of the Keldysh Inst. Appl. Maths., No. 128, 2005. Here we incorporate an approach of embedded grids and introduce real arithmetic in operations {{with the main}} matrix. Both modifications enhance about 3 - 5 times the capability of the solver (1. 5 x due to real arithmetic and 2 x- 4 x due to embedded grids). Smaller details of geometry can be also resolved now on PC owing to <b>safe</b> of <b>memory.</b> Note: Publication language:englis...|$|R
40|$|The undisciplined use {{of shared}} mutable state {{can be a}} source of program errors when aliases unsafely {{interfere}} with each other. While protocol-based techniques to reason about interference abound, they do not address two practical concerns: the decidability of protocol composition and its integration with protocol abstraction. We show that our composition procedure is decidable and that it ensures safe interference even when composing abstract protocols. To evaluate the expressiveness of our protocol framework for <b>safe</b> shared <b>memory</b> interference, we show how this same protocol framework can be used to model safe, typeful message-passing concurrency idioms...|$|R
40|$|Although several UNIX {{techniques}} for sharing memory exist, such as System V IPC Shared Memory and POSIX Shared Memory, these schemes are {{not suitable for}} use internal to the operating system and cannot protect against all threats posed by memory sharing. Therefore, we propose a novel, flexible memory-protection scheme for UNIX-like systems based on fine-grained, delegatable memory grants. We have already applied our ideas to <b>safe</b> <b>memory</b> copies and are currently investigating extensions for direct memory access (DMA) and memory mapping. Although memory grants originated in the MINIX 3 operating system, they is generally applicable and can be easily ported to other platforms. ...|$|E
40|$|Much {{research}} {{has been devoted to}} studies of and algorithms for memory management based on garbage collection or explicit allocation and deallocation. An alternative approach, region-based memory management, has been known for decades, but has not been well-studied, In a region-based system each allocation specifies a region, and memory is reclaimed by destroying a region, freeing all the storage allocated therein. We show that on a suite of allocation-intensive C programs, regions are competitive with malloc/free and sometimes substantially faster. We also show that regions support <b>safe</b> <b>memory</b> management with low overhead. Ex-perience with our benchmarks suggests that modifying many existing programs to use regions is not difficult...|$|E
40|$|Abstract. We {{develop the}} first dynamic data {{structures}} that tolerate δ memory faults, lose no data, and incur only an Õ(δ) additive overhead in overall {{space and time}} per operation. We obtain such data structures for arrays, linked lists, binary search trees, interval trees, predecessor search, and suffix trees. Like previous data structures, δ must be known in advance, but we show how to restore pristine state in linear time, in parallel with queries, making δ just a bound on the rate of memory faults. Our data structures require Θ(δ) words of <b>safe</b> <b>memory</b> during an operation, {{which may not be}} theoretically necessary but seems a practical assumption. ...|$|E
40|$|We {{report in}} this paper how we proved memory safety of a complex Windows image parser written in {{low-level}} C in only three months of work and using only three core tech-niques, namely (1) symbolic execution at the x 86 binary level, (2) exhaustive program path enumeration and testing, and (3) user-guided program decomposition and summariza-tion. We also used a new tool, named MicroX, for executing code fragments in isolation using a custom virtual machine designed for testing purposes. As {{a result of this}} work, we are able to prove, for the first time, that a Windows image parser is <b>memory</b> <b>safe,</b> i. e., free of any buffer-overflow secu-rity vulnerabilities, modulo the soundness of our tools and several additional assumptions regarding bounding input-dependent loops, fixing a few buffer-overflow bugs, and ex-cluding some code parts that are not <b>memory</b> <b>safe</b> by design. In the process, we also discovered and fixed several limita-tions in our tools, and narrowed the gap between systematic testing and verification. 1...|$|R
5000|$|In computing, Redox is a Unix-like {{microkernel}} {{operating system}} {{written in the}} programming language Rust, a language with focus on safety and high performance. Redox aims to be secure, usable, and free. Redox is inspired by previous kernels and operating systems, such as SeL4, Minix, Plan 9, and BSD. It {{is similar to the}} GNU or BSD ecosystem, but in a <b>memory</b> <b>safe</b> language and with modern technology. [...] It runs on extant hardware. It is free and open-source software distributed under an MIT License.|$|R
40|$|Safe is a first-order eager {{functional}} language with facilities for programmer-controlled destruction and copying of data structures and {{is intended for}} compile-time analysis of <b>memory</b> consumption. In <b>Safe,</b> heap <b>memory</b> consumption depends {{on the length of}} recursive calls chains. Ensuring termination of Safe programs (or of particular function calls) is therefore essential to implement these features. Furthermore, being able to giving bounds to the chain length required by such terminating calls becomes essential in computing space bounds. In this paper, we investigate how to analyze termination of Safe programs by using standard term rewriting techniques, i. e., by transforming Safe programs into term rewriting systems whose termination can be automatically analyzed by means of existing tools. Furthermore, we investigate how to use proofs of termination which combine the dependency pairs approach together with polynomial interpretations to obtain suitable bounds to the length of chains of recursive calls in Safe programs...|$|R
40|$|The current {{trend to}} use {{partitioned}} architectures in on-board spacecraft software requires applications {{running on the}} same computer platform to be isolated from each other both in the temporal and memory domains. Memory isolation techniques currently used in Integrated Modular Avionics for Aeronautics usually require a Memory Management Unit (MMU), which is not commonly available {{in the kind of}} processors currently used in the Space domain. Two alternative approaches are discussed in the paper, based on some features of Ada and state-of-the art compilation tool-chains. Both approaches provide <b>safe</b> <b>memory</b> partitioning with less overhead than current IMA techniques. Some footprint and performance metrics taken on a prototype implementation of the most flexible approach are included...|$|E
40|$|We {{develop the}} first dynamic data {{structures}} that tolerate δ memory faults, lose no data, and incur only an O(δ) additive overhead in overall {{space and time}} per operation. We obtain such data structures for arrays, linked lists, binary search trees, interval trees, predecessor search, and suffix trees. Like previous data structures, δ must be known in advance, but we show how to restore pristine state in linear time, in parallel with queries, making δ just a bound on the rate of memory faults. Our data structures require Θ(δ) words of <b>safe</b> <b>memory</b> during an operation, {{which may not be}} theoretically necessary but seems a practical assumption. 12 th International Symposium, WADS 2011, New York, NY, USA, August 15 - 17, 2011. ProceedingsCenter for Massive Data Algorithmics (MADALGO...|$|E
40|$|Titanium is an {{explicitly}} parallel dialect of Java TM {{designed for}} high-performance scientific programming. It offers object-orientation, strong typing, and <b>safe</b> <b>memory</b> {{management in the}} context of a language that supports high performance and scalable parallelism. We present an overview of the language features and demonstrate their use {{in the context of}} the NAS Parallel Benchmarks, a benchmark suite of common scientific kernels. We argue that parallel languages like Titanium provide greater expressive power than conventional approaches, thereby enabling more concise and expressive code and minimizing time to solution. Moreover, the Titanium implementations of three of the NAS Parallel Benchmarks can match or even exceed the performance of the standard Fortran/MPI implementations at realistic problem sizes and processor scales, while still using far cleaner, shorter and more maintainable code...|$|E
40|$|Long-term {{memories}} turn labile with reactivation and {{undergo a}} re-stabilization process, termed reconsolidation, involving molecular changes that allow updating {{of an existing}} memory trace. Such molecular changes may involve the activation of kinases and expression of proteins related to the increase of synaptic plasticity and memory formation. A kinase reported to {{have a role in}} a variety of memory tasks is the extracellular signal-regulated kinase 1 / 2 (ERK 1 / 2). The downstream activation of ERK targets other regulatory enzymes, transcription factors and cytoskeletal proteins, which allow structural changes in the neuron due to protein synthesis up-regulation. Among the proteins up-regulated by ERK activity is the activity-regulated cytoskeleton-associated protein (ARC), an immediate early gene related to synaptic plasticity. The phase-dependent roles of ERK and ARC have not been examined as part of the molecular mechanisms triggered after a learning experience. In this study I used conditioned taste aversion (CTA) as the learning paradigm and investigated the expression of pERK and ARC in brain regions critical for taste information processing such as the insular cortex and the amygdala. A differential pattern of protein expression was observed in the insular cortex (IC) two hours after taste memory acquisition: pERK activity increased in the aversively conditioned group while ARC increased in the group that received only the novel taste. The central amygdala (CeA) showed a significant increase in pERK, but not ARC activity after CTA training. Immunoblotting experiments performed after memory retrieval in the appetitive group show that pERK continues to signal aversive taste to the IC with ARC exhibiting heightened expression an hour later. An increase in ARC expression 30 minutes after reactivation of the aversive taste was seen in the basolateral amygdala and the CeA exhibited a similar increase at 60 and 90 minutes. Local infusion of ARC antisense oligonucleotides within the IC interfered with the consolidation of <b>safe</b> taste <b>memories,</b> but not with their acquisition. Trace update experiments showed that ARC influences the memory switch from aversive to safe, but not the reverse. Our results indicate that ARC plays a critical role in consolidation and updating of <b>safe</b> taste <b>memories,</b> and the ARC signaling could possibly elicit ERK activation...|$|R
60|$|From Egypt we {{pass into}} rooms {{containing}} vases and other articles of Grecian and Roman workmanship, and funeral urns, and beads, and rings, {{none of them}} very beautiful. I saw some splendid specimens, however, at a former visit, when I obtained admission to a room not indiscriminately shown to visitors. What chiefly interested me in that room was a cast taken {{from the face of}} Cromwell after death; representing a wide-mouthed, long-chinned, uncomely visage, with a triangular English nose in the very centre. There were various other curiosities, which I fancied were <b>safe</b> in my <b>memory,</b> but they do not now come uppermost.|$|R
40|$|Concurrency and {{distribution}} pose algorithmic and implementation challenges in developing reliable distributed systems, making the field an excellent testbed for evaluating programming language and verification paradigms. Several specialized domain-specific languages and extensions of memory-unsafe languages were proposed to aid distributed system development. We present {{an alternative to}} these approaches, showing that modern, higher-order, strongly typed, <b>memory</b> <b>safe</b> languages provide an excellent vehicle for developing and debugging distributed systems. We present Opis, a functional-reactive approach for developing distributed systems in Objective Caml. An Opis protocol description consists of a reactive function (called event function) describing {{the behavior of a}} distributed syste...|$|R
40|$|Applying {{imperative}} programming {{techniques to}} process event streams, like those generated by multi-touch devices and 3 D cameras, has significant engineering drawbacks. Declarative approaches {{solve these problems}} but {{have not been able}} to scale on multicore systems while providing guaranteed response times. We propose PARTE, a parallel scalable complex event processing engine which allows a declarative definition of event patterns and provides soft real-time guarantees for their recognition. It extends the state-saving Rete algorithm and maps the event matching onto a graph of actor nodes. Using a tiered event matching model, PARTE provides upper bounds on the detection latency. Based on the domainspecific constraints, PARTE’s design relies on a combination of 1) lock-free data structures; 2) <b>safe</b> <b>memory</b> management techniques; and 3) message passing between Rete nodes. In our benchmarks, we measured scalability up to 8 cores, outperforming highly optimized sequential implementations...|$|E
40|$|Although the slicing of {{programs}} {{written in a}} high-level language has been widely studied in the literature, very little work has been published on the slicing of binary executable programs. The lack of existing solutions is really hard to understand since the application domain for slicing binaries {{is similar to that}} for slicing high-level languages. In this paper we present a method for the interprocedural static slicing of binary executables. We applied our slicing method to real size binaries and achieved an interprocedural slice size of between 56 %- 68 %. We used conservative approaches to handle unresolved function calls and branching instructions. Our current implementation contains an imprecise (but <b>safe)</b> <b>memory</b> dependence model as well. However, this conservative slicing method might still be useful in analysing large binary programs. In the paper we suggest some improvements to eliminate useless edges from dependence graphs as well. 1...|$|E
40|$|Despite their advantages, lock-free {{algorithms}} {{are often}} not adopted in practice, {{partly due to the}} perception that they perform poorly relative to lock-based alternatives in common situations when there is little contention for objects or the CPUs. We show that memory reclamation can be a dominant performance cost for lock-free algorithms; therefore, choosing the most efficient memory reclamation method is essential to having lock-free algorithms perform well. We compare the costs of three memory reclamation strategies: quiescent-state-based reclamation, epoch-based reclamation, and <b>safe</b> <b>memory</b> reclamation. Our experiments show that changing the workload or execution environment can change which of these schemes is the most efficient. We therefore demonstrate that there is, to date, no panacea for memory reclamation for lock-free algorithms. Using a common reclamation scheme, we fairly compare lock-free and concurrently-readable hash tables. Our evaluation shows that programmers can choose memory recla-mation schemes mostly independently of the target algorithm. i...|$|E
40|$|Higher {{transistor}} counts, lower voltage levels, {{and reduced}} noise margin increase the susceptibility of multicore processors to transient faults. Redundant hardware modules can detect such errors, but software transient fault detection techniques are more appealing for their low cost and flexibility. Recent software proposals double register pressure or memory usage, or are too slow {{in the absence}} of hardware extensions, preventing widespread acceptance. This paper presents DAFT, a fast, <b>safe,</b> and <b>memory</b> efficient transient fault detection framework for commodity multicore systems. DAFT replicates computation across multiple cores and schedules fault detection off the critical path. Where possible, values are speculated to be correct and only communicated to the redundant thread at essential program points. DAFT is implemented in the LLVM compiler framework and evaluated using SPEC CPU 2000 and SPEC CPU 2006 benchmarks on a commodity multicore system. Results demonstrate DAFT’s high performance and broad fault coverage. Speculation allows DAFT to reduce the performance overhead of software redundant multithreading from an average of 200 % to 38 % with no degradation of fault coverage...|$|R
40|$|Human {{research}} {{points to}} {{the relevance of the}} hippocampus for episodic memory, i. e. the ability to remember unique events that took place at a particular time and place (Tulving, 2002). The study of the hippocampal involvement in animal models of episodic memory faces several pitfalls (Eichenbaum and Fortin, 2003). As an alternative animal model, episodic-like taste memories may be studied using taste recognition memory tasks (Bermúdez-Rattoni, 2004). As it is required for an animal model of episodic memory, taste memories are bound to the context in which learning occurred. This has been shown both for safe and aversive taste memories. On one hand, the contextual dependency of latent inhibition (LI), i. e. the fact that previous taste exposure without consequences interferes with later learning (Lubow, 1989), indicates that the <b>safe</b> taste <b>memory</b> includes contextual cues. A context change between preexposure and conditioning disrupts LI (Hall and Channell, 1986). On the other hand, retrieval of an aversive taste memory may be context-dependent (Bonardi et al., 1990; Loy et al., 1993), mainly when the taste was previously exposed without consequence...|$|R
50|$|SafeD is {{the name}} given to the subset of D that can be {{guaranteed}} to be <b>memory</b> <b>safe</b> (no writes to memory that were not allocated or {{that have already been}} recycled). Functions marked @safe are checked at compile time to ensure that they do not use any features that could result in corruption of memory, such as pointer arithmetic and unchecked casts, and any other functions called must also be marked as @safe or @trusted. Functions can be marked @trusted for the cases where the compiler cannot distinguish between safe use of a feature that is disabled in SafeD and a potential case of memory corruption.|$|R
