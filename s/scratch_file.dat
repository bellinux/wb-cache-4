5|18|Public
5000|$|But here, command2 {{does not}} start {{executing}} until command1 has finished, and a sufficiently large <b>scratch</b> <b>file</b> {{is required to}} hold the intermediate results as well as whatever work space each task required. As an example, although DOS allows the [...] "pipe" [...] syntax, it employs this second approach. Thus, suppose some long-running program [...] "Worker" [...] produces various messages as it works, and that a second program, TimeStamp copies each record from stdin to stdout, prefixed by the system's date and time when the record is received. A sequence such as Worker | TimeStamp > LogFile.txtWould produce timestamps only when Worker had finished, merely showing how swiftly its output file could be read and written.|$|E
40|$|The package {{processes}} up to 3 o analyses in a {{set with}} up to 14 elements in an analysis, and these elements can be analysed by up to three different characteristic radiations (Ka, L % and Ms); these parameters may be changed if the user wishes. To process data from another probe, one card needs be changed in the program. The form of input is illustrated infig. I. The program defines each request for information by an RQ number, which refers to more detailed notes in the specification fthe program. In this example measured concentrations from one analysis are input by the operator at the terminal. The method of calculation selected causes oxygen {{to be determined by}} difference. The five elements analysed, Mg, Si, Fe, Mn, and Ca, all determined by their K-radiations (code 1), have been measured with standards named OLIVIN, for both Si and Mg, PUREFE, PUREMN and WOLL 2 respectively. The first part of MK 7 organizes and then writes this information on to a <b>scratch</b> <b>file.</b> A second identifies the elements and lines used and extracts from another file all the physical constants (e. g. absorption coefficients, line energies, atomic weights, etc.) needed to make corrections with those elements present. The standard names are also recognized and the standard factors extracted. All these data are written on to a second <b>scratch</b> <b>file.</b> Finally the third part of the program reads the data from these scratch flies and processes the measured concentrations. Results are output via the terminal in an abbreviated form an...|$|E
30|$|In {{this section}} we examine {{detailed}} performance {{figures for the}} in situ and in-transit workflows described above. All of these tests were performed on Edison, a Cray XC 30 supercomputing system, at the National Energy Research Scientific Computing Center (NERSC). Edison’s compute partition consists of 5, 576 nodes, each configured with two 12 -core Intel Xeon ‘Ivy Bridge’ processors at 2.4 GHz, and 64 GB of DDR 3 memory at 1, 866 MHz. Compute nodes communicate using a Cray Aries interconnect which has ‘dragonfly’ topology. The high-performance <b>scratch</b> <b>file</b> system is powered by Lustre, and has a total capacity of 2.1 PB (1.87 PiB) and a peak bandwidth of 48 GB/s (44.7  GiB/s), distributed across 96 object storage targets (OSTs).|$|E
40|$|Abstract. In {{wide area}} Grid {{computing}} environments, computation is often performed {{at a site}} distant from data needed and from the user console. Therefore, it necessitates I/O support to run computation jobs at remote sites. Major Grid software providers have implemented their own I/O solutions. However, in existing solutions, two important user requirements for I/O support are not satisfied, namely, run-time standard input from user console and runtime stage-out of <b>scratched</b> <b>files</b> during computation. Regarding these deficiencies, the paper puts forward an improved I/O support solution. In addition, the paper presents a reference implementations and describes application experience of our implementation in PCG(PACT Computational Grid) project. Keywords: I/O, Grid computing, standard input, <b>scratched</b> <b>files,</b> Globus...|$|R
40|$|Super{{computer}} (n) : A computer {{which turns}} a CPU-bound problem into an I/O bound problem. • As high performance computers become {{faster and more}} parallel, I/O can often become the bottleneck for large computations: – Checkpoint/restart files – Plot <b>files</b> – <b>Scratch</b> <b>files</b> for out-of-core computations • The explosive growth of storage capacity has made things even more interesting: – Data sets in the 10 s to 1000 s of gigabytes – Millions of files (a. k. a. “Backup software’s worst nightmare”) – Not all applications lend themselves well to simple read/write access I/O Approaches for Data...|$|R
50|$|New {{features}} in Encore 5 include wizards to create scores (transposing {{as well as}} in concert pitch) for numerous types of ensembles from <b>scratch,</b> MusicXML <b>file</b> format support, the Gvox VST player, which enables use of virtual studio instruments with Encore, and J.S. Bach complete works for keyboard in Encore format.|$|R
40|$|Abstract—Modern {{petascale}} applications {{can present}} {{a variety of}} configuration, runtime, and data management challenges when run at scale. In this paper, we describe our experiences in running VPIC, a large-scale plasma physics simulation, on the NERSC production Cray XE 6 system Hopper. The simulation ran on 120, 000 cores using ∼ 80 % of computing resources, 90 % of the available memory on each node and 50 % of the Lustre <b>scratch</b> <b>file</b> system. Over two trillion particles were simulated for 23, 000 timesteps, and 10 one-trillion particle dumps, each ranging between 30 and 42 TB, were written to HDF 5 files at a sustained rate of ∼ 27 GB/s. To {{the best of our}} knowledge, this job represents the largest I/O undertaken by a NERSC application and the largest collective writes to single HDF 5 files. We outline several obstacles that we overcame in the process of completing this run, and list lessons learned that are of potential interest to HPC practitioners. I...|$|E
40|$|NPLOT is an {{interactive}} computer graphics program for plotting undeformed and deformed NASTRAN finite element models (FEMs). Although there are many commercial codes already available for plotting FEMs, these have limited use due to their cost, speed, and lack of features to view BAR elements. NPLOT was specifically developed to overcome these limitations. On a vector type graphics device the two best ways to show depth are by hidden line plotting or haloed line plotting. A hidden line algorithm generates views of models with all hidden lines removed, and a haloed line algorithm displays views with aft lines broken {{in order to show}} depth while keeping the entire model visible. A haloed line algorithm is especially useful for plotting models composed of many line elements and few surface elements. The most important feature of NPLOT is its ability to create both hidden line and haloed line views accurately and much more quickly than with any other existing hidden or haloed line algorithms. NPLOT is also capable of plotting a normal wire frame view to display all lines of a model. NPLOT is able to aid in viewing all elements, but it has special features not generally available for plotting BAR elements. These features include plotting of TRUE LENGTH and NORMALIZED offset vectors and orientation vectors. Standard display operations such as rotation and perspective are possible, but different view planes such as X-Y, Y-Z, and X-Z may also be selected. Another display option is the Z-axis cut which allows a portion of the fore part of the model to be cut away to reveal details of the inside of the model. A zoom function is available to terminals with a locator (graphics cursor, joystick, etc.). The user interface of NPLOT is designed to make the program quick and easy to use. A combination of menus and commands with help menus for detailed information about each command allows experienced users greater speed and efficiency. Once a plot is on the screen the interface becomes command driven, enabling the user to manipulate the display or execute a command without having to return to the menu. NPLOT is also able to plot deformed shapes allowing it to perform post-processing. The program can read displacements, either static displacements or eigenvectors, from a MSC/NASTRAN F 06 file or a UAI/NASTRAN PRT file. The displacements are written into a unformatted <b>scratch</b> <b>file</b> where they are available for rapid access when the user wishes to display a deformed shape. All subcases or mode shapes can be read in at once. Then it is easy to enable the deformed shape, to change subcases or mode shapes and to change the scale factor for subsequent plots. NPLOT is written in VAX FORTRAN for DEC VAX series computers running VMS. As distributed, the NPLOT source code makes calls to the DI 3000 graphics package from Precision Visuals; however, a set of interface routines is provided to translate the DI 3000 calls into Tektronix PLOT 10 /TCS graphics library calls so that NPLOT can use the standard Tektronix 4010 which many PC terminal emulation software programs support. NPLOT is available in VAX BACKUP format on a 9 -track 1600 BPI DEC VAX BACKUP format magnetic tape (standard media) or a TK 50 tape cartridge. This program was developed in 1991. DEC, VAX, VMS, and TK 50 are trademarks of Digital Equipment Corporation. Tektronix, PLOT 10, and TCS are trademarks of Tektronix, Inc. DI 3000 is a registered trademark of Precision Visuals, Inc. NASTRAN is a registered trademark of the National Aeronautics and Space Administration. MSC/ is a trademark of MacNeal-Schwendler Corporation. UAI is a trademark of Universal Analytics, Inc...|$|E
40|$|Automatic {{mapping of}} I/O {{intensive}} applications on massively parallel systems is a challenging problem of great importance. This paper proposes a novel {{solution to the}} I/O problem. First, Fortran language extensions are introduced that support highly efficient I/O processing. Second, we specify the appropriate compilation method that utilizes an advanced runtime system called VIPIOS that is designed {{on the basis of}} parallel database technology. We present this proposal in the context of Vienna Fortran and its compiler. 1 Introduction This paper proposes a language, compiler and runtime software {{solution to the problem of}} I/O in distributed-memorysystems (DMSs). We present this proposal in the context of Vienna Fortran [8], and its compilation system. In typical supercomputing applications six types of I/O can be identified ([5]) : (1) input, (2) debugging, (3) <b>scratch</b> <b>files,</b> (4) checkpoint/restart, (5) output, and (6) accessing out-of-core structures. Types (3), (4) and in some phases [...] ...|$|R
40|$|In March 2004, the Nsort# {{program was}} able to sort 34 GB of data (340, 000, 000 100 -byte records) in 58 seconds on a 32 {{processor}} Itanium 2 NEC Express 5800 / 1320 Xd running Microsoft Windows Server 2003 Datacenter Edition. This set new records for the MinuteSort benchmark. The data was read from one input file at 1. 4 GB/sec. The output file was created and written at 1. 2 GB/sec. Both files resided on an NTFS file system on a striped logical volume consisting of 8 Eurologic 14 -disc SAN blocs attached by 8 Qlogic 2350 SAN HBAs. The 34 GB data set was read into main memory, sorted, and written to the output file. No temporary (or <b>scratch)</b> <b>files</b> were used. In April 2004 on the same NEC server, Nsort {{was able to}} sort a 1 TB file in 33 minutes using 21 Qlogic HBAs and 41 Eurologic SAN blocs. This set a new record in the TeraByte Sort benchmark...|$|R
50|$|The program {{includes}} {{a set of}} tutorial videos by John Derry. These teach the viewer various techniques from automatically creating a painting from a photo, to introducing some touch-up by hand, to creating a cartoon, drawing or painting from <b>scratch.</b> Sample <b>files</b> are provided to allow one to follow along while watching the videos. The accompanying manual provides the same tutorials in written form, plus reference material and an art tips section.|$|R
50|$|At startup, {{programs}} {{expect to}} find <b>scratch</b> space, configuration <b>files,</b> device nodes and shared libraries at certain preset locations. For a chrooted program to successfully start, the chroot directory must be populated with a minimum set of these files. This can make chroot difficult {{to use as a}} general sandboxing mechanism.|$|R
50|$|In April 2011, TACC {{announced}} another upgrade of the Lonestar cluster. The $12 million Lonestar 4 cluster replaced {{its predecessor}} with 1,888 Dell M610 PowerEdge blade servers, each with two six-core Intel Xeon 5600 processors (22,656 total cores). The system storage includes a 1000TB parallel (<b>SCRATCH)</b> Lustre <b>file</b> system, and 276TB of local compute-node disk space (146GB/node). Lonestar also {{provides access to}} five large memory (1TB) nodes, and eight nodes containing two NVIDIA GPU's, giving users access to high-throughput computing and remote visualization capabilities respectively.Lonestar 4 entered the Top500 list in June 2011 as the 28th fastest supercomputer, with 301.8 TFlops peak.|$|R
40|$|Poet. Alternative identification: Carpenter (cat. 5). Identification from {{engraving}} in LC P&P Biographical <b>File.</b> <b>Scratched</b> on face of plate: 238; Miss Cary. Scratched on back of plate: 287. Original {{served by}} appointment only. Produced by Mathew Brady's studio. Transfer; U. S. War College; 1920; (DLC/PP- 1920 : 46153). Forms part of: Daguerreotype collection (Library of Congress) ...|$|R
5000|$|Scratch {{space is}} {{space on the}} hard disk drive that is {{dedicated}} for only temporary storage. It cannot be used to permanently back up <b>files.</b> <b>Scratch</b> disks can be set to erase all data at regular intervals so that the disk space is left free for future use. The management of scratch disk space is typically dynamic, occurring when needed.|$|R
25|$|Several {{additional}} utilities {{were published}} in the May 1987 issue of Compute!'s Gazette along with SpeedScript 3.2. ScriptRead was developed to identify and preview SpeedScript documents on a disk, with the ability to <b>scratch</b> any <b>files</b> no longer needed. This was an important addition as on a single-drive system there would be no way to save work if the disk became full. SpeedSearch provided full-text search of all SpeedScript documents on a disk, returning a count of how many times the searched word or phrase was used in each document. Date and Time Stamper introduces a program to the disk drive that adds time stamps to files on disk, then executes SpeedScript.|$|R
50|$|Scratch stocks {{consist of}} a handle, either wood or metal, with {{provision}} to clamp a steel blade into which {{the profile of the}} shape to be cut has been <b>filed.</b> <b>Scratch</b> stocks work best in wood which has a dense grain. They work by using a scraping action which gradually cuts away fibers from the wood. The scratch stock is drawn along the wood repeatedly until the desired shape is formed. Scratch stocks may be used to apply edge treatments and may also be used to apply decorative elements to the face of board.|$|R
5000|$|The use of frit in this paste lent it {{the names}} [...] "Frittenporzellan" [...] in Germany and [...] "frita" [...] in Spain. In France {{it was known}} as [...] "pâte tendre" [...] and in England [...] "soft-paste", perhaps {{because it does not}} easily retain its shape in the wet state, or because it tends to slump in the kiln under high temperature, or because the body and the glaze can be easily scratched. (<b>Scratching</b> with a <b>file</b> is a crude way of finding out whether a piece is made of soft-paste or not.) ...|$|R
40|$|Abstract- In the LANL’s PaScalBB network I/O nodes carry {{data traffic}} between backend compute nodes and global <b>scratch</b> based <b>file</b> systems. An I/O node is {{normally}} equipped with one Infiniband Nic for backend traffic {{and one or}} more 10 -Gigabit Ethernet Nics for parallel file system data traffic. With the growing deployment of multiple, multi-core processors in server and storage systems, overall platform efficiency and CPU and memory utilization depends increasingly on interconnect bandwidth and latency. PCI-Express (PCIe) generation 2. 0 has recently become available and has doubled the transfer rates available. This additional I/O bandwidth balances the system and makes higher data rates for external interconnects such as Infiniband feasible. As a result, Infiniband Quad-Data Rate (QDR) mode has become available on the Infiniband Host Channel Adapter (HCA) with a 40 Gb/sec signaling rate. Combining HCA QDR data rates with multiple 10 -Gigabit Ethernet links and using it in an IO node has created the potential to solve some of the I/O traffic bottlenecks that currently exist. We have setup a small-scale PaScalBB testbed and conduct a sequence of I/O node performance tests. The goal of this I/O node performance testing {{is to figure out}} an enhanced network configuration that we can apply to the LANL’s Cielo machine and future LANL HPC machines using PaScalBB architecture...|$|R
40|$|Figure 1 : Screenshots {{from our}} {{real-time}} editor for grammar-based procedural architecture. Left: Visual editing of grammar rules. Middle left: Direct dragging {{of the red}} ground-plan vertex and modifying the height with a slider creates the building on the middle right. While dragging, the building is updated instantly. Right: Editing is possible at multiple levels, here the high-level shell of a building is modified. We introduce a real-time interactive visual editing paradigm for shape grammars, allowing the creation of rulebases from <b>scratch</b> without text <b>file</b> editing. In previous work, shape-grammar based procedural techniques were successfully applied {{to the creation of}} architectural models. However, those methods are text based, and may therefore be difficult to use for artists with little computer science background. Therefore the goal was to enable a visual workflow combining the power of shape grammars with traditional modeling techniques. We extend previous shape grammar approaches by providing direct and persistent local control over the generated instances, avoiding the combinatorial explosion of grammar rule...|$|R
40|$|Finite Element Simulations with ANSYS Workbench 17 is a {{comprehensive}} and easy to understand workbook. Printed in full color, it utilizes rich graphics and step-by-step instructions to guide you through learning how to perform finite element simulations using ANSYS Workbench. Twenty seven real world case studies are used throughout the book. Many of these case studies are industrial or research projects that you build from <b>scratch.</b> Prebuilt project <b>files</b> are available for download should you run into any problems. Companion videos, that demonstrate exactly how to perform each tutorial, are also available. Relevant background knowledge is reviewed whenever necessary. To be efficient, the review is conceptual rather than mathematical. Key concepts are inserted whenever appropriate and summarized {{at the end of}} each chapter. Additional exercises or extension research problems are provided as homework {{at the end of each}} chapter. A learning approach emphasizing hands-on experiences spreads though this entire book. A typical chapter consists of 6 sections. The first two provide two step-by-step examples. The third section tries to complement the exercises by providing a more systematic view of the chapter subject. The following two sections provide more exercises. The final section provides review problems...|$|R
5000|$|AMD's early design like K6 do {{not have}} a {{register}} file like Intel and do not support [...] "Shadow Register File Architecture" [...] as its lack of context switch and bypass inverter that necessary require for register file to function appropriately. Instead they use a separate GPRS that directly links to a rename register table for its OoOE CPU with a dedicated integer decoder and floating decoder. The mechanism is similar to Intel's pre-Pentium processor line. For example, the K6 processor has four int (one eight-entries temporary <b>scratched</b> register <b>file</b> + one eight-entries future register file + one eight-entries fetched register file + an eight-entries unnamed register file) and two FP rename register files (two eight-entries x87 ST file one goes fadd and one goes fmov) that directly link with its x86 EAX for integer renaming and XMM0 register for floating point renaming, but later Athlon included [...] "shadow register" [...] in its front end, it's scaled up to 40 entries unified register file for in order integer operation before decoded, the register file contain 8 entries scratch register + 16 future GPRs register file + 16 unnamed GPRs register file. In later AMD designs it abandons the shadow register design and favored to K6 architecture with individual GPRs direct link design. Like Phenom, it has three int register files and two SSE register files that are located in the physical register file directly linked with GPRs. However, it scales down to one integer + one floating-point on Bulldozer. Like early AMD designs, most of the x86 manufacturers like Cyrix, VIA, DM&P, and SIS used the same mechanism as well, resulting in a lack of integer performance without register renaming for their in-order CPU. Companies like Cyrix and AMD had to increase cache size in hope to reduce the bottleneck. AMD's SSE integer operation work in a different way than Core 2 and Pentium 4; it uses its separate renaming integer register to load the value directly before the decode stage. Though theoretically it will only need a shorter pipeline than Intel's SSE implementation, but generally the cost of branch prediction are much greater and higher missing rate than Intel, and it would have to take at least two cycles for its SSE instruction to be executed regardless of instruction wide, as early AMDs implementations could not execute both FP and Int in an SSE instruction set like Intel's implementation did.|$|R

