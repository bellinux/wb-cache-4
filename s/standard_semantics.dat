327|461|Public
25|$|The {{semantics}} of second-order logic {{establish the}} meaning of each sentence. Unlike first-order logic, which has only one <b>standard</b> <b>semantics,</b> {{there are two different}} semantics that are commonly used for second-order logic: <b>standard</b> <b>semantics</b> and Henkin semantics. In each of these semantics, the interpretations of the first-order quantifiers and the logical connectives are the same as in first-order logic. Only the ranges of quantifiers over second-order variables differ in the two types of semantics (Väänänen 2001).|$|E
25|$|This {{corollary}} {{is sometimes}} expressed {{by saying that}} second-order logic does not admit a complete proof theory. In this respect second-order logic with <b>standard</b> <b>semantics</b> differs from first-order logic; Quine (1970, pp.9091) pointed {{to the lack of}} a complete proof system as a reason for thinking of second-order logic as not logic, properly speaking.|$|E
25|$|In <b>standard</b> <b>semantics,</b> {{also called}} full semantics, the quantifiers range over all sets or {{functions}} of the appropriate sort. Thus once {{the domain of the}} first-order variables is established, the meaning of the remaining quantifiers is fixed. It is these semantics that give second-order logic its expressive power, and they will be assumed for the remainder of this article.|$|E
50|$|The <b>standard</b> real-valued <b>semantics</b> {{determined}} by the Łukasiewicz t-norm {{is not the only}} possible semantics of Łukasiewicz logic. General algebraic semantics of propositional infinite-valued Łukasiewicz logic is formed by the class of all MV-algebras. The <b>standard</b> real-valued <b>semantics</b> is a special MV-algebra, called the standard MV-algebra.|$|R
40|$|AbstractWe {{address the}} problem of {{handling}} names in concurrent and distributed systems made up of mobile processes. We equip processes with local environments. Our structural operational semantics handles these environments so that captures of names are never possible. Our semantics includes the specification of a distributed name manager that conservatively extends <b>standard</b> operational <b>semantics.</b> Bisimulation-based equivalences can be checked on our transition systems. They yield the same equivalence relations as those based on <b>standard</b> interleaving <b>semantics.</b> Finally, we show that our development scales up smoothly to higher-order calculi...|$|R
5000|$|A simple {{numerical}} example is [...] with operations [...] and [...] In mathematical fuzzy logic, this MV-algebra {{is called the}} standard MV-algebra, as it forms the <b>standard</b> real-valued <b>semantics</b> of Łukasiewicz logic.|$|R
25|$|A {{deductive}} {{system for}} a logic {{is a set of}} inference rules and logical axioms that determine which sequences of formulas constitute valid proofs. Several deductive systems can be used for second-order logic, although none can be complete for the <b>standard</b> <b>semantics</b> (see below). Each of these systems is sound, which means any sentence they can be used to prove is logically valid in the appropriate semantics.|$|E
25|$|Alternatively, one may {{restrict}} or forbid {{the use of}} some of {{the structural}} rules. This yields a variety of substructural logic systems. They are generally weaker than LK (i.e., they have fewer theorems), and thus not complete with respect to the <b>standard</b> <b>semantics</b> of first-order logic. However, they have other interesting properties that have led to applications in theoretical computer science and artificial intelligence.|$|E
25|$|There {{are more}} extreme {{examples}} showing that second-order logic with <b>standard</b> <b>semantics</b> is more expressive than first-order logic. There is a finite second-order theory whose only {{model is the}} real numbers if the continuum hypothesis holds and which has no model if the continuum hypothesis does not hold (cf. Shapiro 2000, p.105). This theory consists of a finite theory characterizing the real numbers as a complete Archimedean ordered field plus an axiom saying that the domain is of the first uncountable cardinality. This example illustrates {{that the question of}} whether a sentence in second-order logic is consistent is extremely subtle.|$|E
40|$|Previous work formalized the C++ memory {{model in}} Isabelle/HOL {{in an effort}} to clarify the {{proposed}} <b>standard’s</b> <b>semantics.</b> Here we employ the model finder Nitpick to check litmus test programs that exercise the memory model, including a simple locking algorithm. Nitpick is built on Kodkod (Alloy’s backend) but understands Isabelle’s richer logic; hence it can be applied directly to the C++ memory model. We only need to give it a few hints, and thanks to the underlying SAT solver it scales much better than the CPPMEM explicit-state model checker. This case study inspired optimizations in Nitpick from which other formalizations can now benefit...|$|R
40|$|The {{normative}} {{version of}} RDF Schema (RDFS) gives non-standard (intensional) interpretations to some standard notions such as classes and properties, thus departing from <b>standard</b> set-based <b>semantics.</b> In this paper we develop a <b>standard</b> set-based (extensional) <b>semantics</b> for the RDFS vocabulary while preserving the simplicity and computational complexity of deduction of the intensional version. This result can positively impact current implementations, as reasoning in RDFS {{can be implemented}} following common set-based intuitions and be compatible with OWL extensions. © 2013 Springer-Verlag...|$|R
40|$|The {{problem of}} {{programming}} scalable multicore processors has {{renewed interest in}} message-passing languages and frameworks. Such languages and frameworks are typically actororiented, implementing some variant of the <b>standard</b> Actor <b>semantics.</b> This paper analyzes {{some of the more}} significant efforts to build actor-oriented frameworks for the JVM platform. It compares the frameworks in terms of their execution semantics, the communication and synchronization abstractions provided, and the representations used in the implementations. It analyzes the performance of actor-oriented frameworks to determine the costs of supporting different actor properties on JVM. The analysis suggests that with suitable optimizations, <b>standard</b> Actor <b>semantics</b> and some useful communication and synchronization abstractions may be supported with reasonable efficiency on the JVM platform...|$|R
2500|$|Minimum t-norm [...] {{also called}} the Gödel t-norm, {{as it is the}} <b>standard</b> <b>semantics</b> for {{conjunction}} in Gödel fuzzy logic. Besides that, it occurs in most t-norm based fuzzy logics as the <b>standard</b> <b>semantics</b> for weak conjunction. It is the pointwise largest t-norm (see the properties of t-norms below).|$|E
2500|$|... (Completeness) Every universally valid second-order formula, under <b>standard</b> <b>semantics,</b> is provable.|$|E
2500|$|... (Soundness) Every provable second-order {{sentence}} is universally valid, i.e., true in all domains under <b>standard</b> <b>semantics.</b>|$|E
5000|$|Client(s) {{that access}} and use the data. Lustre {{presents}} all clients with a unified namespace {{for all of the}} files and data in the filesystem, using <b>standard</b> POSIX <b>semantics,</b> and allows concurrent and coherent read and write access to the files in the filesystem.|$|R
40|$|Emergency {{management}} requires efficient {{information sharing}} and exchange among agencies for the smooth operations of intra- and inter-organizational emergency management processes. However, {{the lack of}} consistent data standards presents a challenge and hampers the information interoperability. In this paper, we develop a XML-based data model that prescribes a comprehensive set of data <b>standards</b> (<b>semantics</b> and internal structures) for emergency management that attempt to mitigate the information interoperability challenges. The data model is developed using Activity Theory and it is validated through interviews with domain experts. The paper applies the standards in a real case of a fire incident scenario. Further, it complies with the national leading initiatives in emergency standards (National Information Exchange Model) which leverage its implications on the information sharing in emergency context...|$|R
40|$|This paper {{shows that}} a first-order unificationbased {{semantic}} interpretation for various coordinate constructs is possible without an explicit use of lambda expressions if we slightly modify the <b>standard</b> Montagovian <b>semantics</b> of coordination. This modification, along with partial execution, completely eliminates the lambda reduction steps during semantic interpretation...|$|R
2500|$|The <b>standard</b> <b>semantics</b> of a {{judgment}} in natural deduction {{is that it}} asserts that whenever , , etc., are all true, [...] will also be true. The judgments ...|$|E
2500|$|Product t-norm [...] (the {{ordinary}} {{product of}} real numbers). Besides other uses, the product t-norm is the <b>standard</b> <b>semantics</b> for strong conjunction in product fuzzy logic. It is a strict Archimedean t-norm.|$|E
2500|$|Łukasiewicz t-norm [...] The {{name comes}} from the fact that the t-norm is the <b>standard</b> <b>semantics</b> for strong {{conjunction}} in Łukasiewicz fuzzy logic. It is a nilpotent Archimedean t-norm, pointwise smaller than the product t-norm.|$|E
40|$|Abstract. We {{consider}} {{the problem of}} incorporating outerjoins into uncertain databases. We motivate why outerjoins are useful, but tricky, in uncertain databases, arguing that <b>standard</b> possible-worlds <b>semantics</b> may be inappropriate for outerjoins. We explore a variety of alternative semantics through a running example, and we briefly discuss implementation considerations. ...|$|R
40|$|AbstractDeviating from <b>standard</b> possible-worlds <b>semantics,</b> authors {{belonging}} {{to what might}} be called the ‘imperative tradition’ of deontic logic have proposed a semantics that directly represents norms (or imperatives). The paper examines possible definitions of (monadic) deontic operators in such a semantics and some properties of the resulting logical systems...|$|R
40|$|It {{is common}} lore that <b>standard,</b> Kripke-style <b>semantics</b> for {{quantified}} modal logic {{is incompatible with}} the view that no individual may belong {{to more than one}} possible world, a view that seems to require a counterpart-theoretic semantics instead. Strictly speaking, however, this thought is wrong-headed. This note explains why...|$|R
2500|$|The <b>standard</b> <b>semantics</b> of a sequent is an {{assertion}} that whenever every [...] is true, {{at least one}} [...] will also be true. Thus the empty sequent, having both cedents empty, is false. One way to express this is that a comma {{to the left of}} the turnstile should be thought of as an [...] "and", and a comma to the right of the turnstile should be thought of as an (inclusive) [...] "or". The sequents ...|$|E
50|$|A {{profile in}} the Unified Modeling Language (UML) {{provides}} a generic extension mechanism for customizing UML models for particular domains and platforms. Extension mechanisms allow refining <b>standard</b> <b>semantics</b> in strictly additive manner, preventing them from contradicting <b>standard</b> <b>semantics.</b>|$|E
5000|$|Minimum t-norm [...] {{also called}} the Gödel t-norm, {{as it is the}} <b>standard</b> <b>semantics</b> for {{conjunction}} in Gödel fuzzy logic. Besides that, it occurs in most t-norm based fuzzy logics as the <b>standard</b> <b>semantics</b> for weak conjunction. It is the pointwise largest t-norm (see the properties of t-norms below).|$|E
40|$|Robert van Rooij (2006) {{proposed}} {{an analysis of}} counterfactual donkey sentences by combining the Stalnaker–Lewis analysis of counterfactuals with <b>standard</b> dynamic <b>semantics.</b> This paper points out some problems with van Rooij’s treatment of counterfactual sentences {{in the language of}} first-order logic and provides a new interpretation using dynamic semantics...|$|R
5000|$|Additional t-norm conjunctions and {{residual}} implications. Some expressively strong t-norm logics, {{for instance}} the logic ŁΠ, {{have more than}} one strong conjunction or residual implication in their language. In the <b>standard</b> real-valued <b>semantics,</b> all such strong conjunctions are realized by different t-norms and the residual implications by their residua.|$|R
40|$|AbstractThe <b>standard</b> {{operational}} <b>semantics</b> of concurrent constraint logic languages is not confluent in {{the sense}} that different schedulings of processes may result in different program behaviors. While implementations are free to choose specific scheduling policies, analyses should be correct for all implementations. Moreover, in the presence of parallelism, it is usually not possible to determine how processes will actually be scheduled. Efficient program analysis is therefore difficult as all process schedulings must be considered. To overcome this problem, we introduce a confluent semantics which closely approximates the <b>standard</b> (nonconfluent) <b>semantics.</b> This semantics provides a basis for efficient and accurate program analysis for these languages. To illustrate the usefulness of this approach, we sketch analyses based on abstract interpretations of the confluent semantics which determine if a program is suspension- and local suspension-free...|$|R
5000|$|... (Completeness) Every universally valid second-order formula, under <b>standard</b> <b>semantics,</b> is provable.|$|E
5000|$|Generalized {{quantifier}} [...] - [...] the <b>standard</b> <b>semantics</b> {{assigned to}} determiner phrases ...|$|E
5000|$|In the {{standard}} or full semantics, quantifiers over higher-type objects range over all possible objects of that type. For example, a quantifier over sets of individuals ranges {{over the entire}} powerset of the set of individuals. Thus, in <b>standard</b> <b>semantics,</b> once the set of individuals is specified, this is enough to specify all the quantifiers. HOL with <b>standard</b> <b>semantics</b> is more expressive than first-order logic. For example, HOL admits categorical axiomatizations of the natural numbers, and of the real numbers, which are impossible with first-order logic. However, by a result of Gödel, HOL with <b>standard</b> <b>semantics</b> does not admit an effective, sound, and complete proof calculus.|$|E
40|$|Abstract. We {{propose a}} static type {{system for a}} {{significant}} subset of JavaScript, dubbed SJS, {{with the goal of}} ensuring that objects have a statically known layout at the allocation time, which in turn can en-able an ahead-of-time (AOT) compiler to generate efficient code. The main technical challenge we address is to ensure fixed object layout, while supporting popular language features such as objects with proto-type inheritance, structural subtyping, and method updates, with the additional constraint that SJS programs can run on any available stan-dard JavaScript engine, with no deviation from JavaScript’s <b>standard</b> operational <b>semantics.</b> The core difficulty arises from the way <b>standard</b> JavaScript <b>semantics</b> implements object attribute update with prototype-based inheritance. To our knowledge, combining a fixed object layout property with prototype inheritance and subtyping has not been achieved previously. ...|$|R
40|$|We {{formally}} {{define the}} set-based abstraction of any language whose operational semantics {{can be defined}} by environment evaluation. The Aiken-Wimmers soft type system precisely corresponds to this set-based abstraction under their operational semantics. The Heintze set-based analysis is precisely this set-based abstraction under a different operational semantics. In general, set-based abstraction determines a notion of SBA-safety. Aiken-Wimmers typability {{is a form of}} SBA-safety. SBA- safety is decidable in most cases. For monovariant functional programs with shallow case statements SBA-safety is decidable in O(n 3) time under any <b>standard</b> operational <b>semantics.</b> We show here that if we allow deep patterns in the case statements of monovariant functional programs the problem of determining SBA-safety becomes complete for deterministic exponential time (under any <b>standard</b> operational <b>semantics).</b> We also systematically characterize the complexity of determining SBA-safety for monov [...] ...|$|R
40|$|The <b>standard</b> {{operational}} <b>semantics</b> of concurrent constraint logic languages is not confluent in {{the sense}} that different schedulings of processes may result in different program behaviors. While implementations are free to choose specific scheduling policies, analyses should be correct for all implementations. Moreover, in the presence of parallelism, it is usually not possible to determine how processes will actually be scheduled. Efficient program analysis is therefore difficult as all process schedulings must be considered. To overcome this problem, we introduce a confluent semantics which closely approximates the <b>standard</b> (nonconfluent) <b>semantics.</b> This semantics provides a basis for efficient and accurate program analysis for these languages. To illustrate the usefulness of this approach, we sketch analyses based on abstract interpretations of the confluent semantics which determine if a program is suspension- and local suspension-free...|$|R
