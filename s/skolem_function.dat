25|78|Public
5000|$|... the {{negation}} of that formula has the {{conjunctive normal form}} , with [...] and [...] denoting the <b>Skolem</b> <b>function</b> {{for the first and}} second existential quantifier, respectively; the literals [...] and [...] are unifiable without occurs check, producing the refuting empty clause.|$|E
5000|$|In general, if [...] is {{a theory}} and for each formula [...] with free {{variables}} [...] there is a <b>Skolem</b> <b>function,</b> then [...] is called a Skolem theory. For example, by the above, arithmetic with the Axiom of Choice is a Skolem theory.|$|E
5000|$|Informally, the <b>skolem</b> <b>function</b> [...] can {{be thought}} of as {{yielding}} the person by whom [...] is loved, while [...] yields the animal (if any) that [...] doesn't love. The 3rd last line from below then reads as [...] " [...] doesn't love the animal , or else [...] is loved by [...] ".|$|E
40|$|The realizability {{problem in}} {{requirements}} engineering {{is to determine}} the existence of an implementation that meets the given formal requirements. A step forward after realizability is proven, is to construct such an implementation automatically, and thus solve the problem of program synthesis. In this paper, we propose a novel approach to pro- gram synthesis guided by k-inductive proofs of realizability of assume- guarantee contracts constructed from safety properties. The proof of re- alizability is performed over a set of forall-exists formulas, and synthesis is per- formed by extracting <b>Skolem</b> <b>functions</b> witnessing the existential quan- tification. These <b>Skolem</b> <b>functions</b> can then be combined into an imple- mentation. Our approach is implemented in the JSyn tool which con- structs <b>Skolem</b> <b>functions</b> from a contract written in a variant of the Lus- tre programming language and then compiles the <b>Skolem</b> <b>functions</b> into a C language implementation. For a variety of benchmark models that already contained hand-written implementations, we are able to identify the usability and effectiveness of the synthesized counterparts, assuming a component-based verification framework. Comment: 18 pages, 3 figure...|$|R
40|$|This paper {{shows how}} to {{conservatively}} extend theories formulated in non-classical logics {{such as the}} Logic of Paradox, the Strong Kleene Logic and relevant Logics with <b>Skolem</b> <b>functions.</b> Translations {{to and from the}} language extended by <b>Skolem</b> <b>functions</b> into the original one are presented and shown to preserve derivability. It is also shown that one may not always substitute s=f(t) and A(t,s) even though A(x,y) determines the extension of a function for which f is introduced...|$|R
40|$|The {{creation}} of values to represent incomplete information, {{often referred to}} as value invention, is central in data ex-change. Within schema mappings, <b>Skolem</b> <b>functions</b> have long been used for value invention as they permit a precise representation of missing information. Recent work on a powerful mapping language called second-order tuple gen-erating dependencies (SO tgds), has drawn {{attention to the fact that}} the use of arbitrary <b>Skolem</b> <b>functions</b> can have neg-ative computational and programmatic properties in data exchange. In this paper, we present two techniques for un-derstanding when the <b>Skolem</b> <b>functions</b> needed to represent the correct semantics of incomplete information are com-putationally well-behaved. Specifically, we consider when the <b>Skolem</b> <b>functions</b> in second-order (SO) mappings have a first-order (FO) semantics and are therefore programmat-ically and computationally more desirable for use in prac-tice. Our first technique, linearization, significantly extends the Nash, Bernstein and Melnik unskolemization algorithm, by understanding when the sets of arguments of the <b>Skolem</b> <b>functions</b> in a mapping are related by set inclusion. We show that such a linear relationship leads to mappings that have FO semantics and are expressible in popular mapping lan-guages including source-to-target tgds and nested tgds. Our second technique uses source semantics, specifically func-tional dependencies (including keys), to transform SO map-pings into equivalent FO mappings. We show that our algo-rithms are applicable to a strictly larger class of mappings than previous approaches, but more importantly we present an extensive experimental evaluation that quantifies this dif-ference (about 78 % improvement) over an extensive schema mapping benchmark and illustrates the applicability of our results on real mappings...|$|R
5000|$|To see the {{connection}} with model theory, notice that if [...] is a structure with universe [...] in a countable language and [...] is a <b>Skolem</b> <b>function</b> for , then a stationary [...] must contain an elementary substructure of [...] In fact, [...] is stationary {{if and only if}} for any such structure [...] there is an elementary substructure of [...] that belongs to [...]|$|E
5000|$|This form of Skolemization is an {{improvement}} over [...] "classical" [...] Skolemization in that only variables that are free in the formula are placed in the Skolem term. This is {{an improvement}} because the semantics of tableau may implicitly place the formula in the scope of some universally quantified variables {{that are not in}} the formula itself; these variables are not in the Skolem term, while they would be there according to the original definition of Skolemization. Another improvement that may be used is applying the same <b>Skolem</b> <b>function</b> symbol for formulae that are identical up to variable renaming.|$|E
5000|$|The {{notion of}} witness {{leads to the}} more general idea of game semantics. In the case of {{sentence}} [...] the winning strategy for the verifier is to pick a witness for [...] For more complex formulas involving universal quantifiers, {{the existence of a}} winning strategy for the verifier depends on the existence of appropriate Skolem functions. For example, if S denotes [...] then an equisatisfiable statement for S is [...] The <b>Skolem</b> <b>function</b> f (if it exists) actually codifies a winning strategy for the verifier of S by returning a witness for the existential sub-formula for every choice of x the falsifier might make.|$|E
40|$|The monadic second-order {{theory of}} trees allows {{quantification}} over elements and over arbitrary subsets. We classify {{the class of}} trees {{with respect to the}} question: does a tree T have definable <b>Skolem</b> <b>functions</b> (by a monadic formula with parameters) ? This continues [LiSh 539] where the question was asked only with respect to choice functions. Here we define a subclass of the class of tame trees (trees with a definable choice function) and prove that this is exactly the class (actually set) of trees with definable <b>Skolem</b> <b>functions...</b>|$|R
40|$|Abstract—Many {{synthesis}} {{problems can}} be solved by formu-lating them as a quantified Boolean formula (QBF). For such problems, a mere true/false answer is often not enough. Instead, expressing the answer in terms of <b>Skolem</b> <b>functions</b> reflecting the quantifier dependencies of the variables is required. Several approaches have been presented to extract such functions from term-resolution proofs. However, not all solvers and preproces-sors are able to produce term-resolution proofs, especially when universal expansion is involved. In previous work, we developed the QRAT proof system consisting of three simple rules which allowed us to overcome this issue and to equip modern expansion-based tools like the preprocessor bloqqer with proof tracing. In this paper, we show how to extract <b>Skolem</b> <b>functions</b> from QRAT proofs. We present a general extraction tool and compare its performance to similar resolution-based tools. We show that the <b>Skolem</b> <b>functions</b> extracted from QRAT proofs are smaller than those produced by alternative approaches making our method in particular useful for synthesis applications. I...|$|R
40|$|The {{monotonicity}} theorem is {{the first}} step in proving that o-minimal structures satisfy cellular decomposition, which gives a comprehensive picture of the definable subsets in an o-minimal structure. This leads to the fact that any o-minimal structure has an o-minimal theory. We first investigate the possible analogues for monotonicity in a weakly o-minimal structure, and find that having definable <b>Skolem</b> <b>functions</b> and uniform elimination of imaginaries is sufficient to guarantee that a weakly o-minimal theory satisfies one of these, the Finitary Monotonicity Property. In much of the work on weakly o-minimal structures, it is shown that nonvaluational weakly o-minimal structures are most "like" the o-minimal case. To that end, there is a monotonicity theorem and a strong cellular decomposition for nonvaluational weakly o-minimal expansions of a group. In contrast to these results, we show that nonvaluational weakly o-minimal expansions of an o-minimal group do not have definable <b>Skolem</b> <b>functions.</b> As a partial converse, we show that certain valuational expansions of an o-minimal group, called T-immune, do have definable <b>Skolem</b> <b>functions,</b> and we calculate them explicitly via quantifier elimination...|$|R
5000|$|At the meta-level, first-order satisfiability of {{a formula}} [...] may be written {{with a little}} abuse of {{notation}} as , where [...] is a model, [...] is {{an evaluation of the}} free variables, and [...] means that [...] is true in [...] under [...] Since first-order models contain the evaluation of all function symbols, any <b>Skolem</b> <b>function</b> [...] contains is implicitly existentially quantified by [...] As a result, after replacing an existential quantifier over variables into an existential quantifiers over functions {{at the front of the}} formula, the formula still may be treated as a first-order one by removing these existential quantifiers. This final step of treating [...] as [...] may be completed because functions are implicitly existentially quantified by [...] in the definition of first-order satisfiability.|$|E
5000|$|More generally, game {{semantics}} may {{be applied}} to predicate logic; the new rules allow a dominant quantifier to be removed by its [...] "owner" [...] (the Verifier for existential quantifiers and the Falsifier for universal quantifiers) and its bound variable replaced at all occurrences by an object of the owner's choosing, drawn from the domain of quantification. Note that a single counterexample falsifies a universally quantified statement, and a single example suffices to verify an existentially quantified one. Assuming the axiom of choice, the game-theoretical semantics for classical first-order logic agree with the usual model-based (Tarskian) semantics. For classical first-order logic the winning strategy for the verifier essentially consists of finding adequate Skolem functions and witnesses. For example, if S denotes [...] then an equisatisfiable statement for S is [...] The <b>Skolem</b> <b>function</b> f (if it exists) actually codifies a winning strategy for the verifier of S by returning a witness for the existential sub-formula for every choice of x the falsifier might make.|$|E
5000|$|More generally, Skolemization is {{performed}} by replacing every existentially quantified variable [...] with a term [...] whose function symbol [...] is new. The variables of this term are as follows. If the formula is in prenex normal form, [...] are {{the variables that}} are universally quantified and whose quantifiers precede that of [...] In general, they are the variables that are quantified universally [...] and such that [...] occurs in the scope of their quantifiers. The function [...] introduced in this process is called a <b>Skolem</b> <b>function</b> (or Skolem constant if it is of zero arity) and the term is called a Skolem term. As an example, the formula [...] is not in Skolem normal form because it contains the existential quantifier [...] Skolemization replaces [...] with , where [...] is a new function symbol, and removes the quantification over [...] The resulting formula is [...] The Skolem term [...] contains , but not , because the quantifier to be removed [...] is in the scope of , but not in that of since this formula is in prenex normal form, this is equivalent to saying that, {{in the list of}} quantifiers, [...] precedes [...] while [...] does not. The formula obtained by this transformation is satisfiable if and only if the original formula is.|$|E
40|$|Expansion {{trees are}} defined as generalizations of Herbrand {{instances}} for formulas in a nonextensional form of higher-order logic based on Church 2 ̆ 7 s simple theory of types. Such expansion trees can be defined {{with or without the}} use of <b>skolem</b> <b>functions.</b> These trees store substitution terms and either critical variables or skolem terms used to instantiate quantifiers in the original formula and those resulting from instantiations. An expansion tree is called an expansion tree proof (ET-proof) if it encodes a tautology, and, in the form not using <b>skolem</b> <b>functions,</b> an 2 ̆ 2 imbedding 2 ̆ 2 relation among the critical variables be acyclic. The relative completeness result for expansion tree proofs not using <b>skolem</b> <b>functions,</b> i. e. if A is provable in higher-order logic then A has such an expansion tree proof, is based on Andrews 2 ̆ 7 formulation of Takahasti 2 ̆ 7 s proof of the cut-elimination theorem for higher-order logic. If the occurrences of <b>skolem</b> <b>functions</b> in instantiation terms are restricted appropriately, the use of <b>skolem</b> <b>functions</b> in place of critical variables is equivalent to the requirement that the imbedding relation is acyclic. This fact not only resolves the open question of what is a sound definition of skolemization in higher-order logic but also provides a direct, syntactic proof of its correctness. Since subtrees of expansion trees are also expansion trees (or their dual) and expansion trees store substitution terms and critical variables explicitly, ET-proofs can be directly converted into sequential and natural deduction proofs. A naive translation will often produce proofs which contain a lot of redunancies and will often use implicational lines in an awkward fashion. An improved translation process is presented. This process will produce only focused proofs in which much of the redunancy has been eliminated and backchaining on implicational lines was automatically selected if it was applicable. The information necessary to construct focused proofs is provided by a certain connection scheme, called a mating,of the boolean atoms within the tautology encoded by an ET-proof...|$|R
5000|$|Given an IF {{sentence}} [...] with [...] existential quantifiers, {{a structure}} , {{and a list}} of [...] functions of appropriate arities, we denote as [...] the expansion of [...] which assigns the functions [...] as interpretations for the <b>Skolem</b> <b>functions</b> of [...]|$|R
50|$|Also {{known as}} <b>Skolem</b> {{elementary}} <b>functions.</b>|$|R
40|$|AbstractArithmetical {{formulas}} are the formulas {{containing the}} usual logical and arithmetical symbols +, ·, and constants of Z. If an arithmetical sentence ∀x∃yψ(x,y) {{is true in}} a model M, then there is function f(x) defined on M such that ∀xψ(x,f(x)) is true in M. Such a function is called a <b>Skolem</b> <b>function</b> of the arithmetical sentence ∀x∃yψ(x,y). In this paper, we study the bounds of the Skolem functions when the model M is the set of all natural numbers N or the ring of integers Z. We define the <b>Skolem</b> <b>function</b> f(x) for ∀x∃yψ(x,y) as follows. For any a in N (or Z) let f(a) be the least (or least absolute value of) b such that ψ(a,b) is true in N (or Z). For every arithmetical sentence ∀x∃y∀zψ(x,y,z) true in N (or Z) there is a polynomial g(x) over Z such that the corresponding <b>Skolem</b> <b>function</b> f(x) <g(|x|) for any x in N (or Z). An application of considering the bounds of these <b>Skolem</b> <b>function</b> is the following: If the Generalized Riemann Hypothesis holds, then for every d there is a polynomial time algorithm for the following problem: given a quantifier-free arithmetical formula φ(x,y) of degree at most d, does ∀x∃yφ(x,y) hold in Z. Moreover, if the sentence is false in Z, then the algorithm outputs an a∈Z such that ∀y¬φ(a,y) ...|$|E
40|$|This paper {{develops}} a unified analysis of "functional" anaphora and wide-scope indefinites. A new operator {{is added to}} Jacobson's variable-free semantics of functional readings, which leads {{to an analysis of}} these readings using the general <b>Skolem</b> <b>function</b> interpretation of wide-scope indefinites. Thi...|$|E
40|$|Skolemization is a {{means to}} {{eliminate}} existential quantifiers within predicate logic sentences by replacing existentially quantified variables with <b>Skolem</b> <b>function</b> applications. The arguments of such Skolem functions are variables that are quantified outside the sub-formula under consideration. In this article a skolemization technique is introduced which abstracts {{from some of the}} <b>Skolem</b> <b>function</b> arguments. It turns out that the result obtained this way is usually more general than what can be achieved from standard (classical) Skolemization techniques. From a theorem prover's point of view such generalizations often lead to a reduction of both search space and proof length. 1 Introduction In automated theorem proving much effort is spent on the development of more and more sophisticated reasoning calculi whereas the optimization of certain normal form transformations as they are, for example, necessary for resolutionbased theorem proving, are fairly neglected. One part of [...] ...|$|E
40|$|We {{prove that}} all known {{examples}} of weakly o-minimal non-valuational structures have no definable <b>Skolem</b> <b>functions.</b> We show, however, that such structures eliminate imaginaries up to (definable families of) definable cuts. Along {{the way we}} give some new examples of weakly o-minimal non-valuational structures...|$|R
5000|$|To recast the {{reasoning}} using the resolution technique, first the clauses must {{be converted to}} conjunctive normal form (CNF). In this form, all quantification becomes implicit: universal quantifiers on variables (X, Y, ...) are simply omitted as understood, while existentially-quantified variables are replaced by <b>Skolem</b> <b>functions.</b>|$|R
2500|$|The trick {{used in this}} {{proof is}} {{essentially}} due to <b>Skolem,</b> who introduced <b>function</b> symbols for the <b>Skolem</b> <b>functions</b> [...] into the language. One could also define the [...] as partial functions such that [...] is defined {{if and only if}} [...] The only important point is that [...] is a preclosure operator such that [...] contains a solution for every formula with parameters in [...] which has a solution in [...] and that ...|$|R
40|$|In 1961 Leon Henkin [3] {{extended}} first-order logic {{by adding}} partially ordered arrays of quantifiers. He proposed a semantics for sentences φ that begin with quantifier arrays of this kind: φ {{is true in}} a structure A {{if and only if}} there are a sentence φ + and a structure A + such that: • φ + comes from φ by removing each existential quantifier ∃y in the partially ordered prefix, and replacing each occurrence of the variable y by a term F (¯x) where ¯x are the variables universally quantified ‘before’ ∃y in the quantifier prefix (so that the new function symbols F are <b>Skolem</b> <b>function</b> symbols), • A + comes from A by adding functions to interpret the <b>Skolem</b> <b>function</b> symbols in φ +, and • φ + is true in A +. For example the sentenc...|$|E
40|$|AbstractLet R⊆ω×ω be an arithemetic relation. We {{show that}} (∀x) (ϵ) R(x,y) holds in the arithemetic isols if {{and if it}} holds in the {{integers}} with an almost arithmetic combinatorial <b>Skolem</b> <b>function.</b> Our proof uses model theoretic mainly developed by A. Mostowski. The results generalize to n variables and to various fragments of the arithmetic isols...|$|E
40|$|We follow [8] {{in asking}} when {{a set of}} ordinals X ` ff is a {{countable}} union of sets in K, the core model. We show that, analogously to L, an X closed under the canonical Σ 1 <b>Skolem</b> <b>function</b> for K ff can be so decomposed, provided K is such that no !-closed filters are put on its measure sequence, but not otherwise. This proviso holds {{if there is no}} inner model of a weak Erdos type property...|$|E
40|$|From proofs in any {{classical}} first-order {{theory that}} proves {{the existence of}} at least two elements, one can eliminate definitions in polynomial time. From proofs in any classical first-order theory strong enough to code finite functions, including sequential theories, one can also eliminate <b>Skolem</b> <b>functions</b> in polynomial time...|$|R
40|$|We give {{techniques}} for extracting proofs from the Clausal Normal Form transformation. We discuss and solve three technical problems: (1). How {{to handle the}} introduction of definitions and <b>Skolem</b> <b>functions.</b> (2). How to generate short (linear size) proofs. (3). How to handle optimized Skolemization. We reduce it to standard Skolemization...|$|R
40|$|We {{develop the}} notion of {{coherent}} ultrafilters (extenders without normality or well-foundedness). We then use definable coherent ultraproducts to characterize any extension of a model M in any fragment of L_∞, ω that defines <b>Skolem</b> <b>functions</b> by a sufficiently complete (but in ZFC) coherent ultrafilter. We apply this method to various elementary classes and AECs...|$|R
40|$|Hintikka {{describes}} the semantical games for Independence Friendly logic (IF-logic) {{in terms of}} the game rules. In this paper we elaborate in detail how the standard extensive game model serves as a mathematical model for these games. We intend the game model to be a framework in which we can reason with mathematical rigor about strategies, hence about truth and falsity in GTS. We discuss negation normal forms, and compare the notion of <b>Skolem</b> <b>function</b> with the game theoretical notion of strategy...|$|E
40|$|Given a propositional formula F(x,y), a <b>Skolem</b> <b>{{function}}</b> for x is {{a function}} Ψ(y), such that substituting Ψ(y) for x in F gives a formula semantically equivalent to ∃ F. Automatically generating Skolem functions is of significant interest in several applications including certified QBF solving, finding strategies of players in games, synthesising circuits and bit-vector programs from specifications, disjunctive decomposition of sequential circuits etc. In many such applications, F is given as a conjunction of factors, each of which depends on a small subset of variables. Existing algorithms for <b>Skolem</b> <b>function</b> generation ignore any such factored form and treat F as a monolithic function. This presents scalability hurdles in medium to large problem instances. In this paper, we argue that exploiting the factored form of F can give significant performance improvements in practice when computing Skolem functions. We present a new CEGAR style algorithm for generating Skolem functions from factored propositional formulas. In contrast to earlier work, our algorithm neither requires a proof of QBF satisfiability nor uses composition of monolithic conjunctions of factors. We show experimentally that our algorithm generates smaller Skolem functions and outperforms state-of-the-art approaches on several large benchmarks. Comment: Full version of FMCAD 2015 conference publicatio...|$|E
40|$|Skolemization is a {{means to}} {{eliminate}} existential quantifiers within predicate logic sentences and that by replacing existentially quantified variables with <b>Skolem</b> <b>function</b> applications. The arguments of these Skolem functions are variables which are quantified outside the sub-formula under consideration. In this paper a Skolemization technique is introduced which abstracts {{from some of the}} arguments of the Skolem functions. It shows that the Skolemization result obtained this way is usually more general than what can be achieved from standard (classical) Skolemization. This can be of quite some importance since such generalizations often lead to a reduction of both search space and proof length...|$|E
40|$|We present two {{extensions}} of pCRL with time-stamped actions: pCRL ae for absolute time and pCRLrae for relative time. We define timed bisimilarity for both versions and {{prove that the}} given axiomatisations are ground complete, provided that the data types have built-in equality and <b>Skolem</b> <b>functions.</b> We base the completeness proofs on the completeness results for untimed pCRL...|$|R
40|$|Given an o-minimal {{structure}} M {{with a group}} operation, we {{show that}} for a properly convex subset U, {{the theory of the}} expanded structure M'=(M,U) has definable <b>Skolem</b> <b>functions</b> precisely when M' is valuational. As a corollary, we get an elementary proof that the theory of any such M' does not satisfy definable choice. Comment: 11 page...|$|R
40|$|In any {{classical}} first-order {{theory that}} proves {{the existence of}} at least two elements, one can eliminate definitions with a polynomial bound on the increase in proof length. In any classical first-order strong enough to code finite functions, including sequential theories, one can also eliminate <b>Skolem</b> <b>functions</b> with a polynomial bound on the increase in proof length...|$|R
