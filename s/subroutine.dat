3890|2608|Public
5|$|In the maximal clique listing problem, {{the input}} is an undirected graph, and the output {{is a list}} of all its maximal cliques. The maximum clique problem may be solved using as a <b>subroutine</b> an {{algorithm}} for the maximal clique listing problem, because the maximum clique must be included among all the maximal cliques.|$|E
5|$|Picard pilots {{the shuttle}} {{through the field}} of {{distortion}} pockets. Chief Miles O'Brien (Colm Meaney) transports the Captain {{back to the ship}} before the shuttle is destroyed. The approach resulted in the Enterprise nearing the edge of the nebula, and they quickly depart. Afterwards, D'Sora reveals to Data over a romantic dinner in his quarters that she broke up with her boyfriend because he was emotionally unavailable and then pursued him because he was the same. Data realises that she is breaking up with him and explains that he will delete the <b>subroutine.</b> D'Sora departs and Data blows out the candles seemingly unperturbed.|$|E
5|$|Later on the bridge, Data is {{reviewing}} {{the information from}} the probes sent into the nebula. He theorises that life might have evolved differently in the nebula because of the volume of dark matter detected. Captain Jean-Luc Picard (Patrick Stewart) orders the ship to the nearest planet within the nebula. Data and D'Sora configure further probes, when she kisses him on the cheek and then on the lips, before leaving the room. Data seeks the opinion of his friends, including Picard, Guinan (Whoopi Goldberg), Geordi La Forge (LeVar Burton), Commander William Riker (Jonathan Frakes), Deanna Troi (Marina Sirtis) and Worf (Michael Dorn). Data decides to pursue the relationship and goes to D'Sora's cabin with a bunch of flowers, where he informs her that he created a romantic <b>subroutine</b> for the relationship.|$|E
5000|$|<b>Subroutines</b> (called [...] "Sub") are {{the most}} basic unit of code. All code must be written inside <b>subroutines.</b> <b>Subroutines</b> can return a value.|$|R
50|$|The NOVAS library {{provides}} {{three levels}} of <b>subroutines</b> (functions): basic, utility, and supervisory. Basic-level <b>subroutines</b> supply the values of fundamental variables, such as the nutation angles and the heliocentric positions of solar system bodies for specific epoches. Utility-level <b>subroutines</b> perform transformations, such as those caused by precession, nutation and aberration. Supervisory-level <b>subroutines</b> serve as interfaces to the basic and utility <b>subroutines</b> to compute the coordinates of stars or Solar System bodies for specific dates and times.|$|R
50|$|<b>Subroutines</b> must {{preserve}} {{the contents of}} r4 to r11 and the stack pointer. (Perhaps by saving them to the stack in the function prologue, then using them as scratch space, then restoring them from the stack in the function epilogue). In particular, <b>subroutines</b> that call other <b>subroutines</b> *must* save the return address in the link register r14 to the stack before calling those other <b>subroutines.</b> However, such <b>subroutines</b> {{do not need to}} return that value to r14—they merely need to load that value into r15, the program counter, to return.|$|R
25|$|Quicksort gained {{widespread}} adoption, appearing, for example, in Unix as {{the default}} library sort <b>subroutine.</b> Hence, it lent {{its name to}} the C standard library <b>subroutine</b> qsort and in the reference implementation of Java.|$|E
25|$|One {{can also}} return {{out of a}} <b>subroutine</b> {{executing}} the looped statements, breaking out of both the nested loop and the <b>subroutine.</b> There are other proposed control structures for multiple breaks, but these are generally implemented as exceptions instead.|$|E
25|$|David Wheeler, {{who earned}} the world's first Computer Science PhD {{working on the}} project, is {{credited}} with inventing {{the concept of a}} <b>subroutine.</b> Users wrote programs that called a routine by jumping {{to the start of the}} <b>subroutine</b> with the return address (i.e. the location-plus-one of the jump itself) in the accumulator (a Wheeler jump). By convention the <b>subroutine</b> expected this and the first thing it did was to modify its concluding jump instruction to that return address. Multiple and nested subroutines could be called so long as the user knew the length of each one in order to calculate the location to jump to; recursive calls were forbidden. The user then copied the code for the <b>subroutine</b> from a master tape onto their own tape following the end of their own program.|$|E
40|$|Computer program PSHFT calculates lifetimes {{of variety}} of {{aircraft}} transmissions. Consists of main program, series of <b>subroutines</b> applying to specific configurations, generic <b>subroutines</b> {{for analysis of}} properties of components, <b>subroutines</b> for analysis of system, and common block. Main program selects routines used in analysis and causes them to operate in desired sequence. Series of configuration-specific <b>subroutines</b> put in configuration data, perform force and life analyses for components (with help of generic component-property-analysis <b>subroutines),</b> fill property array, call up system-analysis routines, and finally print out results of analysis for system and components. Written in FORTRAN 77 (IV) ...|$|R
5000|$|In {{order to}} discuss this topic we need some definitions. In logical terms, an {{executable}} program consists of one main program and zero or more subprograms (or procedures) - these do something. Subprograms are either functions or <b>subroutines,</b> which are either external, internal or module <b>subroutines.</b> (External <b>subroutines</b> are what we knew from FORTRAN 77.) ...|$|R
50|$|Some {{languages}} allow <b>subroutines</b> to {{be defined}} to accept a variable number of arguments. For such languages, the <b>subroutines</b> must iterate through the list of arguments.|$|R
25|$|There is a fully polynomial-time {{approximation}} scheme, {{which uses}} the pseudo-polynomial time algorithm as a <b>subroutine,</b> described below.|$|E
25|$|The <b>subroutine</b> concept {{led to the}} {{availability}} of a substantial <b>subroutine</b> library. By 1951, 87 subroutines in the following categories were available for general use: floating point arithmetic; arithmetic operations on complex numbers; checking; division; exponentiation; routines relating to functions; differential equations; special functions; power series; logarithms; miscellaneous; print and layout; quadrature; read (input); nth root; trigonometric functions; counting operations (simulating repeat until loops, while loops and for loops); vectors; and matrices.|$|E
25|$|These {{algorithms}} {{may be used}} as subroutines {{for other}} problems including testing connectivity, recognizing series-parallel graphs, and constructing st-numberings of graphs (an important <b>subroutine</b> in planarity testing).|$|E
50|$|<b>Subroutines</b> are a {{powerful}} programming tool, and the syntax of many programming languages includes support for writing and using them. Judicious use of <b>subroutines</b> (for example, through the structured programming approach) will often substantially {{reduce the cost}} of developing and maintaining a large program, while increasing its quality and reliability. <b>Subroutines,</b> often collected into libraries, are an important mechanism for sharing and trading software. The discipline of object-oriented programming is based on objects and methods (which are <b>subroutines</b> attached to these objects or object classes).|$|R
40|$|Introduction Hierarchical Genetic Programming (HGP) {{extensions}} discover, modify, {{and exploit}} <b>subroutines</b> {{to accelerate the}} evolution of programs [Koza 1992, Rosca and Ballard 1994 a]. The use of <b>subroutines</b> biases the search for good programs and offers the possibility to reuse code. While HGP approaches improve the efficiency and scalability of genetic programming (GP) for many applications [Koza, 1994 b], several issues remain unresolved. The scalability of HGP techniques could be further improved by solving two such issues. One is the characterization {{of the value of}} <b>subroutines.</b> Current methods for HGP do not attempt to decide what is relevant, i. e. which blocks of code or <b>subroutines</b> may be worth giving special attention, but employ genetic operations on <b>subroutines</b> at random points. The other issue is the time-course of the generation of new <b>subroutines.</b> Current HGP techniques do not make informed choices to automatically decide wh...|$|R
40|$|Abstract In Java bytecode, intra-method <b>subroutines</b> are {{employed}} to represent code in &quot;finally&quot;blocks. The {{use of such}} polymorphic <b>subroutines</b> within a method makes bytecode analysis very difficult. Fortunately, such <b>subroutines</b> can be eliminated through recompilation orinlining. Inlining is the obvious choice since {{it does not require}} changing compilers or access to the source code. It also allows transformation of legacy bytecode. However, thecombination of nested, non-contiguous <b>subroutines</b> with overlapping exception handlers poses a difficult challenge. This paper presents an algorithm that successfully solves allthese problems without producing superfluous instructions...|$|R
25|$|The sorting routine uses two subroutines, heapify and siftDown. The {{former is}} the common in-place heap {{construction}} routine, while {{the latter is a}} common <b>subroutine</b> for implementing heapify.|$|E
25|$|The 68000 {{assembler}} code {{below is}} for a <b>subroutine</b> named , which copies a source null-terminated ASCIZ character string to another destination string, converting all alphabetic characters to lower case.|$|E
25|$|TC (transfer control): An {{unconditional}} branch {{to the address}} specified by the instruction. The return address was automatically stored in the Q register, so the TC instruction {{could be used for}} <b>subroutine</b> calls.|$|E
40|$|Bytecode <b>subroutines</b> {{are a major}} {{complication}} for Java bytecode verification: {{they are}} difficult {{to fit into the}} data flow analysis that the JVM specification suggests. Because of that, <b>subroutines</b> are left out or are restricted in most formalizations of the bytecode verifier. We examine the problems that occur with <b>subroutines</b> and give an overview of the most prominent solutions in the literature. Using the theorem prover Isabelle/HOL, we have extended our substantial formalization of the JVM and the bytecode verifier with its proof of correctness by the most general solution for bytecode <b>subroutines...</b>|$|R
40|$|In this paper, {{we propose}} a {{methodology}} to address {{an important aspect}} of software porting that receives little attention, namely planning support. When a scientific application consisting of many <b>subroutines</b> is to be ported, the selection of key <b>subroutines</b> greatly impacts the productivity and overall porting strategy because these <b>subroutines</b> may represent a significant aspect of the code in terms of functionality or performance. They may as well serve as indicators of the difficulty and amount of effort involved in porting a code to a new platform. The proposed methodology is {{based on the idea that}} similar <b>subroutines</b> can be ported with similar strategies and result in a similar-quality porting. By viewing <b>subroutines</b> as DNA-like sequences, we are able to use various bioinformatic...|$|R
40|$|In {{this paper}} Fortran <b>subroutines</b> for the {{evaluation}} of the discrete form of the Helmholtz integral operators L k, M k, M k t and N k for two-dimensional, three-dimensional and three-dimensional axisymmetric problems are described. The <b>subroutines</b> are useful in the solution of Helmholtz problems via boundary element and related methods. The <b>subroutines</b> have been designed to be easy to use, reliable and efficient. The <b>subroutines</b> are also flexible in that the quadrature rule is defined as a parameter and the library functions (such as the Hankel, exponential and square root functions) are called from external routines. The <b>subroutines</b> are demonstrated on test problems arising from the solution of the Neumann problem exterior to a closed boundary via the Burton and Miller equation...|$|R
25|$|The {{alternative}} rounding modes {{are also}} useful in diagnosing numerical instability: {{if the results}} of a <b>subroutine</b> vary substantially between rounding to + and − infinity then it is likely numerically unstable and affected by round-off error.|$|E
25|$|The CALL_PAL {{format is}} used by the CALL_PAL instruction, which is used to call PALcode subroutines. The format retains the opcode field but replaces the others with a 26-bit {{function}} field, which contains an integer specifying a PAL <b>subroutine.</b>|$|E
25|$|Software reuse {{grew out}} of the {{standard}} <b>subroutine</b> libraries of the 1960s. It is the main principle of today's object-oriented programming. Instead of constantly reinventing software wheels, programming languages like C++, Java, Objective-C, and others are building vast collections of reusable software objects and components.|$|E
40|$|Graduation date: 1985 Two {{packages}} of <b>subroutines</b> {{were developed to}} perform material balances on chemical processes using the simultaneous modular approach and the equation-based approach. The performances of these packages were compared for five different processes under at least two conditions: one with no design specifications, and one with two or more design specifications. The equations arising from chemical process simulation using the simultaneous modular approach and equation-based approach are nonlinear. Therefore, two <b>subroutines</b> were developed to solve systems of nonlinear equations using a modification of Powell's dogleg method as proposed by Chen and Stadtherr. One of the nonlinear solver <b>subroutines</b> uses sparse matrix techniques and updates the Jacobian through Schubert's formula. The other uses full matrix techniques and the Jacobian is updated through Broyden's formula. Both <b>subroutines</b> were tested with five problems and the results compared. The results obtained with the two {{packages of}} <b>subroutines</b> and the nonlinear solver <b>subroutines</b> compared well with similar problems from the open literature...|$|R
5000|$|<b>Subroutines</b> may assign [...] to a hash to {{simulate}} named arguments; this is recommended in Perl Best Practices for <b>subroutines</b> {{that are likely}} to ever have more than three parameters.|$|R
40|$|On the {{mainframe}} {{there is}} a library of <b>subroutines</b> for mathematical physics. Many of the <b>subroutines</b> have been translated from FORTRAN into classic BASIC. They make a showcase of <b>subroutines</b> which compute special functions interpolate data and do matrix arithmetic. The showcase is {{under the control of}} True BASIC on a Macintosh Classic II computer from which it can be distributed on disk to other computer...|$|R
25|$|Interrupts and {{signals are}} {{low-level}} mechanisms that {{can alter the}} flow of control in a way similar to a <b>subroutine,</b> but usually occur {{as a response to}} some external stimulus or event (that can occur asynchronously), rather than execution of an in-line control flow statement.|$|E
25|$|In {{computer}} science a partial function {{corresponds to a}} <b>subroutine</b> that raises an exception or loops forever. The IEEE floating point standard defines a not-a-number value which is returned when a floating point operation is undefined and exceptions are suppressed, e.g. when the square root of a negative number is requested.|$|E
25|$|Turing {{thought that}} the speed {{and the size of}} {{computer}} memory were crucial elements, so he proposed a high-speed memory of what would today be called 25 KB, accessed at a speed of 1 MHz. The ACE implemented <b>subroutine</b> calls, whereas the EDVAC did not, and the ACE also used Abbreviated Computer Instructions, an early form of programming language.|$|E
40|$|Abstract. This paper {{describes}} Fortran <b>subroutines</b> for computing approximate {{solutions to}} the weighted MAX-SAT problem using a greedy randomized adaptive search procedure (GRASP). The algorithm [Resende, Pitsoulis, and Pardalos, 1997] is briefly outlined and its implementation is discussed. Usage of the <b>subroutines</b> is considered in detail. The <b>subroutines</b> are tested {{on a set of}} test problems, illustrating the tradeoff between running time and solution quality. 1...|$|R
40|$|The paper {{presents}} FORTRAN <b>subroutines</b> {{that can}} perform mathematical operations involving polynomial functions both in symbolic and in exact numerical modes. These <b>subroutines</b> {{may be used}} to perform operations including addition, multiplication, differentiation and integration of polynomial functions. An illustrative example performing various mathematical operations on polynomials has been demonstrated using these <b>subroutines</b> and the results obtained {{have been found to be}} highly accurate. The <b>subroutines</b> should be useful to analysts who require exact (or high precision) solutions to problems having a large number of mathematical operations of polynomial functions, such as in analyses of beam-column and plate structures...|$|R
5000|$|GM-Entrylist.cgi {{is a list}} of all of {{the entries}} and {{information}} about each (time of post, author, and so on). * GM-Karma.cgi contains the <b>subroutines</b> for karma voting. * GM-Library.cgi contains the most used <b>subroutines.</b>|$|R
