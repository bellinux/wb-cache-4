0|2010|Public
40|$|This paper {{presents}} {{a method of}} translating natural language specifications of communication protocols into algebraic specifications. Such a natural language specification specifies action sequences performed by the <b>protocol</b> <b>machine</b> (program). Usually, a sentence implicitly specifies {{the state of the}} <b>protocol</b> <b>machine</b> at which the described actions should be performed. A method of analyzing the implicitly specified states of the <b>protocol</b> <b>machine</b> is proposed taking the OSI <b>session</b> <b>protocol</b> specification (265 sentences) as an example. The method uses the following properties: (a) syntactic properties of a natural language (English in this paper); (b) syntactic properties introduced by the target algebraic specifications, e. g., subtype relations; (c) properties of a data type, e. g., properties of timer. This paper also shows the result of applying this method to {{the main part of the}} OSI <b>session</b> <b>protocol</b> specification (29 paragraphs, 98 sentences). For 95 sentences, the translation system uniquely determines the states specified implicitly by those sentences, using only (a) and (b) described above. By using (c) in addition, each implicitly specified state in the remaining three sentences is uniquely determined. ...|$|R
40|$|This paper {{describes}} an integrated {{set of tools}} for generating application-tailored communication <b>protocol</b> <b>machines.</b> In addition to simplifying the process of generating protocols by automating certain development steps, these tools also facilitate the mapping of platform-independent <b>protocol</b> <b>machines</b> onto several types of multi-processor end-system architectures. An overview of the steps used to generate customized <b>protocol</b> <b>machines</b> is presented {{and a set of}} criteria for characterizing tool behavior are defined. Three distinct classes of tools are examined: (1) configuration tools transform highlevel application specifications into platform-independent <b>protocol</b> <b>machine</b> configurations by selecting and ordering the requisite protocol functions, (2) synthesis tools compose and statically interconnect platform-dependent object-code and data to form executable <b>protocol</b> <b>machine</b> instantiations, and (3) mapping tools place these executable instantiations onto processing elements in the run-ti [...] ...|$|R
50|$|In Case of <b>Session</b> Initiation <b>Protocol</b> Servers(SIP servers), CPL {{has been}} used to control the <b>session</b> <b>protocol</b> based on user defined {{preferences}} for example an incoming call can be authenticated based on user set filters of Address information of called or date/time of the call.|$|R
5000|$|RFC 3485 - The <b>Session</b> Initiation <b>Protocol</b> (SIP) and <b>Session</b> Description <b>Protocol</b> (SDP) Static Dictionary for Signaling Compression (SigComp) ...|$|R
50|$|In {{computer}} networking, the Message <b>Session</b> Relay <b>Protocol</b> (MSRP) is {{a protocol}} for transmitting {{a series of}} related instant messages {{in the context of}} a communications session. An application instantiates the session with the <b>Session</b> Description <b>Protocol</b> (SDP) over <b>Session</b> Initiation <b>Protocol</b> (SIP) or other rendezvous methods.|$|R
5000|$|The NTLM2 <b>Session</b> <b>protocol</b> {{is similar}} to MS-CHAPv2. [...] It {{consists}} of authentication from NTLMv1 combined with session security from NTLMv2.|$|R
50|$|SPDY is a {{versioned}} protocol. In {{its control}} frames there are 15 dedicated bits {{to indicate the}} version of the <b>session</b> <b>protocol.</b>|$|R
5000|$|SIMPLE (instant {{messaging}} <b>protocol)</b> (<b>Session</b> Initiation <b>Protocol</b> for Instant Messaging and Presence Leveraging Extensions) ...|$|R
5000|$|Control of ToIP {{sessions}} {{has been}} defined using the standard <b>Session</b> Initiation <b>Protocol</b> (SIP) (RFC 3261) and the <b>Session</b> Description <b>Protocol</b> (SDP) (RFC 4566) protocols.|$|R
40|$|Bibliography: pages 233 - 235. The CCITT X. 400 Message Handling System {{resides in}} the Application Layer of the seven-layer Reference Model for Open Systems Interconnection. It {{bypasses}} the services of the Presentation Layer completely to interact directly with the Session Layer. The objectives of this thesis are {{to show how the}} general Session Layer may be tailored to be minimally conformant to the requirements of X. 400; to produce a formal specification of this session layer; and to show how this session layer may be implemented on a real system. The session services required by X. 400 are those of the Halfduplex, Minor Synchronization, Exceptions and Activity Management functional units of the CCITT X. 215 Session Service Definition. These services, and particularly their use by X. 400, are described in detail. State tables describing these services are derived from the general session service state tables. Those elements of the CCITT X. 225 <b>Session</b> <b>Protocol</b> Specification which are required to provide only those services required by X. 400 are described in detail. State tables describing this <b>session</b> <b>protocol</b> are derived from the general <b>session</b> <b>protocol</b> state tables. A formal specification of the session layer for X. 400 is presented using the Formal Description Technique Estelle. This specification includes a complete session entity, which characterizes the entire session layer for X. 400. A session entity for supporting X. 400 is partially implemented and interfaced to an existing X. 400 product on a real system. Only the Session Connection Establishment Phase of the <b>session</b> <b>protocol</b> is implemented to illustrate the technique whereby the entire <b>session</b> <b>protocol</b> may be implemented. This implementation uses the C programming language in the UNIX operating system environment...|$|R
40|$|Abstract—The {{mandatory}} {{and most}} deployed authentication method {{used in the}} <b>Session</b> Initiaton <b>Protocol,</b> the Digest Access Authentication method, is weak. Other, more secure authentica-tion methods have emerged, but have seen little adoption yet. In this paper, support for using a generic authentication method, the Generic Security Services API, {{is added to the}} <b>Session</b> Initiaton <b>Protocol.</b> When using this method, the <b>Session</b> Initation <b>Protocol</b> does not need to support nor implement other authentication methods, only use the provided API library. This enables the <b>Session</b> Initiation <b>Protocol</b> to transparently support and use more secure authentication methods in a unified and generic way. As the suggested method includes a modification of the <b>Session</b> Initiation <b>Protocol,</b> an initial deployment strategy towards the Generic Security Services API authentication methods is added. To negotiate an authentication service, we use the pseud...|$|R
5000|$|... {{specification}} {{of the dynamic}} behaviour of interfaces based on finite-state <b>machines</b> (<b>Protocol</b> State <b>Machines,</b> short: PSM) ...|$|R
40|$|In a {{previous}} work, the authors proposed {{a method of}} translating natural language specifications of communication protocols into algebraic axioms in to be compiled into an executable program directly. This paper proposes a method of implementing such logical formulas by executable algebraic specifications called BE programs. The syntax of BE programs resembles the syntax of LOTOS. However, the BE interpreter, which executes a given BE program, has {{a finite number of}} registers and unbounded I/O buffers unlike the concept of processes in LOTOS. Since a natural language specification of a communication protocol often assumes that a <b>protocol</b> <b>machine</b> has regis-ters, the BE interpreter is more appropriate for a model of <b>protocol</b> <b>machines</b> than the concept of processes in LOTOS. In this implementation method, the meaning of each predicate appearing in logical formulas and denoting actions of a <b>protocol</b> <b>machine</b> is defined as a BE program and stored as a “lexical item” of the predicate. Then a BE program for the logical formulas is constructed in a bottom-up manner. The whole translation from natural language specifications of communication protocols into executable specifications is simple and concise, since the BE interpreter is appropriate for a model of <b>protocol</b> <b>machines</b> and the whole translation is defined within a single framework of algebraic specification methods...|$|R
50|$|The <b>Session</b> Initiation <b>Protocol</b> for Instant Messaging and Presence Leveraging Extensions (SIMPLE) is the SIP-based {{suite of}} {{standards}} for instant messaging and presence information. MSRP (Message <b>Session</b> Relay <b>Protocol)</b> allows instant message sessions and file transfer.|$|R
25|$|RTP {{sessions}} are typically initiated between communicating peers using a signaling protocol, such as H.323, the <b>Session</b> Initiation <b>Protocol</b> (SIP), or Jingle (XMPP). These protocols {{may use the}} <b>Session</b> Description <b>Protocol</b> to negotiate the parameters for the sessions.|$|R
50|$|SAP {{typically}} uses <b>Session</b> Description <b>Protocol</b> (SDP) as {{the format}} for Real-time Transport <b>Protocol</b> <b>session</b> descriptions. Announcement data is sent using IP multicast and User Datagram Protocol.|$|R
50|$|DSI {{is never}} {{documented}} separately, and is sufficiently simple and static that older references {{are suitable for}} modern implementations. The concepts of DSI are identical to AppleTalk <b>Session</b> <b>Protocol</b> (ASP), and the overview in Inside AppleTalk, Second Edition can be helpful.|$|R
50|$|HTTP/1.0 {{was thought}} to only allow a single request and {{response}} during one Web/HTTP <b>Session.</b> <b>Protocol</b> version HTTP/1.1 improved this by completing the Common Gateway Interface (CGI), {{making it easier to}} maintain the Web Session and supporting HTTP cookies and file uploads.|$|R
40|$|This {{document}} specifies the mPlane {{architecture and}} protocol. The protocol {{is divided into}} layers: an informaƟon model for mPlanemessages –measurement capabiliƟes, specificaƟons, results, and event noƟficaƟons; a serializaƟon of this informaƟon model using JSON, and a <b>session</b> <b>protocol</b> binding using HTTP over TLS...|$|R
50|$|When Apple {{introduced}} TCP with MacTCP and Open Transport in System 7 in the 1990s, {{they needed}} their file sharing protocol (AFP) {{to run on}} both TCP and AppleTalk. They introduced AppleTalk <b>Session</b> <b>Protocol</b> (ASP) and DSI for TCP coincidentally with AFP 2.x.|$|R
50|$|The 3rd Generation Partnership Project (3GPP) {{defined a}} {{technical}} specification (TS 24.147) for conferencing within the IP Multimedia Subsystem (IMS) {{based on the}} <b>Session</b> Initiation <b>Protocol</b> (SIP), SIP Events, the <b>Session</b> Description <b>Protocol</b> (SDP) and the Binary Floor Control Protocol (BFCP, aka RFC4582).|$|R
40|$|Managing modern {{heterogeneous}} network technologies in a simple, uniform manner {{has become an}} increasingly difficult challenge. To help address this issue, we propose a <b>session</b> layer <b>protocol</b> called the eXtensible <b>Session</b> <b>Protocol</b> (XSP) designed to integrate existing network systems, providing the ability to easily introduce additional protocol functionality as needed, including applicationdriven network allocation and integration with network “middleboxes. ” The XSP implementation is currently targeted at network middleware architectures where it allows for the transparent integration and configuration of new and existing network components and services...|$|R
5000|$|<b>Session</b> Initiation <b>Protocol</b> Standard {{protocol}} for IP-communication ...|$|R
50|$|This ARP {{sequence}} {{can take}} a few seconds, which can in turn introduce noticeable latency, {{at least for the}} first RTP-MIDI packet. However, Apple's implementation solved this issue in an elegant manner, using the <b>session</b> control <b>protocol.</b> The <b>session</b> <b>protocol</b> uses the same ports than the RTP-MIDI protocol itself. The ARP sequence then takes places during the session initiation sequence. When the RTP-MIDI application wants to send the first RTP-MIDI packet, the computer's routing tables are already initialized with the correct destination MAC addresses, which avoids any latency for the first packet.|$|R
5000|$|A <b>Session</b> Initiation <b>Protocol</b> (SIP) based Internet {{phone call}} ...|$|R
5000|$|SDES <b>Session</b> Description <b>Protocol</b> Security Descriptions for Media Streams ...|$|R
5000|$|<b>Session</b> Announcement <b>Protocol</b> (SAP) used to {{discover}} RTP sessions ...|$|R
5000|$|<b>Session</b> Initiation <b>Protocol</b> (SIP) modules (packaged in SAR files); ...|$|R
50|$|The {{presentation}} layer establishes context between application-layer entities, {{in which the}} application-layer entities may use different syntax and semantics if the presentation service provides a mapping between them. If a mapping is available, presentation service data units are encapsulated into <b>session</b> <b>protocol</b> data units and passed down the protocol stack.|$|R
50|$|User-Network: There are {{two parts}} to this {{protocol}}: Session and Resource. This protocol is used between {{the client and}} SRM, and between the server and SRM. The U-N <b>Session</b> <b>protocol</b> is used to establish sessions with the network, associated with resources which are allocated and released using the U-N Resource protocol.|$|R
5000|$|Protocol Data Unit (PDU). The {{string of}} octets {{exchanged}} among the <b>Protocol</b> <b>Machines</b> (PM). PDUs contain two parts: the PCI, which is understood and {{interpreted by the}} DIF, and User-Data, that is incomprehensible to this PM and is passed to its user.|$|R
5000|$|The <b>Session</b> Initiation <b>Protocol</b> (SIP) {{specification}} RFC 2543 is released.|$|R
5000|$|Extensions to the <b>Session</b> Initiation <b>Protocol</b> for the IP Multimedia Subsystem ...|$|R
5000|$|... #Subtitle level 2: IP Audio Broadcasting and SIP (<b>Session</b> Initiation <b>Protocol)</b> ...|$|R
50|$|SDP is {{designed}} to be extensible to support new media types and formats. SDP started off as a component of the <b>Session</b> Announcement <b>Protocol</b> (SAP), but found other uses in conjunction with Real-time Transport Protocol (RTP), Real-time Streaming <b>Protocol</b> (RTSP), <b>Session</b> Initiation <b>Protocol</b> (SIP) and even as a standalone format for describing multicast sessions.|$|R
5000|$|OMA SIMPLE IM Instant {{messaging}} {{based on}} SIP-SIMPLE (see <b>Session</b> Initiation <b>Protocol)</b> ...|$|R
