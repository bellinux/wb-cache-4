0|650|Public
50|$|No.8 :A {{horizontal}} single-cylinder steam engine, bore 1 inch, stroke 1 inch, 8.5 inches long, with <b>slipper</b> <b>type</b> crosshead guide, so {{designed for}} single direction of rotation. This engine {{is listed in}} the 1960s with a trunk type bored crosshead guide.|$|R
40|$|<b>Typed</b> <b>assembly</b> {{languages}} {{provide a}} way to generate machinecheckable safety proofs for machine-language programs. But the soundness proofs of most existing <b>typed</b> <b>assembly</b> languages are hand-written and cannot be machine-checked, which is worrisome for such large calculi. We have designed and implemented a low-level <b>typed</b> <b>assembly</b> language (LTAL) with a semantic model and established its soundness from the model. Compared to existing <b>typed</b> <b>assembly</b> languages, LTAL is more scalable and more secure; it has no macro instructions that hinder low-level optimizations such as instruction scheduling; its type constructors are expressive enough to capture dataflow information, support the compiler's choice of data representations and permit typed position-independent code; and its type-checking algorithm is completely syntax-directed...|$|R
25|$|The second batch, {{numbered}} 146 to 155, {{had similar}} bodies {{built by the}} Brush Electrical Engineering Company Limited of Loughborough, mounted on Brush-built P.22 trucks and with identical equipment to the U.E.C. cars, except for 146, which had a B.T.H electromagnetic brake instead of the air <b>slipper</b> <b>type.</b> All these cars were delivered with roller blind indicators, and gradually, but with no small objection from the travelling public, this type of indicator was fitted to practically all the remaining cars.|$|R
40|$|There is {{a growing}} need to provide low-overhead softwarebased {{protection}} mechanisms to protect against malicious or untrusted code. Type-based approaches such as proof-carrying code and <b>typed</b> <b>assembly</b> language provide this protection by relying on untrusted compilers to certify the safety properties of machine language programs. <b>Typed</b> Module <b>Assembly</b> Language (TMAL) {{is an extension of}} <b>typed</b> <b>assembly</b> language with support for the type-safe manipulation of dynamically linked libraries. A particularly important aspect of TMAL is its support for shared libraries...|$|R
50|$|<b>Typed</b> <b>assembly</b> {{languages}} usually {{include a}} high-level memory management {{system based on}} garbage collection.|$|R
40|$|We {{present a}} dependently <b>typed</b> <b>assembly</b> {{language}} (DTAL) {{in which the}} type system supports {{the use of a}} restricted form of dependent types, reaping some bene ts of dependent <b>types</b> at <b>assembly</b> level. DTAL overcomes several signi cant limitations in recently proposed low-level languages including Java bytecode language and a <b>typed</b> <b>assembly</b> language, which prevent them from handling certain important compiler optimizations such as run-time array bound check elimination. We also mention a compiler which can generate DTAL code from compiling some high-level programs. ...|$|R
40|$|We {{present the}} design of a <b>typed</b> <b>assembly</b> {{language}} called TALT that supports heterogeneous tuples, disjoint sums, and a general account of addressing modes. TALT also implements the von Neumann model in which programs are stored in memory, and supports relative addressing. Type safety for execution and for garbage collection are shown by machine-checkable proofs. TALT is the first formalized <b>typed</b> <b>assembly</b> language to provide any of these features...|$|R
40|$|<b>Typed</b> <b>assembly</b> {{languages}} {{provide a}} way to generate machine-checkable safety proofs for machine-language programs. But the soundness proofs of most existing <b>typed</b> <b>assembly</b> lan-guages are hand-written and cannot be machine-checked, which is worrisome for such large calculi. We have de-signed and implemented a low-level <b>typed</b> <b>assembly</b> language (LTAL) with a semantic model and established its soundness from the model. Compared to existing <b>typed</b> <b>assembly</b> lan-guages, LTAL is more scalable and more secure; it has no macro instructions that hinder low-level optimizations such as instruction scheduling; its type constructors are expres-sive enough to capture data ow information, support the compiler's choice of data representations and permit typed position-independent code; and its type-checking algorithm is completely syntax-directed. We have built a prototype system, based on Standard ML of New Jersey, that compiles most of core ML to Sparc code. We explain how {{we were able to}} make the untyped back end in SML/NJ preserve types during instruction selection and register allocation, without restricting low-level optimiza-tions and without knowledge of any type system pervading the instruction selector and register allocator...|$|R
50|$|A <b>slipper</b> <b>type</b> {{torque wrench}} {{consists}} of a roller and cam (or similar) mechanism. The cam {{is attached to the}} driving head, the roller pushes against the cam locking it in place with a specific force which is provided by a spring (which is in many cases adjustable). If a torque is demanded which is able to defeat the holding force of the roller and spring, the wrench will slip and no torque will be applied to the bolt. A slipper torque wrench will not over tighten the fastener by continuing to apply torque beyond a predetermined limit.|$|R
40|$|We {{present a}} {{comparison}} of semantic and syntactic proof methods for reasoning about <b>typed</b> <b>assembly</b> languages in Coq. We make available our complete Coq developments for a simple and easily understood benchmark system presenting both styles of soundness proof to the same interface. The syntactic proof is standard subject reduction; the semantic proof uses Gödal Löb modal logic, shallowly embedded in Coq. The proof style of the modal logic is flexible and facilitates experimental modifications to the underlying machine. As {{an example of this}} flexibility, we discuss how to add fault tolerance to the list machine. In addition, we discus how the the choice of proof methodology affects the trusted computing base of a <b>typed</b> <b>assembly</b> language system. Keywords: theorem proving, <b>typed</b> <b>assembly</b> language, list-machine benchmark, Co...|$|R
5000|$|... 2008 (for 1998): From System F to <b>Typed</b> <b>Assembly</b> Language, Greg Morrisett, David Walker, Karl Crary, and Neal Glew ...|$|R
50|$|Cognac and pineau {{are two of}} {{the major}} {{agricultural}} products of the region, along with butter. The Charentaise <b>slipper</b> (a <b>type</b> of <b>slipper</b> made from felt and wool) is another well-known traditional product.|$|R
40|$|We study {{information}} flow for a <b>typed</b> <b>assembly</b> language where security types restrict information flow. Inspired by recent work in continuation-based information flow analysis, our language, Secure Information Flow TAL (SIFTAL), uses low-level linear continuations {{in order to}} impose a stack discipline on the control flow of programs. The challenge posed by studying information flow analysis at the assembly language level is many-fold. On the one hand, the well behaved control constructs of high-level languages are not available, and, on the other hand, {{the role of an}} unbounded number of variables is played by a finite number of registers that need to be reused not only with different types, but also with different security levels. Non-interference refers to the desirable property of systems of multilevel security architecture that states that information stored at a high security level does not affect computed low security level values. Our main contributions are a type system for checking that <b>typed</b> <b>assembly</b> language programs enjoy non-interference and its proof of soundness. Furthermore, SIFTAL is the first <b>typed</b> <b>assembly</b> language with security types for information flow analysis, and our proof is the first proof of non-interference for a MIPSstyle <b>typed</b> <b>assembly</b> language. 1...|$|R
5000|$|TILT {{is a full}} {{certifying}} compiler for SML. It uses typed intermediate languages {{to optimize}} code and ensure correctness, and can compile to <b>Typed</b> <b>assembly</b> language.|$|R
40|$|A {{calculus}} for {{dynamic loading}} is presented and proved sound. The calculus extends the polymorphic -calculus with a load primitive that dynamically loads {{terms that are}} closed, with respect to values. The calculus is meant to approximate <b>Typed</b> <b>Assembly</b> Language [3], and thus contains references, and facilities for generative types. Loadable programs may refer to generative types dened by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al [1]. This calculus has been implemented in the TALx 86 [4] version of <b>Typed</b> <b>Assembly</b> Language, and forms {{the foundation of a}} exible and ecient approach to dynamic linking therein. 1 Introduction The purpose of this report is prove the soundness of a simple calculus for dynamic loading, designed as a theoretical basis for dynamic linking in <b>Typed</b> <b>Assembly</b> Language [3, 4, 1]. Dynamic loading is provided by a simple primitive load, which converts the binary represent [...] ...|$|R
40|$|We {{present a}} dependently <b>typed</b> <b>assembly</b> {{language}} (DTAL) {{in which the}} type system supports {{the use of a}} restricted form of dependent types, reaping some benefits of dependent <b>types</b> at the <b>assembly</b> level. DTAL improves upon TAL, enabling certain important compiler optimizations such as run-time array bound check elimination and tag check elimination. Also, DTAL formally addresses the issue of representing sum <b>types</b> at <b>assembly</b> level, making it suitable for handling not only datatypes in ML but also dependent datatypes in Dependent ML (DML) ...|$|R
5000|$|The piston is {{connected}} to the Scotch yoke through a <b>slipper</b> bearing (a <b>type</b> of hydrodynamic tilting-pad fluid bearing) ...|$|R
40|$|We {{present a}} dependently <b>typed</b> <b>assembly</b> {{language}} (DTAL) {{in which the}} type system supports {{the use of a}} restricted form of dependent types, reaping some benefits of dependent <b>types</b> at <b>assembly</b> level. DTAL overcomes several significant limitations in recently proposed low-level languages including Java bytecode language and a <b>typed</b> <b>assembly</b> language, which prevent them from handling certain important compiler optimizations such as run-time array bound check elimination. We also mention a compiler which can generate DTAL code from compiling some high-level programs. 1 Introduction A certifying compiler is one that generates object code that can be readily checked for compliance with a specified safety policy that constrains its run-time behavior. By ensuring that compliance is checkable, the code recipient need not be concerned with the origin of the code, only the (augmented) code itself. Typical safety policies include type safety (which excludes, for examples, programs that attempt to [...] ...|$|R
40|$|<b>Typed</b> <b>assembly</b> {{languages}} usually support heap allocation safely, {{but often}} rely on an external garbage collector to deallocate {{objects from the}} heap and prevent unsafe dangling pointers. Even if the external garbage collector is provably correct, verifying {{the safety of the}} interaction between TAL programs and garbage collection is nontrivial. This paper introduces a <b>typed</b> <b>assembly</b> language whose <b>type</b> system is expressive enough to type-check a Cheney-queue copying garbage collector, so that ordinary programs and garbage collection can co-exist and interact inside a single typed language. The only built-in types for memory are linear types describing individual memory words, so that TAL programmers can define their own object layouts, method table layouts, heap layouts, and memory management techniques. 1...|$|R
5000|$|A <b>typed</b> <b>assembly</b> {{language}} with a suitably expressive type {{system can be}} used to enable the safe execution of untrusted code without using an intermediate representation like bytecode, allowing features similar to those currently provided by virtual machine environments like Java and [...]NET.|$|R
40|$|The LLVM {{compiler}} infrastructure [11] employs {{an intermediate}} representation {{which is similar}} to a <b>typed</b> <b>assembly</b> language. LLVM’s representation is fully typed, RISC-like, has data-flow information in Static Single-Assignment form built-in, and is powerful enough to express any C or C++ program, type-safe o...|$|R
40|$|<b>Typed</b> <b>assembly</b> {{languages}} {{have the}} goal of providing security guarantees, for example, for the limited use of resources in a host machine or the detection of autoupdate code. This work presents a simple <b>typed</b> <b>assembly</b> language which allows us to perform various kinds of static analysis tasks {{with the purpose of}} detecting flaws in the code security. The security policy we use guarantees type and memory safety. Moreover, wa can ensure that non-initialized variables are not read, and that there is no out-of-bound array accesses. The language we present, called STALlion, was designed in order to interpret a particular kind of imperative programs, more specifically abstract syntax tree. Eje: I - Workshop de Ingeniería de Software y Base de Dato...|$|R
40|$|Type-preserving compilers {{translate}} well-typed source code, such as Java or C#, into verifiable target code, such as <b>typed</b> <b>assembly</b> {{language or}} proof-carrying code. This paper presents {{the implementation of}} type-preserving compilation in a complex, large-scale optimizing compiler. Compared to prior work, this implementation supports extensive optimizations, and it verifies {{a large portion of}} the interface between the compiler and the runtime system. This paper demonstrates the practicality of type-preserving compilation in complex optimizing compilers: the generated <b>typed</b> <b>assembly</b> language is only 2. 3 % slower than the base compiler’s generated untyped assembly language, and the type-preserving compiler is 82. 8 % slower than the base compiler. Categories and Subject Descriptors D. 3. 3 [Programming Languages]: Language Constructs and Features—Classes and object...|$|R
40|$|Multi-cellular organisms have {{exploited}} {{a simple}} but powerful design concept: the regular tiling of {{a relatively small number}} of individual cell <b>types</b> yields <b>assemblies</b> with spectacular functional capacity. This capability comes at the cost of substantial complexity in design synthesis and assembly, which nature has addressed via developmental processes and evolutionary search. I will describe my application of these ideas to electromechanical systems, which has led to the development of various electromechanical cell <b>types,</b> <b>assembly</b> strategies, and design synthesis tools inspired by lessons from Ecology and Evolutionary Biology. 2020 - 05 - 2...|$|R
40|$|We {{present the}} load-{{calculus}}, used to model dynamic loading, and prove it sound. The calculus extends the polymorphic #-calculus with a load primitive that dynamically loads {{terms that are}} closed, with respect to values. The calculus is meant to approximate the process of dynamic loading in TAL/Load [4], an version of <b>Typed</b> <b>Assembly</b> Language [7] extending with dynamic linking. To model the key aspects of TAL, the calculus contains references and facilities for named types. Loadable programs may refer to named types defined by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al [3]. This calculus has been implemented in the TALx 86 [6] version of <b>Typed</b> <b>Assembly</b> Language, and is used to implement a full-featured dynamic linking library, DLpop [4]. ...|$|R
40|$|Abstract. In this paper, we {{introduce}} a Foundational Proof-Carrying Code (FPCC) framework for constructing certified code packages from <b>typed</b> <b>assembly</b> language that will interface with a similarly certified runtime system. Our framework permits the <b>typed</b> <b>assembly</b> language {{to have a}} “foreign function ” interface, in which stubs, initially provided when the program is being written, are eventually compiled and linked to code {{that may have been}} written in a language with a different type system, or even certified directly in the FPCC logic using a proof assistant. We have increased the potential scalability and flexibility of our FPCC system by providing a way to integrate programs compiled from different source type systems. In the process, we are explicitly manipulating the interface between Hoare logic and a syntactic type system. ...|$|R
50|$|Twelf {{has been}} used to formalize many {{different}} logics and programming languages (examples are included with the distribution). Among the larger projects are a proof of safety for the Standard ML programming language, a foundational <b>typed</b> <b>assembly</b> language system from CMU, and a foundational proof carrying code system from Princeton.|$|R
40|$|We {{present a}} first-order linearly <b>typed</b> <b>assembly</b> language, HBAL, {{that allows the}} safe reuse of heap space for {{elements}} of di#erent types. The linear types discipline ensures a single pointer property, but disallows aliasing. Since HBAL does not assume an external memory management system, programs run in a bounded amount of heap space...|$|R
40|$|A Calculus for Dynamic Loading We {{present the}} load-{{calculus}}, used to model dynamic loading, and prove it sound. The calculus extends the polymorphic λ-calculus with a load primitive that dynamically loads {{terms that are}} closed, with respect to values. The calculus is meant to approximate the process of dynamic loading in TAL/Load [4], a version of <b>Typed</b> <b>Assembly</b> Language [7] extending with dynamic linking. To model the key aspects of TAL, the calculus contains references and facilities for named types. Loadable programs may refer to named types defined by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al [3]. This calculus has been implemented in the TALx 86 [6] version of <b>Typed</b> <b>Assembly</b> Language, and is used to implement a full-featured dynamic linking library, DLpop [4]...|$|R
40|$|We {{motivate the}} design of a statically <b>typed</b> <b>assembly</b> {{language}} (TAL) and present a type-preserving translation from System F to TAL. The TAL we present is based on a conventional RISC assembly language, but its static type system provides support for enforcing high-level language abstractions, such as closures, tuples, and objects, as well as user-defined abstract data types. The type system ensures that well-typed programs cannot violate these abstractions. In addition, the typing constructs place almost no restrictions on low-level optimizations such as register allocation, instruction selection, or instruction scheduling. Our translation to TAL is specified as a sequence of type-preserving transformations, including CPS and closure conversion phases; type-correct source programs are mapped to type-correct assembly language. A key contribution is an approach to polymorphic closure conversion that is considerably simpler than previous work. The compiler and <b>typed</b> <b>assembly</b> language pro [...] ...|$|R
5000|$|... #Caption: Volkswagen <b>Type</b> 4 <b>assembly</b> line in Wolfsburg as of 1973 ...|$|R
50|$|The center {{also has}} an IRT-2000 pool-type {{research}} reactor, supplied by the Soviet Union in 1963, operational since 1965. The reactor fuel is IRT-2M <b>type</b> <b>assemblies</b> of 36% and 80% highly enriched uranium. As the center has not received fresh fuel since Soviet times, this reactor is now only run occasionally to produce iodine-131 for thyroid cancer radiation therapy.|$|R
40|$|We {{motivate the}} design of a <b>typed</b> <b>assembly</b> {{language}} (TAL) by presenting a type-preserving translation from System F to our TAL. The TAL we present is based on a conventional RISC assembly language, but its static type system ensures that well-typed programs cannot "go wrong. " Furthermore, the type system presented here is sufficiently powerful that we can compile polymorphic, recursive, and higher-order functions; abstract data types; objects; {{and a variety of other}} language mechanisms to highly-optimized but type-correct TAL code. We sketch such a compiler as a sequence of type-directed translations. Inspired by SML/NJ, the compiler uses CPS and closure conversion phases, but unlike SML/NJ, maintains types throughout compilation. In addition, we present an approach to polymorphic closure conversion that is considerably simpler than previous work. The compiler and <b>typed</b> <b>assembly</b> language provide a fully automatic way to produce proof carrying code, suitable for use in systems where unt [...] ...|$|R
40|$|Programs {{written in}} a typed {{language}} are guaranteed to satisfy the safety properties of the type system without runtime checks. A type system for an intermediate language allows static verification of safety properties independent of source languages, and opens up opportunities for advanced compiler optimizations. This paper surveys three major intermediate languages: Java bytecode, <b>typed</b> <b>assembly</b> language and proof-carrying code. Java bytecode requires minimal type annotation but sophisticated verification algorithms. <b>Typed</b> <b>assembly</b> language permits low-level constructs such as registers and instruction blocks, yet still enforces control- flow safety and memory safety. Proof-carrying code provides a general framework for any safety properties definable in a meta-logical framework. We motivate the use of typed intermediate languages, illustrate the type systems of the three languages mentioned above with examples, and compare their tradeoffs of expressiveness versus complexity. Additionally, we {{assess the impact of}} the three languages and identify research directions for future work...|$|R
40|$|In the Fall of 2005, Carnegie Mellon o ered for the rst time {{a course}} on compilers for higher-order, typed {{programming}} languages designed to be accessible for students at both the graduate and undergraduate levels. In its rst iteration, HOT Compilation's projects explored the compilation of Standard ML from elaboration to CPS conversion. With a few notable exceptions, the material in the course was presented very much like System F to <b>Typed</b> <b>Assembly</b> Language " [3], which explicated the translation from a traditional typed lambda calculus to calculi that were each successively closer to real machine code. As part of the independent project component of that course, {{the members of this}} group implemented subsequent phases of the translation down to TAL, such as closure conversion and hoisting of closed functions. However, due to time constraints no student participating in that course completed a full compiler down to executable code. We propose implementing a type-preserving back-end for a HOT Compilation compiler, going from closure converted code to an idealized <b>typed</b> <b>assembly</b> language we will design {{for the purposes of this}} project. Following traditional compiler design principles, we will translate our lowest intermediate language to a version of our <b>typed</b> <b>assembly</b> language with an in nite number of registers. Instruction selection will be a fairly trivial issue, as we intend to have a RISC-like syntax for our assembly language which will align cleanly with most operations extant in the lower intermediate languages. From this point translatin...|$|R
40|$|This paper {{describes}} an algorithm {{developed as a}} decision support system for SMT line operators and its purpose is to suggest changes in an existing feeder setup {{in order to improve}} the production performance. The proposed algorithm based on a relaxed model of the problem uses constraint programming approach and its performance is tested on production trial of one PCB <b>type</b> <b>assembly...</b>|$|R
