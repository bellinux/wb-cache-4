42|83|Public
5000|$|VsEP {{assesses the}} non-auditory {{portions}} of the labyrinth and requires kinematic stimuli (i.e. motion) instead of sound stimuli and bear only a loose relationship to VEMPs. This kinematic stimuli needs to be well characterized, precisely controlled, consistent in amplitude, and consistent in kinematic makeup. An electromechanical shaker is a <b>stimuli</b> <b>generator</b> that is widely available. This shaker provides a transient stimuli, can generate angular or linear acceleration, and can couple to the skull directly (with skull screws) or via a stimulus platform.|$|E
30|$|After the {{accomplishment}} of the first step, the automatic derivation step was conducted. The software architectural description produced in step 1 was used as input for this step, being processed by the model transformation script, delivering a <b>stimuli</b> <b>generator</b> for sensors that compose the FMSoS. At this step, a distinct <b>stimuli</b> <b>generator</b> is produced for each distinct type of constituent. In FMSoS case, three types of <b>stimuli</b> <b>generator</b> are conceived: one <b>stimuli</b> <b>generator</b> for sensors, another one for crowdsourcing systems, and another for drone system. The transformation runs and delivers the code in 2 s. The products of this activity (the stimuli generators themselves) were evaluated using the metrics defined in RQ 1 (similarity and correctness).|$|E
30|$|Reuse: Programming {{the model}} {{transformation}} to automatically produce a <b>stimuli</b> <b>generator</b> by one specialist with integral dedication took 5 days of work (a total of approximately 40 h). Despite {{the learning curve}} associated to DEVS modeling, Xtend programming, and domain-specific knowledge to adapt model transformations, the model transformation can be reused in a myriad of other domains. Producing a <b>stimuli</b> <b>generator</b> {{for each type of}} constituent of a SoS takes the same amount of time. The same specialist that produced the model transformation also produced an operational <b>stimuli</b> <b>generator</b> to realize the final format that should be achieved.|$|E
30|$|Stimuli-SoS workflow: <b>Stimuli</b> <b>generators</b> are {{produced}} using a SoS software architecture description as input, following well-defined systematic steps that achieve {{the production of}} functional <b>stimuli</b> <b>generators</b> deployed in a simulation. The proposed workflow is also a contribution of our work, as it exhibits potential to be reproduced in other scenarios and contributes by prescribing how to produce this type of simulation structure.|$|R
30|$|We run {{simulations}} of a SoS architectural configuration with 69 constituent systems, i.e., 42 sensors, 9 crowdsourcing systems, and 18 drones. <b>Stimuli</b> <b>generators</b> were automatically generated {{for each type}} of constituent. These <b>stimuli</b> <b>generators</b> were capable of receiving the input data from the database and generating the expected stimuli for the constituents, allowing to simulate constituent systems interoperations into the flood monitoring SoS. Using Stimuli-SoS, we simulated 38 days of flood monitoring in little more than 6 h. <b>Stimuli</b> <b>generators</b> correctly forwarded data to the simulation, which was able to reproduce 29 flood alerts triggered by the SoS during a flooding event. In particular, Stimuli-SoS is almost 65 times more productive than a manual approach to producing data for the same type of simulation.|$|R
30|$|We {{established}} a model-based approach termed Stimuli-SoS {{to support the}} creation of <b>stimuli</b> <b>generators</b> {{to be used in}} SoS simulations. Stimuli-SoS uses software architecture descriptions for automating the creation of such generators. Specifically, this approach transforms SoSADL, a formal architectural description language for SoS, into dynamic models expressed in DEVS, a simulation formalism. We carried out a case study in which Stimuli-SoS was used to automatically produce <b>stimuli</b> <b>generators</b> for a simulation of a flood monitoring SoS.|$|R
30|$|Listing 2 {{shows the}} code in DEVS that {{specifies}} {{part of the}} <b>stimuli</b> <b>generator</b> produced using our approach. The <b>stimuli</b> <b>generator</b> is created {{not only with the}} automaton that guides its operation, but also with specification of ports, data types, and all the apparatus necessary to make it executable and to enable the execution of the target simulation (some parts are hidden for the reader convenience). In listing 2, the <b>stimuli</b> <b>generator</b> has four output ports (lines 1 to 4) that delivers the collection of the geographic positions (coordinate), power threshold, power level (battery energy), and the water level sensed by sensors.|$|E
40|$|The {{purpose of}} this report is to {{implement}} and evaluate parts of the simulation software used in the SoCBUS project. In order to complete and evaluate the entire software package, a traffic model and a <b>stimuli</b> <b>generator</b> must be implemented. They are implemented and evaluated together with the entire simulator software. The purpose of the Traffic model is to model communication traffic as good and descriptive as possible. The output of the Traffic model is called a test case, which works as input for the <b>Stimuli</b> <b>generator.</b> The <b>Stimuli</b> <b>generator</b> computes and creates an event list for the Simulator. This report will investigate and motivate the presented traffic model and <b>stimuli</b> <b>generator</b> in detail. The simulator software is then tested with two separate test cases in order to investigate if the simulator software works properly. The results are promising and the simulator software behaves as expected...|$|E
40|$|International audienceAmong other applications, {{programmable}} oscillators {{are used}} to generate patterns for analogue and mixed-signal built-in self-test. The switched-capacitor multi-mode <b>stimuli</b> <b>generator</b> presented in this work associates programmability to lower area overheads. The type of signal (pulse, ramp or sinewave), the amplitude {{and the frequency of}} oscillation can be easily programmed. The <b>stimuli</b> <b>generator</b> is expected to alleviate surface penalties, because digital programming of the oscillation frequency can be achieved by changing the switching frequency using an embedded frequency divider. Experimental results involving a giquad filter show that a very high fault coverage can be obtained in both transient and multifrequency modes of the <b>stimuli</b> <b>generator...</b>|$|E
3000|$|Automatic {{derivation}} of stimuli generators: This activity comprises {{running the}} model transformation, receiving SoSADL work products as inputs, and delivering DEVS files as outputs, including the <b>stimuli</b> <b>generators</b> [...]...|$|R
30|$|In this scenario, <b>stimuli</b> <b>generators</b> {{can support}} SoS {{simulation}}. They {{consist of a}} virtual simulation entity responsible for {{playing the role of}} the environment, delivering input to a SoS [18].|$|R
30|$|Goal: The {{goal is to}} {{evaluate}} with regard to its correctness if <b>stimuli</b> <b>generators</b> automatically produced are able to trigger and feed a simulation {{until the end of}} its execution.|$|R
3000|$|Adoption of stimuli generator: Does the {{approach}} adopt <b>stimuli</b> <b>generator</b> as the technique to inject inputs into the simulation? [...]...|$|E
30|$|Rationale. The aim of a <b>stimuli</b> <b>generator</b> is {{supporting}} a simulation with a continuous emission of stimuli {{that keep the}} simulation running.|$|E
30|$|After the {{automatic}} derivation, the <b>stimuli</b> <b>generator</b> must be {{deployed in the}} simulation code specified in DEVS and already deployed in MS 4 ME environment. This step consists of moving the <b>stimuli</b> <b>generator</b> file to the simulation project in MS 4 ME environment. MS 4 ME environment automatically generates a Java file that corresponds to the execution entity of each <b>stimuli</b> <b>generator.</b> The SoS architectural description in DEVS is also adapted to include stimuli generators and to specify that they must emit data to their corresponding constituents, that is, those that hold environment connections that were used as input to produce the respective stimuli generators. Figure  3 illustrates an example of FMSoS architecture during simulation. Mediators enable transmission of data received by sensors from stimuli generators until the nearest gateway. This activity was evaluated by checking if, after deployed, the simulation become executable.|$|E
30|$|We report {{our results}} {{based on the}} steps {{systematically}} followed to achieve the derivation of the <b>stimuli</b> <b>generators</b> for FMSoS constituents. A video shows {{a summary of the}} entire procedure 18.|$|R
3000|$|... 20 We do {{not discuss}} this {{mechanism}} with details in this paper, since {{the focus is}} the representation and derivation of a <b>stimulus</b> <b>generator.</b> Other details are discussed in a forthcoming paper.|$|R
30|$|Regarding other threats, we can {{mention the}} {{possibility}} of failures if the SoS architect does not qualify the environment connections in SoSADL with the keyword environment. If it occurs, simulation can fail because expected input can be never received. Indeed, any error regarding the declaration of environment connections at design time can affect the final simulation. Moreover, more accurate evaluation in larger contexts and applications are still required. Our approach was evaluated in regards to its success to support automatic production of <b>stimuli</b> <b>generators</b> that can correctly (i) reproduce the surrounding environment and constituents operational conditions. Considering that we use a software architecture description as the basis to produce <b>stimuli</b> <b>generators,</b> if the software architecture is not faithfully described, the <b>stimuli</b> <b>generators</b> created can not be correctly produced. We relieved this threat by submitting the software architecture description to a specialist. Another threat to validity is the correctness of the model transformation. To minimize {{the impact of this}} threat, a specialist conducted a manual inspection and carefully evaluated if each transformation rule produced exactly the expected output considering each input given.|$|R
30|$|Our {{approach}} {{succeeded in}} automatically deriving a functional <b>stimuli</b> <b>generator</b> that can reproduce environmental conditions for simulating a SoS. In particular, we presented new contributions regarding productivity and automation {{for the use}} of a model-based approach in SoS engineering.|$|E
30|$|Rationale: {{they receive}} battery level and power threshold, and a {{coordinate}} {{to start their}} work. After that, the <b>stimuli</b> <b>generator</b> will deliver water level to them, imitating {{the data obtained by}} sensors to verify if the SoS will detect possible floods.|$|E
30|$|Execution and {{monitoring}} of simulation: This activity uses the <b>stimuli</b> <b>generator</b> and collects {{data from the}} simulation to observe emergent behaviors, to perform statistical analysis and to collect evidence for validation and verification of properties of the SoS software architecture.|$|E
30|$|Rationale. This {{question}} establishes {{whether or}} not the <b>stimuli</b> <b>generators</b> automatically generated are functional, that is, if they can work into the context of a simulation after deployed, exactly how they were created, without any manual intervention or modification.|$|R
3000|$|Inclusion of <b>stimuli</b> <b>generators</b> in {{the target}} {{simulation}} model: After delivering the DEVS files, they must {{be included in a}} project that is deployed in MS 4 ME tool to support the launching and execution of the simulation; and [...]...|$|R
30|$|Potential {{applications}} and forthcoming investigation can be conducted {{relying on the}} advances produced by our research. Co-simulation, for instance, is an important but significant challenge. It exhibits the potential to establish a communication between industrial simulators. However, even for the context of simulation of single subsystems that compose a whole monolithic system, co-simulation is still a matter of investigation [41, 73]. <b>Stimuli</b> <b>generators</b> {{have the potential to}} be the interface that enables receiving the injection of values from industrial simulators. The automatic derivation of these <b>stimuli</b> <b>generators</b> from software architectural descriptions of SoS with support for environment modeling may enhance the fidelity of the code generated and the proximity with the environmental modeling provided by industrial simulators.|$|R
30|$|Listing 1 {{shows an}} excerpt of a code in SoSADL that depicts part of the {{specification}} of one constituent: in this case, a sensor Additional file  1. Some parts are hidden {{because they do not}} influence in the derivation of stimuli generation. It is possible to see, for example, that the gate energy offers two environment connections (lines 12 and 13): one to receive a threshold (a limit of energy that is considered enough to keep the sensor in operation), and power, which is used to receive the level of battery available. A connection in SoSADL has a name and a data type that can be transferred through that communication channel. Then, when a connection is specified with the environment modifier, it actually models what is expected to be received from the environment and the data type expected. Each type of constituent requires a different <b>stimuli</b> <b>generator.</b> Then, such architectural model is used as an input for a model transformation that collects the set of environment connections, extracting the data type, and creating one respective output state transition for each one of them. These state transitions are assembled in sequence to form an entire state diagram that will drive the <b>stimuli</b> <b>generator</b> operation. Then, each state transition will deliver one of the expected data to the correspondent constituent whose architectural specification model was used to create that <b>stimuli</b> <b>generator.</b> Each <b>stimuli</b> <b>generator</b> is associated to a data flow that receives data from a textual file. That file holds the data that feeds the constituent. Then, these data are read from the text file and sent to the constituent, triggering the simulation to run. This happens in a periodic and constant rhythm so as to keep the simulation running.|$|E
30|$|Our {{approach}} also {{exhibits a}} {{potential to become}} an architectural pattern for modeling of simulations. As stimulating a simulation is a recurrent problem, we can establish a <b>stimuli</b> <b>generator</b> as a systematic and repetitive solution that can be adapted according to {{the context in which}} it will be applied.|$|E
30|$|Developing stimuli {{generators}} {{require a}} careful investigation of SoS requirements and architecture specification to elicit which stimuli should be provided. Such tasks can bring additional {{cost to the}} SoS development and might be error-prone when a manual approach is used to transform architectural elements in software code. Moreover, <b>stimuli</b> <b>generator</b> {{can be used as}} an interface between the simulator actually employed and other industrial simulators used to imitate real environments, such as flight simulators, or a river simulation for flood monitoring SoS. This association between two types of simulator is known as co-simulation [40, 41]. This approach is broadly adopted by the industry to a large-scale test. Meanwhile, despite the potential of stimuli generators to support co-simulation approaches in SoS development, such approaches for automatically creating this <b>stimuli</b> <b>generator</b> for simulation of SoS have not been widely investigated.|$|E
30|$|However, as SoSADL is not {{executable}} yet, {{we needed}} to combine SoSADL with the simulation formalism that matched {{the majority of our}} requirements and complemented the characteristics not covered by SoSADL. SosADL holds the environment description, whilst a simulation formalism run the <b>stimuli</b> <b>generators</b> created.|$|R
40|$|Abstract—The neural {{stimulation}} {{has been gaining}} much interest in neuromodulation research and clinical trials. For efficiency, {{there is a need}} for variable electrical stimulation such as current and voltage stimuli as well as wireless framework. In this regard, we develop the wireless neural stimulator capable of voltage and current stimuli. The system consists of ZigBee which is a wireless communication module and <b>stimulus</b> <b>generator.</b> The <b>stimulus</b> <b>generator</b> with 8 -bits resolution enable both mono-polar and bi-polar waveform in voltage (- 3. 3 ~ 3. 3 V) and current (- 330 ~ 330 µA) stimulus mode which is controllable. The experimental results suggest that the proposed neural stimulator can play a role as an effective approach for neuromodulation. Keywords—Neural stimulator, current stimulation, voltage stimulation, neuromodulation. I...|$|R
40|$|This paper proposes an Oscillation BIST (OBIST) that {{is meant}} to test ADCs {{fabricated}} in sub 100 nm processes. The design {{is intended to be}} capable of testing a 10 -bit ADC that was designed in 40 nm CMOS. The design scheme presents a simple analog <b>stimulus</b> <b>generator</b> that was designed in 40 nm CMOS together with schematic based simulation results. There is also a description of a calibration circuit and a highlevel implementation of a BIST control system to run the BIST and to calculate static parameters such as Differential Non-linearity (DNL) and Integral Non-linearity (INL). Simulation results for the analog <b>stimulus</b> <b>generator</b> suggest that OBIST might still be a viable method to test ADCs despite device scaling to sub 100 nm processes...|$|R
30|$|SoSADL {{models are}} {{analyzed}} by the transformation algorithm, searching for environment connections. Each connection specified as an environment connection (underlined in Fig.  7) produces one transition in the specification {{of the state}} diagram in the resulting <b>stimuli</b> <b>generator.</b> Hence, the <b>stimuli</b> <b>generator</b> consists of a special type of model that has a continuous behavior (a behavior materialized as a loop) to emit stimuli by output state transitions, starting and maintaining the SoS operation. Figure  7 depicts a state diagram equivalent that is created with state transitions created to deliver each {{of one of the}} connection data types underlined. It delivers the aforementioned data and comes back to the state s 0, forming a loop that continuously offer stimuli for SoS simulation. Order is not important, as constituents are only triggered when the data received matches the input data expected in the state transition in which its operation is at that moment.|$|E
30|$|Connections {{are read}} from the text file and analyzed. Such {{connections}} are parsed from the architectural description of the SoS {{to be in the}} following format: measurement::sense;RawData-true. This first part {{is the name of the}} gate in which the connection has been specified. The second part is the name of the connection. The third part represents the data type that can be transferred across that communication channel. The last part of each connections descriptions is a boolean: it has a true value if the connection is of the type environment and false if it is not. The transformation algorithm searches for environment connections. Each connection specified as an environment connection produces one transition in the specification of the state diagram in the resulting <b>stimuli</b> <b>generator.</b> Hence, the <b>stimuli</b> <b>generator</b> consists of a special type of system (in the context of the simulation) that has a continuous behavior (a behavior materialized as a loop) to emit stimulus by output state transitions, starting and keeping the SoS in operation.|$|E
30|$|The {{development}} of stimuli generators for simulation purposes {{is not a}} new trend [35, 37, 38]. Initiatives have investigated the adoption of stimuli generators for hardware benchmarking. For example, Al-Hashimi [37] describes the use of stimuli generators to produce digital input signals for simulation purposes of analogic-digital systems. Kitchen and Kuehlmann present an approach to stimulate simulations of hardware with a <b>stimuli</b> <b>generator</b> that performs a random generation of input stimuli that obey a set of declaratively specified input constraints. Rahman and Lombigit [33] describe the {{development of}} a software that systematically generates stimulus required for code simulation (functional and timing) of new digital processors in gamma spectroscopy system. Yang et al. [35] adopts simulations for verification purposes to evaluate the correctness of system-on-chips. They apply <b>stimuli</b> <b>generator</b> to offer a broader coverage of test cases aiming to confirm the correctness of the chip operation. Thus, they do not work on top of software architectures, automating only the generation of the stimuli but not the infrastructure that will forward stimuli to the simulation.|$|E
30|$|Yes. The <b>stimuli</b> <b>generators</b> were {{analyzed}} by a specialist that agreed that it contains all necessary structures to deliver the expected behavior. Moreover, we observed their behavior during the simulation execution, and the data that arrived in the gateways. Of the data, 100 % were correctly delivered to the simulation.|$|R
30|$|Simulations {{have been}} {{recognized}} as source of empirical evidences for software engineering [63]. Hence, the adoption of our approach can leverage the research on empirical software engineering supported by simulations. Adopting our approach can aid in the automation of simulation-based studies, deriving <b>stimuli</b> <b>generators</b> to be applied during the simulation operation.|$|R
30|$|Considering these {{previous}} works, {{there is}} a gap regarding the automatic derivation of <b>stimuli</b> <b>generators</b> based on software architectural descriptions of SoS. Our approach bridges these gaps and contributes by advancing {{the state of the}} art about simulation of software architectures of SoS. The next section discusses threats to validity.|$|R
