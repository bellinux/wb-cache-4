1313|553|Public
2500|$|There {{are various}} notions of a flow {{function}} {{that can be}} defined in a flow graph. Flow functions model the net flow of units between pairs of nodes, and are useful when asking questions such as what is {{the maximum number of}} units that can be transferred from the source node s to the <b>sink</b> <b>node</b> t? The simplest example of a flow function is [...] known as a pseudo-flow.|$|E
5000|$|... (4) Flow {{conservation}} at the destination: A flow must enter its <b>sink</b> <b>node</b> completely.|$|E
5000|$|Inputs Given a Network [...] with flow {{capacity}} , a source node , and a <b>sink</b> <b>node</b> ...|$|E
3000|$|We have {{a source}} node S, {{a set of}} relay nodes R, {{and a set of}} <b>sink</b> <b>nodes</b> D. Assume that S has n packets to {{transmit}} to corresponding <b>sink</b> <b>nodes</b> (i.e., S [...]...|$|R
30|$|In[6], initially, an {{inversely}} proportional effect between the power usage {{and the number}} of base stations is demonstrated. However, when the network becomes saturated with more <b>sink</b> <b>nodes,</b> the added <b>sink</b> <b>nodes</b> yield smaller power savings.|$|R
30|$|The last {{solution}} requires less memory usage, less {{processing and}} less {{communication in the}} different sinks. This solution constructs a DODAG where the level 0 exists of a virtual node and the level 1 exists of all the <b>sink</b> <b>nodes.</b> If the <b>sinks</b> are positioned as good as possible, the load and nodes are divided between the different <b>sink</b> <b>nodes.</b> However, some extra communication is needed to synchronise the different <b>sink</b> <b>nodes.</b>|$|R
5000|$|Add a <b>sink</b> <b>node</b> [...] and add edges {{from all}} villages [...] to [...] with {{capacity}} [...] where [...] is the demand rate of village [...]|$|E
5000|$|An output or <b>sink</b> <b>node</b> {{has only}} {{incoming}} branches (represents a dependent variable). Although any node {{can be an}} output, explicit output nodes are often used to provide clarity. Explicit output nodes are characterized by having one or more attached arrows pointing into the node and no arrows pointing away from the node. Explicit output nodes are not required.|$|E
50|$|There {{are various}} notions of a flow {{function}} {{that can be}} defined in a flow graph. Flow functions model the net flow of units between pairs of nodes, and are useful when asking questions such as what is {{the maximum number of}} units that can be transferred from the source node s to the <b>sink</b> <b>node</b> t? The simplest example of a flow function is known as a pseudo-flow.|$|E
3000|$|... as its {{internal}} timer value. A relay node whose internal timer expires first broadcasts {{a signal to}} neighbor relays to stop their transmission to reserve the channel, which is a first-come-first-serve policy. The <b>sink</b> <b>nodes</b> that successfully overhear the network-coded packets decode the packets using theirs own stored data and update their decoding results. After that, the <b>sink</b> <b>nodes</b> transmit report packets again. Until {{there are no more}} packets to be delivered from the relay <b>nodes</b> to the <b>sink</b> <b>nodes,</b> the procedure is repeated.|$|R
40|$|Part 1 : Decision Support Systems, Intelligent Systems and Artificial Intelligence ApplicationsInternational audienceWater quality {{information}} collection {{is an important}} part of factory aquaculture. This paper proposes a kind of wireless <b>sink</b> <b>nodes</b> using information fusion for water {{quality information}} collection in factory aquaculture. In the <b>sink</b> <b>nodes,</b> Support Vector Regression and fuzzy algorithmic approach are used for information fusion. Making decisions according to information fusion, it converts the collected water quality information into a simple parameter that signified the current state of water quality. The <b>sink</b> <b>nodes</b> can eliminate redundant information, reduce information transmission, thus save energy effectively and prolong the network life...|$|R
40|$|Due to {{the battery}} {{resource}} constraint, it {{is a critical}} issue to save energy in wireless sensor networks, particularly in large sensor networks. One possible solution is to deploy multiple <b>sink</b> <b>nodes</b> simultaneously. In this paper, we propose a protocol called MRMS (Multipath Routing in large scale sensor networks with Multiple <b>Sink</b> <b>nodes)</b> which incorporates multiple <b>sink</b> <b>nodes,</b> a new path cost metric for improving path selection, dynamic cluster maintenance and path switching to improve energy efficiency. MRMS is shown to increase the lifetime of sensor nodes substantially compared to other algorithms based {{on a series of}} simulation experiments. 1...|$|R
50|$|NOM {{is a new}} {{approach}} to the problem of automatic search of mathematical equations. The researcher defines the sets of operations, variables and parameters. The computer program generates a number of mathematical equations that satisfy given restrictions. Then the optimization algorithm finds the structure of appropriate mathematical expression and its parameters.Network operator is a directed graph that corresponds to some mathematical expressions. Every source nodes of the graph are variables or constants of mathematical expression, inner nodes correspond to binary operations and edges correspond to unary operations. The calculation’s result of mathematical expression is kept in the last <b>sink</b> <b>node.</b>|$|E
50|$|In the figure, {{a simple}} block diagram for a {{feedback}} system is shown with two possible interpretations as a signal-flow graph. The input R(s) is the Laplace-transformed input signal; it is shown {{as a source}} node in the signal-flow graph (a source node has no input edges). The output signal C(s) is the Laplace-transformed output variable. It is represented as a <b>sink</b> <b>node</b> in the flow diagram (a sink has no output edges). G(s) and H(s) are transfer functions, with H(s) serving to feed back {{a modified version of}} the output to the input, B(s). The two flow graph representations are equivalent.|$|E
5000|$|... {{algorithm}} ford-fulkerson is input: Graph G with {{flow capacity}} c, [...] source node s, [...] <b>sink</b> <b>node</b> t output: Flow f such that f is maximal from s to t [...] (Note that f(u,v) is the flow from node u to node v, and c(u,v) is the flow capacity from node u to node v) [...] for each edge (u, v) in GE do f(u, v) &larr; 0 f(v, u) &larr; 0 [...] while {{there exists a}} path p from s to t in the residual network Gf do let cf be the flow capacity of the residual network Gf cf(p) &larr; min{cf(u, v) | (u, v) in p} for each edge (u, v) in p do f(u, v) &larr; f(u, v) + cf(p) f(v, u) &larr; &minus;f(u, v) [...] return f ...|$|E
30|$|These methods, however, {{cannot be}} used by <b>sink</b> <b>nodes</b> {{on-the-fly}} during network operation, since they require {{a huge amount of}} computation which <b>sink</b> <b>nodes</b> cannot achieve with the current technology. In this chapter, we want to present algorithms that do not require too much complexity, but still achieve considerable lifetime improvement compared to random movement and static-sink cases.|$|R
30|$|The {{network has}} a single source node and it can have one or more <b>sink</b> <b>nodes.</b>|$|R
50|$|The multi-commodity flow {{problem is}} a network flow problem with {{multiple}} commodities (flow demands) between different source and <b>sink</b> <b>nodes.</b>|$|R
5000|$|Let G = (V, E) be {{a network}} with s,t ∈ V being {{the source and}} the sink respectively. One adds a game node {i,j} with i < j to V, and connects each of them from s by an edge with {{capacity}} rij - which represents the number of plays between these two teams. We also add a team node for each team and connect each game node {i,j} with two team nodes i and j to ensure one of them wins. One {{does not need to}} restrict the flow value on these edges. Finally, edges are made from team node i to the <b>sink</b> <b>node</b> t and the capacity of wk+rk-wi is set to prevent team i from winning more than wk+rk.Let S be the set of all teams participating in the league and let [...] In this method it is claimed team k is not eliminated if and only if a flow value of size r(S − {k}) exists in network G. In the mentioned article it is proved that this flow value is the maximum flow value from s to t.|$|E
30|$|The {{reason why}} Droptimeout and DropTTL {{increase}} {{is that the}} sensor node that is deployed around the failed <b>sink</b> <b>node</b> keeps sending data in upstream routing to the failed <b>sink</b> <b>node</b> until potential fields converge. When a neighbor node of the failed <b>sink</b> <b>node</b> has data in upstream routing, the node waits for an ID message from the failed <b>sink</b> <b>node.</b> Because the failed <b>sink</b> <b>node</b> cannot send an ID message, the neighbor node of the failed <b>sink</b> <b>node</b> drops the data owing to timeout.|$|E
30|$|The Classifier <b>sink</b> <b>node</b> is {{the second}} {{component}} in the second layer of the proposed management system, see Fig.  2. This <b>sink</b> <b>node</b> is found behind the Manager <b>sink</b> <b>node.</b> The job of the Classifier <b>sink</b> <b>node</b> is to rearrange and mark the information of sensors which are located in its Manager <b>sink</b> <b>node</b> area. Also, it should {{have the ability to}} differentiate between each type of data (i.e., multimedia, text, or image). The specs of the Classifier <b>sink</b> <b>node</b> are high buffer capacity and suitable processing power.|$|E
30|$|Broadcasting {{nature of}} {{wireless}} communications {{makes it possible}} to apply opportunistic network coding (OPNC) by overhearing transmitted packets from a source to <b>sink</b> <b>nodes.</b> However, it is difficult to apply network coding to the topology of multiple relay and <b>sink</b> <b>nodes.</b> We propose to use relay node selection, which finds a proper node for network coding since the OPNC alone in the topology of multiple relays and <b>sink</b> <b>nodes</b> cannot guarantee network coding gain. The proposed system is a novel combination of wireless network coding and relay selection. In this paper, with the consideration of channel state and potential network coding gain, we propose several relay node selection techniques that have performance gain over the conventional OPNC and the conventional channel-based selection algorithm in terms of average system throughput.|$|R
40|$|This paper {{considers}} a special class of wiretap networks {{with a single}} source <b>node</b> and K <b>sink</b> <b>nodes.</b> The source message is encoded into a binary digital sequence of length N, divided into K subsequences, {{and sent to the}} K <b>sink</b> <b>nodes</b> respectively through noiseless channels. The legitimate receivers are able to obtain subsequences from arbitrary μ 1 = K α 1 <b>sink</b> <b>nodes.</b> Meanwhile, there exist eavesdroppers who are able to observe subsequences from arbitrary μ 2 = K α 2 <b>sink</b> <b>nodes,</b> where 0 ≤ α 2 < α 1 ≤ 1. The goal is to let the receivers be able to recover the source message with a vanishing decoding error probability, and keep the eavesdroppers ignorant about the source message. It is clear that the communication model is an extension of wiretap channel II. Secrecy capacity with respect to the strong secrecy criterion is established. In the proof of the direct part, a codebook is generated by a randomized scheme and partitioned by Csiszár’s almost independent coloring scheme. Unlike the linear network coding schemes, our coding scheme is working on the binary field and hence independent of the scale of the network...|$|R
40|$|Mobile sensor {{networks}} are desirable {{in a variety}} of application scenarios, in which information collection is no doubt of great importance. In this paper, we present a mobile sensor network architecture consisting of a potentially large number of mobile sensors and a single or multiple stationary <b>sink</b> <b>nodes</b> for sensing information collection. We formulate a distinct coverage measurement problem in term of sensing information collection; we study the relevant performance and examine the effect from a variety of relevant factors through extensive simulations. We demonstrate that the performance is not only affected by the sensor mobility and the transmission range between mobile sensors and <b>sink</b> <b>node(s),</b> but also by the distribution of mobile sensors and the number and locations of <b>sink</b> <b>nodes.</b> Based on the observation and analysis, we also provide some preliminary understandings and implications for improving the information collection performance. 1...|$|R
30|$|Strategy 2 : The sensors {{send their}} {{reports to the}} Manager <b>sink</b> <b>node.</b> Hence, the Manager <b>sink</b> <b>node</b> multicasts its report to the Classifier and the Prioritizer sink nodes. Consequently, each <b>sink</b> <b>node</b> in the Multi-Functional layer (Manager, Classifier, and Prioritizer) sends its report to the upper layer (General <b>sink</b> <b>node),</b> see Fig.  3.|$|E
30|$|The Manager <b>sink</b> <b>node</b> is {{the first}} {{component}} in the second layer of the proposed management system. The Manager <b>sink</b> <b>node</b> is considered as a head of sensors cluster. The job of the Manager <b>sink</b> <b>node</b> is to collect reports sent from the sensors in its cluster. Hence, it analyzes these reports and merges them in one report. Consequently, it should send this collective report to the General <b>sink</b> <b>node</b> in the upper layer. The main specifications, which should be required in the Manager <b>sink</b> <b>node,</b> are sufficient buffer space and powerful central processing unit (but not as powerful as the General <b>sink</b> <b>node).</b>|$|E
30|$|The Prioritizer <b>sink</b> <b>node</b> is {{the third}} {{component}} in the second layer of the proposed management system. The job of this <b>sink</b> <b>node</b> {{is to determine the}} data that should be transmitted firstly especially in case of WSN starvation. The specs of this node are high buffer capacity and powerful processing unit. This <b>sink</b> <b>node</b> works on the reports which are received from the Manager <b>sink</b> <b>node.</b>|$|E
40|$|Due to {{the fact}} that it plays an {{important}} role to improve the connectivity and coverage of Wireless Sensor Networks, it is considered to be efficient to improve the coverage by artificially deploying the critical <b>Sink</b> <b>nodes.</b> In this paper, we use Particle Swarm Optimizer algorithm to find out the best position of <b>sink</b> <b>nodes</b> deployment in the whole network area and then optimize the Wireless Sensor Network by adding <b>sink</b> <b>nodes</b> after generating a quantity of nodes to constitute Wireless Sensor Networks at random. Hereafter, by simulation based on a random network to prove that: (1) intelligent algorithms are worthy of considering and efficiently to be utilized in the network topological deployment and keeping the network integrity, (2) the Partial Swarm Optimization is much algorithmically easier and reliable, (3) Intelligent computation is a kind of optimal methodology to improve the network integrity...|$|R
30|$|In our {{proposed}} method, {{at least}} three <b>sink</b> <b>nodes</b> must be deployed in the sensing area. To identify each sensor node, a virtual coordinate needs to be assigned to a sensor node uniquely. When less than three <b>sink</b> <b>nodes</b> are deployed {{and each of them}} constructs its own potential field, some sensor nodes may have the same virtual coordinate because our method is based on a theory of triangulation. In such a case, data may be routed to a sensor node that is not a destination node.|$|R
30|$|Moving <b>sink</b> <b>nodes</b> (base {{stations}} or mobile agents) {{is among}} the most effective solutions to improve network lifetime in wireless sensor networks (WSNs) where sinks can move [1]. This approach aims to solve the so called hot-spot problem in a WSN, in which first-hop neighbors of sinks suffer from quick energy depletion due to a high rate of message forwarding [2]. In order to distribute traffic forwarding load as evenly as possible among all sensor <b>nodes,</b> <b>sinks</b> can be moved through the region so that all sensor nodes have nearly equal chance of being the first-hop neighbors of <b>sinks</b> <b>nodes.</b> In this way, data is collected in a mobile manner.|$|R
30|$|To clarify how our {{proposed}} system works, {{two directions}} should be studied intensively. The first direction {{consists of two}} connection types: one from the lower level layer (the Sensor layer) and Multi-Functional layer. The other connection is from the Multi-Functional layer to the General <b>sink</b> <b>node</b> layer. The model scenario starts as follows: sensors are clustered into groups and the collected environmental data are sent to the Manager <b>sink</b> <b>node</b> [48]. Hence, the Manager <b>sink</b> <b>node</b> collects and filters the sensors messages. The Manager filtering process separates the correct data from the corrupted data which decreases the WSN overload. Correspondingly, it collects the correct data in one report. The filtering process uses the scheme stated in [49] {{that is based on}} statistical data analysis for periodically aggregates sensors’ survival massages to detect failure nodes and their corrupted data. The Manager <b>sink</b> <b>node</b> sends a copy from its cumulative report to the Classifier <b>sink</b> <b>node.</b> The Classifier node signs each data depending on its type. Hence, easily, it can separate each data type in one group, which helps the entire system to send special required information in a specific time. To accomplish this job, the classifier uses the technique presented in [50]. Furthermore, the Manager <b>sink</b> <b>node</b> sends a copy from its report to the Prioritizer <b>sink</b> <b>node.</b> The Prioritizer <b>sink</b> <b>node</b> determines the data which should be sent firstly. These data can be determined as regards some parameters such as the WSN throughput, available component power, and importance of transmitted data which can be defined from the system feedback process [51]. The second connection type is from the Manager <b>sink</b> <b>node,</b> the Classifier <b>sink</b> <b>node,</b> and the Prioritizer <b>sink</b> <b>node</b> to the General <b>sink</b> <b>node.</b> The Manager sink sends its report to the General <b>sink</b> <b>node</b> to describe each sensor status, which is determined using some parameters such as level of each sensor power, congestion time and MAC address, bandwidth consumption, and notable data type that should be sent from this area. Also, the Classifier <b>sink</b> <b>node</b> sends its report to the General <b>sink</b> <b>node.</b> Moreover, the Prioritizer <b>sink</b> <b>node</b> sends its report, which contains prioritized data, to the General <b>sink</b> <b>node.</b> This report contains the state of the collected data which describes type, size, and history of this data. The Prioritizer report contains the most important data, followed by the least important data.|$|E
30|$|When a <b>sink</b> <b>node</b> {{receives}} the data, it sends {{the data to}} the <b>sink</b> <b>node</b> that is closest to the destination node in terms of potential distance via the wired link. The <b>sink</b> <b>node</b> then starts to send the data to the destination node through PBDR.|$|E
30|$|The {{proposed}} system comprises three management layers: the General <b>sink</b> <b>node</b> layer, the Multi-Functional sink layer, and the Sensors layer. The proposed WSN {{management system}} is considered as bi-directional {{due to the}} messages sent to and received from the system components. The first direction is from the Sensors layer to the Multi-Functional layer. In this direction the data, which are collected by sensors, {{is sent to the}} Multi-Functional layer components. Each component in this layer handles this data beginning from the Manager <b>sink</b> <b>node,</b> passing through the Classifier and Prioritizer sink nodes, and ending with the Manager <b>sink</b> <b>node.</b> Hence, the Manager <b>sink</b> <b>node</b> sends this data to the General <b>sink</b> <b>node</b> layer. The other direction starts with the General <b>sink</b> <b>node</b> layer through the Multi-Functional layer down to the Sensors layer.|$|E
30|$|The {{simulated}} environment is rather {{small for the}} usage of four <b>sink</b> <b>nodes,</b> but the goal of these tests is to demonstrate the behaviour of the implemented support.|$|R
30|$|As {{stated in}} the RPL specifications[15], the usage of {{multiple}} sinks will require reliable communication between the sinks. This requirement however is not that restrictive, because these sinks normally are already connected to a reliable network to report their data to a database or central application. The biggest challenge to enable multi-sink support for usage with RPL is the coordination and synchronisation of the different <b>sink</b> <b>nodes.</b> This coordination and synchronisation is {{needed to keep the}} different <b>sink</b> <b>nodes</b> in a common state to act together as a virtual sink.|$|R
40|$|Abstract — We {{investigate}} {{transmission of}} information in a network {{in the presence of}} an adversary that can eavesdrop k channels and inject d errors into the network at the same time. We propose a deterministic construction of a secure error-correcting (SEC) network codes which can transmit information at rate m − 2 d − k to all the <b>sink</b> <b>nodes</b> which protecting the information from eavesdropping and contamination by the adversary, where m is the minimum maxflow among all the <b>sink</b> <b>nodes.</b> We also show that this rate is optimal. I...|$|R
