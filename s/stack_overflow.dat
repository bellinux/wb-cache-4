318|92|Public
25|$|Excessive {{recursion}} which—though logically valid—causes <b>stack</b> <b>overflow.</b>|$|E
25|$|Swift {{won first}} place for Most Loved Programming Language in the <b>Stack</b> <b>Overflow</b> Developer Survey 2015 and {{second place in}} 2016.|$|E
25|$|The Eclipse Foundation {{reported}} in its annual community survey {{that as of}} May 2014, Git is now {{the most widely used}} source-code management tool, with 42.9% of professional software developers reporting that they use Git as their primary source control system compared with 36.3% in 2013, 32% in 2012; or for Git responses excluding use of GitHub: 33.3% in 2014, 30.3% in 2013, 27.6% in 2012 and 12.8% in 2011. Open source directory Black Duck Open Hub reports a similar uptake among open source projects. The <b>Stack</b> <b>Overflow</b> developer survey {{reported in}} 2015 that 69.3% of developers use Git; 36.9% use Subversion; 12.2% use TFS; and 7.9% use Mercurial.|$|E
50|$|In 2016, Spolsky {{announced}} {{the appointment of}} Anil Dash as Fog Creek Softwares new CEO, with Spolsky continuing as <b>Stack</b> <b>Overflows</b> CEO and as a Fog Creek Software board member.|$|R
50|$|The Blaster worm {{spread by}} {{exploiting}} a <b>stack</b> buffer <b>overflow</b> in Microsoft DCOM service.|$|R
5000|$|Best Client-Side Bug: msvidctl.dll MPEG2TuneRequest <b>Stack</b> buffer <b>overflow</b> (CVE-2008-0015) Ryan Smith and Alex Wheeler ...|$|R
25|$|Windows {{specific}} compiler {{support is}} also needed for Structured Exception Handling (SEH). This system serves two purposes: {{it provides a}} substrate on which language-specific exception handling can be implemented, and it is how the kernel notifies applications of exceptional conditions such as dereferencing an invalid pointer or <b>stack</b> <b>overflow.</b> The Microsoft/Borland C++ compilers {{had the ability to}} use this system {{as soon as it was}} introduced in Windows 95 and NT, however the actual implementation was undocumented and had to be reverse engineered for the Wine project and free compilers. SEH is based on pushing exception handler frames onto the stack, then adding them to a linked list stored in thread local storage (the first field of the thread environment block). When an exception is thrown, the kernel and base libraries unwind the stack running handlers and filters as they are encountered. Eventually, every exception unhandled by the application will be dealt with by the default backstop handler, which pops up the Windows common crash dialog.|$|E
500|$|An {{analysis}} {{posted on}} GitHub {{of the most}} visited websites on April 8, 2014 revealed vulnerabilities in sites including Yahoo!, Imgur, <b>Stack</b> <b>Overflow,</b> Slate, and DuckDuckGo. [...] The following sites have services affected or made announcements recommending that users update passwords {{in response to the}} bug: ...|$|E
2500|$|<b>Stack</b> <b>overflow</b> may be {{difficult}} to avoid when using recursive procedures, since many compilers assume that the recursion stack is a contiguous area of memory, and some allocate a fixed amount of space for it. [...] Compilers may also save more information in the recursion stack than is strictly necessary, such as return address, unchanging parameters, and the internal variables of the procedure. [...] Thus, the risk of <b>stack</b> <b>overflow</b> can be reduced by minimizing the parameters and internal variables of the recursive procedure, or by using an explicit stack structure.|$|E
5000|$|The Slammer worm {{spread by}} {{exploiting}} a <b>stack</b> buffer <b>overflow</b> in Microsoft's SQL server.https://www.wired.com/wired/archive/11.07/slammer.html ...|$|R
50|$|Prevent the {{execution}} of malicious code from the stack without directly detecting the <b>stack</b> buffer <b>overflow.</b>|$|R
30|$|Some {{monitoring}} tools provide {{mechanisms to}} implement basic automated error recover strategies [9],[10]. In {{the case of}} cloud computing the simplest error recovery mechanism is to terminate a faulty VM and then instantiate a replacement. This will resolve any errors contained to a VM (<b>stack</b> <b>overflows,</b> kernel panics etc) but will do little to resolve an error trigged by external phenomenon or an error that continuously reoccurs.|$|R
2500|$|According to a <b>Stack</b> <b>Overflow</b> [...] "Web Developer Survey Results 2016" [...] survey, English-speaking users' [...] "Desktop Operating System"-preference for web-development use is the {{following}} (and [...] "by next year's survey fewer than 50% of developers may be using Windows" [...] that is, for 2017): ...|$|E
2500|$|In {{recursive}} implementations of D algorithms, {{one must}} {{make sure that there}} is sufficient memory allocated for the recursion stack, otherwise the execution may fail because of <b>stack</b> <b>overflow.</b> [...] Fortunately, D algorithms that are time-efficient often have relatively small recursion depth. [...] For example, the quicksort algorithm can be implemented so that it never requires more than [...] nested recursive calls to [...] sort [...] items.|$|E
2500|$|Programmers in the Scheme dialect often express loops using tail recursion. Scheme's {{commonality}} {{in academic}} computer science {{has led some}} students to believe that tail recursion is the only, or the most common, way to write iterations in Lisp, but this is incorrect. All oft-seen Lisp dialects have imperative-style iteration constructs, from Scheme's [...] loop to Common Lisp's complex [...] expressions. Moreover, the key issue that makes this an objective rather than subjective matter is that Scheme makes specific requirements for the handling of tail calls, and thus {{the reason that the}} use of tail recursion is generally encouraged for Scheme is that the practice is expressly supported by the language definition. By contrast, ANSI Common Lisp does not require the optimization commonly termed a tail call elimination. Thus, the fact that tail recursive style as a casual replacement for the use of more traditional iteration constructs (such as , [...] or [...] ) is discouraged in Common Lisp {{is not just a matter}} of stylistic preference, but potentially one of efficiency (since an apparent tail call in Common Lisp may not compile as a simple jump) and program correctness (since tail recursion may increase stack use in Common Lisp, risking <b>stack</b> <b>overflow).</b>|$|E
5000|$|The Morris worm {{spread in}} part by {{exploiting}} a <b>stack</b> buffer <b>overflow</b> in the Unix finger server.http://www.ee.ryerson.ca/~elf/hack/iworm.html ...|$|R
5000|$|The Witty worm {{spread by}} {{exploiting}} a <b>stack</b> buffer <b>overflow</b> in the Internet Security Systems BlackICE Desktop Agent.http://www.icsi.berkeley.edu/~nweaver/login_witty.txt ...|$|R
50|$|Detect that a <b>stack</b> buffer <b>overflow</b> has {{occurred}} and thus prevent redirection {{of the instruction}} pointer to malicious code.|$|R
50|$|In February 2011, <b>Stack</b> <b>Overflow</b> {{released}} an associated job board called Careers 2.0, charging fees to recruiters for access, which later re-branded to <b>Stack</b> <b>Overflow</b> Careers. In March 2011, <b>Stack</b> <b>Overflow</b> raised US$12 million in additional venture funding, {{and the company}} renamed itself to Stack Exchange, Inc. It is based in Manhattan, New York City. In February 2012, Atwood left the company.|$|E
50|$|Spolsky also co-founded <b>Stack</b> <b>Overflow,</b> a {{question}} and answer community website for software developers, with Jeff Atwood. He is now CEO of the resulting <b>Stack</b> <b>Overflow</b> and the Stack Exchange Network.|$|E
5000|$|Following {{the success}} of <b>Stack</b> <b>Overflow</b> they started {{additional}} sites in 2009 based on the <b>Stack</b> <b>Overflow</b> model: Server Fault for questions related to system administration and Super User for questions from computer [...] "power users".|$|E
5000|$|Unless users {{choose the}} [...] "NoRecurse" [...] PCRE build option (aka [...] "--disable-stack-for-recursion"), the calling {{application}} or operating system must allocate adequate stack space to PCRE. The amount of stack needed varies for each pattern. For example, completing the tests provided with pcretest needs 8 MB of stack space. While PCRE's documentation cautions that the [...] "NoRecurse" [...] build option makes PCRE {{slower than the}} alternative, using it avoids entirely the issue of <b>stack</b> <b>overflows.</b>|$|R
40|$|While {{numerous}} {{approaches have}} been proposed to prevent <b>stack</b> <b>overflows,</b> heap overflows remain both a security vulnerability and a frequent source of bugs. Previous approaches to preventing these overflows require source code or can slow programs down {{by a factor of}} two or more. We present HeapShield, an approach that prevents all library-based heap overflows at runtime. It works with arbitrary, unaltered binaries. It incurs no space overhead and is efficient, imposing minimal impact on real application performance (2 % on average). 1...|$|R
50|$|<b>Stack</b> <b>overflows</b> {{are made}} worse by {{anything}} that reduces the effective stack size of a given program. For example, the same program being run without multiple threads might work fine, {{but as soon as}} multi-threading is enabled the program will crash. This is because most programs with threads have less stack space per thread than a program with no threading support. Because kernels are generally multi-threaded, people new to kernel development are usually discouraged from using recursive algorithms or large stack buffers.|$|R
5000|$|Excessive {{recursion}} which—though logically valid—causes <b>stack</b> <b>overflow.</b>|$|E
5000|$|Programming communities: Advogato, {{freelance}} marketplaces, <b>Stack</b> <b>Overflow</b> ...|$|E
50|$|<b>Stack</b> <b>Overflow</b> {{also has}} a Jobs section to assist {{developers}} in finding their next opportunity. For employers, <b>Stack</b> <b>Overflow</b> provides tools to brand their business, advertise their openings on the site, and source candidates from Stack Overflow's database of developers who are open to being contacted.|$|E
50|$|A <b>stack</b> buffer <b>overflow</b> {{occurs when}} a program writes to a memory address on the program's call stack outside of the {{intended}} data structure, which is usually a fixed-length buffer. <b>Stack</b> buffer <b>overflow</b> bugs are caused when a program writes more data to a buffer located on the stack than what is actually allocated for that buffer. This almost always results in corruption of adjacent data on the stack, and {{in cases where the}} overflow was triggered by mistake, will often cause the program to crash or operate incorrectly. <b>Stack</b> buffer <b>overflow</b> is a type of the more general programming malfunction known as buffer overflow (or buffer overrun). Overfilling a buffer on the stack is more likely to derail program execution than overfilling a buffer on the heap because the stack contains the return addresses for all active function calls.|$|R
50|$|The 11i v2 release {{introduced}} kernel-based intrusion detection, strong {{random number}} generation, <b>stack</b> buffer <b>overflow</b> protection, security partitioning, role-based access management, and various open-source security tools.|$|R
5000|$|Over {{the years}} {{a number of}} control-flow {{integrity}} schemes {{have been developed to}} inhibit malicious <b>stack</b> buffer <b>overflow</b> exploitation. These may usually be classified into three categories: ...|$|R
5000|$|Joel Spolsky '91, {{software}} engineer, {{co-founder of}} <b>Stack</b> <b>Overflow</b> ...|$|E
5000|$|Alexa Scordato - Director {{of product}} {{marketing}} at <b>Stack</b> <b>Overflow</b> ...|$|E
5000|$|Most Overhyped Bug: MS08-067 Server Service NetpwPathCanonicalize (...) <b>Stack</b> <b>Overflow</b> (CVE-2008-4250) Anonymous ...|$|E
40|$|Abstract. The paper {{addresses}} {{the problem of}} stack smashing or <b>stack</b> <b>overflows</b> in modern operating systems. We focus on a security solution for this problem, namely compiler generated canary protection and, to be more specific, we consider the Stack Smashing Protector (SSP) present in the most popular C compiler, the GCC. We first analyze {{the limitations of the}} GCCs SSP and then present three improvements that will harden the security offered by the SSP making an attackers attempt more difficult. All improvements refer to the most recent version of GCC, 4. 6. 2...|$|R
50|$|The code segment {{in memory}} is {{typically}} read-only {{and has a}} fixed size, so on embedded systems it can usually be placed in read-only memory (ROM), {{without the need for}} loading. If the code segment is not read-only, then the particular architecture allows self-modifying code. Fixed-position or position independent code may be shared in memory by several processes in segmented or paged memory systems. As a memory region, the code segment may be placed below the heap or stack in order to prevent heap and <b>stack</b> <b>overflows</b> from overwriting it.|$|R
5000|$|... "Smashing The Stack For Fun And Profit" [...] by Aleph One, {{published}} in issue 49, is the [...] "classic paper" [...] on <b>stack</b> buffer <b>overflows,</b> {{partly responsible for}} popularizing the vulnerability.|$|R
