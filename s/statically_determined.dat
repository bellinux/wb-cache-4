101|177|Public
25|$|C# 3.0 {{introduced}} type inference, {{allowing the}} type specifier of a variable declaration {{to be replaced}} by the keyword , if its actual type can be <b>statically</b> <b>determined</b> from the initializer. This reduces repetition, especially for types with multiple generic type-parameters, and adheres more closely to the DRY principle.|$|E
5000|$|Bearings with {{integrated}} piston for preload of <b>statically</b> <b>determined</b> guidances.|$|E
50|$|The linear slider, {{which is}} air-guided and <b>statically</b> <b>determined,</b> {{guarantees}} a high-precision {{positioning of the}} optical component before grinding. The self-aligning process is done without friction or force. When clamped the component retains its position for further manufacturing in the sub-micrometer-range.|$|E
5000|$|The warning {{is issued}} by the {{compiler}} because it can <b>statically</b> <b>determine</b> that in [...] the expression [...] evaluates always to true, because it contains an ELF jump table entry. The error message is {{issued by the}} linker. The build for [...] includes the same warning but no link error.|$|R
40|$|Abstract This paper {{presents}} a control architecture for multi-robot systems. The proposed architecture {{has been developed}} {{in the framework of}} the Null-Space-based-Behavioral (NSB) control, a competitive-collaborative behavior-based control approach. The standard NSB <b>statically</b> <b>determines</b> a set of suitably defined elementary The manuscript is based on three conference papers of the same authors, namely, Marino et al. [27 – 29]...|$|R
30|$|To {{handle these}} issues, user access to {{resources}} {{should be based on}} trustworthiness rather than the traditional techniques that <b>statically</b> <b>determine</b> the access rights of the entities. To meet the security concerns in ubiquitous resource sharing environment, the model should {{be able to deal with}} devices and environment of unknown origin and also should be adaptive to the dynamics of mobile and socially motivated computing models [3].|$|R
50|$|Beside the performance, the {{reliability}} {{is extremely important}} for a production machine. The air-guided solution {{is designed to be}} <b>statically</b> <b>determined.</b> The iron-core linear motor and piston bearings achieve the preload for the air bearings. Thereby, the drive is easy to assemble and insensitive against geometric variations, for instance through temperature influences or the disposition of the machines.|$|E
50|$|Even though {{years of}} {{experience}} accounts for a good gauge for the appropriate lifting anchor to be used, {{it should not be}} left to the reinforcement fabricators and precast factory personnel to select the lifting anchor. The design engineer should specifically account for the applied loads expected during the lifting, transport and placement (or re-usability requirements) of the element. Flexure, casting bed suction, load direction (axial ‘tensile’, angular ‘sling’, transverse ‘shear’) are also load considerations to be accounted for in the lifting design of the element.The anchor selection, together with additional reinforcement, and rigging arrangements is influenced by:- The dead weight of the element- The number of anchors in the element and the configuration of the anchor- Capacity of the anchor at the specific concrete compressive strengths at time of lift- The dynamic loads applied during lifting (suction to the casting bed, or crane dynamics)- The rigging configurationAll of the above factors must be taken into consideration during the lifting design phase of the element.The weight of the element can be determined by the calculated volume, and using the specific gravity (normal weight reinforced concrete is approximately 24 kN/m3).Establishing the lifting anchor positions will influence the rigging arrangements used and therefore the static analysis of the rigging should be determined. Particular rigging configurations may be more suitable for particular job sites or lifting in place considerations, and the lifting design should denote the assumptions accordingly. For example, the <b>statically</b> <b>determined</b> systems, shown in Figure 3, where the determination of the loads is not always possible.Dynamic loads considered in lifting design are accounted for in two stages; suction to the casting bed on the initial lift and then the dynamic loads induced from crane vibration. These crane impact loads must be accounted for during transportation in the yard and on-site, and the coefficient increases from an overhead gantry crane through to a crane moving over rough terrain. Consideration for the entire transportation loads {{must be taken into account}} during the lifting design.Anchor capacity, or load resistance, should be considered for tensile loads (axial), sling angle (angular) and shear loads (transverse). Consideration of different load combinations may result in wide variations required from the lifting insert. The load directions during production, transport and placement should be considered carefully. Depending on the planned load direction, either a different anchor may be included in the lifting design, alternatively, reinforcement may be included to reduce the possibility of element flexure crack damage. The configuration (size, position and quantity) of this reinforcement should be supplemented to the element reinforcement design to ensure for adequate capacity of the lifting design.Lifting design is influenced by the steel / concrete interaction of the specific anchor selected. Different load cases are considered by the lifting design engineer, such as anchor susceptibility to edge distance, placement sensitivity, and anchor capacity at the specific concrete strength at time of lift. For example, a footed pin head style anchor maybe more susceptible to edge distance than a hairpin style anchor. Or a splayed anchor does not have the same tensile/axial capacity with the equivalent anchor length (effective embedment is greater on a footed anchor than a splayed anchor of equivalent overall length, see figure 4).|$|E
40|$|The {{performance}} structures made {{of steel}} under the action of fire {{is very important in}} real constructions and there is not an accurate system to estimate the resistance of them at elevated temperatures. Linear elastic analysis is normally used in the design of welded tubular trusses in fire using FEM models. The main question {{of this study is to}} define if the elastic linear theory is suitable with <b>statically</b> <b>determined</b> and non-determined trusses. <b>Statically</b> <b>determined</b> truss is such that support reactions can be calculated just with equilibrium equations only. <b>Statically</b> <b>determined</b> is ‘internally’ statically non-determined because of the continuous beams for the chords and the eccentricities of the joints. Statically non-determined truss is such that compatibility conditions are needed as well. The strength of the structure and the constraints check are derived from the requirements given in the European building code. The standard ISO 834 fire is supposed around the tubular truss without fire painting on it. Both linear and non-linear theories are considered in the study using ABAQUS. Non-linear includes both material and geometrical non-linearities. The mechanical analysis is done with constant load and by increasing temperatures given as an input of a previous heat transfer analysis. The results show that when the truss is externally <b>statically</b> <b>determined</b> the linear model is pretty accurate and can be used to design tubular steel trusses. However, with non-statically determined structures would be needed more in depth studies than the linear elastic analysis...|$|E
50|$|The {{similarly}} named reaching definitions is a data-flow analysis which <b>statically</b> <b>determines</b> which definitions {{may reach}} a given {{point in the}} code. Because of its simplicity, it is often used as the canonical example of a data-flow analysis in textbooks. The data-flow confluence operator used is set union, and the analysis is forward flow. Reaching definitions are used to compute use-def chains and def-use chains.|$|R
50|$|The SofCheck Inspector is {{a static}} {{analysis}} tool for Java and Ada. It <b>statically</b> <b>determines</b> and documents the pre- and postconditions of Java methods or Ada subprograms, and uses {{that information to}} identify logic flaws, race conditions, and redundant code in an individual Java class or Ada package, a subsystem, or a complete program. The SofCheck Inspector is produced by SofCheck, Inc., a software product company in Burlington, Massachusetts.|$|R
50|$|Lipton and J.Naughton {{presented}} an adaptive random sampling algorithm for database querying which is applicable to any query for which {{answer to the}} query can be partitioned into disjoint subsets. Compared with most sampling estimation algorithms that <b>statically</b> <b>determines</b> the number of samples needed, the algorithm they proposed decides the number of samples based {{on the size of}} samples and tends to keep the running time constant rather than the number of samples.|$|R
40|$|Key results: An {{abstract}} interpretation framework is described that allows dynamic properties of asynchronous circuits to be <b>statically</b> <b>determined.</b> How does the work advance {{the state of}} the art?: A sound mathematical framework is pre-sented that allows new approaches to the model checking, static analysis and logic synthesis of asynchronous digital circuits...|$|E
40|$|The paper {{presents}} a simple approach {{to evaluate the}} response of <b>statically</b> <b>determined</b> steel beams reinforced by carbon fiber reinforced polymer (CFRP) plates in the elasticplastic regime. The formulation is applied to two cases: simply supported beams both with distributed and concentrated load. The proposed solution is validated by comparison with experimental data available in the literature...|$|E
3000|$|... [...]) in the {{dataflow}} graph {{and leads}} to significantly larger buffer size requirements compared to use of a <b>statically</b> <b>determined</b> number of classifications. At the same time, we found through experiments that dynamically, determining the number of classifications {{does not lead to}} significant improvement in overall system accuracy. Based on this combination of dataflow graph analysis and experimentation, we converted the number of classifications to a statically fixed parameter (p [...]...|$|E
40|$|Memory {{operations}} {{remain a}} significant bottleneck in dynamically scheduled pipelined processors, {{due in part}} to the inability to <b>statically</b> <b>determine</b> the existence of memory address dependencies. Hardware memory renaming techniques have been proposed to predict which stores a load might be dependent upon. These prediction techniques can be used to speculatively forward a value from a predicted store dependency to a load through a value prediction table. However, these techniques require large, timeconsuming hardware tables. In thi...|$|R
40|$|The {{interconnection}} structure of mobile systems {{is very difficult}} to predict, since communication between component agents may carry information which dynamically changes that structure. In this paper we design an automatic analysis for <b>statically</b> <b>determining</b> all potential links between the agents of a mobile system specified in the - calculus. For this purpose, we use a nonstandard semantics of the - calculus which allows us to describe precisely the linkage of agents. The analysis algorithm is then derived by abstract interpretation of this semantics...|$|R
40|$|In {{this paper}} {{we present a}} type system with strong typing and static type {{checking}} that is not yet well supported in most existing object-oriented database systems. Using a partial ordering defined on type structures and on methods associated to types, we define a subtyping rule for correctly structuring the inheritance hierarchy of the types. Based on the subtyping, a number of type inference rules are defined. They {{can be used by}} the type system to <b>statically</b> <b>determine</b> the types of the query results and whether a given application program is type correct...|$|R
40|$|International audienceWe {{show that}} the typed region {{calculus}} of Tofte and Talpin can be encoded in a typed π-calculus equipped with name groups and a novel effect analysis. In the region calculus, each boxed value has a <b>statically</b> <b>determined</b> region {{in which it is}} stored. Regions are allocated and de-allocated according to a stack discipline, thus improving memory management. The idea of name groups arose in the typed ambient calculus of Cardelli, Ghelli, and Gordon. There, and in our π-calculus, each name has a <b>statically</b> <b>determined</b> group to which it belongs. Groups allow for type-checking of certain mobility properties, as well as effect analyses. Our encoding makes precise the intuitive correspondence between regions and groups. We propose a new formulation of the type preservation property of the region calculus, which avoids Tofte and Talpin’s rather elaborate co-inductive formulation. We prove the encoding preserves the static and dynamic semantics of the region calculus. Our proof of the correctness of region de-allocation shows it to be a specific instance of a general garbage collection principle for the π-calculus with effects...|$|E
40|$|Methods of probanbility {{design and}} {{statistical}} control of reinforced concrete and composite structures lead to material economy and increase in reliability of buildings and constructions. Limit states of construction {{are to be}} caused by loads and materialcharacteristics as well as by unfavourable environmental conditions. Methods of assessment, and reliability of <b>statically</b> <b>determined</b> and undetermined systems are discussed. the reliability analysis of structural elements is based on dispersion of material strength properties and geometrical characteristics of elements...|$|E
40|$|This {{paper will}} be {{published}} in ‘Precisie Portaal ’ and is made available as an electronic reprint with permission of SPIE. One print or electronic copy may be made for personal use only. Systematic or multiple reproduction, distribution to multiple locations via electronic or other means, duplications of any material in this paper for fee or for commercial purposes, or modification of the content of the paper are prohibited. <b>Statically</b> <b>determined</b> structures: Tension between classical and modern desig...|$|E
40|$|In {{this work}} {{disassembler}} for monolithic microproces or (micro-controllers) Microchip PIC was created. For typical programs this disasambler <b>statically</b> <b>determines</b> values of runtime address registers, thus complting the address from partial address in instruction. On its basis the disassembler recognizes procedures, creates procedure call-graph and recognizes control structures. Described disassembler separates usage of a register us do for variables of multiple procedures and sorts them to procedures inputs, locally modified variables and returned variables. Contemporary disassemblers for this architecture restrict themselves to printing instructions with incomplete addresses, {{because they do}} not perform any analysis. Powered by TCPDF (www. tcpdf. org...|$|R
40|$|Two {{methods of}} {{analysis}} {{have been developed for}} legged planetary landers. The first of these, the Large Displacement Gear Analysis, is a design tool for <b>statically</b> <b>determining</b> the large displacement stroking behavior, energy absorption characteristics, and internal load distributions in a single gear. The second, the Landing Dynamics Analysis, predicts the spatial landing dynamics of a legged lander. Effects of structural flexibility, elastic-plastic gear load characteristics, and soil properties on the loads, motions, and stability of the lander may be determined. Validation of the analytical techniques is accomplished through comparison of predicted results and experimental data obtained during a model test program...|$|R
40|$|Object-oriented {{programming}} languages where {{classes are}} top-level, i. e. not first-class citizens, are {{better suited for}} compilation than completely dynamic languages like SMALLTALK or SELF. In O 2 ̆ 7 SMALL, a language with top-level classes, the compiler can <b>statically</b> <b>determine</b> the inheritance hierarchy. Due to late binding, the class of the receiver of a message must be determined at run time. After that a direct jump to the corresponding method is possible. Method lookup can thus be done in constant time. We present an abstract machine for O 2 ̆ 7 SMALL based on these principles. It is a concise description of a portable O 2 ̆ 7 SMALL implementation...|$|R
40|$|We {{show that}} the typed region {{calculus}} of Tofte and Talpin can be encoded in a typed -calculus equipped with name groups and a novel effect analysis. In the region calculus, each boxed value has a <b>statically</b> <b>determined</b> region {{in which it is}} stored. Regions are allocated and de-allocated according to a stack discipline, thus improving memory management. The idea of name groups arose in the typed ambient calculus of Cardelli, Ghelli, and Gordon. There, and in our -calculus, each name has a <b>statically</b> <b>determined</b> group to which it belongs. Groups allow for type-checking of certain mobility properties, as well as effect analyses. Our encoding makes precise the intuitive correspondence between regions and groups. We propose a new formulation of the type preservation property of the region calculus, which avoids Tofte and Talpin’s rather elaborate co-inductive formulation. We prove the encoding preserves the static and dynamic semantics of the region calculus. Our proof of the correctness of region de-allocation shows it to be a specific instance of a general garbage collection principle for the -calculus with effects. We propose new equational laws for letregion, analogous to scope mobility laws in the -calculus, and show them sound in our semantics...|$|E
40|$|Conventional Minimally Invasive Surgery (MIS) {{generally}} {{provides the}} surgeon with an uncomfortable body posture, limited force feedback and unnatural eye-handcoordination when manipulating camera and instruments through small incisions. A masterslave system with force-feedback is being developed, since {{such a system}} can overcome the inconveniences of MIS. This paper is about {{the design of the}} slave robot for MIS in the abdomen and chest. By applying design principles on kinematically and <b>statically</b> <b>determined</b> design: hysteresis of position is minimized; and stresses, deformations and dynamical behaviour are highly predictable. This improves the reliability of the robot...|$|E
40|$|In rock {{engineering}} projects, <b>statically</b> <b>determined</b> {{parameters are}} more reflective of actual load conditions than dynamic parameters. This study reports {{a new and}} efficient approach to the formulation of the static modulus of elasticity Es applying gene expression programming (GEP) with nondestructive testing (NDT) methods. The results obtained using GEP are compared {{with the results of}} multivariable linear regression analysis (MRA), univariate nonlinear regression analysis (URA), and the dynamic elasticity modulus (Ed). The GEP model was found to produce the most accurate calculation of Es. The proposed approach is a simple, nondestructive, and practical way to determine Es for anisotropic and heterogeneous rocks...|$|E
40|$|Abstract {{interpretation}} {{theory has}} successfully {{been used for}} constructing algorithms to <b>statically</b> <b>determine</b> run-time properties of programs. Central {{is the notion of}} an abstract domain, describing certain properties of interest about the program. In logic programming, program analyses typically fall into two different categories: either they detect program points where the property definitely holds (universal analyses) or possibly holds (existential analyses). We study the relation between such analyses in the case where the concrete domain is a lattice join-generated by its set of join-irreducible elements. Although our intended application is for logic programming, the theory is sufficiently general for possible applications to other languages...|$|R
40|$|Abstract—In this paper, {{we study}} {{the problem of}} {{reducing}} both the dynamic and leakage energy consumption for real-time systems with (m,k) -constraints, which require that at least m out of any k consecutive jobs of a task meet their deadlines. Two energy efficient scheduling approaches incorporating both dynamic voltage scheduling (DVS) and dynamic power down (DPD) are proposed in this paper. The first one <b>statically</b> <b>determines</b> the mandatory jobs that need to meet their deadlines {{in order to satisfy}} the (m,k) -constraints, and the second one does so dynamically. The simulation results demonstrate that, with more accurate workload estimation, our proposed techniques outperformed previous research in both overall and idle energy reduction while providing the (m,k) -guarantee. I...|$|R
40|$|Abstract: In certain {{real-time}} systems worst-case {{execution time}} estimates {{often lead to}} a waste of resources. In hard real-time systems these types of estimates are essential to guarantee temporal requirements are met. However in soft-real time systems using other measurements, such as average-case timing, to complement the worst-case estimates can lead to better utilisation of resources while ensuring most, if not all, deadlines are met. We propose a methodology to integrate modular average-case timing in Real-Time languages. Previously <b>statically</b> <b>determining</b> average-case time, if possible, required rigorous mathematical techniques. Our approach, {{which is based on}} a new programming paradigm called MOQA and is built on Real-Time Java, simplifies the process and allows for automation...|$|R
40|$|Abstract. A {{middleware}} {{for real}} ad-hoc cooperation of distributed device ensembles must support self-organization of its components. Self-organization {{means that the}} independence of the ensembles ’ components is ensured, that the ensemble is dynamically extensible by new components and that real distributed implementation is possible. Furthermore the data-flow of messages within the ensemble may not be <b>statically</b> <b>determined.</b> This article presents the application of the SodaPop model for distributed device ensembles to physical heterogeneous devices as well as the distributed implementation of conflict resolution strategies that guarantee the data-flow even if there are competing components. The proposed approach relies on the principle of device representatives. ...|$|E
40|$|Abstract: Actor {{programs}} {{give rise}} to computation structures that evolve dynamically and unpredictably both in shape and size. Therefore, their execution times cannot be <b>statically</b> <b>determined.</b> This paper describes an approach {{to the problem of}} estimating time costs of actor programs. The approach takes into account the constraints imposed both by the semantics and implementation of the model. In particular, implementation constraints can be captured and exploited to drastically reduce the number of computations generable by the program, thus simplifying the execution time evaluation. Moreover, execution times are expressed in a parametric form by using a variant of the LogP model able to synthetically characterize the target hardware/software platform...|$|E
40|$|The {{seamless}} integration of relational databases and programming languages remains a major challenge. Mapping rich data types featured in general-purpose programming languages to the relational data model is {{one aspect of}} this challenge. We present a novel technique for mapping arbitrary (nonrecursive) algebraic data types to a relational data model, based on previous work on the relational representation of nested tables. Algebraic data types may be freely constructed and deconstructed in queries and may {{show up in the}} result type. The number of relational queries generated is small and <b>statically</b> <b>determined</b> by the type of the query. We have implemented the mapping in the Database Supported Haskell (DSH) library...|$|E
40|$|This paper {{shows how}} data flow {{analysis}} {{can be used}} to infer type information related to Java bytecode, and evaluates this approach. All the elements needed to specify, the data flow,problem to be software conveniently defined, according to the theory on data flow frameworks, along with algorithms to build them automatically from the Java bytecode. To evaluate the approach, we consider the specific problem of <b>statically</b> <b>determining</b> the set of methods potentially invoked by each method call instruction, which is useful for several purposes, such as building accurate call graphs. Experimental results are presented showing that data flow analysis can improve the accuracy of the results with respect to other simpler techniques at acceptable costs...|$|R
40|$|We develop near-concrete program {{interpretation}} (NCI), a higherorder program {{analysis that}} achieves high precision via close, yet decidable, simulation of operational (concrete) semantics. NCI models mutable heaps with possibly recursive structure, and achieves flow-, context- and path-sensitivity {{in a uniform}} setting. The analysis also extracts a nugget that characterizes the value bindings resulting from program execution; {{it can be used}} to <b>statically</b> <b>determine</b> a wide range of non-trivial properties. The technical novelty of the system lies in a prune-rerun technique for approximating recursive functions. To illustrate the generality and usefulness of the system, we show how {{it can be used to}} statically enforce temporal program safety, information flow security, and array bounds checking properties. 1...|$|R
40|$|Symbolic {{complexity}} bounds help programmers {{understand the}} performance characteristics of their implementations. Existing work provides techniques for <b>statically</b> <b>determining</b> bounds of procedures with simple control-flow. However, procedures with nested loops or multiple paths through a single loop are challenging. In this paper we describe two techniques, control-flow refinement and progress invariants, that together enable estimation of precise bounds for procedures with nested and multi-path loops. Control-flow refinement transforms a multi-path loop into a semantically equivalent code fragment with simpler loops {{by making the}} structure of path interleaving explicit. We show that this enables non-disjunctive invariant generation tools to find a bound on many procedures for which previous techniques were unable to prove termination. Progress invariants characterize relationships betwee...|$|R
