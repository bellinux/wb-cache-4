477|1404|Public
2500|$|.....the {{magnitudes}} involved {{should lead}} one to suspect that theorems and arguments based chiefly on the mere finiteness [...] the <b>state</b> <b>diagram</b> may not carry {{a great deal of}} significance. (Minsky p. 25) ...|$|E
2500|$|There is a {{wide variety}} of {{representations}} possible and one can express a given Turing machine program as a sequence of machine tables (see more at finite-state machine, state transition table and control table), as flowcharts and drakon-charts (see more at <b>state</b> <b>diagram),</b> or as a form of rudimentary machine code or assembly code called [...] "sets of quadruples" [...] (see more at Turing machine).|$|E
2500|$|A <b>state</b> <b>diagram</b> for {{a simple}} example {{is shown in the}} figure on the right, using a {{directed}} graph to picture the state transitions. The states represent whether a hypothetical stock market is exhibiting a bull market, bear market, or stagnant market trend during a given week. [...] According to the figure, a bull week is followed by another bull week 90% of the time, a bear week 7.5% of the time, and a stagnant week the other 2.5% of the time. Labelling the state space {1=bull, 2=bear, 3=stagnant} the transition matrix for this example is ...|$|E
50|$|There are two model types {{supported}} by ECO: class <b>diagrams</b> and <b>state</b> <b>diagrams.</b> Class diagrams {{are used to}} define static description of a system. On the other hand, <b>state</b> <b>diagrams</b> describe possible <b>states</b> of an object and transitions between them. Thus <b>state</b> <b>diagrams</b> describe behavioral aspects of a system.|$|R
2500|$|<b>State</b> <b>diagrams,</b> {{graphical}} {{representations of}} finite state machines ...|$|R
40|$|This paper {{describes}} the syntax and semantics of multi-level <b>state</b> <b>diagrams</b> to support probabilistic behavior of cooperating robots. The techniques are presented to analyze these diagrams by querying combined robots behaviors. It is shown {{how to use}} state abstraction and transition abstraction to create, verify and process large probabilistic <b>state</b> <b>diagrams...</b>|$|R
2500|$|The {{turnstile}} {{state machine}} {{can also be}} represented by a directed graph called a <b>state</b> <b>diagram</b> (above). [...] Each state is represented by a node (circle). [...] Edges (arrows) show the transitions from one state to another. [...] Each arrow is labeled with the input that triggers that transition. [...] An input that doesn't cause a change of state (such as a coin input in the Unlocked state) is represented by a circular arrow returning to the original state. [...] The arrow into the Locked node from the black dot indicates it is the initial state.|$|E
50|$|The <b>state</b> <b>diagram</b> {{is similar}} in shape to the flip-flop's <b>state</b> <b>diagram,</b> but with {{different}} labelling on the transitions.|$|E
5000|$|... #Caption: A Simplified TCP <b>State</b> <b>Diagram.</b> See TCP EFSM diagram {{for a more}} {{detailed}} <b>state</b> <b>diagram</b> including the states inside the ESTABLISHED state.|$|E
5000|$|<b>State</b> <b>diagrams</b> are {{directed}} multigraphs that represent finite state machines.|$|R
40|$|If {{software}} architecture is assigned with formal semantics, then automatic verification and validation {{can be performed}} {{during the process of}} model refinement. In this paper, we emphasized on the formal semantics of UML <b>state</b> <b>diagrams</b> oriented performance analysis. The exact definitions of the basic elements and composition mechanism of UML <b>state</b> <b>diagrams</b> are proposed, UML <b>state</b> <b>diagrams</b> is abstracted as a multi-tuple, CTMC models are abstracted as stochastic Kripke structure, mapping rules between the above two mathematics models are proposed, furthermore the corresponding formal semantics are generated. Finally, an asynchronous parallel composition queuing network is presented to illustrate how the theory is applied to formalize UML <b>state</b> <b>diagrams.</b> The key properties of system are manually deduced and validated. The results are analyzed and compared with the automatic executing results through model checker, which validated the practicability and validity of the theory. </span...|$|R
40|$|The paper {{discusses}} {{the application of}} <b>state</b> <b>diagrams</b> in UML to class testing. A set of coverage criteria is proposed based on control and data flow in UML <b>state</b> <b>diagrams</b> and it is shown how to generate test cases satisfying these criteria from UML <b>state</b> <b>diagrams.</b> First, control flow is identified by transforming UML <b>state</b> <b>diagrams</b> into extended finite state machines (EFSMs). The hierarchical and concurrent structure of states is flattened and the broadcast communication are eliminated in the resulting EFSMs. Second, data flow is identified by transforming EFSMs into flow graphs to which conventional data flow analysis techniques can be applied. Keywords: software testing, specification-based testing, object-oriented programs, classes, Unified Modeling Languages, Statecharts 1 Introduction Classes encapsulate both data (attributes) and procedures (member functions, methods) and are the basic building blocks in object-oriented software development. In addition, a class is oft [...] ...|$|R
50|$|The <b>state</b> <b>diagram</b> for a Mealy machine {{associates}} an {{output value}} with each transition edge (in {{contrast to the}} <b>state</b> <b>diagram</b> for a Moore machine, which associates an output value with each state).|$|E
5000|$|... #Caption: Figure 2: <b>State</b> <b>diagram</b> of 2-bit saturating counter ...|$|E
5000|$|... #Caption: <b>State</b> <b>diagram</b> of bus {{transactions}} for the MSI protocol.|$|E
40|$|A {{prototype}} tool called SCED is {{used for}} modeling the dynamic behavior of object-oriented software as scenario <b>diagrams</b> and <b>state</b> <b>diagrams.</b> In SCED <b>state</b> <b>diagrams</b> can be synthesized automatically from scenario diagrams. When reverse engineering existing software, a parser and a debugger are used for extracting static and dynamic information, respectively. The parsed information {{is viewed as a}} nested graph using a reverse engineering environment Rigi. The debugged information is shown as SCED scenario <b>diagrams</b> and <b>state</b> <b>diagrams.</b> Static and dynamic views to the software can be improved and insured by comparing partly overlapping informationgenerated by the parser and the debugger...|$|R
40|$|A {{system is}} {{introduced}} which automatically generates implementation code from {{the object and}} dynamic models of an application. We found that the behavior of active objects can well be represented by activity <b>diagrams</b> rather than <b>state</b> <b>diagrams.</b> The paper first explains our approach to convert <b>state</b> <b>diagrams</b> as well as activity diagrams into implementation code. The paper then describes our system, dCode, which automatically generates executable Java code from the object <b>diagram,</b> <b>state</b> <b>diagrams</b> and activity diagrams of an application. The paper also {{presents the results of}} the experiment in which the code generated by dCode was compared to that of Rhapsody...|$|R
40|$|Bibliography: pages 107 - 110. The {{theme of}} this thesis is the {{construction}} of <b>state</b> <b>diagrams</b> and their implications. The author generalises most of the theorems in Chapter II of Goldberg [Gl] by dropping {{the assumption that the}} doin. ain of the operator is dense in X. The author also presents the standard Taylor-Halberg-Goldberg <b>state</b> <b>diagrams</b> [Gl, 61, 66]. Chapters II and III deal with F₊- and F₋-operators, which are generalisations of the ф₊- and ф₋-operators in Banach spaces of Gokhberg-Krein [GK]. Examples are given of F₊- and F₋-operators. Also, in Chapter III, the main theorems needed to construct the <b>state</b> <b>diagrams</b> of Chapter IV are discussed. The <b>state</b> <b>diagrams</b> of Chapter IV are based on states corresponding to F₊- and F₋-operators; in addition <b>state</b> <b>diagrams</b> relating T and T˝ under the assumptions ϒ(T) > 0 and ϒ(T΄) > 0 are derived. Second adjoints are important in Tauberian Theory (see Cross [Cl]). Chapters I and IV are the main chapters. In Chapter I of this thesis the author modifies many of the proofs appearing in Goldberg [Gl), to take account of the new definition of the adjoint...|$|R
5000|$|... #Caption: <b>State</b> <b>diagram</b> of {{processor}} {{requests for}} the MSI protocol.|$|E
50|$|From {{the finite}} <b>state</b> <b>diagram</b> we can infer the {{following}} generators (shown at right) {{that creates the}} signal. A generator is a 4-tuple: current state, next state, word written, probability of written word when there are multiple choices. That is, each generator is a state transition arrow of <b>state</b> <b>diagram</b> for a Markov chain.|$|E
5000|$|... #Caption: Circular {{layout of}} a <b>state</b> <b>diagram</b> for the border gateway {{protocol}} ...|$|E
40|$|Concurrent {{software}} for engineering computations consists of multiple cooperating modules. The behavior of individual modules {{is described by}} means on <b>state</b> <b>diagrams.</b> In the paper, the constraints on <b>state</b> <b>diagrams</b> are proposed, allowing for the specification of designer's intentions as to the synchronization of modules. Also, the translation of <b>state</b> <b>diagrams</b> (with enforcement constraints) into Concurrent State Machines is shown, which provides formal framework for the verification of inter-module synchronization. An example of engineering software design based on the method is presented. Comment: 17 pages, 12 figures, 3 rd Biennial World Conference on Integrated Design & Process Technology, Berlin, July 6 - 9, 199...|$|R
50|$|State {{transition}} modeling {{makes use}} of <b>state</b> transition <b>diagrams</b> to describe system behavior. These <b>state</b> transition <b>diagrams</b> use distinct <b>states</b> to define system behavior and changes. Most current modeling tools contain some kind of ability to represent state transition modeling. The use of state transition models can be most easily recognized as logic <b>state</b> <b>diagrams</b> and directed graphs for finite-state machines.|$|R
5000|$|Characterizing {{sequential}} circuits of the Moore and Mealy type, obtaining regular expressions from <b>state</b> <b>diagrams.</b>|$|R
5000|$|... #Caption: Figure 1: UML <b>state</b> <b>diagram</b> {{representing}} the computer keyboard state machine ...|$|E
5000|$|<b>State</b> <b>diagram</b> {{are used}} for state {{machines}} in software engineering from UML 7/9 ...|$|E
5000|$|... #Caption: <b>State</b> <b>diagram</b> for {{a simple}} Mealy machine with one input and one output.|$|E
5000|$|... #Caption: IEEE 1902.1 - Protocol <b>States</b> <b>Diagram</b> - free {{interpretation}} of the author, not IEEE ...|$|R
30|$|In {{relation}} {{to the number of}} warnings of the experimental group, these errors were made by two subjects (7 errors each). One subject agreed that he/she is proficient in <b>state</b> <b>diagrams</b> and statecharts and he/she is indifferent to other system modeling languages. The other subject also agreed in his/her proficiency in <b>state</b> <b>diagrams</b> and totally agreed that he/she is proficient in other system modeling languages.|$|R
40|$|Organic acids {{are present}} in low amounts in most foods, both as {{ingredients}} and as natural components and in considerable amounts in acid foods. The <b>state</b> <b>diagrams</b> of citric acid-, tartaric acid-, malic acid-and lactic acid-water systems are presented here. The <b>state</b> <b>diagrams</b> {{can be useful in}} controlling and predicting the physical changes of amorphous and glassy systems in non equilibrium state during processing and storage...|$|R
5000|$|... #Caption: A <b>state</b> <b>diagram</b> for a {{door that}} can only be opened and closed ...|$|E
5000|$|... #Caption: Figure 6: UML <b>state</b> <b>diagram</b> of the {{keyboard}} state machine with internal transitions ...|$|E
5000|$|Snooping Operation: In a {{snooping}} system, all caches {{on the bus}} monitor (or snoop) all the bus transactions. Every cache has a copy of {{the sharing}} status of every block of physical memory it has stored. The state of the block is changed according to the <b>State</b> <b>Diagram</b> of the protocol used.(Refer image above for MESI <b>state</b> <b>diagram).</b> The bus has snoopers on both sides: ...|$|E
40|$|Abstract. In {{this paper}} we reflect {{the need for}} {{modelling}} in a systematic production of adaptive hypermedia applications. Proposed approach {{is based on the}} Unified Modelling Language (UML). <b>State</b> <b>diagrams</b> are used to model possible paths through hypertext. The user model expressed by a class diagram determines structural and behavioural features, which are used for specification of adaptations in states and transitions contained in <b>state</b> <b>diagrams.</b> ...|$|R
40|$|Integrated formal {{description}} techniques are a promising approach for the specification of multi-aspect systems. In this context, we {{have proposed a}} formalism, called Extended <b>State</b> <b>Diagrams</b> (ESD), combining in an homogeneous framework <b>state</b> <b>diagrams</b> and formal data description languages. Our purpose is here to enhance the implicit ESD communication mechanisms with explicit descriptions of communications, which is achieved using synchronization vectors. The use of interaction diagrams is also discussed...|$|R
40|$|Abstract: UML models offer {{a lot of}} {{information}} that should not be ignored in testing. By combining different UML components, different views of the program under test are used. The paper concentrates on a technique for generating test cases from a combination of UML sequence and <b>state</b> <b>diagrams.</b> The main information is extracted from sequence diagrams, which is complemented by initialization sequences for the participating objects derived from <b>state</b> <b>diagrams.</b> ...|$|R
