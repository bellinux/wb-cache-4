0|10000|Public
40|$|Cache {{memories}} are now standard components of modern computer systems. They have proven extremely useful in {{bridging the gap}} between CPU and DRAM speeds, which continues to grow. Consequently, {{there has been a}} great deal of research into making caches more aggressive. A specific type of cache is the "trace cache" which <b>stores</b> dynamic <b>sequences</b> <b>of</b> <b>instructions</b> as opposed to sequential contiguous blocks. It is the aim of this paper to provide an overview of trace caches against a background of enhancements to standard caches. The basic trace cache architecture is presented together with a survey of several enhancements which have been made to improve its performance. Following this the limitations of trace caches are discussed. 1 Introduction Cache memories have become standard components of modern computer systems. To date they have proven to be extremely successful in offsetting the disparity between CPU and DRAM speed. However, as processor speeds thrust ahead at a rate of 50 to 100 [...] ...|$|R
50|$|In multiprocessing, the {{processors}} {{can be used}} {{to execute}} a single <b>sequence</b> <b>of</b> <b>instructions</b> in multiple contexts (single-instruction, multiple-data or SIMD, often used in vector processing), multiple <b>sequences</b> <b>of</b> <b>instructions</b> in a single context (multiple-instruction, single-data or MISD, used for redundancy in fail-safe systems and sometimes applied to describe pipelined processors or hyper-threading), or multiple <b>sequences</b> <b>of</b> <b>instructions</b> in multiple contexts (multiple-instruction, multiple-data or MIMD).|$|R
5000|$|... doTogether - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{simultaneously}} ...|$|R
5000|$|... direct {{creation}} <b>of</b> whole <b>instructions</b> or <b>sequences</b> <b>of</b> <b>instructions</b> {{in memory}} ...|$|R
50|$|Most {{assemblers}} provide macros {{to generate}} common <b>sequences</b> <b>of</b> <b>instructions.</b>|$|R
5000|$|More formally, a <b>sequence</b> <b>of</b> <b>instructions</b> forms a basic block if: ...|$|R
50|$|Ngram index : <b>Stores</b> <b>sequences</b> <b>of</b> {{length of}} data to support other types of {{retrieval}} or text mining.|$|R
5000|$|... while - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} while a given condition holds ...|$|R
5000|$|... for - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} a given {{number of times}} ...|$|R
5000|$|... forAllInOrder - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} iterating over the given collection ...|$|R
5000|$|... if - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} only under a given condition ...|$|R
50|$|The code may be source code, {{assembly}} code {{or some other}} <b>sequence</b> <b>of</b> <b>instructions.</b>|$|R
50|$|Input: A <b>sequence</b> <b>of</b> <b>instructions</b> (mostly three-address code).Output: A list {{of basic}} blocks with each three-address {{statement}} in exactly one block.|$|R
50|$|The <b>sequence</b> <b>of</b> <b>instructions</b> {{listed above}} will allow two robots with labels 0 and 1 to meet after O(n2c) time steps.|$|R
5000|$|In {{event-driven}} programming, the programmer may write <b>sequences</b> <b>of</b> <b>instructions</b> {{to respond}} to events without specifying an overall sequence for the program.|$|R
5000|$|Conceptually [...] "wrap" [...] {{the full}} <b>sequence</b> <b>of</b> <b>{{instructions}}</b> around the loop, using FADD and FMUL instructions to drive calculations through the pipelines.|$|R
5000|$|... {{hardware}} compilers (also {{known as}} syntheses tools) are compilers whose output is {{a description of}} the hardware configuration instead <b>of</b> a <b>sequence</b> <b>of</b> <b>instructions.</b>|$|R
50|$|When {{writing a}} multi-threaded program, the {{programmer}} may write each thread as a <b>sequence</b> <b>of</b> <b>instructions</b> without specifying the timing <b>of</b> any <b>instruction</b> relative to instructions in other threads.|$|R
30|$|Shift the <b>stored</b> <b>sequence</b> <b>of</b> {{correlator}} outputs by one {{sample and}} repeat the above two steps; repeat this for all possible bit boundaries and identify the shift that yields the maximum output value.|$|R
5000|$|This <b>sequence</b> <b>of</b> <b>instructions</b> generates position-independent code because [...] {{takes an}} instruction-pointer-relative {{immediate}} operand describing the offset in bytes <b>of</b> the target <b>instruction</b> {{from the next}} instruction (in this case 0).|$|R
5000|$|... "In a {{multiprogramming}} or multiprocessing environment, {{one or more}} <b>sequences</b> <b>of</b> <b>instructions</b> {{treated by}} a control program as an element {{of work to be}} accomplished by a computer." ...|$|R
40|$|We {{propose a}} method for {{compressing}} programs in embedded processors where instruction memory size dominates cost. A post-compilation analyzer examines a program and replaces common <b>sequences</b> <b>of</b> <b>instructions</b> with a single instruction codeword. A microprocessor executes the compressed instruction sequences by fetching codewords from the instruction memory, expanding {{them back to the}} original <b>sequence</b> <b>of</b> <b>instructions</b> in the decode stage, and issuing them to the execution stages. We apply our technique to the PowerPC instruction set and achieve 30 % to 50 % reduction in size for SPEC CINT 95 programs. Keywords...|$|R
50|$|A {{computer}} {{program is a}} <b>sequence</b> <b>of</b> <b>instructions</b> that are executed by a CPU. While simple processors execute instructions one after another, superscalar processors are capable <b>of</b> executing several <b>instructions</b> at once.|$|R
5000|$|... “an {{intuitive}} definition <b>of</b> {{an acceptable}} <b>sequence</b> <b>of</b> <b>instructions</b> {{is one in}} which each instruction is precisely defined so that the robot is guaranteed to be able to obey it” (p. 6) ...|$|R
5000|$|Lay out the {{shortest}} <b>sequence</b> <b>of</b> <b>instructions</b> for performing one {{instance of the}} desired calculation, allowing for two-cycle memory latency, and the driving of the floating-point modules with explicit FADD and FMUL instructions.|$|R
2500|$|Cf. in {{particular}} the first chapter titled: Algorithms, Turing Machines, and Programs. His succinct informal definition: [...] "...any <b>sequence</b> <b>of</b> <b>instructions</b> that can be obeyed by a robot, is called an algorithm" [...] (p.4).|$|R
40|$|The <b>sequence</b> <b>of</b> <b>instruction</b> and {{appropriate}} tools for novice learners of object-oriented programming {{has been extensively}} debated. This paper analyzes the learning environment for OO programmers, and presents {{a series of studies}} aimed at finding the <b>sequence</b> <b>of</b> <b>instruction</b> and the corresponding tool that best supports the learning of object-oriented programming, starting with objects first. The studies indicate that starting out with a tool with visualization of object behavior and predefined classes in a toy domain is preferable. After having learnt the basic OO concepts, the learners can proceed to an environment that supports definition of classes for modeling a real world domain. 1...|$|R
5000|$|Macros in software. In some software, a <b>sequence</b> <b>of</b> <b>instructions</b> can be {{associated}} to a keyboard or mouse action. Some software can include {{a programming language}} (like VBA in Microsoft Office) allowing the control of software features.|$|R
50|$|Manual (or static) loop {{unrolling}} {{involves the}} programmer analyzing the loop and interpreting the iterations into a <b>sequence</b> <b>of</b> <b>instructions</b> which {{will reduce the}} loop overhead. This {{is in contrast to}} dynamic unrolling which is accomplished by the compiler.|$|R
40|$|Instructional texts consist <b>of</b> <b>sequences</b> <b>of</b> <b>instructions</b> {{designed}} {{in order to}} reach an objective. The user must follow step by step the instructions {{in order to reach}} the results expected. In this short paper, we explore the different facets of natural argumentation used in such texts. Our study is based on an extensive corpus study, and within a language generation perspective. 1 General typology of instructional texts Instructional texts, also equivalently called procedural texts, consist <b>of</b> a <b>sequence</b> <b>of</b> <b>instructions,</b> designed with some accuracy in order to reach an objective (e. g. assemble a computer). Procedural texts explain how to realize a certain goal by means of actions which are at least partially temporall...|$|R
40|$|We derive in a {{rigorous}} way, {{using a new}} technique, the saddle–point equations of a modified Hopfield model which <b>stores</b> <b>sequences</b> <b>of</b> patterns. We obtain the same equations {{as those of the}} replica-symmetry approach without using the n → 0 limit but assuming selfaveraging of the Edwards-Anderson order parameter...|$|R
40|$|Identifying common {{features}} in Forth programs {{is important for}} those designing Forth machines and optimisers. In this paper we measure the behaviour of six large Forth programs and four small ones. We look at the ratio of user to system code, basic block lengths, common <b>instructions,</b> and common <b>sequences</b> <b>of</b> <b>instructions.</b> Our most important finding is that for most large programs, many (38. 4 %– 47. 6 % statically and 21. 8 %– 40. 9 % dynamically) basic blocks consist of only a single instruction, which hinders optimisation. We also show static measures <b>of</b> frequent <b>instructions</b> and <b>sequences</b> <b>of</b> <b>instructions</b> are more consistent across programs, and {{may be a better}} predictor of the behaviour of other programs than dynamic measures. ...|$|R
5000|$|... :build a new tree <b>storing</b> the <b>sequence</b> <b>of</b> values L at its leaves.|$|R
30|$|The morphological-syntactic {{classifier}} models morphological-syntactic {{classes as}} elements in PPM-C. This model <b>stores</b> <b>sequences</b> <b>of</b> morphological-syntactic classes {{taken from a}} corpus of morphological-syntactic classified BP texts. Once a sentence is received for classification, the most likely morphological-syntactic class of each token is selected according to its context in PPM model.|$|R
5000|$|Character {{and string}} types can <b>store</b> <b>sequences</b> <b>of</b> {{characters}} from a character set such as ASCII. Since most character sets include the digits, {{it is possible}} to have a numeric string, such as [...] However, many languages treat these as belonging to a different type to the numeric value [...]|$|R
5000|$|Return-oriented {{programming}} requires these <b>sequences</b> <b>of</b> <b>instructions</b> called gadgets to {{end with}} a [...] instruction {{in this way the}} attacker can put a <b>sequence</b> <b>of</b> addresses where these gadgets resides and as soon as a [...] instruction is met the control flow will proceed to the next gadget of the list.|$|R
