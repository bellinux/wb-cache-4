778|0|Public
25|$|While local (to a {{database}} system) relaxed <b>serializability</b> methods compromise <b>serializability</b> for performance gain (and are utilized {{only when the}} application can tolerate possible resulting inaccuracies, or its integrity is unharmed), it is unclear that various proposed relaxed global <b>serializability</b> methods which compromise global <b>serializability,</b> provide any performance gain over commitment ordering which guarantees global <b>serializability.</b> Typically, the declared intention of such methods has not been performance gain over effective global <b>serializability</b> methods (which apparently have been unknown to the inventors), but rather correctness criteria alternatives {{due to lack of}} a known effective global <b>serializability</b> method. Oddly, some of them were introduced years after CO had been introduced, and some even quote CO without realizing that it provides an effective global <b>serializability</b> solution, and thus without providing any performance comparison with CO to justify them as alternatives to global <b>serializability</b> for some applications (e.g., Two-level <b>serializability).</b> Two-level <b>serializability</b> is even presented as a major global concurrency control method in a 2010 edition of a text-book on databases (authored by two of the original authors of Two-level <b>serializability,</b> where one of them, Avi Silberschatz, is also an author of the original Strong recoverability articles). This book neither mentions CO nor references it, and strangely, apparently does not consider CO a valid Global <b>serializability</b> solution.|$|E
25|$|Classes of {{schedules}} {{defined by}} relaxed global <b>serializability</b> properties either contain the global <b>serializability</b> class, or are incomparable with it. What differentiates techniques for relaxed global conflict <b>serializability</b> (RGCSR) properties {{from those of}} relaxed conflict <b>serializability</b> (RCSR) properties that are not RGCSR is typically the different way global cycles (span two or more databases) in the global conflict graph are handled. No distinction between global and local cycles exists for RCSR properties that are not RGCSR. RCSR contains RGCSR. Typically RGCSR techniques eliminate local cycles, i.e., provide local <b>serializability</b> (which can be achieved effectively by regular, known concurrency control methods), however, obviously they do not eliminate all global cycles (which would achieve global <b>serializability).</b>|$|E
25|$|In {{concurrency}} control of databases, transaction processing (transaction management), and other transactional distributed applications, Global <b>serializability</b> (or Modular <b>serializability)</b> is a property {{of a global}} schedule of transactions. A global schedule is the unified schedule of all the individual database (and other transactional object) schedules in a multidatabase environment (e.g., federated database). Complying with global <b>serializability</b> means that the global schedule is serializable, has the <b>serializability</b> property, while each component database (module) has a serializable schedule as well. In other words, a collection of serializable components provides overall system <b>serializability,</b> which is usually incorrect. A need in correctness across databases in multidatabase systems makes global <b>serializability</b> a major goal for global {{concurrency control}} (or modular concurrency control). With the proliferation of the Internet, Cloud computing, Grid computing, and small, portable, powerful computing devices (e.g., smartphones), as well as increase in systems management sophistication, the need for atomic distributed transactions and thus effective global <b>serializability</b> techniques, to ensure correctness in and among distributed transactional applications, seems to increase.|$|E
25|$|Also {{the above}} quoted article proposes a relaxed global <b>serializability</b> solution, while {{referencing}} the CO work. The CO solution for global <b>serializability</b> both bridges between different concurrency control protocols with no substantial concurrency reduction (and typically minor, if at all), and maintains {{the autonomy of}} local DBMSs. Evidently also here CO has been misunderstood. This misunderstanding continues to 2010 in a textbook {{by some of the}} same authors, where the same relaxed global <b>serializability</b> technique, Two level <b>serializability,</b> is emphasized and described in detail, and CO is not mentioned at all.|$|E
25|$|Commitment ordering, {{publicly}} {{introduced in}} May 1991 (see below), provides an efficient elegant general solution, from both practical and theoretical points of view, {{to the global}} <b>serializability</b> problem across database systems with possibly different concurrency control mechanisms. It provides conflict <b>serializability</b> with no negative effect on availability, and with no worse performance than the de facto standard for global <b>serializability,</b> CO's special case Strong strict two-phase locking (SS2PL). It requires knowledge about neither local nor global transactions.|$|E
25|$|In a federated {{database}} {{system or}} any other more loosely defined multidatabase system, which are typically distributed in a communication network, transactions span multiple (and possibly distributed) databases. Enforcing global <b>serializability</b> in such system, where different databases may use different types of concurrency control, is problematic. Even if every local schedule of a single database is serializable, the global schedule of a whole system is not necessarily serializable. The massive communication exchanges of conflict information needed between databases to reach conflict <b>serializability</b> globally would lead to unacceptable performance, primarily due to computer and communication latency. Achieving global <b>serializability</b> effectively over different types of concurrency control has been open for several years. Commitment ordering (or Commit ordering; CO), a <b>serializability</b> technique publicly introduced in 1991 by Yoav Raz from Digital Equipment Corporation (DEC), provides an effective general solution for global (conflict) <b>serializability</b> across any collection of database systems and other transactional objects, with possibly different concurrency control mechanisms. CO does not need the distribution of conflict information, but rather utilizes the already needed (unmodified) atomic commitment protocol messages without any further communication between databases. It also allows optimistic (non-blocking) implementations. CO generalizes Strong strict two phase locking (SS2PL), which {{in conjunction with the}} Two-phase commit (2PC) protocol is the de facto standard for achieving global <b>serializability</b> across (SS2PL based) database systems. As a result, CO compliant database systems (with any, different concurrency control types) can transparently join existing SS2PL based solutions for global <b>serializability.</b> The same applies also to all other multiple (transactional) object systems that use atomic transactions and need global <b>serializability</b> for correctness (see examples above; nowadays such need is not smaller than with database systems, the origin of atomic transactions).|$|E
25|$|The {{quotation}} {{above is}} from a 1997 article proposing a relaxed global <b>serializability</b> solution (see Relaxing global <b>serializability</b> below), and referencing Commitment ordering (CO) articles. The CO solution supports effectively both full ACID properties and full local autonomy, as well as meeting the other requirements posed above in the Problem statement section, and apparently has been misunderstood.|$|E
25|$|Find an {{efficient}} (high-performance and fault tolerant) method to enforce Global <b>serializability</b> (global conflict <b>serializability)</b> in a heterogeneous distributed environment of multiple autonomous database systems. The database systems may employ different concurrency control methods. No limitation should {{be imposed on}} the operations of either local transactions (confined to a single database system) or global transactions (span two or more database systems).|$|E
25|$|Heterogeneity: Global <b>serializability</b> is {{achieved}} across multiple transactional objects (e.g., database management systems) with different (any) concurrency control mechanisms, without {{interfering with the}} mechanisms' operations.|$|E
25|$|Consequently, Optimistic {{replication}} (Lazy replication) {{is often}} utilized (e.g., in many {{products and services}} by Google, Amazon, Yahoo, and alike), while Global <b>serializability</b> is relaxed and compromised for Eventual consistency. In this case relaxation is done only for applications that {{are not expected to}} be harmed by it.|$|E
25|$|Another common reason {{nowadays}} for Global <b>serializability</b> relaxation is {{the requirement}} of availability of internet products and services. This requirement is typically answered by large scale data replication. The straightforward solution for synchronizing replicas' updates of a same database object is including all these updates in a single atomic distributed transaction. However, with many replicas such a transaction is very large, and may span several computers and networks {{that some of them}} are likely to be unavailable. Thus such a transaction is likely to end with abort and miss its purpose.|$|E
25|$|All {{the qualities}} of CO in the list above, except the first three, are also possessed by SS2PL, which is a special case of CO, but {{blocking}} and constraining. This partially explains the popularity of SS2PL as a solution (practically, the only solution, for many years) for achieving global <b>serializability.</b> However, property 9 above, automatic resolution of global deadlocks, has not been noticed for SS2PL in the database research literature until today (2009; except in the CO publications). This, since the phenomenon of voting-deadlocks in such environments and their automatic resolution by the atomic commitment protocol has been overlooked.|$|E
2500|$|Some {{techniques}} {{have been developed}} for relaxed global <b>serializability</b> (i.e., they do not guarantee global serializability; see also Relaxing <b>serializability).</b> Among them (with several publications each): ...|$|E
2500|$|... "The {{concept of}} <b>serializability</b> {{has been the}} {{traditionally}} accepted correctness criterion in database systems. However in multidatabase systems (MDBSs), ensuring global <b>serializability</b> is a difficult task. The difficulty arises due to the heterogeneity of the concurrency control protocols used by the participating local database management systems (DBMSs), {{and the desire to}} preserve the autonomy of the local DBMSs. In general, solutions to the global <b>serializability</b> problem result in executions with a low degree of concurrency. The alternative, relaxed <b>serializability,</b> may result in data inconsistency." ...|$|E
2500|$|Lack of an {{appropriate}} {{solution for the}} global <b>serializability</b> problem has driven researchers to look for alternatives to <b>serializability</b> as a correctness criterion in a multidatabase environment (e.g., see Relaxing global <b>serializability</b> below), and {{the problem has been}} characterized as difficult and open. The following two quotations demonstrate the mindset about it {{by the end of the}} year 1991, with similar quotations in numerous other articles: ...|$|E
2500|$|Global {{conflict}} graph (<b>serializability</b> graph, precedence graph) checking ...|$|E
2500|$|Commitment {{ordering}} (or Commit ordering; CO) is {{the only}} high-performance, fault tolerant, conflict <b>serializability</b> providing solution that has been proposed as a fully distributed (no central computing component or data-structure are needed), general mechanism that can be combined seamlessly with any local (to a database) concurrency control mechanism (see technical summary). Since the CO property of a schedule is {{a necessary condition for}} global <b>serializability</b> of autonomous databases (in the context of concurrency control), it provides the only general solution for autonomous databases (i.e., if autonomous databases do not comply with CO, then global <b>serializability</b> may be violated). Seemingly by sheer luck, the CO solution possesses many attractive properties: ...|$|E
2500|$|Several solutions, some partial, {{have been}} {{proposed}} for the global <b>serializability</b> problem. Among them: ...|$|E
2500|$|Most {{existing}} database systems, {{including all}} major commercial database systems, are strong strict two phase locking (SS2PL) based and already CO compliant. Thus they {{can participate in}} a CO based solution for global <b>serializability</b> in multidatabase environments without any modification (except for the popular multiversioning, where additional CO aspects should be considered). Achieving global <b>serializability</b> across SS2PL based databases using atomic commitment (primarily using two phase commit, 2PC) has been employed for many years (i.e., using the same CO solution for a specific special case; however, no reference is known prior to CO, that notices this special case's automatic global deadlock resolution by the atomic commitment protocol's augmented-conflict-graph global cycle elimination process). Virtually all existing distributed transaction processing environments and supporting products rely on SS2PL and provide 2PC. As {{a matter of fact}} SS2PL together with 2PC have become a de facto standard. This solution is a homogeneous concurrency control one, suboptimal (when both <b>Serializability</b> and Strictness are needed; see Strict commitment ordering; SCO) but still quite effective in most cases, sometimes at the cost of increased computing power needed relatively to the optimum. (However, for better performance relaxed <b>serializability</b> is used whenever applications allow). It allows inter-operation among SS2PL-compliant different database system types, i.e., allows heterogeneity in aspects other than concurrency control. SS2PL is a very constraining schedule property, and [...] "takes over" [...] when combined with any other property. For example, when combined with any optimistic property, the result is not optimistic anymore, but rather characteristically SS2PL. On the other hand, CO does not change data-access scheduling patterns at all, and any combined property's characteristics remain unchanged. Since also CO uses atomic commitment (e.g., 2PC) for achieving global <b>serializability,</b> as SS2PL does, any CO compliant database system or transactional object can transparently join existing SS2PL based environments, use 2PC, and maintain global <b>serializability</b> without any environment change. This makes CO a straightforward, natural generalization of SS2PL for any conflict <b>serializability</b> based database system, for all practical purposes.|$|E
2500|$|The most {{significant}} aspects of CO {{that make it}} a uniquely effective general solution for global <b>serializability</b> are the following: ...|$|E
2500|$|... allows heterogeneity: Global <b>serializability</b> is {{achieved}} across multiple transactional objects with different (any) concurrency control mechanisms, without {{interfering with the}} mechanisms' operations.|$|E
2500|$|The {{problem of}} global <b>serializability</b> {{has been a}} quite intensively {{researched}} subject in the late 1980s and early 1990s. Commitment ordering (CO) has provided an effective general solution to the problem, insight into it, and understanding about possible generalizations of strong strict two phase locking (SS2PL), which practically and almost exclusively has been utilized (in conjunction with the Two-phase commit protocol (2PC) [...] ) since the 1980s to achieve global <b>serializability</b> across databases. An important side-benefit of CO is the automatic global deadlock resolution that it provides (this is applicable also to distributed SS2PL; though global deadlocks have been an important research subject for SS2PL, automatic resolution has been overlooked, except in the CO articles, until today (2009)). At that time quite many commercial database system types existed, many non-relational, and databases were relatively very small. Multi database systems were considered a key for database scalability by database systems interoperability, and global <b>serializability</b> was urgently needed. Since then the tremendous progress in computing power, storage, and communication networks, resulted in orders of magnitude increases in both centralized databases' sizes, transaction rates, and remote access to database capabilities, as well as blurring the boundaries between centralized computing and distributed one over fast, low-latency local networks (e.g., Infiniband). These, together with progress in database vendors' distributed solutions (primarily the popular SS2PL with 2PC based, a de facto standard that allows interoperability among different vendors' (SS2PL-based) databases; both SS2PL and 2PC technologies have gained substantial expertise and efficiency), workflow management systems, and database replication technology, in most cases have provided satisfactory and sometimes better information technology solutions without multi database atomic distributed transactions over databases with different concurrency control (bypassing the problem above). As a result, {{the sense of urgency}} that existed with the problem at that period, and in general with high-performance distributed atomic transactions over databases with different concurrency control [...] types, has reduced. However, the need in concurrent distributed atomic transactions as a fundamental element of reliability exists in distributed systems also beyond database systems, and so the need in global <b>serializability</b> as a fundamental correctness criterion for such transactional systems (see also Distributed <b>serializability</b> in <b>Serializability).</b> With the proliferation of the Internet, Cloud computing, Grid computing, small, portable, powerful computing devices (e.g., smartphones), and sophisticated systems management the need for effective global <b>serializability</b> techniques to ensure correctness in and among distributed transactional applications seems to increase, and thus also the need in Commitment ordering (including the popular for databases special case SS2PL; SS2PL, though, does not meet the requirements of many other transactional objects).|$|E
2500|$|The only {{overhead}} {{incurred by}} the CO solution is locally detecting conflicts (which is already done by any known <b>serializability</b> mechanism, both pessimistic and optimistic) and locally ordering in each database system both the (local) commits of local transactions and the voting for atomic commitment of global transactions. Such overhead is low. The {{net effect of}} CO may be some delays of commit events (but never more delay than SS2PL, and on the average less). This makes CO instrumental for global concurrency control of multidatabase systems (e.g., federated database systems). The underlying Theory of Commitment ordering, part of <b>Serializability</b> theory, is both sound and elegant (and even [...] "mathematically beautiful"; referring to structure and dynamics of conflicts, graph cycles, and deadlocks), with interesting implications for transactional distributed applications.|$|E
2500|$|... "Without {{knowledge}} about local {{as well as}} global transactions, {{it is highly unlikely}} that efficient global concurrency control can be provided... Additional complications occur when different component DBMSs [...] and the FDBMSs [...] support different concurrency mechanisms... It is unlikely that a theoretically elegant solution that provides conflict <b>serializability</b> without sacrificing performance (i.e., concurrency and/or response time) and availability exists." ...|$|E
2500|$|... processes. CO was {{disclosed}} {{outside of}} DEC by lectures and technical reports' distribution to database researches in May 1991, immediately after its first patent filing. It has been misunderstood by many database researchers {{years after its}} introduction, which is evident by the quotes above from articles in 1997-1998 referencing Commitment ordering articles. On the other hand, CO has been utilized extensively as a solution for global <b>serializability</b> in works on Transactional processes, ...|$|E
50|$|While local (to a {{database}} system) relaxed <b>serializability</b> methods compromise <b>serializability</b> for performance gain (and are utilized {{only when the}} application can tolerate possible resulting inaccuracies, or its integrity is unharmed), it is unclear that various proposed relaxed global <b>serializability</b> methods which compromise global <b>serializability,</b> provide any performance gain over commitment ordering which guarantees global <b>serializability.</b> Typically, the declared intention of such methods has not been performance gain over effective global <b>serializability</b> methods (which apparently have been unknown to the inventors), but rather correctness criteria alternatives {{due to lack of}} a known effective global <b>serializability</b> method. Oddly, some of them were introduced years after CO had been introduced, and some even quote CO without realizing that it provides an effective global <b>serializability</b> solution, and thus without providing any performance comparison with CO to justify them as alternatives to global <b>serializability</b> for some applications (e.g., Two-level <b>serializability).</b> Two-level <b>serializability</b> is even presented as a major global concurrency control method in a 2010 edition of a text-book on databases (authored by two of the original authors of Two-level <b>serializability,</b> where one of them, Avi Silberschatz, is also an author of the original Strong recoverability articles). This book neither mentions CO nor references it, and strangely, apparently does not consider CO a valid Global <b>serializability</b> solution.|$|E
50|$|In {{database}} {{systems and}} transaction processing (transaction management) global concurrency control {{relates to the}} concurrency control of a multidatabase system (for example, a Federated database; other examples are Grid computing and Cloud computing environments). It deals with {{the properties of the}} global schedule, which is the unified schedule of the multidatabase system, comprising all the individual schedules of the database systems and possibly other transactional objects in the system. A major goal for global concurrency control is Global <b>serializability</b> (or Modular <b>serializability).</b> The problem of achieving global <b>serializability</b> in a heterogeneous environment had been open for many years, until an effective solution based on Commitment ordering (CO) has been proposed (see Global <b>serializability).</b> Global concurrency control deals also with relaxed forms of global <b>serializability</b> which compromise global <b>serializability</b> (and in many applications also correctness, and thus are avoided there). While local (to a database system) relaxed <b>serializability</b> methods compromise <b>serializability</b> for performance gain (utilized when the application allows), it is unclear that the various proposed relaxed global <b>serializability</b> methods provide any performance gain over CO, which guarantees global <b>serializability.</b>|$|E
50|$|Global ECO (all global cycles in {{the global}} {{conflict}} graph are eliminated by atomic commitment) together with Local <b>serializability</b> (i.e., each database system maintains <b>serializability</b> locally; all local cycles are eliminated) imply Global <b>serializability</b> (all cycles are eliminated). This means that if each database system in a multidatabase environment provides local <b>serializability</b> (by any mechanism) and enforces the vote ordering strategy in the theorem above (a generalization of CO's vote ordering strategy), then Global <b>serializability</b> is guaranteed (no local CO is needed anymore).|$|E
50|$|Global <b>serializability,</b> {{where the}} Global <b>serializability</b> problem and its {{proposed}} solutions are described.|$|E
50|$|Classes of {{schedules}} {{defined by}} relaxed global <b>serializability</b> properties either contain the global <b>serializability</b> class, or are incomparable with it. What differentiates techniques for relaxed global conflict <b>serializability</b> (RGCSR) properties {{from those of}} relaxed conflict <b>serializability</b> (RCSR) properties that are not RGCSR is typically the different way global cycles (span two or more databases) in the global conflict graph are handled. No distinction between global and local cycles exists for RCSR properties that are not RGCSR. RCSR contains RGCSR. Typically RGCSR techniques eliminate local cycles, i.e., provide local <b>serializability</b> (which can be achieved effectively by regular, known concurrency control methods), however, obviously they do not eliminate all global cycles (which would achieve global <b>serializability).</b>|$|E
50|$|Mechanisms that enforce <b>serializability</b> need {{to execute}} in real time, or almost in real time, while {{transactions}} are running at high rates. In {{order to meet}} this requirement special cases of <b>serializability,</b> sufficient conditions for <b>serializability</b> which can be enforced effectively, are utilized.|$|E
50|$|Classes of {{schedules}} {{defined by}} relaxed <b>serializability</b> properties either contain the <b>serializability</b> class, or are incomparable with it.|$|E
5000|$|... (Local, {{which implies}} global) ECO {{together}} with local conflict <b>serializability,</b> is a sufficient condition to guarantee global conflict <b>serializability.</b>|$|E
50|$|In {{concurrency}} control of databases, transaction processing (transaction management), and other transactional distributed applications, Global <b>serializability</b> (or Modular <b>serializability)</b> is a property {{of a global}} schedule of transactions. A global schedule is the unified schedule of all the individual database (and other transactional object) schedules in a multidatabase environment (e.g., federated database). Complying with global <b>serializability</b> means that the global schedule is serializable, has the <b>serializability</b> property, while each component database (module) has a serializable schedule as well. In other words, a collection of serializable components provides overall system <b>serializability,</b> which is usually incorrect. A need in correctness across databases in multidatabase systems makes global <b>serializability</b> a major goal for global {{concurrency control}} (or modular concurrency control). With the proliferation of the Internet, Cloud computing, Grid computing, and small, portable, powerful computing devices (e.g., smartphones), as well as increase in systems management sophistication, the need for atomic distributed transactions and thus effective global <b>serializability</b> techniques, to ensure correctness in and among distributed transactional applications, seems to increase.|$|E
5000|$|Some {{techniques}} {{have been developed}} for relaxed global <b>serializability</b> (i.e., they do not guarantee global serializability; see also Relaxing <b>serializability).</b> Among them (with several publications each): ...|$|E
5000|$|... "The {{concept of}} <b>serializability</b> {{has been the}} {{traditionally}} accepted correctness criterion in database systems. However in multidatabase systems (MDBSs), ensuring global <b>serializability</b> is a difficult task. The difficulty arises due to the heterogeneity of the concurrency control protocols used by the participating local database management systems (DBMSs), {{and the desire to}} preserve the autonomy of the local DBMSs. In general, solutions to the global <b>serializability</b> problem result in executions with a low degree of concurrency. The alternative, relaxed <b>serializability,</b> may result in data inconsistency." ...|$|E
