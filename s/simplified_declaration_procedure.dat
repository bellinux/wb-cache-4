0|60|Public
30|$|The Simplified Express Consignment Clearance System {{was first}} {{introduced}} in Taiwan in 2001 to improve the effectiveness and efficiency of customs clearance operations of air cargo. This system, {{which is based on}} <b>simplified</b> <b>declaration</b> <b>procedures,</b> is expected to facilitate the effective and efficient collection of taxes and duties even with limited manpower. The Customs Administration (CA) has highlighted the system’s efficiency, but its effectiveness is yet to be validated. Thus, this study comprehensively examines this system by adopting both bottom–up and top–down approaches from operation and policy perspectives.|$|R
5000|$|A typedef {{may be used}} to <b>simplify</b> the <b>declaration</b> of a {{compound}} type (struct, union) or pointer type. [...] For example, in the following snippet: ...|$|R
5000|$|Another {{case where}} proceduring was used was the <b>declaration</b> of <b>procedures,</b> in the declaration: ...|$|R
5000|$|Typedefs {{can also}} <b>simplify</b> {{definitions}} or <b>declarations</b> for structure pointer types. Consider this: ...|$|R
5000|$|Both IAL and ALGOL 60 allow nesting of <b>procedure</b> <b>declarations</b> and the {{corresponding}} identifier scopes.|$|R
5000|$|A <b>procedure</b> <b>declaration</b> {{consists}} of the keyword , followed by a unique procedure identifier and a statement: ...|$|R
40|$|The closing decade for Italy {{has been}} marked by the most {{important}} fiscal consolidation effort among the euro zone countries. The discretionary dimension of consolidation, although pursued in an unstable political environment, has been significant and the effort entirely structural. Italy has not completely allowed fiscal stabilisers to work and stabilisation has been based on pro-cyclical tax growth. The restrictive fiscal stance, coupled with tight monetary conditions has penalised growth, amplified the gap with the European Union and caused a fall in households disposable income. The increase in tax revenues, {{as a result of a}} comprehensive reform of taxation and of the tax <b>declaration</b> <b>procedure,</b> has allowed to lower personal income tax. At the eve of the new decade Italy can slow the consolidation process and orient fiscal policy to support recently accelerating economic growth. ...|$|R
40|$|A {{survey of}} various results {{concerning}} Hoare's approach to proving partial and total correctness of programs is presented. Emphasis {{is placed on}} the soundness and completeness issues. Various proof systems for while programs, recursive <b>procedures,</b> local variable <b>declarations,</b> and <b>procedures</b> with parameters, together with the corresponding soundness, completeness, and incompleteness results, are discussed...|$|R
5000|$|... the {{principle}} of correspondence : The rules governing names should be uniform and apply everywhere. This primarily applies to correspondence between <b>declarations</b> and <b>procedure</b> parameters, including consideration of all parameter passing modes. This principle was examined by R. D. Tennent in conjunction with Pascal, and {{has its roots in}} work by Peter Landin and Christopher Strachey.|$|R
5000|$|IAL <b>procedure</b> <b>declarations</b> provide {{separate}} declaration lists for {{input and output}} parameters, a procedure can return multiple values; this mechanism was replaced in ALGOL 60 with the value declaration.|$|R
30|$|The Simplified Express Consignment Clearance System (the SECCS) for aircargo was {{introduced}} in Taoyuan Airport, Taiwan, in 2001 to provide an efficient consignment clearance service for express aircargo operators. This system has booted efficiency by streamlining the <b>declaration</b> <b>procedures.</b> However, the Customs Administration (CA), customs officers, customs brokers, and consignees disagree as regards {{the effectiveness of the}} SECCS. To conduct a comprehensive analysis of the system, this study examines the SECCS operations in detail and identifies the critical influencing factors. Suggestions based on the findings are then offered to strengthen the system’s effectiveness. The research scope is expanded to cover the development and structure of the SECCS. This paper makes several contributions. First, this paper examines the CA’s development of the express consignment clearance system. Second, this paper analyzes the consignment clearance system’s effectiveness and identifies critical factors. Third, this paper provides new insights into the system flaw and examines the trade-off between the system’s efficiency and effectiveness.|$|R
40|$|We first {{introduce}} a novel modeling framework, called linear coupled component automata (LCCA), {{to facilitate the}} modeling of discrete-continuous dynamical systems with piecewise constant derivatives. Second, we provide a procedure for transforming models in this framework to mixed-integer linear programming (MILP) constraints. Traditionally, such systems have been modeled directly with MILP constraints. We show with an example that our framework significantly <b>simplifies</b> model <b>declaration</b> and allows the complex MILP constraints to be produced systematically. Key words: hybrid automata; modeling frameworks; optimization; discrete-continuous systems...|$|R
40|$|In {{international}} trade, reliability, {{security and}} cost effective logistic chain management {{are very important}} challenges {{that can only be}} met by innovative usages of IT. The Extended Single Window project aims at a drastic reduction of physical inspections of goods in main ports by coordinated planning of government authorities, reliable transport to and from hinterland hubs and administrative cost reduction. Although quite some efficiency gains can be achieved already by improving the data logistics, a higher level of innovation requires a re-engineering of the control processes. Service-Oriented Auditing (SOAu) stands for the integrated application of smart auditing techniques in the framework of a Service-Oriented Architecture. In this article we evaluate the SOAu methodology on a B 2 G case study. From this study we have identified seven challenges: 1 -simplifying <b>declaration</b> <b>procedures</b> 2 -alignment of (multiple) inspections 3 -data quality 4 - increasing inspections efficiency 5 -online monitoring 6 -electronic data delivery 7 -collaborative testing. We examine to what extent SOAu can provide solution directions for each challenge...|$|R
50|$|Libraries in ALGOL 68RS {{are written}} using {{declaration}} modules which {{consist of a}} sequence of mode, variable, operator and <b>procedure</b> <b>declarations</b> followed by a keep list which defines which declarations are visible to other segments.|$|R
5000|$|The <b>declaration</b> of the <b>procedure</b> is {{decorated}} with annotations that define a command line syntax allowing the program to be called from SCL, or used from an interactive shell with prompting for default parameter values.|$|R
5000|$|Identifiers are {{distinguished}} by their definition within the current scope. For example, a ⟨procedure identifier⟩ is an identifier {{that has been}} defined by a <b>procedure</b> <b>declaration,</b> a ⟨label identifier⟩ is an identifier {{that is being used}} as a goto label.|$|R
50|$|In {{the third}} and last edition of his book on {{compiler}} construction, Wirth replaced PL/0 with Oberon-0. The compiler is still presented in its entirety, although the language Oberon-0 is much more complex than PL/0. For example, Oberon-0 offers arrays, records, type <b>declarations</b> and <b>procedure</b> parameters. The publisher of Wirth's books (Addison-Wesley) has decided to phase out all his books, but Wirth revised the third edition of his book in 2005 {{and the result is}} now available online.|$|R
40|$|We {{investigate}} {{the origin of}} recursive procedures in imperative programming languages. We attempt {{to set the record}} straight, and to identify the trend that led to recursive procedures, by means of an analysis of the related concepts and of the most reliable available documents, as far as known to us. We show that not all of those who were involved in defining these concepts in these documents were fully aware of the implications of their proposals. Our aim is not primarily historical, but to contribute to a clarification of some of the concepts related to recursion. In particular, we demonstrate that recursive <b>procedure</b> <b>declarations</b> and recursive <b>procedure</b> activations are logically disjoint concepts...|$|R
40|$|Current customs {{applications}} are declaration based {{to support the}} various customs procedures based on (inter) national laws and regulations. To {{be able to perform}} a proper supply chain risk analysis, customs requires to have all data in supply chains. The current <b>declaration</b> <b>procedures</b> are not sufficient since they do not supported retrieval of containers stuffing information resulting in the fact that authorities do not have a complete data set. It has been shown that enterprises already have a lot of data available to meet their customer requirements that can be made directly accessible to authorities, instead of 'pushing' data to the authorities based on procedures. By not only making this data available to customs but also to other authorities, they also comply with Single Window implementations. There are various solutions to data retrieval, e. g. a Service Oriented Architecture (SOA) offers a potential solution. The proposed approach in this paper is based on Linked Open Data (LOD) and implies innovative IT to be implemented by both authorities and enterprises in supply chains. The paper discusses LOD and its application to supply chain risk analysis. The proposed solution allows authorities to govern global supply chains in supply networks...|$|R
5000|$|Formal declarers are {{the modes}} {{on the left}} hand side of an {{identity}} declaration, or the modes specified in a <b>procedure</b> <b>declaration.</b> In the original language they could include array bounds and specified whether the matching actual declarer was fixed, flex or either: ...|$|R
40|$|Severe and {{widespread}} drought occurred {{over a large}} portion of the United States between 1974 and 1977. Impacts on agriculture and other industries, as well as local water supplies, were substantial. The federal government responded with forty assistance programs administered by sixteen federal agencies. Assistance was provided primarily in the form of loans and grants to people, businesses and governments experiencing hardship caused by drought. The total cost of the program is estimated at $ 7 - 8 billion. Federal response to the mid- 1970 s drought was largely untimely, ineffective and poorly coordinated. Four recommendations are offered that, if implemented, would improve future drought assessment and response efforts: 1) reliable and timely informational products and dissemination plans; 2) improved impact assessment techniques, especially in the agricultural sector, for use by government to identify periods of enhanced risk and to trigger assistance measures; 3) administratively centralized drought <b>declaration</b> <b>procedures</b> that are well publicized and consistently applied; and 4) standby assistance measures that encourage appropriate levels of risk management by producers and that are equitable, consistent and predictable. The development of a national drought plan that incorporates these four items is recommended. Atmospheric scientists have an important role to play in the collection and interpretation of near-real time weather data for use by government decision makers...|$|R
40|$|International audienceWe {{propose a}} finite {{structural}} translation of possibly recursive π-calculus terms into Petri nets. This {{is achieved by}} using high-level nets together with an equivalence on markings in order to model entering into recursive calls, which {{do not need to}} be guarded. We view a computing system as consisting of a main program (π-calculus term) together with <b>procedure</b> <b>declarations</b> (recursive definitions of π-calculus identifiers). The control structure of these components is represented using disjoint high-level Petri nets, one for the main program and one for each of the <b>procedure</b> <b>declarations.</b> The program is executed once, while each procedure can be invoked several times (even concurrently), each such invocation being uniquely identified by structured tokens which correspond to the sequence of recursive calls along the execution path leading to that invocation...|$|R
5000|$|... {{when the}} form [...] evaluates to [...] causes {{execution}} of the loop to terminate with the value [...] The value of the last statement in a block ( ... form becomes {{the value of the}} block form. The value of the form in a <b>procedure</b> <b>declaration</b> becomes the result of the procedure call.|$|R
30|$|One {{point of}} utmost {{importance}} is how to guarantee the reliability of COOL information. In the second round, the experts discussed the necessity of traceability certificate to support origin declaration and the control of origin <b>declaration</b> in customs <b>procedure.</b> This topic refers to official inspection, but not for providing information to consumers.|$|R
40|$|We {{propose a}} finite {{structural}} translation of possibly recursive π-calculus terms into Petri nets. This {{is achieved by}} using high-level nets together with an equivalence on markings in order to model entering into recursive calls, which {{do not need to}} be guarded. We view a computing system as consisting of a main program (π-calculus term) together with <b>procedure</b> <b>declarations</b> (recursive definitions of π-calculus identifiers). The control structure of these components is represented using disjoint high-level Petri nets, one for the main program and one for each of the <b>procedure</b> <b>declarations.</b> The program is executed once, while each procedure can be invoked several times (even concurrently), each such invocation being uniquely identified by structured tokens which correspond to the sequence of recursive calls along the execution path leading to that invocation. © 2008 British Computer Society. SCOPUS: ar. jinfo:eu-repo/semantics/publishe...|$|R
50|$|In {{strongly}} typed programming languages, each parameter's type must be {{specified in}} the <b>procedure</b> <b>declaration.</b> Languages using type inference attempt to discover the types automatically from the function's body and usage. Dynamically typed programming languages defer type resolution until run-time. Weakly typed languages perform little to no type resolution, relying instead on the programmer for correctness.|$|R
50|$|Anyone who has {{attempted}} to maintain coherence amongst the declarations and usages of procedures in a large program and its usage of libraries of routines, especially one undergoing changes, will have struggled over the usage of forward or similar added <b>declarations</b> for <b>procedures</b> invoked but not defined in the current compilation. Maintaining synchrony between widely-separated locations especially across different source files requires diligence. Those declarations using the reserved word are easy to find, but if the helpful declarations are not distinguished from ordinary declarations, the task becomes troublesome. The gain of supposedly swifter compilation may seem insufficient when simply abandoning the goal of one-pass compilation would remove this imposition.|$|R
40|$|The {{well-known}} static link {{technique is}} used for stack-based implementations of imperative programming languages which admit nested recursive <b>procedure</b> <b>declarations.</b> Its basic idea is to access non [...] local variables by tracing a static link chain to lower stack elements. Evolving algebras are a new method for defining operational semantics of abstract machines. Based on an appropriate stack machine, defined as an evolving algebra, and a functional description of a compiler for a sample language, we give a complete proof of correctness for this technique using the method of refinement. Introduction The assignment of values to variables is at the basis of imperative programming languages. Consequently, the way variables are accessed is crucial {{for the implementation of}} such languages. This is an easy task {{as long as there is}} either no recursion (as with FORTRAN 77) or no nested <b>procedure</b> <b>declarations</b> (as with C) in the language. In the first case, each variable in the program gets a stat [...] ...|$|R
5000|$|Despite this, the {{original}} IP Pascal implementation ran until 1987 {{as a general}} purpose compiler. In this phase, IP Pascal was C like in its modular layout. Each source file was a unit, and consisted of some combination of a 'program' module, types, constants, variables, procedures or functions. These were in [...] "free format". Procedures, functions, types, constants and variables could be outside of any block, and in any order. Procedures, functions, and variables in other files were referenced by 'external' <b>declarations,</b> and <b>procedures,</b> functions, and variables in the current file were declared 'global'. Each file was compiled to an object file, and then linked together. There was no type checking across object files.|$|R
50|$|Pascal, {{like many}} {{programming}} languages of today (but unlike most languages in the C family), allows nested procedure definitions to {{any level of}} depth, and also allows most kinds of definitions and <b>declarations</b> inside subroutines (<b>procedures</b> and functions). This enables a very simple and coherent syntax where a complete program is syntactically nearly identical to a single procedure or function (except for the heading, which has one of these three keywords).|$|R
40|$|To {{represent}} {{mutually exclusive}} procedures, we propose a choice-conjunctive declaration {{statement of the}} form $uchoo(S,R) $ where $S, R$ are the <b>procedure</b> <b>declaration</b> statements within a module. This statement has the following semantics: request the machine to choose a successful one between $S$ and $R$. This statement is useful for representing objects with mutually exclusive procedures. We illustrate our idea via C^uchoo, {{an extension of the}} core C with a new statement. Comment: 3 page...|$|R
40|$|Rule-based versus procedure-based view {{of logic}} {{programming}} Krzysztof R. Apt, Jan-Georg Smaus Logic programming is a rule-based formalism: a program {{consists of a}} set of rules activated by an initial query. In contrast, imperative programming is explained by means of a procedure-based view: a program consists {{of a set of}} <b>procedure</b> <b>declarations</b> and an initial statement. We clarify here to what procedure-based formalism logic programming corresponds. To this end we introduce a procedure-based view based on a subset of first-order logic and assign to it an operational semantics. We establish two results. First, we show that a syntactic transformation that forms part of Clark's completion of a logic program provides a translation from the rule-based view to the procedure-based view. Second, we show that the transformations in the spirit of Lloyd-Topor provide a translation from the procedurebased view to the rule-based view. Finally, we discuss the consequences of adoption of each view for the design of logic programming languages. 1. Introduction Logic programming is a rule-based formalism: a program consists of a collection of rules that are activated by means of an initial query. This approach to programming {{has to do with the}} automated theorem proving roots of logic programs. In fact, each rule or query is a Horn clause and the computation process corresponds to a specialised form of the resolution method. In imperative programs, for example in Pascal or C, a different view is taken according to which a program consists of a collection of <b>procedure</b> <b>declarations</b> together with an initial statement. Each <b>procedure</b> <b>declaration</b> consists of a procedure name followed by (the specification of the types of) the formal parameters and the procedure body, which is a statement. In turn, the statements are defined by structural induction starting with the atomic statements and using compound statements. We call this approach a procedure-based formalism...|$|R
40|$|Abstract The Energy Declaration is a {{law that}} will come into effect October 1 : Th 2006. This report has Värnamo {{municipality}} as principal and shall clarify what the estate owner in general and Värnamo municipality in particular {{need to know about}} this law. Another part {{that is going to be}} dealt with is how large the future need for energy experts in this field will be, and which competence that will be demanded for them. The work will in general deal with <b>simplified</b> energy <b>declarations</b> for apartment houses and public buildings, since these buildings are the first to be involved with energy declarations. The energy declaration will consist of a number of important components. • Energy power i. e. how much energy the building consume • If the ventilation control is done • If the radon measurement is carried out • Recommendations of measures to improve the energy power • Reference value to compare the buildings energy power against According to the law the declaration shall been made by an independent expert, which will need certain information for this. The estate owner will need to collect some of this information. To simplify the collection of information a model was developed that can be used by the estate owner. The model was tested on Trälleborgskolan in Värnamo. It worked well because energy statistics were available from Värnamo municipality estate department. Regarding the energy consumption monthly statistics were also available which was desirable. Some improvement can been made by correlate the heat consumption for a normal year. There will be an estimated need for about 500 - 1000 energy experts to work with energy declarations in the future. The requirements on these experts are apart from the right education, also a couple of years of experience from the energy business. This can be hard to fulfil for a newly examined engineer. This report focuses on the <b>simplified</b> energy <b>declaration.</b> In a couple of years when building will need to be inspected more thoroughly, there might be a need for more information to be collected. How this can be done in the different estate management computer software that are available, could be a base for future work in this area...|$|R
40|$|The {{mathematical}} viability theory offers {{concepts and}} methods that are suitable {{to study the}} compatibility between a dynamical system described {{by a set of}} differential equations and constraints in the state space. The result sets built during the viability analysis can give very useful information regarding management issues in fields where it is easier to discuss constraints than objective functions. However, computational problems arise very quickly with the number of state variables, and the practical implementation of the method is difficult, although there exists a convergent numerical scheme and several approaches to bypass the computational problems. In order to popularize the use of viability analysis we propose a framework in which the viability sets are represented and approximated with particular kd-trees. The computation of the viability kernel is seen as an active learning problem. We prove the convergence of the algorithm and assess the approximation it produces for known problems with analytical solution. This framework aims at <b>simplifying</b> the <b>declaration</b> of the viability problem and provides useful methods to assist further use of viability sets produced by the computation...|$|R
40|$|Issues {{concerning}} {{the implementation of}} a notion of modules in the higher-order logic programming language Prolog are examined. A program in this language is a composite of type <b>declarations</b> and <b>procedure</b> definitions. The module construct that is considered permits large collections of such declarations and definitions to be decomposed into smaller units. Mechanisms are provided for controlling the interaction of these units and for restricting the visibility of names used within any unit. The typical interaction between modules has both a static and a dynamic nature. The parsing of expressions in a module might require declarations in a module that it interacts with, and this information must be available during compilation. Procedure definitions within a module might utilize procedures presented in other modules and support must be provided for making the appropriate invocation during execution. Our concern here is largely with the dynamic aspects of module interaction. We describe a [...] ...|$|R
40|$|The {{question}} {{investigated in}} this paper is: How does ACT-R propitiate as an architecture for modeling the search and evaluation of (scientific) hypotheses? It is demonstrated how inductive search, modeled by Paul Thagard's PI and Herbert Simon's BACON. 1, can easily be learned from examples by ACT-R 3. 0 {{as a form of}} abductive inference. Furthermore, I argue that PI's hypothesis evaluation process 'inference to the best explanation' is subsumed by ACT-R's rational analysis mechanism. Contents 1 Introduction 2. Primary and secondary cognition <b>Declarations</b> and <b>procedures</b> Structures and processes Creation and modification Selection Evaluation 3. Abductive inference Simple abduction in PI Learning ACT-R abduction - part 1 Abduction as search in BACON. 1 Learning ACT-R abduction - part 2 4. Conclusion Bibliography 2 1. Introduction In cognitive science, scientific endeavor itself is being studied as an interesting cognitive phenomenon. One popular view is taking scientific discovery, or t [...] ...|$|R
