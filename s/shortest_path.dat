9351|4806|Public
5|$|In graph algorithms, {{the widest}} path {{problem is the}} problem of finding a path between two {{designated}} vertices in a weighted graph, maximizing the weight of the minimum-weight edge in the path. The widest path problem is also known as the bottleneck <b>shortest</b> <b>path</b> problem or the maximum capacity path problem. It is possible to adapt most <b>shortest</b> <b>path</b> algorithms to compute widest paths, by modifying them to use the bottleneck distance instead of path length. However, in many cases even faster algorithms are possible.|$|E
5|$|Some {{algorithms}} become simpler {{when used}} on DAGs instead of general graphs, {{based on the}} principle of topological ordering. For example, it is possible to find shortest paths and longest paths from a given starting vertex in DAGs in linear time by processing the vertices in a topological order, and calculating the path length for each vertex to be the minimum or maximum length obtained via any of its incoming edges. In contrast, for arbitrary graphs the <b>shortest</b> <b>path</b> may require slower algorithms such as Dijkstra's algorithm or the Bellman–Ford algorithm, and longest paths in arbitrary graphs are NP-hard to find.|$|E
5|$|Each {{enemy was}} {{designed}} to exhibit a unique behavior toward the character; random elements were programmed into the enemies' behaviors to make the game more interesting. The first two designed were the simplest: Electrodes and Grunts. Electrodes are stationary objects that are lethal to the in-game characters, and Grunts are simple robots that chase the protagonist by plotting the <b>shortest</b> <b>path</b> to him. Grunts were designed to overwhelm the player with large groups. While testing the game with the new control system and the two enemies, Jarvis and DeMar were impressed by the gameplay's excitement and fun. As a result, they began steadily {{increasing the number of}} on-screen enemies to over a hundred to see if more enemies would generate more enjoyment.|$|E
3000|$|..., {{characterizing the}} sinusoids of the <b>shortest</b> <b>paths</b> to the array elements, that will contain the {{location}} information of the MT, if the <b>shortest</b> <b>paths</b> are the direct paths.|$|R
30|$|Here: i, j,k ϵ N and σ(i)jk is {{the number}} of <b>shortest</b> <b>paths</b> between j and k that pass through i; σjk is the total number of <b>shortest</b> <b>paths</b> between j and k.|$|R
30|$|A {{multihop}} range-free localization algorithm with approximate <b>shortest</b> <b>paths</b> {{was proposed}} for anisotropic networks. In the proposed algorithm, each normal node approximates the <b>shortest</b> <b>paths</b> to two arbitrary anchors with a virtual hole placed between the anchors and estimates the distances to the anchors by considering how much their approximate <b>shortest</b> <b>paths</b> are detoured. By using approximate <b>shortest</b> <b>paths,</b> the proposed algorithm can effectively handle with the anisotropic network localization problem with fewer anchors compared to existing range-free algorithms. Through extensive computer simulations, we {{demonstrated that the}} proposed algorithm enhances the distance estimation accuracy and achieves improved localization performance than other range-free algorithms with {{a small number of}} anchors.|$|R
5|$|Important {{polynomial}} time computational problems on DAGs include topological sorting (finding a topological ordering), {{construction of the}} transitive closure and transitive reduction (the largest and smallest DAGs with the same reachability relation, respectively), and the closure problem, in which {{the goal is to}} find a minimum-weight subset of vertices with no edges connecting them {{to the rest of the}} graph. Transforming a directed graph with cycles into a DAG by deleting as few vertices or edges as possible (the feedback vertex set and feedback edge set problem, respectively) is NP-hard, but any directed graph can be made into a DAG (its condensation) by contracting each strongly connected component into a single supervertex. The problems of finding shortest paths and longest paths can be solved on DAGs in linear time, in contrast to arbitrary graphs for which <b>shortest</b> <b>path</b> algorithms are slower and longest path problems are NP-hard.|$|E
25|$|The Multicast Open <b>Shortest</b> <b>Path</b> First (MOSPF) {{protocol}} is {{an extension}} to the Open <b>Shortest</b> <b>Path</b> First protocol to support multicast routing, allowing routers to share information about group memberships.|$|E
25|$|If {{the last}} {{equality}} is satisfied for all , the geodesic {{is called a}} minimizing geodesic or <b>shortest</b> <b>path.</b>|$|E
40|$|Abstract — In this paper, {{we study}} the dynamic {{version of the}} {{distributed}} all-pairs <b>shortest</b> <b>paths</b> problem. Most of the solutions given in the literature for this problem, either (i) work {{under the assumption that}} before dealing with an edge operation, the algorithm for the previous operation has to be terminated, that is, they are not able to update <b>shortest</b> <b>paths</b> concurrently, or (ii) concurrently update <b>shortest</b> <b>paths,</b> but their convergence can be very slow (possibly infinite). In this paper we propose a partially dynamic algorithm that overcomes most of these limitations. In particular, it is able to concurrently update <b>shortest</b> <b>paths</b> and in many cases its convergence is quite fast. These properties are highlighted by an experimental study whose aim is to show the effectiveness of the proposed algorithms also in the practical case. Index Terms — Distributed networks, dynamic algorithms, <b>shortest</b> <b>paths,</b> routing, experimental evaluation, networ...|$|R
40|$|We {{investigate}} the all-pairs <b>shortest</b> <b>paths</b> problem in weighted graphs. We present an algorithm [...] -the Hidden Paths Algorithm [...] -that finds these paths in time O(m n+n 2 log n), where m {{is the number}} of edges participating in <b>shortest</b> <b>paths.</b> Our algorithm is a practical substitute for Dijkstra's algorithm. We argue that m is likely to be small in practice, since m = O(n log n) with high probability for many probability distributions on edge weights. We also prove an ΩΓ mn) lower bound on the running time of any path-comparison based algorithm for the all-pairs <b>shortest</b> <b>paths</b> problem. Path-comparison based algorithms form a natural class containing the Hidden Paths Algorithm, as well as the algorithms of Dijkstra and Floyd. Lastly, we consider generalized forms of the <b>shortest</b> <b>paths</b> problem, and show that many of the standard <b>shortest</b> <b>paths</b> algorithms are effective in this more general setting...|$|R
50|$|Block graphs are {{examples}} of pseudo-median graphs: for every three vertices, either there exists a unique vertex that belongs to <b>shortest</b> <b>paths</b> between all three vertices, or there exists a unique triangle whose edges lie on these three <b>shortest</b> <b>paths.</b>|$|R
25|$|Optimal {{substructure}} {{means that}} the solution to a given optimization problem {{can be obtained by}} the combination of optimal solutions to its sub-problems. Such optimal substructures are usually described by means of recursion. For example, given a graph G=(V,E), the <b>shortest</b> <b>path</b> p from a vertex u to a vertex v exhibits optimal substructure: take any intermediate vertex w on this <b>shortest</b> <b>path</b> p. If p is truly the <b>shortest</b> <b>path,</b> then it can be split into sub-paths p1 from u to w and p2 from w to v such that these, in turn, are indeed the shortest paths between the corresponding vertices (by the simple cut-and-paste argument described in Introduction to Algorithms). Hence, one can easily formulate the solution for finding shortest paths in a recursive manner, which is what the Bellman–Ford algorithm or the Floyd–Warshall algorithm does.|$|E
25|$|Betweenness is a {{centrality}} {{measure of}} a vertex within a graph (there is also edge betweenness, which is not discussed here). Betweenness centrality quantifies {{the number of times}} a node acts as a bridge along the <b>shortest</b> <b>path</b> between two other nodes. It was introduced as a measure for quantifying the control of a human on the communication between other humans in a social network by Linton Freeman In his conception, vertices that have a high probability to occur on a randomly chosen <b>shortest</b> <b>path</b> between two randomly chosen vertices have a high betweenness.|$|E
25|$|If we {{can find}} the values of this {{function}} for all the squares at rank n, we pick the minimum and follow that path backwards to get the <b>shortest</b> <b>path.</b>|$|E
40|$|AbstractWe {{study the}} dynamic {{version of the}} {{distributed}} all-pairs <b>shortest</b> <b>paths</b> problem. Most of the solutions given in the literature for this problem, either (i) work {{under the assumption that}} before dealing with an edge operation, the algorithm for the previous operation has to be terminated, that is, they are not able to update <b>shortest</b> <b>paths</b> concurrently, or (ii) concurrently update <b>shortest</b> <b>paths,</b> but their convergence can be very slow (possibly infinite) due to the looping and counting infinity phenomena. In this paper, we propose partially dynamic algorithms that are able to concurrently update <b>shortest</b> <b>paths.</b> We experimentally analyze the effectiveness and efficiency of our algorithms by comparing them against several implementations of the well-known Bellman–Ford algorithm...|$|R
40|$|Finding <b>shortest</b> <b>paths</b> is a {{fundamental}} operator in spatial databases. Recently, terrain datasets have attracted {{a lot of attention}} from both industry and academia. There are some interesting issues to be studied in terrain datasets which cannot be found in a traditional two-dimensional space. In this paper, we study one of the issues called a slope constraint which exists in terrain datasets. In this paper, we propose a problem of finding <b>shortest</b> <b>paths</b> with the slope constraint. Then, we show that this new problem is more general than the traditional problem of finding <b>shortest</b> <b>paths</b> without considering the slope constraint. Since finding <b>shortest</b> <b>paths</b> with the slope constraint is costly, we propose a new framework called surface simplification so that we can compute <b>shortest</b> <b>paths</b> with the slope constraint efficiently. Under this framework, the surface is "simplified" such that the complexity of finding <b>shortest</b> <b>paths</b> on this simplified surface is lower. We conducted experiments to show that the surface simplification is very efficient and effective not only for the new problem with the slope constraint but also the traditional problem without the slope constraint. © 2011 ACM...|$|R
40|$|The inverse <b>shortest</b> <b>paths</b> {{problem in}} a graph is considered, that is, the problem of {{recovering}} the arc costs given some information about the <b>shortest</b> <b>paths</b> in the graph. The problem is #rst motivated by some practical examples arising from applications. An algorithm based on the Golfarb-Idnani method for convex quadratic programming is then proposed and analyzed {{for one of the}} instances of the problem. Preliminary numerical results are reported. yBelgian National Fund for Scienti#c Research Department of Mathematics Facult#es Universitaires ND de la Paix B- 5000 Namur, Belgium zDepartment of Mathematics Facult#es Universitaires ND de la Paix B- 5000 Namur, Belgium Keywords : Graph theory, <b>shortest</b> <b>paths,</b> inverse problems, quadratic programming. On an instance of the inverse <b>shortest</b> <b>paths</b> problem by D. Burton and Ph. L. Toint Report 89 # 7 June 10, 1997 Abstract. The inverse <b>shortest</b> <b>paths</b> {{problem in a}} graph is considered, that is, the problem of recovering the arc [...] ...|$|R
25|$|They are the graphs {{in which}} every induced path is a <b>shortest</b> <b>path,</b> or {{equivalently}} the graphs {{in which every}} non-shortest path {{has at least one}} edge connecting two non-consecutive path vertices.|$|E
25|$|If {{there is}} a path from s to u with at most i edges, then Distance(u) is at most {{the length of the}} <b>shortest</b> <b>path</b> from s to u with at most i edges.|$|E
25|$|Every cograph is a distance-hereditary graph, {{meaning that}} every induced path in a cograph is a <b>shortest</b> <b>path.</b> The cographs may be {{characterized}} among the distance-hereditary graphs as having diameter two in each connected component.|$|E
40|$|We {{describe}} {{the structure of}} semi-regular Auslander-Reiten components of artin algebras without external <b>short</b> <b>paths</b> in the module category. As an application we give a complete description of self-injective artin algebras whose Auslander-Reiten quiver admits a regular acyclic component without external <b>short</b> <b>paths...</b>|$|R
30|$|The {{beam width}} ε is empirically {{determined}} for each {{length of the}} path. In our experimental system, we found that for <b>shorter</b> <b>paths,</b> ε shall be greater. We saw that in <b>shorter</b> <b>paths,</b> the addition of another factor results in a larger change of perplexity than in longer paths. If we expand <b>shorter</b> <b>paths</b> with a certain difference in performance with additional factors, the worse performing path has a greater chance of being expanded into a path that will later outperform other paths.|$|R
40|$|A problem {{studied in}} Systems Biology {{is how to}} find <b>shortest</b> <b>paths</b> in {{metabolic}} networks. Unfortunately, simple (i. e., graph theoretic) <b>shortest</b> <b>paths</b> do not properly reflect biochemical facts. An approach to overcome this issue is to use edge labels and search for paths with distinct labels. In this paper, we show that such biologically feasible <b>shortest</b> <b>paths</b> are hard to compute. Moreover, we present solutions to find such paths in networks in reasonable time. Comment: 9 pages, 5 figure...|$|R
25|$|Dijkstra {{formulated}} and {{solved the}} <b>shortest</b> <b>path</b> {{problem for a}} demonstration at the official inauguration of the ARMAC computer in 1956, but—because {{of the absence of}} journals dedicated to automatic computing—did not publish the result until 1959.|$|E
25|$|For routing IP {{multicast}} traffic, OSPF {{supports the}} Multicast Open <b>Shortest</b> <b>Path</b> First (MOSPF) protocol. Cisco {{does not include}} MOSPF in their OSPF implementations. Protocol Independent Multicast (PIM) in conjunction with OSPF or other IGPs, is widely deployed.|$|E
25|$|The {{distance}} matrix, {{like the}} adjacency matrix, has both its rows and columns indexed by vertices, {{but rather than}} containing a 0 or a 1 in each cell it contains {{the length of a}} <b>shortest</b> <b>path</b> between two vertices.|$|E
50|$|Another {{example is}} the use of k <b>shortest</b> <b>paths</b> {{algorithm}} to track multiple objects. The technique implements a multiple object tracker based on the k <b>shortest</b> <b>paths</b> routing algorithm. A set of probabilistic occupancy maps is used as input. An object detector provides the input.|$|R
40|$|We define {{two related}} graph {{covering}} problems motivated by network monitoring. Both problems {{relate to the}} idea of graph measurement from a single vertex via <b>shortest</b> <b>paths,</b> and are meant to serve as lower and upper bounds on the amount of information that can be gained by measuring a graph via <b>shortest</b> <b>paths.</b> We show that the minimization problem for each model is NP-hard, and then we enumerate several classes of graphs for which the minimization problems are efficiently solvable. Key Words: vertex covers, <b>shortest</b> <b>paths,</b> NP-complete...|$|R
40|$|We {{consider}} {{the problem of}} computing <b>shortest</b> <b>paths</b> in a weighted directed graph whose edges have positive or negative length associated with them. Some <b>shortest</b> <b>paths</b> are not well defined if the graph contains negative cycles. We shortly review the classical Bellman-Ford algorithm for finding <b>shortest</b> <b>paths</b> and/or negative cycles, which runs in O(mn) time. We next describe a scaling algorithm of Goldberg that runs in O(m √ n log N) when the length ℓ(e) of each edge e is an integer satisfying ℓ(e) ≥ −N. ...|$|R
25|$|The {{problem of}} {{determining}} the language accepted by a given finite state acceptor is an instance of the algebraic path problem—itself a generalization of the <b>shortest</b> <b>path</b> problem to graphs with edges weighted by the elements of an (arbitrary) semiring.|$|E
25|$|For {{the second}} part, {{consider}} a <b>shortest</b> <b>path</b> P (there {{may be more}} than one) from source to u with at most i edges. Let v be the last vertex before u on this path. Then, the part of the path from source to v is a <b>shortest</b> <b>path</b> from source to v with at most i-1 edges, since if it were not, then there must be some strictly shorter path from source to v with at most i-1 edges, and we could then append the edge uv to this path to obtain a path with at most i edges that is strictly shorter than P -- a contradiction. By inductive assumption, v.distance after i−1 iterations is at most the length of this path from source to v. Therefore, uv.weight + v.distance is at most the length of P. In the ith iteration, u.distance gets compared with uv.weight + v.distance, and is set equal to it if uv.weight + v.distance was smaller. Therefore, after i iterations, u.distance is at most the length of P, i.e., the length of the <b>shortest</b> <b>path</b> from source to u that uses at most i edges.|$|E
25|$|In a {{connected}} graph, the normalized closeness centrality (or closeness) of a node is {{the average}} length of the <b>shortest</b> <b>path</b> between the node and all other nodes in the graph. Thus the more central a node is, the closer it is to all other nodes.|$|E
25|$|<b>Shortest</b> <b>paths</b> in {{directed}} graphs (Floyd's algorithm).|$|R
50|$|The Floyd-Warshall {{algorithm}} solves all pairs <b>shortest</b> <b>paths.</b>|$|R
50|$|Traditional grid-based {{approaches}} produce paths whose heading {{changes are}} constrained to multiples {{of a given}} base angle, often resulting in suboptimal paths. Any-angle path planning approaches find <b>shorter</b> <b>paths</b> by propagating information along grid edges (to search fast) without constraining their paths to grid edges (to find <b>short</b> <b>paths).</b>|$|R
