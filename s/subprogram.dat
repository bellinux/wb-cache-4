575|514|Public
5|$|Perl's text-handling {{capabilities}} can be {{used for}} generating SQL queries; arrays, hashes, and automatic memory management make it easy to collect and process the returned data. For example, in Tim Bunce's Perl DBI application programming interface (API), the arguments to the API can be the text of SQL queries; thus it is possible to program in multiple languages at the same time (e.g., for generating a Web page using HTML, JavaScript, and SQL in a here document). The use of Perl variable interpolation to programmatically customize each of the SQL queries, and the specification of Perl arrays or hashes as the structures to programmatically hold the resulting data sets from each SQL query, allows a high-level mechanism for handling large amounts of data for post-processing by a Perl <b>subprogram.</b>|$|E
25|$|Assignment statements, in {{imperative}} paradigm, {{perform an}} operation on information located in memory and store {{the results in}} memory for later use. High-level imperative languages, in addition, permit the evaluation of complex expressions, which may consist {{of a combination of}} arithmetic operations and function evaluations, and the assignment of the resulting value to memory. Looping statements (as in while loops, do while loops, and for loops) allow a sequence of statements to be executed multiple times. Loops can either execute the statements they contain a predefined number of times, or they can execute them repeatedly until some condition changes. Conditional branching statements allow a sequence of statements to be executed only if some condition is met. Otherwise, the statements are skipped and the execution sequence continues from the statement following them. Unconditional branching statements allow an execution sequence to be transferred to another part of a program. These include the jump (called goto in many languages), switch, and the <b>subprogram,</b> subroutine, or procedure call (which usually returns to the next statement after the call).|$|E
2500|$|... computable subprograms (the {{program that}} computes f is a <b>subprogram</b> in program e), ...|$|E
5000|$|<b>Subprograms</b> {{are called}} with CALL {{statement}} (e.g. CALL CLEAR). There are no user defined <b>subprograms</b> (this {{is possible in}} TI Extended BASIC), but some <b>subprograms</b> are predefined: ...|$|R
5000|$|... {{provides}} use {{association to}} all the module's entities. Module <b>subprograms</b> may, in turn, contain internal <b>subprograms.</b>|$|R
5|$|This {{situation}} improved as COBOL adopted more features. COBOL-74 added <b>subprograms,</b> giving programmers {{the ability}} to control the data each part of the program could access. COBOL-85 then added nested <b>subprograms,</b> allowing programmers to hide <b>subprograms.</b> Further control over data and code came in 2002 when object-oriented programming, user-defined functions and user-defined data types were included.|$|R
2500|$|As {{pointed out}} by Peter Landin's 1965 paper [...] "A Correspondence between ALGOL 60 and Church's Lambda-notation", {{sequential}} procedural programming languages can {{be understood in terms}} of the lambda calculus, which provides the basic mechanisms for procedural abstraction and procedure (<b>subprogram)</b> application.|$|E
2500|$|Another major {{contributor}} to the modern library concept {{came in the form}} of the <b>subprogram</b> innovation of FORTRAN. FORTRAN subprograms can be compiled independently of each other, but the compiler lacked a linker. [...] So prior to the introduction of modules in Fortran-90, type checking between FORTRAN subprograms was impossible.|$|E
2500|$|But what model {{should be}} used for the simulation? Van Emde Boas observes [...] "even if we base {{complexity}} theory on abstract instead of concrete machines, arbitrariness of the choice of a model remains. It is at this point that the notion of simulation enters". When speed is being measured, the instruction set matters. For example, the <b>subprogram</b> in Euclid's algorithm to compute the remainder would execute much faster if the programmer had a [...] "modulus" [...] instruction available rather than just subtraction (or worse: just Minsky's [...] "decrement").|$|E
40|$|In this study, we {{revisit the}} {{question}} of identifying the characteristics of "optimum" software components. Specifically, we focus on those characteristics {{that are expected to}} minimize defect densities uncovered during the testing phases of software development. Although a number of such models have been examined in the past, these models have embodied some methodological difficulties that we attempt to remedy. Using data from Ada and C <b>subprograms,</b> we examine the optimum number of lines of code for <b>subprograms</b> and the optimum relationship between the internal and external complexities of <b>subprograms.</b> Our results show that the optimal size for <b>subprograms</b> is between 80 - 100 lines of code and that for these optimally sized <b>subprograms</b> the optimal number of calls is about 14...|$|R
40|$|A {{modeling}} method {{to calculate the}} intervals of uncertainty for parameters found by identification is described. The region of confidence and the general approach to the calculation of these intervals are discussed. The general <b>subprograms</b> for determination of dimensions are described. They provide the organizational charts for the <b>subprograms,</b> the tests carried out and the listings of the different <b>subprograms...</b>|$|R
40|$|Ten {{families}} of <b>subprograms</b> are bundled {{together for the}} General-Purpose Ada Packages. The families bring to Ada many features from HAL/S, PL/I, FORTRAN, and other languages. These families are: string <b>subprograms</b> (INDEX, TRIM, LOAD, etc.); scalar <b>subprograms</b> (MAX, MIN, REM, etc.); array <b>subprograms</b> (MAX, MIN, PROD, SUM, GET, and PUT); numerical <b>subprograms</b> (EXP, CUBIC, etc.); service <b>subprograms</b> (DATE_TIME function, etc.); Linear Algebra II; Runge-Kutta integrators; and three text I/O {{families of}} packages. In two cases, a family consists of a single non-generic package. In all other cases, a family comprises a generic package and its instances for a selected group of scalar types. All generic packages {{are designed to be}} easily instantiated for the types declared in the user facility. The linear algebra package is LINRAG 2. This package includes <b>subprograms</b> supplementing those in NPO- 17985, An Ada Linear Algebra Package Modeled After HAL/S (LINRAG). Please note that LINRAG 2 cannot be compiled without LINRAG. Most packages have widespread applicability, although some are oriented for avionics applications. All are designed to facilitate writing new software in Ada. Several of the packages use conventions introduced by other programming languages. A package of string <b>subprograms</b> is based on HAL/S (a language designed for the avionics software in the Space Shuttle) and PL/I. Packages of scalar and array <b>subprograms</b> are taken from HAL/S or generalized current Ada <b>subprograms.</b> A package of Runge-Kutta integrators is patterned after a built-in MAC (MIT Algebraic Compiler) integrator. Those packages modeled after HAL/S make it easy to translate existing HAL/S software to Ada. The General-Purpose Ada Packages program source code is available on two 360 K 5. 25 " MS-DOS format diskettes. The software was developed using VAX Ada v 1. 5 under DEC VMS v 4. 5. It should be portable to any validated Ada compiler and it should execute either interactively or in batch. The largest package requires 205 K of main memory on a DEC VAX running VMS. The software was developed in 1989, and is a copyrighted work with all copyright vested in NASA...|$|R
5000|$|Executing one <b>subprogram,</b> {{and then}} another <b>subprogram</b> (sequence) ...|$|E
50|$|The Fortran {{compiler}} produced self-modifying code when generating {{code for}} any <b>subprogram</b> (subroutine or function) that had parameters. The compiler built {{a table of}} every location where the <b>subprogram</b> referenced one of its parameters, and compiled as the first instruction {{in the body of}} the <b>subprogram</b> a call to a <b>subprogram</b> called SUBIN that used the table to modify the address field of every reference to a parameter to be the actual address of the parameter during the current invocation. SUBIN made these patches every time the <b>subprogram</b> was called.|$|E
50|$|If a <b>subprogram</b> can {{function}} properly even when called while another execution {{is already in}} progress, that <b>subprogram</b> {{is said to be}} reentrant. A recursive <b>subprogram</b> must be reentrant. Reentrant subprograms are also useful in multi-threaded situations, since multiple threads can call the same <b>subprogram</b> without fear of interfering with each other. In the IBM CICS transaction processing system, quasi-reentrant was a slightly less restrictive, but similar, requirement for application programs that were shared by many threads.|$|E
40|$|MATH 77, Release 3. 17, is {{library of}} 412 FORTRAN 77 <b>subprograms</b> {{for use in}} {{numerical}} computation. <b>Subprograms</b> providing machine and system characteristic parameters make library operational on any computer system supporting full FORTRAN 77 standard. Portability and high quality of <b>subprograms</b> and user's manual make MATH 77 extremely versatile and valuable tool for all numerical computation applications. Written in FORTRAN 77. Program and documentation copyrighted products of California Institute of Technology...|$|R
40|$|Types and <b>Subprograms</b> 5. 3. 9. 3. 1 References ARM Section 3. 9. 3 Abstract Types and <b>Subprograms</b> Abstract {{types and}} <b>subprograms</b> provide {{significant}} capability to Ada 95 at virtually no run-time cost. By declaring a type to be abstract, one can prevent objects {{of that type}} from being declared, although type derivation (or extension) is permitted, and these new types may then have objects and actual primitive operations. Abstract <b>subprograms</b> allow the definer of the type to make unavailable certain operations that would ordinarily be available for the type. When a tagged type is extended, abstract primitive operations ensure that the extender of the type provides "real" code for each primitive operation, and does not accidentally use default or incomplete operations. 5. 3. 9. 3. 2 Applicability to High Integrity Systems Because of the capabilities described above, abstract types and <b>subprograms</b> can be a significant engineering advantage for Ada 95. It should be noted, however, {{that this is a}} new [...] ...|$|R
40|$|The author {{describes}} <b>subprograms</b> for {{calculating the}} numerical value of arbitrary order derivatives of a function {{with two or}} three real variables. The application of these <b>subprograms</b> to finite series developments, integral calculus and numerical integration of partial differential equations is described...|$|R
50|$|The Betty compiler, for example, treats every {{possible}} straight line of instructions as a <b>subprogram,</b> {{and if a}} 'p' instruction alters that <b>subprogram,</b> that <b>subprogram</b> is recompiled. This is an interesting variation on just-in-time compilation, and it results {{in a much better}} advantage over an interpreter, since many instructions can be executed in native code without making intervening decisions on the 'direction' register.|$|E
50|$|A {{function}} that self-modified, as IOR does, {{could not be}} used in a Fortran <b>subprogram</b> on any of the parameters to that <b>subprogram</b> (though it could be used to combine local variables) because it is incompatible with the SUBIN <b>subprogram</b> discussed above. IOR's transformation of its four-word calling sequence, shown above, moves the location of the address of variable I. On subsequent calls to the Fortran <b>subprogram,</b> the table of references to parameters would be in error and SUBIN would patch the wrong word, in this case placing the new address of I over the OR operation code.|$|E
50|$|If a {{postcondition}} {{or other}} assertions {{are added to}} a <b>subprogram,</b> GNATprove will also generate VCs that require the user to show that these properties hold for all possible paths through the <b>subprogram.</b>|$|E
50|$|The Festival {{contains}} about 300 <b>subprograms.</b>|$|R
40|$|Dynamic Analysis Program, FORTRAN 4 Level H /DAP 4 H/, {{developed}} from 27 <b>subprograms,</b> features liberal {{use of the}} subroutines, <b>subprograms,</b> and skeletonization to minimize programming effort in formulating models of new systems and components. It formulates mathematical models of complex mechanical, pneumatic, and hydraulic dynamic systems...|$|R
40|$|A {{package of}} 38 low level <b>subprograms</b> {{for many of}} the basic {{operations}} of numerical linear algebra is presented. The package is intended to be used with FORTRAN. The operations in the package are dot products, elementary vector operations, Givens transformations, vector copy and swap, vector norms, vector scaling, and the indices of components of largest magnitude. The <b>subprograms</b> and a test driver are available in portable FORTRAN. Versions of the <b>subprograms</b> are also provided in assembly language for the IBM 360 / 67, the CDC 6600 and CDC 7600, and the Univac 1108...|$|R
50|$|A <b>subprogram</b> {{may find}} it useful {{to make use of}} a certain amount of scratch space; that is, memory used during the {{execution}} of that <b>subprogram</b> to hold intermediate results. Variables stored in this scratch space are termed local variables, and the scratch space is termed an activation record. An activation record typically has a return address that tells it where to pass control back to when the <b>subprogram</b> finishes.|$|E
50|$|Mercury-Atlas was a <b>subprogram</b> of Project Mercury that {{included}} {{most of the}} flights and tests using the Atlas LV-3B launch vehicle. The Atlas was also used for one Mercury flight under the Big Joe <b>subprogram.</b>|$|E
5000|$|We {{can further}} extend these {{specifications}} by asserting various properties that either {{need to hold}} when a <b>subprogram</b> is called (preconditions) or that will hold once execution of the <b>subprogram</b> has completed (postconditions). For example, we could say the following: ...|$|E
5000|$|... #Subtitle level 2: The BLAS: Basic Linear Algebra <b>Subprograms</b> ...|$|R
40|$|Two FORTRAN-callable <b>subprograms</b> {{have been}} written to draw a smooth curve {{through a set of}} input points as a solid line or as a general {{sequence}} of long and short dashes. Subroutine LINSEQ draws conventional curves whereas subroutine CONSEQ draws smooth closed curves (contours). The <b>subprograms</b> are based on an approximate calculation of the arc length along the curve and spline interpolation along the arc length. Options are provided for smoothing of the input data and for offsetting the plotted curve from the input data points. The method of calculation of the arc length and the generation of the line sequence are described. Usage descriptions of the main <b>subprograms,</b> sample calling programs illustrating the various features of the <b>subprograms,</b> and sample plots are given. The subroutines should be readily adaptable to almost any computer-driven incremental plotter...|$|R
40|$|A simple thermal {{analysis}} program for Space Shuttle payloads {{has been developed}} to accommodate the user who requires an easily understood but dependable analytical tool. The {{thermal analysis}} program includes several thermal <b>subprograms</b> traditionally employed in spacecraft thermal studies, a data management system for data generated by the <b>subprograms,</b> and a master program to coordinate the data files and thermal <b>subprograms.</b> The language and logic used to run the thermal analysis program are designed for the small user. In addition, analytical and storage techniques which conserve computer time and minimize core requirements are incorporated into the program...|$|R
5000|$|GNATprove {{can also}} {{generate}} {{a set of}} Verification Conditions or VCs. VCs are used to attempt to establish certain properties hold for a given <b>subprogram.</b> At a minimum, the GNATprove will generate VCs attempting to establish that all run-time errors cannot occur within a <b>subprogram,</b> such as ...|$|E
50|$|ToasterEdit is a video-editing <b>subprogram</b> {{inside of}} Video Toaster.|$|E
5000|$|A {{function}} is a <b>subprogram</b> written to perform certain computations.|$|E
40|$|This is a reprinting of the {{original}} report of June 1969, with correction of a few minor errors. The SAC- 1 Modular Arithmetic System is the fifth of the ten SAC-I subsystems which are now available. It provides <b>subprograms</b> for the arithmetic operations in a prime finite field GF(p), for any single-precision prime p, and various operations on polynomials in several variables with coefficients in GF(p). Besides the arithmetic operations on such polynomials there are included <b>subprograms</b> for the Chinese remainder theorem, evaluation and interpolation. For univariate polynomials, <b>subprograms</b> are included for greatest common divisor calculation and Berlekamp's factorization algorithm...|$|R
5000|$|In {{order to}} discuss this topic we need some definitions. In logical terms, an {{executable}} program consists of one main program and zero or more <b>subprograms</b> (or procedures) - these do something. <b>Subprograms</b> are either functions or subroutines, which are either external, internal or module subroutines. (External subroutines are what we knew from FORTRAN 77.) ...|$|R
40|$|MATH 77 is {{high-quality}} {{library of}} ANSI FORTRAN 77 <b>subprograms</b> implementing contemporary algorithms for basic computational processes {{of science and}} engineering. Release 4. 0 of MATH 77 contains 454 user-callable and 136 lower-level <b>subprograms.</b> MATH 77 release 4. 0 subroutine library designed to be usable on any computer system supporting full ANSI standard FORTRAN 77 language...|$|R
