7|57|Public
5000|$|<b>Syntax</b> <b>diagram</b> used in {{software}} engineering {{to represent a}} context-free grammar ...|$|E
40|$|Abstract. The new {{approach}} to representation of syntax of formal languages – a formalism of syntax diagrams is offered. Syntax diagrams look a convenient language for the description of syntactic relations in the languages having nonlinear representation of texts, for example, for representation of syntax lows {{of the language of}} structural chemical formulas. The formalism of neighbourhood grammar is used to describe the set of correct syntax constructs. The neighbourhood the grammar consists of a set of families of ”neighbourhoods ” – the diagrams defined for each symbol of the language’s alphabet. The <b>syntax</b> <b>diagram</b> is correct if each symbol is included into this diagram together with some neighbourhood. In other words, correct diagrams are needed to be covered by elements of the neighbourhood grammar. Thus, the grammar of formal language can be represented as system of the covers defined for each correct <b>syntax</b> <b>diagram...</b>|$|E
40|$|Includes bibliographical {{references}} (page 32) This {{curve and}} surface generating program {{was designed for}} the graphics user who has {{a special interest in}} various surface modeling techniques. In this program the primary importance is not given to different computational methods but rather in providing flexibility in generating surfaces of three dimensional objects. Two surface fitting methods that are implemented in this program are the Bezier surface and Polygon Mesh method. This program allows the user to input surface specifications which consist in a set of control points in 3 -dimensional space, and to use a surface generation technique to generate a surface. Upon request the surface specifications are interpreted and, if no error is detected, the surface is drawn. If errors occur the appropriate error messages are generated and displayed. The user may save the surface specifications on a Floppy disk to be retrieved later for display or further work. Included in this project is a description of the two surface techniques, the algorithms used for impelmentation and a user???s manual. It also includes a set of actual surfaces illustrating various properties of these surface fitting techniques, and a <b>syntax</b> <b>diagram.</b> The <b>syntax</b> <b>diagram</b> describes a valid surface specifications that the program accepts...|$|E
40|$|Abstract. The {{method of}} {{constructing}} of Grothendieck’s topology basing on a neighbourhood grammar, defined on {{the category of}} <b>syntax</b> <b>diagrams</b> is described in the article. <b>Syntax</b> <b>diagrams</b> of a formal language are the multigraphs with nodes, signed by symbols of the language’s alphabet. The neighbourhood grammar allows to select correct <b>syntax</b> <b>diagrams</b> from the set of all <b>syntax</b> <b>diagrams</b> on the given alphabet by mapping an each correct diagram to the cover consisted of the grammar’s neighbourhoods. Such the cove...|$|R
40|$|The {{method of}} {{constructing}} of Grothendieck's topology basing on a neighbourhood grammar, defined on {{the category of}} <b>syntax</b> <b>diagrams</b> is described in the article. <b>Syntax</b> <b>diagrams</b> of a formal language are the multigraphs with nodes, signed by symbols of the language's alphabet. The neighbourhood grammar allows to select correct <b>syntax</b> <b>diagrams</b> from the set of all <b>syntax</b> <b>diagrams</b> on the given alphabet by mapping an each correct diagram to the cover consisted of the grammar's neighbourhoods. Such the cover gives rise to Grothendieck's topology on category of correct <b>syntax</b> <b>diagrams</b> extended by neighbourhoods' diagrams. An each object of the category may be mapped to the set of meanings (abstract senses) of this syntax construction. So, the contrvariant functor from category of correct <b>syntax</b> <b>diagrams</b> to category of sets is defined. The given category of contravariant functors likes {{to be seen as}} the convenient means to think about relations between syntax and semantic of a formal language. The sheaves of set defined on category of contravariant functors are the objects that satisfy of compositionality principle defined in the semantic analysis. Comment: 11 page...|$|R
40|$|We {{provide a}} {{pipeline}} for generating <b>syntax</b> <b>diagrams</b> (also called railroad diagrams) from context free grammars. <b>Syntax</b> <b>diagrams</b> are a graphical {{representation of a}} context free language, which we formalize abstractly {{as a set of}} mutually recursive nondeterministic finite automata and draw by combining elements from the confluent drawing, layered drawing, and smooth orthogonal drawing styles. Within our pipeline we introduce several heuristics that modify the grammar but preserve the language, improving the aesthetics of the final drawing. Comment: GD 201...|$|R
40|$|Abstract. We {{present a}} light {{formalism}} for proofs that encodes their inferential structure, {{along with a}} system that transforms these represen-tations into flow-chart diagrams. Such diagrams should improve the com-prehensibility of proofs. We discuss language <b>syntax,</b> <b>diagram</b> semantics, and our goal of building a repository of diagrammatic representations of proofs from canonical mathematical literature. The repository will be available online {{in the form of}} a wiki at proofflow. org, where the flow chart drawing software will be deployable through the wiki editor. We also consider the possibility of a semantic tagging of the assertions in a proof, to permit data mining...|$|E
40|$|Abstract. The {{abstract}} syntax of a graphical modeling language is typically defined with a metamodel while its concrete <b>syntax</b> (<b>diagram)</b> is informally defined with text and figures. Recently, the Object Management Group (OMG) released a beta specification, called Diagram Definition (DD), to formally define both the interchange syntax and the graphical syntax of diagrams. In this paper, we validate DD by {{using it to}} define {{a subset of the}} UML class diagram. Specifically, we define the interchange syntax with a MOF-based metamodel and the graphical syntax with a QVT mapping to a graphics metamodel. We then run an experiment where we interchange and render an example diagram. We highlight various design decisions and discuss challenges of using DD in practice. Finally, we conclude that DD is a sound approach for formally defining diagrams that is expected to facilitate the interchange and the consistent rendering of diagrams between tools...|$|E
5000|$|<b>Syntax</b> <b>diagrams</b> (or {{railroad}} diagrams) {{are a way}} {{to represent}} a context-free grammar. They represent a graphical alternative to Backus-Naur form or to EBNF as metalanguages. Early books using <b>syntax</b> <b>diagrams</b> include the [...] "Pascal User Manual" [...] written by Niklaus Wirth [...] (diagrams start at page 47) and the Burroughs CANDE manual. In the compilation field, textual representations like BNF or its variants are usually preferred. BNF is text-based, and used by compiler writers and parser generators. Railroad diagrams are visual, and may be more readily understood by laypeople, sometimes incorporated into graphic design. The canonical source defining the JSON data interchange format provides {{yet another example of}} a popular modern usage of these diagrams.|$|R
50|$|The {{representation}} of a grammar is made {{of a set of}} <b>syntax</b> <b>diagrams.</b> Each diagram defines a non-terminal. There is a main diagram which defines the language in the following way: to belong to the language, a word must describe a path in the main diagram.|$|R
40|$|This {{document}} {{describes the}} Diagrams tool, {{which is a}} compiler from EBNF production rules to <b>syntax</b> <b>diagrams</b> in PostScript. Apart from the traditional extended BNF constructions, notations for layout are available. Scaling and positioning is completely automatic. 1 Contents 1 Introduction 3 2 Syntax denition 3 3 Short-cuts 4 4 Switches 5 5 Cooperation with Elegant 6 6 Font directory 6 PHILIPS Research, Information and Software Technology 2 PHILIPS Research, Information and Software Technology 3 1 Introduction This document describes the Diagrams tool, which is a compiler from EBNF production rules to <b>syntax</b> <b>Diagrams</b> in PostScript. Apart from the traditional extended BNF constructions, notations for layout control are available. 2 Syntax denition The extended BNF syntax has the following form: hspecicationi ::= f [hformfeedi] hrulei g hrulei ::= hidenti hderivesi hdisjunctioni. hdisjunctioni ::= halternationi == hori halternationi ::= hconjunctioni == hseparatesi hconju [...] ...|$|R
40|$|Contents 1 Introduction 1 2 How to make <b>syntax</b> <b>diagrams</b> 2 2. 1 Basic elements................................. 2 2. 1. 1 Blanks.................................. 2 2. 1. 2 Non-terminals.............................. 3 2. 1. 3 Terminals................................ 3 2. 1. 4 Parameters............................... 3 2. 2 Building up diagrams............................. 4 2. 2. 1 Choice.................................. 5 2. 2. 2 Concatenation............................. 5 2. 2. 3 Optional components......................... 5 2. 2. 4 Repetitions............................... 5 2. 2. 5 Grouping................................ 6 2. 3 Options... ...|$|R
40|$|The {{principal}} {{elements and}} functions of the Ground Operations Aerospace Language (GOAL) compiler are presented. The technique used to transcribe the <b>syntax</b> <b>diagrams</b> into machine processable format {{for use by the}} parsing routines is described. An explanation of the parsing technique used to process GOAL source statements is included. The compiler diagnostics and the output reports generated during a GOAL compilation are explained. A description of the GOAL program package is provided...|$|R
40|$|Includes bibliographical {{references}} (page 44) The system {{described in}} this report is a comprehensive error-checking compiler for a subset of Pascal called Minipas. It is designed for students with limited experience in debugging erroneous Pascal programs. The Minipas compiler only handles the early two stages of the compilation process, that is, lexical analysis and syntax analysis; no object code is generated. It is coded in Pascal 6000 [4] and implemented on a CDC Cyber 170 with NOS operating system. Chapter 1 of this report explains the motivation and goals for the project. Chapter 2 defines the language Minipas; a complete syntax description in terms of BNF (Backus-Naur Form) and <b>syntax</b> <b>diagrams</b> is given in an appendix. The <b>syntax</b> <b>diagrams</b> closely reflect. {{the structure of the}} compiler. Chapter 3 describes the internal organization of the compiler. It starts with an explanation of the error types (lexical, syntactic, and semantic errors) and their corresponding recovery strategies. Various compiler tables (symbol tables) and their data structures are also discussed in detail. These tables are valuable tools in detecting semantic errors. Chapter 4 examines machine-dependency problems, that is, compiler portability. (See more in text. ...|$|R
50|$|The {{appearance}} of statements shapes {{the look of}} programs. Programming languages are characterized {{by the type of}} statements they use (e.g. the curly brace language family). Many statements are introduced by identifiers like if, while or repeat. Often statement keywords are reserved such that they cannot be used as names of variables or functions. Imperative languages typically use special syntax for each statement, which looks quite different from function calls. Common methods to describe the syntax of statements are Backus-Naur form and <b>syntax</b> <b>diagrams.</b>|$|R
40|$|Includes bibliographical {{references}} (page 33) Tinytab is {{a general}} purpose statistical computing system designed for students and researchers without computing experience. It is flexible, powerful, easy to use, and useful for small to moderate size data sets. It is coded in UCSD Pascal and implemented on an Apple II microcomputer. Tinytab is a subset of Minitab [4, 5], a statistics package written in Fortran IV and available on medium to large size computers [6]. This project includes a series of <b>syntax</b> <b>diagrams</b> that define Minitab and by inclusion, Tinytab. Tinytab's interpreter parses input into command names and operands. The names are checked in the command dictionary and the operands are checked against those specified in coded <b>syntax</b> <b>diagrams.</b> Legal commands are executed interactively and all others generate descriptive error messages. Tinytab performs virtually all operations on linked lists and stores most data in linked lists. Since the worksheet is not stored as a linear array, {{there is no need}} to pack or repack memory as the worksheet varies dynamically in size. Consequently, the program suffers no loss in speed as the columns expand or contract. Users are allowed to save and retrieve the worksheet on their own floppy diskette as well as operate in either batch or time-sharing modes...|$|R
40|$|The {{theme of}} this thesis is syntax {{analysis}} of the source texts based on TeX. The work contains the summary of basic terms from the theory of formal languages, there is also explained {{the function of the}} translator in all the analytical phases of the translation and finally it contains the introduction of the Lua scripting language and the ConTeXt typesetting system. The aim of the thesis is implementation of the syntax analyser for the source texts in ConTEXt format. The implementation is accompanied by the description of the solution developement of the lexical analysis, syntax analysis, creating <b>syntax</b> <b>diagrams</b> and context-free grammar...|$|R
5000|$|The IFML visual <b>syntax</b> (Defined through <b>Diagram</b> Definition and Diagram Interchange specification).|$|R
40|$|DIAGEN [1] is a {{tool for}} {{generating}} diagram editors that respect the <b>syntax</b> of partic-ular <b>diagram</b> languages. Editors generated with DIAGEN work as follows: A drawing tool allows free-hand editing of diagrams, by arranging diagram primi-tives like boxes, circles, lines, text on a drawing pane. The set of available primitives depends on the particular diagram language. A scanner analyses the spatial relationships of diagram primitives, and reduces them to diagram symbols like states and transitions. Finally, a parser checks whether the diagram symbols are related according to the <b>syntax</b> of the <b>diagram</b> language, and produces a derivation structure. DIAGEN relies on hypergraphs and hypergraph transformation: diagrams are rep-resented as hypergraphs, the scanner is specified by hypergraph transformation rules, and the <b>syntax</b> of <b>diagram</b> languages is specified by hypergraph grammars. (See [5] for details.) Case studies with editors for control flow diagrams, Nassi-Shneiderman diagrams, message sequence charts, state charts, and UML class diagrams indicate that the syntax of practically every kind of diagram language—also for design language...|$|R
40|$|PASCAL/ 48 is a {{programming}} language for the Intel MCS- 48 series of microcomputers. In particular, {{it can be used}} with the Intel 8748. It is designed to allow the programmer to control most of the instructions being generated and the allocation of storage. The language can be used instead of ASSEMBLY language in most applications while allowing the user the necessary degree of control over hardware resources. Although it is called PASCAL/ 48, the language differs in many ways from PASCAL. The program structure and statements of the two languages are similar, but the expression mechanism and data types are different. The PASCAL/ 48 cross-compiler is written in PASCAL and runs on the CDC CYBER NOS system. It generates object code in Intel hexadecimal format {{that can be used to}} program the MCS- 48 series of microcomputers. This reference manual defines the language, describes the predeclared procedures, lists error messages, illustrates use, and includes language <b>syntax</b> <b>diagrams...</b>|$|R
40|$|In {{this paper}} the author {{illustrates}} systematic circuit redrawings using {{breadth first search}} starting at "half " the source, redrawing the visited electrical node wiring in a manner akin to rail-road (computer language <b>syntax)</b> <b>diagrams</b> where the sidings arise from redrawn wiring and the electrical components are where the tokens would be. Implied left to right conventional current flow is terminated with the other "half " of the source. The resulting curvaceous circuit drawing helps facilitate writing of the equivalent resistance (or impedance) {{in terms of the}} series and parallel operators. Further visualization is encouraged in the organization of intermediate equivalent resistances in a manner that facilitates reuse for branch division and superposition. The introduction of graph theory in the University of Chicago School Mathematics Project high school geometry text 1 supports the further development and application by lower division college students of an elementary graph algorithm in circuit visualization. Elementary graph theory also enhances many traditional topics in lower division college courses (e. g. Management). 1...|$|R
40|$|The BLOOM (BarceLona Object Oriented Model) {{data model}} was {{developed}} to be the Canonical Data Model (CDM) of a Federated Database Management System prototype. Its design satises the features that a data model should have to be suitable as a CDM. The initial version of the model (BLOOM 91) has evolved into the present version, BLOOM 99. This report species the syntax of the schema denition language of BLOOM 99. In our model, a schema {{is a set of}} classes, related through two dimensions: the generalization/specialization dimension, and the aggregation/decomposition dimension. BLOOM supports several features in each of these dimensions, through their corresponding metaclasses. Even if users are supposed to dene and modify schemas in an interactive way, using a Graphical User Interface, a linear schema denition language is clearly needed. <b>Syntax</b> <b>diagrams</b> are used in this report to specify the language; an alternative using grammar productions appears as Appendix A. A possible graphical [...] ...|$|R
40|$|We {{describe}} a visualisation system which allows {{an artist to}} perform music to a pre-recorded accompaniment without some of the constraints that normally render such a performance dull and lifeless. Musicians who perform with an accompanist or a band can't always practise together or {{may be unable to}} accept gigs by lack of availability of the other musician(s). In these circumstances, some artists have tried performing to pre-recorded accompaniments, but these are inflexible; it is difficult, or impossible, to achieve variations in tempo, spur-of-the-moment repetitions or omissions of sections of the music, and solo breaks of indeterminate length. The system described here is a prototype for a computer-controlled accompanist capable of all of these variations. It is based on three premises. First, the accompaniment is recorded as MIDI data, in which the various sections that are, or may be, performed, are individually identified. Secondly, the arranger creates a representation of the &quot;syntax &quot; of the piece of music that shows repeated sections, and alternative sections using a visual structure similar to the <b>syntax</b> <b>diagrams</b> commonly used for defining computer programming languages. Thirdly, the performer interacts with this graphical representation of the high-level structure of the piece, choosing alternatives, and altering tempi, while the music is playing...|$|R
40|$|In this paper, we {{recall how}} the <b>syntax</b> of <b>diagrams</b> is {{captured}} by the dia-gram editor generator DIAGEN, and outline a visual, rule-based, and object-oriented programming language based on graph transformation by which DIAGEN can be extended to model the semantics of diagrams as well. This language is generic w. r. t. the diagram notation {{to be used in}} the programmed visual system and may thus be used for implementing arbitrary systems based on diagram-manipulation. Keywords diagram editor generator, diagram processing, graph language, graph transformation, visual programming languag...|$|R
40|$|Includes bibliographical {{references}} (page 31) This surface fitting {{program was}} designed for the student of graphics who has {{a special interest in}} shape modeling techniques. The techniques studied are used when the primary concern is not the computation of derived properties such as areas and volumes but, rather, the flexibility given to the designer in the design of shapes. The three surface fitting techniques implemented in this program are Bezier, non-periodic B-spline, and periodic B-spline. The program allows the user to give surface specifications which consist of a set of points in 3 -space, a set of surface fitting techniques with all their associated parameters, and transformations to be performed on the surfaces. When requested the surface specifications will be interpreted and if no errors were found the surfaces will be drawn. If errors occur the appropriate error messages are generated and the user may save the surface specification on a Floppy Disk to be retrieved later on for display or further work. Included in this project is a description of the three surface fitting techniques and the algorithms used to implement them, a users manual, a set of actual curves and surfaces demonstrating many of the properties of the surface fitting techniques, and <b>syntax</b> <b>diagrams</b> which define what the program accepts as a valid surface specification...|$|R
40|$|This paper {{presents}} STTL, {{a language}} for communicating, storing, and evaluating timetabling problems, instances, and solutions. An interpreter for STTL is freely {{available on the}} Internet. Contents 1. Introduction [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 1 2. Lexical structure [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 2 3. Types and expressions [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 2 4. Functions [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 4 5. Sets and sequences [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 5 6. Classes and objects [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 6 7. Problems, instances, and solutions [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 8 8. Optimizations [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 9 9. Implementation [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 11 Appendix A. <b>Syntax</b> <b>diagrams</b> [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] [...] 11 1. Introduction STTL is a [...] ...|$|R
40|$|We {{present a}} model of {{generation}} of alternative designs to selected architectural and spatial configurations of small complexity. Specifically we present a production pipeline of architectural / spatial configurations using the context of animation and time based design tools. Our model consists {{of time and space}} design constraints of boundaries / objects affecting a given architectural design, thus producing an alternative solution for every timeframe of the animation cycle. The alternative designs vary from the original according to their temporal and/or spatial distance from the original object on the animation time-line.   The constraints placed upon the objects, used as actuators of Shape Grammars, are defined informally by the user/designer while their influence can vary according to time, speed, location, configuration of the object and/or the constraint itself. However the constraints further function as formal rules for the Shape Grammar creation so that our model tries to predict ahead of time the emergence of alternate designs. The employ of animation tools [shape driven curves, speed and time-line functions,parent child relationships] in the shape generation of our model empowers the user/designer to configure whole sets of shapes and designs interactively and without the need to define every solution independently. Simultaneously, a different, time-focused view of our model describes its use on designs that develop different configurations over time. Thus a duality of our model is established: either the animated schema may be a sum or family of various designs or the animated time-line represents a single design which changes over time. Finally the possibility of an automated analysis of every design is discussed, using Space <b>Syntax</b> <b>diagrams</b> so the designer can quickly evaluate the various spatial configurations produced by a single original...|$|R
40|$|SQL Data Modeler {{is a tool}} to make {{database}} {{modeling and}} design. This program provide database diagram for visualization. This diagram make user more easily understanding and modeling the database. User {{does not need to}} know about SQL syntax to make the database. SQL Data Modeler stores all information on XML file as saved file. This information used to create database <b>diagram</b> and SQL <b>syntax.</b> After read information from XML file, the information is stored on Abstract Syntax Tree as data structure. Information can be update, delete or add from Abstract Syntax Tree (AST). The information on Abstract Syntax Tree will be generated into database <b>diagram,</b> SQL <b>syntax,</b> and XML <b>syntax.</b> Database <b>diagram</b> is for show all tables that had been created. SQL syntax is the result from generating the AST into source SQ...|$|R
40|$|Abstract Algebraic graph {{transformation}} {{has been}} promoted by several authors {{as a means to}} specify model transformations. This paper explores how we can specify graph transformation-based rules for a classical problem of transforming from sequence diagrams to state machines. The specification of the transformation rules is based on the concrete <b>syntax</b> of sequence <b>diagrams</b> and state machines. We introduce tailored transformation support for sequence diagrams and a novel graphical operator to match and transform combined fragments...|$|R
40|$|DCpic is {{a package}} of TEX macros for drawing Commutative Dia-grams in a (La) TEX or ConTEXt document. Its {{distinguishing}} features are: the use of PICTEX a powerful graphical engine, and a simple spec-ification <b>syntax.</b> A commutative <b>diagram</b> is {{described in terms of}} its objects and its arrows. The objects are textual elements and the arrows can have various straight or curved forms. We describe the syntax and semantics of the user’s commands, and present several examples of their use...|$|R
40|$|The {{original}} idea of proof nets can be formulated {{by means of}} interaction nets syntax. Additional machinery as switching, jumps and graph connectivity is {{needed in order to}} ensure correspondence between a proof structure and a correct proof in sequent calculus. In this paper we give an interpretation of proof nets in the <b>syntax</b> of string <b>diagrams.</b> Even though we lose standard proof equivalence, our construction allows to define a framework where soundness and well-typeness of a diagram can be verified in linear time. Comment: In Proceedings LINEARITY 2016, arXiv: 1701. 0452...|$|R
40|$|Abstract. This {{builds on}} {{previous}} work {{in which we}} have developed diagramming principles based on theories of structural object perception. We call these geon diagrams. We have previously shown that such diagrams are easy to remember and to analyze. To evaluate our hypothesis that geon diagrams should also be easy to understand we carried out an empirical study to evaluate the learnability of geon diagram semantics in comparison with the well-established UML convention. The results support our theory of learnability. Both novices and experts found the geon <b>diagram</b> <b>syntax</b> easier to apply in a diagram-to-textual description matching task than the equivalent UML syntax. ...|$|R
40|$|Extended {{version of}} the paper {{appearing}} in the proceeding of "Linearity 2016 "International audienceThe original idea of proof nets can be formulated by means of interaction nets syntax. Additional machinery as switching, jumps and graph connectivity is {{needed in order to}} ensure correspondence between a proof structure and a correct proof in sequent calculus. In this paper we give two models of proof structures in the <b>syntax</b> of string <b>diagrams.</b> Even though we lose standard proof equivalence, our construction allows to prove a uniform correction criterion which is internal to the syntax and of constant time complexity...|$|R
40|$|This is {{a conference}} paper. We here {{describe}} technical issues in setting objective tests in various areas of mathematics using Question Mark Perception’s QML language and format files, coupled with MathML mathematics mark-up and the Scalable Vector Graphics (SVG) <b>syntax</b> for producing <b>diagrams.</b> The plain text MathML and SVG coding can replace graphics files {{commonly used to}} display equations and diagrams in CAA packages and web pages, and have the overwhelming advantage that random parameters can be dropped into the interpreted plain text at runtime, thereby producing many millions of realisations of the underlying question style...|$|R
40|$|An {{existing}} {{procedure to}} compute left Kan extensions {{over the ground}} category Set also computes left Kan extensions over the ground categories Cat, 2 -Cat, n-Cat for any n and indeed !-Cat. Therefore extension data structured in this manner already can {{make use of the}} left Kan extension notion of a best possible approximation. Examples include systems of labeled transition systems and certain higher dimensional rewriting systems. Keywords: Algorithms, higher dimensional structures, transition systems, labeled transition systems. A functor X: B ! S may be used to present a behavior of a base <b>syntax,</b> or <b>diagram,</b> B, over a ground category S. The ground category S is typically the category of sets and functions or else a close relative such as the category of finite sets and functions between them. A functor K: B ! E may be used to present an extension E of the base diagram B. It is then asked what is a best extension of the behavior X: B ! S to a behavior E ! S, given K: B ! E. One ans [...] ...|$|R
40|$|We {{introduce}} the Evidence Verification Algorithm (EVA) in this paper, which verifies consistency of life cycles of ev-idences (evidence documents) in workflow diagrams. We used the AIST Workflow Language (AWL) as the <b>syntax</b> for workflow <b>diagrams,</b> which has {{additional information about}} evidences. A workflow diagram of AWL {{is essentially the same}} as a Unified Modeling Language (UML) activity dia-gram. EVA verifies the existence of consistent sequences of flows between the occurrences of evidences in a workflow diagram. It is important to verify consistency of life cycles of evidences, since some defects in the workflow diagram itself can be found by checking inconsistent life cycles of evidences in a workflow diagram...|$|R
