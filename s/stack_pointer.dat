184|34|Public
25|$|R13 is also {{referred}} to as SP, the <b>Stack</b> <b>Pointer.</b>|$|E
25|$|Has {{dedicated}} zero or <b>stack</b> <b>pointer</b> (SP) register (depending on instruction).|$|E
25|$|Uniform 16× 32-bit {{register}} file (including {{the program}} counter, <b>stack</b> <b>pointer</b> and the link register).|$|E
50|$|Bellmac 32 has {{a program}} counter and 15 {{general-purpose}} 32-bit registers. Three {{of these are}} used to support the operating system {{and can be used}} when the microprocessor is in kernel mode. It has three other registers that are used by some instructions as <b>stack</b> <b>pointers.</b>|$|R
50|$|The linker adds any {{necessary}} {{header information}} {{required by the}} operating system in order to execute the program, and ensures the run time library assembler support code is run which sets up the run time environment (data and <b>stack</b> <b>pointers)</b> and passes control to the start procedure of the application.|$|R
50|$|When {{setting up}} data {{structures}} like lists, queues and trees, {{it is necessary}} to have pointers to help manage how the structure is implemented and controlled. Typical examples of pointers are start pointers, end <b>pointers,</b> and <b>stack</b> <b>pointers.</b> These pointers can either be absolute (the actual physical address or a virtual address in virtual memory) or relative (an offset from an absolute start address ("base") that typically uses fewer bits than a full address, but will usually require one additional arithmetic operation to resolve).|$|R
25|$|R13 and R14 are banked {{across all}} privileged CPU modes except system mode. That is, each mode {{that can be}} entered because of an {{exception}} has its own R13 and R14. These registers generally contain the <b>stack</b> <b>pointer</b> and the return address from function calls, respectively.|$|E
25|$|An {{advantage}} of this system is that the supervisor level has a separate <b>stack</b> <b>pointer.</b> This permits a multitasking system to use very small stacks for tasks, because the designers {{do not have to}} allocate the memory required to hold the stack frames of a maximum stack-up of interrupts.|$|E
25|$|Among the {{significant}} enhancements {{introduced in the}} 6809 were the use of two 8-bit accumulators (A and B, which could be combined into a single 16-bit register, D), two 16-bit index registers (X, Y) and two 16-bit stack pointers. The index and stack registers allowed advanced addressing modes. Program counter relative addressing allowed for the easy creation of position-independent code, while a user <b>stack</b> <b>pointer</b> (U) facilitated the creation of reentrant code.|$|E
50|$|In systems {{supporting}} high thread counts, it {{is better}} if the hardware interrupt mechanism switches the stack to a special system stack, so {{that none of the}} thread stacks need account for worst-case nested interrupt usage. Tiny CPUs {{as far back as the}} 8-bit Motorola 6809 from 1978 have provided separate system and user <b>stack</b> <b>pointers.</b>|$|R
5000|$|BP/EBP/RBP: <b>Stack</b> base <b>pointer</b> {{for holding}} {{the address of}} the current stack frame.|$|R
5000|$|Quicksort {{operates}} in-place on {{the data}} to be sorted. However, quicksort requires [...] <b>stack</b> space <b>pointers</b> {{to keep track of}} the subarrays in its divide and conquer strategy. Consequently, quicksort needs [...] additional space. Although this non-constant space technically takes quicksort out of the in-place category, quicksort and other algorithms needing only [...] additional pointers are usually considered in-place algorithms.|$|R
2500|$|Thread mode (ARMv6-M, ARMv7-M, ARMv8-M): A mode {{which can}} be {{specified}} as either privileged or unprivileged, while whether Main <b>Stack</b> <b>Pointer</b> (MSP) or Process <b>Stack</b> <b>Pointer</b> (PSP) is used can also be specified in CONTROL register with privileged access. This mode is designed for user tasks in RTOS environment but it's typically used in bare-metal for super-loop.|$|E
2500|$|The CPU {{has eight}} 32-bit {{general-purpose}} data registers (D0-D7), and eight address registers (A0-A7). The last address register is the <b>stack</b> <b>pointer,</b> and assemblers accept the label SP as equivalent to A7. This {{was a good}} number of registers at the time in many ways. It was small enough to allow the 68000 to respond quickly to interrupts (even in the worst case where all 8 data registers D0–D7 and 7 address registers A0–A6 needed to be saved, 15 registers in total), and yet large enough to make most calculations fast, because they could be done entirely within the processor without keeping any partial results in memory. (Note that an exception routine in supervisor mode can also save the user <b>stack</b> <b>pointer</b> A7, which would total 8 address registers. However, the dual <b>stack</b> <b>pointer</b> (A7 and supervisor-mode A7') design of the 68000 makes this normally unnecessary, except when a task switch is performed in a multitasking system.) ...|$|E
2500|$|The V60/V70/V80 mostly {{shared a}} common architecture. They had thirty-two 32-bit {{general-purpose}} registers, although the last three of these were commonly used as <b>stack</b> <b>pointer,</b> frame pointer and argument pointer. The V60 and V70 had a 119-instruction set, slightly extended to 123 instructions for the V80. The instructions have variable-length between one and 22 bytes, and they take two operands, both {{of which can be}} memory locations. After studying the V60's reference manual, Paul Vixie described it as [...] "a very vax-ish arch, with a V20/V30 emulation mode (which, if you recall, means it can run Intel 8086/8088 software)".|$|E
50|$|A {{new feature}} {{introduced}} in the AMD64 extensions is called the Interrupt Stack Table (IST), which also resides in the TSS and contains logical (segment+offset) <b>stack</b> <b>pointers.</b> If an interrupt descriptor table specifies an IST entry to use (there are 8), the processor will load the new stack from the IST instead. This allows known-good stacks {{to be used in}} case of serious errors (NMI or Double fault for example). Previously, the entry for the exception or interrupt in the IDT pointed to a task gate, causing the processor to switch to the task that is pointed by the task gate. The original register values were saved in the TSS current at the time the interrupt or exception occurred. The processor then set the registers, including SS:ESP, to a known value specified in the TSS and saved the selector to the previous TSS. The problem here is that hardware task switching is not supported on AMD64.|$|R
50|$|The {{randomization}} of {{the stack}} base {{has an effect on}} payload delivery during shellcode and return-to-libc attacks. Shellcode attacks modify the return pointer field to the address of the payload; while return-to-libc attacks modify the <b>stack</b> frame <b>pointer.</b> In either case, the probability of success is diminished significantly; the position {{of the stack}} is unpredictable, and missing the payload likely causes the program to crash.|$|R
40|$|A {{significant}} problem of lock-free concurrent data structures {{in an environment}} without garbage collection is to ensure safe memory reclamation of objects that are removed from the data structure. An elegant {{solution to this problem}} is Michael's hazard pointers method, but the verification of a simple lock-free <b>stack</b> with hazard <b>pointers</b> is challenging. This work contributes to the formal verification of lock-free algorithms. Using the temporal logic framework of the interactive prover KIV, we intuitively verify correctness and liveness of a lock-free <b>stack</b> with hazard <b>pointers.</b> The proof exploits the algorithm's symmetry and requires neither additional history variables nor temporal past operators to describe inter-process interference. Moreover, the verification shows a relation between hazard pointers and garbage collection, which makes it possible to reuse the verification conditions from the simpler proof under garbage collection. Die Arbeit beschreibt die intuitive, formale Verifikation eines lock-freien <b>Stacks</b> mit Hazard <b>Pointer.</b> Im Gegensatz zu vorherigen Beweisen werden dabei weder zusätzliche History-Variablen, noch vergangenheitsorientierte Argumente verwendet. Es wird die Symmetrie der Speicherverwaltungstechnik "Hazard Pointer" sowie deren Beziehung zu Garbage Collection aufgezeigt...|$|R
50|$|When stack {{frame sizes}} can differ, such as between {{different}} functions or between invocations {{of a particular}} function, popping a frame off the stack does not constitute a fixed decrement of the <b>stack</b> <b>pointer.</b> At function return, the <b>stack</b> <b>pointer</b> is instead restored to the frame pointer, {{the value of the}} <b>stack</b> <b>pointer</b> just before the function was called. Each stack frame contains a <b>stack</b> <b>pointer</b> {{to the top of the}} frame immediately below. The <b>stack</b> <b>pointer</b> is a mutable register shared between all invocations. A frame pointer of a given invocation of a function is a copy of the <b>stack</b> <b>pointer</b> as it was before the function was invoked.|$|E
5000|$|... which {{removes the}} last symbol from the <b>stack</b> <b>pointer</b> (i.e. it moves the <b>stack</b> <b>pointer</b> {{to the parent}} position), and ...|$|E
5000|$|... which {{replaces the}} current <b>stack</b> <b>pointer</b> [...] by [...] (i.e. it moves the <b>stack</b> <b>pointer</b> to the -th child position) if [...] {{is in the}} domain of , ...|$|E
40|$|Abstract. In [1] {{the almost}} {{complete}} formal verification {{of a small}} hypervisor with the automated C code verifier VCC [2] was reported: the correctness of the C portions of the hypervisor and of the guest simulation was established; the verification of the assembler portions of the code was left as future work. Suit-able methodology for the verification of Macro Assembler programs in VCC was given without soundness proof in [3]. A joint semantics of C + Macro Assembler necessary for such a soundness proof was introduced in [4]. In this paper i) we observe that for two instructions (that manipulate <b>stack</b> <b>pointers)</b> of the hyper-visor code the C + Macro Assembler semantics does not suffice; therefore we extend it to C + Macro Assembler + assembler, ii) we argue the soundness of the methodology from [3] {{with respect to this}} new semantics, iii) we apply the methodology from [3] to formally verify the Macro Assembler + assembler por-tions of the hypervisor from [1], completing the formal verification of the small hypervisor in the automated tool VCC. ...|$|R
25|$|One way {{to attack}} a piece of {{software}} is to redirect the flow of execution of a program. A variety of control-flow integrity techniques, including stack canaries, buffer overflow protection, shadow <b>stacks,</b> and vtable <b>pointer</b> verification, are used to defend against these attacks.|$|R
50|$|Climbing {{back up to}} {{the root}} {{requires}} O(log n) storage space, usually allocated on the <b>stack,</b> or parent <b>pointers.</b> This can actually be avoided by pointing each child at its parent as you go down, and repairing on the walk back up.|$|R
5000|$|... a pop or pull operation: a {{data item}} {{at the current}} {{location}} pointed to by the <b>stack</b> <b>pointer</b> is removed, and the <b>stack</b> <b>pointer</b> is adjusted {{by the size of}} the data item.|$|E
50|$|Moves the <b>stack</b> <b>pointer</b> {{further by}} {{decreasing}} or increasing its value, {{depending on whether}} the stack grows down or up. On x86, the <b>stack</b> <b>pointer</b> is decreased {{to make room for the}} function's local variables.|$|E
5000|$|... a push operation, {{in which}} a data item is placed at the {{location}} pointed to by the <b>stack</b> <b>pointer,</b> and the address in the <b>stack</b> <b>pointer</b> is adjusted {{by the size of}} the data item; ...|$|E
50|$|One way {{to attack}} a piece of {{software}} is to redirect the flow of execution of a program. A variety of control-flow integrity techniques, including stack canaries, buffer overflow protection, shadow <b>stacks,</b> and vtable <b>pointer</b> verification, are used to defend against these attacks.|$|R
50|$|Control-flow {{integrity}} (CFI) is {{a general}} term for computer security techniques which prevent {{a wide variety of}} malware attacks from redirecting the flow of execution of a program. Associated techniques include code-pointer separation (CPS), code-pointer integrity (CPI), stack canaries, shadow <b>stacks,</b> and vtable <b>pointer</b> verification.|$|R
40|$|As part of {{designing}} and building the Amoeba distributed operating system, {{we have come}} up with a simple set of mechanisms for process management hat allows downloading, process migration, checkpointing, remote debugging and emulation of alien operating system interfaces. The basic process management facilities are realized by the Amoeba Kernel and can be augmented by user-space services: Debug Service, Load-Balancing Service, Unix-Emulation Service, Checkpoint Service, etc. The Amoeba Kernel can produce a representation of the state of a process which can be given to another Kernel where it is accepted for continued exe-cution. This state consists of the memory contents in the form of a collection of segments, and a Process Descriptor which contains the additional state, pro-gram counters, <b>stack</b> <b>pointers,</b> system call state, etc. Careful separation of mechanism and policy has resulted in a compact set of Kernel operations for process creation and management. A collection of user-space services provides process management policies and a simple inter-face for application programs. In this paper we shall describe the mechanisms as they are being imple-mented in the Amoeba Distributed System at the Centre for Mathematics and Computer Science in Amsterdam. We believe that the mechanisms described here can also apply to other distributed systems...|$|R
50|$|If frame {{pointers}} {{are being}} used, the prologue will typically set the new {{value of the}} frame pointer register from the <b>stack</b> <b>pointer.</b> Space on the stack for local variables can then be allocated by incrementally changing the <b>stack</b> <b>pointer.</b>|$|E
50|$|Simpler {{processors}} {{store the}} <b>stack</b> <b>pointer</b> {{in a regular}} hardware register and use the arithmetic logic unit (ALU) to manipulate its value. Typically push and pop are translated into multiple micro-ops, to separately add/subtract the <b>stack</b> <b>pointer,</b> and perform the load/store in memory.|$|E
50|$|Many {{computers}} (such as x86 and AVR) {{have one}} special-purpose register called the <b>stack</b> <b>pointer</b> which is implicitly incremented or decremented when pushing or popping {{data from the}} stack, and the source or destination effective address is (implicitly) the address stored in that <b>stack</b> <b>pointer.</b>|$|E
50|$|It is also {{possible}} to discover {{the parent of a}} node from a threaded binary tree, without explicit use of parent <b>pointers</b> or a <b>stack,</b> albeit slowly. This can be useful where stack space is limited, or where a <b>stack</b> of parent <b>pointers</b> is unavailable (for finding the parent pointer via DFS).|$|R
50|$|It is {{possible}} to leak information about memory layout using format string vulnerabilities. Format string functions such as printf use a variable argument list to do their job; format specifiers describe what the argument list looks like. Because of the way arguments are typically passed, each format specifier moves closer {{to the top of}} the stack frame. Eventually, the return <b>pointer</b> and <b>stack</b> frame <b>pointer</b> can be extracted, revealing the address of a vulnerable library and the address of a known stack frame; this can completely eliminate library and stack randomization as an obstacle to an attacker.|$|R
50|$|The MC6801 was a single-chip {{microcomputer}} with a 6802 CPU with 128 bytes of RAM, a 2 KB ROM, a 16-bit timer, 31 programmable parallel I/O lines, and a serial port. It could {{also use the}} I/O lines as data and address buses to connect to standard M6800 peripherals. The 6801 would execute 6800 code but it had ten additional instructions and the execution time of key instructions was reduced. The two 8-bit accumulators could act as a single 16-bit accumulator for double precision addition, subtraction and multiplication. It was initially designed for automotive use with General Motors as the lead customer. The first application was a trip computer for the 1978 Cadillac Seville. This 35,000 transistor chip was too expensive for wide-scale adoption in automobiles so a reduced function MC6805 {{single-chip microcomputer}} was designed. The MC6809 was the most advanced 8-bit microprocessor Motorola produced. It had a new instruction set that {{was similar to the}} 6800 but abandoned op-code compatibility for improved performance and high-level language support; the two were software compatible in that assemblers could (and generally did) generate code which was equivalent to 6800 opcodes the 6809 did not directly emulate. In that sense, the 6809 was upward compatible with the 6800. The 6809 had many 16-bit operations, including the first 8-bit multiply instruction (generating a 16 bit product) in a microprocessor, two 16-bit index registers and <b>stack</b> <b>pointers,</b> and full support for both position independent (object code could run wherever it was loaded in memory) and reentrant (object code could be written to be reused by other routines), these last features previously seen only in much larger machines such as IBM 360 mainframes.|$|R
