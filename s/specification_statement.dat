25|77|Public
5000|$|Refinement {{calculus}} extends non-deterministic statements {{with the}} notion of <b>specification</b> <b>statement.</b> Informally, this statement represents a procedure call in black box, where the body of the procedure is not known. Typically, using a syntax close to B-Method, a <b>specification</b> <b>statement</b> is written ...|$|E
5000|$|The weakest-precondition of <b>specification</b> <b>statement</b> {{is given}} by: ...|$|E
5000|$|... #Subtitle level 3: <b>Specification</b> <b>statement</b> (or weakest-precondition of {{procedure}} call) ...|$|E
40|$|This paper {{addresses}} {{the issue of}} giving a formal semantics to an object-oriented programming and specification language. Object-oriented constructs considered are objects with attributes and methods, encapsulation of attributes, subtyping, bounded type parameters, classes, and inheritance. Classes are distinguished from object types. Besides usual imperative <b>statements,</b> <b>specification</b> <b>statements</b> are included. <b>Specification</b> <b>statements</b> allow changes of variables to be described by a predicate. They are abstract {{in the sense that}} they are non-executable. <b>Specification</b> <b>statements</b> may appear in method bodies of classes, leading to abstract classes. The motivation for this approach is that abstract classes can be used for problem -oriented specification in early stages and later refined to efficient implementations. Various refinement calculi provide laws for procedural and data refinement, which can be used here for class refinement. This paper, however, focuses on the semantics of object-o [...] ...|$|R
40|$|Constraint {{diagrams}} [1, 2] {{constitute a}} graphical notation for program specification. This paper presents an experiment that compares {{the efficacy of}} constraint diagrams (CD) with natural language (NL) for understanding program <b>specification</b> <b>statements.</b> In a web-based competition 33 participants were given training either on CD notation or equivalent NL expression, and answered questions about <b>specification</b> <b>statements.</b> It was predicted that the CD participants would find learning and answering questions harder {{than those in the}} NL group, because they had no prior experience of CD notation. Although the CD group spent more time on the training examples and were less confident about their answers, they spent less time answering the questions and achieved approximately the same proportion of correct answers as the NL group...|$|R
40|$|Data {{refinement}} is {{a powerful}} technique to derive implementations in terms of low-level data structures like bytes from specification in terms of highlevel data structures like queues. The higher level operations need not be coded as ordinary programs; {{it is more convenient}} to introduce <b>specification</b> <b>statements</b> to the programming language and use them instead of actual code. <b>Specification</b> <b>statements</b> represent the maximal program satisfying a given Hoare-triple. Sound and (relatively) complete simulation techniques allow for proving data refinement by local arguments. A major challenge for simulation consists of expressing the weakest lower level specification simulating a given higher level specification w. r. t. a given relation between these two levels of abstraction. We present solutions to this challenge for upward and downward simulation in both partial and total correctness frameworks, thus reducing the task of proving data refinement to proving validity of certain Hoare-triples [...] . ...|$|R
5000|$|The same {{counter-example}} can be reproduced using a <b>specification</b> <b>statement</b> (see above) instead: ...|$|E
50|$|This is {{the case}} for , even if {{statement}} S is non-deterministic as a selection statement or a <b>specification</b> <b>statement.</b>|$|E
5000|$|Moreover, a {{statement}} S implements such a <b>specification</b> <b>statement</b> if {{and only if}} the following predicate is a tautology: ...|$|E
40|$|PROC TRANSPOSE {{can be used}} to "rotate " (transpose) SAS ® data sets. I. e. {{the values}} of one given {{variable}} become variable names and variables in the input data set become observations in the output. The answers to three simple questions suffice to define the <b>specification</b> <b>statements</b> of PROC TRANSPOSE. This paper poses these questions and demonstrates how PROC TRANSPOSE can be handled using them...|$|R
40|$|Traditional formal {{methods and}} modern agile methods are {{separated}} more by limitations of current technology than by fundamental intellectual differences. A mixed interpreter that executes mixed programs, comprising both declarative <b>specification</b> <b>statements</b> and regular imperative statements, might bridge the gap. This paper explores how such an interpreter might be used, showing by example {{how it might}} support a variety of development activities. National Science Foundation (U. S.) (Grant No. 0541183...|$|R
50|$|The MSI 20000 scope <b>statement’s</b> <b>specification</b> {{provides}} the requirements {{in terms of}} the financial quality of firms, depending on their sector of activity. The <b>statement’s</b> <b>specifications</b> focus on two main aspects: financial strength and financial performance.|$|R
40|$|AbstractThe <b>specification</b> <b>{{statement}}</b> {{allows us}} to easily express what a program statement does. This paper shows how refinement of specification statements can be directly expressed using the predicate calculus. It also shows that the specification statements interpreted as predicate transformers form a complete lattice, and that this lattice is the lattice of conjunctive predicate transformers. The join operator of this lattice is constructed as a <b>specification</b> <b>statement.</b> The join operators of two interesting sublattices of the set of specification statements are also investigated...|$|E
40|$|Abstract. We {{introduce}} a new algebraic model for program variables, suitable for reasoning about recursive procedures with parameters and local variables in a mechanical verification setting. We give a predicate transformer semantics to recursive procedures and prove refinement rules for introducing recursive procedure calls, procedure parameters, and local variables. We also prove, based on the refinement rules, Hoare total correctness rules for recursive procedures, and parameters. We {{introduce a}} special form of Hoare <b>specification</b> <b>statement</b> which alone is enough to fully specify a procedure. Moreover, we prove that this Hoare <b>specification</b> <b>statement</b> is equivalent to a refinement specification. We implemented this theory in the PVS theorem prover...|$|E
40|$|In {{this paper}} {{we present a}} case study in {{deriving}} an algorithm from a formal specification via FermaT transformations. The general method (which is presented in a separate paper) is extended to a method for deriving an implementation of a program transformation from a specification of the program transformation. We use program slicing as an example transformation, since this is of interest outside the program transformation community. We develop a formal specification for program slicing, {{in the form of a}} WSL <b>specification</b> <b>statement,</b> which is refined into a simple slicing algorithm by applying a sequence of general purpose program transformations and refinements. Finally, we show how the same methods can be used to derive an algorithm for semantic slicing. The main novel contributions of this paper are: (1) Developing a formal specification for slicing. (2) Expressing the definition of slicing in terms of a WSL <b>specification</b> <b>statement.</b> (3) By applying correctness preserving transformations to the specification we can derive a simple slicing algorithm. ...|$|E
40|$|AbstractAn {{algebraic}} {{technique for}} reasoning about recursive programs is proposed. The technique {{is based on}} Tarski's axioms of least fixed points of monotonic functions {{and the existence of}} weak-op-inverses. The algebraic style gives rise to elegant proofs, although the requirement of existence of weak-op-inverse may limit applicability. When such inverses do exist, the method can be used in presence of noncontinuous but monotonic operators occuring in languages containing unbounded nondeterminism, fairness constraints and <b>specification</b> <b>statements...</b>|$|R
40|$|We {{investigate}} {{the relationship between}} specifications by means of Hoare triples and <b>specification</b> <b>statements</b> in the Refinement Calculus style, focusing {{on the issue of}} sharpness. In particular, we examine the exact status and role of specification variables, showing that their interpretation is not as straightforward as one might intuitively think. In {{the second part of the}} paper we demonstrate how our results can be applied to the derivation of proof rules for correctness of procedure calls...|$|R
40|$|This paper {{describes}} a formal component language, {{used to support}} automated component-based program development. The components, referred to as templates, are machine processable, meaning that appropriate tool support, such as retrieval support, can be developed. The templates are highly adaptable, meaning {{that they can be}} applied {{to a wide range of}} problems. Some of the main features of the language are described, including: higher-order parameters; state variable declarations; <b>specification</b> <b>statements</b> and conditionals; applicability conditions and theories; meta-level place holders; and abstract data structures...|$|R
40|$|A {{specification}} and top-level {{refinement of}} a simple mine pump control system, {{as well as a}} proof of correctness of the refinement, are presented {{as an example of the}} application of a formal method for the development of time-based systems. The overall approach makes use of a refinement calculus for timed systems similar to the refinement calculi for sequential programs. The specification makes use of topologically continuous functions of time to describe both analog and discrete properties of both the system and its refinements. The basic building block of specifications is a <b>specification</b> <b>statement,</b> similar to Morgan’s <b>specification</b> <b>statement</b> for sequential programs. It gives a clear separation between the specification of the assumptions that the system may make about the environment in which it is to be placed, and the effect the system is guaranteed to achieve if placed in such an environment. The top-level refinement of the system is developed by application of refinement laws that allow design decisions to be made, local state to be introduced, and the decomposition of systems into pipe-lined and/or parallel processes...|$|E
40|$|AbstractWe {{propose a}} new and uniform {{abstract}} relational approach to demonic nondeterminism and robust correctness similar to Hoare's chaos semantics. It {{is based on a}} specific set of relations on flat lattices. This set forms a complete lattice. Furthermore, we deal with the refinement of programs. Among other things, we show the correctness of the unfold/fold method for demonic nondeterminism and robust correctness as refinement relation and investigate relationships to Dijkstra's wp-calculus and Morgan's <b>specification</b> <b>statement...</b>|$|E
40|$|AbstractThis paper proposes an {{approach}} to prove reachability properties of the form AG(ψ⇒EFϕ) using substitution refinement in classical B. Such properties denote that there exists an execution path for each state satisfying ψ to a state satisfying ϕ. These properties frequently occur in security policies and information systems. We show how to use Morganʼs <b>specification</b> <b>statement</b> to represent a property and refinement laws to prove it. The idea is to construct by stepwise refinement a program whose elementary statements are operation calls. Thus, the execution of such a program provides an execution satisfying AG(ψ⇒EFϕ). Proof obligations are represented using assertions (ASSERTIONS clause of B) and can be discharged using Atelier B...|$|E
40|$|Abstract. We {{present a}} case study of the {{application}} of fact-oriented modeling to the capture and management of requirement specifications for the introduction of an information technology solution within Microsoft. The delivered solution involves automation and centralization of information about relationships between Microsoft product offerings. The methodology contributed to the project’s fast turn-around time and high quality deliverable largely due to the clarity, completeness and traceability of business concepts and individual <b>specification</b> <b>statements.</b> We conclude with a generalization of the methodology used. Page 3 of 1...|$|R
40|$|The paper {{explores the}} overall {{feasibility}} and possible advantages of part-whole hierarchical state-based modeling {{with respect to}} formal specification and verification. It is shown, partly by a running example, that the identification of pattern of coordinated behavior allows to partition the overall complexity of a state based design by self-contained and uncoupled modules. Such modules can be incrementally validated against specification constraints, thus allowing to reuse al- ready validated modules. Finally, the proposed approach interleaves validation and design, forcing the designer to transform <b>specification</b> <b>statements</b> into state proposi- tions which further improve understandability...|$|R
40|$|The lack of {{a formal}} {{semantics}} for UML-RT makes it inadequate for rigourous system development, especially if the preservation of behaviour {{is a major concern}} when applying well-known model transformations, like refactorings and refinements. In this paper, we propose a semantics for UML-RT active classes through a mapping into Circus, a specification language that combines CSP, Z and <b>specification</b> <b>statements.</b> As a consequence of the translation, we are able to prove that model transformations preserve both static and dynamic behaviour, using refinement laws and a relational semantics of Circus, based on th...|$|R
40|$|International audienceThis paper proposes an {{approach}} to prove reachability properties of the form AG psi => EF phi using substitution refinement in classical B. Such properties denote that there exists an execution path for each state satisfying psi to a state satisfying phi. These properties frequently occur in security policies and information systems. We show how to use Morgan's <b>specification</b> <b>statement</b> to represent a property and refinement laws to prove it. The idea is to construct by stepwise refinement a program whose elementary statements are operation calls. Thus, the execution of such a program provides an execution satisfying AG psi => EF phi. Proof obligations are represented using assertions (ASSERT clause of B) and can be discharged using Atelier...|$|E
40|$|AbstractA uniform {{treatment}} of specifications, programs, and programming is presented. The treatment {{is based on}} adding a <b>specification</b> <b>statement</b> to a given procedural language and defining its semantics. The extended language is thus a specification language and programs are viewed as a subclass of specifications. A partial ordering on specifications/programs corresponding to ‘more defined’ is defined. In this partial ordering the program/specification hybrids that arise {{in the construction of}} a program by stepwise refinement form a monotonic sequence. We show how Dijkstra's calculus for the derivation of programs corresponds to constructing this monotonic sequence. Formalizing the calculus thus gives some insight into the intellectual activity it demands and allows us to hint at further developments...|$|E
40|$|This thesis puts {{forward a}} {{flexible}} and principled {{approach to the}} development of construction and verification tools for imperative programs, in which the control flow and the data level are cleanly separated. The approach is inspired by algebraic principles and benefits from an algebraic semantics layer. It is programmed in the Isabelle/HOL interactive theorem prover and yields simple lightweight mathematical components as well as program construction and verification tools that are themselves correct by construction. First, a simple tool is implemented using Kleeene algebra with tests (KAT) for the control flow of while-programs, which is the most compact verification formalism for imperative programs, and their standard relational semantics for the data level. A reference formalisation of KAT in Isabelle/HOL is then presented, providing three different formalisations of tests. The structured comprehensive libraries for these algebras include an algebraic account of Hoare logic for partial correctness. Verification condition generation and program construction rules are based on equational reasoning and supported by powerful Isabelle tactics and automated theorem proving. Second, the tool is expanded to support different programming features and verification methods. A basic program construction tool is developed by adding an operation for the <b>specification</b> <b>statement</b> and one single axiom. To include recursive procedures, KATs are expanded further to quantales with tests, where iteration and the <b>specification</b> <b>statement</b> can be defined explicitly. Additionally, a nondeterministic extension supports the verification of simple concurrent programs. Finally, the approach is also applied to separation logic, where the control-flow is modelled by power series with convolution as separating conjunction. A generic construction lifts resource monoids to assertion and predicate transformer quantales. The data level is captured by concrete store-heap models. These are linked to the algebra by soundness proofs. A number of examples shows the tools at work...|$|E
40|$|It is {{generally}} accepted that poorly written requirements {{can result in}} software with the wrong functionality. The Goddard Space Flight Center's (GSFC) Software Assurance Technology Center (SATC) has developed an early life cycle tool for assessing requirements that are specified in natural language. The tool searches the document for terms the SATC has identified as quality indicators, e. g. weak phrases. The reports produced by the tool are used to identify <b>specification</b> <b>statements</b> and structural areas of the requirements specification document {{that need to be}} improved. The metrics are used by project managers to recognize and preclude potential areas of risk...|$|R
40|$|The {{behaviour}} of a real-time {{system that}} interacts repeatedly with its environment is most succinctly specified by its possible traces, or histories. We present {{a way of}} using the refinement calculus for developing real-time programs from requirements expressed in this form. Our trace-based <b>specification</b> <b>statements</b> and target language constructs constrain the traces of system variables, rather than updating them destructively like the usual state-machine model. The only variable that is updated is a special current-time variable. The resulting calculus allows refinement from formal specifications with hard real-time requirements, to high-level language programs annotated with precise timing constraints...|$|R
5000|$|In SQL, renames are {{performed}} {{by using the}} [...] <b>specification</b> in [...] <b>statements.</b>|$|R
40|$|The present paper {{contains}} a new result on {{the combination of}} Hoare logic and Scott's induction rule, obtained by taking the <b>specification</b> <b>statement</b> ϕψ as basic statement instead of assignments [...] -here ϕ and ψ stand for recursively enumerable first order assertions. This result owes its significance to EdR:mfcs 96, in which the general case of data refinement is shown to be expressible using specification statements. Consequently the resulting Hoare logic enables data refinement proofs, and the interesting question arises to which extent this logic can be simplified without sacrificing completeness. We present a rather simple sound and relatively complete logic in which the recursion rule {{does not require a}} deduction in its antecedent, in contrast to all but one formulation of Scott's induction rule, namely the one by Jerald Schwarz Schwarz 77...|$|E
40|$|The {{purpose of}} this study was to {{determine}} if the 55 test specifications for the Praxis I: Academic Skills Assessments computer-based tests (CBT) and the Praxis I: Pre-Professional Skills Tests (PPST) were judged to be appropriate for entry-level vocational education teachers regardless of specialty area. The test specification statements were mailed to a random sample of 5, 610 vocational education teachers representing 11 specialty areas. Useable surveys were returned by 2, 347 vocational education teachers. Judgments of importance were made using a 5 -point rating scale. A test <b>specification</b> <b>statement</b> was considered to be appropriate for entry-level vocational education teachers if respondents from at least 9 or 11 specialty areas judged it to have a mean importance greater than 3. 0 (moderately important). The results indicated that all 55 test specifications received mean ratings above 3. 00 b...|$|E
40|$|We {{propose a}} {{specification}} language for shared-variable concurrent programs based on Morgan's <b>specification</b> <b>statement</b> [Mor 89]. A denotational semantics {{is given in}} terms of transition traces (sequences of pairs of states) following [Bro 93]. A context-sensitive notion of approximation between specifications is presented which permits modular verification through stepwise program transformation. We argue that the resulting framework also supports program development through stepwise refinement. 1 Introduction In the quest for tractable verification methods for concurrent systems, assumptioncommitment reasoning has {{received a lot of}} attention, e. g., [Jon 83, Pnu 85, AL 93, GL 91]. In this approach, proofs are split into two parts: First, it is shown that a component of the overall system satisfies a certain property under the assumption that its environment behaves in a certain way. Then, this environment assumption is discharged by proving that the actual environment does indeed meet the [...] ...|$|E
40|$|AbstractPreparing the {{students}} for {{the demands of the}} 21 century employment market requires training them to assemble scientific knowledge and to approach complex problems {{in the same way that}} scientists do. SMELT, the Physical Study of the MatEriaL erupTing from mud volcanoes, is an assessment instrument for experimental activity in physics. The paper presents the assessment objectives, table of <b>specifications,</b> <b>statement</b> and answer sheet of the experimental problem, as well as evidence of the assessment tool and interpretation of the results obtained by the competitors. The analysis of the results led to conclusions on the scientific abilities of students selected in the Olympic team...|$|R
5000|$|Proponents include Ralph-Johan Back, who {{originated}} {{the approach}} in his 1978 PhD thesis On the Correctness of Refinement Steps in Program Development, and Carroll Morgan, especially with his book Programming from Specifications (Prentice Hall, 2nd edition, 1994, [...] ). In the latter case, the motivation was to link Abrial's specification notation Z, via a rigorous relation of behaviour-preserving program refinement, to an executable programming notation based on Dijkstra's language of guarded commands. Behaviour-preserving {{in this case}} means that any Hoare triple satisfied by a program should also be satisfied by any refinement of it, which notion leads directly to <b>specification</b> <b>statements</b> as pre- and postconditions standing, on their own, for any program that could soundly be placed between them.|$|R
5000|$|At {{this point}} Gadfly {{supports}} {{quite a lot}} of the SQL semantics requested in the ODBC 2.0 <b>specification.</b> SQL <b>statements</b> supported include the SELECT:SELECT DISTINCT|ALL expressions or * FROM tables condition BY group-expressions aggregate-condition union-clause BY columnsThis statement is quite powerful. It reads as follows: ...|$|R
