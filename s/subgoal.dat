352|610|Public
25|$|In a team, {{each member}} has a <b>subgoal</b> {{pertinent}} to his/her specific role that feeds into the overall team goal. Associated with each member's <b>subgoal</b> are {{a set of}} SA elements about which he/she is concerned. Team SA, therefore, can be represented as shown in Figure 2. As {{the members of a}} team are essentially interdependent in meeting the overall team goal, some overlap between each member's <b>subgoal</b> and their SA requirements will be present. It is this subset of information that constitutes much of team coordination. That coordination may occur as a verbal exchange, a duplication of displayed information, or by some other means.|$|E
25|$|Subgoals {{encountered}} in a query evaluation are maintained in a table, along with {{answers to these}} subgoals. If a <b>subgoal</b> is re-encountered, the evaluation reuses information from the table rather than re-performing resolution against program clauses.|$|E
25|$|In {{the more}} general case, where {{sub-goals}} share variables, other strategies can be used, such as choosing the <b>subgoal</b> that is most highly instantiated or that is sufficiently instantiated so that only one procedure applies. Such strategies are used, for example, in concurrent logic programming.|$|E
40|$|This {{study was}} {{conducted}} to investigate the effect of <b>subgoals</b> on commitment and task performance. A model was developed which hypothesized that progress toward <b>subgoals</b> would affect three mediating variables: satisfaction with performance, expectancy of goal attainment, and intrinsic interest for the task. In turn, those variables were hypothesized to affect goal commitment. Finally, the interaction between goal commitment and goal difficulty was predicted to produce performance differences. ^ One hundred twenty undergraduate students solved addition problems for 60 minutes. They were assigned a goal for the number of problems to solve correctly that was 0 %, 10 %, or 20 % above their number summing ability. One-half of all subjects were also assigned four <b>subgoals</b> for the number of problems to solve {{in each of the four}} 15 -minute intervals of the performance session. ^ Regression and correlation analyses confirmed that the effect of <b>subgoals</b> on goal commitment was mediated by the three hypothesized mediators and that expectancy of goal attainment played a key role in that mediation. However, the variation in commitment produced by the mediational process did not affect performance. A goal difficulty effect was found such that higher goals led to higher performance. There was no effect of <b>subgoals</b> and no subgoal-goal difficulty interaction. ^ An exploratory set of regression and correlation analyses was conducted in which hypothetical <b>subgoals</b> were generated for subjects not assigned <b>subgoals.</b> Those analyses indicated that the model was also valid without the assignment of <b>subgoals.</b> This finding led to the conclusion that the main function of <b>subgoals</b> was to provide feedback about performance. However, the <b>subgoals</b> did not have the ability to effect performance changes. ^ It was suggested that future research investigate the utility of self-set <b>subgoals</b> and the frequency with which that strategy is employed. ...|$|R
40|$|Abstract – We address {{trust and}} {{security}} issues for new generation network (NWGN) and present {{the concept of}} trustworthy and secure NWGN. Towards such concept, we identify trust and security <b>subgoals</b> for NWGN, and classify trust <b>subgoals</b> into two groups based on the interaction of entities over NWGN. As for security, we present <b>subgoals</b> according to different characteristics of NWGN. Then, the requirements are clarified to achieve these <b>subgoals</b> from three aspects: trust/security services, trustworthy/secure communications, and architecture resilience. Finally, we investigate the trust establishment among users and provide functional architecture for it...|$|R
40|$|Reinforcement {{learning}} {{addresses the}} problem of learning to select actions {{in order to maximize}} an agent’s performance in unknown environments. To scale reinforcement learning to complex real-world tasks, agent must be able to discover hierarchical structures within their learning and control systems. This paper presents a method by which a reinforcement learning agent can discover <b>subgoals</b> with certain structural properties. By discovering <b>subgoals</b> and including policies to <b>subgoals</b> as actions in its action set, the agent is able to explore more effectively and accelerate learning in other tasks in the same or similar environments where the same <b>subgoals</b> are useful. The agent discovers the <b>subgoals</b> by searching a learned policy model for state that exhibits certain structural properties. This approach is illustrated using gridworld tasks...|$|R
25|$|Declarative {{programming}} languages {{describe what}} computation {{should be performed}} and not how to compute it. Declarative programs omit the control flow and are considered sets of instructions. Two broad categories of declarative languages are functional languages and logical languages. The principle behind functional languages (like Haskell) is to not allow side effects, which {{makes it easier to}} reason about programs like mathematical functions. The principle behind logical languages (like Prolog) is to define the problem to be solved– the goal– and leave the detailed solution to the Prolog system itself. The goal is defined by providing a list of subgoals. Then each <b>subgoal</b> is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that <b>subgoal</b> is backtracked and another path is systematically attempted.|$|E
25|$|The {{earliest}} work in computerized {{knowledge representation}} {{was focused on}} general problem solvers such as the General Problem Solver (GPS) system developed by Allen Newell and Herbert A. Simon in 1959. These systems featured data structures for planning and decomposition. The system would begin with a goal. It would then decompose that goal into sub-goals and then set out to construct strategies that could accomplish each <b>subgoal.</b>|$|E
2500|$|... {{there are}} two {{candidate}} solutions, which solve the first <b>subgoal</b> bird(X), namely X = john and X = mary. The second <b>subgoal</b> not abnormal(john) of the first candidate solution fails, because wounded(john) succeeds and therefore abnormal(john) succeeds. However, The second <b>subgoal</b> not abnormal(mary) of the second candidate solution succeeds, because wounded(mary) fails and therefore abnormal(mary) fails. Therefore, X = mary is the only solution of the goal.|$|E
40|$|In this research, {{our goal}} is that a mobile robot learns to move between <b>subgoals</b> in a real {{environment}} without interaction with humans. The robot does not have knowledge on the environment: positions of <b>subgoals</b> and obstacles. There are affects of various errors in experiments of a robot learning in a real world, and thus the robot learning is unavoidably influenced by the errors. We pay attention this point, and suggest how to learn to move efficiently between <b>subgoals</b> with resetting errors. In our system, we define the distinctive place on which the movement control of a robot changes from sensor-based to coordinatesbased. The distinctive place is identified only with local information, and the cumulative errors through the movement between two <b>subgoals</b> are reset on distinctive places. First, the robot moves randomly and tries to find <b>subgoals.</b> Next, it moves between <b>subgoals</b> repeatedly, and learns to move efficiently. We made experiments in a real environment, {{and found out that}} th [...] ...|$|R
40|$|Hierarchical Reinforcement Learning {{is often}} used for {{reinforcement}} learning problems that are too large to be handled directly. Most techniques consist of learning to handle <b>subgoals</b> on a lower level and having a higher level module, often a planner, choose between different <b>subgoals.</b> This requires the <b>subgoals</b> to have a sequential nature. In this work we study the Digger game, an example problem where several <b>subgoals</b> {{have to be dealt}} with concurrently. We design a new hierarchical reinforcement learning method that makes use of Relational Reinforcement Learning (RRL) and show some preliminary results of this technique. status: publishe...|$|R
40|$|This paper {{presents}} a {{method by which}} a reinforcement learning agent can automatically discover certain types of <b>subgoals</b> online. By creating useful new <b>subgoals</b> while learning, the agent is able to accelerate learning on the current task and to transfer its expertise to other, related tasks through the reuse {{of its ability to}} attain <b>subgoals.</b> The agent discovers <b>subgoals</b> based on commonalities across multiple paths to a solution. We cast the task of finding these commonalities as a multiple-instance learning problem and use the concept of diverse density to find solutions. We illustrate this approach using several gridworld tasks. 1...|$|R
2500|$|Given this program, {{the query}} [...] will succeed, because the program {{includes}} [...] as a fact; the query [...] will fail, {{because it does}} not occur in the head of any of the rules. The query [...] will fail also, because the only rule with [...] in the head contains the <b>subgoal</b> [...] in its body; as we have seen, that <b>subgoal</b> fails. Finally, the query [...] succeeds, because each of the subgoals , [...] succeeds. (The latter succeeds because the corresponding positive goal [...] fails.) To sum up, the behavior of SLDNF resolution on the given program can be represented by the following truth assignment: ...|$|E
5000|$|<b>Subgoal</b> labels {{have been}} used in worked {{examples}} to teach learners to solve problems in STEM domains [...] Pairing <b>subgoal</b> labeled instructional text with <b>subgoal</b> labeled worked examples can further improve learners performance in problem solving in a computer-based learning environment (e.g. online learning) without personal interaction with an instructor. [...] <b>Subgoal</b> labels can be used in different important areas such as teaching and learning novel problem solving, in training teachers to teach technical subjects (e.g. teaching computer programming), multi agent programming, professional development, online learning and other types of lifelong learning (e.g. <b>Subgoal</b> labeled instruction material helped novices to program in App Inventor for Android).|$|E
5000|$|... {{there are}} two {{candidate}} solutions, which solve the first <b>subgoal</b> bird(X), namely X = john and X = mary. The second <b>subgoal</b> not abnormal(john) of the first candidate solution fails, because wounded(john) succeeds and therefore abnormal(john) succeeds. However, The second <b>subgoal</b> not abnormal(mary) of the second candidate solution succeeds, because wounded(mary) fails and therefore abnormal(mary) fails. Therefore, X = mary is the only solution of the goal.|$|E
40|$|Abstract—The {{standard}} {{reinforcement learning}} methods {{do not scale}} up well for complex tasks and {{a solution to this}} drawback is to decompose a learning task into a set of <b>subgoals,</b> develop some skills based on the identified <b>subgoals</b> and then utilize the learnt skills. In this paper we propose a new approach for automatically identifying and evaluating <b>subgoals</b> based on bridgeness centrality measure. Investigating three benchmark problems, it is shown that how the proposed steps can significantly improve the learning performance of the agent...|$|R
40|$|We {{describe}} {{a new technique}} for designing more accurate admissible heuristic evaluation functions, based on pattern databases [1]. While many heuristics, such as Manhattan distance, compute the cost of solving individual <b>subgoals</b> independently, pattern databases consider the cost of solving multiple <b>subgoals</b> simultaneously. Existing work on pattern databases allows combining values from di erent pattern databases by taking their maximum. If the <b>subgoals</b> {{can be divided into}} disjoint subsets so that each operator only a ects <b>subgoals</b> in one subset, then we can add the pattern-database values for each subset, resulting in a more accurate admissible heuristic function. We used this technique to improve performance on the Fifteen Puzzle by a factor of over 2000, and to nd optimal solutions to 50 random instances of the Twenty-Four Puzzle. 1...|$|R
40|$|An {{ability to}} adjust to {{changing}} environments and unforeseen circumstances {{is likely to be}} an important component of a successful autonomous space robot. This paper shows how to augment reinforcement learning algorithms with a method for automatically discovering certain types of <b>subgoals</b> online. By creating useful new <b>subgoals</b> while learning, the agent is able to accelerate learning on a current task and to transfer its expertise to related tasks through the reuse of its ability to attain <b>subgoals.</b> <b>Subgoals</b> are created based on commonalities across multiple paths to a solution. We cast the task of finding these commonalities as a multiple-instance learning problem and use the concept of diverse density to find solutions. We introduced this approach in [10] and here we present additional results for a simulated mobile robot task. ...|$|R
5000|$|<b>Subgoal</b> {{labeling}} {{is giving}} {{a name to}} a group of steps, in a [...] description of a , to explain how the group of steps achieve a related <b>subgoal.</b> This concept is used in the fields of cognitive science and educational psychology.|$|E
50|$|In a team, {{each member}} has a <b>subgoal</b> {{pertinent}} to his/her specific role that feeds into the overall team goal. Associated with each member's <b>subgoal</b> are {{a set of}} SA elements about which he/she is concerned. Team SA, therefore, can be represented as shown in Figure 2. As {{the members of a}} team are essentially interdependent in meeting the overall team goal, some overlap between each member's <b>subgoal</b> and their SA requirements will be present. It is this subset of information that constitutes much of team coordination. That coordination may occur as a verbal exchange, a duplication of displayed information, or by some other means.|$|E
5000|$|Check if 5 {{minutes is}} up—wait a while—recheck if 5 minutes is up—exit (ie [...] "leave a while" [...] <b>subgoal</b> is achieved) ...|$|E
40|$|AbstractWe {{describe}} {{a new technique}} for designing more accurate admissible heuristic evaluation functions, based on pattern databases [J. Culberson, J. Schaeffer, Comput. Intelligence 14 (3) (1998) 318 – 334]. While many heuristics, such as Manhattan distance, compute the cost of solving individual <b>subgoals</b> independently, pattern databases consider the cost of solving multiple <b>subgoals</b> simultaneously. Existing work on pattern databases allows combining values from different pattern databases by taking their maximum. If the <b>subgoals</b> {{can be divided into}} disjoint subsets so that each operator only affects <b>subgoals</b> in one subset, then we can add the pattern-database values for each subset, resulting in a more accurate admissible heuristic function. We used this technique to improve performance on the Fifteen Puzzle by a factor of over 2000, and to find optimal solutions to 50 random instances of the Twenty-Four Puzzle...|$|R
40|$|This paper {{attempts}} {{to develop a}} multiobjective model to help policy-makers choose the most appropriate mix of economic policies concurrent with the elimination of serious gaps. Each individual policy {{attempts to}} achieve a specific goal or a set of subgoals; but it may hinder the achievement of some other <b>subgoals.</b> To differentiate between the importance of different objectives, the analyst assigns different priorities {{to each of the}} given set of <b>subgoals.</b> Three sets of results are provided by three separate computer runs of this model. Each set of results corresponds to one of the three priority structures, and each run indicates quite differing underachievements or over-achievements of individual <b>subgoals.</b> A detailed explanation for each of these deviations (gaps) from the targeted <b>subgoals</b> is attempted in an overall framework and some interactions between various gaps (savings gaps, foreign exchange gap, domestic growth gap, GNP gap, etc.) are also identified. ...|$|R
40|$|Part 4 : Software Platforms and EvaluationInternational audienceInter-organizational {{collaboration}} {{in the public}} sphere is essentially important to address sustainability problems in contemporary regional societies. To facilitate public collaboration, we are developing a Web application for sharing public issues and their solutions as public goals. Since participating in abstract or general goals is more difficult than concrete or specific ones, our system provides a functionality to break down individual public goals into concrete <b>subgoals.</b> Our Web application, GoalShare, is based on a linked open dataset of public goals that are linked with titles, participants, <b>subgoals,</b> related issues, related articles, and related geographic regions. GoalShare recommends public goals and users on the basis of similarity calculations taking into account not only surficial and semantic features but also contextual features extracted from <b>subgoals</b> and supergoals. We conducted experiments to investigate the effects of contextual features in <b>subgoals</b> and supergoals. Moreover, we conducted a trial workshop with GoalShare in Ogaki city to improve system design through actual use...|$|R
5000|$|Given this program, {{the query}} [...] will succeed, because the program {{includes}} [...] as a fact; the query [...] will fail, {{because it does}} not occur in the head of any of the rules. The query [...] will fail also, because the only rule with [...] in the head contains the <b>subgoal</b> [...] in its body; as we have seen, that <b>subgoal</b> fails. Finally, the query [...] succeeds, because each of the subgoals , [...] succeeds. (The latter succeeds because the corresponding positive goal [...] fails.) To sum up, the behavior of SLDNF resolution on the given program can be represented by the following truth assignment: ...|$|E
50|$|In {{the more}} general case, where {{sub-goals}} share variables, other strategies can be used, such as choosing the <b>subgoal</b> that is most highly instantiated or that is sufficiently instantiated so that only one procedure applies. Such strategies are used, for example, in concurrent logic programming.|$|E
50|$|Declarative {{programming}} languages {{describe what}} computation {{should be performed}} and not how to compute it. Declarative programs omit the control flow and are considered sets of instructions. Two broad categories of declarative languages are functional languages and logical languages. The principle behind functional languages (like Haskell) is to not allow side effects, which {{makes it easier to}} reason about programs like mathematical functions. The principle behind logical languages (like Prolog) is to define the problem to be solved - the goal - and leave the detailed solution to the Prolog system itself. The goal is defined by providing a list of subgoals. Then each <b>subgoal</b> is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that <b>subgoal</b> is backtracked and another path is systematically attempted.|$|E
40|$|The paper {{introduces}} {{an approach}} to derive a total ordering between increasing sets of <b>subgoals</b> by defining a relation over atomic goals. The ordering is represented in a so-called goal agenda {{that is used by}} the planner to incrementally plan for the increasing sets of <b>subgoals.</b> This can lead to an exponential complexity reduction because the solution to a complex planning problem is found by solving easier subproblems. Since only a polynomial overhead is caused by the goal agenda computation, a potential exists to dramatically speed up planning algorithms as we demonstrate in the empirical evaluation. Introduction How to effectively plan for interdependent <b>subgoals</b> has been in the focus of AI planning research {{for a very long time}} (Chapman 1987). But until today planners have made only some progress to solve larger sets of <b>subgoals</b> and scalability of classical planning systems is still a problem. Previous approaches fell into two categories: On one hand, one can focus on [...] ...|$|R
5000|$|HRAI is {{organized}} into several departments, each with responsibility over specific <b>subgoals</b> of the organization: ...|$|R
40|$|This paper {{describes}} {{a method for}} hierarchical reinforcement learning in which high-level policies automatically discover <b>subgoals,</b> and low-level policies learn to specialize for different <b>subgoals.</b> <b>Subgoals</b> are represented as desired abstract observations which cluster raw input data. High-level value functions cover the state space at a coarse level; low-level value functions cover only {{parts of the state}} space at a fine-grained level. An experiment shows that this method outperforms several flat reinforcement learning methods. A second experiment shows how problems of partial observability due to observation abstraction can be overcome using high-level policies with memory. Key words Reinforcement learning, hierarchical reinforcement learning, feedforward neural networks, recurrent neural networks, MDPs, POMDPs, short-term memory...|$|R
50|$|Partial-order {{planning}} {{is the opposite}} of total-order planning, in which actions are sequenced all at once and for the entirety of the task at hand. The question arises when one has two competing processes, which one is better? Anthony Barret and Daniel Weld have argued in their 1993 book, that partial-order {{planning is}} superior to total-order planning, as it is faster and thus more efficient. They tested this theory using Korf’s taxonomy of <b>subgoal</b> collections, in which they found that partial-order planning performs better because it produces more trivial serializability than total-order planning. Trivial serializability facilitates a planner’s ability to perform quickly when dealing with goals that contain subgoals. Planners perform more slowly when dealing with laboriously serializable or nonserializable subgoals. The determining factor that makes a <b>subgoal</b> trivially or laboriously serializable is the search space of different plans. They found that partial-order planning is more adept at finding the quickest path, and is therefore the more efficient of these two main types of planning.|$|E
5000|$|While the {{ultimate}} goals of superintelligences can vary greatly, a functional superintelligence will spontaneously generate, as natural subgoals, [...] "instrumental goals" [...] such as self-preservation and goal-content integrity, cognitive enhancement, and resource acquisition. For example, an agent whose sole final {{goal is to}} solve the Riemann hypothesis (a famous unsolved, mathematical conjecture) could create, and act upon, a <b>subgoal</b> of transforming the entire Earth into some form of computronium (hypothetical [...] "programmable matter") {{to assist in the}} calculation. The superintelligence would proactively resist any outside attempts to turn the superintelligence off or otherwise prevent its <b>subgoal</b> completion. In order to prevent such an existential catastrophe, it might be necessary to successfully solve the [...] "AI control problem" [...] for the first superintelligence. The solution might involve instilling the superintelligence with goals that are compatible with human survival and well-being. Solving the control problem is surprisingly difficult because most goals, when translated into machine-implementable code, lead to unforeseen and undesirable consequences.|$|E
50|$|The {{earliest}} work in computerized {{knowledge representation}} {{was focused on}} general problem solvers such as the General Problem Solver (GPS) system developed by Allen Newell and Herbert A. Simon in 1959. These systems featured data structures for planning and decomposition. The system would begin with a goal. It would then decompose that goal into sub-goals and then set out to construct strategies that could accomplish each <b>subgoal.</b>|$|E
5000|$|However, noninterleaved {{planners}} typically {{separate the}} goal (stack A atop B atop C) into <b>subgoals,</b> such as: ...|$|R
50|$|The SLD {{resolution}} {{search space}} is an or-tree, in which different branches represent alternative computations. In {{the case of}} propositional logic programs, SLD can be generalised so that the search space is an and-or tree, whose nodes are labelled by single literals, representing <b>subgoals,</b> and nodes are joined either by conjunction or by disjunction. In the general case, where conjoint <b>subgoals</b> share variables, the and-or tree representation is more complicated.|$|R
40|$|Real-time {{heuristic}} search {{is a standard}} approach to pathfind-ing when agents are required to make decisions in a bounded, {{very short period of}} time. An assumption usually made in the development and evaluation of real-time algorithms is that the environment is unknown. Nevertheless, in many in-teresting applications such as pathfinding for automnomous characters in video games, the environment is known in ad-vance. Recent real-time search algorithms such as D LRTA* and kNN LRTA * exploit knowledge about the environment while pathfinding under real-time constraints. Key to those algorithms is the computation of <b>subgoals</b> in a preprocessing step. <b>Subgoals</b> are subsequently used in the online planning phase to obtain high-quality solutions. Preprocessing in those algorithms, however, requires significant computation. In this paper we propose a novel preprocessing algorithm that gener-ates <b>subgoals</b> using a series of backward search episodes car-ried out from potential goals. The result of a single backward search episode is a tree of <b>subgoals</b> that we then use while planning online. We show the advantages of our approach over state-of-the-art algorithms by carrying out experiments on standard real-time search benchmarks...|$|R
