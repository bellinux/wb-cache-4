198|155|Public
25|$|Subtract {{the partial}} product {{resulting}} from the MSB (pseudo <b>sign</b> <b>bit)</b> instead of adding it like the other partial products. This method requires the multiplicand's <b>sign</b> <b>bit</b> to be extended by one position, being preserved during the shift right actions.|$|E
25|$|The {{computer}} had 2048 {{words of}} erasable magnetic core memory and 36 kilowords of read-only core rope memory. Both had cycle times of 11.72microseconds. The memory word length was 16 bits: 15 bits {{of data and}} one odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, one overflow bit, and one <b>sign</b> <b>bit</b> (ones' complement representation).|$|E
25|$|Logarithmic number systems {{represent}} a real number by the logarithm of its absolute value and a <b>sign</b> <b>bit.</b> The value distribution {{is similar to}} floating point, but the value-to-representation curve (i.e., the graph of the logarithm function) is smooth (except at 0). Conversely to floating-point arithmetic, in a logarithmic number system multiplication, division and exponentiation are simple to implement, but addition and subtraction are complex. The level index arithmetic of Clenshaw, Olver, and Turner is a scheme based on a generalized logarithm representation.|$|E
30|$|Error tolerance: {{depends on}} the {{encryption}} algorithm used to scramble <b>sign</b> <b>bits.</b>|$|R
30|$|Cryptographic security: {{bounding}} the encryption to {{the first}} 64 <b>sign</b> <b>bits</b> is not sufficient from the security point of view. Indeed, when considering high-resolution videos with high bitrate, the first 64 ?bits represent a very {{small fraction of the}} data.|$|R
40|$|Absfmct- We {{introduce}} a redundant binary {{representation of the}} rationals and an associated algorithm for computing the sum, difference, product, quotient, and other useful functions of two rational operands, employing our representation. Our al-gorithm extends Gosper’s partial quotient arithmetic algorithm and allows the design of an on-line arithmetic unit with compu-tations granularized at the <b>signed</b> <b>bit</b> level. Each input or output port can independently be set to receivehroduce operandshesult in either binary radix or our binary rational representation. We investigate by simulation the interconnection of several such units for the parallel computation of more complicated expressions in a tree-pipelined manner, with particular regards to measuring individual and compounded on-line delays. Index Terms- Arithmetic unit, continued fraction, fine grained parallelism, on-line, radix, redundancy, <b>signed</b> <b>bit.</b> I...|$|R
25|$|DV (divide): Divide the {{contents}} of register A by the data at the referenced memory address. Store the quotient in register A and the absolute value of the remainder in register Q. Unlike modern machines, fixed-point numbers were treated as fractions (notional decimal point just to right of the <b>sign</b> <b>bit),</b> so you could produce garbage if the divisor was not larger than the dividend; there was no protection against that situation. In the Block II AGC, a double-precision dividend started in A and L (the Block II LP), and the correctly signed remainder was delivered in L. That considerably simplified the subroutine for double precision division.|$|E
25|$|TS (transfer to storage): Store {{register}} A at {{the specified}} memory address. TS also detects, and corrects for, overflows {{in such a}} way as to propagate a carry for multi-precision add/subtract. If the result has no overflow (leftmost 2 bits of A the same), nothing special happens; if there is overflow (those 2 bits differ), the leftmost one goes the memory as the <b>sign</b> <b>bit,</b> register A is changed to +1 or −1 accordingly, and control skips to the second instruction following the TS. Whenever overflow is a possible but abnormal event, the TS was followed by a TC to the no-overflow logic; when it is a normal possibility (as in multi-precision add/subtract), the TS is followed by CAF ZERO (CAF = XCH to fixed memory) to complete the formation of the carry (+1, 0, or −1) into the next higher-precision word. Angles were kept in single precision, distances and velocities in double precision, and elapsed time in triple precision.|$|E
2500|$|The most {{significant}} bit determines {{the sign of the}} number and is sometimes called the <b>sign</b> <b>bit.</b> Unlike in sign-and-magnitude representation, the <b>sign</b> <b>bit</b> also has the weight [...] shown above. Using [...] bits, all integers from [...] to [...] can be represented.|$|E
50|$|There {{are various}} notations used to {{represent}} word length and radix point in a binary fixed-point number. In the following list, f represents the number of fractional bits, m the number of magnitude or integer bits, s the number of <b>sign</b> <b>bits,</b> and b {{the total number of}} bits.|$|R
40|$|Protecting {{video streams}} while {{incurring}} minimal {{impact on the}} compression performance {{is very important for}} practical video distribution. Selective encryption {{is one of the most}} promising techniques that can offer the required security while maintaining format compliance after encryption with no or little impact on the compression performance. Also, selective encryption techniques can be employed in video surveillance systems to alleviate concerns over privacy invasion by applying the encryption to specific regions of interest. This thesis presents advanced selective encryption techniques for a range of video applications and new methods to effectively and efficiently protect privacy 111 video surveillance systems by applying selective encryption. Background knowledge on video encryption is introduced and previous work is reviewed. Two improved video encryption methods are first demonstrated: one randomly selects one of two equivalent zig-zag scan orders for video preview applications; the other is based on encrypting the <b>sign</b> <b>bits</b> of motion vectors to enhance the scrambling effect. Then, two recently proposed fast selective encryption methods for H. 264 /AVC are analyzed to show that they are not as efficient as only encrypting the <b>sign</b> <b>bits</b> of nonzero coefficients. A tunable selective encryption scheme for H. 264 /AVC is developed to provide a tunable scrambling effect by simply adjusting three parameters, so that for different scenarios the user can easily adjust the scrambling effect according to specific requirements. Finally, to more effectively protect privacy in video surveillance systems, it is proposed to el 1 crypt intra prediction modes within regions of interest in addition to encrypting <b>sign</b> <b>bits</b> of nonzero coefficients, as only encrypting <b>sign</b> <b>bits</b> produces a relatively weak scrambling effect. A re-encoding method is presented to remove the drift error in the non-privacy region caused by the encryption. A spiral binary mask mechanism is also proposed to more efficiently signal the position of the privacy region. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
5000|$|<b>Sign</b> (1 <b>bit)</b> - Whole word (-) or Half word (+) {{operand address}} ...|$|R
2500|$|... 1|1100|0100 [...] (subtract last partial product since it's from <b>sign</b> <b>bit)</b> ...|$|E
2500|$|... |1110|0010 [...] (discard {{extended}} <b>sign</b> <b>bit,</b> {{giving the}} final answer, −30) ...|$|E
2500|$|Floating-point {{numbers are}} {{typically}} packed {{into a computer}} datum as the <b>sign</b> <b>bit,</b> the exponent field, and the significand or mantissa, from left to right. [...] For the IEEE 754 binary formats (basic and extended) which have extant hardware implementations, they are apportioned as follows: ...|$|E
40|$|A carry-free {{subtractive}} division {{algorithm is}} proposed in this paper. In the conventional subtractive divider, adders are used to find both quotient bit and partial remainder. Carries are usually generated in the addition operation, and it may take time to finish the operation, therefore, the carry propagation delay usually is a bottleneck of the conventional subtractive divider. In this paper, a carry-free scheme is proposed by using <b>signed</b> <b>bit</b> representation to represent both quotient and partial remainder. During the arithmetic operation, a special technique is used to decide the quotient bit, and the new partial remainder can be found further by a table lookup-like method. The <b>signed</b> <b>bit</b> format of the quotient can be converted by on-the-fly conversion to the binary representation. Based on this algorithm a 32 -b/ 32 -b divider is designed and implemented, and the simulation shows that the divider works well. Key Words: Divider, radix- 2, quotient bit, partial remainder, carry propagation delay, high speed, Svobota-Tung divisio...|$|R
40|$|A Chord [13] network, {{used for}} an {{implementation}} of a distributed dictionary, is structured as a ring of nodes with connections at offsets of powers of base two around the ring. We consider routing algorithms for a bidirectional variant of Chord networks and show that the structure of optimal routes in these networks is exactly characterized by their specification as <b>signed</b> <b>bit</b> representations of integers. We determine optimal routes using a simple rewrite system over these route specifications and thus exactly characterize minimal <b>signed</b> <b>bit</b> representations. We give an algorithm to determine an optimal route from the ring offset between the route’s source and destination. We extend our rewrite system approach to study optimal routing in networks for bases greater than two, generalizing our results to find minimal signed digit representations. Such representations provide an elegant characterization of routing for these networks, and their study has applicability to computer systems and computer arithmetic in general...|$|R
40|$|The Lott Ranch 3 D seismic {{prospect}} {{located in}} Garza County, Texas {{is a project}} initiated in September of 1991 by the J. M. Huber Corp., a petroleum exploration and production company. By today's standards the 126 square mile project does not seem monumental, however {{at the time it}} was conceived it was the most intensive land 3 D project ever attempted. Acquisition began in September of 1991 utilizing GEO-SEISMIC, INC., a seismic data contractor. The field parameters were selected by J. M. Huber, and were of a radical design. The recording instruments used were GeoCor IV amplifiers designed by Geosystems Inc., which record the data in <b>signed</b> <b>bit</b> format. It would not have been practical, if not impossible, to have processed the entire raw volume with the tools available at that time. The end result was a dataset that was thought to have little utility due to difficulties in processing the field data. In 1997, Yates Energy Corp. located in Roswell, New Mexico, formed a partnership to further develop the project. Through discussions and meetings with Pinnacle Seismic, it was determined that the original Lott Ranch 3 D volume could be vastly improved upon reprocessing. Pinnacle Seismic had shown the viability of improving field-summed <b>signed</b> <b>bit</b> data on smaller 2 D and 3 D projects. Yates contracted Pinnacle Seismic Ltd. to perform the reprocessing. This project was initiated with high resolution being a priority. Much of the potential resolution was lost through the initial summing of the field data. Modern computers that are now being utilized have tremendous speed and storage capacities that were cost prohibitive when this data was initially processed. Software updates and capabilities offer a variety of quality control and statics resolution, which are pertinent to the Lott Ranch project. The reprocessing effort was very successful. The resulting processed data-set was then interpreted using modern PC-based interpretation and mapping software. Production data, log data, and scout ticket data were integrated with the 3 D interpretations to evaluate drilling opportunities resulting in an initial three well drilling program. Thousands of miles of <b>signed</b> <b>bit</b> data exist. Much of this data was processed during a time when software and hardware capabilities were either incapable or cost prohibitive to glean the full potential of the data. In fact in some circles <b>signed</b> <b>bit</b> gained an undeserved reputation for being less than optimum. As a consequence much of the older <b>signed</b> <b>bit</b> data sits on the shelf long forgotten or overlooked. With the high cost of new acquisition and permitting it might behoove other exploration companies to reconsider resurrecting perfectly viable existing volumes and have them reprocessed at a fraction of the cost of new acquisition...|$|R
2500|$|In 1938, Konrad Zuse of Berlin {{completed}} the Z1, the first binary, programmable mechanical computer; {{it uses a}} 24-bit binary floating-point number representation with a 7-bit signed exponent, a 17-bit significand (including one implicit bit), and a <b>sign</b> <b>bit.</b> The more reliable relay-based Z3, completed in 1941, has representations for {{both positive and negative}} infinities; in particular, it implements defined operations with infinity, such as , and it stops on undefined operations, such as [...]|$|E
2500|$|XCH (exchange): Exchange the {{contents}} of memory with {{the contents}} of the A register. If the specified memory address is in fixed (read-only) memory, the memory contents are not affected, and this instruction simply loads register A. If it is in erasable memory, overflow [...] "correction" [...] is achieved by storing the leftmost of the 16 bits in A as the <b>sign</b> <b>bit</b> in memory, but there is no exceptional behavior like that of TS.|$|E
2500|$|In the {{following}} table, [...] "s" [...] {{is the value}} of the <b>sign</b> <b>bit</b> (0 means positive, 1 means negative), [...] "e" [...] {{is the value of}} the exponent field interpreted as a positive integer, and [...] "m" [...] is the significand interpreted as a positive binary number where the binary point is located between bits 63 and 62. [...] The [...] "m" [...] field is the combination of the integer and fraction parts in the above diagram.|$|E
25|$|Here, XS and YS {{represent}} the <b>sign</b> <b>bits</b> {{of the movement}} vectors, XV and YV indicate an overflow in the respective vector component, and LB, MB and RB indicate {{the status of the}} left, middle and right mouse buttons (1 = pressed). PS/2 mice also understand several commands for reset and self-test, switching between different operating modes, and changing the resolution of the reported motion vectors.|$|R
30|$|Therefore, the {{recorded}} greatest absolute number is 748. However, since the correlation coefficient is <b>signed,</b> 11 <b>bits</b> {{are required to}} represent the integer part as 1 bit {{is used for the}} <b>sign</b> and 10 <b>bits</b> determine the value. Subsequently, the range of numbers represented by 11 bits is [−[*] 1024, 1024].|$|R
40|$|In this work, {{an attempt}} {{is made to}} analyze four fast MPEG video {{encryption}} algorithms. These algorithms use a secret key randomly changing the <b>sign</b> <b>bits</b> of DCT coefficients and/or the <b>sign</b> <b>bits</b> of motion vectors. The encryption effects are achieved by the IDCT during MPEG video decompression processing. These algorithms add very small overhead to MPEG codec. Software implementations are fast enough to meet the real time requirement of MPEG video applications and thus the analysis shows that satisfactory results can be obtained using these video encryption algorithms. The experiments conducted helped us analyze two points. First, to test the encryption results with overheads added to MPEG codec and second, encoding time with varying key lengths. We believe that these experiments will produce satisfactory results and thus help to know the efficiency and application of such algorithms in the real world. And will also {{give us a chance}} to analyze the drawbacks in the existing algorithms so that certain modification may be suggested for getting fast and better security...|$|R
2500|$|On {{a typical}} {{computer}} system, a 'double precision' (64-bit) binary floating-point number has a coefficient of 53 bits (one {{of which is}} implied), an exponent of 11 bits, and one <b>sign</b> <b>bit.</b> [...] Positive floating-point numbers in this format have an approximate range of 10−308 to 10308, because {{the range of the}} exponent is [...] and 308 is approximately log10(21023). [...] The complete range of the format is from about −10308 through +10308 (see IEEE 754).|$|E
2500|$|As {{an example}} of the second method, take the common add-and-shift {{algorithm}} for multiplication. Instead of shifting partial products to the left as is done with pencil and paper, the accumulated product is shifted right, into a second register that will eventually hold the least significant half of the product. Since the least significant bits are not changed once they are calculated, the additions can be single precision, accumulating in the register that will eventually hold the most significant half of the product. In the following example, again multiplying 6 by 5, the two registers and the extended <b>sign</b> <b>bit</b> are separated by [...] "|": ...|$|E
2500|$|Fundamentally, {{the system}} {{represents}} negative integers by counting backward and wrapping around. The boundary between {{positive and negative}} numbers is arbitrary, but by convention all negative numbers have a left-most bit (most significant bit) of one. Therefore, the most positive 4-bit number is 0111 (7) and the most negative is 1000 (8). Because {{of the use of}} the left-most bit as the <b>sign</b> <b>bit,</b> the absolute value of the most negative number (|8| = 8) is too large to represent. For example, an 8-bit number can only represent every integer from 128 to 127 (...) inclusive. Negating a two's complement number is simple: Invert all the bits and add one to the result. For example, negating 1111, we get 0000+1=1. Therefore, 1111 must represent 1.|$|E
40|$|Abstract — This {{article focuses}} on the <b>bit</b> <b>sign</b> {{transition}} {{and its impact on}} the acquisition performance in terms of probability of detection. To do so, a theoretical study on the correlation process considering <b>bit</b> <b>sign</b> transition is done leading to the expression of the probability of detection, expressed in function of the bit transition location. Based on this, Monte-Carlo simulations were run to determine the acquisition performance degradations in terms of sensitivity losses and probability of detection for several GNSS civil signals. This allows determining the optimal acquisition parameters when <b>bit</b> <b>sign</b> transitions are considered during the acquisition process. Keywords—Acquisition; <b>Bit</b> <b>sign</b> transition; Probability of detectio...|$|R
5000|$|Integer: EXPRESS {{integers}} {{can have}} in principle any length, but most implementations restricted {{them to a}} <b>signed</b> 32 <b>bit</b> value.|$|R
40|$|The {{literature}} on {{foreign direct investment}} (FDI) has paid an increasing interest to international institutions such as bilateral investment treaties (BITs), but whether BITs help attract FDI is an unsettled question. Building on the exist¬ing literature, this article argues that BITs can change investors’ perceptions and the corresponding investment they make because <b>signing</b> <b>BITs</b> signals the involvement of another powerful country that is able to compel the host government to comply. This implies {{that the effect of}} BITs is not constant across signatory countries: BITs are more effective when they are signed with rich and influential countries. Using monadic and dyadic FDI data, this article finds that <b>BITs</b> <b>signed</b> with powerful countries (defined as the top six largest economies) lead to an increase in FDI inflows (both from these signatory countries and from other countries). <b>BITs</b> <b>signed</b> with other countries, despite in a larger quantity, have little influence on FDI inflows...|$|R
2500|$|The {{architecture}} of the MPACT! media processor was distinguished in that it used a large addressable SRAM in place of registers, but had 4 special purpose registers {{for being able to}} address its 72 bit SRAM entries indirectly (a feature also seen in Intel's Itanium processor). [...] By being based on 9 bit bytes instead of 8 bit bytes, this was the equivalent of adding a <b>sign</b> <b>bit</b> to each byte which is very useful for MPEG decoding. [...] One of the founders was also a founder of RAMBUS, and not surprisingly, the MPACT used RDRAM as its memory technology. [...] The chip could DMA data into contiguous SRAM entries asynchronously with other ALU operations which made the design very parallel and able to absorb the long latencies of RAMBUS's RDRAM while sustaining high throughput.|$|E
5000|$|... s 11110 x ±Infinity (see Extended {{real number}} line) s 11111 0 quiet NaN (<b>sign</b> <b>bit</b> ignored) s 11111 1 {{signaling}} NaN (<b>sign</b> <b>bit</b> ignored) ...|$|E
50|$|One {{convention}} {{includes the}} <b>sign</b> <b>bit</b> {{in the value}} of m, and the other convention does not. The choice of convention can be determined by summing m+n. If the value is equal to the register size, then the <b>sign</b> <b>bit</b> is included {{in the value of}} m. If it is one less than the register size, the <b>sign</b> <b>bit</b> is not included in the value of m.|$|E
50|$|Invoke {{components}} have a <b>signed</b> 7 <b>bit</b> InvokeID {{which is}} present in all the other components to identify which invoke they relate to.|$|R
40|$|The next {{generation}} of Global Navigation Satellite Systems (GNSS), such as Galileo [1] and GPS modernization [2], will use signals with equal code and bit periods, which will introduce a potential <b>bit</b> <b>sign</b> transition in each segment of the received signal processed in the acquisition block. The presence of <b>bit</b> <b>sign</b> transitions in the data record is a critical aspect in all the acquisition methods where the data are processed in blocks, like the fast acquisition method based on Fast Fourier Transformation (FFT) where the <b>bit</b> <b>sign</b> transition could occur in any position within the data block. A <b>bit</b> <b>sign</b> transition occurring within an integration time causes a splitting of the main peak of the Cross Ambiguity Function (CAF) into two smaller lobes along the Doppler shift axis, which causes a great performance degradation of the acquisition system [3]. In this paper an innovative two steps acquisition algorithm is proposed to mitigate the CAF peak splitting effect caused {{by the presence of}} <b>bit</b> <b>sign</b> transitions in the signal segments, which fits the requirements of the new generation of GNSS signals. The <b>bit</b> <b>sign</b> transition problem is described in detail in this paper and the CAF peak splitting effect dependent on the <b>bit</b> <b>sign</b> transition position in the signal segment is also clearly explained. It is able to prove that the presence of <b>bit</b> <b>sign</b> transition does not destroy the information on the presence of the satellite in view, but it introduces an erroneous Doppler frequency shift estimation. When the proposed two steps acquisition technique is adopted in the signal acquisition in presence of <b>bit</b> <b>sign</b> transitions, it could overcome the CAF peak splitting effect due to the presence of <b>bit</b> <b>sign</b> transitions and provide improved performance in comparison with the classical fast acquisition scheme. In order to validate the proposed technique, simulation campaigns have been performed on the simulated Galileo Open Service (OS) BOC 1, 1 signals to evaluate the performances in terms of histograms of the estimated Doppler shift and code phase delay, Receiver Operative Characteristics (ROC) and Signal to Noise Ratio (SNR) curves. The simulation results show that the proposed two steps acquisition method provides superior performance over the classical fast acquisition approach, which prove the advantages of the proposed technique and consolidate its validity and effectiveness to solve the CAF peak splitting problem in presence of <b>bit</b> <b>sign</b> transition...|$|R
30|$|Cryptographic security: {{the first}} version of VEA [12] is only secure if the secret key is used once. Otherwise, knowing one {{plaintext}} and the corresponding ciphertext, the secret key can be computed by XORing the DCT <b>sign</b> <b>bits.</b> Both versions of VEA are vulnerable to chosen plaintext attacks; in [12], it is feasible to create a repetitive/periodic pattern and then compute its inverse DCT. The encryption of the image obtained will allow us to get the key length and even compute the secret key by chosen-plaintext attack.|$|R
