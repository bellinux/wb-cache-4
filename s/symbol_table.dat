191|140|Public
25|$|Most modern {{operating}} systems can have shared library {{files of the}} same format as the executable files. This offers two main advantages: first, it requires making only one loader for both of them, rather than two (having the single loader is considered well worth its added complexity). Secondly, it allows the executables also {{to be used as}} shared libraries, if they have a <b>symbol</b> <b>table.</b> Typical combined executable and shared library formats are ELF and Mach-O (both in Unix) and PE (Windows).|$|E
2500|$|System V ar {{uses the}} special {{filename}} [...] "/" [...] to denote {{that the following}} data entry contains a symbol lookup table, which is used in ar libraries to speed up access. [...] This <b>symbol</b> <b>table</b> is built in three parts which are recorded together as contiguous data.|$|E
2500|$|Assembly directives, {{also called}} pseudo-opcodes, pseudo-operations or pseudo-ops, are {{commands}} given to an assembler [...] "directing it to perform operations other than assembling instructions.". Directives affect how the assembler operates and [...] "may affect the object code, the <b>symbol</b> <b>table,</b> the listing file, {{and the values}} of internal assembler parameters." [...] Sometimes the term pseudo-opcode is reserved for directives that generate object code, {{such as those that}} generate data.|$|E
5000|$|Run-time {{environment}} (including parameter passing, <b>symbol</b> <b>tables</b> and register allocation) ...|$|R
50|$|The rod of Asclepius has a {{representation}} on the Miscellaneous <b>Symbols</b> <b>table</b> of the Unicode Standard at U+2695 (⚕).|$|R
40|$|Even {{the most}} {{advanced}} reverse engineering techniques and products are weak in recovering data structures in stripped binaries—binaries without <b>symbol</b> <b>tables.</b> Unfortunately, forensics and reverse engineering without data structures is exceedingly hard. We present a new solution, knownasHoward,toextractdatastructuresfromCbinaries without any need for <b>symbol</b> <b>tables.</b> Our results are significantlymoreaccuratethanthoseofpreviousmethods—sufficientlysotoallowustogenerateourown(partial) symbol tableswithoutaccesstosourcecode. Thus,debuggingsuch binariesbecomesfeasibleandreverseengineeringbecomes simpler. Also,weshowthatwecanprotectexistingbinaries from popular memory corruption attacks, without access to sourcecode. Unlikemostexistingtools,oursystemusesdynamic analysis (on a QEMU-based emulator) and detects data structuresby tracking how aprogram uses memory. 1...|$|R
5000|$|A typeglob {{value is}} a <b>symbol</b> <b>table</b> entry. The main use of typeglobs is {{creating}} <b>symbol</b> <b>table</b> aliases. For example: ...|$|E
5000|$|A {{compiler}} for {{a language}} such as C creates a spaghetti stack as it opens and closes symbol tables representing block scopes. When a new block scope is opened, a <b>symbol</b> <b>table</b> is pushed onto a stack. When the closing curly brace is encountered, the scope is {{closed and the}} <b>symbol</b> <b>table</b> is popped. But that <b>symbol</b> <b>table</b> is remembered, rather than destroyed. And of course it remembers its higher level [...] "parent" [...] <b>symbol</b> <b>table</b> and so on. Thus when the compiler is later performing translations over the abstract syntax tree, for any given expression, it can fetch the <b>symbol</b> <b>table</b> representing that expression's environment and can resolve references to identifiers. If the expression refers to a variable X, it is first sought after in the leaf <b>symbol</b> <b>table</b> representing the inner-most lexical scope, then in the parent and so on.|$|E
50|$|Numerous data {{structures}} {{are available for}} implementing tables. Trees, linear lists and self-organizing lists can all be used to implement a <b>symbol</b> <b>table.</b> The <b>symbol</b> <b>table</b> is accessed by most phases of a compiler, beginning with lexical analysis, and continuing through optimization.|$|E
50|$|In {{addition}} to performing semantic analysis {{at this stage}} of compilation, often <b>symbol</b> <b>tables</b> are created in order to assist in code generation.|$|R
5000|$|A {{common data}} {{structure}} used to implement <b>symbol</b> <b>tables</b> is the hash table. It also simplifies {{the classification of}} literals in tabular format.|$|R
40|$|Even {{the most}} {{advanced}} reverse engineering techniques and products are weak in recovering data structures in stripped binaries—binaries without <b>symbol</b> <b>tables.</b> Unfortunately, forensics and reverse engineering without data structures is exceedingly hard. We present a new solution, known as Howard, to extract data structures from C binaries without any need for <b>symbol</b> <b>tables.</b> Our results are significantly more accurate than those of previous methods — sufficiently so {{to allow us to}} generate our own (partial) <b>symbol</b> <b>tables</b> without access to source code. Thus, debugging such binaries becomes feasible and reverse engineering becomes simpler. Also, we show that we can protect existing binaries from popular memory corruption attacks, without access to source code. Unlike most existing tools, our system uses dynamic analysis (on a QEMU-based emulator) and detects data structures by tracking how a program uses memory. 1...|$|R
5000|$|... #Caption: <b>Symbol</b> <b>table</b> for non-verbal {{communication}} with patients ...|$|E
50|$|The lexical {{analyser}} {{spends a}} great proportion {{of its time}} looking up the <b>symbol</b> <b>table,</b> this activity has a crucial effect on the overall speed of the computer. A <b>symbol</b> <b>table</b> must be organised {{in such a way}} that entries can be found as quick as possible. Hash tables are used to organise a <b>symbol</b> <b>table,</b> where the keyword or identifier is 'hashed' to produce an array subscript. Collisions are inevitable in a hash table, and a common way of handling them is to store the synonym in the next available free space in the table.|$|E
50|$|While reverse {{engineering}} an executable, many tools {{refer to the}} <b>symbol</b> <b>table</b> to check what addresses have been assigned to global variables and known functions. If the <b>symbol</b> <b>table</b> has been stripped or cleaned out before being converted into an executable, tools will find it harder to determine addresses or understand anything about the program.|$|E
50|$|Radix-50 (called Radix 508 format) {{was used}} in Digital's 18-bit PDP-9 and PDP-15 {{computers}} to store <b>symbols</b> in <b>symbol</b> <b>tables,</b> leaving two extra bits per word ("symbol classification bits").|$|R
50|$|Radix-50 in 36-bit systems was {{commonly}} used in <b>symbol</b> <b>tables</b> for assemblers or compilers which supported six-character symbol names. This left four bits to encode properties of the symbol.|$|R
50|$|The Unicode {{character}} set has a character ☩, U+2629 CROSS OF JERUSALEM in the Miscellaneous <b>Symbols</b> <b>table.</b> However, the glyph {{associated with that}} character according to the official Unicode character sheet is shown as a simple cross potent, and not a Jerusalem cross.|$|R
50|$|Symbolic {{names are}} stored in the COFF <b>symbol</b> <b>table.</b> Each <b>symbol</b> <b>table</b> entry {{includes}} a name, storage class, type, value and section number. Short names (8 characters or fewer) are stored directly in the symbol table; longer names are stored as an offset into the string table {{at the end of}} the COFF object.|$|E
5000|$|In Linux, the System.map file is a <b>symbol</b> <b>table</b> {{used by the}} kernel.|$|E
5000|$|A C {{compiler}} that parses {{this code}} will contain {{at least the}} following <b>symbol</b> <b>table</b> entries: ...|$|E
50|$|The Python {{programming}} language includes extensive support for creating and manipulating <b>symbol</b> <b>tables.</b> Properties {{that can be}} queried include whether a given symbol is a free variable or a bound variable, whether it is block scope or global scope, whether it is imported, and what namespace it belongs to.|$|R
50|$|The AST is used intensively during {{semantic}} analysis, {{where the}} compiler checks for correct {{usage of the}} elements of the program and the language. The compiler also generates <b>symbol</b> <b>tables</b> based on the AST during semantic analysis. A complete traversal of the tree allows verification of the correctness of the program.|$|R
40|$|Our native Java {{compiler}} directly generates runtime {{structures in}} a persistent Distributed Shared Memory (DSM). The compiler {{has been used}} to build a general purpose PC Operating System (OS) on top of a persistent DSM memory. The persistent DSM operating environment lends itself naturally to an integration of <b>symbol</b> <b>tables,</b> class descriptors and naming during Java program compilation and execution...|$|R
50|$|A {{compiler}} may use {{one large}} <b>symbol</b> <b>table</b> for all symbols or use separated, hierarchical symbol tables for different scopes.|$|E
50|$|UNIX allow programmers {{to access}} the global <b>symbol</b> <b>table,</b> which {{includes}} both the main executable and subsequently loaded dynamic libraries.|$|E
50|$|A {{debugger}} {{can use a}} <b>symbol</b> <b>table,</b> if one exists, to {{help the}} programmer interpret dumps, identifying variables symbolically and displaying source code; if the <b>symbol</b> <b>table</b> is not available, less interpretation of the dump is possible, but there might still be enough possible to {{determine the cause of}} the problem. There are also special-purpose tools called dump analyzers to analyze dumps. One popular tool, available on many operating systems, is the GNU binutils' objdump.|$|E
50|$|The ROSE IR {{consists}} of an abstract syntax tree, <b>symbol</b> <b>tables,</b> control flow graph, etc. It is an object-oriented IR with several levels of interfaces for quickly building source-to-source translators. All information from the input source code is carefully preserved in the ROSE IR, including C preprocessor control structure, source comments, source position information, and C++ template information, e.g., template arguments.|$|R
40|$|This paper {{describes}} {{the design of}} a nub interface for debugging, a target-independent implementation of this interface for cdb, and the implementation of cdb itself. When compared to platform-specific debuggers, cdb's implementation is minuscule: the nub, debugger, and associated communications routines take about 1500 lines of C, and fewer than 600 lines were added to lcc's front end to emit <b>symbol</b> <b>tables</b> and breakpoint hooks. All this code is machine independent...|$|R
40|$|Program {{language}} structures, translation, loading, execution, {{and storage}} allocation; compilation of simple expressions and statements; organization of compiler including compile-time and run-time <b>symbol</b> <b>tables,</b> lexical scan, syntax scan, object code generation, error diagnostics, object code optimization techniques, and overall design; use of compiler writing languages and bootstrapping. Prerequisite According {{to the course}} listing, the prerequisites are: CSC 4101 or equivalent. Credit will not be given for both this course and CSC 7001. Office Hour...|$|R
50|$|DynamoRIO {{contains}} libraries {{that extend}} its API to provide <b>symbol</b> <b>table</b> access, function wrapping and replacing, and memory address tracing utilities.|$|E
50|$|It uses an {{intermediate}} representation (IR), {{that is based}} on the encoded abstract syntax tree and <b>symbol</b> <b>table</b> of a program.|$|E
50|$|At {{that time}} of {{accessing}} variables and allocating memory dynamically, a compiler should perform many works and as such the extended stack model requires the <b>symbol</b> <b>table.</b>|$|E
5000|$|... "IDC scripts" [...] make it {{possible}} to extend the operation of the disassembler. Some helpful scripts are provided, which can {{serve as the basis for}} user written scripts. Most frequently scripts are used for extra modification of the generated code. For example, external <b>symbol</b> <b>tables</b> can be loaded thereby using the function names of the original source code. There are websites devoted to IDA scripts and offer assistance for frequently arising problems.|$|R
5000|$|Cfront was the {{original}} compiler for C++ (then known as [...] "C with Classes") from around 1983, which converted C++ to C; developed by Bjarne Stroustrup. The preprocessor did not understand all of the language {{and much of the}} code was written via translations. Cfront had a complete parser, built <b>symbol</b> <b>tables,</b> and built a tree for each class, function, etc. Cfront was based on CPre (C with classes compiler, which was started in 1979).|$|R
40|$|This paper {{introduces}} a rather general technique for computing the average-case performance of dynamic data structures, subjected to arbitrary sequences of insert, delete, and search operations. The method allows us effectively {{to evaluate the}} integrated cost of various interesting data structure implementations, for stacks, dictionaries, <b>symbol</b> <b>tables,</b> priority queues, and linear lists; it can thus {{be used as a}} basis for measuring the efficiency of each proposed implementation. For each data type, a specific continued fraction and a family of orthogonal polynomials are associated with sequences of operations: Tchebycheff for stacks, Laguerre for dictionaries, Charlier for <b>symbol</b> <b>tables,</b> Hermite for priority queues, and Meixner for linear lists. Our main result is an explicit expression, for each of the above data types, of the generating function for integrated costs, as a linear integral transform of the generating functions for individual operation costs. We use the result to compute explicitly integrated costs of various implementations of dictionaries and priority queues. 1. I~R~DUCTION The {{purpose of this paper is}} to describe a rather general technique for computing the average cost of a sequence of operations, which is applica-ble to many of the interesting known implementations of data structures in computer science...|$|R
