38|63|Public
5000|$|Akamai is {{the first}} major CDN to support HTTP/2 and HTTP/2 <b>Server</b> <b>Push.</b> http2.akamai.com showcases Akamai's HTTP/2 implementation, {{including}} <b>Server</b> <b>Push.</b>|$|E
50|$|HTTP <b>server</b> <b>push</b> (also {{known as}} HTTP streaming) is a {{mechanism}} for sending unsolicited (asynchronous) data from a web server to a web browser. HTTP <b>server</b> <b>push</b> can be achieved through any of several mechanisms.|$|E
5000|$|<b>Server</b> <b>Push</b> - Provides {{functionality}} of OMA Push {{delivery to}} Web Applications {{running in the}} widget context.|$|E
5000|$|There are {{two methods}} of IaC: [...] 'Push' [...] and [...] 'Pull' [...] The main {{difference}} is {{the manner in which}} the servers are told how to be configured. In the Pull method the server to be configured will pull its configuration from the controlling <b>server.</b> In the <b>Push</b> method the controlling <b>server</b> <b>pushes</b> the configuration to the destination system.|$|R
5000|$|Pull coding or {{client pull}} is {{a style of}} network {{communication}} where the initial request for data originates from the client, and then is responded to by the server. The reverse is known as push technology, where the <b>server</b> <b>pushes</b> data to clients.|$|R
40|$|Abstract. The {{purpose of}} this article is to design and {{implement}} a XMPP-Based C/S system in which the <b>server</b> <b>pushes</b> information to the client actively. By realizing the client to connect to the server, client registration, the client to login the server and the <b>server</b> to <b>push</b> messages to client 4 core functions through XMPP, this article accomplished the core of a push system. In addition, the use of uninterrupted heartbeat package maintains a long connection, ensuring the client and the server connection. This article has important significance on future mobile push system research...|$|R
50|$|The {{content type}} multipart/x-mixed-replace was {{developed}} {{as part of}} a technology to emulate <b>server</b> <b>push</b> and streaming over HTTP.|$|E
50|$|Cloudflare {{supports}} new web protocols, including SPDY and HTTP/2. In {{addition to}} this, Cloudflare offers support for HTTP/2 <b>Server</b> <b>Push.</b> Cloudflare also supports proxying Websockets.|$|E
5000|$|Cloudflare {{supports}} HTTP/2 using nginx with SPDY as a fallback for browsers without support, whilst maintaining all {{security and}} performance services. Cloudflare {{was the first}} major CDN to support HTTP/2 <b>Server</b> <b>Push.</b>|$|E
5000|$|Push {{services}} are {{often based on}} information preferences expressed in advance. This is called a publish/subscribe model. A client [...] "subscribes" [...] to various information [...] "channels" [...] provided by a server; whenever new content is available {{on one of those}} channels, the <b>server</b> <b>pushes</b> that information out to the client.|$|R
50|$|In {{comparison}} to most other configuration management software, cdist {{does not have}} any requirements on the target host besides SSH and a bourne shell.It requires Python 3.2 on the source host, though.cdist operates in push based approach, in which a <b>server</b> <b>pushes</b> configurations to the client and the clients do not poll for updates.|$|R
5000|$|Web caches store popular {{content on}} servers {{that have the}} {{greatest}} demand for the content requested. These shared network appliances reduce bandwidth requirements, reduce server load, and improve the client response times for content stored in the cache. Web caches are populated based on requests from users (pull caching) or based on preloaded content disseminated from content <b>servers</b> (<b>push</b> caching).|$|R
5000|$|Other: Conditional {{access control}} in AD FS; {{application}} authentication support for OpenID Connect and OAuth; full OpenGL support with RDS for VDI; Server-side support for HTTP/2, including header compression, connection multiplexing and <b>server</b> <b>push</b> ...|$|E
50|$|Push technology, or <b>server</b> <b>push,</b> is a {{style of}} Internet-based {{communication}} where the request for a given transaction is initiated by the publisher or central server. It is contrasted with pull/get, where the request for the transmission of information is initiated by the receiver or client.|$|E
50|$|In 1994, {{he became}} a {{founding}} engineer of Netscape Communications and programmed the networking code for the first versions of the Netscape web browser. He was also responsible for several browser innovations, such as HTTP cookies, the blink element, <b>server</b> <b>push</b> and client pull, HTTP proxying, and encouraging the implementation of animated GIFs into the browser. While at Netscape, {{he also was a}} founding member of the HTML working group at the W3C and was a contributing author of the HTML 3.2 specification. He is one of only six inductees in the World Wide Web Hall of Fame announced at the First International Conference on the World-Wide Web in 1994.|$|E
5000|$|Propagation: Users {{manually}} pull updates from {{a central}} <b>server,</b> or <b>push</b> changes out once the user feels they are ready.|$|R
50|$|While request-response is {{the most}} common {{client-server}} design, there are others, such as the publish-subscribe pattern. In the publish-subscribe pattern, clients register with a pub-sub server, subscribing to specified types of messages; this initial registration may be done by request-response. Thereafter, the pub-sub server forwards matching messages to the clients without any further requests: the <b>server</b> <b>pushes</b> messages to the client, rather than the client pulling messages from the server as in request-response.|$|R
50|$|The initial {{launch of}} an {{application}} {{would be important}} for the end user and the Packaging process might be optimized to achieve this. Once launched, common functions would be followed. As these functions are requested by the end user, these may be streamed in a similar manner. In this case the client is pulling the application from the stream server. Otherwise, the full application might be delivered from the server to the client in the background. In this case, the <b>server</b> <b>pushes</b> the application to the client.|$|R
40|$|Nowadays, {{web browser}} based instant {{messaging}} applications {{are becoming more}} and more popular. In these applications, the function of <b>server</b> <b>push</b> has caused lots of problems because of the shortages of HTTP protocol. HTTP Polling, HTTP Long Polling and HTTP Streaming are the most popular solutions for <b>server</b> <b>push</b> methods, and with the rapid development of HTML 5 standard and other Web technologies, WebSocket based real-time applications seem to be very promising. This paper introduces different methods of <b>server</b> <b>push,</b> and has an experiment to compare their dela ys and unnecessary connection costs. At the end of this paper, a conclusion is drawn to show the usage scenarios of different methods and have a summary for the using of <b>server</b> <b>push</b> methods in Web browser based real-time appli c ation.   </p...|$|E
40|$|In this work, I use ns- 3 {{simulations}} {{to compare}} and evaluate {{different approaches to}} web based adaptive bitrate (ABR) video streaming. In particular, I look at the difference between client pull and <b>server</b> <b>push</b> based approaches, the effects of media formatting parameters such as chunk duration and number of encoding rates, and the implementation of bandwidth estimation and request scheduling strategies. I find that client pull applications with a 2 second chunk duration are very inefficient with bandwidth compared to applications using a <b>server</b> <b>push</b> based approach. The reasons for this stem from the effect of frequent idle periods at chunk boundaries, which are absent with <b>server</b> <b>push,</b> on the behaviour of TCP. Increasing the chunk duration to 10 seconds makes a significant difference to client pull applications and allows them to perform at a level much more comparable with <b>server</b> <b>push</b> applications. I also find that ABR applications in general are vulnerable to suffering from encoding rate instability, a result that echoes findings {{from a number of}} recent studies. This problem seems to stem from the difficulty of selecting a suitable encoding rate based on transfer rates observed at the application layer. Effective remedies for encoding rate instability include ensuring that the system is not over provided for {{in terms of the number}} of available encoding rates, and using an averaging function, such as the harmonic mean, over a series of recent transfer rates in order to filter out short term fluctuations in the estimate of available bandwidth. I also show that a simple request scheduling strategy can be used to avoid over buffering and the associated problems, but that periodic request scheduling can introduce further problems related to fairness when multiple ABR flows compete. Finally, I show that a hybrid of client pull and <b>server</b> <b>push,</b> which I call pull selective, can offer a useful compromise between the two, by matching the performance characteristics of <b>server</b> <b>push</b> whilst maintaining the low server overheads and scalability attributes of client pull...|$|E
40|$|Abstract. First of all, three current <b>server</b> <b>push</b> modes are {{elaborated}} in this paper, {{including a}} detailed analysis and comparison. Due to a single <b>server</b> <b>push</b> mode {{is used by the}} current push frame, most application requirements can not be meet. Push techniques based on analytic hierarchy process is proposed in this paper, which selects optimal push mode in different situations by theory of operations research. This method not only improves server performance but also reduces server load. Finally, experimental results show that the proposed method is superior to other single mode...|$|E
40|$|We {{characterize}} the dynamic data management problem for location based services(LBS) in mobile environments and devise a cost model for servicing both location independent and location dependent data. The cost analysis {{leads to a}} set of dynamic data management strategies that employs judicious caching, proactive <b>server</b> <b>pushing</b> and neighborhood replication to reduce service cost and improve response time under changing user mobility and access patterns. Simulation results suggest that different strategies are effective for different types of data in response to different patterns of movement and information access...|$|R
40|$|Even {{though the}} AJAX {{paradigm}} helps web applications {{to become more}} responsive, AJAX alone does not provide an efficient mechanism for real-time data delivery. Use cases of applications that need such a service include stock tickers, auction sites or chat rooms. The user interface components of these applications must be kept up-to-date with the latest data from the server, and changes should be received immediately. There are two different static ap-proaches used in the industry to provide real-time data de-livery: Either the client pulls for the latest data, or the <b>server</b> <b>pushes</b> it to the client. However, such a static ap-proach is not optimal, since both techniques have their own advantages and disadvantages. In this paper we present an adaptive algorithm that combines both solutions in or-der to increase scalability, network performance and user-perceived latency. ...|$|R
5000|$|RST_STREAM frames. These {{frames are}} handy {{in a variety}} of conditions, one of them is having the browser signal to the <b>server</b> that a <b>pushed</b> stream is not needed.|$|R
30|$|The busy service {{amounts to}} a polling session, notifying the user when the {{requested}} service is available and showing a waiting message or other distraction until then. Using <b>server</b> <b>push</b> technology or websockets, the busy service server could be moved to the client instead.|$|E
40|$|Communication between servers {{and clients}} can be {{realised}} in several ways. A basic method is, when the client requests and the server responds. In case the client does not know, when the specific {{information will be}} available, it needs to ask the server in intervals. This is ineffective, and a better alternative is when the server informs the clients. Such communication is called <b>server</b> <b>push.</b> <b>Server</b> <b>push</b> was implemented with the SignalR library and with the WCF framework. Both technologies have been explored and compared. For comparison of technologies we implemented the notification of activity in revision control. In our case, we had two types of clients. The first client is an interface for managing {{the control of the}} Git revision control. It informs the server about actions, which take place over the code. The second client is a desktop application and an application for Windows Phone 8. Both applications receive notifications of activities in revision control...|$|E
40|$|The passive {{web pages}} can {{transform}} into active environment by the continuous queries arepersistent queries {{by providing the}} time varying dynamic query results useful for online decision making. Tohandle {{a large number of}} users with diverse interests a continuous query system must be capable ofsupporting <b>server</b> <b>push</b> style of Internet-based communication. A network of data aggregators has priorapproaches for the scalable handling of push based data dissemination. Their implementation requiredGreedy Heuristics Algorithm along with pre configured incoherency bounds to manage both multipleaggregators and multiple clients for supporting <b>server</b> <b>push</b> based communications. The sub-optimalsolutions are explored by existing heuristic-based approaches can only explore a limited solution space. Sowe propose to use an adaptive and cost-based approach. In a network of data aggregators, each dedicatedand judiciously chosen aggregator serves a set of data items at specific coherencies. By our approach we candecompose a client query into sub-queries and executing sub-queries using aggregators with their individualsub-query incoherency bounds. Our cost model takes into account both the processing cost and thecommunication cost unlike prior approaches. Clustering based penalty Adaptive Query Planning has betterperformance in terms of both processing and communication cost...|$|E
40|$|Conventional e-mail {{systems are}} prone to {{problems}} that affect their dependability. E-mail systems operate following a “push-based ” approach: the sender side <b>server</b> <b>pushes</b> the e-mails it wants to send to the corresponding receivers’ servers. This approach may impose processing and storage overhead on the receiver side. This paper presents a peer-to-peer e-mail system in which messages are sent directly from senders to receivers using a “pull-based ” approach. The sender stores locally all e-mails it intends to send, and notify their receivers using a global, distributed notification service. Receivers can then retrieve such notifications and decide {{if they want to}} receive the corresponding e-mails. If so, e-mails can be retrieved directly from their senders. This proposal is inspired from file sharing peer-to-peer sys-tems, in which users locate and retrieve the contents they are looking for. A prototype was built to show the feasibility of the proposal, and experimental results show its viability. ...|$|R
40|$|Preprint {{of paper}} {{published}} in: AEWSE 2008 - Proceedings of the Third International Workshop on Adaptation and Evolution in Web Systems Engineering, 16 July 2008 Even though the AJAX paradigm helps web applications {{to become more}} responsive, AJAX alone does not provide an efficient mechanism for real-time data delivery. Use cases of applications that need such a service include stock tickers, auction sites or chat rooms. The user interface components of these applications must be kept up-to-date with the latest data from the server, and changes should be received immediately. There are two different static approaches used in the industry to provide real-time data delivery: Either the client pulls for the latest data, or the <b>server</b> <b>pushes</b> it to the client. However, such a static approach is not optimal, since both techniques have their own advantages and disadvantages. In this paper we present an adaptive algorithm that combines both solutions {{in order to increase}} scalability, network performance and userperceived latency. Software Computer TechnologyElectrical Engineering, Mathematics and Computer Scienc...|$|R
50|$|The {{traditional}} approach to data collection involves installing agents onall computers from which data is needed. Sometimes this installation stepis performed manually for each computer, {{other times it}} is automated via a centralized installation <b>server</b> that <b>pushes</b> software to other computers.In either case, the cost of installation (and subsequent maintenance and upgrade)is typically proportional {{to the number of}} computers that require installationservices, and this is in turn equal to the number of computers from which datais needed.|$|R
40|$|The current browser {{landscape}} {{has no real}} {{support for}} server initiated push. Existing technologies such as Comet and AJAX emulate <b>server</b> <b>push</b> using "long-polling" and rely on maintaining two connections between client and browser for streaming. The latest HTML standard, HTML 5, is introducing elements which will integrate web front-ends much tighter with server back-ends. Most importantly, web sockets are now being introduced and thereby allowing browser applications to receive asynchronous updates from the server side, so called <b>server</b> <b>push.</b> Web sockets de ne a full-duplex communication channel that operates over a single socket using HTML 5 compliant browsers. Web sockets allow for true low latency applications and put less strain on the server. This paper {{is an attempt to}} create a web socket server according to the HTML 5 web socket standard. The server will integrate with TickCapture[18] which is an existing system for back-testing and trading of algorithms written in various languages. TickCapture also allows for low latency presentation of real time market data and this data will be pushed through the web socket server to the clients using regular HTML 5 compliant browsers. The nished system must provide good scalability so an in-depth study of scalability and load balancing techniques will be carried out to identify dierent solutions for my implementation...|$|E
40|$|Long polling is a {{technique}} that simulates <b>server</b> <b>push</b> using Ajax requests, allowing Web pages to be updated quickly in response to server events. Unfortunately, existing long poll approaches are difficult to use, do not work well with server-side frameworks based on the Model-View-Controller (MVC) pattern, and are not scalable. Vault is an architecture for long polling that integrates cleanly with MVC frameworks and scales for clustered environments of hundreds of application servers. Vault lets developers focus on writing application-specific code without worrying {{about the details of}} how long polling is implemented. We have implemented Vault in two different Web frameworks. ...|$|E
40|$|The {{purpose of}} this thesis is to {{investigate}} and test the usage of HTTP/ 2 in dynamic adaptive video streaming {{as well as to}} take a look into how {{it can be used to}} benefit prefetching algorithms used with branched video. With a series of experiments the performance gains of using HTTP/ 2 rather than the older standard HTTP/ 1. 1 has been investigated. The results has shown no significant change to player quality and buffer occupancy when using HTTP/ 2, though our tests has shown in a slight decrease in overall playback quality when using HTTP/ 2. When using a linear prefetch of two fragments an average quality improvement of 4. 59 % has been shown, however, the result is inconclusive due to variations in average quality between different values for how many fragments to prefetch. Average buffer occupancy has shown promise with a maximum increase of 12. 58 %, when using linear prefetch with three fragments. The values for buffer occupancy gains are conclusive. Two implementations for non-linear prefetching has been made. The first one uses HTTP/ 2 <b>server</b> <b>push</b> to deliver fragments for prefetching and the second one uses client-side invoked HTTP requests to pull fragments from the server. Using HTTP/ 2 <b>server</b> <b>push</b> has shown in a decrease of 2. 5 % in average total load time while using client-side pulling has shown in a decrease of 34 % in average total load time...|$|E
50|$|Comet is a web {{application}} {{model in which}} a long-held HTTP request allows a web <b>server</b> to <b>push</b> data to a browser, without the browser explicitly requesting it. Comet is an umbrella term, encompassing multiple techniques for achieving this interaction. All these methods rely on features included by default in browsers, such as JavaScript, rather than on non-default plugins. The Comet approach differs from the original model of the web, in which a browser requests a complete web page at a time.|$|R
40|$|Data prefetching, where data is fetched before CPU {{demands for}} it, has been {{considered}} as an effective solution to mask data access latency. However, the current client-initiated prefetching strategies do not work well for applications with complex, non-contiguous data access patterns. While technology advances continue to enlarge the gap between computing and data access performance, trading computing power for data access delay has become a natural choice. We propose a serverbased data-push approach. In this server-push architecture, a dedicated <b>server</b> named Data <b>Push</b> <b>Server</b> (DPS) initiates and proactively pushes data closer to the client in time. We present the DPS architecture and study the issues such as what data to fetch, when to fetch, how to push, and data access modeling. 1...|$|R
5000|$|Shared {{file access}} {{involves}} but {{should not be}} confused with file synchronization and other information synchronization. Internet-based information synchronization may, for example, use the SyncML language. Shared file access is based on <b>server</b> side <b>pushing</b> of folder information, and is normally used over an [...] "always on" [...] Internet socket. File synchronization allows the user to be offline from time to time, and is normally based on an agent software that polls synchronized machines at reconnect, and sometimes repeatedly with a certain time interval, to discover differences. Modern operating systems often include a local cache of remote files, allowing offline access and synchronization when reconnected.|$|R
