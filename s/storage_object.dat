24|585|Public
5000|$|... {{physical}} <b>storage</b> <b>object</b> identifies {{free storage}} blocks in memory ...|$|E
5000|$|The first central {{database}} <b>storage</b> (<b>object</b> [...] "C [...] ") {{were in the}} south of the Crimean military unit (B / W) № 62047 (Krasnokamyanka, Simferopol-10 or Theodosius-13) [...] "Object 712" [...] - Commander of the M. Nemirovsky.|$|E
50|$|Object storage {{services}} like Amazon S3 and Microsoft Azure <b>Storage,</b> <b>object</b> storage software like Openstack Swift, object storage systems like EMC Atmos, EMC ECS and Hitachi Content Platform, and distributed storage research projects like OceanStore and VISION Cloud are all examples of storage {{that can be}} hosted and deployed with cloud storage characteristics.|$|E
25|$|As in C, C++ {{supports}} {{four types}} of memory management: static <b>storage</b> duration <b>objects,</b> thread <b>storage</b> duration <b>objects,</b> automatic <b>storage</b> duration <b>objects,</b> and dynamic <b>storage</b> duration <b>objects.</b>|$|R
40|$|Abstract: Network {{attached}} {{disk storage}} {{is an independent}} Internet node and provides geographical distribution, mutual identification and exchange of <b>storage</b> <b>objects.</b> The paper describes a method for global identification of <b>storage</b> <b>objects</b> and a structure of object registry. For the identification word-wide unique identifiers are generated by double hash transformation based on the Advanced Encryption Standard (Rijndael) with no collisions. Key words: network attached storage, global identification of <b>storage</b> <b>objects,</b> cryptographic hashin...|$|R
50|$|Once the {{relationships}} and dependencies amongst the various {{pieces of information}} have been determined, {{it is possible to}} arrange the data into a logical structure which can then be mapped into the <b>storage</b> <b>objects</b> supported by the database management system. In the case of relational databases the <b>storage</b> <b>objects</b> are tables which store data in rows and columns. In an <b>Object</b> database the <b>storage</b> <b>objects</b> correspond directly to the objects used by the Object-oriented programming language used to write the applications that will manage and access the data. The relationships may be defined as attributes of the object classes involved or as methods that operate on the object classes.|$|R
5000|$|More {{general purpose}} object storage systems came to market around 2008. Lured by the {{incredible}} growth of [...] "captive" [...] storage systems within web applications like Yahoo Mail {{and the early}} success of cloud <b>storage,</b> <b>object</b> storage systems promised the scale and capabilities of cloud storage, {{with the ability to}} deploy the system within an enterprise, or at an aspiring cloud storage service provider. Notable examples of object storage systems include NetApp StorageGRID, EMC Atmos, OpenStack Swift, Scality RING, Caringo Swarm (formerly CAStor), Cloudian, OpenIO, and Minio.|$|E
50|$|Smaller DAM {{systems are}} easier to {{categorize}} as to content and usage since they normally operate in a particular operational context. This would hold true for systems attached to audio or video production systems. The key differentiators here are the type of decoders and I/O (input/output) used for the asset ingest, use and outgest. Since metadata describes the essence (and proxy copies), the metadata {{can serve as a}} guide to the playout decoders, transcoders, and channels as well as an input to access control rules. This means that the essence can be treated as a non-described <b>storage</b> <b>object</b> except when being accessed for viewing or editing. There is relevance to this when considering the overall design and use of larger implementations. The closer the asset is to the ingest/edit/playout tool, the greater the technical architecture needs to accommodate delivery requirements such as bandwidth, latency, capacity, access control, availability of resources, etc. The further the asset moves into a general storage architecture (e.g. hierarchical storage management HSM) the more it can be treated as a general blob (binary large object) that is typically held in the filesystem, not the database. The impact of this set of needs means that it is possible and reasonable to design larger systems using smaller, more expensive performance-systems {{at the edge of the}} network where the essence is being used in its intended form and less expensive systems further back for storage and archival. This type of design exemplifies Infrastructure Convergence Architecture, where the line-of-business operations technology and IT technologies depend on one another for functional and performance (non-functional) requirements.|$|E
40|$|Content of {{bachelor}} work is civil-technological {{project of}} substructure in administrative and <b>storage</b> <b>object</b> in Kunratice close to Praha. Project contains technological prescriptions of drilled piles, groundwork and lime stabilisation. Another parts are {{inspection and testing}} plans, situation of building with wide detentions of transport routes, bill of quantities, schedule of work, catalog of mechanization, safety during work and organization of construction...|$|E
5000|$|... <b>storage</b> claim <b>object</b> limits <b>storage</b> {{that may}} be {{allocated}} by all associated <b>storage</b> resource <b>objects</b> ...|$|R
50|$|Mozilla Firefox stores all web <b>storage</b> <b>objects</b> in {{a single}} file named webappsstore.sqlite. The sqlite3 command {{can be used to}} show the {{elements}} stored therein.|$|R
5000|$|Storage of web <b>storage</b> <b>objects</b> {{is enabled}} by default in Mozilla Firefox and SeaMonkey, {{but can be}} {{disabled}} by setting the [...] "about:config" [...] parameter [...] "dom.storage.enabled" [...] to false.|$|R
40|$|Complex {{objects are}} a major advance {{achieved}} in modern database systems (DBS) to provide powerful data modelling capabilities. A complex object is highly structured, containing many dependent or independent subobjects. Most of today's DBS {{are based on the}} traditional two-level DBS architecture consisting of a storage and a logical data model level. In these systems, the structural aspect of a complex object is managed on the data model level, but lacks specific support from the storage level which could enhance overall DBS performance. In this paper, we present the concepts and implementation of the KIOSK <b>storage</b> <b>object</b> server designed to efficiently load complex objects from secondary storage. KIOSK introduces the notion of complex storage objects which facilitates modelling the structural aspect of complex objects at the storage level. KIOSK provides operators to load a complex <b>storage</b> <b>object</b> in its entirety from disk in one access and additionally allows clients to retrieve dynamica [...] ...|$|E
40|$|This paper {{describes}} {{the design of}} the object-oriented storage component of EXODUS, an extensible database manaaement~svstern currently under development at the University of-Wiscon&t. The basic abstraction in the EXODU’S storage system is the <b>storage</b> <b>object,</b> an uninterpmted variable-length m&z & of arbitrary size; higher level abstractions such as records and indices am supported via the <b>storage</b> <b>object</b> abstraction. One of the key design %atums described here is a scheme,for managing large dynamic objects, as storage objects can occupy many disk pages and can grow or s. hrink at arbitrary points. The data structure and algorithmsused to su-port such objects are described, and nerformance results from a ore s-iminary prototype of the EXODUS. large-object management scheme am presented. A scheme for maintainin versions of large objects is also described. We then describe the fi K e structure used in the EXODUS storage system, which provides a mechanism for grouping and sequencing through a set of related storage objects. In addition to object and file management. we discuss the EXODUS approach to buffer management, &ntcurrency control, and recovery, both for small and large objects. 1...|$|E
40|$|Modern {{applications}} demand {{support for}} {{a large number of}} clients and require large scale storage subsystems. This paper presents a theoretical model of prefetching and caching of storage objects under a parallel storage units architecture. The storage objects are defined as variable sized data blocks and a specific cache area is reserved for data prefetching and caching. An evolutionary algorithm is proposed for identifying the storage objects to be prefetched and cached. The <b>storage</b> <b>object</b> prefetching approach is experimented under certain artificial workloads of requests for a set of storage units and has shown significant performance improvement with respect to request service times, as well as cache and byte hit ratios...|$|E
5000|$|In {{addition}} to changing the camera's settings and operating mode, {{it is possible}} to receive a through-the-lens view using [...] "Live View". As described above, the <b>storage</b> <b>objects</b> of the camera's memory cards can be manipulated too.|$|R
50|$|Some early incarnations of <b>object</b> <b>storage</b> {{were used}} for archiving, as {{implementations}} were optimized for data services like immutability, not performance. EMC Centera and Hitachi HCP (formerly known as HCAP) are two commonly cited <b>object</b> <b>storage</b> products for archiving. Another example is Quantum Lattus <b>Object</b> <b>Storage</b> Platform.|$|R
40|$|Page 276 {{missing from}} {{original}} copy. The overall {{aim of the}} thesis is to study associative access in a Persistent Object Store (POS) providing necessary <b>object</b> <b>storage</b> and retrieval capabilities to an Object Oriented Database System (OODBS) (Delis, Kanitkar & Kollios, 1998 cited in Kirchberg & Tretiakov, 2002). Associative access in an OODBS often includes navigational access to referenced or referencing objects of the object being accessed (Kim. Kim. & Dale. 1989). The thesis reviews several existing approaches proposed to support associative and navigational access in an OODBS. It {{was found that the}} existing approaches proposed for associative access could not perform well when queries involve multiple paths or inheritance hierarchies. The thesis studies how associative access can be supported in a POS regardless of paths or inheritance hierarchies involved with a query. The thesis proposes extensions to a model of a POS such that approaches that are proposed for navigational access can be used to support associative access in the extended POS. The extensions include (1) approaches to cluster <b>storage</b> <b>objects</b> in a POS on their storage classes or values of attributes, and (2) approaches to distinguish references between <b>storage</b> <b>objects</b> in a POS based on criteria such as reference types - inheritance and association, storage classes of referenced <b>storage</b> <b>objects</b> or referencing <b>storage</b> <b>objects,</b> and reference names. The thesis implements Matrix-Index Coding (MIC) approach with the extended POS by several coding techniques. The implementation demonstrates that (1) a model of a POS extended by proposed extensions is capable of supporting associative access in an OODBS and (2) the MIC implemented with the extended POS can support a query that requires associative access in an OODBS and involves multiple paths or inheritance hierarchies. The implementation also provides proof of the concepts suggested by Kirchberg & Tretiakov (2002) that (1) the MIC can be made independent from a coding technique, and (2) data compression techniques should be considered as appropriate alternatives to implement the MIC because they could reduce the storage size required...|$|R
40|$|Complex systems-on-chip {{present one}} of the most chal-lenging design {{problems}} of today. To meet this challenge, new design languages capable to model such heteroge-neous, dynamic systems are needed. For implementation of such a language, the use of an object oriented C++ class library {{has proven to be a}} promising approach, since new classes dealing with design- and platform-specific problems can be added in a conceptual and seamlessly reusable way. This paper shows the development of such an extension aimed to provide a platform-independent high-level struc-tured <b>storage</b> <b>object</b> through hiding of the low-level imple-mentation details. It results in a completely virtualised, user-extendible component, suitable for use in heteroge-neous systems. 1...|$|E
40|$|Object {{database}} systems (ODBs) are {{an attractive}} alternative to relational database systems, especially in application {{areas where the}} modeling power or performance of relational database systems is insufficient. These applications typically maintain large amounts of data. Frequently, some of the data is temporal data. For the temporal data, {{the whole history of}} the individual objects is kept, and data is never deleted. The area of temporal ODBs is still immature, and there are many design issues that need to be solved {{in order to be able}} to achieve the desired performance. In this paper, we discuss some temporal ODB research issues and possible solutions related to object <b>storage,</b> <b>object</b> management, main memory buffering, and language bindings...|$|E
40|$|Now a day’s {{replication}} is {{an effective}} approach to improve the efficacy of distributed system, where large amount of data (terabytes or peta-bytes) is handled. An efficient replica technique {{is more effective than}} a shared distributed system (network attached <b>storage,</b> <b>object</b> based storage and storage area network) and common access point. In a distributed system, data access time depends on unreliable network bandwidth especially in desktop grid. The data transfer is a major bottleneck in data intensive distributed grid environment due to high latency and low and unreliable bandwidth. In such an environment, an effective scheduling and effective replica technique can reduce the amount of data transfer across the internet by dispatching a job to a node where the required data are present for its operation. As th...|$|E
40|$|This {{release is}} NOT {{backwards}} compatible. It comprises a significant refactoring {{of the entire}} codebase. Major changes: Introduction of the sample_set and discretization classes which are new <b>storage</b> <b>objects.</b> Non-Voronoi cell based partitioning. Local volume estimation. Error estimates. Updating and streamlining of parallelism. Updating of documentation and examples...|$|R
5000|$|External {{entities}} {{refer to}} external <b>storage</b> <b>objects.</b> They are just declared by a unique {{name in the}} document, and defined with a public identifier (an FPI) and/or a system identifier (interpreted as an URI) specifying where {{the source of their}} content. They exist in fact in two variants: ...|$|R
5000|$|More recently, global file {{systems have}} emerged that combine cloud or any <b>object</b> <b>storage,</b> {{versioning}} and local caching {{to create a}} single, unified, globally accessible file system that does not rely on redirection to a storage device [...] but serves files from the local cache while maintaining the single file system and all meta data in the <b>object</b> <b>storage.</b> [...] As described in Google's patents, advantages of these global file systems include the ability to scale with the <b>object</b> <b>storage,</b> use snapshots stored in the <b>object</b> <b>storage</b> for versioning to replace backup, and create a centrally managed consolidated storage repository in the <b>object</b> <b>storage.</b>|$|R
40|$|An {{object model}} of {{multi-modal}} transport networks is developed with {{particular emphasis on}} applications in trip planning. The model caters for {{both public and private}} transport modes, and incorporates spatial and temporal data. A uniform approach to optimum trip finding across multi-modal transport networks is developed. The multi-modal network is spatially ordered using a quadtree <b>storage</b> <b>object</b> for efficient storage and access. Introduction Trip planning systems can be defined as systems for assisting travellers or potential travellers with all aspects of their journeys including decisions on such issues as how to travel, when to travel and what route or routes to travel on. Travel decisions may be based on static information such as physical transport networks and public transport timetables, and dynamic information such as data on delays, congestion and cancellations. The challenge in multi-modal trip planning is to develop a model which expresses the common features (both [...] ...|$|E
40|$|For many {{distributed}} data intensive applications, {{the default}} remote invocation of CORBA objects to a server {{is not acceptable}} because of performance degradation. Caching can improve performance and scalability of such applications by increasing the locality of data. This paper proposes a caching approach that optimises the default remote invocation behaviour of CORBA clients. Efficient fine-grained access to remote objects requires objects to be shipped to clients and cached across transaction boundaries. This approach is based on cache consistency via backward validation, generic approach for cache <b>storage,</b> <b>object</b> based data shipping and replication management. These features are introduced without changing the object definitions that the client may already depend upon. An implementation of the proposed caching approach is done on Orbix by extending the smart proxies. We have also provided a test with different client workloads. The results demonstrated a significant performance inc [...] ...|$|E
40|$|Network {{attached}} storage devices improve I/O performance by separating control and data paths and eliminating host intervention during data transfer. Devices {{are attached to}} a high speed network for data transfer and to a slower network for control messages. Hierarchical mass storage systems use disks to cache the most recently used files and tapes (robotic and manually mounted) to store {{the bulk of the}} files in the file system. This paper shows how queuing network models can be used to assess the performance of hierarchical mass storage systems that use network {{attached storage}} devices. The analytic model validated through simulation was used to analyze many different scenarios. 1 Introduction Most current mass storage systems at national laboratories and supercomputer centers are based on the server attached storage model in which all storage devices are attached to a single machine using high speed busses and I/O channels. A request for access to a <b>storage</b> <b>object</b> arrives at the ser [...] ...|$|E
40|$|Deduplication {{in storage}} systems has gained {{momentum}} recently for its capability in reducing data footprint. However, deduplication introduces challenges to storage management as <b>storage</b> <b>objects</b> (e. g., files) {{are no longer}} independent from each other due to content sharing between these <b>storage</b> <b>objects.</b> In this paper, we present a graph-based framework to address the challenges of storage management due to deduplication. Specifically, we model content sharing among <b>storage</b> <b>objects</b> by content sharing graphs (CSG), and apply graph-based algorithms to two real-world storage management use cases for deduplication-enabled storage systems. First, a quasi-linear algorithm was developed to partition deduplication domains with a minimal amount of deduplication loss (i. e., data replicated across partitioned domains) in commercial deduplication-enabled storage systems, whereas in general the partitioning problem is NP-complete. For a real-world trace of 3 TB data with 978 GB of removable duplicates, the proposed algorithm can partition the data into 15 balanced partitions with only 54 GB of deduplication loss, that is, a 5 % deduplication loss. Second, a quick and accurate method to query the deduplicated size for a subset of <b>objects</b> in deduplicated <b>storage</b> systems was developed. For the same trace of 3 TB data, the optimized graph-based algorithm can complete the query in 2. 6 s, which is less than 1 % of that of the traditional algorithm based on the deduplication metadata...|$|R
5000|$|B2 Cloud <b>Storage</b> - An <b>object</b> <b>storage</b> service {{similar to}} Amazon's S3. B2 {{is known as}} a reliable, but {{affordable}} option for [...] "cloud storage".|$|R
40|$|Abstract — Intercloud <b>object</b> <b>storage</b> {{services}} are crucial for inter-organization research collaborations that need {{huge amounts of}} remotely stored data and machine image. This study introduces a prototype implementation of wide-area distributed <b>object</b> <b>storage</b> services, called colony, and describes a trial of its cloud storage architecture and intercloud storage services for academic clouds. Keywords-Cloud computing; <b>Object</b> <b>storage</b> service...|$|R
40|$|Many {{recently}} proposed sensornet applications require {{large number}} of sensor nodes operating {{over long periods of}} time. In contrast to the first-generation sensornet deployments, these applications involve sophisticated internode communication rather than simple tree-based data collection. The examples include network maintenance, data-centric <b>storage,</b> <b>object</b> tracking, and various query engines. If these proposals for next-generation applications are ever to become reality, we will need solutions for self-organization of very large networks. We argue that these applications need methods for organizing nodes into recursive geometric structures, for example, proximity-based hierarchies. Such structures should provide naming that facilitates amongst others, routing, multicasting, and data aggregation and fusion. This paper presents a novel algorithm for dynamically organizing nodes in a sensornet into an area hierarchy. The algorithm employs gossiping, guaranteeing predictable maintenance traffic, which is a crucial property when it comes to energy conservation. Simulations show that the algorithm scales to large networks, works well in the presence of message loss and networ...|$|E
40|$|Although many {{distributed}} storage protocols {{have been}} introduced, {{a solution that}} combines the strongest properties in terms of availability, consistency, fault-tolerance, storage complexity and the supported level of concurrency, has been elusive for a long time. Combining these properties is difficult, especially if the resulting solution is required to be efficient and incur low cost. We present AWE, the first erasure-coded distributed implementation of a multi-writer multi-reader read/write <b>storage</b> <b>object</b> that is, at the same time: (1) asynchronous, (2) wait-free, (3) atomic, (4) amnesic, (i. e., with data nodes storing a bounded number of values) and (5) Byzantine fault-tolerant (BFT) using the optimal number of nodes. Furthermore, AWE is efficient since it does not use public-key cryptography and requires data nodes that support only reads and writes, further reducing the cost of deployment and ownership of a distributed storage solution. Notably, AWE stores metadata separately from k-out-of-n erasure-coded fragments. This enables AWE {{to be the first}} BFT protocol that uses as few as 2 t+ k data nodes to tolerate t Byzantine nodes, for any k ≥ 1. ...|$|E
40|$|Over the years, {{different}} meanings {{have been associated}} to the word consistency in the distributed systems community. While in the ' 80 s "consistency" typically meant strong consistency, later defined also as linearizability, in recent years, {{with the advent of}} highly available and scalable systems, the notion of "consistency" has been at the same time both weakened and blurred. In this paper we aim to fill the void in literature, by providing a structured and comprehensive overview of different consistency notions that appeared in distributed systems, and in particular storage systems research, in the last four decades. We overview more than 50 different consistency notions, ranging from linearizability to eventual and weak consistency, defining precisely many of these, in particular where the previous definitions were ambiguous. We further provide a partial order among different consistency predicates, ordering them by their semantic "strength", which we believe will reveal useful in future research. Finally, we map the consistency semantics to different practical systems and research prototypes. The scope of this paper is restricted to non-transactional semantics, i. e., those that apply to single <b>storage</b> <b>object</b> operations. As such, our paper complements the existing surveys done in the context of transactional, database consistency semantics...|$|E
5000|$|<b>Storage</b> of <b>objects</b> not {{directly}} related to images (such as human-generated requests and reports) ...|$|R
50|$|MinFS is a FUSE {{driver for}} Amazon S3 {{compatible}} <b>object</b> <b>storage</b> server. MinFS enables legacy applications to use Amazon S3 compatible <b>object</b> <b>storage</b> by mounting the object store onto the file system.|$|R
50|$|In April 2016, Cloudian {{released}} HyperStore 6.0, which added built-in <b>storage</b> analytics, <b>object</b> GPS, and proactive repair.|$|R
