0|3992|Public
40|$|The aim of {{the thesis}} "Labeling and <b>schematic</b> <b>typing</b> in {{kindergarten}} " is to cover these phenomena in the nursery school environment in Rudnik. In the theoretical part of the thesis are presented various bases, such as labeling theory, psychological knowledge of pre-school age, selected theories based on social psychology, such as teachers'perceptual and attitudinal orientation or <b>schematic</b> <b>typing.</b> The empirical part of this thesis {{is divided into two}} sections - observation (which took place in a kindergarten in Rudnik in September 2010 and September 2011) and two semi-structured interviews. The empirical part is devoted to issues of discipline and forms of labeling and <b>schematic</b> <b>typing</b> in the kindergarten environment in Rudnik. Keywords: Labelling, <b>schematic</b> <b>typing,</b> school discipline, kindergarten, sociolog...|$|R
2500|$|<b>Type</b> <b>variables</b> are monotypes. Standing alone, a <b>type</b> <b>variable</b> [...] {{is meant}} ...|$|R
30|$|Given any set of <b>type</b> <b>variables</b> V, the {{constraints}} of a constraint set P can be partitioned into two disjoint subsets P|_V^* and P-P|_V^*, the first containing constraints {{with at least one}} reachable <b>type</b> <b>variable</b> and the second constraints with only unreachable <b>type</b> <b>variables.</b>|$|R
3000|$|The {{overloading}} resolution condition used in Haskell (Haskell 98 or Haskell 2010), {{which supports}} only single parameter type classes, {{has been changed}} in Haskell implementations that support multi-parameter type classes. In the case of single parameter type classes, the overloading resolution condition for constrained type Pτ is simply tv(P)⊆ tv(τ [...]) (i.e.,  there is a <b>type</b> <b>variable</b> that occurs in P but not in τ). In the case of multi-parameter type classes, the condition considers so-called reachable <b>type</b> <b>variables.</b> A <b>type</b> <b>variable</b> occurring in P is reachable, from a set of <b>type</b> <b>variables</b> tv(τ [...]) in a constrained type Pτ, if it occurs in τ or if it occurs in a constraint in P where another reachable <b>type</b> <b>variable</b> occurs (if a <b>type</b> <b>variable</b> is not reachable, it is, of course, unreachable). In the example above, <b>type</b> <b>variable</b> a in (F a b,O [...] a) b occurs in the set of constraints ({ F a b, O [...] a}) {{but not in the}} simple type (b). This does not characterize that overloading must have been resolved, because <b>type</b> <b>variable</b> a is reachable, since it occurs in constraint F [...] a [...] b, where another reachable <b>type</b> <b>variable</b> (b) occurs. This idea, used nowadays in Haskell implementations that support multi-parameter type classes, appeared firstly in [8], as far as we know.|$|R
50|$|A <b>type</b> <b>variable</b> is an {{unqualified}} identifier. <b>Type</b> <b>variables</b> are introduced by generic class declarations, generic interface declarations, generic method declarations, and by generic constructor declarations.|$|R
50|$|An {{interface}} is generic if it declares {{one or more}} <b>type</b> <b>variables.</b> These <b>type</b> <b>variables</b> {{are known}} as the type parameters of the interface. It defines one or more <b>type</b> <b>variables</b> that act as parameters. A generic interface declaration defines a set of types, one for each possible invocation of the type parameter section. All parameterized types share the same interface at runtime.|$|R
50|$|This {{includes}} inheritance, interface implementation, parameter <b>types,</b> <b>variable</b> <b>types,</b> and exceptions.|$|R
2500|$|In a type , {{the symbol}} [...] is the {{quantifier}} binding the <b>type</b> <b>variables</b> [...] in the monotype [...] The variables [...] are called quantified and any occurrence of a quantified <b>type</b> <b>variable</b> in [...] is called bound and all unbound <b>type</b> <b>variables</b> in [...] are called free. Like in the lambda calculus, {{the notion of}} free and bound variables {{is essential for the}} understanding of the meaning of types.|$|R
3000|$|In this paper, {{improvement}} {{is used to}} remove unreachable <b>type</b> <b>variables</b> for resolving overloading, when overloading resolution cannot be further deferred, and for detecting ambiguity or unsatisfiability, if unreachable <b>type</b> <b>variables</b> cannot be removed (that is, overloading resolution is not possible). For any constrained type Pτ, {{improvement is}} tested only upon the presence of unreachable <b>type</b> <b>variables,</b> that is, if P_u = P - P|_tv(τ [...])^* = ∅ [...].|$|R
5000|$|In a type , {{the symbol}} [...] is the {{quantifier}} binding the <b>type</b> <b>variables</b> [...] in the monotype [...] The variables [...] are called quantified and any occurrence of a quantified <b>type</b> <b>variable</b> in [...] is called bound and all unbound <b>type</b> <b>variables</b> in [...] are called free. Like in the lambda calculus, {{the notion of}} free and bound variables {{is essential for the}} understanding of the meaning of types.|$|R
5000|$|<b>Type</b> <b>variables</b> are monotypes. Standing alone, a <b>type</b> <b>variable</b> [...] is meantto be as {{concrete}} as [...] or , {{and clearly}} different from both. <b>Type</b> <b>variables</b> occurring as monotypes behave {{as if they}} were type constants whose identity is unknown. Correspondingly, a function typed [...] only maps values of the particular type [...] on itself. Such a function can only be applied to values having type [...] and to no others.|$|R
40|$|Adding ML-style {{references}} to a Hindley-Milner polymorphic type system is troublesome becausc {{such a system}} is unsound with naive polymorphic generalization of reference types. Tofte [12] introduced a distinction between imperative and applicative <b>type</b> <b>variables,</b> such that applicative <b>type</b> <b>variables</b> are never in reference types, that provides a simple static analysis of which <b>type</b> <b>variables</b> may be polymorphically generalized. MacQueen's [7] weak <b>type</b> <b>variables</b> generalize imperative <b>type</b> <b>variables</b> with a counter called a strength. The finer distinction allows a more accurate analysis of when a reference may be created, and thus which <b>type</b> <b>variables</b> may be generalized. Unfortunately, weak polymorphism has been presented only {{as part of the}} implementation of the SML/NJ compiler, not as a formal type system. As a result, it is not well understood, as its more subtle points are not well known. Furthermore, while versions of the implementation have repeatedly been shown unsound, the concept has not been proven sound or unsound. We present several formal systems of weak polymorphism, show their connection to the SML/NJ implementation, and show the soundness of most of these systems...|$|R
5000|$|A {{declaration}} binds a non-blank identifier to a constant, <b>type,</b> <b>variable,</b> function, label, or package. ... The {{scope of}} a declared identifier {{is the extent}} of source text in which the identifier denotes the specified constant, <b>type,</b> <b>variable,</b> function, label, or package.|$|R
50|$|In type {{theory and}} {{programming}} languages, a <b>type</b> <b>variable</b> is a mathematical <b>variable</b> ranging over <b>types.</b> Even in programming languages that allow mutable <b>variables,</b> a <b>type</b> <b>variable</b> remains an abstraction, {{in the sense}} that it does not correspond to some memory locations.|$|R
50|$|A {{method is}} generic if it {{declares}} {{one or more}} <b>type</b> <b>variables.</b> These <b>type</b> <b>variables</b> are known as the formal type parameters of the method. The form of the formal type parameter list is identical to a type parameter list of a class or interface.|$|R
5000|$|... #Caption: <b>Schematic</b> of {{solid-state}} <b>type</b> Li-Air battery design ...|$|R
40|$|International audienceWe study {{some basic}} {{properties}} of <b>schematic</b> homotopy <b>types</b> and the schematization functor. We describe two different algebraic models for schematic homotopy types: co-simplicial Hopf alegbras and equivariant co-simplicial algebras, and provide explicit constructions of the schematization functor {{for each of}} these models. We also investigate some standard properties of the schematization functor helpful for the description of the schematization of smooth projective complex varieties. In a companion paper these results are used in the construction of a non-abelian Hodge structure on the <b>schematic</b> homotopy <b>type</b> of a smooth projective variety...|$|R
5000|$|It {{featured}} explicitly <b>typed</b> <b>variables,</b> subroutines, and functions.|$|R
40|$|AbstractLambda definability is {{characterized}} in categorical models of simply typed lambda calculus with <b>type</b> <b>variables.</b> A category-theoretic framework known as glueing or sconing {{is used to}} extend the Jung-Tiuryn (1993) characterization of lambda definability first to ccc models, and then to categorical models of the calculus with <b>type</b> <b>variables...</b>|$|R
5000|$|Programming {{languages}} {{that support}} parametric polymorphism {{make use of}} universally quantified <b>type</b> <b>variables.</b> Languages that support existential types make use of existentially quantified <b>type</b> <b>variables.</b> For example, the following OCaml code defines a polymorphic identity function that has a universally quantified type, which is printed by the interpreter on the second line: ...|$|R
2500|$|Typed lambda {{calculus}} – Lambda calculus with <b>typed</b> <b>variables</b> (and functions) ...|$|R
5000|$|Typed lambda {{calculus}} - Lambda calculus with <b>typed</b> <b>variables</b> (and functions) ...|$|R
2500|$|I.e. {{in context}} of the example, the same <b>type</b> <b>variable</b> [...] appears both bound and free in {{different}} types. As a consequence, a free <b>type</b> <b>variable</b> cannot be interpreted better than stating it is a monotype without knowing the context. Turning the statement around, in general, a typing is not meaningful without a context.|$|R
50|$|Usage of {{generics}} may {{be limited}} to some particular methods, this concept applies to constructors as well. To declare a parameterized method, <b>type</b> <b>variables</b> are written before the return type of the method in the same format as for the generic classes. In the case of constructor, <b>type</b> <b>variables</b> are declared before the constructor name.|$|R
5000|$|... 04/2010 - Version 6.9 released, {{added support}} for <b>typed</b> <b>variables</b> and subs.|$|R
3000|$|Equality of {{constraint}} sets {{is considered}} modulo <b>type</b> <b>variable</b> renaming. That is, constraint sets P,Q are also equal if {{there exists a}} renaming substitution S {{that can be applied}} to P to make S P and Q equal. S is a renaming substitution if for all α∈ dom(S) we have that S(α [...])=β, for some <b>type</b> <b>variable</b> β∈ dom(S).|$|R
40|$|Bounded {{quantification}} allows quantified types {{to specify}} subtyping bounds for the <b>type</b> <b>variables</b> they introduce. It has undecidable subtyping and type checking. This paper shows that subclassing-bounded quantification—type variables have subclassing bounds—has decidable type checking. The main difficulty is that, <b>type</b> <b>variables</b> can have either upper bounds or lower bounds, which complicates the minimal type property...|$|R
5000|$|The most {{important}} earliest {{groups of the}} Grotta-Pelos culture are Pelos, Plastiras and Louros. Pelos figurines are of <b>schematic</b> <b>type.</b> Both males and females, in standing position with a head and face, compose the Plastiras type; the rendering is naturalistic but also strangely stylized. The Louros type is seen as transitional, combining both schematic and naturalistic elements. Schematic figures are more commonly found and are very flat in profile, having simple forms and lack a clearly defined head. Naturalistic figures are small and tend to have strange or exaggerated proportions, with long necks, angular upper bodies, and muscular legs.|$|R
5000|$|Various diagram types, or schematics, can be {{constructed}} in the IDEF5 Schematic Language. The purpose of these schematics, like that of any representation, is to represent information visually. Thus, semantic rules must be provided for interpreting every possible schematic. These rules are provided by outlining the rules for interpreting the most basic constructs of the language, then applying them recursively to more complex constructs. There are four primary <b>schematic</b> <b>types</b> derived from the basic IDEF5 Schematic Language {{which can be used}} to capture ontology information directly in a form that is intuitive to the domain expert.|$|R
2500|$|... the {{instances}} for the <b>type</b> <b>variable</b> in the rules. Working towards {{finding the}} ...|$|R
5000|$|... a <b>type</b> <b>variable</b> in <b>type</b> theories, {{such as the}} simply typed lambda {{calculus}} ...|$|R
5000|$|In {{computer}} science, a type {{class is}} a type system construct that supports ad hoc polymorphism. This is achieved by adding constraints to <b>type</b> <b>variables</b> in parametrically polymorphic types. Such a constraint typically involves a type class [...] and a <b>type</b> <b>variable</b> , and means that [...] can only be instantiated to a type whose members support the overloaded operations associated with [...]|$|R
50|$|One can use any {{variable}} as a quantified {{variable in}} place of any other, under certain restrictions in which variable capture does not occur. Even if the notation uses <b>typed</b> <b>variables,</b> <b>variables</b> of that <b>type</b> may be used.|$|R
5000|$|In {{mathematical}} notation, {{the type}} of the function [...] is , where [...] is a <b>type</b> <b>variable.</b>|$|R
3000|$|A substitution, {{denoted by}} meta-variable S, {{possibly}} primed or subscripted, {{is a function}} from <b>type</b> <b>variables</b> to simple <b>type</b> expressions. The identity substitution is denoted by [...] id.Sσ represents the capture-free operation of substituting S(α [...]) for each free occurrence of <b>type</b> <b>variable</b> α in σ [...]. Sθ and sets of types and constraints are defined analogously. Symbol ∘ denotes function composition, and dom(S)={α| S(α [...]) =α}.|$|R
50|$|A {{constructor}} can {{be declared}} as generic, independently {{of whether the}} class that the constructor is declared in is itself generic. A constructor is generic if it declares one or more <b>type</b> <b>variables.</b> These <b>type</b> <b>variables</b> are known as the formal type parameters of the constructor. The form of the formal type parameter list is identical to a type parameter list of a generic class or interface.|$|R
