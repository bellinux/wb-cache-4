74|323|Public
50|$|Many RISC machines, {{as well as}} the CISC IBM System/360 and successors, have <b>subroutine</b> <b>call</b> {{instructions}} that place the return address in an address register—the register-indirect addressing mode is used to return from that <b>subroutine</b> <b>call.</b>|$|E
50|$|The {{processor}} {{does not}} have standard <b>subroutine</b> <b>CALL</b> address and RET instructions, though they can be simulated. The 16-register design makes possible some interesting <b>subroutine</b> <b>call</b> and return mechanisms, though they are better suited to small programs than general purpose coding.|$|E
50|$|A branch {{provides}} {{that the next}} instruction is fetched from somewhere else in memory. A <b>subroutine</b> <b>call</b> not only branches but saves the preceding contents of the PC somewhere. A return retrieves the saved contents of the PC and places {{it back in the}} PC, resuming sequential execution with the instruction following the <b>subroutine</b> <b>call.</b>|$|E
50|$|In the {{recursive}} ascent parser variation, {{the explicit}} parse stack structure is also {{replaced by the}} implicit stack used by <b>subroutine</b> <b>calls.</b> Reductions terminate several levels of <b>subroutine</b> <b>calls,</b> which is clumsy in most languages. So recursive ascent parsers are generally slower, less obvious, and harder to hand-modify than recursive descent parsers.|$|R
5000|$|If {{there were}} two {{consecutive}} <b>subroutine</b> <b>calls,</b> they would look like this: ...|$|R
50|$|In {{some other}} IOCS {{packages}} similar functions {{are provided by}} explicit <b>subroutine</b> <b>calls.</b>|$|R
5000|$|... r14 is {{the link}} register. (The BL instruction, {{used in a}} <b>subroutine</b> <b>call,</b> stores the return address in this register).|$|E
50|$|To {{pipeline}} nested loops, {{the mill}} treats each loop {{almost like a}} <b>subroutine</b> <b>call,</b> with saves and restores of appropriate state.|$|E
5000|$|The [...] command was {{a unique}} form of <b>subroutine</b> <b>call.</b> It was defined as being {{equivalent}} to textual substitution {{of the body of}} the joined unit in place of the join command itself (page 21, 1973 TUTOR User's Memo). As such, a joined unit could contain part of a judging block. Thus, while the judging block is conceptually an iterator enclosing a series of cases, this block may be arbitrarily broken into subroutines. (An alternative <b>subroutine</b> <b>call,</b> the [...] command, conformed to the usual semantics associated with subroutine calls in other programming languages.) ...|$|E
50|$|In the {{compiling}} method called threaded code, the {{executable program}} {{is basically a}} sequence of <b>subroutine</b> <b>calls.</b>|$|R
5000|$|Application of compiler's {{own time}} {{critical}} <b>subroutine</b> <b>calls,</b> especially those dealing with {{floating point arithmetic}} and graphics functions ...|$|R
5000|$|The RS08 core {{does not}} manage a stack. During <b>subroutine</b> <b>calls,</b> it {{preserves}} a return address in a Shadow Program Counter link register. If a <b>subroutine</b> in turn <b>calls</b> another <b>subroutine,</b> it can preserve the return address {{in a local}} variable, <b>call</b> <b>subroutines</b> as necessary, and restore the saved address just before returning.|$|R
50|$|The F8 has two {{bidirectional}} 8-bit ports {{built into}} every PSU. An interrupt in the F3850 {{is similar to}} a <b>subroutine</b> <b>call.</b> A power-on detection organizes the computer circuitry.|$|E
50|$|In {{a similar}} manner, <b>subroutine</b> <b>call</b> {{instructions}} can be indirect, with {{the address of}} the subroutine to be called specified in memory. Function Pointers are typically implemented with indirect subroutine calls.|$|E
5000|$|... (0x81) Stack pointer SP. This is an 8-bit {{register}} used by <b>subroutine</b> <b>call</b> and return instructions. The stack grows upward; the SP is incremented before pushing, and decremented after popping a value.|$|E
5000|$|It {{defines a}} <b>subroutine</b> <b>called</b> [...] "Main". [...] "Main" [...] is the entry point, where the program begins execution.|$|R
5000|$|In common usage, a {{constructor}} is {{a method}} directly called explicitly by user code to create an object, while [...] "destructor" [...] is the <b>subroutine</b> <b>called</b> (usually implicitly, but sometimes explicitly) on object destruction in languages with deterministic object lifetimes - the archetype is C++ - and [...] "finalizer" [...] is the <b>subroutine</b> <b>called</b> implicitly by the garbage collector on object destruction in languages with non-deterministic object lifetime - the archetype is Java.|$|R
50|$|For <b>subroutine</b> <b>calls,</b> the Branch and Load Workspace Pointer (BLWP) {{instruction}} loads new WP and PC values, then {{saves the}} values of WP, PC and ST to the (new) registers 13, 14 and 15 respectively. At {{the end of the}} subroutine, the Return Workspace Pointer (RTWP) restores these in reverse order. Using BLWP/RTWP, it is possible to nest <b>subroutine</b> <b>calls</b> despite the absence of a stack, however, the programmer needs to assign the appropriate register workspace explicitly.|$|R
5000|$|Software {{interrupt}}: an interrupt generated {{within a}} processor by executing an instruction. Software interrupts {{are often used}} to implement system calls because they result in a <b>subroutine</b> <b>call</b> with a CPU ring level change.|$|E
50|$|A <b>subroutine</b> <b>call</b> or method {{invocation}} {{will not}} exit until the invoked computation has terminated. Asynchronous message passing, by contrast, {{can result in}} a response arriving a significant time after the request message was sent.|$|E
5000|$|... setjmp.h is a header {{defined in}} the C {{standard}} library to provide [...] "non-local jumps": control flow that deviates from the usual <b>subroutine</b> <b>call</b> and return sequence. The complementary functions '''''' and '''''' provide this functionality.|$|E
5000|$|<b>Subroutines</b> (<b>called</b> [...] "Sub") are {{the most}} basic unit of code. All code must be written inside subroutines. Subroutines can return a value.|$|R
50|$|Exokernels {{communicate}} efficiently by normal <b>subroutine</b> <b>calls.</b> The {{hardware and}} all the software in the system are available to and extensible by application programmers.|$|R
50|$|The {{standard}} assembler places {{constant values}} for arithmetic {{in the current}} page. Likewise, cross-page jumps and <b>subroutine</b> <b>calls</b> use an indirect address in the current page.|$|R
50|$|The {{format of}} a macro (<b>subroutine)</b> <b>call</b> may be {{illustrated}} by the following example. Macro A in this example adds the two parameters passed to it from the main program, and returns the sum {{on the top of}} the stack.|$|E
50|$|The {{idea of a}} {{subroutine}} was {{worked out}} after computing machines had already existed for some time.The arithmetic and conditional jump instructions were planned {{ahead of time and}} have changed relatively little; but the special instructions used for procedure calls have changed greatly over the years.The earliest computers and microprocessors, such as the Small-Scale Experimental Machine and the RCA 1802, did not have a single <b>subroutine</b> <b>call</b> instruction.Subroutines could be implemented, but they required programmers to use the call sequence—a series of instructions—at each call site.Some very early computers and microprocessors, such as the IBM 1620, the Intel 8008, and the PIC microcontrollers, have a single-instruction <b>subroutine</b> <b>call</b> that uses dedicated hardware stack to store return addresses—such hardware supports only a few levels of subroutine nesting, but can support recursive subroutines.Machines before the mid 1960s—such as the UNIVAC I, the PDP-1, and the IBM 1130—typically use a calling convention which saved the instruction counter in the first memory location of the called subroutine. This allows arbitrarily deep levels of subroutine nesting, but does not support recursive subroutines.The PDP-11 (1970) {{is one of the first}} computers with a stack-pushing <b>subroutine</b> <b>call</b> instruction; this feature supports both arbitrarily deep subroutine nesting and also supports recursive subroutines.|$|E
50|$|Trampolines: Many CPUs have smaller <b>subroutine</b> <b>call</b> {{instructions}} to access low memory. A compiler can save space by using these small {{calls in the}} main body of code. Jump instructions in low memory can access the routines at any address. This multiplies space savings from code factoring.|$|E
50|$|It is {{particularly}} important to recognize the compiler idioms for <b>subroutine</b> <b>calls,</b> exception handling, and switch statements. Some languages also have extensive support for strings or long integers.|$|R
50|$|Its I/O mode is {{flexible}} and programmable, {{and it has}} a single-phase clock with an on-chip oscillator. Its register set consists of sixteen 16-bit registers. The program counter (PC) can reside in any of these, and is settable using the SEP Rn instruction, providing a simple way to implement multiple PCs, and to perform <b>subroutine</b> <b>calls.</b> (see <b>Subroutine</b> <b>calls</b> below). Similarly, pointers and indirect addressing use the X register (SEX Rn instruction), or the 16 registers can be used as general purpose registers. DMA In and Out and Interrupts use specific registers.|$|R
5000|$|To save space, programmers {{squeezed}} {{the lists of}} <b>subroutine</b> <b>calls</b> into simple lists of subroutine addresses, and used a small loop to <b>call</b> each <b>subroutine</b> in turn. For example: ...|$|R
50|$|Another part of {{a calling}} {{convention}} is which registers are guaranteed to retain their values after a <b>subroutine</b> <b>call.</b> According to the Intel ABI to which {{the vast majority of}} compilers conform, the EAX, EDX, and ECX are to be free for use within a procedure or function, and need not be preserved.|$|E
50|$|VOS {{has always}} been a network aware {{operating}} system. Virtually every system call in the native API has a parameter that determines what computer the operation affects. If the operation isn't local, it is redirected to the target computer via remote <b>subroutine</b> <b>call.</b> For example, file names are parsed to indicate which computer the file resides on.|$|E
50|$|All processors, {{including}} TTA processors, include {{control flow}} instructions that alter the program counter, {{which are used}} to implement subroutines, if-then-else, for-loop, etc.The assembly language for TTA processors typically includes control flow instructions such as unconditional branches (JUMP), conditional relative branches (BNZ), <b>subroutine</b> <b>call</b> (CALL), conditional return (RETNZ), etc. that look {{the same as the}} corresponding assembly language instructions for other processors.|$|E
50|$|However, another {{advantage}} of the call stack method {{is that it allows}} recursive <b>subroutine</b> <b>calls,</b> since each nested call to the same procedure gets a separate instance of its private data.|$|R
5000|$|... (transfer control): An {{unconditional}} branch {{to the address}} specified by the instruction. The return address was automatically stored in the Q register, so the [...] instruction {{could be used for}} <b>subroutine</b> <b>calls.</b>|$|R
5000|$|The {{desire to}} retain the {{high-order}} bit as a [...] "control or escape bit." [...] In particular, the standard <b>subroutine</b> <b>calling</b> convention marked the final parameter word by setting its high bit.|$|R
