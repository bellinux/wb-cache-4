16|39|Public
40|$|This paper {{discusses}} {{our initial}} work in developing metrics for <b>software</b> <b>adaptability.</b> In this paper {{we have developed}} several metrics for <b>software</b> <b>adaptability.</b> One {{of the advantages of}} the metrics that we have developed is that they are applicable at the architectural level. Since architecture development is the first stage of the design process, {{the extent to which the}} architecture is adaptable will determine the adaptability of the final software. Hence the metrics in this paper will help determine the extent to which the final software will be adaptable as well. This paper first defines <b>software</b> <b>adaptability</b> and then defines adaptability indices – the architecture adaptability index (AAI) and the <b>software</b> <b>adaptability</b> index (SAI). The application of these indices is illustrated with examples. Also the validity of these indices for hierarchical architectures, legacy systems and for dynamic adaptation is examined. ...|$|E
40|$|In {{the last}} few years, new {{software}} paradigms, such as Aspect-Oriented Software Development (AOSD) or Model Driven Development (MDD), have been brought up {{in order to improve}} <b>software</b> <b>adaptability</b> to changes. MDA improves the adaption to different technologies by means of three di-fferent levels of modelling. This paper is focused on the platform specific level, and proposes the use of transforma-tions to weave AspectJ aspects and the basic functionality at the modelling level before the code generation phase. 1...|$|E
40|$|The dynamic {{characteristics}} of business processes and network computing environments bring new challenges to distributed applications. As {{an approach to}} solve the adaptation problem of serviceoriented applications, caused by changes of service resources and user requirements in such dynamic network computing environments, we present an open and adaptive software architecture model in this paper. We also discuss the deployment of the model in a real project. An analysis and evaluation of the model's capability to improve <b>software</b> <b>adaptability</b> shows that the model can improve service-oriented applications regarding change awareness, continuous evolution and selforganization...|$|E
40|$|Agent-based {{approaches}} offer promising {{solutions for}} recent demands in enterprise <b>software</b> like <b>adaptability</b> {{cooperation and coordination}} (Jennings 2001). Industrial strength agent platforms, such as the JADE platform or Whitesteins LS/TS tool suite, serve as an established technological basis for agent-based programmin...|$|R
40|$|<b>Software</b> has dynamic <b>adaptability</b> if it {{can adapt}} itself to {{dynamically}} changing runtime environments. As open-ended distributed systems and mobile computing systems have spread widely, the need for <b>software</b> with dynamic <b>adaptability</b> increases. We propose {{a model of the}} <b>software</b> with dynamic <b>adaptability.</b> We are currently designing and implementing a programming language based on the model. The basic idea is that we introduce the mechanism which changes procedure invocations dynamically depending on the states of runtime environments. Our language LEAD++ provides the mechanism as a language functionality. Although our software model is simple, it can realize highly dynamic adaptability (including extensibility) of the software. By using LEAD++, we can develop dynamically adaptable software easily and systematically. I...|$|R
40|$|Based on GQM (Goal Question Metric) approach, {{this paper}} {{presents}} a new process-oriented metrics for <b>software</b> architecture <b>adaptability.</b> This method extends and improves the GQM method. It develops process-oriented processes for metrics modeling, introduces data and validation levels, adds structured description of metrics, and defines new indexes of metrics. </span...|$|R
40|$|Aspect-oriented {{technologies}} are increasingly promoting {{new ways of}} developing software {{in order to better}} control change and improve <b>software</b> <b>adaptability</b> and evolution. However, aspect-oriented development still appears strongly attached to the underlying programming approach used to support it, rather than to design mechanisms guiding development. In this context, we propose an approach for enhancing aspect-oriented software development considering aspects as first-class design entities. This work presents an agent-based tool called Smartweaver, which allows developers to describe aspect designs using UML extensions and a special documentation method, and then provides smart assistance through a planning agent to translate these specifications into particular AOP implementation technologies. Eje: Ingeniería de Softwar...|$|E
40|$|Educational {{software}} {{should be}} designed by development teams with actual teachers. Thus, implementations {{of this type of}} software would be able to cover most teaching requirements and to adjust to different teaching principles. Moreover, some more work should be done to abstract common patterns in educational software so that software engineering methods can be adapted to suit educational needs. We propose an abstraction of system users by defining a role hierarchy which fits web-based collaborative educational systems. This proposal, which can significantly improve <b>software</b> <b>adaptability</b> and usability, has been used to develop Tutor, a web-based educational software system to promote a blended learning environment in Higher Education...|$|E
40|$|Abstract- Continuous {{effort to}} achieve higher {{performance}} without {{driving up the}} power consumption and thermal effects has led the researchers to look for alternative architectures for microprocessors. Like the parallel processing which is extensively used in today’s all microprocessors, multi-core architecture which combines several independent microprocessor cores in a single die has currently become very popular in most high performance intergraded circuits. Although multi-core processor offers excellent instruction execution speed with reduced power consumption, optimizing performance of individual processors and then incorporating them by interconnection on a single chip is a non-trivial task. This paper investigates the leading challenges associated with current high performance multi-core processor in terms of interfacing different cores, design automation and verification, <b>software</b> <b>adaptability...</b>|$|E
30|$|Different {{from the}} {{commonly}} used Frank-Wolf assignment algorithm, this paper uses a genetic algorithm {{to optimize the}} stochastic equilibrium flow assignment iteratively. In this way, {{the upper and lower}} layer models are all iteratively optimized using the genetic algorithm, and the programming is easier under the same conditions using MATLAB <b>software.</b> Its <b>adaptability</b> is stronger.|$|R
40|$|Requirements {{placed by}} the {{application}} – on the user: recognize and articulate needs – on the developer: make herself {{acquainted with the}} domain – on both: create and adapt a corpus of sample target texts • Requirements wrt the <b>software</b> – <b>Adaptability</b> to new tasks and domains – Scalability (low costs of the next rule) – Modularisation (interpreter, daten, knowledge, interfaces) High efficiency of development is difficult to achieve wit...|$|R
40|$|A {{system has}} dynamic {{adaptability}} {{if it can}} adapt itself to dynamically changing runtime environment. As open-ended distributed systems and mobile computing systems have spread widely, the need for <b>software</b> with dynamic <b>adaptability</b> increases. We propose a model of <b>software</b> with dynamic <b>adaptability</b> and, have designed and implemented a programming language based on the model. The basic idea is to introduce a mechanism that changes the actual runtime codes of callee procedure dynamically according to the runtime environments. Although the model itself is simple, it can realize highly dynamic adaptability and extensibility of the software. Moreover, the model is independent of specific programming languages...|$|R
40|$|Runtime <b>software</b> <b>adaptability</b> – {{the ability}} to change an application’s {{behavior}} during runtime – is an increasingly important capability for systems, both to support continuous operation and to support a good user experience. Achieving such adaptability may be very hard or easy; the degree of difficulty will largely reflect choices made in a system’s architecture. Some architectural styles are much more supportive of dynamic change than others. This paper examines a range of styles and assesses them {{with respect to a}} four-element evaluation framework, called BASE. The framework considers how a style supports changes to behavior, state, its execution context, and supports asynchrony of change. Styles considered include REST, event-based, service-oriented, and peer-to-peer. 1...|$|E
40|$|Abstract: Software-related costs {{account for}} a growing share of total {{development}} costs for embedded control systems. In the control field, containment of software costs can be done either {{through the use of}} model-based tools (e. g. Matlab) or through a higher level of reuse. This paper argues that the second strategy is advantageous in the case of industrial control systems targeting niche markets where systems tend to be one-of-a-kind and where they can be organized in “families ” of related applications. The paper then argues that progress in raising the level of software reuse in these fields depends on the adoption of better <b>software</b> <b>adaptability</b> techniques. The most promising such techniques are reviewed from the standpoint of control engineers. Copyright © 2005 IFA...|$|E
40|$|Today’s fast-growing data-intensive network {{services}} place heavy {{demands on the}} backend servers that support them. This paper introduces ISTORE, an intelligent server architecture that couples LEGO-like plug-and-play hardware with <b>software</b> <b>adaptability</b> and continuous monitoring. ISTORE exploits introspection to provide high availability and performance while drastically reducing the cost and complexity of administration. ISTORE provides a generic server platform designed to be specialized to match the exact demands of a specific network service application, providing {{the benefits of a}} fully-custom-built server, or appliance, without the complexity of constructing one from scratch. Additionally, once specialized, ISTORE acts dynamically to monitor and adapt to changes in the imposed workload and to unexpected system events such as hardware failure. This adaptability is enabled by a combination of intelligent self-monitoring hardware components and a software extensibility mechanism that allows the target application to specify adaptation policies to the system using constrained, domain-specific languages. ...|$|E
40|$|A {{system has}} dynamic {{adaptability}} {{if it can}} adapt itself to dynamically changing runtime environments. As open-ended distributed systems and mobile computing systems have spread widely, the need for <b>software</b> with dynamic <b>adaptability</b> increases. We propose a model of <b>software</b> with dynamic <b>adaptability</b> and the object-oriented reflective language LEAD++ based on the model. The basic idea is that we introduce the mechanism which changes procedure invocations dynamically depending on the states of runtime environments. The mechanism forms a meta-level architecture, and realizes dynamic adaptability in reflective way. LEAD++ provides the mechanism as a language functionality. We are currently implementing a prototype of LEAD++ as a preprocessor of Java. Using LEAD++, we can systematically describe dynamically adaptable applets, mobile objects, etc...|$|R
40|$|The {{rapid growth}} in the Internet users and diverse {{services}} have made the researches and practitioners to think of intelligent tools that can assist the users and applications in delivering the required quality of services. In this context, software agent technology is expected to become the tool for development of future softwares in distributed environments such as mobile computing, E-commerce, telecommunication network management, etc. Agent technology can be classified as single- and multi-agent systems (distributed static and mobile agents). In this paper, we review the software agent technology applications in communications with more emphasis on mobile agents since it is an emerging agent technology. The popularity of the agent technology is due to its support to: component based software engineering, flexible operations, easy <b>software</b> maintainability, <b>adaptability</b> to the real world, and extensibility of the softwares...|$|R
40|$|Making {{trade-offs}} {{in architecture}} {{is a fundamental}} activity in software design. As software is required to operate continuously in changing and uncertain environments, adaptability needs to {{be considered as a}} key issue, along with other more traditional software qualities. In this chapter, we introduce the concept of managing trade-offs in adaptable <b>software</b> architectures, discussing <b>adaptability</b> during the design of the software and as it runs. We outline important current approaches, challenges, and opportunities in managing these trade-offs...|$|R
40|$|Dynamic <b>software</b> <b>adaptability</b> {{is one of}} {{the central}} {{features}} leveraged by autonomic computing. However, developing software that changes its behavior at run time adapting to the operational conditions is a challenging task. Several approaches have been proposed in the literature to attack this problem at different and complementary abstraction levels: software architecture, middleware, and programming level. We focus on the support that ad-hoc programming language constructs may provide to support dynamically adaptive behaviors. We introduce context-oriented programming languages and we present a framework that positions the supported paradigm in the MAPE-K autonomic loop. We discuss the advantages of using context-oriented programming languages instead of other mainstream approaches based on dynamic aspect oriented programming languages and present a case study that shows how the proposed programming style naturally fits dynamic adaptation requirements. Finally, we discuss some known problems and outline a number of open research challenges...|$|E
40|$|The {{successful}} use {{of patterns}} in a software development organization {{depends on a}} number of issues. One such issue is the classification of patterns in a manner supportive of the organization's model of software development. In modern reuse [...] based organizations adaptability of software products is a capital issue. Given this context, this paper discusses the issues and rationale for pattern classification based upon <b>software</b> <b>adaptability,</b> presents two such classification schemes and discusses their effectiveness when applied to two popular pattern catalogues. Introduction Patterns in general, and design patterns in particular, have recently become a very popular scheme for encapsulating and reusing good software engineering practice within software development organizations. The commonly available pattern literature such as [Gamma et al. 1995] and [Buschmann et al. 1996] firmly establishes the value of the technique and presents an elaborate set of practical patterns that can be used [...] ...|$|E
40|$|Message Passing Interface (MPI) {{collective}} communication routines {{are widely}} used in parallel applications. In order for a collective communication routine to achieve high performance for different applications on different platforms, it must be adaptable to both the system architecture and the application workload. Current MPI implementations do not support such <b>software</b> <b>adaptability</b> and {{are not able to}} achieve high performance on many platforms. In this paper, we present STAR-MPI (Self Tuned Adaptive Routines for MPI collective operations), a set of MPI collective communication routines that are capable of adapting to system architecture and application workload. For each operation, STAR-MPI maintains a set of communication algorithms that can potentially be efficient at different situations. As an application executes, a STAR-MPI routine applies the Automatic Empirical Optimization of Software (AEOS) technique at run time to dynamically select the best performing algorithm for the application on the platform. We describe the techniques used in STAR-MPI, analyze STAR-MPI overheads, and evaluate the performance of STAR-MPI with applications and benchmarks. The results of our study indicate that STAR-MPI is robust and efficient. It is able to find efficient algorithms with reasonable overheads, and it out-performs traditional MPI implementations to a large degree in many cases. 1...|$|E
40|$|Ontology {{evolution}} and its automation are key factors for achieving <b>software’s</b> ﬂexibility and <b>adaptability.</b> In {{the approach to}} automated ontology evolution adopted in the GALILEO project, progress in physics is modelled {{as a process of}} ontology evolution. An overview of the approach is provided in Section 2. Section 3 shows that the construction and the modiﬁcation of qualitative causal models of experimental set-ups make it possible to gain information about the quantities that appear in an equation and contribute to creating the logical conditions for the equation to evolve...|$|R
40|$|Component-oriented {{development}} of <b>software</b> supports the <b>adaptability</b> and maintainability of large systems, in particular if requirements {{change over time}} and parts of a system have to be modified or replaced. The software architecture in such systems can be described by components and their composition. In order to describe larger architectures, the composition concept becomes crucial. We will present a formal framework for component composition for object-based software development. The deployment of modal logics for defining components and component composition {{will allow us to}} reason about and prove properties of components and compositions. ...|$|R
40|$|Software {{components}} can {{be implemented}} and distributed as collections of classes, then adapted {{to the needs of}} specific applications by means of subclassing. Unfortunately, subclassing in collections of related classes may require re-implementation of otherwise valid classes just because they utilize outdated parent classes, a phenomenon that {{is referred to as the}} subclassing anomaly. The subclassing anomaly is a serious problem since it can void the benefits of component-based programming altogether. We propose a code adaptation language mechanism called class overriding that is intended to overcome the subclassing anomaly. Class overriding does not create new and isolated derived classes as subclassing does, but rather extends and updates existing classes across collections of related classes. If adopted in new languages for component-based programming, or in existing compiled languages such as C # and Java, class overriding can help maintain the integrity of evolving collections of related classes and thus enhance <b>software</b> component <b>adaptability...</b>|$|R
40|$|IN THIS THESIS IS DESCRIBED A PARALLEL FINITE ELEMENT SYSTEM (PARFES) USED FORTHE EXPLOITATION OF PARALLEL PROCESSING TECHNIQUES ON FINITE ELEMENT ANALYSIS FOR STRUCTURAL APPLICATIONS. PARFES RUNS ON MULTIPLE INSTRUCTION MULTIPLE DATA (MIMD) TYPE PARALLEL COMPUTERS FOLLOWING THE COMMUNICATING SEQUENTIAL PROCESSES (CSP) MODEL OF MIMD PARALLEL COMPUTATION AS IMPLEMENTED IN PARALLEL PROGRAMMING LANGUAGE OCCAM. THE MAIN DESIGN GOALS FOR PARFES ARE: A) SOFTWARE PORTABILITY, WHICH MEANS THAT THE SAME SOFTWARE SOURCE SHOULD RUN UNCHANGED ON ALL MIMD PARALLEL COMPUTERS THAT FOLLOW THE CSP MODEL. B) <b>SOFTWARE</b> <b>ADAPTABILITY,</b> WHICH MEANS THAT THE SAME SOFTWARE SOURCE SHOULD RUN UNCHANGED ON ALL ABOVE PARALLEL COMPUTERS HAVING ANY NUMBER OF PROCESSORS AND ARBITRARY INTERCONNECTION BETWEEN THEM. NEW NOVEL PARALLEL TECNIQUES ARE PROPOSED FOR THE GENERATION OF ELEMENT STIFFNESSES AND LOADINGS AND THE EVALUATION OF ELEMENT STRESSES. FURTHERMORE A NEW NOVEL PARALLEL SOLUTION METHOD FOR THE GLOBAL LINEAR SYSTEM OF THE STRUCTURE IS PROPOSED (ASYNCHRONOUS SYSTOLIC MULTIPLE GAUSS JORDAN (ASMGJ)). THE PROPOSED TECNIQUES WERE IMPLEMENTED ON PARALLEL COMPUTERS WITH VARIABLE NUMBER OF TRANSPUTER PROCESSORS. WITH THE USE OF THE IMPLEMENTED VERSIONS OF PARFES PARTICULAR STRUCTURAL ANALYSIS FINITE ELEMENT PROBLEMS HAVE BEEN SOLVED. THE SOLUTION TIME FOR ONE OR MORE PROCESSORS WAS MEASURED AND THERESULTING SPEEDUP AND EFFICIENCY IS PRESENTED AND IS COMMENTED. WITH THE PRESENTED IMPLEMENTATIONS OF PARFES IS PROVED THAT THE PROPOSED PARALLEL ALGORITHMS PRODUCE SIGNIFICANT GAINS FOR THE (ABSTRACT TRUNCATED) ...|$|E
40|$|Adaptation of {{software}} systems is almost an inevitable process, {{due to the}} change in customer requirements, needs for faster development of new, or maintenance of existing, software systems, etc. No doubt numerous techniques {{have been developed to}} deal with adaptation {{of software}} systems. In this paper we present an overview of some of these techniques. As {{the first step in the}} development of software solution it is our opinion that software architecture should itself be adaptable for the final software system to be adaptable. In order to systematically support adaptation at the architectural level, this paper adapts the NFR (Non-Functional Requirements) Framework and treats <b>software</b> <b>adaptability</b> requirement as a goal to be achieved during development. Through this adaptation, then, consideration of design alternatives, analysis of tradeoffs and rationalization of design decisions are all carried out in relation to the stated goals, and captured in historical records. This NFR approach can also be adapted to a knowledge-based approach for (semi-) automatically generating architectures for adaptable software systems and we also discuss how this can be achieved. Categories and Subject Descriptors Software-Software Engineering - Requirements/Specifications (D. 2. 1) : Methodologies (e. g., object-oriented, structured); Software-Software Engineering - Management (D. 2. 9) : Software process models (e. g., CMM, ISO, PSP); Computing Methodologies-Simulation and Modeling - Model Development (I. 6. 5); General Terms Design Keywords Non-Functional Requirements, Adaptability, Software Architecture, NFR Framework, Knowledge Base 1...|$|E
40|$|A new {{generation}} of Mini All-purpose Satellite Control Centers (MASCC) has been developed by CNES (F). They {{turn out to be}} easily adaptable to different kinds of satellites, both Low Earth Orbital or Geostationary. The features of MASCC allow both standard satellite control activities, and checking of passengers experiments hosted on a space platform. In the different environments in which it may be used, MASCC provides standard broadcasting of telemetry parameters on animated synoptics (curves, bar graphs, alphanumeric displays, [...] .), which {{turns out to be a}} very useful and ergonomic medium for operational teams or satellite specialists. Special care has been taken during the MASCC development about two points: - automation of all routine tasks, allowing automated operation, and limiting human commitment to system supervision and decision making, - <b>software</b> <b>adaptability.</b> To reach these two main objectives, the MASCC design provides:(1) a simple, robust and flexible hardware architecture, based on powerful distributed workstations; and (2) a table-driven software architecture, easily adapted to various operational needs. Satellite characteristics are described in a central Data Base. Hence, the processing of telemetry and commands is largely independent from the satellite itself. In order to validate these capabilities, the MASCC has been customized to several types of satellites and orbital platforms: (1) SPOT 4, the French {{new generation}} of remote sensing satellites; (2) TELECOM 2, the French geostationary TV and telecommunication satellite; and (3) MIR, the Russian orbital platform. MASCC development has been completed by the third quarter of 1993. This paper will provide first a description of the MASCC basic functions, of its hardware and software design. It will then detail the increased automation capability, along with the easy adaptation of the MASCC to new satellites with minimal software modifications...|$|E
40|$|Abstract. Issues {{related to}} large scale systems made of {{autonomous}} components encompass interoperability among independently developed <b>software</b> and <b>adaptability</b> to changing environmental conditions. Formal specifications are traditionally used at design time for software engineering tasks. However, recently, several attempts of using formal specifications at run-time have been realised that let envisage a future use of formal specifications at run-time that will enhance interoperability and adaptability of autonomous components. This paper intends {{to highlight the}} potentialities {{of the use of}} formal specifications at run-time as a support for the correct execution of such components. This paper reviews and discusses the use of formal specifications at run-time from different perspectives: software engineering, run-time code evolution, adaptive middleware, trust and security, or business applications. It highlights the potentialities of the use of formal specifications at run-time as a support for interoperability and adaptability of interacting autonomous components. It identifies as well application domains and open issues related to the combination of specifications and code in the framework of large scale systems. ...|$|R
40|$|The {{topic of}} {{software}} quality assessment {{is at the}} forefront of the software engineering movement. Many models of organization and quality control exist which serve to foster software quality and reliability (Bloom, McPheters 2 ̆ 6 Tsiang, 1973; Brandl, 1990; Comer, 1988; Dunn, 1990; Kaplan, Clark 2 ̆ 6 Tang, 1994; Livson, 1988; Musa, lannino 2 ̆ 6 Okumoto, 1987). Some models now consider the software engineering project team and end users, but most still treat them as static contributors to the system. Major factors often ignored in most conventional models include the cybernetics of the process, and human factors which have a significant impact on the assessment of the quality of the <b>software.</b> <b>Software</b> environment, <b>adaptability,</b> and motivation have all been discussed as essential in creating a superior product. Yet, the factor of human perception has been either overlooked or avoided in the ensuing discussions. In software development the software engineers 2 ̆ 7 perceptions as well as those of all potential end users, must be considered in order to ensure software quality and reliability. End User Perception and Software Quality Assessmen...|$|R
40|$|AbstractThis paper {{introduces}} the basic {{concepts of the}} rewriting logic language Maude and discusses its implementation. Maude is a wide-spectrum language supporting formal specification, rapid prototyping, and parallel programming. Maude's rewriting logic paradigm includes the functional and object-oriented paradigms as sublanguages. The fact that rewriting logic is reflective leads to novel metaprogramming capabilities that can greatly increase <b>software</b> reusability and <b>adaptability.</b> Control of the rewriting computation is achieved through internal strategy languages defined inside the logic. Maude's rewrite engine is designed with the explicit goal of being highly extensible and of supporting rapid prototyping and formal methods applications, but its semi-compilation techniques allow it to meet those goals with good performance...|$|R
40|$|In {{the vision}} of Ambient Intelligence, people are {{assisted}} in their everyday activities through the proactive, opportunistic support of non-intrusive computing devices offering intuitive interaction modalities. The usefulness and quality of delivered services can be improved considerably if the devices are able to adapt their behaviour according to sensed changes in their surrounding environment, both at the physical and logical levels. This interplay between context-awareness and dynamic <b>software</b> <b>adaptability</b> {{is key to the}} construction of applications that are smart with respect to user needs. Unfortunately, most current applications do not reach this level of adaptability, {{due to a lack of}} appropriate programming technology. Most applications exhibit fixed functionality and seldom do they sense their environment and adapt their services in a context-aware fashion. Many chances of delivering improved services to users and network peers are thus missed. This dissertation presents a programming model to ease the construction of applications that can react to changes in their execution context by adapting their behaviour dynamically. The starting point of our research is the development of novel language abstractions and the adaptation of existing abstractions to render context-aware, self-adaptable applications easier to develop. We demonstrate that a simple yet powerful computation model readily provides the needed support, leading to straightforward application code that is not concerned with context adaptation, behaviour that can be adapted dynamically to different contexts in a non-intrusive fashion, and context-aware applications with software architectures that are not biased towards context adaptation [...] -rather, they can be designed freely according to their domain. The proposed computation model is realised through the Ambience programming language, and its underlying open implementation, the Ambient Object System. A small-step operational semantics describes it formally. Much in the vein of prototype-based programming, the model has been designed with simplicity and concreteness in mind. It is highly dynamic, featuring dynamic (multiple) dispatch, dynamic inheritance, dynamic typing, and dynamic method scoping. Application logic adaptation is enabled by means of an intuitive, first-class reification of context that is straightforwardly connected to dynamic behaviour selection. We describe needed management techniques for such context, and a few programming guidelines on how to develop context-aware applications using our approach. The approach is validated by showing its application in a number of scenarios inspired on Ambient Intelligence. (FSA 3) [...] UCL, 200...|$|E
40|$|User Interface (UI) is that {{subset of}} a {{software}} system that {{interacts with the}} user of the system. Being a software system in itself, UI possesses certain attributes or non-functional requirements (NFRs) such as usability, reliability, simplicity, unambiguity, etc. However, recently, adaptability is emerging as an important characteristic for UI systems. Briefly, adaptability {{is the ability of}} a system to accommodate changes in its environment. As for any other software system, {{the first step in the}} development of a UI is the creation of the architecture for the system, and in order for the UI to be adaptable, the architecture of the UI should itself be adaptable. This paper focuses on semi-automatic generation of adaptable User Interfaces by using a tool called the <b>Software</b> Architecture <b>Adaptability</b> Assistant (or SA 3). SA 3 uses the principles behind the NFR Framework, particularly the latter's knowledge base properties, to automatically generate adaptable architectures, which can then be completed by the UI developer, if needed. In order to validate the architectures generated by the tool, we used the domain of embedded systems, in particular, test systems. SA 3 generated adaptable architectures for UI for these systems and we implemented the architectures to confirm their adaptability. 1...|$|R
40|$|A primary {{expected}} {{benefit of}} object-oriented (OO) methods {{is the creation}} of software systems that are easier to adapt and maintain. OO design patterns are especially geared to improve adaptability, since patterns generally increase the complexity of an initial design in order to ease future enhancements. For design patterns to really provide benefit, they must reduce the cost of future adaptation. The evidence of improvements in adaptability through the use of design patterns and other design structures consists primarily of intuitive arguments and examples. There is little empirical evidence to support claims of improved flexibility of these preferred structures. In this case study, we analyze 39 versions of an evolving industrial OO software system {{to see if there is}} a relationship between patterns, other design attributes, and the number of changes. We found a strong relationship between class size and the number of changes [...] - larger classes were changed more frequently. We also found two relationships that we did not expect: (1) classes that participate in design patterns are not less change prone [...] - these pattern classes are among the most change prone in the system, and (2) classes that are reused the most through inheritance tend to be more change prone. These unexpected results hold up after accounting for class size, which had the strongest relationship with changes. Keywords Design patterns, object-oriented design, <b>software</b> changes, <b>adaptability.</b> 1...|$|R
40|$|Model Driven Engineering (MDE) is an {{emerging}} approach for software development. This thesis focuses {{on one of}} the main research topics in MDE: transforming models. This topic may be studied from process and artifact perspectives. The artifact perspective involves transformation definitions and models. Transformation definitions written in transformation languages are software assets that may be considered as important as models of systems. Transformation definitions may be subject of design, implementation, reuse and evolution. In addition, they are affected by changes in their environment. An important quality factor of <b>software</b> is <b>adaptability,</b> which indicates the capabilities of software to be modified for a changing environment and as a response to changes in <b>software</b> requirements. <b>Adaptability</b> of model transformations is required in several cases motivated by various changes that may occur. This thesis addresses three problems related to the adaptability property of model transformations: identification and comparison of alternative transformations, definition of transformation languages capable of expressing transformations among models written in different languages, and language support for reusable and adaptable transformations. We claim that the identification of alternative transformations should be included as a step in an MDE process. This is motivated by the observation that multiple ways are usually available to transform a given source model to a target model. The resulting target models may be functionally equivalent but different in their quality properties such as <b>adaptability</b> and performance. <b>Software</b> engineers must be able to identify transformations that produce models with the required quality properties. For this purpose a formal technique is defined for describing the space of alternative transformations for a given source model. The technique provides operations for reduction of and selection from transformation spaces {{on the basis of the}} desired quality properties of the resulting target model. The thesis presents a hybrid transformation language named MISTRAL capable of defining transformations between models expressed in different modeling languages. The transformation language is separated from the instantiation and generalization mechanisms, which are represented in the modeling space in which the transformation language operates. Transformation definitions are specified on the basis of intensions. The concept of intension is a generalization of the concepts of meta-model and domain model expressed in a modeling language. The transformation language MISTRAL is capable of working with more than one instanceOf relation and more than one model level in a single transformation definition. This overcomes a major drawback in current transformation languages that are often coupled with particular modeling languages. A prototype shows the feasibility of this approach. Transformation definitions should be reusable and adaptable artifacts. The thesis studies requirements for a transformation language to provide adequate support for reusability and adaptability of transformation definitions. An evaluation of a set of representative languages against requirements is given. A light-weight approach is proposed for extending transformation languages with new features. The techniques proposed in the thesis are applied in a case study on XML (eXtensible Markup Language) processing based on model transformations. Compared to current techniques, this approach improves the extensibility of XML applications...|$|R
40|$|In a <b>software</b> system, dynamic <b>adaptability</b> is {{the ability}} for dynamic {{adaptation}} on runtime environments. A software system with dynamic adaptability can adapt itself to the changes of runtime environments by changing its own behavior in dynamic & exible way. We have proposed a software model with dynamic adaptability named DAS and its description language named LEAD++. We can use LEAD++ as a script language to construct componentbased software systems with dynamic adaptability. In this paper, we consider about safety issues on dynamic <b>adaptability</b> of component-based <b>software</b> systems and propose an improved DAS model named Safe DAS. The safety means that adaptable behavior of component-based software systems does not violate their consistency. To realize safe dynamic adaptability, the Safe DAS model supports exceptions & assertions mechanisms, atomicity & serialization of adaptable behavior and a unique mechanism named dynamic assertions that assertions can be changed dynamically...|$|R
40|$|From the reason, each {{software}} system {{should have the}} ability {{to be aware of the}} states' changes in runtime environments, and to change its own behaviors depending on the states. We call such ability of <b>software</b> systems dynamic <b>adaptability.</b> However, there is a limitation on runtime environments and their states that software engineers can predict beforehand. Thus, there is also a limitation on the dynamic adaptability that the engineers can give to {{software system}}s beforehand. Therefore, the mechanism of dynamic adaptability must be extensible. Namely, the mechanism must be able to change depending on various runtime environments and their states afterward. Such software systems with dynamic adaptability not only adapt themselves to dynamically changing runtime environments, but also change their own functionalities exibly to make full use of the properties in the runtime environments. We have proposed a software model with dynamic adaptability called DAS<F 12...|$|R
