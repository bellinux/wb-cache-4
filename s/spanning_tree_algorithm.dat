199|10000|Public
25|$|This {{function}} {{arises in}} more precise {{analyses of the}} algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, m represents the number of operations while n represents the number of elements; in the minimum <b>spanning</b> <b>tree</b> <b>algorithm,</b> m represents the number of edges while n represents the number of vertices.|$|E
25|$|A year later, he {{came across}} another problem from {{hardware}} engineers working on the institute's next computer: minimize the amount of wire needed to connect the pins on the back panel of the machine. As a solution, he re-discovered the algorithm known as Prim's minimal <b>spanning</b> <b>tree</b> <b>algorithm.</b> The Prim's algorithm was originally developed in 1930 by Czech mathematician Vojtěch Jarník and later independently rediscovered and republished by Robert C. Prim in 1957 and Dijkstra in 1959. Therefore, it is also sometimes called the DJP algorithm.|$|E
25|$|Optimal {{spanning}} tree problems {{have also been}} studied for finite sets of points in a geometric space such as the Euclidean plane. For such an input, a {{spanning tree}} is again a tree that has as its vertices the given points. The quality of the tree is measured {{in the same way}} as in a graph, using the Euclidean distance between pairs of points as the weight for each edge. Thus, for instance, a Euclidean minimum spanning tree is the same as a graph minimum spanning tree in a complete graph with Euclidean edge weights. However, it is not necessary to construct this graph in order to solve the optimization problem; the Euclidean minimum spanning tree problem, for instance, can be solved more efficiently in O(nlogn) time by constructing the Delaunay triangulation and then applying a linear time planar graph minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> to the resulting triangulation.|$|E
3000|$|The final {{conclusion}} is that NBP-ST (with 2 <b>spanning</b> <b>trees)</b> <b>algorithm</b> performs better than NBP in terms of accuracy and communication cost, for [...]...|$|R
5000|$|... #Subtitle level 2: Minimum <b>spanning</b> <b>tree</b> {{segmentation}} <b>algorithms</b> ...|$|R
40|$|Clustering is a {{splitting}} up of data into groups of similar objects called clusters. The objects in a cluster are similar {{between themselves and}} dissimilar compared to objects of other clusters. This paper is intended to study and compare different data clustering algorithms. The algorithms in investigation are: hierarchical agglomerative clustering algorithms: Parameter Free Minimum <b>Spanning</b> <b>Tree</b> (MST) clustering <b>algorithm</b> and single link, complete link and average link clustering algorithms. K-means partitional clustering algorithm {{is used in the}} results as a reference. Our experimental evaluation shows that Parameter Free Minimum <b>Spanning</b> <b>Tree</b> <b>algorithms</b> are lead to better clustering results than hierarchical agglomerative algorithms, which suggests that Parameter Free Minimum <b>Spanning</b> <b>Tree</b> clustering <b>algorithms</b> are well-suited for clustering...|$|R
50|$|Seth Pettie and Vijaya Ramachandran {{have found}} a provably optimal {{deterministic}} comparison-based minimum <b>spanning</b> <b>tree</b> <b>algorithm.</b> The following is a simplified description of the algorithm.|$|E
5000|$|A faster {{randomized}} minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> {{based in}} part on Borůvka's algorithm due to Karger, Klein, and Tarjan runs in expected [...] time. [...] The best known (deterministic) minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> by Bernard Chazelle is also {{based in part}} on Borůvka's and runs in [...] time, where α is the inverse of the Ackermann function. These randomized and deterministic algorithms combine steps of Borůvka's algorithm, reducing the number of components that remain to be connected, with steps of a different type that reduce the number of edges between pairs of components.|$|E
50|$|ECT-MASK0 is {{reserved}} for a common <b>spanning</b> <b>tree</b> <b>algorithm,</b> while ECT-MASK1 creates the Low PATHID set of shortest path first trees, ECT-MASK2 creates the High PATHID set of shortest path trees and the other indexes create other relatively diverse permutations of shortest path first trees.|$|E
3000|$|Suppose G(V,E) {{meet the}} {{fault-tolerant}} constraint. According Section  6, FICTC achieves the optimal topology via node-disjoint paths set R between any two nodes, which are obtained by Prim’s minimum <b>span</b> <b>tree</b> <b>algorithm.</b> If we can prove the link maximum interference in path P∈R in G [...]...|$|R
50|$|Note {{that simply}} running {{classical}} Prim's on a graph with random edge weights would create mazes stylistically identical to Kruskal's, {{because they are}} both minimal <b>spanning</b> <b>tree</b> <b>algorithms.</b> Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight.|$|R
40|$|Abstract. We give {{a simple}} {{algorithm}} {{to find a}} <b>spanning</b> <b>tree</b> that simultaneously approximates a shortest-path tree and a minimum <b>spanning</b> <b>tree.</b> The <b>algorithm</b> provides a continuous tradeoff: given the two trees and a 7 > 0, the <b>algorithm</b> returns a <b>spanning</b> <b>tree</b> in which the distance between any vertex and {{the root of the}} shortest-path tree is at most 1 + x/ 27 times the shortest-path distance, and yet the total weight of the tree is at most 1 +,~/ 2 /~/times the weight of a minimum <b>spanning</b> <b>tree.</b> Our <b>algorithm</b> runs in linear time and obtains the best-possible tradeoff. It can be implemented on a CREW PRAM to run a logarithmic time using one processor per vertex. Key Words. Minimum <b>spanning</b> <b>trees,</b> Graph <b>algorithms,</b> Parallel algorithms, Shortest paths. 1. Introduction. ...|$|R
5000|$|Run a graph minimum <b>{{spanning}}</b> <b>tree</b> <b>algorithm</b> on this graph to find {{a minimum}} spanning tree. Since there are O(n) edges, this requires O(n log n) time using any of the standard minimum spanning tree algorithms such as Borůvka's algorithm, Prim's algorithm, or Kruskal's algorithm.|$|E
50|$|Blocking - A port {{that would}} cause a {{switching}} loop if it were active. No user data is sent or received over a blocking port, but it may go into forwarding mode if the other links in use fail and the <b>spanning</b> <b>tree</b> <b>algorithm</b> determines the port may transition to the forwarding state. BPDU data is still received in blocking state. Prevents the use of looped paths.|$|E
50|$|A year later, he {{came across}} another problem from {{hardware}} engineers working on the institute's next computer: minimize the amount of wire needed to connect the pins on the back panel of the machine. As a solution, he re-discovered the algorithm known as Prim's minimal <b>spanning</b> <b>tree</b> <b>algorithm.</b> The Prim's algorithm was originally developed in 1930 by Czech mathematician Vojtěch Jarník and later independently rediscovered and republished by Robert C. Prim in 1957 and Dijkstra in 1959. Therefore, it is also sometimes called the DJP algorithm.|$|E
40|$|The minimum <b>spanning</b> <b>tree</b> {{clustering}} <b>algorithm</b> {{is capable}} of detecting clusters with irregular boundaries. In this paper we propose minimum <b>spanning</b> <b>tree</b> based clustering <b>algorithm.</b> The algorithm produces k clusters with Minimum <b>Spanning</b> Clustering <b>Tree</b> (MSCT), a new data structure {{which can be used}} as search <b>tree.</b> Our <b>algorithm</b> works in two phases. The first phase produces subtree (cluster). The second phase converts the subtree into binary tree called MSCT...|$|R
40|$|Evolutionary {{algorithms}} (EAs) {{that search}} spaces of <b>spanning</b> <b>trees</b> can encode candidate trees as sets of edges. In this case, edge-sets for an EA's initial population should represent <b>spanning</b> <b>trees</b> chosen with uniform probabilities on the graph that underlies the target problem instance. The generation of random <b>spanning</b> <b>trees</b> {{is not as}} simple as it might appear. Mechanisms based on Prim's and Kruskal's minimum <b>spanning</b> <b>tree</b> <b>algorithms</b> are not uniform, and uniform mechanisms are slow, not guaranteed to terminate, or require that the underlying graph be complete...|$|R
5000|$|Remove all F-heavy edges from G (where F is {{the forest}} from step 3) using a linear time minimum <b>spanning</b> <b>tree</b> {{verification}} <b>algorithm.</b>|$|R
50|$|The {{simplest}} algorithm {{to find an}} EMST in two dimensions, given n points, is {{to actually}} construct the complete graph on n vertices, which has n(n-1)/2 edges, compute each edge weight by finding the distance between each pair of points, and then run a standard minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> (such as the version of Prim's algorithm or Kruskal's algorithm) on it. Since this graph has &Theta;(n2) edges for n distinct points, constructing it already requires &Omega;(n2) time. This solution also requires Ω(n2) space to store all the edges.|$|E
50|$|Karger's work in {{algorithms}} {{has focused}} on applications of randomization to optimization problems and led to significant progress on several core problems. He is responsible for Karger's algorithm, a Monte Carlo method to compute the minimum cut of a connected graph. Karger developed the fastest minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> to date, with Philip Klein and Robert Tarjan. They found a linear time randomized algorithm based {{on a combination of}} Borůvka's algorithm and the reverse-delete algorithm. With Ion Stoica, Robert Morris, Frans Kaashoek, and Hari Balakrishnan, he also developed Chord, one of the four original distributed hash table protocols.|$|E
5000|$|A two-parameter {{variation}} of the inverse Ackermann function {{can be defined as}} follows, where [...] is the floor function:This function arises in more precise analyses of the algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, m represents the number of operations while n represents the number of elements; in the minimum <b>spanning</b> <b>tree</b> <b>algorithm,</b> m represents the number of edges while n represents the number of vertices.Several slightly different definitions of α(m, n) exist; for example, log2 n is sometimes replaced by n, and the floor function is sometimes replaced by a ceiling.|$|E
40|$|The minimum <b>spanning</b> <b>tree</b> {{clustering}} <b>algorithm</b> {{is known}} to be capable of detecting clusters with irregular boundaries. In this paper, we propose two minimum <b>spanning</b> <b>tree</b> based clustering <b>algorithms.</b> The first algorithm produces a k-partition of a set of points for any given k. The algorithm constructs a minimum <b>spanning</b> <b>tree</b> of the point set and removes edges that satisfy a predefined criterion. The process is repeated until k clusters are produced. The second algorithm partitions a point set into a group of clusters by maximizing the overall standard deviation reduction, without a given k value. We present our experimental results comparing our proposed algorithms to k-means and EM. We also apply our algorithms to image color clustering and compare our algorithms to the standard minimum <b>spanning</b> <b>tree</b> clustering <b>algorithm.</b> 1...|$|R
40|$|Abstract. In this article, {{we explore}} {{modified}} versions of Multicast Overlay <b>Spanning</b> <b>Tree</b> <b>algorithms</b> (MOST) to support {{quality of service}} for wireless ad hoc networks. These algorithms (Q-MOST) {{take into account the}} interferences due to radio transmissions and the residual capacity of the nodes in the network. Different algorithms are compared to the basic MOST algorithm. We show by simulations the ability and superiority of these <b>algorithms</b> to find <b>spanning</b> <b>trees</b> that connect all multicast group members with respect to the bandwidth requirements. ...|$|R
40|$|The {{fundamental}} design {{choices in}} an evolutionary algorithm are its representation of candidate solutions and the operators that {{will act on}} that representation. We propose representing <b>spanning</b> <b>trees</b> in evolutionary <b>algorithms</b> for network design problems directly as sets of their edges, and we describe initialization, recombination, and mutation operators for this representation. The operators offer locality, heritability, and computational efficiency. Initialization and recombination depend on an underlying random <b>spanning</b> <b>tree</b> algorithm; three choices for this algorithm, based on the minimum <b>spanning</b> <b>tree</b> <b>algorithms</b> of Prim and Kruskal and on random walks, respectively, are examined analytically and empirically. We demonstrate {{the usefulness of the}} edge-set encoding in an evolutionary algorithm for the NP-hard degree-constrained minimum <b>spanning</b> <b>tree</b> problem. The <b>algorithm’s</b> operators are easily extended to generate only feasible <b>spanning</b> <b>trees</b> and to incorporate local, problem-specific heuristics. Comparisons of this algorithm to others that encode candidate <b>spanning</b> <b>trees</b> via the Blob Code, with network random keys, and as strings of weights indicate the superiority of the edge-set encoding, particularly on larger instances. Keywords: <b>Spanning</b> <b>trees,</b> network design, edge-set representation, One-Max-Tree problem, degree constraints, evolutionary algorithms, hybridization. ...|$|R
5000|$|As the {{application}} of precise algorithm to solve problem is very limited, we often use approximate algorithm or heuristic algorithm. The result of the algorithm can be assessed by C / C* ≤ ε [...] C is the total travelling distance generated from approximate algorithm; C* is the optimal travelling distance; ε is the upper limit for {{the ratio of the}} total travelling distance of approximate solution to optimal solution under the worst condition. The value of ε >1.0. The more it closes to 1.0, the better the algorithm is. These algorithms include: Interpolation algorithm, Nearest neighbour algorithm, Clark & Wright algorithm, Double <b>spanning</b> <b>tree</b> <b>algorithm,</b> Christofides algorithm, Hybrid algorithm, Probabilistic algorithm.|$|E
5000|$|In 1992, Ungermann Bass {{engineering}} in Andover, Mass produced the first Virtual Private Network. It was marketed as a [...] "Virtual Network Architecture". The product's implementation utilized UB Ethernet switches, which were modified to add metadata to every packet which indicated which VPN originated the packet. Specialized segmentation and reassembly, which were compatible with Ethernet's <b>spanning</b> <b>tree</b> <b>algorithm,</b> was implemented in each switch to support jumbo packets. While this product was not successful, this technology {{was transferred to}} Cisco when UB was broken up a few years later. Cisco subsequently offered the first successful commercial VPN which included [...] "tunneling" [...] ISO layer 2 VPN LAN packets through layer 3 to interconnect two LANS via Cisco routers.|$|E
50|$|Optimal {{spanning}} tree problems {{have also been}} studied for finite sets of points in a geometric space such as the Euclidean plane. For such an input, a {{spanning tree}} is again a tree that has as its vertices the given points. The quality of the tree is measured {{in the same way}} as in a graph, using the Euclidean distance between pairs of points as the weight for each edge. Thus, for instance, a Euclidean minimum spanning tree is the same as a graph minimum spanning tree in a complete graph with Euclidean edge weights. However, it is not necessary to construct this graph in order to solve the optimization problem; the Euclidean minimum spanning tree problem, for instance, can be solved more efficiently in O(n log n) time by constructing the Delaunay triangulation and then applying a linear time planar graph minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> to the resulting triangulation.|$|E
40|$|Abstract. A {{topology}}-aware {{network is}} a dynamic network in which the nodes can detect whether locally topology changes occur. Many modern networks, like IEEE 1394. 1, are topology-aware networks. We present a distributed algorithm for computing and maintaining an arbitrary <b>spanning</b> <b>tree</b> in such a topology-aware network. Although usually minimal <b>spanning</b> <b>trees</b> are studied, in practice arbitrary <b>spanning</b> <b>trees</b> are often sufficient. Since our algorithm {{is not involved in}} the detection of topology changes, it performs better than the <b>spanning</b> <b>tree</b> <b>algorithms</b> in standards like IEEE 802. 1. Because reasoning about distributed algorithms is rather tricky, we use a systematic approach to prove our algorithm. ...|$|R
40|$|The minimum <b>spanning</b> <b>tree</b> {{clustering}} <b>algorithm</b> {{is capable}} of detecting clusters with irregular boundaries. In this {{paper we propose a}} novel minimum <b>spanning</b> <b>tree</b> based clustering <b>algorithm.</b> The algorithm produces k clusters with center and guaranteed intra-cluster similarity. The algorithm uses divisive approach to produce k number of clusters. The center points are considered as representative points for each cluster. These center points are connected and again minimum <b>spanning</b> <b>tree</b> is constructed. Using eccentricity of points the central cluster is identified from k number of cluster...|$|R
40|$|The {{ability to}} provide uniform shared-memory access to a {{significant}} number of processors in a single SMP node brings us much closer to the ideal PRAM parallel computer. Many PRAM algorithms can be adapted to SMPs with few modifications. Yet there are few studies that deal with the implemen-tation and performance issues of running PRAM algorithms on SMPs. Our study in this paper focuses on implementing parallel <b>spanning</b> <b>tree</b> <b>algorithms</b> on SMPs. <b>Spanning</b> <b>tree</b> is an important problem {{in the sense that it}} is the building block for many other parallel graph algorithms and also becaus...|$|R
50|$|Dijkstra {{thought about}} the {{shortest}} path problem when working at the Mathematical Center in Amsterdam in 1956 as a programmer to demonstrate the capabilities of a new computer called ARMAC. His objective was to choose both a problem {{as well as an}} answer (that would be produced by computer) that non-computing people could understand. He designed the shortest path algorithm and later implemented it for ARMAC for a slightly simplified transportation map of 64 cities in the Netherlands (64, so that 6 bits would be sufficient to encode the city number). A year later, he came across another problem from hardware engineers working on the institute's next computer: minimize the amount of wire needed to connect the pins on the back panel of the machine. As a solution, he re-discovered the algorithm known as Prim's minimal <b>spanning</b> <b>tree</b> <b>algorithm</b> (known earlier to Jarník, and also rediscovered by Prim). Dijkstra published the algorithm in 1959, two years after Prim and 29 years after Jarník.|$|E
40|$|Normally, Minimal <b>Spanning</b> <b>Tree</b> <b>algorithm</b> {{is used to}} nd the {{shortest}} route in a network. Neutrosophic set theory is used when incomplete, inconsistancy and indeterminacy occurs. In this paper, Bipolar Neutrosophic Numbers are used in Minimal <b>Spanning</b> <b>Tree</b> <b>algorithm</b> for nding {{the shortest}} path on a network when the distances are inconsistant and indeterminate and it is illustrated by a numerical example...|$|E
3000|$|... node-disjoint paths. In {{the process}} of computing, an augment path between any two nodes is found by Prim’s minimum <b>spanning</b> <b>tree</b> <b>algorithm.</b> If the graph G(V,E) is stored in the {{adjacency}} list, the complexity of Prim’s minimum <b>spanning</b> <b>tree</b> <b>algorithm</b> is O(m[*]+[*]n). After finding the augment paths, these paths are used to update the flow. The flow updating of each path in worst case take n- 1 times addition operation and subtraction operation, then the total time of finding the k [...]...|$|E
40|$|The minimum <b>spanning</b> <b>tree</b> {{clustering}} <b>algorithm</b> {{is capable}} of detecting clusters with irregular boundaries. In this paper we propose minimum <b>spanning</b> <b>trees</b> based clustering <b>algorithm.</b> The algorithm produces k clusters with center and it also creates a dendrogram for the k clusters. The algorithm works in two phases. The {{first phase of the}} algorithm produces subtrees. The second phase converts the subtrees into dendrogram. The key feature of the algorithm is it uses both divisive and agglomerative approaches to find Dual similarity clusters...|$|R
25|$|A <b>spanning</b> <b>tree</b> chosen {{randomly}} {{from among}} all the <b>spanning</b> <b>trees</b> with equal probability is called a uniform <b>spanning</b> <b>tree.</b> Wilson's <b>algorithm</b> {{can be used to}} generate uniform <b>spanning</b> <b>trees</b> in polynomial time by a process of taking a random walk on the given graph and erasing the cycles created by this walk.|$|R
40|$|Abstract We give {{a simple}} {{algorithm}} {{to find a}} <b>spanning</b> <b>tree</b> that simultaneously approximates a shortest-path tree and a minimum <b>spanning</b> <b>tree.</b> The <b>algorithm</b> provides a continuous trade-off: given the two trees and a fl? 0, the <b>algorithm</b> returns a <b>spanning</b> <b>tree</b> in which the distance between any vertex and {{the root of the}} shortest-path tree is at most 1 + p 2 fl times the shortest-path distance, and yet the total weight of the tree is at most 1 + p 2 =fl times the weight of a minimum <b>spanning</b> <b>tree.</b> Our <b>algorithm</b> runs in linear time and obtains the best-possible trade-off. It can be implemented on a CREW PRAM to run in logarithmic time using one processor per vertex...|$|R
