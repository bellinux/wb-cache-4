1|5483|Public
40|$|An {{important}} {{property of}} a client/server {{system is the}} independence of the interaction between the server and a client from the interactions that the server might have with other possible clients. In this paper we try to give a definition of such a property, that we called linearity, by means of the Process Algebra formalism. Through some examples of linear and non linear systems, we illustrate the expressiveness of our definition. Moreover, we present a sufficient condition for linearity and discuss the preservation of linearity w. r. t. process-algebraic operators applied to linear systems. 1 Introduction The growth of computer networks and distributed computing has {{led to the development of}} the client/server paradigm, which is widespread nowadays. A client/server system is a composite system which allows distributed computing, analysis and presentation [Si 92]. The client is a process (program) that sends a message to a <b>server</b> <b>process</b> (<b>program)</b> requesting that the latter performs a ta [...] ...|$|E
50|$|NSAPI can be {{compared}} to an earlier protocol named Common Gateway Interface (CGI). Like CGI, NSAPI provides a means of interfacing application software with a web server. Unlike CGI programs, NSAPI plug-ins run inside the <b>server</b> <b>process.</b> Because CGI <b>programs</b> run outside of the <b>server</b> <b>process,</b> CGI <b>programs</b> are generally slower than NSAPI plug-ins. However, running outside of the <b>server</b> <b>process</b> can improve <b>server</b> reliability by isolating potentially buggy applications from the server software and from each other.|$|R
40|$|Abstract:- {{research}} on the Web Services has rapidly developed in recent years. A Web Service is a technology that makes the distributed applications on a network cooperate by using the standard technology of the Internet compared with the Web site. It transforms the methods and the data tendered to it from WSDL into a utilizable class, an mutual transformation of data and communication processing with the <b>server</b> are <b>processed</b> by <b>programming</b> done in a traditional language (C#, Java, and Perl, etc.). Here however, we examine {{the construction of the}} Web Service based on ET (Equivalent Transformation) ...|$|R
40|$|This {{paper is}} on the {{construction}} of a server subsystem in a client/server system in an application context where the number of potential clients can be arbitrarily large. The implementation of the server is based on the well-known Triple Modular Redundancy (TMR) technique. The three <b>server</b> <b>processes</b> must process the client inputs in the same order to keep the server state consistent. While a client can fail by crashing and at least two <b>server</b> <b>processes</b> behave correctly, the third <b>server</b> <b>process</b> can behave in an arbitrary way. Moreover, the communication between clients and <b>server</b> <b>processes</b> is assumed reliable and the network can deliver the same client input to any two <b>server</b> <b>processes</b> within a known bounded time (D). There is also a known bound on the communication delay between every pair of correct <b>server</b> <b>processes</b> (d). In order to cope with client crash and <b>server</b> <b>process</b> failure, it is assumed that if a client input is deposited in the local memory of a <b>server</b> <b>process</b> at time t [...] ...|$|R
50|$|A <b>server</b> <b>process</b> is {{also said}} to be {{orphaned}} when the client that initiated the request unexpectedly crashes after making the request while leaving the <b>server</b> <b>process</b> running.|$|R
5000|$|The doors {{concept is}} very similar to X/Open XATMI API specification, where client <b>processes</b> invokes <b>server</b> <b>processes</b> exposed functions. Clients does the tpcall (...) just like a door_call (...) and <b>server</b> <b>processes</b> does tpreturn (...) just like a door_return (...) [...]|$|R
25|$|Each server machine runs {{multiple}} instances of the <b>server</b> <b>process.</b> Using a proprietary form of context-switching, the servers {{keep track of}} the state of each end user, allowing consecutive interactions from a single user to be handled by different <b>server</b> <b>processes.</b> The graphical user interface (GUI) code is also proprietary.|$|R
40|$|A {{design is}} {{presented}} for fault tolerant linearization of a concurrent data object in shared memory. <b>Server</b> <b>processes</b> may stop and restart functioning without notification, but always {{at least one}} member of each family of <b>server</b> <b>processes</b> makes progress. Then every client process that makes progress gets its transactions done within bounded delay. Invariants are used to prove the safety properties. The processes are tightly coupled but the separation into client processes and some families of <b>server</b> <b>processes</b> enables modularity in the design. Preservation of the invariants is proved {{by means of the}} theorem prover Nqthm of Boyer and Moore. ...|$|R
40|$|We apply {{a formal}} method based on assertions to specify and verify an atomic {{broadcast}} protocol. The protocol is implemented by replicating a <b>server</b> <b>process</b> on all processors in a network. First {{the requirements of}} the protocol are formally described. Next the underlying communication mechanism, the assumptions about local clocks, and the failure assumptions are axiomatized. Also the <b>server</b> <b>process</b> is represented by a formal specification. Then we verify that parallel execution of the <b>server</b> <b>processes</b> leads to the desired properties by proving that the conjunction of all server specifications and the axioms about the system implies {{the requirements of the}} protocol...|$|R
5000|$|Only the ColdFusion <b>server</b> <b>processes</b> CFScript. There is no {{client-side}} CFScript.|$|R
5000|$|... {{no threads}} or {{multiple}} <b>server</b> <b>processes</b> for handling multiple requests at once ...|$|R
30|$|The {{secondary}} <b>server(s)</b> <b>processes</b> {{the client}} requests and sends {{the response to}} the Dispatcher.|$|R
5000|$|Environment {{variables}} can {{be updated}} for XATMI <b>server</b> <b>processes</b> with out full application reboot.|$|R
50|$|In typical operation, each {{computer}} in a cluster runs its own {{instance of the}} Spread server, and client applications connect locally to that <b>server</b> <b>process.</b> The Spread <b>servers,</b> in turn, {{communicate with each other}} to pass messages to subscriber applications. It can also be configured so that clients distributed across the network all communicate with a Spread <b>server</b> <b>process</b> on one host.|$|R
5000|$|A <b>server</b> <b>process</b> first {{creates a}} named server {{connection}} port object, {{and waits for}} clients to connect.|$|R
30|$|Virtual <b>server</b> <b>processes</b> {{the remote}} {{view of the}} {{graphical}} desktop and sends it to the users via a secure link.|$|R
5000|$|Unlike Cristian's algorithm, the <b>server</b> <b>process</b> in the Berkeley algorithm, {{called the}} master, {{periodically}} polls other slave processes. Generally speaking, the algorithm is: ...|$|R
50|$|The NAMESERVER {{protocol}} {{is used by}} the DARPA Trivial Name <b>Server,</b> a <b>server</b> <b>process</b> called tnamed that {{is provided}} in some implementations of UNIX.|$|R
25|$|Apache HTTP Server as network server, WebDAV/Delta-V for protocol. There {{is also an}} {{independent}} <b>server</b> <b>process</b> called svnserve that uses a custom protocol over TCP/IP.|$|R
5000|$|NLTSS was a capability-based {{client-server}} system. The {{two primary}} servers were the file <b>server</b> and the <b>process</b> <b>server.</b> The file <b>server</b> was a <b>process</b> privileged {{to be trusted}} by the drivers for local storage (disk storage,) and the <b>process</b> <b>server</b> was a <b>process</b> privileged to be trusted by the processor driver (software that switched time sharing control between processes in the [...] "alternator", handled interrupts for processes besides the [...] "communicate" [...] call, provided access to memory and process state for the <b>process</b> <b>server,</b> etc.).|$|R
50|$|TeamSpeak 2 {{supports}} {{virtual server}} instancing. This allows up to 75 server instances to be contained in one <b>process</b> on the <b>server.</b> Additional <b>server</b> <b>processes</b> are possible.|$|R
5000|$|OpenXPKI {{is mostly}} written in Perl. The {{software}} is separated into a <b>server</b> <b>process</b> and several client implementations which {{communicate with the}} server via Unix Domain Sockets.|$|R
5000|$|SASEFAME:SAS {{provides}} an interface to FAME databases called SASEFAME. This provides dynamic {{read and write}} access between a SAS application and FAME databases or a FAME <b>server</b> <b>process</b> ...|$|R
5000|$|Uniface Router—a multi-threaded process {{responsible}} for interprocess communication in Uniface applications. It starts and stops Uniface <b>Server</b> <b>processes,</b> performs load balancing, and passing messages between various Uniface processes.|$|R
30|$|Pre-IME {{guard and}} services. Specifically, the pre-IME Guard runs as a trustlet in secure world and Android runs in normal world. The commit-proxy {{is a system}} service in Android System <b>Server</b> <b>process.</b> The Replay Executor is a daemon thread running in System <b>Server</b> <b>process.</b> Both of them are passively waiting to receive data from the pre-IME Guard. When a user types in the STIE, the pre-IME Guard {{receives}} keystrokes from touch screen and translates them into a char string. Corresponding to its sensitiveness, we return it through green path or red path. (see Fig.  8).|$|R
5000|$|Oracle WebLogic <b>Server</b> <b>Process</b> Edition also {{includes}} Business Process Management and Data Mapping functionality. WebLogic supports security policies managed by security administrators. The Oracle WebLogic Server Security Model includes: ...|$|R
50|$|User to PSRP server via PSRP client (using PSRP protocol). This {{communication}} mode establishes an asynchronous pseudotty {{connection between}} the psrp client (and hence the user) and the PSRP <b>server</b> <b>process.</b>|$|R
25|$|Btrieve for Netware was {{essentially}} the same as Btrieve for DOS with some extra features available only on Netware at the time. It ran a <b>server</b> <b>process,</b> called BSERVER, on the file-sharing server and this managed data I/O in conjunction with the network file system. The <b>server</b> <b>process</b> was first implemented as a Netware Value Added Process (VAP) called BSERVER.VAP, but was switched to a Netware NetWare Loadable Module (NLM) soon after. BSERVER was the database engine that dealt with access to records, however it also accepted requests for the transmission of requested data to another server via the BROUTER process.|$|R
50|$|The Helios kernel is {{effectively}} a micro-kernel, providing a minimal abstraction above the hardware with most services implemented as non-privileged <b>server</b> <b>processes.</b> It provides memory allocation, process management, message passing and synchronisation primitives.|$|R
50|$|In computing, {{configuration}} files (or config files) are files used {{to configure}} the parameters and initial settings for some computer programs. They {{are used for}} user applications, <b>server</b> <b>processes</b> and operating system settings.|$|R
50|$|Server-side scripts are {{completely}} <b>processed</b> by the <b>servers</b> instead of clients. When clients request a page containing server-side scripts, the applicable <b>server</b> <b>processes</b> the scripts and returns an HTML page to the client.|$|R
50|$|Each {{customer}} database {{is being}} started and stopped as an isolated database <b>server</b> <b>process</b> for the controlled management of CPU resources, RAM memory and disk storage. All databases share a single networked computing and storage infrastructure.|$|R
5000|$|The {{central part}} of the {{platform}} is the OpenWGA Server, a web <b>server</b> <b>process</b> responsible for publishing web applications. It itself is a web application of the Java Enterprise Edition Platform and is available in two editions: ...|$|R
50|$|In {{contrast}} to similar tools like Iperf or Netperf {{it features a}} distributed architecture, where throughput and othermetrics are measured between flowgrind <b>server</b> <b>processes.</b> The Flowgrind client hasthe purpose to schedule such measurements and collect the measurement data.|$|R
5000|$|A plugin system CherryPy plugins hook into events {{within the}} <b>server</b> <b>process</b> — into <b>server</b> startup, server shutdown, server exiting, etc. — to run code {{that needs to}} be run when the server starts up or shuts down.|$|R
5000|$|Concurrent {{database}} updates are not supported. The [...] "databases" [...] {{are currently}} {{designed to be}} written/modified by one process in isolation. Multiple processes can access a Gadfly database when accesses are arbitrated by a TCP/IP Gadfly <b>server</b> <b>process.</b>|$|R
