2534|2919|Public
25|$|DSC {{allows for}} declaratively specifying how a <b>software</b> <b>environment</b> should be configured.|$|E
25|$|R: A {{programming}} language and <b>software</b> <b>environment</b> for statistical computing, data mining, and graphics. It {{is part of}} the GNU Project.|$|E
25|$|Since its inception, DACS {{has been}} {{operated}} by various Defense contractors {{over the years}} and the library, and other resources constituting the DACS collection, have migrated to each contractor in turn. The objectives are essentially the same but the terminology used to define them has evolved as the <b>software</b> <b>environment</b> has changed. The means for improving the 'transfer of software engineering technology' now centers around use of web technology to deliver information to the mass community in electronic format, organized in ways that make it easy for the community to acquire and use the information.|$|E
40|$|Complex <b>software</b> <b>environments,</b> like virtual {{research}} environments or visualisation frameworks, are increasingly used {{to conduct research}} and present its results. While {{there is a growing}} amount for solutions facilitating the (granular) citation of publications and research data, the citation of complex <b>software</b> <b>environments</b> remains a challenge. This abstract outlines the challenges and introduces an approach for referencing <b>software</b> <b>environments</b> developed in the Humanities Data Centre project: the application preservation...|$|R
5000|$|Organization of {{distributed}} software tools into modular, extensive-wide <b>software</b> <b>environments</b> ...|$|R
40|$|<b>Software</b> <b>environments</b> {{support the}} process of {{constructing}} and maintaining application systems. This paper describes {{the idea of a}} thesaurus 1 as a viable foundation for <b>software</b> <b>environments.</b> A thesaurus contains information about the names and identifiers in all the software written in all the languages of an application. Information about extensional dat...|$|R
25|$|Beginning in {{the late}} 1980s, an open {{operating}} system standardization effort now known as POSIX provided a common baseline for all operating systems; IEEE based POSIX around the common structure of the major competing variants of the Unix system, publishing the first POSIX standard in 1988. In the early 1990s, a separate but very similar effort was started by an industry consortium, the Common Open <b>Software</b> <b>Environment</b> (COSE) initiative, which eventually became the Single UNIX Specification (SUS) administered by The Open Group. Starting in 1998, the Open Group and IEEE started the Austin Group, to provide a common definition of POSIX and the Single UNIX Specification, which, by 2008, had become the Open Group Base Specification.|$|E
500|$|The {{need for}} a more modernized method for {{forecasting}} tropical cyclones had become apparent by the mid-1980s. At that time Department of Defense was using acetate, grease pencils, and disparate computer programs to forecast tropical cyclones. [...] The ATCF software {{was developed by the}} Naval Research Laboratory for the Joint Typhoon Warning Center (JTWC) beginning in 1986, and used since 1988. During 1990 the system was adapted by the National Hurricane Center (NHC) for use at the NHC, National Centers for Environmental Prediction and the Central Pacific Hurricane Center. This provided the NHC with a multitasking <b>software</b> <b>environment</b> which allowed them to improve efficiency and cut the time required to make a forecast by 25% or 1 hour. ATCF was originally developed for use within DOS, before later being adapted to Unix and Linux.|$|E
500|$|Historically, {{tropical}} cyclone tracking charts {{were used to}} include the past track and prepare future forecasts at Regional Specialized Meteorological Centers and Tropical Cyclone Warning Centers. [...] The need for a more modernized method for forecasting {{tropical cyclone}}s had become apparent to operational weather forecasters by the mid-1980s. At that time the United States Department of Defense was using paper maps, acetate, grease pencils, and disparate computer programs to forecast tropical cyclones. [...] The Automated Tropical Cyclone Forecasting System (ATCF) software {{was developed by the}} Naval Research Laboratory for the Joint Typhoon Warning Center (JTWC) beginning in 1986, and used since 1988. During 1990 the system was adapted by the National Hurricane Center (NHC) for use at the NHC, National Centers for Environmental Prediction and the Central Pacific Hurricane Center. This provided the NHC with a multitasking <b>software</b> <b>environment</b> which allowed them to improve efficiency and cut the time required to make a forecast by 25% or 1 hour. ATCF was originally developed for use within DOS, before later being adapted to Unix and Linux.|$|E
40|$|This paper serves two goals. First, we {{advocate}} real-world <b>software</b> <b>environments,</b> such as operating sys-tems or databases, as domains {{for planning}} research. Second, we describe our ongoing research on planning with incomplete information. In both cases, we fo-cus on the UNIX planning domain as a testbed for our implementation {{and a source}} of concrete examples and intuitions. l%eal-world <b>software</b> <b>environments,</b> such as UNIX, have a number of attractive features as testbeds for plan-ning research. First, it is relatively easy to develop "embodied agents, " which interact directly with a soft-ware environment by issuing commands and interpret-ing the environment’s feedback [6]. Such agents facil-itate testing planners experimentally and integrating planning with execution and error recovery capabili-ties. Second, <b>software</b> <b>environments</b> circumvent many thorny, but peripheral, research issues that have to be addressed in physical environments (e. g., overcoming sensor noise, representing liquids, shapes, etc.). Third, software experiments are relatively easy to perform, control, and repeat, facilitating systematic experimen-tal research of the sort advocated by [10] and oth-ers. Finally, software facilitates the dissemination and replication of research results. It is straightforward to distribute multiple copies of a software agent, and many <b>software</b> <b>environments</b> (e. g., UNIX) are easily accessible to most researchers. Simulated worlds share some of these features but, <b>software</b> <b>environments</b> are readily available (sophisti-cated simulations can take years to develop and per-fect). Furthermore, <b>software</b> <b>environments</b> are real. *We thank Richard Segal, our co-softboticist, for his numerous contributions to this research. Thanks are als...|$|R
5000|$|Xsede <b>Software</b> <b>Environments.</b> The Extreme Science and Engineering Discovery Environment ― National Science Foundation ...|$|R
40|$|Software Shaping Workshops are <b>software</b> <b>environments</b> {{that support}} various {{activities}} of End-User Development (EUD) and tailoring. The work described here introduces {{a perspective on}} system tailoring, distinguishing between tailored and tailorable <b>software</b> <b>environments.</b> Such environments are tailored by the developers to the work context, culture, experience, and skills of users; they are also tailorable by the users at runtime in order to adapt them to the specific work situation. The approach is illustrated with reference to cooperative work that is performed in a medical domain...|$|R
2500|$|... 4K {{streaming}} {{requires a}} 4K-compatible device and display, both supporting HDCP 2.2. 4K streaming on personal computers requires {{hardware and software}} support of the Microsoft PlayReady 3.0 digital rights management solution, which requires a compatible CPU, graphics card, and <b>software</b> <b>environment.</b> Currently, this feature is limited to Intel Kaby Lake (seventh-generation Intel Core), Windows 10, Nvidia Geforce 10 series graphics cards, and running through Microsoft Edge web browser, or the UWP Netflix app.|$|E
2500|$|...NET Framework (pronounced dot net) is a {{software}} framework developed by Microsoft that runs primarily on Microsoft Windows. It includes a large class library named Framework Class Library (FCL) and provides language interoperability (each language can use code written in other languages) across several programming languages. Programs written for [...]NET Framework execute in a <b>software</b> <b>environment</b> (in {{contrast to a}} hardware environment) named Common Language Runtime (CLR), an application virtual machine that provides services such as security, memory management, and exception handling. (As such, computer code written using [...]NET Framework is called [...] "managed code".) FCL and CLR together constitute [...]NET Framework.|$|E
2500|$|The Internet {{protocol}} suite does not presume any specific hardware or <b>software</b> <b>environment.</b> [...] It only requires that hardware and a software layer exists that {{is capable of}} sending and receiving packets on a computer network. As a result, the suite has been implemented on essentially every computing platform. A minimal implementation of TCP/IP includes the following: Internet Protocol (IP), Address Resolution Protocol (ARP), Internet Control Message Protocol (ICMP), Transmission Control Protocol (TCP), User Datagram Protocol (UDP), and Internet Group Management Protocol (IGMP). In addition to IP, ICMP, TCP, UDP, Internet Protocol version 6 requires Neighbor Discovery Protocol (NDP), ICMPv6, and IGMPv6 and is often accompanied by an integrated IPSec security layer.|$|E
5000|$|Dynamic {{generation}} of formatted user interfaces in <b>software</b> <b>environments,</b> and Modeling delay using a discrete event execution modeling environment.|$|R
50|$|Many {{training}} centres used Microsoft software (the applications used {{are shown in}} parenthesis) but other <b>software</b> <b>environments</b> could be used, such as Apache OpenOffice/LibreOffice.|$|R
50|$|The toolkit {{consists}} of a messaging server, and client libraries for many <b>software</b> development <b>environments,</b> including C/C++ libraries (with and without thread support), a Java class {{to be used by}} applets or applications, and interfaces for Perl, Python, and Ruby. Interfaces for many other <b>software</b> <b>environments</b> have been provided by third parties.|$|R
2500|$|Standard device drivers can be {{difficult}} to write because they must handle a very wide range of system and device states, particularly in a multithreaded <b>software</b> <b>environment.</b> [...] Badly written device drivers can cause severe damage to a system (e.g., BSoD and data corruption) since all standard drivers have high privileges when accessing the kernel directly. The User-Mode Driver Framework insulates the kernel from the problems of direct driver access, instead providing a new class of driver with a dedicated application programming interface at the user level of interrupts and memory management. If an error occurs, the new framework allows for an immediate driver restart without impacting the system. [...] This is particularly useful for devices that are intermittently connected to the system or support hot swapping via a bus technology such as USB or Firewire.|$|E
2500|$|The STI Design Center {{opened in}} March 2001. The Cell was {{designed}} {{over a period}} of four years, using enhanced versions of the design tools for the POWER4 processor. Over 400 engineers from the three companies worked together in Austin, with critical support from eleven of IBM's design centers. During this period, IBM filed many patents pertaining to the Cell architecture, manufacturing process, and <b>software</b> <b>environment.</b> An early patent version of the Broadband Engine was shown to be a chip package comprising four [...] "Processing Elements", which was the patent's description for what is now known as the Power Processing Element (PPE). Each Processing Element contained 8 APUs, which are now referred to as SPEs on the current Broadband Engine chip. This chip package was widely regarded to run at a clock speed of 4GHz and with 32 APUs providing 32gigaFLOPS each(FP8 quarter precision), the Broadband Engine was shown to have 1 teraFLOPS of raw computing power. This design was fabricated using a 90nm SOI process.|$|E
5000|$|Combines hardware, <b>software,</b> <b>environment,</b> {{and human}} {{interaction}} ...|$|E
40|$|Distributed <b>software</b> <b>environments</b> are {{increasingly}} com-plex {{and difficult to}} manage, as they integrate various legacy software with specific management interfaces. More-over, the fact that management tasks are performed by hu-mans leads to many configuration errors and low reactiv-ity. This is particularly true in medium or large-scale grid infrastructures. To address this issue, we developed Jade, a middleware for self-management of distributed <b>software</b> <b>environments.</b> In this paper, we report on our experiments in using Jade {{for the management of}} grid applications. ...|$|R
40|$|The GUPRO {{approach}} to support program understanding in heterogeneous <b>software</b> <b>environments</b> is presented. GUPRO is {{an acronym for}} Generic Understanding of PROgrams. A tool of the GUPRO family consists of a parsing component which translates source code into a repository together with a source code independent query component. Since the repository can be defined for different languages on arbitrary levels of granularity a generic program understanding tool is given. Thus, also heterogeneous <b>software</b> <b>environments</b> using various programming languages can be analysed...|$|R
40|$|In {{his recent}} papers, {{entitled}} "Intelligence without Representation and "Intelligence without Reason," Brooks argues for studying complete agents in real-world environments and for mobile robots {{as the foundation}} for AI research. This article argues that, even if we seek to investigate complete agents in real-world environments, robotics is neither necessary nor sufficient as a basis for AI research. The article proposes real-world <b>software</b> <b>environments,</b> such as operating systems or databases, as a complementary substrate for intelligent-agents research, and considers the relative advantages of <b>software</b> <b>environments</b> as testbeds for AI. First, the cost, effort, and expertise necessary to develop and systematically experiment with software artifacts are relatively low. Second, <b>software</b> <b>environments</b> circumvent many thorny, but peripheral, research issues that are inescapable in physical environments. Brooks's mobile robots tug AI towards a bottom-up focus in which the mechanics of percept [...] ...|$|R
5000|$|... #Subtitle level 3: Computational Systems and <b>Software</b> <b>Environment</b> ...|$|E
5000|$|... "E-CELL: <b>Software</b> <b>environment</b> for whole cell simulation", Bioinformatics 1999; 15:72-84 ...|$|E
50|$|DSC {{allows for}} declaratively specifying how a <b>software</b> <b>environment</b> should be configured.|$|E
50|$|The upshot is that SDVO {{cards are}} {{compatible}} with a narrow range of Intel-only hardware platforms, but {{a broad range of}} <b>software</b> <b>environments</b> within that platform.|$|R
40|$|Intelligence without Reason, ” Brooks {{argues for}} mobile robots as the {{foundation}} of AI research. This article argues that even if we seek to investigate complete agents in real-world environments, robotics is neither necessary nor sufficient as a basis for AI research. The article proposes real-world <b>software</b> <b>environments,</b> such as operating systems or databases, as a complementary substrate for intelligent-agent research and considers the relative advantages of <b>software</b> <b>environments</b> as test beds for AI. First, the cost, effort, and expertise necessary to develop and systematicall...|$|R
40|$|International audienceDistributed <b>software</b> <b>environments</b> are {{increasingly}} complex {{and difficult to}} manage, as they integrate various legacy software with proprietary management interfaces. Moreover, the fact that management tasks are performed by humans leads to many configuration errors and low reactivity. This paper presents Jade, a middleware for self-management of distributed <b>software</b> <b>environments.</b> The main principle is to wrap legacy software pieces in components {{in order to provide}} a uniform management interface, thus allowing the implementation of management applications. Management applications are used to deploy distributed applications and to autonomously reconfigure them as require...|$|R
50|$|The FAME <b>software</b> <b>environment</b> {{had several}} {{development}} phases during its long history.|$|E
5000|$|HeuristicLab, a <b>software</b> <b>environment</b> for {{heuristic}} {{and evolutionary}} algorithms, including symbolic regression ...|$|E
5000|$|... using multiphysics {{numerical}} simulation <b>software</b> <b>environment</b> (e.g. Comsol Multiphysics , Ansys Workbench [...] ) ...|$|E
3000|$|Infrastructure dependability—how {{dependable}} are {{the underlying}} infrastructure components (e.g., sensors, networks, actuators, computing/storage elements, <b>software</b> <b>environments)</b> {{in the presence}} of diverse failures that may lead to disruptions, and [...]...|$|R
40|$|AI {{is moving}} away from "toy tasks" such as block {{stacking}} towards real-world problems. This trend is positive, but the amount of preliminary groundwork required to tackle a real-world task can be staggering, particularly when developing an integrated agent architecture. To address this problem, we advicate real-world <b>software</b> <b>environments,</b> such as operating systems or databases, as domains for agent research. The cost, effort, and expertise required to develop and systematically experiment with software agents is relatively low. Furthermore, <b>software</b> <b>environments</b> circumvent many thorny, but peripheral, research issues that are inescapable in other <b>environments.</b> Thus, <b>software</b> <b>environments</b> enable us to test agents ina real world yet focus on core AI research issues. To support this claim, we describe our project to develop UNIX softbots (software robots) [...] intelligent agnets that interact with UNIX. Existing softbots accept a diverse set of high-level goals, generate and execute plans to achieve these goals in real time, and recover from errors when necessary...|$|R
40|$|End-user {{development}} {{means the}} active participation of end {{users in the}} software development process. In this perspective, tasks that are traditionally performed by professional software developers at design time are transferred to end users at use time. This creates a new challenge for software engineers: designing software systems that can be evolved by end users. Metadesign, a new design paradigm discussed in this chapter, {{is regarded as a}} possible answer to this challenge. In this line, we have developed a metadesign methodology, called Software Shaping Workshop methodology, that supports user work practice and allows experts in a domain to personalize and evolve their own <b>software</b> <b>environments.</b> We illustrate the Software Shaping Workshop methodology and describe its application to a project in the medical domain. The work proposes a new perspective on system personalization, distinguishing between customization and tailoring of <b>software</b> <b>environments.</b> The <b>software</b> <b>environments</b> are customized by the design team to the work context, culture, experience, and skills of the user communities; they are also tailorable by end users at runtime in order to adapt them to the specific work situation and users’ preferences and habits. The aim is to provide the physicians with <b>software</b> <b>environments</b> that are easy to use and adequate for their tasks, capable to improve their work practice and determine an increase in their productivity and performance...|$|R
