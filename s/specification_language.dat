4701|2497|Public
25|$|In the Z formal <b>specification</b> <b>language,</b> braces denote a set and angle {{brackets}} denote a sequence.|$|E
2500|$|Requires Java Modeling Language (JML) {{behavioral}} interface <b>specification</b> <b>language.</b>|$|E
2500|$|IEC 60848: 2002, GRAFCET <b>specification</b> <b>language</b> for {{sequential}} function charts ...|$|E
40|$|Data Types............................. 50 4. 5. 4 Special Approaches.................................... 50 4. 6 Semantics of Programming Languages............................. 52 4. 6. 1 Semantics of Ada..................................... 52 4. 6. 2 Action Semantics..................................... 52 4. 7 <b>Specification</b> <b>Languages.....................................</b> 53 4. 7. 1 Early Algebraic <b>Specification</b> <b>Languages........................</b> 53 4. 7. 2 Recent Algebraic <b>Specification</b> <b>Languages.......................</b> 55 4. 7. 3 The Common Framework Initiative........................... 56 5 Methodology 57 5. 1 Development Phases....................................... 57 5. 1. 1 Applica [...] ...|$|R
40|$|Separation of {{concerns}} or aspects is nowadays {{recognized as an}} important issue in software engineering, both at the programming and at the design/specification level. The goal of mixed <b>specification</b> <b>languages</b> is {{to take into account}} all - or at least several - aspects of systems. We found out from our experience that a lot of mixed <b>specification</b> <b>languages</b> do share most of their features. However, specific theories, such as the symbolic transition systems one, still have to be studied for several families of mixed <b>specification</b> <b>languages.</b> In this paper we propose a logic for mixed specifications that aims at providing a proposal to give an abstract denotational semantics for mixed <b>specification</b> <b>languages...</b>|$|R
40|$|AbstractThe paper proposes an axiomatic {{approach}} to <b>specification</b> <b>languages,</b> and introduces notions of reducibility and equivalence as tools for their study and comparison. Algebraic <b>specification</b> <b>languages</b> are characterized up to equivalence. They are {{shown to be}} limited in expressive power by implicational languages...|$|R
2500|$|TLA+ (pronounced as tee ell a plus, [...] ) is {{a formal}} <b>specification</b> <b>language</b> {{developed}} by Leslie Lamport. It {{is used to}} design, model, document, and verify concurrent systems. TLA+ {{has been described as}} exhaustively-testable pseudocode ...|$|E
2500|$|Spec# is a dialect of C# that is {{developed}} {{in parallel with}} the standard implementation from Microsoft. It extends C# with <b>specification</b> <b>language</b> features and is a possible future feature to the C# language. It also adds syntax for the code contracts API that was introduced in [...]NET Framework 4.0. Spec# is being developed by Microsoft Research.|$|E
2500|$|This example shows a {{specification}} in readable language {{embedded in}} executable code. In {{this case a}} choice of the tool is to formalize the <b>specification</b> <b>language</b> into {{the language of the}} test code by adding methods named it and should. Also there is the concept of a specification precondition [...] the before section establishes the preconditions that the specification is based on.|$|E
5000|$|The {{following}} prominent <b>specification</b> <b>languages</b> {{are currently}} supported: ...|$|R
40|$|In recent years, {{object-oriented}} design and formal <b>specification</b> <b>languages</b> {{have become increasingly}} important {{in the development of}} software systems. In this paper we use the formal <b>specification</b> <b>languages</b> OBJ 1 and OBJ 3 to investigate {{the extent to which they}} support {{object-oriented design}} in general and inheritance in particular...|$|R
40|$|AbstractSeparation of {{concerns}} or aspects is nowadays {{recognized as an}} important issue in software engineering, both at the programming and at the design/specification level. The goal of mixed <b>specification</b> <b>languages</b> (e. g. SDL, value-passing process algebras such as extensions of CSP or full-LOTOS, Korrigan) is {{to take into account}} all - or at least several - aspects of systems. We found out from our experience that a lot of mixed <b>specification</b> <b>languages</b> do share most of their features. However, specific theories, such as the symbolic transition systems one, still have to be studied for several families of mixed <b>specification</b> <b>languages.</b> In this paper we propose a logic with an expressive temporal gluing mechanism. This logic aims at providing an abstract denotational semantics for mixed <b>specification</b> <b>languages.</b> This logic enables one to reason about mixed specifications at a high level, without targeting a specific model or language. We show how our logic can be seen as an institution, which has the benefits of enabling a common refinement theory for mixed <b>specification</b> <b>languages...</b>|$|R
2500|$|... is a CSP {{analysis}} tool {{developed in}} the School of Computing at the National University of Singapore. PAT is able to perform refinement checking, LTL model-checking, and simulation of CSP and Timed CSP processes. The PAT process language extends CSP with support for mutable shared variables, asynchronous message passing, {{and a variety of}} fairness and quantitative time related process constructs such as deadline and waituntil. The underlying design principle of the PAT process language is to combine a high-level <b>specification</b> <b>language</b> with procedural programs (e.g. an event in PAT may be a sequential program or even an external C# library call) for greater expressiveness. Mutable shared variables and asynchronous channels provide a convenient syntactic sugar for well-known process modelling patterns used in standard CSP. The PAT syntax is similar, but not identical, to CSPM. The principal differences between the PAT syntax and standard CSPM are the use of semicolons to terminate process expressions, the inclusion of syntactic sugar for variables and assignments, and the use of slightly different syntax for internal choice and parallel composition.|$|E
5000|$|RAISE <b>Specification</b> <b>Language,</b> {{described}} as a wide-spectrum <b>specification</b> <b>language</b> ...|$|E
5000|$|Resource <b>Specification</b> <b>Language</b> (See The Globus Resource <b>Specification</b> <b>Language</b> RSL v1.0) ...|$|E
40|$|Abstract- This paper {{constitutes}} a state-of-the art of <b>specification</b> <b>languages</b> relevant {{to be used}} as front-ends towards the DEVS (Discrete EVent System Specification) formalism. Comparison criteria are defined to evaluate <b>specification</b> <b>languages</b> for the description of DEVS structures. Finally, the need for building an original front-end, accounting for the whole criteria, is discussed...|$|R
40|$|Abstract. We present <b>specification</b> <b>languages</b> that {{naturally}} capture exactly the regular and ω-regular properties that are stutter invariant. Our <b>specification</b> <b>languages</b> are variants {{of the classical}} regular expressions and of the core of PSL, a temporal logic, which is widely used in industry and which extends the classical linear-time temporal logic LTL by semi-extended regular expressions. ...|$|R
40|$|Formal <b>specification</b> <b>languages</b> are mathematically based {{techniques}} with welldefined syntax and semantics {{to describe}} system properties. The {{application of a}} specific technique depends {{on the type of}} the system to be specified. In this paper, we present a classification of the formal <b>specification</b> <b>languages</b> based on the type of programs for which each technique is best suitable...|$|R
50|$|The Common Algebraic <b>Specification</b> <b>Language</b> (CASL) is a {{general-purpose}} <b>specification</b> <b>language</b> {{based on}} first-order logic with induction. Partial functions and subsorting are also supported.|$|E
50|$|ACSL is a Behavioral Interface <b>Specification</b> <b>Language</b> (BISL). It aims at specifying {{behavioral}} {{properties of}} C source code. The main inspiration for this language {{comes from the}} <b>specification</b> <b>language</b> of the Caduceus tool for deductive verification of behavioral properties of C programs. The <b>specification</b> <b>language</b> of Caduceus is itself inspired from JML which aims at similar goals for Java source code.|$|E
5000|$|Alloy (<b>specification</b> <b>language)</b> is {{a general}} purpose <b>specification</b> <b>language</b> for expressing complex {{structural}} constraints and behavior in a software system. It provides a concise language base on first-order relational logic.|$|E
40|$|This work {{provides}} a general integration mechanism for <b>specification</b> <b>languages</b> motivated by partial specification. We use category theory to formalise <b>specification</b> <b>languages</b> and define a relational semantic framework. We show some inherent {{limits of the}} approach, and propose a solution inspired from Z semantics to overcome it. An integration of Z and CCS is considered as an example...|$|R
5000|$|Hybrid systems: optimal control, {{observers}} and observability, and <b>specification</b> <b>languages</b> for hybrid systems.|$|R
5000|$|Several formal <b>specification</b> <b>languages</b> include {{set theory}} {{notation}} using special characters. Examples are: ...|$|R
5000|$|... #Article: Document Style Semantics and <b>Specification</b> <b>Language</b> ...|$|E
5000|$|P1850 Standard for PSL: Property <b>Specification</b> <b>Language</b> (IEEE-1850) ...|$|E
5000|$|<b>Specification</b> <b>Language</b> for Internet Communications Engine (Ice: Slice) ...|$|E
5000|$|LTSmin - {{open source}} model checker for various <b>specification</b> <b>languages</b> (Promela, mCRL2, UPPAAL language) ...|$|R
40|$|Business {{transactions}} {{are prone to}} failure and {{having to deal with}} unexpected situations. Some business process <b>specification</b> <b>languages,</b> e. g. StAC, introduce notions like compensation handling. Given the need of verification of correctness in business related software, it is important to fill in the gap between business process <b>specification</b> <b>languages</b> like StAC and the verification software already available. We repor...|$|R
40|$|Abstract. Separation of {{concerns}} or aspects is nowadays {{recognized as an}} important issue in software engineering, both at the programming and at the design/specification level. The goal of mixed <b>specification</b> <b>languages</b> is {{to take into account}} all- or at least several- aspects of systems. We found out that a lot of mixed <b>specification</b> <b>languages</b> do share most of their features. However, specific theories, such as the symbolic transition systems one, still have to be studied for several families of mixed <b>specification</b> <b>languages.</b> Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed <b>specification</b> <b>languages.</b> This logic enables one to reason about a specification at a high level, abstracting away from implementation details and without targetting a specific (often initial) model. 1 Research Area – Main Themes In the last few years, the need for a separation {{of concerns}} with reference t...|$|R
50|$|Assertions {{are useful}} for verifying {{properties}} of a design that manifest themselves after a specific condition or state is reached. SystemVerilog has its own assertion <b>specification</b> <b>language,</b> similar to Property <b>Specification</b> <b>Language.</b> The subset of SystemVerilog language constructs that serves assertion is commonly called SystemVerilog Assertion or SVA.|$|E
50|$|The ANSI/ISO C <b>Specification</b> <b>Language</b> (ACSL) is a <b>specification</b> <b>language</b> for C programs, using Hoare style pre- and postconditions and invariants, {{that follows}} the design by {{contract}} paradigm. Specifications are written as C annotation comments to the C program, which hence can be compiled with any C compiler.|$|E
5000|$|Requires Java Modeling Language (JML) {{behavioral}} interface <b>specification</b> <b>language.</b>|$|E
2500|$|Several other <b>specification</b> <b>languages</b> and formalisms {{have been}} derived from, or {{inspired}} by, the classic untimed CSP, including: ...|$|R
50|$|An {{important}} use of <b>specification</b> <b>languages</b> is {{enabling the}} creation of proofs of program correctness (see theorem prover).|$|R
5000|$|Several other <b>specification</b> <b>languages</b> and formalisms {{have been}} derived from, or {{inspired}} by, the classic untimed CSP, including: ...|$|R
