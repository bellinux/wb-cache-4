989|535|Public
25|$|PGP {{can be used}} to send {{messages}} confidentially. For this, PGP combines symmetric-key encryption and public-key encryption. The message is encrypted using a symmetric encryption algorithm, which requires a symmetric key. Each symmetric key is used only once and is also called a <b>session</b> <b>key.</b> The message and its <b>session</b> <b>key</b> are sent to the receiver. The <b>session</b> <b>key</b> must be sent to the receiver so they know how to decrypt the message, but to protect it during transmission it is encrypted with the receiver's public key. Only the private key belonging to the receiver can decrypt the <b>session</b> <b>key.</b>|$|E
25|$|This concludes the {{handshake}} {{and begins}} the secured connection, which is encrypted and decrypted with the <b>session</b> <b>key</b> until the connection closes. If {{any one of}} the above steps fails, then the TLS handshake fails and the connection is not created.|$|E
25|$|Passwords are {{protected}} in memory while KeePass is running. On Windows Vista and later versions, passwords are encrypted in process memory using Windows Data Protection API, which allows storing {{the key for}} memory protection in a secure, non-swappable memory area. On previous Windows systems, KeePass falls back to using the ARC4 cipher with a temporary, random <b>session</b> <b>key.</b>|$|E
3000|$|... [*]' queries and answers. The {{method for}} {{protecting}} the information {{is to use the}} bounded-time with the <b>session</b> <b>keys</b> for each individual auditing-service. The CSP releases the <b>session</b> <b>keys</b> with the bounded-time for each auditing service. Once the auditing service is completed, the <b>session</b> <b>keys</b> will be returned and will not be regenerated until the CSP releases another poll of <b>session</b> <b>keys.</b>|$|R
40|$|In many {{applications}} [...] . In this paper, we adopt a common model where <b>session</b> <b>keys</b> are issued and distributed by a central group controller (GC). The resources {{needed for the}} GC to distribute <b>session</b> <b>keys</b> to group members include communication, storage and computation resources. The communication complexity is usually measured {{by the number of}} data bits that need to be transmitted from the GC to group members to convey information of <b>session</b> <b>keys,</b> while the storage complexity is measured by the number of data bits that the GC and group members need to store to obtain <b>session</b> <b>keys,</b> and the computation complexity is measured by the computation the GC and group member need to perform to derive <b>session</b> <b>keys.</b> Hereafter, {{the problem of how to}} effectively use resources to distribute <b>session</b> <b>keys</b> is referred to as the group key distribution problem [...] ...|$|R
3000|$|We prove Theorem 3.1 using similar {{techniques}} {{as described in}} [19]. We define a series of hybrid experiments. In each experiment, we modify the way <b>session</b> <b>keys</b> are chosen for instances involved in protocol execution. We start by choosing random <b>session</b> <b>keys</b> for instances for which the Execute oracle is called. Then, we continue to choose random <b>session</b> <b>keys</b> for instances for which the Send oracle is called. These instances are gradually changed over five hybrid experiments {{and in the last}} experiment, all the <b>session</b> <b>keys</b> are selected uniformly at random. Thus, the adversary [...]...|$|R
25|$|The 2013 mass {{surveillance}} disclosures made it {{more widely}} known that IIS is particularly bad in supporting perfect forward secrecy (PFS), especially when {{used in conjunction with}} Internet Explorer. Possessing one of the long term asymmetric secret keys used to establish a HTTPS session should not make it easier to derive the short term <b>session</b> <b>key</b> to then decrypt the conversation, even at a later time. Diffie–Hellman key exchange (DHE) and elliptic curve Diffie–Hellman key exchange (ECDHE) are in 2013 the only ones known to have that property. Only 30% of Firefox, Opera, and Chromium Browser sessions use it, and nearly 0% of Apple's Safari and Microsoft Internet Explorer sessions.|$|E
25|$|Forward secrecy is a {{property}} of cryptographic systems which ensures that a <b>session</b> <b>key</b> {{derived from a}} set {{of public and private}} keys will not be compromised if one of the private keys is compromised in the future. Without forward secrecy, if the server's private key is compromised, not only will all future TLS-encrypted sessions using that server certificate be compromised, but also any past sessions that used it as well (provided of course that these past sessions were intercepted and stored at the time of transmission). An implementation of TLS can provide forward secrecy by requiring the use of ephemeral Diffie-Hellman key exchange to establish session keys, and some notable TLS implementations do so exclusively: e.g., Gmail and other Google HTTPS services that use OpenSSL. However, many clients and servers supporting TLS (including browsers and web servers) are not configured to implement such restrictions. In practice, unless a web service uses Diffie-Hellman key exchange to implement forward secrecy, all of the encrypted web traffic to and from that service can be decrypted by a third party if it obtains the server's master (private) key; e.g., by means of a court order.|$|E
2500|$|... encrypts {{a random}} number with the server's public key and sends the result to the server (which only the server {{should be able}} to decrypt with its private key); both parties then use the random number to {{generate}} a unique <b>session</b> <b>key</b> for subsequent encryption and decryption of data during the session ...|$|E
50|$|Note {{that there}} is a {{difference}} between master <b>keys</b> and <b>session</b> <b>keys.</b> Master keys are long-lived and usually work as a shared secret or a means to distribute <b>session</b> <b>keys,</b> which in turn do not outlive the connection for which they were created and usually serve as the functional encryption/decryption mechanism. A specific header field indicates which of the possible keys is to be used. It is also important to note that replay prevention mechanisms require the keeping of counters which are updated on valid receptions. The range of these counters further limits the life of <b>session</b> <b>keys.</b>|$|R
5000|$|Pseudo-random number {{generator}} (PRNG) which generates <b>session</b> <b>keys</b> ...|$|R
50|$|Like all {{cryptographic}} <b>keys,</b> <b>session</b> <b>keys</b> must {{be chosen}} {{so that they}} cannot be predicted by an attacker, usually requiring them to be chosen randomly. Failure to choose <b>session</b> <b>keys</b> (or any key) properly is a major (and too common in actual practice) design flaw in any crypto system.|$|R
2500|$|... uses Diffie-Hellman key {{exchange}} to securely {{generate a}} random and unique <b>session</b> <b>key</b> for encryption and decryption {{that has the}} additional property of forward secrecy: if the server's private key is disclosed in future, it cannot be used to decrypt the current session, even if the session is intercepted and recorded by a third party.|$|E
2500|$|The 1940s were an {{unstable}} {{period for the}} OBP, with a [...] "senate" [...] (as its sponsoring organization was called) existing in name only and a weak premier {{who had to be}} replaced soon after the 16th <b>Session.</b> <b>Key</b> alumni and strong premiers with good cabinets carried the OBP through the late 1940s when a proper [...] "Senate" [...] and well founded Parliament were established.|$|E
5000|$|Message F: Client/Server <b>Session</b> <b>Key</b> {{encrypted}} {{with the}} Client/TGS <b>Session</b> <b>Key.</b>|$|E
50|$|With {{the unusually}} large block size of 4096 bits, all of FEA-M's {{calculations}} operate on 64&times;64 binary matrices. Unlike most block ciphers, FEA-M {{does not use}} multiple rounds of encryption. Each block is encrypted using just two multiplications and two additions. The data is encrypted using a pair of <b>session</b> <b>keys</b> chosen for just that message. The key is an invertible matrix used to encrypt the <b>session</b> <b>keys,</b> and the encrypted <b>session</b> <b>keys</b> must be sent along with the ciphertext. Since only invertible matrices {{can be used for}} the key, the effective key size is about 4094.2 bits.|$|R
2500|$|To {{generate}} the <b>session</b> <b>keys</b> {{used for the}} secure connection, the client either: ...|$|R
40|$|Abstract. The {{version of}} Kerberos {{presented}} by Burrows et al. [5] is fully mechanised using the Inductive Method. Two models are presented, allowing respectively the leak of any <b>session</b> <b>keys,</b> and of expired <b>session</b> <b>keys.</b> Thanks to timestamping, the protocol provides the involved parties with strong guarantees in a realistically hostile environment. These guarantees {{are supported by}} the generic theorem prover Isabelle. ...|$|R
50|$|On each login session, Skype {{generates a}} <b>session</b> <b>key</b> from 192 random bits. The <b>session</b> <b>key</b> is {{encrypted}} with the hard-coded login server's 1536-bit public RSA key {{to form an}} encrypted <b>session</b> <b>key.</b> Skype also generates a 1024-bit private/public RSA key pair. An MD5 hash of a concatenation of the user name, constant string ("\nSkyper\n") and password {{is used as a}} shared secret with the login server. The plain <b>session</b> <b>key</b> is hashed into a 256-bit AES key that is used to encrypt the session's public RSA key and the shared secret. The encrypted <b>session</b> <b>key</b> and the AES encrypted value are sent to the login server.|$|E
5000|$|<b>Session</b> <b>key</b> {{security}} - An attacker cannot {{compute the}} <b>session</b> <b>key</b> if he impersonates a user {{but has no}} access to the user's private key.|$|E
50|$|For each call, Skype {{creates a}} session with a 256-bit <b>session</b> <b>key.</b> This session exists {{as long as}} {{communication}} continues and for a fixed time afterward. As part of connecting a call, Skype securely transmits the <b>session</b> <b>key</b> to the call recipient. That <b>session</b> <b>key</b> is then used to encrypt messages in both directions.|$|E
5000|$|Forward secrecy - It {{produces}} <b>session</b> <b>keys</b> {{that remain}} secure {{even when the}} password is later disclosed.|$|R
5000|$|The {{security}} of a cryptosystem's CSPRNG is significant {{because it is the}} origin for dynamic key material. Keys needed [...] "on the fly", such as the AES TLS <b>session</b> <b>keys</b> that protect HTTPS sessions with bank websites, originate from CSPRNGs. If these pseudorandom numbers are predictable, <b>session</b> <b>keys</b> are predictable as well. Because CryptGenRandom is the de facto standard CSPRNG in Win32 environments, its security is critical for Windows users.|$|R
5000|$|A {{pseudorandom}} number generator (PRNG) in the firmware of the AMT PC, which generates high-quality <b>session</b> <b>keys</b> for secure communication.|$|R
50|$|PGP {{can be used}} to send {{messages}} confidentially. For this, PGP combines symmetric-key encryption and public-key encryption. The message is encrypted using a symmetric encryption algorithm, which requires a symmetric key. Each symmetric key is used only once and is also called a <b>session</b> <b>key.</b> The message and its <b>session</b> <b>key</b> are sent to the receiver. The <b>session</b> <b>key</b> must be sent to the receiver so they know how to decrypt the message, but to protect it during transmission it is encrypted with the receiver's public key. Only the private key belonging to the receiver can decrypt the <b>session</b> <b>key.</b>|$|E
5000|$|Use {{of a long}} {{random number}} or string as the <b>session</b> <b>key.</b> This reduces the risk that an {{attacker}} could simply guess a valid <b>session</b> <b>key</b> {{through trial and error}} or brute force attacks.|$|E
50|$|On the login server side, {{the plain}} <b>session</b> <b>key</b> is {{obtained}} by decrypting the encrypted <b>session</b> <b>key</b> using the login server's private RSA key. The plain <b>session</b> <b>key</b> is {{then used to}} decrypt the session's public RSA key and the shared secret. If the shared secret match, the login server will sign the user's public RSA key with its private key. The signed data is dispatched to the super nodes.|$|E
50|$|In {{the shared}} secret cases, the {{customer}} and the operator are first mutually authenticated through 3G and Authentication Key (AKA) and they agree on <b>session</b> <b>keys</b> which {{can then be}} used between the client and services that the customer wants to use. This is called bootstrapping.After that, the services can retrieve the <b>session</b> <b>keys</b> from the operator, {{and they can be}} used in some application specific protocol between the client and services.|$|R
3000|$|... c The cookie stores at {{the client}} side {{a variety of}} {{information}} about the running <b>session</b> (<b>keys,</b> contents, user preferences, etc.).|$|R
50|$|The <b>session</b> <b>keys</b> {{produced}} by COMP128-1 and COMP128-2 have only 54 bits of entropy. This significantly weakens the A5 or A6 encryption.|$|R
50|$|The {{public key}} {{algorithms}} known thus far are relatively computationally costly compared with most symmetric key algorithms of apparently equivalent security. The difference {{factor is the}} use of typically quite large keys. This has important implications for their practical use. Most are used in hybrid cryptosystems for reasons of efficiency - in such a cryptosystem, a shared secret key ("session key") is generated by one party, and this much briefer <b>session</b> <b>key</b> is then encrypted by each recipient's public key. Each recipient then uses his own private key to decrypt the <b>session</b> <b>key.</b> Once all parties have obtained the <b>session</b> <b>key,</b> they can use a much faster symmetric algorithm to encrypt and decrypt messages. In many of these schemes, the <b>session</b> <b>key</b> is unique to each message exchange, being pseudo-randomly chosen for each message.|$|E
50|$|MIKEY {{provides}} many {{methods to}} share the <b>session</b> <b>key</b> and authenticate participants.|$|E
5000|$|Message A: Client/TGS <b>Session</b> <b>Key</b> {{encrypted}} {{using the}} secret key of the client/user.|$|E
5000|$|A secure {{distribution}} mechanism {{based on}} GDOI and the IKEv2 protocol is presented for {{the usage of}} symmetric <b>keys,</b> e.g. <b>session</b> <b>keys.</b>|$|R
5000|$|<b>Session</b> <b>keys</b> can {{introduce}} complication into a system. However, they solve some real problems. There are two primary reasons to use session keys: ...|$|R
3000|$|... ▪ We {{provide the}} bounded-time {{interval}} by using <b>session</b> <b>keys</b> {{for each individual}} auditing service, preventing malicious insiders from accessing the client’s confidential data stored in cloud servers.|$|R
