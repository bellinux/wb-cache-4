342|0|Public
25|$|In {{concurrency}} control of databases, transaction processing (transaction management), and other transactional distributed applications, Global serializability (or Modular serializability) is a property {{of a global}} schedule of transactions. A global schedule is the unified schedule of all the individual database (and other transactional object) schedules in a multidatabase environment (e.g., federated database). Complying with global serializability means that the global schedule is <b>serializable,</b> has the serializability property, while each component database (module) has a <b>serializable</b> schedule as well. In other words, a collection of <b>serializable</b> components provides overall system serializability, which is usually incorrect. A need in correctness across databases in multidatabase systems makes global serializability a major goal for global {{concurrency control}} (or modular concurrency control). With the proliferation of the Internet, Cloud computing, Grid computing, and small, portable, powerful computing devices (e.g., smartphones), as well as increase in systems management sophistication, the need for atomic distributed transactions and thus effective global serializability techniques, to ensure correctness in and among distributed transactional applications, seems to increase.|$|E
25|$|In a federated {{database}} {{system or}} any other more loosely defined multidatabase system, which are typically distributed in a communication network, transactions span multiple (and possibly distributed) databases. Enforcing global serializability in such system, where different databases may use different types of concurrency control, is problematic. Even if every local schedule of a single database is <b>serializable,</b> the global schedule of a whole system is not necessarily <b>serializable.</b> The massive communication exchanges of conflict information needed between databases to reach conflict serializability globally would lead to unacceptable performance, primarily due to computer and communication latency. Achieving global serializability effectively over different types of concurrency control has been open for several years. Commitment ordering (or Commit ordering; CO), a serializability technique publicly introduced in 1991 by Yoav Raz from Digital Equipment Corporation (DEC), provides an effective general solution for global (conflict) serializability across any collection of database systems and other transactional objects, with possibly different concurrency control mechanisms. CO does not need the distribution of conflict information, but rather utilizes the already needed (unmodified) atomic commitment protocol messages without any further communication between databases. It also allows optimistic (non-blocking) implementations. CO generalizes Strong strict two phase locking (SS2PL), which {{in conjunction with the}} Two-phase commit (2PC) protocol is the de facto standard for achieving global serializability across (SS2PL based) database systems. As a result, CO compliant database systems (with any, different concurrency control types) can transparently join existing SS2PL based solutions for global serializability. The same applies also to all other multiple (transactional) object systems that use atomic transactions and need global serializability for correctness (see examples above; nowadays such need is not smaller than with database systems, the origin of atomic transactions).|$|E
2500|$|In computing, JavaScript Object Notation or JSON ( [...] ), is an open-standard {{file format}} that uses human-readable text to {{transmit}} data objects consisting of attribute–value pairs and array data types (or any other <b>serializable</b> value). It {{is a very}} common data format used for asynchronous browser–server communication, including {{as a replacement for}} XML in some AJAX-style systems.|$|E
50|$|Anomaly <b>Serializable</b> is not {{the same}} as <b>Serializable.</b> That is, it is necessary, but not {{sufficient}} that a <b>Serializable</b> schedule should be free of all three phenomena types.|$|E
50|$|In computing, a blind write {{occurs when}} a {{transaction}} writes a value without reading it. Any view <b>serializable</b> schedule that is not conflict <b>serializable</b> must contain a blind write.|$|E
50|$|From : (Second Informal Review Draft) ISO/IEC 9075:1992, Database Language SQL- July 30, 1992:The {{execution}} of concurrent SQL-transactions at isolation level <b>SERIALIZABLE</b> {{is guaranteed to}} be <b>serializable.</b> A <b>serializable</b> execution is defined to be an {{execution of}} the operations of concurrently executing SQL-transactions that produces the same effect as some serial execution of those same SQL-transactions. A serial execution {{is one in which}} each SQL-transaction executes to completion before the next SQL-transaction begins.|$|E
5000|$|The {{schedule}} S is conflict <b>serializable</b> if the precedence graph has no cycles. As T1 and T2 {{constitute a}} cycle, then we cannot declare S as <b>serializable</b> or not and serializability {{has to be}} checked using other methods.|$|E
50|$|Making {{snapshot}} isolation <b>serializable</b> in Snapshot isolation.|$|E
5000|$|... #Subtitle level 4: <b>Serializable</b> multi-version {{concurrency}} control ...|$|E
50|$|CO based {{snapshot}} isolation (COSI) is {{the intersection}} of Snapshot isolation (SI) with MVCO. SI is a multiversion concurrency control method widely utilized due to good performance and similarity to serializability (1SER) in several aspects. The theory in (Raz 1993b) for MVCO described above is utilized later in (Fekete et al. 2005) and other articles on SI, e.g., (Cahill et al. 2008); see also Making snapshot isolation <b>serializable</b> and the references there), for analyzing conflicts in SI {{in order to make}} it <b>serializable.</b> The method presented in (Cahill et al. 2008), <b>Serializable</b> snapshot isolation (SerializableSI), a low overhead modification of SI, provides good performance results versus SI, with only small penalty for enforcing serializability. A different method, by combining SI with MVCO (COSI), makes SI <b>serializable</b> as well, with a relatively low overhead, similarly to combining the generic CO algorithm with single-version mechanisms. Furthermore, the resulting combination, COSI, being MVCO compliant, allows COSI compliant database systems to inter-operate and transparently participate in a CO solution for distributed/global serializability (see below). Besides overheads also protocols' behaviors need to be compared quantitatively. On one hand, all <b>serializable</b> SI schedules can be made MVCO by COSI (by possible commit delays when needed) without aborting transactions. On the other hand, SerializableSI is known to unnecessarily abort and restart certain percentages of transactions also in <b>serializable</b> SI schedules.|$|E
5000|$|Kochanski multiplication, <b>serializable</b> {{method for}} calculating the {{remainder}} when the modulus is very large ...|$|E
5000|$|MVCC is {{especially}} popular nowadays through the relaxed serializability (see above) method Snapshot isolation (SI) which provides better performance than most known serializability mechanisms (at {{the cost of}} possible serializability violation in certain cases). SerializableSI, which is an efficient enhancement of SI to make it <b>serializable,</b> is intended to provide an efficient <b>serializable</b> solution. SerializableSI has been analyzed via a general theory of MVCC ...|$|E
50|$|FoundationDB {{guarantees}} <b>serializable</b> {{isolation and}} strong durability via redundant storage on disk before transactions are considered committed.|$|E
50|$|In {{spite of}} its {{distinction}} from serializability, snapshot isolation is {{sometimes referred to as}} <b>serializable</b> by Oracle.|$|E
5000|$|...NET {{applications}} can directly use the Caching API to programmatically cache {{and retrieve}} any <b>serializable</b> managed objects.|$|E
50|$|A JavaBean is a POJO that is <b>serializable,</b> has a no-argument constructor, {{and allows}} access to {{properties}} using getter and setter methods that follow a simple naming convention. Because of this convention, simple declarative references {{can be made}} to the properties of arbitrary JavaBeans. Code using such a declarative reference does not have to know anything about the type of the bean, and the bean can be used with many frameworks without these frameworks having to know the exact type of the bean.The JavaBeans specification, if fully implemented, slightly breaks the POJO model as the class must implement the <b>Serializable</b> interface to be a true JavaBean. Many POJO classes still called JavaBeans do not meet this requirement. Since <b>Serializable</b> is a marker (method-less) interface, this is not much of a burden.|$|E
50|$|Note (1): Currently only {{supports}} read uncommited transaction isolation. Version 1.9 adds <b>serializable</b> {{isolation and}} version 2.0 {{will be fully}} ACID compliant.|$|E
5000|$|Java: Java {{provides}} automatic serialization {{which requires}} that the object be marked by implementing the [...] interface. Implementing the interface marks the class as [...] "okay to serialize", and Java then handles serialization internally. There are no serialization methods defined on the [...] interface, but a <b>serializable</b> class can optionally define methods with certain special names and signatures that if defined, will be called {{as part of the}} serialization/deserialization process. The language also allows the developer to override the serialization process more thoroughly by implementing another interface, the [...] interface, which includes two special methods that are used to save and restore the object's state. There are three primary reasons why objects are not <b>serializable</b> by default and must implement the [...] interface to access Java's serialization mechanism. Firstly, not all objects capture useful semantics in a serialized state. For example, a [...] object is tied to the state of the current JVM. There is no context in which a deserialized [...] object would maintain useful semantics. Secondly, the serialized state of an object forms part of its classes' compatibility contract. Maintaining compatibility between versions of <b>serializable</b> classes requires additional effort and consideration. Therefore, making a class <b>serializable</b> needs to be a deliberate design decision and not a default condition. Lastly, serialization allows access to non-transient private members of a class that are not otherwise accessible. Classes containing sensitive information (for example, a password) should not be <b>serializable</b> nor externalizable. The standard encoding method uses a recursive graph-based translation of the object's class descriptor and <b>serializable</b> fields into a byte stream. Primitives as well as non-transient, non-static referenced objects are encoded into the stream. Each object that is referenced by the serialized object via a field that is not marked as [...] must also be serialized; and if any object in the complete graph of non-transient object references is not <b>serializable,</b> then serialization will fail. The developer can influence this behavior by marking objects as transient, or by redefining the serialization for an object so that some portion of the reference graph is truncated and not serialized. Java does not use constructor to serialize objects. It is possible to serialize Java objects through JDBC and store them into a database. While Swing components do implement the <b>Serializable</b> interface, they are not guaranteed to be portable between different versions of the Java Virtual Machine. As such, a Swing component, or any component which inherits it, may be serialized to a byte stream, but it is not guaranteed that this will be re-constitutable on another machine.|$|E
50|$|Note {{that this}} Schedule {{would not be}} <b>serializable</b> if T1 would be committed.Cascading aborts {{avoidance}} is sufficient but not necessary for a schedule to be recoverable.|$|E
5000|$|Schedules {{that are}} not <b>serializable</b> are likely to {{generate}} erroneous outcomes. Well known examples are with transactions that debit and credit accounts with money: If the related schedules are not <b>serializable,</b> then the total sum of money may not be preserved. Money could disappear, or be generated from nowhere. This and violations of possibly needed other invariant preservations are caused by one transaction writing, and [...] "stepping on" [...] and erasing what has been written by another transaction before it has become permanent in the database. It does not happen if serializability is maintained.|$|E
50|$|In {{concurrency}} control of databases, transaction processing (transaction management), and other transactional distributed applications, Global serializability (or Modular serializability) is a property {{of a global}} schedule of transactions. A global schedule is the unified schedule of all the individual database (and other transactional object) schedules in a multidatabase environment (e.g., federated database). Complying with global serializability means that the global schedule is <b>serializable,</b> has the serializability property, while each component database (module) has a <b>serializable</b> schedule as well. In other words, a collection of <b>serializable</b> components provides overall system serializability, which is usually incorrect. A need in correctness across databases in multidatabase systems makes global serializability a major goal for global {{concurrency control}} (or modular concurrency control). With the proliferation of the Internet, Cloud computing, Grid computing, and small, portable, powerful computing devices (e.g., smartphones), as well as increase in systems management sophistication, the need for atomic distributed transactions and thus effective global serializability techniques, to ensure correctness in and among distributed transactional applications, seems to increase.|$|E
5000|$|The class {{should be}} <b>serializable.</b> (This allows {{applications}} and frameworks to reliably save, store, {{and restore the}} bean's state in a manner independent of the VM and of the platform.) ...|$|E
50|$|Renderer modules {{are used}} to render the {{information}} passed to the Salt state system. The renderer system {{is what makes it}} possible to represent Salt's configuration management data in any <b>serializable</b> format.|$|E
50|$|A {{precedence}} graph of {{the schedule}} D, with 3 transactions. As {{there is a}} cycle (of length 2; with two edges) through the committed transactions T1 and T2, this schedule (history) is not Conflict <b>serializable.</b>|$|E
5000|$|PostgreSQL manages {{concurrency}} {{through a}} system known as multiversion concurrency control (MVCC), which gives each transaction a [...] "snapshot" [...] of the database, allowing changes {{to be made}} without being visible to other transactions until the changes are committed. This largely {{eliminates the need for}} read locks, and ensures the database maintains the ACID (atomicity, consistency, isolation, durability) principles in an efficient manner. PostgreSQL offers three levels of transaction isolation: Read Committed, Repeatable Read and <b>Serializable.</b> Because PostgreSQL is immune to dirty reads, requesting a Read Uncommitted transaction isolation level provides read committed instead. PostgreSQL supports full serializability via the <b>serializable</b> snapshot isolation (SSI) technique.|$|E
50|$|Almost all {{implemented}} {{concurrency control}} mechanisms achieve serializability by providing Conflict serializablity, a broad special case of serializability (i.e., it covers, enables most <b>serializable</b> schedules, {{and does not}} impose significant additional delay-causing constraints) which can be implemented efficiently.|$|E
50|$|All the persistable {{types of}} JPA and JDO are {{supported}} by ObjectDB, including user defined entity classes, user defined embeddable classes, standard Java collections, basic data types (primitive values, wrapper values, String, Date, Time, Timestamp) and any other <b>serializable</b> classes.|$|E
50|$|In a federated {{database}} {{system or}} any other more loosely defined multidatabase system, which are typically distributed in a communication network, transactions span multiple and possibly Distributed databases. Enforcing global serializability in such system is problematic. Even if every local schedule of a single database is <b>serializable,</b> still, the global schedule of a whole system is not necessarily <b>serializable.</b> The massive communication exchanges of conflict information needed between databases to reach conflict serializability would lead to unacceptable performance, primarily due to computer and communication latency. The problem of achieving global serializability effectively had been characterized as open until the public disclosure of CO in 1991 by its inventor Yoav Raz (Raz 1991a; see also Global serializability).|$|E
50|$|For this reason, some programmers {{suggest to}} make the objects in the {{hierarchy}} <b>Serializable,</b> and create copies by serializing the old object and then creating a new object from the resulting bitstream, which handles final data members correctly, but is significantly slower.|$|E
50|$|All {{four levels}} of {{isolation}} are supported: Dirty read, read committed, repeatable read and <b>serializable.</b> The level of isolation may be specified operation by operation {{within a single}} transaction. Virtuoso can also act as a resource manager and/or transaction coordinator under Microsoft's Distributed Transaction Coordinator (MS DTC) or the XA standard.|$|E
5000|$|With these {{constructs}} in place, transactional memory {{provides a}} high level programming abstraction by allowing programmers to enclose their methods within transactional blocks. Correct implementations ensure that data cannot be shared between threads without going through a transaction and produce a <b>serializable</b> outcome. For example, code can be written as: ...|$|E
50|$|We have a lost update. Any {{attempts}} to make this schedule serial would give off two different results (either T1's version of A and B is shown, or T2's version of A and B is shown), {{and would not be}} the same as the above schedule. This schedule would not be <b>serializable.</b>|$|E
50|$|Under multiversion {{concurrency}} control, at the <b>SERIALIZABLE</b> isolation level, both SELECT queries see {{a snapshot}} of the database taken at the start of Transaction 1. Therefore, they return the same data. However, if Transaction 1 then attempted to UPDATE that row as well, a serialization failure would occur and Transaction 1 would be forced to roll back.|$|E
5000|$|In {{computing}} {{based on}} the Java Platform, JavaBeans are classes that encapsulate many objects into a single object (the bean). They are <b>serializable,</b> have a zero-argument constructor, and allow access to properties using getter and setter methods. The name [...] "Bean" [...] was given to encompass this standard, which aims to create reusable software components for Java.|$|E
5000|$|In computing, JavaScript Object Notation or JSON ( [...] ), is an open-standard {{file format}} that uses human-readable text to {{transmit}} data objects consisting of attribute-value pairs and array data types (or any other <b>serializable</b> value). It {{is a very}} common data format used for asynchronous browser/server communication, including {{as a replacement for}} XML in some AJAX-style systems.|$|E
50|$|Note that Transaction 1 {{executed}} {{the same}} query twice. If {{the highest level}} of isolation were maintained, the same set of rows should be returned both times, and indeed that is what is mandated to occur in a database operating at the SQL <b>SERIALIZABLE</b> isolation level. However, at the lesser isolation levels, a different set of rows may be returned the second time.|$|E
