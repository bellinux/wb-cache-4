15|98|Public
5000|$|Electronic Calculator with Dynamic Recirculating <b>Storage</b> <b>Register</b> ...|$|E
5000|$|... 'Latched' {{means the}} bits {{are put into}} a <b>storage</b> <b>register</b> (array of flip-flops) which holds its output {{constant}} even if the inputs change after being latched.|$|E
50|$|DSZ (Decrement and Skip on Zero): Decrements <b>storage</b> <b>register</b> zero, and skips {{the next}} {{instruction}} if {{the result is}} zero. There was also an inverse form, Decrement and Skip if Not Zero.|$|E
5000|$|... 1 THROUGH 6 - Six <b>storage</b> <b>registers</b> {{for storing}} keys in KYK-13.|$|R
5000|$|... "Z" [...] ALL - Zeroizes all 6 <b>storage</b> <b>registers</b> when {{mode switch}} {{is set to}} [...] "Z".|$|R
5000|$|Registers {{related to}} {{fetching}} information from RAM, {{a collection of}} <b>storage</b> <b>registers</b> located on separate chips from the CPU: ...|$|R
5000|$|The HP-65 had a [...] "feature" [...] whereby <b>storage</b> <b>register</b> R9 was {{corrupted}} {{whenever the}} user (or program) executed trigonometric functions or performed comparison tests; {{this kind of}} issue was common in many early calculators, caused {{by a lack of}} memory due to cost, power, and/or size considerations. Since the limitation was documented in the manual, it is not strictly speaking a bug.|$|E
5000|$|Significant to the HP-34C {{calculator}} was {{the capability}} for integration and root-finding (a first for any pocket calculator). Integration and root-finding worked {{by having the}} user input a formula as a program. Multiple roots are found using the technique of first finding a root, then dividing the equation by (1 - root value), thus driving {{the solution of the}} equation away from the root at that point. This technique for multiple root-finding is referred to as [...] "deflation". The user would usually programmatically recall the root value from a <b>storage</b> <b>register</b> to improve its precision.|$|E
50|$|A 6000 series CPU {{contained}} 24 operating registers, designated X0-X7, A0-A7, and B0-B7. The eight X registers {{were each}} 60 bits long, {{and used for}} most data manipulationâ€”both integer and floating point. The eight B registers were 18 bits long, and generally used for indexing and address <b>storage.</b> <b>Register</b> B0 was hard-wired to always return 0. By software convention, register B1 was generally set to 1. (This often allowed the use of 15-bit instructions instead of 30-bit instructions.) The eight 18-bit A registers were 'coupled' to their corresponding X registers in an interesting way: setting an address into any of registers A1 through A5 caused a memory load {{of the contents of}} that address into the corresponding X registers. Likewise, setting an address into registers A6 and A7 caused a memory store into that location in memory from X6 or X7. Registers A0 and X0 were not coupled in this way, so could be used as scratch registers. However A0 and X0 were used when addressing CDCs Extended Core Storage (ECS).|$|E
5000|$|... "Kaphengst's {{approach}} is interesting {{in that it}} gives a direct proof of the universality of present-day digital computers, at least when idealized {{to the extent of}} admitting an infinity of <b>storage</b> <b>registers</b> each capable of storing arbitrarily long words" [...] (Shepherdson and Sturgis, p. 219) ...|$|R
5000|$|The 602 was {{available}} in four models: Model 1, Model 2, Model 50, and Model 51. The [...] "Series 50" [...] models were low cost versions that ran at a slower speed, with half as many program steps, and fewer <b>storage</b> <b>registers</b> and counters.|$|R
50|$|In 1965 Victor Comptometer Corporation {{produced}} the Victor 3900, a fully electronic calculator with multiple functions, three <b>storage</b> <b>registers,</b> {{and a small}} CRT display. The unit incorporated an early MOS integrated circuit for processing and storage. The unit was designed for desktop use, but was extremely large and heavy. Due to manufacturing difficulties, manufacturing was discontinued in 1967.|$|R
40|$|An on-chip bubble domain circuit organization. One or more storage {{registers}} {{are connected}} to a propagation path whereby data {{in the form of}} magnetic bubble domains (bubbles) may be transferred {{into and out of the}} storage registers. The propagation path includes a generator for producing the initial bubbles which are expanded into any desired number of new bubbles by a unique multiple output replicator. A unique input decoder is utilized to determine to which <b>storage</b> <b>register</b> the bubbles from the replicator will be directed along the propagation path. Those bubbles not selected may be annihilated. An output decoder utilizing essentially the same decoding scheme as the input decoder, selectively receives bubbles from the <b>storage</b> <b>register.</b> A transfer and replicate switch is utilized between the <b>storage</b> <b>register</b> and output decoder to selectively transfer bubbles to the output decoder. The output decoder may collapse all of the bubbles from certain storage registers so that only the information from the selected <b>storage</b> <b>register</b> reaches the detector. The detectors in turn produce the chip output signal. External control electronics are utilized to control the selective operation of the various devices utilized in the propagation path...|$|E
40|$|A {{system for}} {{analyzing}} asynchronous signals containing {{bits of information}} for ensuring the validity of said signals, by sampling each bit of information a plurality of times, and feeding the sampled pieces of bits of information into a sequence controlled is described. The sequence controller has a plurality of maps or programs through which the sampled pieces of bits are stepped so as to identify the particular bit of information and determine the validity and phase of the bit. The step in which the sequence controller is clocked is controlled by a <b>storage</b> <b>register.</b> A data decoder decodes the information fed out of the <b>storage</b> <b>register</b> and feeds such information to shift registers for storage...|$|E
40|$|This paper {{defines a}} new type of register, called a <b>storage</b> <b>register,</b> to {{represent}} blocks of a replicated logical volume built from a distributed collection of disks. We give a formal specification of storage registers and, in doing so, we extend linearizability to a crash-recovery model. Existing algorithms that implement registers on top of message-passing primitives typically assume a crashstop failure model. Our work illustrates the difficulties in moving to a more general failure model and presents an efficient implementation of storage registers in a message-passing system with crash-recovery processes...|$|E
5000|$|IBM 653 Storage Unit (magnetic tape, disk, core <b>storage,</b> index <b>registers,</b> {{floating}} point arithmetic) ...|$|R
50|$|The HP-65 is {{the first}} {{magnetic}} card-programmable handheld calculator. Introduced by Hewlett-Packard in 1974 at an MSRP of $795, it featured nine <b>storage</b> <b>registers</b> and room for 100 keystroke instructions. It also included a magnetic card reader/writer to save and load programs. Like all Hewlett-Packard calculators of the era and most since, the HP-65 used Reverse Polish Notation (RPN) and a four-level automatic operand stack.|$|R
30|$|Three major {{approaches}} {{are used to}} achieve both low power and reconfigurability of the FFT core in our work. In a FFT core, the major portion of power consumption occurs in two blocks, namely the butterflies with complex twiddle factor multiplications and the internal data <b>storage</b> <b>registers.</b> These two issues are addressed in this design to achieve low power, and reconfigurability is also achieved with the following listed methodologies.|$|R
40|$|A wide {{class of}} {{numerical}} methods needs {{to solve a}} linear system, where the matrix pattern of non-zero coefficients can be arbitrary. These problems can greatly benefit from highly multithreaded computational power and large memory bandwidth available on GPUs, especially since dedicated general purpose APIs such as CTM (AMD-ATI) and CUDA (NVIDIA) have appeared. CUDA even provides a BLAS implementation, but only for dense matrices (CuBLAS). Other existing linear solvers for the GPU are also limited by their internal matrix representation. This paper describes how to combine recent GPU programming techniques and new GPU dedicated APIs with high performance computing strategies (namely block compressed row <b>storage,</b> <b>register</b> blocking and vectorization), to implement a sparse general-purpose linear solver. Our implementation of the Jacobi-preconditioned Conjugate Gradient algorithm outperforms by up to a factor of 6. 0 x leading-edge CPU counterparts, making it attractive for applications which content with single precision...|$|E
40|$|A Unified Lower Bound Estimation Technique for High-Level Synthesis The {{importance}} of effective lower bound estimation (LBE) techniques is well-established in HighLevel Synthesis (HLS), since it allows more efficient {{exploration of the}} design space while providing other HLS tools with the capability of predicting the effect of specific tools on the design space. Much of previous work has focused on LBE techniques that use very simple cost models which primarily focus on the functional unit resources. With the push towards sub-micron technologies, simple models that use functional unit resources alone are not accurate enough to allow effective design space exploration since the effects of storage and interconnect can indeed dominate the cost function. In this paper, we present an integrated approach aimed at predicting lower bounds on hardware resources needed to implement a behavioral description within a given amount of time. Our area cost model accounts for <b>storage</b> (<b>register)</b> and int [...] ...|$|E
40|$|We create low-entropy {{states of}} neutral atoms by {{utilizing}} a conceptually new optical-lattice technique {{that relies on}} a high-precision, high-bandwidth synthesis of light polarization. Polarization-synthesized optical lattices provide two fully controllable optical lattice potentials, each of them confining only atoms in either {{one of the two}} long-lived hyperfine states. By employing one lattice as the <b>storage</b> <b>register</b> and the other one as the shift register, we provide a proof of concept using four atoms that selected regions of the periodic potential can be filled with one particle per site. We expect that our results can be scaled up to thousands of atoms by employing a atom-sorting algorithm with logarithmic complexity, which is enabled by polarization-synthesized optical lattices. Vibrational entropy is subsequently removed by sideband cooling methods. Our results pave the way for a bottom-up approach to creating ultralow-entropy states of a many-body system. Comment: 6 pages; the first two authors have equally contributed; description of PSOLAS algorithm added in version...|$|E
50|$|The HP-25 had memory {{space for}} up to 49 program steps. It was the first HP {{calculator}} which used fully merged keycodes (storing prefix key and function key together in one program location) to save memory space. Additionally there were eight <b>storage</b> <b>registers</b> and specialized scientific and statistical functions. The owner's manual came with 161 pages in four colors and contained many mathematical, scientific, navigational and financial programming examples.|$|R
50|$|As another example, {{the state}} of a {{microprocessor}} is the contents of all the memory elements in it: the accumulators, <b>storage</b> <b>registers,</b> data caches, and flags. When computers such as laptops go into a hibernation mode to save energy by shutting down the processor, {{the state of}} the processor is stored on the computers hard disk, so it can be restored when the computer comes out of hibernation, and the processor can take up operations where it left off.|$|R
50|$|The HP-55 was a {{programmable}} handheld calculator; a lower-cost {{alternative to}} the HP-65. Introduced by Hewlett-Packard in 1975, it featured twenty <b>storage</b> <b>registers</b> and room for 49 keystroke instructions. Its outward appearance was identical to the HP-65, except that a few key functions were different and {{that it did not}} have a magnetic card reader/writer. Like all Hewlett-Packard calculators of the era and most since, the HP-55 used Reverse Polish Notation (RPN) and a four-level automatic operand stack.|$|R
40|$|The Linear Collider Flavour Identification (LCFI) {{collaboration}} {{has successfully}} developed the first prototype {{of a novel}} particle detector, the In-situ Storage Image Sensor (ISIS). This device ideally suits the challenging requirements for the vertex detector at the future International Linear Collider (ILC), combining the charge storing capabilities of the Charge-Coupled Devices (CCD) with readout commonly used in CMOS imagers. The ISIS avoids the need for high-speed readout and offers low power operation combined with low noise, high immunity to electromagnetic interference and increased radiation hardness compared to typical CCDs. The ISIS {{is one of the}} most promising detector technologies for vertexing at the ILC. In this paper we describe the measurements on the charge-shielding properties of the p -well, which is used to protect the <b>storage</b> <b>register</b> from parasitic charge collection and is at the core of device's operation. We show that the p -well can suppress the parasitic charge collection by almost two orders of magnitude, satisfying the requirements for the application...|$|E
40|$|Purpose. Consideration of the {{treatment}} facilities, which are debited from the balance, but continue {{to participate in the}} activities of the institutio. We used a systematic approach {{to the study of the}} issues, analysis, synthesis, observation, group, etc. The article focuses on the issues arising in the course of accounting and control system development. The key issues in this respect are property valuation and classification, ways of entity identification and writing them off from offbalance- sheet accounts. The author also writes about tax consequences in case of having no accounting data. The article introduces a <b>storage</b> <b>register</b> which allows to obtain information about the entities, their maintenance costs and to develop data about the entities in accordance with the accounting groups with the view to further structure analysis. Finally, the author proposes measures to increase control over writing these entities off. The results can be applied in the practice of accounting in the budgetary institutions and the teaching of disciplines, "Accounting for budgetary institutions", "Control and Audit" for students of economic specialties...|$|E
40|$|The {{importance}} of effective lower bound estimation (LBE) techniques {{is well established}} in high-level synthesis (HLS) since it allows more efficient exploration of the design space while providing other HLS tools with the capability of predicting the effect of specific tools on the design space. Much of the previous work has focused on LBE techniques that use very simple cost models which primarily focus on the functional unit resources. With the push toward submicron technologies, simple models that use functional unit resources alone are not accurate enough to allow effective design space exploration since the effects of storage and interconnect can indeed dominate the cost function. In this paper, we present an integrated approach aimed at predicting lower bounds on hardware resources needed to implement a behavioral description within a given amount of time. Our area cost model accounts for <b>storage</b> (<b>register)</b> and interconnect resources (buses) in addition to functional resources. Our timing model uses a finer granularity that permits the modeling of functional unit, register, and interconnect delays. Our approach is integrated because we consider the dependencies between {{the different types of}} resources as well as the ordering in which the resources are allocated. We tested our technique for functional unit, storage, and interconnect requirements on several high-level synthesis benchmarks, and observed near-optimal results. We believe that our comprehensive LBE approach can lead to better quality HLS solutions in less time, and we demonstrate this approach in our paper...|$|E
50|$|The TI-57 was a {{programmable}} calculator made by Texas Instruments between 1977 and 1982. There were three machines by this name made by TI, {{the first was}} the TI-57 with LED display released in September 1977 along the more powerful TI-58 and TI-59. It had 50 program steps and 8 memory registers. Two later versions named TI-57 LCD and TI-57 LCD-II have a LCD display, but were less powerful (ran much slower) and had much less memory: 48 bytes to be allocated between program 'steps' and <b>storage</b> <b>registers.</b>|$|R
5000|$|The Mark I read its {{instructions}} from a 24-channel punched paper tape. It executed the current instruction and then {{read in the}} next one. A separate tape could contain numbers for input, but the tape formats were not interchangeable. Instructions could not be executed from the <b>storage</b> <b>registers.</b> This separation of data and instructions {{is known as the}} Harvard architecture (although the exact nature of this separation that makes a machine Harvard, rather than Von Neumann, has been obscured with the passage of time; see Modified Harvard architecture).|$|R
40|$|IntroductionComputer System OrganizationComputer EvolutionOrganization versus Design versus ArchitectureSummaryProblemsBibliographyNumber Systems and CodesNumber SystemsConversionArithmeticSign-Magnitude SystemComplement Number SystemFloating-Point NumbersBinary CodesData <b>Storage</b> and <b>Register</b> TransferRepresentation of Numbers, Arrays, and RecordsSummaryProblemsBibliographyCombinational LogicBasic Operations and TerminologyBoolean Algebra (Switching Algebra) Minimization of Boolean FunctionsPrimitive Hardware BlocksFunctional Analysis of Combinational CircuitsSynthesis of Combinational Circuits...|$|R
40|$|Matrix {{multiplication}} is {{most often}} involved in graphics, image processing, digital signal processing, robotics and control engineering applications. In this paper we compared and analyzed the power and energy consumption in three different designs, which multiply two matrices A and B of nxn 32 -bit items and store the result in C matrix of nxn 64 -bit items. The first two designs use FPGA HW with different number of <b>storage</b> <b>registers</b> 2 n and 2 n 2 and the third design uses a computer system piloted by NIOS II processor with On-Chip memory. We showed that NIOS II is not an energy efficient alternative to multiply nxn matrices compared to HW matrix multiplier on FPGA. Since our target FPGA is the Altera cyclone II family, we also had to find one acceptable method to measure the real power consumption in the FPGA device...|$|R
40|$|Abstract:- In {{this paper}} we {{present the results}} {{obtained}} from the comparative study of limit cycles in different lattice structures digital filters. The study was derived using ladder lattice, state space ladder lattice and scaled state space ladder lattice structures. Several Butterworth, Chebyshev, Inverse Chebyshev and Elliptic filters have been analyzed in detail and the information obtained can be seen summarized in different tables and figures. In order to evaluate the real impact of these oscillations in practical situations, maximum amplitude and period of limit cycles have been obtained. Although hidden oscillations donâ€™t appear at {{the output of the}} filter, the remaining energy at the inner <b>storage</b> <b>registers</b> can degrade the good performance of the filter, so these kind of cycles have also been analyzed. Key-Words:- limit cycles, ladder lattice digital filters, fixed point, state space. ...|$|R
5000|$|The {{system has}} a CPU cycle time of 500 nanoseconds, 25% {{faster than the}} Model 40 and 40% slower than the Model 65. Processor storage is {{magnetic}} core memory that transfers four bytes per 2 microsecond cycle. It has [...] "protected" [...] and [...] "local" [...] core <b>storage</b> for <b>registers</b> and internal buffers with cycle times of 200 and 500 nanoseconds respectively.|$|R
50|$|The 1108 was {{introduced}} in 1964. Integrated circuits replaced the thin film memory that the UNIVAC 1107 used for <b>register</b> <b>storage.</b> Smaller and faster cores, compared to the 1107, were used for main memory.|$|R
5000|$|Before the {{introduction}} of the HP-25C in 1976, all calculator random-access memory (RAM) was volatile, i.e. its contents (esp. user data in <b>storage</b> <b>registers</b> and any user programs) were cleared when the calculator was turned off. Three early models with this improved, continuous memory - the HP-25C, HP-29C, and HP-19C - actually had the words [...] " [...] Continuous Memory [...] " [...] printed in conspicuous, white script on the bottom margin of their faceplates. The [...] "C" [...] in the model designations was to distinguish those models within HP's calculator product line. HP did not print this phrase on subsequent, featured models because the novelty of continuous memory had by then faded and also because it could no longer claim it as a feature unique to HP calculators (Texas Instruments would later call their identical feature [...] "Constant Memory"). At introduction over the next 9 years (approx. 1979-1987), subsequent HP models so featured simply had designations in which the letter [...] "C" [...] followed the model number, e.g. the HP-34C and the Voyager series HP-10C, HP-11C, HP-12C, HP-15C and HP-16C.|$|R
50|$|The Pup was a single-seat {{parasol wing}} {{monoplane}} with an Ava flat-four pusher engine {{mounted on the}} wing trailing edge. The wings could be folded back for <b>storage.</b> The Pup <b>registered</b> G-AELR first flew in July 1936.|$|R
