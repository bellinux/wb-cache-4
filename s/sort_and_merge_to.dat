0|10000|Public
50|$|The Sort Merge Generator was an {{application}} developed by Betty Holberton in 1951 for the Univac I {{and is one}} of the first examples of using a computer to create a computer program. The input to the application was a specification of files and the kind of <b>sort</b> <b>and</b> <b>merge</b> operations <b>to</b> use <b>and</b> the output would be machine code for performing the specification.|$|R
40|$|The {{main goal}} of this work is to present an {{investigation}} over the influence of errors into the geographic location software developed by Sousa (2000) and by Sousa and Kuga (2004). Basically the satellite receives the UHF signals from DCPs (Data Collecting Platforms) and relay such signals to ground reception stations in range. The Doppler shift measurements are computed in the ground station. In the Data Collection Mission Center, the Doppler measurements are <b>sorted</b> <b>and</b> <b>merged</b> <b>to</b> input them to the geographic location software, which provides the DCPs location. This feature is particularly useful for monitoring moving DCPs (drifting buoys in sea or rivers), for animal tracking, for checking if the DCP is still in place, or for insuring that goods reaches the destiny. To enable this kind of analysis a special simulator was developed to produce simulated Doppler measurements according to error simulation cases. A test scenario composed by SCD- 2 and NOAA- 17 satellite passes, a single DCP (Data Collecting Platform) and a ground receiving station was used. The analyses of error introduced in the simulation covers the following cases: ideal simulated conditions, without any errors; random errors in the Doppler measurements; bias errors in the Doppler measurements; and errors in the satellite ephemeris. The obtained results are quite satisfactory and in the ideal case the results shows compatibility between the simulator and the geographic location software. As a final remark, this paper shows the importance of satellite ephemeris and on board satellite oscillator to get more accurate locations. Pages: 1625 - 163...|$|R
40|$|Software {{development}} sometimes requires to statically {{predict the}} quantity of resources—such as memory and time—that is needed to execute a program. The difficulties of manual resource analysis led to extensive research on automatic methods for quantitative resource analysis. Recently we developed an automatic amortized analysis to compute polynomial resource bounds for first-order functional programs at compile time. Its basis is a type system that augments types with resource annotations. The analysis system is integrated in the programming language Resource Aware ML. Our experiments with a prototype implementation show that the analysis efficiently computes precise time and heap-space bounds for many example programs. In this paper I demonstrate how a user can employ Resource Aware ML to analyze the worst-case time behavior of the sorting algorithms quick <b>sort,</b> insertion <b>sort</b> <b>and</b> <b>merge</b> <b>sort.</b> <b>To</b> illustrate pros <b>and</b> cons, I compare our automatic analysis to a manual analysis of the algorithms in a standard textbook. The paper {{is divided into three}} sections. Section 1 motivates the research on static resource analysis. Section 2 briefly introduces Resource Aware ML. Finally, Section 3 contains the actual case study on sorting algorithms...|$|R
40|$|This paper {{addresses}} {{the problem of}} evaluating ranked top- queries with expensive predicates. As major DBMSs now all support expensive user-defined predicates for Boolean queries, we believe such support for ranked queries {{will be even more}} important: First, ranked queries often need to model user-specific concepts of preference, relevance, or similarity, which call for dynamic user-defined functions. Second, middleware systems must incorporate external predicates for integrating autonomous sources typically accessible only by per-object queries. Third, fuzzy joins are inherently expensive, as they are essentially user-defined operations that dynamically associate multiple relations. These predicates, being dynamically defined or externally accessed, cannot rely on index mechanisms to provide zero-time <b>sorted</b> output, <b>and</b> must instead require per-object probe to evaluate. The current standard sort-merge framework for ranked queries cannot efficiently handle such predicates because it must completely probe all objects, before <b>sorting</b> <b>and</b> <b>merging</b> them <b>to</b> produce top- answers. To minimize expensive probes, we thus develop the formal principle of "necessary probes," which determines if a probe is absolutely required. We then propose Algorithm MPro which, by implementing the principle, is provably optimal with minimal probe cost. Further, we show that MPro can scale well and can be easily parallelized. Our experiments using both a real-estate benchmark database and synthetic datasets show that MPro enables significant probe reduction, which can be orders of magnitude faster than the standard scheme using complete probing...|$|R
40|$|In this thesis, we {{consider}} the problem of finding an optimal join order sequence for tree and star queries. A join between two relations is either performed using the nested loop method or the sort-merge method. The problem considered in our thesis {{is an extension of}} the work studied by Ibaraki and Kameda[IK 84] and Ravi Krishnamurthy, Boral and Zaniolo[KBZ 86] The algorithm for obtaining an optimal join order sequence for star query has exponential time complexity[Cha 00]. In this thesis we present a greedy heuristic, GHGS, that outputs join sequence that is very close to the optimal solution. These results are based on the experimental analysis performed on GHGS with 10000 different Catalogs. The greedy algorithm, GHGS has O(m 3) time complexity and O(m) space complexity where the number of relations considered are m. We have also extended the idea proposed in [IK 84] and [KBZ 86] to consider both, nested loop <b>and</b> <b>sort</b> <b>merge</b> joins <b>to</b> obtain an optimal join order sequence for tree queries. The time complexity of our algorithm ExIba is O(m 2 log m 2 m) and the space complexity is O(m). The time complexity of the ExKBZ algorithm is O(m 2 2 m) and the space complexity of the algorithm is O(m) where m is the number of relations in the tree query...|$|R
40|$|Microfluidics, {{the study}} of fluid flow at the sub-millimetre scale, is an {{enabling}} technology that offers scaling down of common laboratory procedures into what is called lab-on-a-chip (LOC) devices. Such devices exhibit significantly reduced fluid consumption, faster reaction times and higher sensitivity. Droplet microfluidics, where nanoliter to femtoliter volume droplets are dispersed in an immiscible carrier medium, offers physical and chemical isolation of droplets {{so that they could}} be used as micro-reactors to study reactions. However, it's quite challenging to manipulate droplets in closed microfluidic channels. Researchers have designed passive as well as active manipulation techniques to accomplish tasks such as merging, sorting or mixing of droplets. Elegant and efficient as they may be, such systems fail to demonstrate cross-compatibility due to fabrication differences and imposed flow conditions. This thesis presents three novel droplet microfluidic devices capable of performing highest demand droplet manipulation techniques, starting with sensing <b>and</b> <b>sorting</b> <b>to</b> <b>merging</b> <b>and</b> splitting, in an integrable manner offering exceptional on-demand control using surface acoustic waves (SAWs). SAWs are nm-scale amplitude, MHz frequency waves that are generated by electrodes deposited on piezoelectric substrates. Microfluidic devices utilising SAWs are easy to fabricate and operate; they are portable, energy efficient and safe to biological samples. Droplet trapping and coalescence, steering at Y-junctions and splitting at T-junctions using SAWs were realised and thoroughly characterised in the presented thesis. They were designed {{in such a way that}} they could be mixed and matched in order to perform a specific study. Moreover, it was shown that a combinatorial library could be formed using an automated LOC device presented here that can sense, split, <b>merge</b> <b>and</b> mix droplets. These systems could easily be coupled with existing LOC devices or modified to carry out required workflows in an efficient manner...|$|R
5000|$|... #Caption: An {{example of}} merge sort. First divide the list into the {{smallest}} unit (1 element), then compare each element with the adjacent list <b>to</b> <b>sort</b> <b>and</b> <b>merge</b> the two adjacent lists. Finally {{all the elements}} are <b>sorted</b> <b>and</b> <b>merged.</b>|$|R
30|$|Massive {{amounts of}} data are <b>sorted</b> <b>and</b> <b>merged</b> by the data packing {{technique}} to reduce the problem scale by aggregators.|$|R
40|$|Due to the {{intrinsic}} characteristics, P 2 P information retrieval has faced {{quite a few}} challenges, {{and it is one}} of the urgent problems how <b>to</b> <b>sort</b> <b>and</b> <b>merge</b> the retrieval results from multiple nodes. For this reason, we propose a novel algorithm for layered <b>sorting</b> <b>and</b> <b>merging</b> of P 2 P information retrieval. In the proposed approach, the query submitting node submits the query string to the nodes that more probably acquires retrieval results. These nodes accept query request, sort the retrieval results in the descending order of similarities with traditional <b>sorting</b> method <b>and</b> select top-k documents to send to the query requesting node, and then the query submitting node execute <b>sorting</b> <b>and</b> <b>merging.</b> The final experimental results suggest that our proposed approach is feasible, correct and valid. Key words...|$|R
50|$|Based on the amortized {{analysis}} of splay trees, {{the worst case}} running time of splaysort, on an input with n data items, is O(n log n), matching the time bounds for efficient non-adaptive algorithms such as quicksort, heap <b>sort,</b> <b>and</b> <b>merge</b> <b>sort.</b>|$|R
40|$|There {{are several}} sorting algorithms. We can {{implement}} several sorting algorithms {{such as the}} insertion sort, the binary-insertion sort, quick <b>sort,</b> heap <b>sort</b> <b>and</b> <b>merge</b> <b>sort.</b> Moreover, we can compare the efficiency of each algorithm by measuring the running time and counting the numbers of comparisons...|$|R
40|$|With the {{development}} of computing technology, CUDA has become a very important tool. In computer programming, sorting algorithm is widely used. There are many simple sorting algorithms such as enumeration <b>sort,</b> bubble <b>sort</b> <b>and</b> <b>merge</b> <b>sort.</b> In this paper, we test some simple sorting algorithm based on CUDA and draw some useful conclusions...|$|R
40|$|Sorting is a {{commonly}} used operation in computer science. In {{addition to its}} main job of arranging lists or arrays in sequence, sorting is often also required to facilitate some other operation such as searching, <b>merging</b> <b>and</b> normalization or used as an intermediate operation in other operations. A sorting algorithm consists of comparison, swap, and assignment operations[1 - 3]. There are several simple <b>and</b> complex <b>sorting</b> algorithms that are being used in practical {{life as well as}} in computation such as Quick sort, Bubble sort, Merge sort, Bucket sort, Heap sort, Radix sort etc. But the application of these algorithms depends on the problem statement. This paper introduces MQ sort which combines the advantages of quick <b>sort</b> <b>and</b> <b>Merge</b> <b>sort.</b> The comparative analysis of performance and complexity of MQ sort is done against Quick <b>sort</b> <b>and</b> <b>Merge</b> <b>sort.</b> MQ sort significantly reduces complexity and provides better performance than Quick sort, Merge sort...|$|R
40|$|Increasing Yield {{and short}} {{time to market}} is a key factor for {{increasing}} economy and customers satisfication in the leading edge semiconductor production. The BMBF funded government project Logicenter for <b>Sorting</b> <b>and</b> Stocking IC Wafers 'LOCSS' focuses {{on research and development}} to create new Clusterequipment for the whole <b>sort</b> <b>and</b> <b>merge</b> process in semiconductor production cycles. Positive Results have been achieved in developing a fully automated cluster tool suitable for all Stocking <b>and</b> <b>Sorting</b> processes without manual handling of sensitive and expensive semiconductor wafers. <b>Sort</b> <b>and</b> <b>merge</b> yield loss due to manual mismatch, misprocessing, waferdamage or contamination is not longer a trouble. By using consequently SMIF Technology LOCSS is a 'Clean Machine' which needs less floor space whilst maintaining all cleanroom requirements even for the leading edge 300 mm Wafer Technology. Partners of TEMIC Semiconductor in this Research Project were: ACR, Thesys, GPS Plessey WED and Fraunhofer IPA Stuttgart. (orig.) SIGLEAvailable from TIB Hannover: F 00 B 673 +a / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekBundesministerium fuer Bildung und Forschung (BMBF), Bonn (Germany) DEGerman...|$|R
5000|$|The 95 page ring-bound manual {{describes}} {{the function of}} the software as follows: [...] "Microsoft Standalone SORT is a programmable <b>sorting</b> <b>and</b> <b>merging</b> utility. It accepts data files and arranges the records contained in these files in the order you assign. You may specify sequence keys, which are specific data field(s) within each record, for comparison of records. Also, you may specify a selection procedure." ...|$|R
40|$|Abstract: Sorting large {{data sets}} {{has always been}} an {{important}} application, and hence {{has been one of the}} benchmark applications on new parallel architectures. We present a parallel sorting algorithm for the Cell processor that combines elements of bitonic <b>sort</b> <b>and</b> <b>merge</b> <b>sort,</b> <b>and</b> reduces the bandwidth to main memory by pipelining. We present runtime results of a partial prototype implementation and simulation results for the complete sorting algorithm, that promise performance advantages over previous implementations...|$|R
50|$|The UNISERVO {{supported}} both {{forward and}} backward modes on read or write operation. This offered significant advantages in data <b>sorting</b> <b>and</b> <b>merging</b> applications. The data transfers to/from the UNIVAC I processor were fully buffered in a one block dedicated memory, permitting instruction execution in parallel with tape movement and data transfer. The internal serial data path permitted inserting a tape data block into main memory in one instruction.|$|R
40|$|Space-filling curves, particularly, Hilbert curves, {{have been}} {{extensively}} used to maintain spatial locality of multi-dimensional {{data in a}} wide variety of applications. A window query is an important query operation in spatial (image) databases. Given a Hilbert curve, a window query reports its corresponding orders without the need to decode all the points inside this window into the corresponding Hilbert orders. Given a query window of size p × q on a Hilbert curve of size T × T, Chung et al. have proposed an algorithm for decomposing a window into the corresponding Hilbert orders, which needs O(n log T) time, where n = max(p, q). By employing the properties of Hilbert curves, we present an efficient algorithm, named as Quad-Splitting, for decomposing a window into the corresponding Hilbert orders on a Hilbert curve without individual <b>sorting</b> <b>and</b> <b>merging</b> steps. Although the proposed algorithm also takes O(n log T) time, it does not perform individual <b>sorting</b> <b>and</b> <b>merging</b> steps which are needed in Chung et al. ’s algorithm. Therefore, experimental results show that the Quad-Splitting algorithm outperforms Chung et al. ’s algorithm. ...|$|R
5000|$|Python's {{standard}} library (since 2.6) {{also has}} a [...] function in the [...] module, that takes multiple <b>sorted</b> iterables, <b>and</b> <b>merges</b> them into a single iterator.|$|R
40|$|Today {{there are}} several {{efficient}} algorithms that cope with the popular task of sorting. This paper titled Comparative Performance Study of Improved Heap <b>Sort</b> Algorithm <b>and</b> other <b>sorting</b> Algorithms {{presents a comparison between}} classical <b>sorting</b> algorithms <b>and</b> improved heap <b>sort</b> algorithm. To have some experimental data to sustain these comparisons three representative algorithms were chosen (classical Heap <b>sort,</b> quick <b>sort</b> <b>and</b> <b>merge</b> <b>sort).</b> The improved Heap sort algorithm was compared with some experimental data of classical algorithms on two different platforms that lead to final conclusions...|$|R
50|$|Note {{that most}} {{worst-case}} sorting algorithms that do optimally {{well in the}} worst-case, notably heap <b>sort</b> <b>and</b> <b>merge</b> <b>sort,</b> do not take existing order within their input into account, although this deficiency is easily rectified {{in the case of}} merge sort by checking if left.last_item ≤ right.first_item, in which case a merge operation may be replaced by simple concatenation - a modification that is well within the scope of making an algorithm adaptive.|$|R
5000|$|Extensional equality: Two {{functions}} f and g {{are considered}} extensionally equal if they agree on their outputs for all inputs (∀x. f(x) = g(x)). Under this definition of equality, for example, any two implementations {{of a stable}} sorting algorithm, such as insertion <b>sort</b> <b>and</b> <b>merge</b> <b>sort,</b> would be considered equal. Deciding on extensional equality is undecidable in general and even for functions with finite domains often intractable. For this reason no programming language implements function equality as extensional equality.|$|R
5000|$|On 1 January 2015 {{the former}} {{municipalities}} of Péry <b>and</b> La Heutte <b>merged</b> <b>to</b> form the new municipality of Péry-La Heutte. The former municipalities of Bévilard, Malleray <b>and</b> Pontenet <b>merged</b> <b>to</b> form Valbirse. Finally, Châtelat, Monible, Sornetan <b>and</b> Souboz <b>merged</b> <b>to</b> form Petit-Val.|$|R
50|$|The Hocking Glass Company {{was formed}} in 1905, <b>and</b> <b>merged</b> <b>to</b> become Anchor Hocking by 1937.|$|R
50|$|In 2010 {{the three}} districts were {{dissolved}} <b>and</b> <b>merged</b> <b>to</b> form the Arrondissement administratif Jura bernois.|$|R
5000|$|On 1 January 2001 {{the former}} {{municipalities}} of Onnens (FR), Lentigny <b>and</b> Lovens <b>merged</b> <b>to</b> form the new municipality of La Brillaz. The former municipalities of Ecuvillens <b>and</b> Posieux <b>merged</b> <b>to</b> form the new municipality of Hauterive (FR). The former municipalities of Corjolens <b>and</b> Avry-sur-Matran <b>merged</b> <b>to</b> form the new municipality of Avry.|$|R
5000|$|Lincoln High School (Port Arthur, Texas), {{now defunct}} <b>and</b> <b>merged</b> <b>to</b> Memorial High School (Port Arthur, Texas) ...|$|R
40|$|We {{describe}} {{the design of}} high-performance parallel radix <b>sort</b> <b>and</b> <b>merge</b> <b>sort</b> routines for manycore GPUs, {{taking advantage of the}} full programmability offered by CUDA. Our radix sort is the fastest GPU <b>sort</b> <b>and</b> our <b>merge</b> <b>sort</b> is the fastest comparison-based sort reported in the literature. Our radix sort is up to 4 times faster than the graphics-based GPUSort and greater than 2 times faster than other CUDA-based radix sorts. It is also 23 % faster, on average, than even a very carefully optimized multicore CPU sorting routine. To achieve this performance, we carefully design our algorithms to expose substantial fine-grained parallelism and decompose the computation into independent tasks that perform minimal global communication. We exploit the high-speed onchip shared memory provided by NVIDIA’s GPU architecture and efficient data-parallel primitives, particularly parallel scan. While targeted at GPUs, these algorithms should also be wellsuited for other manycore processors...|$|R
40|$|In {{this paper}} we are proposing a new sorting algorithm, List Sort algorithm, {{is based on}} the dynamic memory allocation. In this {{research}} study we have also shown the comparison of various efficient sorting techniques with List sort. Due the dynamic nature of the List sort, it becomes much more fast than some conventional comparison <b>sorting</b> techniques <b>and</b> comparable <b>to</b> Quick <b>Sort</b> <b>and</b> <b>Merge</b> <b>Sort.</b> List sort takes the advantage of the data which is already sorted either in ascending order or in descending order. Comment: 7 pages, 5 figure...|$|R
50|$|Cheshire Council of Girl Scouts (1947-1957) {{was split}} off from Waterbury <b>and</b> <b>merged</b> <b>to</b> form Laurel Trail Council.|$|R
5000|$|... 1999 - UMC and MMC were {{purchased}} by Shands HealthCare <b>and</b> <b>merged</b> <b>to</b> become Shands Jacksonville Medical Center ...|$|R
5000|$|Albstadt {{consists}} of the following urban districts, which had been independent towns <b>and</b> <b>merged</b> <b>to</b> form Albstadt in 1975: ...|$|R
5000|$|... 2000: Hong Kong Telecom was {{acquired}} by <b>and</b> <b>merged</b> <b>to</b> Pacific Century Cyberworks. It was renamed to PCCW-HKT Limited.|$|R
5000|$|... polyfocal settlement, two (or more) {{adjacent}} nucleated {{villages that}} have expanded <b>and</b> <b>merged</b> <b>to</b> form a cohesive overall community ...|$|R
50|$|Data can be {{compared}} <b>and</b> <b>merged</b> <b>to</b> reduce duplication <b>and</b> can be organized to increase relevance to the radio audience.|$|R
50|$|Pseudocode for {{top down}} merge sort {{algorithm}} which recursively divides the input list into smaller sublists until the sublists are trivially <b>sorted,</b> <b>and</b> then <b>merges</b> the sublists while returning up the call chain.|$|R
