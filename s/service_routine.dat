113|655|Public
25|$|The AGC {{responded to}} each {{interrupt}} by temporarily suspending the current program, executing a short interrupt <b>service</b> <b>routine,</b> and then resuming the interrupted program.|$|E
50|$|Interrupt vectors are {{blocks of}} two 16-bit words in low kernel address space (which {{normally}} corresponded to low physical memory) between 0 and 776. The first {{word of the}} interrupt vector contains {{the address of the}} interrupt <b>service</b> <b>routine</b> and the second word the value to be loaded into the PSW (priority level) on entry to the <b>service</b> <b>routine.</b>|$|E
50|$|In {{computer}} science, a {{vectored interrupt}} is a processing technique {{in which the}} interrupting device directs the processor to the appropriate interrupt <b>service</b> <b>routine.</b> This {{is in contrast to}} a polled interrupt system, in which a single interrupt <b>service</b> <b>routine</b> must determine the source of the interrupt by checking all potential interrupt sources, a slow and relatively laborious process.|$|E
5000|$|... #Subtitle level 2: TRAP <b>service</b> <b>routines</b> (possible {{values for}} ZZ) ...|$|R
5000|$|API: {{defines the}} {{interface}} and functional behavior of executable routines {{for the purpose}} of calling <b>service</b> <b>routines</b> or exchanging data between computer programs.|$|R
40|$|Embedded {{real-time}} programs rely {{on external}} interrupts {{to respond to}} events in their physical environment in a timely fashion. Formal program verification theories, such as the refinement calculus, are intended for development of sequential, block-structured code and do not allow for asynchronous control constructs such as interrupt <b>service</b> <b>routines.</b> In this article we extend the refinement calculus to support formal development of interrupt-dependent programs. To do this we: use a timed semantics, to support reasoning about the occurrence of interrupts within bounded time intervals; introduce a restricted form of concurrency, to model composition of interrupt <b>service</b> <b>routines</b> with the main program they may preempt; introduce a semantics for shared variables, to model contention for variables accessed by both interrupt <b>service</b> <b>routines</b> and the main program; and use real-time scheduling theory to discharge timing requirements on interruptible program code...|$|R
50|$|The Operating System's Non-Maskable Interrupt {{dispatch}} routine reads this {{register to}} determine {{the reason for the}} interrupt and so which <b>service</b> <b>routine</b> to execute.|$|E
50|$|The AGC {{responded to}} each {{interrupt}} by temporarily suspending the current program, executing a short interrupt <b>service</b> <b>routine,</b> and then resuming the interrupted program.|$|E
5000|$|In the DioneOS {{system the}} context switch can be {{initiated}} from interrupt <b>service</b> <b>routine.</b> This property {{is useful for}} moving an event handling to the thread and commonly implemented in two-layer architecture: ...|$|E
40|$|This {{exploratory}} study gave {{an insight into}} the effect that <b>service</b> <b>routines</b> and technology had {{on the ability of}} frontline employees from a large Australian telecommunications company to deliver effective service to call centre customers. The study highlighted that for simple and timely <b>service</b> <b>routines</b> to occur, product lines and support services needed to be compatible with both the technology provided and frontline employees’ expertise in using the technology. When this occurred, simple and timely <b>service</b> <b>routines</b> appeared to follow, which equated to higher quality service and better customer satisfaction. On the other hand, when this did not occur frontline employees were often forced to unwillingly deliver poor service to customers. The comments of the frontline staff provide an interesting window into the potentially high cost for any organization that does not understand the power that frontline employees have to build or break a business...|$|R
40|$|Sensor network {{simulations}} require {{high fidelity}} and timing accuracy {{to be used}} as an implementation and evaluation tool. The cycle-accurate and instruction-level simulator is the known solution for these purposes. However, this type of simulation incurs a high computation cost since it has to model not only the instruction level behavior but also the synchronization between multiple sensors for their causality. This paper presents a novel technique that exploits asynchronous simulations of interrupt <b>service</b> <b>routines</b> (ISR). We can avoid the synchronization overheads when the interrupt <b>service</b> <b>routines</b> are simulated without preemption. If the causality errors occur, we devise a rollback procedure to restore the original synchronized simulation. This concept can be extended to any instruction-level sensor network simulator. Evaluation results show our method can enhance the simulation speed up to 52 % in the case of our experiments. For applications with longer interrupt <b>service</b> <b>routines</b> and smaller number of preemptions, the speedup becomes greater. In addition, our simulator is 2 to 11 times faster than the well-known sensor network simulator...|$|R
25|$|Hardware {{exception}} {{mechanisms are}} processed by the CPU. It {{is intended to}} support error detection and redirects the program flow to error handling <b>service</b> <b>routines.</b> The state before the exception is saved on the stack.|$|R
50|$|The design {{philosophy}} of the Propeller is that a hard real-time multi-core architecture negates the need for dedicated interrupt hardware and support in assembly. In traditional CPU architecture, external interrupt lines are fed to an on-chip interrupt controller and are serviced {{by one or more}} interrupt service routines. When an interrupt occurs, the interrupt controller suspends normal CPU processing and saves internal state (typically on the stack), then vectors to the designated interrupt <b>service</b> <b>routine.</b> After handling the interrupt, the <b>service</b> <b>routine</b> executes a return from interrupt instruction which restores the internal state and resumes CPU processing.|$|E
50|$|The {{processor}} reserves {{low memory}} addresses for two-word vectors that give a program counter and processor status word {{with which to}} begin a <b>service</b> <b>routine.</b> When an I/O device interrupts a program, it places the address of its vector on the bus to indicate which <b>service</b> <b>routine</b> should take control. The lowest vectors are service routines to handle various types of trap. Traps occur on some program errors, such {{as an attempt to}} execute an undefined instruction; and also when the program executes an instruction such as BPT, EMT, IOT, or TRAP to request service from the operating system.|$|E
5000|$|This is {{an example}} of a [...] {{function}} that fails to be reentrant (as well as failing to be thread-safe). As such, it should not have been used in the interrupt <b>service</b> <b>routine</b> : ...|$|E
5000|$|Trampolines (sometimes {{referred}} to as indirect jump vectors) are memory locations holding addresses pointing to interrupt <b>service</b> <b>routines,</b> I/O routines, etc. Execution jumps into the trampoline and then immediately jumps out, or bounces, hence the term trampoline. They have many uses: ...|$|R
5000|$|A [...] "reentrant {{interrupt}} handler" [...] is an {{interrupt handler}} that re-enables interrupts {{early in the}} interrupt handler. This may reduce interrupt latency.In general, while programming interrupt <b>service</b> <b>routines,</b> it is recommended to re-enable interrupts {{as soon as possible}} in the interrupt handler. This practice helps to avoid losing interrupts.|$|R
50|$|The PDP-11 {{supports}} hardware interrupts at four priority levels. Interrupts are {{serviced by}} software <b>service</b> <b>routines,</b> which could specify whether they themselves could be interrupted (achieving interrupt nesting). The event {{that causes the}} interrupt is indicated by the device itself, as it informs the processor of the address of its own interrupt vector.|$|R
50|$|The Operation System sets NMIEN to {{the default}} $40hex/64dec during the power up {{routines}}. The NMI service routines first vector through $FFFAhex/65530dec which determines {{the cause and}} then transfers control to the interrupt <b>service</b> <b>routine.</b>|$|E
50|$|The Rabbit {{processor}} {{family has}} unique features. For example, the Z80/Z180 family disables interrupts once an interrupt is serviced by an interrupt <b>service</b> <b>routine.</b> However, the Rabbit processors permit interrupts to interrupt service routines according to priorities (a total of 4).|$|E
50|$|The 2d Liaison Squadron {{provided}} emergency air evacuation, {{search and}} rescue, courier and messenger <b>service,</b> <b>routine</b> reconnaissance and transportation of personnel. It regularly operated between Langley Air Force Base, Virginia and Fort John Custis with one Beechcraft C-45 Expeditor and several Stinson L-13s.|$|E
50|$|Intertask or interprocess {{communication}} in µC/OS-II occurs via: semaphores, message mailbox, message queues, tasks, and interrupt <b>service</b> <b>routines</b> (ISRs). They can {{interact with each}} other when a task or an ISR signals a task through a kernel object called an event control block (ECB). The signal is considered to be an event.|$|R
40|$|The thesis {{deals with}} {{designing}} {{and implementation of}} a library of <b>service</b> <b>routines</b> for peripherals on educational kit with Freescale microcontrollers. It presents the laboratory kit, features of individual peripherals and ways of comunication with them. Further, the thesis describes developing the driver for LCD touchscreen on auxiliary kit module and its use in graphic library Freescale eGUI...|$|R
40|$|In the report, <b>service</b> <b>routines</b> are {{developed}} for linear, quadratic and cubic finite elements {{for two and}} three dimensional regions. Also, an equation solver of very large capacity is developed for systems of linear equations where the matrix of coefficients is symmetrical, positive definite and tightly banded along the main diagonalNaval Weapons Center, China Lake, California, Work Request No. 1 - 0029 [URL]...|$|R
5000|$|This routine {{will operate}} {{correctly}} if interrupted, because the program counter {{will continue to}} point to the [...] instruction until the block copy is completed. The copy will therefore continue from where it left off when the interrupt <b>service</b> <b>routine</b> returns control.|$|E
50|$|Vectored {{interrupts}} {{are achieved}} by assigning each interrupting device a unique code, typically {{four to eight}} bits in length. When a device interrupts, it sends its unique code over the data bus to the processor, telling the processor which interrupt <b>service</b> <b>routine</b> to execute.|$|E
50|$|A VBI was {{implemented}} on the Atari 8-bit family, whose ANTIC display chip included a register {{pointing to the}} start of the display memory. The main program would draw the new frame into a buffer in memory and the VBI <b>service</b> <b>routine</b> would change the ANTIC register.|$|E
40|$|PLAN (Programming Language for Active Networks) {{is a new}} {{language}} for programs that are carried in the packets of a programmable network. PLAN programs replace the packet headers (which {{can be viewed as}} `dumb' programs) used in current networks. As a header replacement, PLAN programs must be lightweight and of limited functionality. These limitations are mitigated by allowing PLAN code to call <b>service</b> <b>routines</b> written in other, more powerful languages. These <b>service</b> <b>routines</b> may also be loaded into the routers dynamically. This two-level architecture, in which PLAN serves as a scripting or `glue' language for more general services, is the primary contribution of the paper. PLAN is a strict functional language providing a limited set of primitives and datatypes. PLAN defines primitives for remotely executing PLAN programs on other nodes, and these primitives are used to provide basic data transport in the network. Because remote execution makes debugging difficult, PLAN provides strong [...] ...|$|R
5000|$|Level IV: Four Regional Hospitals (with 620 beds) {{that provide}} {{emergency}} <b>services,</b> <b>routine</b> surgery and obstetrical and gynecological care, dental services, diagnostic services and specialist services in general medicine and pediatrics. They {{are designed to}} include the necessary support for this level of medical service in terms of laboratory and X-ray facilities, pharmacies and dietetic expertise. These hospitals are located in Regions 2, 3, 6 and 10.|$|R
40|$|This work {{is devoted}} to present the results {{obtained}} when using a tool to build Supervisory Systems called IGNATIUS. An architectural decomposition the Supervisory Systems in three service levels allows to improve development times and security. IGNATIUS encapsulates the Basic <b>Service</b> <b>routines,</b> providing a development environment {{that can be easily}} used by inexperienced programmers. This approach allowed to build complex Supervisory applications, experiences whose results are discussed with detail. 1...|$|R
5000|$|The {{interrupt}} vector register, , is {{used for}} the Z80 specific mode 2 interrupts (selected by the [...] instruction). It supplies the high byte of the base address for a 128-entry table of <b>service</b> <b>routine</b> addresses which are selected via an index sent to the CPU during an interrupt acknowledge cycle; this index is simply the low byte part of the pointer to the tabulated indirect address pointing to the <b>service</b> <b>routine.</b> The pointer identifies a particular peripheral chip and/or peripheral function or event, where the chips are normally connected in a so-called daisy chain for priority resolution. Like the refresh register, this register has also sometimes been used creatively; in interrupt modes 0 and 1 (or in a system not using interrupts) it can be used as simply another 8-bit data register.|$|E
50|$|The {{interrupt}} <b>service</b> <b>routine</b> {{can then}} run specific display or graphics software to modify {{data in the}} video display memory {{while it is not}} being read. This was particularly useful in simple home computers and video game consoles that relied upon a central microprocessor to generate text or graphic displays.|$|E
50|$|The OS jumps through VVBLKI ($0222hex/546dec) {{to begin}} the OS VBI <b>Service</b> <b>Routine,</b> and the OS VBI Routine exits with a jump through VVBLKD ($0224hex/548dec). By default VVBLKI points to the OS jump vector SYSVBV ($E45Fhex/58463dec) {{to begin the}} Vertical Blank Interrupt, and VVBLKD points to the OS jump vector XITVBV ($E462hex/58466dec).|$|E
40|$|Our {{aim is to}} {{investigate}} the suitability of hardware multithreading for real-time event handling in combination with appropriate real-time scheduling techniques. We designed and evaluated a multithreaded microcontroller based on a Java processor core. Java threads are used as Interrupt Service Threads (ISTs) instead of the Interrupt <b>Service</b> <b>Routines</b> (ISRs) of conventional processors. Our proposed Komodo microcontroller supports multiple ISTs with zero-cycle context switching overhead. A so-called priority manager implements several real-time scheduling algorithms in hardware...|$|R
25|$|The {{operating}} system may provide facilities for handling exceptions in programs via IPC. Typically, interrupts {{caused by the}} execution of a process are handled by the interrupt <b>service</b> <b>routines</b> of the {{operating system}}, and the operating system may then send a signal to that process, which may have asked the operating system to register a signal handler to be called when the signal is raised, or let the operating system execute a default action (like terminating the program). Typical examples are SIGSEGV, SIGBUS, SIGILL and SIGFPE.|$|R
50|$|The typical {{method of}} {{utilizing}} an interrupt vector involves reading its present value (the address), storing {{it within the}} memory space of the TSR, and installing a pointer to its own code. The stored address is called {{before or after the}} TSR has received the interrupt and has finished its processing, in effect forming a singly linked list of interrupt handlers, also called interrupt <b>service</b> <b>routines,</b> or ISRs. This procedure of installing ISRs is called chaining or hooking an interrupt or an interrupt vector.|$|R
