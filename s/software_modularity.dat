85|40|Public
50|$|Cisco's IOS-XR (ultra high {{availability}} IOS) built about 2004-2005 {{is based on}} QNX software, as is IOS <b>Software</b> <b>Modularity</b> introduced in 2006.|$|E
50|$|In 2006, Cisco {{has made}} {{available}} IOS <b>Software</b> <b>Modularity</b> which extends the QNX microkernel {{into a more}} traditional IOS environment, but still providing the software upgrade capabilities that customers are demanding. It is currently available on the Catalyst 6500 enterprise switch.|$|E
50|$|The {{product is}} {{designed}} from principles of <b>software</b> <b>modularity</b> and extensibility and aims at exhibiting stability and providing feature requirements for production use while also supporting networking research. The development project {{was founded by}} Mark Handley in 2000. Receiving funding from Intel, Microsoft, and the National Science Foundation, it released its first production software in July 2004. The project was then run by Atanu Ghosh of the International Computer Science Institute, in Berkeley, California.|$|E
5000|$|In <b>software</b> design, <b>modularity</b> {{refers to}} a logical {{partitioning}} of the [...] "software design" [...] that allows complex software to be manageable {{for the purpose of}} implementation and maintenance. The logic of partitioning may be based on related functions, implementation considerations, data links, or other criteria.|$|R
50|$|The OpenXPKI project aims at {{creating}} an enterprise-grade Open Source PKI <b>software.</b> Flexibility and <b>modularity</b> are the project's key design objectives.|$|R
40|$|Lieberherr {{advocated}} adaptive, or structure shy, programming. This object-oriented pro-gramming (OOP) extension {{attempts to}} bind algorithms to data structures {{as late as}} possi-ble to maximize the <b>software’s</b> <b>modularity,</b> purportedly making <b>software</b> easier to under-stand and maintain. 1 (Lieberherr’s Demeter Project met with limited success because it re-quired using modified programming lan-guages.) From a more database-oriented per-spective, semistructured data management systems let programmers represent data whose structure is not completely regular. 2 Here, the ubiquitous (and often hyped) XML-based technologies, 3 in particular, have induced {{a new wave of}} advances. We introduce a novel OOP extension, merging both philosophies (adaptive program-ming and semistructured data management), that you can use transparently in current pro-gramming platforms. Lazy types model vari-ability without increasing implementation complexity. In situations where the use of standard design patterns could hinder design understandability, lazy types deal with com-plexity by keeping track of a unique type while avoiding the artificial multiplication of types traditional OOP solutions introduce. Moreover, lazy types reduce potential error sources as well as the amount of code pro-grammers must write. A case study We can use existing OO models to repre-sent complex data and behavior, but the data’s structure (and, hence, its behavior) must stay the same. Yet, many applications must deal with data that doesn’t easily fit into static models, and the data can present structural ir-featur...|$|R
50|$|The {{focus of}} aspect-oriented {{software}} development {{is in the}} investigation and implementation of new structures for <b>software</b> <b>modularity</b> that provide support for explicit abstractions to modularize concerns.Aspect-oriented programming approaches provide explicit abstractions for the modular implementation of concerns in design, code, documentation, or other artifacts developed during the software life-cycle. These modularized concerns are called aspects, and aspect-oriented approaches provide methods to compose them. Some approaches denote a root concern as the base. Various approaches provide different flexibility with respect to composition of aspects.|$|E
50|$|The {{monolithic}} {{approach requires}} a code developed {{for this particular}} combination of physical problems whereas the partitioned approach preserves <b>software</b> <b>modularity</b> because an existing flow solver and structural solver are coupled. Moreover, the partitioned approach facilitates solution of the flow equations and the structural equations with different, possibly more efficient techniques which have been developed specifically for either flow equations or structural equations. On the other hand, development of stable and accurate coupling algorithm is required in partitioned simulations. In conclusion, the partitioned approach allows reusing existing software which is an attractive advantage. However, stability of the coupling method {{needs to be taken}} into consideration.|$|E
40|$|We empirically {{examine the}} {{relationship}} between software design modularity and software quality in open source software (OSS) development projects. Conventional wisdom suggests that degree of <b>software</b> <b>modularity</b> affects software quality. An analysis of 203 software releases in 46 OSS projects hosted on SourceForge. net lends support for a more complex relationship between <b>software</b> <b>modularity</b> and software quality than conventional wisdom suggests. We find that <b>software</b> <b>modularity</b> is associated with reduced software complexity, an increased number of static software bugs, and a mixed relationship with the percentage of bugs closed. We do not find empirical evidence supporting any relationship between modularity and other measures of customer satisfaction. In addition to empirically testing the relationship between modularity and quality, we introduce new measures of <b>software</b> <b>modularity</b> and software quality. Implications are developed for the theory of modularity and the practice of software development...|$|E
40|$|The NUbots team, from The University of Newcastle, Australia, has had {{a strong}} record of success in the RoboCup Standard Platform League since first {{entering}} in 2002. The team has also competed within the RoboCup Humanoid Kid-Size League since 2012. The 2014 team brings a renewed focus on <b>software</b> architecture, <b>modularity,</b> {{and the ability to}} easily share code. This paper summarizes the history of the NUbots team, describes the roles and research of the team members, gives an overview of the NUbots' robots and software system, and addresses relevant research projects within the the Newcastle Robotics Laboratory. Comment: RoboCup 2014 humanoid league team description pape...|$|R
40|$|This paper {{presents}} Clio, {{an approach}} thatdetects modularity violations, {{which can cause}} <b>software</b> defects, <b>modularity</b> decay, or expensive refactorings. Clio computes the discrepancies between how components should change together based on the modular structure, and how components actually change together as revealed in version histories. We evaluated Clio using 15 releases of Hadoop Common and 10 releases of Eclipse JDT. The results show that hundreds of violations identified using Clio were indeed recognized as design problems or refactored by the developers in later versions. The identified violations cover multiple symptoms of poor design, {{some of which are}} not easily detectable using existing approaches. Categories and Subject Descriptors D. 2. 7 [Software Engineering]: MaintenanceandEnhancement—refactoring, restructuring; D. 2. 10 [Software Engineering]: Design—modularity violation, refactoring Keywords modularity violation detection, refactoring, bad code smells, design structure matrix 1...|$|R
40|$|This {{dissertation}} {{presents a}} framework {{for the application of}} compositional modularity, a module model that facilitates extensive reuse of highly decomposed <b>software.</b> Compositional <b>modularity</b> supports not only the traditional notions of program decomposition and encapsulation but also effective mechanisms for module recomposition. Based on a previously developed model, a suite of operators individually achieve effects of adaptation and combination on a simple notion of modules viewed as self-referential namespaces. This dissertation extends the previous model by introducing the notion of hierarchical nesting as a composition operation. Furthermore, this work shows that compositional modularity is unifying in scope. Important effects and idioms of advanced modularity, including several varieties of inheritance in object-oriented programming, find convenient expression within this model. Compositional modularity can be applied within a wide range of systems that manipulate self-referenti [...] ...|$|R
40|$|Implementation {{aspects of}} control-structure {{interaction}} analysis and optimization by the staggered use of single-discipline analysis modules are discussed. The single-discipline modules include structural analysis, controller synthesis and optimization. The <b>software</b> <b>modularity</b> is maintained by employing a partitioned control-structure interaction analysis procedure, thus avoiding {{the need for}} embedding the single-discipline modules into a monolithic program. A software testbed has been constructed as a stand-alone analysis and optimization program and tested for its versatility and <b>software</b> <b>modularity</b> by applying it to the dynamic analysis and preliminary design of a prototype Earth Pointing Satellite. Experience with the in-core testbed program so far demonstrates that the testbed is efficient, preserves <b>software</b> <b>modularity,</b> and enables the analyst to choose {{a different set of}} algorithms, control strategies and design parameters via user software interfaces. Thus, the present software architecture is recommended for adoption by control-structure interaction analysts as a preliminary analysis and design tool...|$|E
40|$|This paper proposes and {{examines}} {{a model of}} the relationship between elements of product design and software quality in open source software (OSS) development projects. Research suggests that product design, or product architecture, affects work processes and outputs in the production of goods and services. In the case of software, we therefore hypothesize that product architecture affects characteristics of subsequent code contributions, which in turn affect product quality. An analysis of 203 software releases in 46 OSS projects hosted on SourceForge. net lends support for the hypothesized relationship between <b>software</b> <b>modularity</b> and software development, suggesting that the degree of <b>software</b> <b>modularity</b> is positively associated with the number of contribution opportunities and the number of code contributions, and negatively associated with contribution size. In addition, we find that <b>software</b> <b>modularity</b> is associated with reduced software complexity, one common measure of software quality. Surprisingly we find that <b>software</b> <b>modularity</b> is associated with an increased number of static software bugs and number of bugs reported, additional measures of software quality. However, opportunities to contribute mediates the relationship between degree of modularity and number of static bugs and bugs reported to yield the expected relationship between modularity and bugs. In addition to proposing and testing relationships between elements of software development and software quality, we introduce new measures of modularity and software quality. Implications are developed for the theory of modularity and the practice of software development...|$|E
40|$|In this paper, we {{describe}} our {{experience with the}} design of an advanced teleconferencing service under two different frameworks — an early implementation of the Distributed Feature Composition architecture, and the SIP Servlet API. The usual design goals of <b>software</b> <b>modularity</b> for encapsulation and reuse are pursued. Interestingly, two very different designs resulted. This paper discusses the factors that influenced our design decisions. In particular, we examine the different characteristics of the two frameworks {{as well as the}} maturity of project requirements, and illustrate the ways in which these factors affect various mechanisms for achieving <b>software</b> <b>modularity.</b> We also aim to draw on this experience to propose a set of design guidelines for building modular, composable SIP Servlet applications for Voice over IP and converged services. 1...|$|E
40|$|Abstract. We analyze {{how to use}} the {{reflective}} approach to integrate an authorization system into a distributed object-oriented framework. The expected benefits from {{the reflective}} approach are: more stability of the security layer (i. e., with a more limited number of hidden bugs), better <b>software</b> and development <b>modularity,</b> more reusability, and the possibility to adapt the security module with at most a few changes to other applications. Our analysis is supported by simple and illustrative examples written in Java...|$|R
40|$|The main aim of {{this paper}} is to show an {{abstract}} machine for compiling logic programs composed by means of meta-operators; in particular, we deal with union, intersection and closure, which are directly supported by the most common abstract machine for logic programming: the Warren Abstract Machine. The proposed solution is a mix of the interpretation-oriented and the compilation-oriented approach such that it is possible to exploit the benefits and to reduce, as possible, the drawbacks. 1 Introduction Many extensions of logic programming have been proposed to increase its expressive power and to widen application area. Such extensions provide tools to deal with typical problems of Artificial Intelligence (hypothetical reasoning, knowledge assimilation) and <b>Software</b> Engineering (<b>modularity,</b> incremental development of programs, object oriented programming). However, they add non declarative elements, or their semantics is inspired by other logics so that clarity and simplicity [...] ...|$|R
40|$|Modularity as {{an object}} {{oriented}} principle helps to develop appropriate large-scale and complex <b>software.</b> But <b>modularity</b> has some deficits [14] such as modular decomposition etc., which is not allowed widely using <b>modularity</b> in <b>software</b> development in current years. In this paper some principles have been provided for increase <b>modularity</b> of <b>software</b> systems and help for turn an existing system to a modular system. These principles distribute functionalities of each module to them and decrease dependency of modules. To obtain this aim, object oriented principles and heuristics has been analyzed then by considering a module {{as an object}}, new modular principles have been provided. In the reminder to evaluate new principles, a new modular architecture has been provided. The strength of new principles has been shown with two complete case studies. New principles {{can be used in}} any large-scale software architectures, modular architectures and any service oriented platforms...|$|R
40|$|Separation of Concerns is an {{important}} aspect of <b>software</b> <b>modularity.</b> Being able to reason and analyze about a single characteristics of a software project in detriment of the others is a necessity already identified in the seminal work of Dijkstra [Dijkstra, 1982]. Such charac-teristics are referred to as “concerns”, and by concern one can mean features, non-functiona...|$|E
40|$|Abstract:- In {{this paper}} we propose an {{engineering}} approach for fast prototyping of a HMM-based speech recognizer. The presented system has been specifically used for words and sentences recognition of a regional variety of Italian. Experimental results have been obtained using the AVIP corpus of Italian spontaneous speech. The prototyping system {{is based on the}} "Khoros " software framework, which offers the possibility of creating a processing system that can be easily modified and extended, while keeping the needed <b>software</b> <b>modularity...</b>|$|E
30|$|A <b>software</b> <b>modularity</b> {{is defined}} as a way to {{implement}} more flexible and comprehensible systems, which impacts directly on its maintenance tasks [33]. In software architecture, modularity is also very important. We can observe this importance in the architectural model 4 + 1, where views like logical view and implementation view capture modularity aspects [5]. Although the benefits of modularization are clear, for architectural conformance and specification, there is little discussion on this front. As we explain in related work (the “Related work” section), most architectural specifications are monolithic in nature.|$|E
40|$|During {{my studies}} at the Ecole des Mines d'Albi-Carmaux, I did an {{internship}} at the Royal Institute of Technology (Kungliga Tekniska Högskolan) in Sweden to finalize my master. The subject of this exercise is positioned as the junction of two different research areas. There is on one hand {{the development of new}} analysis method of Enterprise Architecture (EA) and on the other the analysis of <b>software</b> architecture <b>modularity.</b> The entire mission concerns a method of analyzing the modularity of EA developed by Harvard  Business  School.   The  analysis  method  called "Hidden  Structure"  aims  to evaluate the components of software and isolate vulnerable or key components. This internship's main task is to develop the Enterprise Application Modularity module. It is a module dedicated to the modularity analysis according to the hidden structure method and  its  integration  with  the  Enterprise  Architecture  Analysis  Tool  (EAAT)   software developed by KTH. This project also needs to develop additional functionalities to support the calculations. Among these features, you can find support for instantiation of new models and automated generation of reports containing the results...|$|R
40|$|When doing mission {{analysis}} {{and design of}} an imaging system in orbit around the Earth, answering the fundamental question of imaging performance requires {{an understanding of the}} image products that will be produced by the imaging system. GOATS software represents a series of MATLAB functions to provide for geometric image projections. Unique features of the <b>software</b> include function <b>modularity,</b> a standard MATLAB interface, easy-to-understand first-principles-based analysis, and the ability to perform geometric image projections of framing type imaging systems. The software modules are created for maximum analysis utility, and can all be used independently for many varied analysis tasks, or used in conjunction with other orbit analysis tools...|$|R
40|$|In this paper, {{we present}} an {{approach}} to detect design rule violations that could cause <b>software</b> defects, <b>modularity</b> decay, or expensive refactorings. Our approach is to compute the discrepancies between how components should change together based on the modular structure framed by design rules, and how components actually changed together revealed by how modification requests were fulfilled. Our contributions include a design violation detection framework and a design-rule based impact scope prediction algorithm. We evaluatedour approach usingthe version historyof three large-scale open source software projects. We examined all identified violations to check whether they were refactored or recognized by the developers in later versions. Our results show that (1) on average 73 % of the violations we identified were either recognized or refactored in later releases (when using. 5 confidence and varying support from 2 to 10 in Hadoop); (2) our approach can identify problematic design violations much earlier than manual identification by developers; and (3) the identified violations cover multiple bad smells, such as tight coupling and code clone. Categories and Subject Descriptors D. 2. 7 [Software Engineering]: MaintenanceandEnhancement—refactoring, restructuring; D. 2. 10 [Software Engineering]...|$|R
40|$|Layered {{architecture}} in operating system code is often compromised by execution path-specific customizations such as prefetching, page replacement and scheduling strategies. Pathspecific customizations {{are difficult to}} modularize in a layered architecture because they involve dynamic context passing and layer violations. Effectively they are vertically integrated slices through the layers. An initial experiment using an aspect-oriented programming language to refactor prefetching in the FreeBSD operating system kernel shows significant benefits, including easy (un) pluggability of prefetching modes, independent development of prefetching modes, and overall improved comprehensibility. Keywords aspect-oriented programming, <b>software</b> <b>modularity,</b> operating system design 1...|$|E
40|$|A design {{language}} and tool like MATLAB/Simulink {{is used for}} the graphical modelling and simulation of automotive control software. As the functionality based on electronics and software systems increases in motor vehicles, it is becoming increasingly important for system/software architects and control engineers in the automotive industry to ensure the quality of the highly complex MATLAB/Simulink control software. For automotive <b>software,</b> <b>modularity</b> is recognized as being a crucial quality attribute; therefore at Eindhoven University of Technology in the Netherlands we have been carrying out industrial case studies on defining and validating the modularity of Simulink models...|$|E
40|$|Abstract: This paper {{describes}} a fully automated method of measuring magnetisation curves (flux linkage versus current and position) of Switched Reluctance (SR) motors. The measuring scheme was developed using a graphical programming environment (LabVIEW), a data acquisition card and external interface hardware. The graphical programming method allowed {{a high degree}} of <b>software</b> <b>modularity,</b> and provided the features needed for acquiring and analysing the data, control, and presentation of the results. The experimental setup was given, which can be used in other electromechanical devices to obtain the magnetisation characteristics. The measured results of a test SR motor were also presented. 1...|$|E
40|$|The {{value of}} <b>software</b> design <b>modularity</b> largely {{lies in the}} ability to {{accommodate}} potential changes. Each modularization technique, such as aspect-oriented programming and object-oriented design patterns, provides one way to let some part of a system change independently of all other parts. A modularization technique benefits a design if the potential changes to the design can be well encapsulated by the technique. In general, questions in software evolution, such as which modularization technique is better and whether it is worthwhile to refactor, should be evaluated against potential changes. In this paper, we present a decision-tree-based framework to generally assess design modularization in terms of its changeability. In this framework, we formalize design evolution questions as decision problems, model software designs and potential changes using augmented constraint networks (ACNs), and represent design modular structure before and after envisioned changes using design structure matrices (DSMs) derived from ACNs. We formalize change impacts using an evolution vector to precisely capture well-known informal design principles. As a preliminary evaluation, we use this model to compare the aspect-oriented and object-oriented observer pattern in terms of their ability to accommodate envisioned changes. The results confirm previous published results, but in formal and quantitative ways. 1...|$|R
40|$|The {{complexity}} of software has driven both researchers and practitioners toward design methodologies that decompose problems into intellectually manageable pieces and that assemble partial products into complete <b>software</b> artifacts. <b>Modularity</b> in design, however, rarely translates into modularity at the implementation level. Hence, an important {{problem is to}} provide implementation (i. e., programming language) support for expressing modular designs concisely. This dissertation shows that software can be conveniently modularized using large-scale object-oriented software components. Such large-scale components encapsulate multiple classes but can themselves be viewed as classes, as they support the object-oriented mechanisms of encapsulation and inheritance. This conceptual approach has several concrete applications. First, existing language mechanisms, like a pattern of inheritance, class nesting, and parameterization, {{can be used to}} simulate large-scale components called mixin layers. Mixin layers are ideal for implementing certain forms of object-oriented designs and result in simpler and more concise implementations than those possible with previous methodologies. Second, we propose new language constructs to provide better support for component-based programming. These constructs express components cleanly (i. e., without unwanted interactions with other language mechanisms) and address the issue of component type-checking...|$|R
40|$|Scientific {{software}} applications are increasingly developed by large interdiscplinary teams operating on functional modules organized around a common software framework, which is ca-pable of integrating new functional capabilities without modifying {{the core of}} the framework. In such environment, <b>software</b> correctness and <b>modularity</b> take precedence at the expense of code performance, which is an important concern during execution on supercomputing facil-ities, where the allocation of core-hours is a valuable resource. To alleviate the performance problems, we propose automated performance tuning (autotuning) of software to extract the maximum performance on a given hardware platform and to enable performance portability across heterogeneous hardware platforms. The resulting code remains generic without commit-ting to a particular software stack and yet is compile-time specializable for maximal sustained performance. ...|$|R
40|$|An Aspect-Oriented Programming-based {{approach}} {{to the development of}} software components for fault detection in automatic measurement systems is proposed. Faults are handled by means of specific software units, the ``aspects{''}, in order to better modularize issues transversal to several components. As a case study, this approach was applied to the design of the fault detection software inside a flexible framework for magnetic measurements, developed at the European Organization for Nuclear Research (CERN). Experimental results of <b>software</b> <b>modularity</b> and performance measurements for comparing aspect- and objectoriented solutions in rotating coils tests on superconducting magnets are reported. (C) 2009 Elsevier B. V. All rights reserved...|$|E
40|$|In recent days, {{the amount}} of {{functions}} has increased significantly in embedded products so that systems development methodologies {{play an important role}} to ensure the product’s quality, cost, and time. Furthermore, this complexity coupled with constantly evolving specifications, has led to propose a semiformal development methodology to support the building of embedded real-time systems. A platform-based design approach has been used to balance costs and time-to-market in relation to performance and functionality constraints. We performed three expressive case studies and we concluded that the proposed methodology significantly reduces design time and improves <b>software</b> <b>modularity</b> and reliability...|$|E
40|$|This paper {{describes}} a software reengineering tool which attempts to guide programmers in the remodularisation of software systems. The tool {{makes use of}} several technologies, which include an object-oriented information base for storing the original source code and an artificial neural network (ANN), {{which is used to}} cluster together procedures that share information. The remainder of this paper discusses the relations between <b>software</b> <b>modularity</b> and information hiding, suggesting a way that data and procedures could be organised into modules, and describes the reengineering tool, which attempts the remodularisation of existing code, with a presentation of results from several experiment...|$|E
40|$|A {{fascination for}} {{electronics}} development platforms was {{the starting point}} for this project. Brought forward from open source initiatives, these exist of modular hardware toolkits and <b>software.</b> This <b>modularity</b> allows people to use them in different configurations to support a variety of contexts and purposes. In this way it enables them to bring just about any idea to life. There is an emerging trend on the web, where people modify or hack into products, trying to change or extends their products to fit their needs. As technology is becoming cheaper and embedded in everyday products, it allows products to become more flexible, and be more sensitive towards these trends. My project has been an investigation in developing a method for design, which promotes modular product systems, rather than closed, fixed products. Open-ended design is an approach which supports an exploration space for end-users. Focused on laymen users, allows them to investigate what functionality and behaviour is needed for their own interests and niche purposes. The open-ended design framework was used to design Myriad: a flexible, modular camera system to complement GoPro cameras. Myriad exists of a growing library of modules, sensors and a mobile app which combined create unique camera functionality and behaviours...|$|R
40|$|Software {{can either}} be {{developed}} in a way such that the source code is available to others, open source, or such that it is not, closed source. Open source software {{has a number of}} architectural advantages over traditionally developed closed-source <b>software</b> including <b>modularity,</b> a frequent release pattern and a strong culture of reuse. As there has been a shift away from developing software that runs locally to a model where service based computing and web services {{are some of the most}} important software used on a daily basis by people, there has been a shift away from developing such software as open source. This thesis looks at a comparison between open source and web services and shows how they compare on some of the aspects which are the most important architectural advantages of open source. This examination is based on a look at literature and specific web services. Through this examination, it shows that many of the benefits of open source can be found as a result of other architectural characteristics of web services. by Jeremy Lee Katz. Thesis (S. M. in System Design and Management) [...] Massachusetts Institute of Technology, Engineering Systems Division, System Design and Management Program, 2010. Cataloged from PDF version of thesis. Includes bibliographical references (p. 69 - 73) ...|$|R
40|$|Managing {{tradeoffs}} between program {{structure and}} program efficiency {{is one of}} the most difficult problems facing software engineers. Decomposing programs into abstractions simplifies the construction and maintenance of software and results in fewer errors. However, the introduction of these abstractions often introduces significant inefficiencies. This paper describes a strategy for eliminating many of these inefficiencies. It is based upon providing alternative implementations of the same abstraction, and using information contained in formal specifications to allow a compiler to choose the appropriate one. The strategy has been implemented in a prototype compiler that incorporates theorem proving technology. Keywords: Program <b>Modularity,</b> <b>Software</b> Interfaces, Formal Specifications, Compilers, Program Optimization. 1 INTRODUCTION Many approaches to programming emphasize the use of specifications of interfaces. The basic idea is to achieve a separation of concerns. The client of an [...] ...|$|R
