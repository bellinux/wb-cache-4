0|4993|Public
40|$|Nowadays, graph {{databases}} {{are employed}} when relationships between entities {{are in the}} scope of database queries to avoid performance-critical join operations of relational databases. Graph queries are used to query and modify <b>graphs</b> <b>stored</b> in <b>graph</b> databases. Graph queries employ graph pattern matching that is NP-complete for subgraph isomorphism. Graph database views can be employed that keep ready answers in terms of precalculated graph pattern matches for often stated and complex graph queries to increase query performance. However, such graph database views must be kept consistent with the <b>graphs</b> <b>stored</b> in the <b>graph</b> database. In this paper, we describe how to use incremental graph pattern matching as technique for maintaining graph database views. We present an incremental maintenance algorithm for graph database views, which works for imperatively and declaratively specified graph queries. The evaluation shows that our maintenance algorithm scales {{when the number of}} nodes and edges <b>stored</b> in the <b>graph</b> database increases. Furthermore, our evaluation shows that our approach can outperform existing approaches for the incremental maintenance of <b>graph</b> query <b>results.</b> Comment: In Proceedings GaM 2016, arXiv: 1612. 0105...|$|R
40|$|I have plotted {{an image}} by using {{mathematical}} {{functions in the}} Database " 4 th Dimension". I'm going to show an alternative method to: detect which sector has been clicked; highlight it and combine it with other sectors already highlighted; <b>store</b> the <b>graph</b> information in an efficient way; load and splat image layers to reconstruct the <b>stored</b> <b>graph.</b> Comment: 4 pages, 3 figure...|$|R
5000|$|Performance data {{collection}} exists in OpenNMS {{for a number}} of network protocols including SNMP, HTTP, JMX, WMI, XMP, XML, NSClient, and JDBC. Data can be collected, <b>stored,</b> <b>graphed</b> as well as checked against thresholds.|$|R
5000|$|A graph {{database}} {{is a kind}} of NoSQL {{database that}} uses graph structures with nodes, edges, and properties to represent and <b>store</b> information. General <b>graph</b> databases that can <b>store</b> any <b>graph</b> are distinct from specialized graph databases such as triplestores and network databases.|$|R
40|$|This paper {{describes}} a interchangable file format for <b>storing</b> <b>graphs</b> in a file, {{as it is}} used by the GraphEd system. This format combines an adjacency list with embedded graphical information. It is designed as an extendible format and provides facilities such that other programs can easily add their own information in their own format. 1 Introduction With the devopment of several graph editors and graph manipulation packages, such as GraphEd [2, 3], EDGE [7], VEGA, vcg [6], gem, dot, graphbase [5], or daVinci [1], several formats for <b>storing</b> <b>graphs</b> have been implemented. However, nearly each tool uses its own format, and almost all of them are pairwise incompatible. Exceptions are VCG which uses EDGE's format, and gem uses GraphEd's format. As a consequence, it is quite difficult to exchange graphs between different tools. Not only the syntax is different, there are also several semantic differences: ffl Some formats support only directed or only undirected graphs. ffl Some formats [...] ...|$|R
3000|$|... is satisfied. Thus, if {{we assume}} that we have {{sufficient}} memory for <b>storing</b> reduced <b>graphs,</b> the proposed approach is better than Dijkstra’s and A* algorithms; taking into account that if we reduce original graph as proposed before, always we can obtain a response in a lower runtime. The proposal is not useful when the available memory is low and does not permit to <b>store</b> reduced <b>graphs.</b>|$|R
50|$|A graph {{database}} {{has a more}} generalized structure than a triplestore, using graph structures with nodes, edges, and {{properties to}} represent and <b>store</b> data. <b>Graph</b> databases might provide index-free adjacency, meaning every element contains a direct pointer to its adjacent elements, and no index lookups are necessary. General graph databases that can <b>store</b> any <b>graph</b> are distinct from specialized graph databases such as triplestores and network databases.|$|R
5000|$|... #Caption: <b>Graph</b> <b>resulting</b> {{from the}} RDFa example, enriched with further {{data from the}} Web ...|$|R
40|$|Graphs are the {{ubiquitous}} models for constructing {{both natural and}} human-made structures. Many practical problems can be represented by graphs. They {{can be used to}} model many applications such as physical, biological and social systems. With the emergence of these applications, developments of graph databases are very useful to <b>store</b> <b>graph</b> data. Due to the existence of noise (e. g., duplicated graphs) in the graph database, we investigate the problem of <b>storing</b> the same <b>graphs</b> in the single graph database. Therefore, detecting and eliminating of automorphic graphs in a graph database become an important research area. In this paper, we propose a novel DAGC algorithm to identify and removal of automorphic <b>graph</b> <b>storing</b> into the <b>graph</b> database using AdE index structure. AdE index structure incorporates graph structural information of each graph in the database. The computational time complexity is significantly reduced compared to canonical labeling approach used in most graph matching algorithms and F-GAF algorithm. This paper demonstrates the effectiveness and efficiency of the proposed method through experiments on various types of graphs...|$|R
5000|$|... the {{elements}} of the cover are the cliques of the <b>graph</b> <b>resulting</b> from enforcing chordality; ...|$|R
50|$|Some Schema markups such as Organization and Person {{are used}} to {{influence}} Google's Knowledge <b>Graph</b> <b>results.</b>|$|R
40|$|We {{present an}} {{algorithm}} {{to solve the}} graph isomorphism problem {{for the purpose of}} object recognition. Objects, such as those that exist in a robot workspace, may be represented by labeled graphs (graphs with attributes on their nodes and/or edges). Object recognition, thereafter, is achieved by matching pairs of these graphs. Assuming that all objects are sufficiently different that their corresponding representative graphs are distinct, then given a new graph, the algorithm efficiently finds the isomorphic <b>stored</b> <b>graph</b> (if it exists). The algorithm consists of three phases: preprocessing, link construction, and ambiguity resolution. Results from experiments on a wide variety and sizes of <b>graphs</b> are reported. <b>Results</b> are also reported for experiments on recognizing graphs that represent protein molecules. The algorithm works for all types of graphs except for a class of highly ambiguous graphs that includes strongly regular graphs. However, members of this class are detected in polynom [...] ...|$|R
50|$|Every {{orientation}} {{of a tree}} is acyclic. The directed acyclic <b>graph</b> <b>resulting</b> from such an orientation is called a polytree.|$|R
25|$|A {{subdivision}} of a <b>graph</b> <b>results</b> from inserting vertices into edges (for example, changing an edge •• to •••) zero or more times.|$|R
5000|$|AG-relation (Association <b>Graph)</b> <b>stores</b> {{association}} relationships ...|$|R
5000|$|CG-relation (Characteristic <b>Graph)</b> <b>stores</b> {{characteristic}} relationships ...|$|R
5000|$|The {{problem is}} then to {{determine}} algorithmically whether {{one of the}} <b>graphs</b> <b>resulting</b> from this process contains a clique of at least [...] vertices.|$|R
25|$|There are {{different}} ways to <b>store</b> <b>graphs</b> in a computer system. The data structure used depends on both the graph structure and the algorithm used for manipulating the graph. Theoretically one can distinguish between list and matrix structures but in concrete applications the best structure is often a combination of both. List structures are often preferred for sparse graphs as they have smaller memory requirements. Matrix structures {{on the other hand}} provide faster access for some applications but can consume huge amounts of memory.|$|R
5000|$|Formspring uses Cassandra {{to count}} responses, {{as well as}} <b>store</b> Social <b>Graph</b> data (followers, following, blockers, blocking) for 26 Million {{accounts}} with 10 million responses a day ...|$|R
40|$|The <b>graph</b> <b>resulting</b> from {{contracting}} edge "e" is denoted as G/e and the <b>graph</b> <b>resulting</b> from deleting edge "e" is denoted as G-e. An edge "e" is radius-essential if rad(G/e) rad(G), and radius-vital {{if it is}} both radius-essential and radius-increasing. We partition {{the edges}} that are not radius-vital into three categories. In this paper, we study realizability questions relating {{to the number of}} edges that are not radius-vital in the three defined categories. A graph is radius-vital if all its edges are radius-vital. We give a structural characterization of radius-vital graphs...|$|R
50|$|Maps are <b>stored</b> as <b>graphs,</b> or two {{dimensional}} arrays of objects with attributes of location and category, where some common categories include parks, roads, cities, and the like.|$|R
40|$|We {{study the}} ALT {{algorithm}} [19] for the point-to-point shortest path {{problem in the}} context of road networks. We suggest improvements to the algorithm itself and to its preprocessing stage. We also develop a memory-efficient implementation of the algorithm that runs on a Pocket PC. It <b>stores</b> <b>graph</b> data in a flash memory card and uses RAM to store information only for the part of the graph visited by the current shortest path computation. The implementation works even on very large graphs, including that of the North America road network, with almost 30 million vertices...|$|R
50|$|The ABC-machine has an {{uncommon}} memory model. It has a <b>graph</b> <b>store</b> {{to hold the}} Clean graph that is being rewritten. The A(rgument)-stack holds arguments that refer to nodes in the <b>graph</b> <b>store.</b> This way, a node's arguments can be rewritten, which is needed for pattern matching. The B(asic value)-stack holds basic values (integers, characters, reals, etc.). While not strictly necessary (all these elements could be nodes in the <b>graph</b> <b>store</b> as well), using a separate stack is much more efficient. The C(ontrol)-stack holds return addresses for flow control.|$|R
40|$|I have plotted {{an image}} (Figure 1) by using {{mathematical}} functions. I’m {{going to show}} an alternative method to: detect which sector has been clicked; highlight it and combine it with other sectors already highlighted; <b>store</b> the <b>graph</b> information in an efficient way; load and splat image layers to reconstruct the <b>stored</b> <b>graph.</b> 1 Detecting the clicked area Instead of using the button grid method or the generalized image maps [2], to discretize the space and approximate the curves with rectangles, I’m using an alternative system to detect the clicked image partition based on a mathematical continuous representation. Any window {{can be considered as}} a cartesian plane having the upper/left corner as center and having the y axes reversed. One can make a translation so that the center of the window coincides with the center of the cartesian plane as well. Let (x 0,y 0) be the new center; let (mx,my) be the clicked point; the following procedure shows how to evaluate the translated coordinates (x,y) ...|$|R
30|$|Calibration <b>graphs</b> <b>resulting</b> from {{plotting}} {{the potential}} values in dependence to the corresponding final concentration values {{turned out to}} be linear in a concentration range as referred to in Fig.  1.|$|R
5000|$|A {{subdivision}} of a <b>graph</b> <b>results</b> from inserting vertices into edges (for example, changing an edge • - [...] - • to • - • - •) zero or more times.|$|R
50|$|Another result {{found by}} Elias Dahlhaus is: A bipartite graph B = (X,Y,E) is chordal bipartite if {{and only if}} the split <b>graph</b> <b>resulting</b> from making X a clique is {{strongly}} chordal.|$|R
40|$|In {{contemporary}} world, {{there is}} a lot of different social applications. This work aims to create user friendly genealogic application similar to MyHeritage. com. This application allows users to create and edit their own family tree, search for matches based on similarity with the possibility to merge family trees. Among other functionalities, the application provides users with possibilities to create photogallery, share information or display profiles of other persons. As a base for processing and <b>storing</b> <b>graph</b> data like family trees graph database Neo 4 j was used whose performance was later tested and compared with selected relational database...|$|R
40|$|This paper {{presents}} a heuristic for guiding A* search for finding the shortest distance path between two vertices in a connected, undirected, and explicitly <b>stored</b> <b>graph.</b> The heuristic requires {{a small amount}} of data to be stored at each vertex. The heuristic has application to quickly detecting relationships between two vertices in a large information or knowledge network. We compare the performance of this heuristic with breadth-first search on graphs with various topological properties. The results show that one or more orders of magnitude improvement in the number of vertices expanded is possible for large graphs, including Poisson random graphs...|$|R
40|$|In {{order to}} realize {{the vision of the}} Semantic Web, a {{semantic}} model for encoding content in the World Wide Web, efficient storage and retrieval of large RDF data sets is required. A common technique for <b>storing</b> RDF data (<b>graphs)</b> is to use a single relational database table, a triple <b>store,</b> for the <b>graph.</b> However...|$|R
40|$|A graph G {{is called}} perfect if the {{chromatic}} {{number and the}} clique number have the same value for every of its induced subgraph. A glued <b>graph</b> <b>results</b> from combining two vertex-disjoint graphs by identifying connected isomorphic subgraphs of both graphs. Such subgraphs {{are referred to as}} the clones. We study the perfection of glued graphs whose clones are complete <b>graphs.</b> Our <b>result</b> generalizes the simplicial elimination ordering which is a characterization of chordal graphs...|$|R
40|$|The {{large volumes}} of {{information}} that arise from telecommunications and cyberspace systems can be represented by massive digraphs. The size of these graphs are so huge that {{they are unable to}} be processed by current technologies. The graphs require new and innovative methods of processing and visualizing. Graph surfaces of hierarchical graph slices have been suggested as a way of representing massive digraphs. In this chapter an approach is presented which involves encoding Lipschitz functions into monotone k-logic functions using symmetric chain decompositions (SeD). This approach proposes to address some of the issues concerning huge graphs by providing memory minimization techniques that can be applied to <b>storing</b> <b>graph</b> surfaces...|$|R
40|$|A vertex set S of a graph G is convex if all {{vertices}} {{of every}} shortest path {{between two of}} its vertices are in S. We say that G has a convex p-cover if  can be covered by p convex sets. The convex cover number of G is the least  for which G has a convex p- cover. In particular, the nontrivial convex cover number of G is the least  for which G has a convex p- cover, where every set contains at least 3 elements. In this paper we determine convex cover number and nontrivial convex cover number of special <b>graphs</b> <b>resulting</b> from some operations. We examine <b>graphs</b> <b>resulting</b> from join of graphs, cartesian product of graphs, lexicographic product of graphs and corona of graphs. </p...|$|R
40|$|AbstractIn this paper, we {{prove that}} any simple and cosimple {{connected}} binary matroid {{has at least}} four connected hyperplanes. We further prove that each element in such a matroid is contained {{in at least two}} connected hyperplanes. Our main result generalizes a matroid result of Kelmans, and independently, of Seymour. The following consequence of the main <b>result</b> generalizes a <b>graph</b> <b>result</b> of Thomassen and Toft on induced non-separating cycles and another <b>graph</b> <b>result</b> of Kaugars on deletable vertices. If G is a simple 2 -connected graph with minimum degree at least 3, then, for every edge e, {{there are at least two}} induced non-separating cycles avoiding e and two deletable vertices non-incident to e. Moreover, G has at least four induced non-separating cycles...|$|R
40|$|We {{define and}} {{investigate}} properties of universal operator algebras of directed <b>graphs.</b> <b>Results</b> include free products decomposition and {{continuity of the}} construction with respect to direct limits. Lastly we prove some K-theoretic results about our algebras. Comment: 19 pages, uses xypic, submitted to Houston Journal of Mathematic...|$|R
40|$|The aim of {{this paper}} is to lower bound the {{connectivity}} of k-path graphs. From the bounds obtained, we give conditions to guarantee maximum connectivity. Then, it is shown that those maximally connected graphs satisfying the previous conditions are also super-lambda. While doing so, we derive some properties about the girth and the diameter of path <b>graphs.</b> Finally, the <b>results</b> are extended to path <b>graphs</b> <b>resulting</b> from the iteration of the k-path graph operator...|$|R
