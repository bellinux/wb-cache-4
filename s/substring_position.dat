1|9|Public
40|$|Existing Searchable Encryption (SE) {{solutions}} {{are able to}} handle simple Boolean search queries, such as single or multi-keyword queries, but cannot handle substring search queries over encrypted data that also involve identifying {{the position of the}} substring within the document. These types of queries are relevant in areas such as searching DNA data. In this paper, we propose a tree-based <b>Substring</b> <b>Position</b> Searchable Symmetric Encryption (SSP-SSE) to overcome the existing gap. Our solution efficiently finds occurrences of a given substring over encrypted cloud data. Specifically, our construction uses the position heap tree data structure and achieves asymptotic efficiency comparable to that of an unencrypted position heap tree. Our encryption takes O (k n) time, and the resulting ciphertext is of size O (k n), where k is a security parameter and n is the size of stored data. The search takes O (m 2 + o c c) time and three rounds of communication, where m is the length of the queried substring and o c c is the number of occurrences of the substring in the document collection. We prove that the proposed scheme is secure against chosen-query attacks that involve an adaptive adversary. Finally, we extend SSP-SSE to the multi-user setting where an arbitrary group of cloud users can submit substring queries to search the encrypted data...|$|E
5000|$|Given an {{infinite}} string where each character is chosen uniformly at random, any given finite string almost surely occurs as a <b>substring</b> at some <b>position.</b>|$|R
40|$|A bubble {{language}} {{is a set of}} binary strings with a simple closure property: The first 01 of any string can be replaced by 10 to obtain another string in the set. Natural representations of many combinatorial objects are bubble languages. Examples include binary string representations of k-ary trees, unit interval graphs, linear-extensions of B-posets, binary necklaces and Lyndon words, and feasible solutions to knapsack problems. In co-lexicographic order, fixed-density binary strings are ordered so that their suffixes of the form 10 i occur (recursively) in the order i = max,max − 1, [...] .,min + 1,min for some values of max and min. In cool-lex order the suffixes occur (recursively) in the order max − 1, [...] ., min+ 1, min, max. This small change has significant consequences. We prove that the strings in any bubble language appear in a Gray code order when listed in cool-lex order. This Gray code may be viewed from two different perspectives. On the one hand, successive binary strings differ by one or two transpositions, and on the other hand, they differ by a shift of some <b>substring</b> one <b>position</b> to the right. This article also provides the theoretical foundation for many efficient generation algorithms, as well as the firs...|$|R
40|$|An {{indeterminate}} string (or, more simply, just a string) x = x[1 [...] n] on an alphabet Σ is {{a sequence}} of nonempty subsets of Σ. We say that x[i_ 1] and x[i_ 2] match (written x[i_ 1] x[i_ 2]) {{if and only if}} x[i_ 1] ∩x[i_ 2] ∅. A feasible array is an array y = y[1 [...] n] of integers such that y[1] = n and for every i ∈ 2 [...] n, y[i] ∈ 0 [...] n i 1. A prefix table of a string x is an array π = π[1 [...] n] of integers such that, for every i ∈ 1 [...] n, π[i] = j if and only if x[i [...] i j 1] is the longest <b>substring</b> at <b>position</b> i of x that matches a prefix of x. It is known from CRSW 13 that every feasible array is a prefix table of some indetermintate string. A prefix graph P = P_y is a labelled simple graph whose structure is determined by a feasible array y. In this paper we show, given a feasible array y, how to use P_y to construct a lexicographically least indeterminate string on a minimum alphabet whose prefix table π = y. Comment: 13 pages, 1 figur...|$|R
40|$|Abstract—In this paper, we tackle a novel type of {{interesting}} queries — shortest unique substring queries. Given a (long) string S and a query point q in the string, can {{we find a}} shortest substring containing q that is unique in S? We illustrate that shortest unique substring queries have many potential applications, such as information retrieval, bioinformatics, and event context analysis. We develop efficient algorithms for online query answering. First, we present an algorithm to answer a shortest unique substring query in O(n) time using a suffix tree index, where n is the length of string S. Second, we show that, using O(n·h) time and O(n) space, we can compute a shortest unique <b>substring</b> for every <b>position</b> in a given string, where h is variable theoretically in O(n) but on real data sets often much smallerthannandcanbetreatedasaconstant. Oncetheshortest unique substrings are pre-computed, shortest unique substring queries can be answered online in constant time. In addition to the solid algorithmic results, we empirically demonstrate the effectiveness and efficiency of shortest unique substring queries on real data sets. I...|$|R
40|$|Network trafﬁc classiﬁcation is a {{critical}} foundation for trusted network management and security systems. Matching application signatures in trafﬁc payload is widely {{considered to be the}} most reliable classifying method. However, deriving accurate and efﬁcient signatures for various applications is not a trivial task, for which current practice is mostly manual thus error-prone and of low efﬁciency. In this paper, we tackle the problem of automatic signature generation. In particular, we focus on generating regular expression signatures with a certain subset of standard syntax rules, which are of sufﬁcient expressive power and compatible with most practical systems. We propose a novel approach that takes as input a labeled training data set and produces a set of signatures for matching the application classes presented in the data. The approach involves four procedures: pre-processing to extract application session payload, tokenization to ﬁnd common <b>substrings</b> and incorporate <b>position</b> constraints, multiple sequence alignment to ﬁnd common subsequences, and signature construction to transform the results into regular expressions. A real life full payload trafﬁc trace is used to evaluate the proposed system, and signatures for a range of applications are automatically derived. The results indicate that the signatures are of high quality, and exhibit low false negatives and false positives...|$|R
40|$|AbstractWe {{investigate}} a problem which arises in computational biology: Given a constant-size alphabet A with a weight function μ:A→N, find an efficient data structure and query algorithm solving the following problem: For a string σ over A and a weight M∈N, decide whether σ contains a substring with weight M, where {{the weight of}} a string is the sum of the weights of its letters (ONE-STRING MASS FINDING PROBLEM). If the answer is yes, then we may in addition require a witness, i. e., indices i⩽j such that the <b>substring</b> beginning at <b>position</b> i and ending at position j has weight M. We allow preprocessing of the string and measure efficiency in two parameters: storage space required for the preprocessed data and running time of the query algorithm for given M. We are interested in data structures and algorithms requiring subquadratic storage space and sublinear query time, where we measure the input size as the length n of the input string σ. Among others, we present two non-trivial efficient algorithms: LOOKUP solves the problem with O(n) storage space and O(n/logn) time; INTERVAL solves the problem for binary alphabets with O(n) storage space in O(logn) query time. We introduce other variants of the problem and sketch how our algorithms may be extended for these variants. Finally, we discuss combinatorial properties of weighted strings...|$|R
40|$|We {{investigate}} a problem which arises in computational biology: Given a constant– size alphabet A with a weight function µ: A → N, find an efficient data structure and query algorithm solving the following problem: For a string σ over A and a weight M ∈ N, decide whether σ contains a substring with weight M, where {{the weight of}} a string is the sum of the weights of its letters (One–String Mass Finding Problem). If the answer is yes, then we may in addition require a witness, i. e., indices i ≤ j such that the <b>substring</b> beginning at <b>position</b> i and ending at position j has weight M. We allow preprocessing of the string, and measure efficiency in two parameters: storage space required for the preprocessed data, and running time of the query algorithm for given M. We are interested in data structures and algorithms requiring subquadratic storage space and sublinear query time, where we measure the input size as the length n of the input string σ. Among others, we present two non–trivial efficient algorithms: Lookup solves the problem with O(n) storage space and O (n log n) time; Interval solves the problem for binary alphabets with O(n) storage space in O(log n) query time. We introduce other variants of the problem and sketch how our algorithms may be extended for these variants. Finally, we discuss combinatorial properties of weighted strings. ...|$|R
40|$|Motivation: Intimately tied to {{assembly}} {{quality is}} {{the complexity of}} the de Bruijn graph built by the assembler. Thus, there have been many paradigms developed to decrease {{the complexity of the}} de Bruijn graph. One obvious combinatorial paradigm for this is to allow the value of k to vary; having a larger value of k where the graph is more complex and a smaller value of k where the graph would likely contain fewer spurious edges and vertices. One open problem that affects the practicality of this method is how to predict the value of k prior to building the de Bruijn graph. We show that optimal values of k can be predicted prior to assembly by using the information contained in a phylogenetically-close genome and therefore, help make the use of multiple values of k practical for genome assembly. Results: We present HyDA-Vista, which is a genome assembler that uses homology information to choose a value of k for each read prior to the de Bruijn graph construction. The chosen k is optimal if there are no sequencing errors and the coverage is sufficient. Fundamental to our method is the construction of the maximal sequence landscape, which is a data structure that stores for each position in the input string, the largest repeated <b>substring</b> containing that <b>position.</b> In particular, we show the maximal sequence landscape can be constructed in O(n + n log n) -time and O(n) -space. HyDA-Vista first constructs the maximal sequence landscape for a homologous genome. The reads are then aligned to this reference genome, and values of k are assigned to each read using the maximal sequence landscape and the alignments. Eventually, all the reads are assembled by an iterative de Bruijn graph construction method. Our results and comparison to other assemblers demonstrate that HyDA-Vista achieves the best assembly of E. coli before repeat resolution or scaffolding. Availability: HyDA-Vista is freely available [1]. The code for constructing the maximal sequence landscape and choosing the optimal value of k for each read is also separately available on the website and could be incorporated into any genome assembler...|$|R

