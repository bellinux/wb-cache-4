542|318|Public
25|$|The same {{as regular}} {{quicksort}} except the pivot {{is replaced by}} a buffer. First, read the M/2 first and last elements into the buffer and sort them. Read the next element from the beginning or end to balance writing. If the next element is less than the least of the buffer, write it to available space at the beginning. If greater than the greatest, write it to the end. Otherwise write the greatest or least of the buffer, and put the next element in the buffer. Keep the maximum lower and minimum upper keys written to avoid resorting middle elements that are in order. When done, write the buffer. Recursively sort the smaller partition, and loop to sort the remaining partition. This is a kind of three-way quicksort in which the middle partition (buffer) represents a sorted <b>subarray</b> of elements that are approximately equal to the pivot.|$|E
500|$|Uniform {{binary search}} stores, {{instead of the}} lower and upper bounds, the index of the middle element and {{the change in the}} middle element from the current {{iteration}} to the next iteration. Each step reduces the change by about half. For example, if the array to be searched was , the middle element would be [...] Uniform binary search works on the basis that the difference between the index of middle element of the array and the left and right subarrays is the same. In this case, the middle element of the left <b>subarray</b> (...) is [...] and the middle element of the right <b>subarray</b> (...) is [...] Uniform binary search would store the value of [...] as both indices differ from [...] by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the middle element. The main advantage of uniform binary search is that the procedure can store a table of the differences between indices for each iteration of the procedure, which may improve the algorithm's performance on some systems.|$|E
500|$|The {{worst case}} is [...] {{iterations}} of the comparison loop, where the [...] notation denotes the floor function that rounds its argument to the next-smallest integer and [...] is the binary logarithm. The worst case is reached when the search reaches the deepest {{level of the}} tree, equivalent to a binary search that has reduced to one element and, in each iteration, always eliminates the smaller <b>subarray</b> out of the two {{if they are not}} of equal size.|$|E
3000|$|The {{positions}} of the <b>subarrays</b> were chosen by hand {{in order to be}} irregular. The distances between <b>subarrays</b> were selected to correspond to <b>subarrays</b> placed on the walls of a room. The <b>subarrays</b> have planar geometry in vertical plains, rotated around their vertical axes so that their broadside directions (approximately) point {{to the center of the}} area between <b>subarrays</b> (the room). Geometry G 2 is formed from G 1 by scaling up by a factor of five the antenna positions in the <b>subarrays</b> with respect to their centers (omni antennas). The simulations were carried out using a known deterministic sequence, the first of the modulatable orthogonal sequences proposed in [40] for a given N. The parameters were as follows: ν [...]...|$|R
40|$|High-performance cache {{architectures}} always {{pull up the}} bitlines in all cache <b>subarrays</b> to {{hide the}} bitline charging latency prior to a cache access. Unfortunately, such architectures lead to significant bitline discharge in unaccessed <b>subarrays</b> in nanoscale CMOS caches and waste power. Recent proposals advocate bitline isolation to reduce bitline discharge in unaccessed <b>subarrays</b> by turning off precharge devices located between the supply voltage and bitlines in these <b>subarrays.</b> Many of these proposals tacitly assume that on-demand precharging of isolated bitlines can be overlapped with address decoding and hidden from the cache access latency. Moreover, they assume that the energy overhead of switching precharge devices is insignificant...|$|R
40|$|An array antenna, {{which has}} {{a large number of}} {{radiating}} element, is divided into <b>subarrays.</b> The current distribution of the planar array antenna is approximated as a Taylor distribution using the genetic algorithm to combine <b>subarrays</b> having the same current distribution. Doing this simplifies the feed systems. By considering the planar array antenna as an aggregate of <b>subarrays,</b> designs, production, inspection, and maintenance are simplified, which in turn reduces costs. 本論文では, 平面アレーアンテナをサブアレーに分割し, サブアレーを構成するアンテナ素子数をパラメータとして, 同一の波源分布のサブアレーを組合せることにより, 平面アレーアンテナの波源分布がテーラ分布に, 限りなく近くなるよう遺伝的アルゴリズムを用いている. そして, サブアレーの給電分布を求めることにより, 給電系の簡略化が図られることを示している...|$|R
500|$|On average, {{assuming}} that each element is equally {{likely to be}} searched, the procedure will most likely find the target value the second-deepest level of the tree. This is equivalent to a binary search that completes one iteration before the worst case, reached after [...] iterations. However, the tree may be unbalanced, with the deepest level partially filled. Equivalently, the array may not be divided exactly in half by the search in some iterations, half of the time resulting in the smaller <b>subarray</b> being eliminated. This cannot occur if {{the size of the}} array is one less than a power of two, but otherwise the actual number of average iterations is slightly higher, at [...] iterations. In the best case, where the target value is the middle element of the array, its position is returned after one iteration.|$|E
2500|$|Selecting a pivot {{element is}} also {{complicated}} by the existence of integer overflow. If the boundary indices of the <b>subarray</b> being sorted are sufficiently large, the naïve expression for the middle index, , will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, [...] to index the middle element, {{at the cost of}} more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.|$|E
2500|$|Once every [...] and [...] {{block of}} every [...] and [...] <b>subarray</b> have been merged for {{that level of}} the merge sort, the values in that buffer must be sorted to restore their {{original}} order, so an insertion sort must be applied. The values in the buffers are then redistributed to their first sorted position within the array. This process repeats for each level of the outer bottom-up merge sort, {{at which point the}} array will have been stably sorted.|$|E
40|$|A fast {{direction}} of arrival (DOA) estimation method using a real-valued cross-correlation matrix (CCM) of coprime <b>subarrays</b> is proposed. Firstly, real-valued CCM with extended aperture is constructed {{to obtain the}} signal subspaces corresponding to the two <b>subarrays.</b> By analysing {{the relationship between the}} two subspaces, DOA estimations from the two <b>subarrays</b> are simultaneously obtained with automatic pairing. Finally, unique DOA is determined based on the common results from the two <b>subarrays.</b> Compared to partial spectral search (PSS) method and estimation of signal parameter via rotational invariance (ESPRIT) based method for coprime arrays, the proposed algorithm has lower complexity but achieves better DOA estimation performance and handles more sources. Simulation results verify the effectiveness of the approach...|$|R
40|$|This paper {{presents}} new results {{showing the}} application of polyomino-based <b>subarrays</b> to limited field of view and wideband, wide-angle scanning. This technology can {{reduce the number of}} phase controls in arrays used for limited sector coverage or the number of time delay devices for wideband radar or communications, and so can reduce the cost of space-based active arrays. We concentrate on the wideband application. Results are presented by comparing the gain and peak sidelobe results of irregular polyomino subarray-based arrays with those of rectangular <b>subarrays.</b> It is shown that using irregular polyomino <b>subarrays</b> can result in a major decrease in sidelobes while presenting, in most cases, only a few tenths of a dB gain reduction compared to rectangular <b>subarrays...</b>|$|R
50|$|Funnelsort {{is similar}} to merge sort in that some number of <b>subarrays</b> are recursively sorted, after which a merging step {{combines}} the <b>subarrays</b> into one sorted array. Merging is performed by a device called a k-merger, which is described in the section below.|$|R
2500|$|This {{algorithm}} {{is a combination}} of radix sort and quicksort. Pick an element from the array (the pivot) and consider the first character (key) of the string (multikey). Partition the remaining elements into three sets: those whose corresponding character is less than, equal to, and greater than the pivot's character. Recursively sort the [...] "less than" [...] and [...] "greater than" [...] partitions on the same character. Recursively sort the [...] "equal to" [...] partition by the next character (key). Given we sort using bytes or words of length W bits, the best case is O(KN) and the worst case O(2KN) or at least O(N2) as for standard quicksort, given for unique keys N<2K, and K is a hidden constant in all standard comparison sort algorithms including quicksort. This is a kind of three-way quicksort in which the middle partition represents a (trivially) sorted <b>subarray</b> of elements that are exactly equal to the pivot.|$|E
5000|$|Kadane's {{algorithm}} {{begins with}} a simple inductive question: if we know the maximum <b>subarray</b> sum ending at position , what is the maximum <b>subarray</b> sum ending at position ? The answer {{turns out to be}} relatively straightforward: either the maximum <b>subarray</b> sum ending at position [...] includes the maximum <b>subarray</b> sum ending at position [...] as a prefix, or it doesn't. Thus, we can compute the maximum <b>subarray</b> sum ending at position [...] for all positions [...] by iterating once over the array. As we go, we simply keep track of the maximum sum we've ever seen. Thus, the problem can be solved with the following code, expressed here in Python: ...|$|E
50|$|In {{computer}} science, {{the maximum}} <b>subarray</b> {{problem is the}} task of finding the contiguous <b>subarray</b> within a one-dimensional array of numbers which has the largest sum. For example, for the sequence of values &minus;2, 1, &minus;3, 4, &minus;1, 2, 1, &minus;5, 4; the contiguous <b>subarray</b> with the largest sum is 4, &minus;1, 2, 1, with sum 6.|$|E
2500|$|The outer loop of block sort is {{identical}} to a bottom-up merge sort, where each level of the sort merges pairs of <b>subarrays,</b> [...] and , in sizes of 1, then 2, then 4, 8, 16, and so on, until both <b>subarrays</b> combined are the array itself.|$|R
40|$|High-performance caches statically {{pull up the}} bitlines in all cache <b>subarrays</b> to {{optimize}} cache access latency. Unfortunately, such an architecture results in a significant waste of energy in nanoscale CMOS implementations due to high leakage and bitline discharge in the unaccessed <b>subarrays.</b> Recent research advocates bitline isolation to control precharging of individual <b>subarrays</b> using bitline precharge devices. In this paper, we carefully evaluate the energy and performance trade-offs of bitline isolation, and propose a technique to exploit nearly its full potential to eliminate discharge and reduce overall energy in level-one caches. Cycle...|$|R
40|$|The popular ESPRIT {{algorithm}} {{provides a}} computationally eficient approach for direction of arrival (DOA) estimation {{in situations where}} the sensor array is composed of two identical translated <b>subarrays.</b> One of the key advantages of ESPRIT is that the <b>subarrays</b> need not be calibrated {{in order to obtain}} the DOA estimates. In this paper, the problem of DOA estimation using sensor arrays composed of two identical, uncalibrated, and rotated <b>subarrays</b> is considered. It is ahown that, unlike ESPRIT, such rotationally invariant arrays do not provide an identifiable parameterization of the problem; i. e., unique DOA estimates are not possible without additional calibration infor-mation when more than one signal is present. 1...|$|R
5000|$|To {{accomplish}} this, each <b>subarray</b> and bucket {{will have}} a state associated with it. The state of a <b>subarray</b> consists of an index next of the next element to be read from the <b>subarray,</b> and a bucket number bnum indicating which bucket index the element should be copied to. By convention, [...] if all elements in the <b>subarray</b> have been distributed. (Note that when we split a bucket, we have to increment all bnum values of all subarrays whose bnum value {{is greater than the}} index of the bucket that is split.) The state of a bucket consists {{of the value of the}} bucket's pivot, and the number of elements currently in the bucket.|$|E
50|$|Because of the {{way this}} {{algorithm}} uses optimal substructures (the maximum <b>subarray</b> ending at each position is calculated in a simple way from a related but smaller and overlapping subproblem: the maximum <b>subarray</b> ending at the previous position) this algorithm {{can be viewed as}} a simple/trivial example of dynamic programming.|$|E
5000|$|Average case: Each <b>subarray</b> is at most size c, a constant; {{insertion}} sort for each <b>subarray</b> is then O(c^2) at worst - a constant. (The actual {{time can be}} much better, since c items are not sorted until the last item {{is placed in the}} bucket). Total time is the number of buckets, (n/c), times [...] = [...]|$|E
5000|$|The Maximum sum k-disjoint <b>subarrays</b> {{can also}} be {{computed}} in the optimal time bound [...]|$|R
40|$|This paper {{explores the}} use of <b>subarrays</b> as array elements. Benefits of such a concept include {{improved}} gain in any direction without significantly increasing the overall size of the array and enhanced pattern control. The architecture for an array of <b>subarrays</b> will be discussed via a systems approach. Individual system designs are explored in further details and proof of principle is illustrated through a manufactured examples...|$|R
40|$|Ternary {{adjusting}} method is proposed and combined with {{particle swarm optimization}} (PSO) algorithm for <b>subarrayed</b> antenna array synthesis. Ternary variables are introduced to represent element adjustments between adjacent <b>subarrays.</b> Compared to previous methods, rounding-off operations are not required any longer, and the equation constraint of the fixed total element number is also removed, which effectively reduces the complexity of implementation while obtaining improved topology exploration capability simultaneously...|$|R
50|$|GURT {{is a large}} {{phased array}} {{composed}} of many identical subarrays. The basic part of this radio telescope is a square regular <b>subarray</b> made of 25 active dipoles (5×5). The distance between the crossed dipole antenna elements in the <b>subarray</b> is 3.75 m, the suspension height is 1.6 m. The <b>subarray</b> design provides a wide frequency coverage from 8 to 80 MHz, high sensitivity (the galactic background level exceeds their self-noise by more than 7 dB), and high RFI immunity (achieved due to high dynamic range of the dipole amplifier: input IP3 is 30 dBm). The effective area at the central frequency is about 350 m². The HPBW of a single <b>subarray</b> beam at 40 MHz is about 20.4°. The estimate {{is consistent with the}} direct measurements that give 22±2°. The GURT <b>subarray</b> geometry provides a high filling factor that is important for a number of research tasks. Phasing inside a <b>subarray</b> is accomplished by analogue devices whereas the phasing between subarrays is planned to be digital. A powerful dedicated digital recorder for the GURT system has been developed at the IRA NASU. It is designed for spectral analysis of a band up to 80 MHz (at a sampling frequency of 160 MHz), with high spectral and temporal resolutions, high dynamic range and several operation modes including real time FFT, waveform recording, auto- and cross-correlation spectral measurements, addition and subtraction regime between the two input channels, normalization, and programmable signal delay.|$|E
5000|$|... #Caption: Fig. 7: EIRP versus {{number of}} antenna {{elements}} in a passive <b>subarray.</b>|$|E
5000|$|Partition {{the array}} into [...] {{contiguous}} subarrays of size , and recursively sort each <b>subarray.</b>|$|E
50|$|GURT, {{currently}} under construction, {{will consist of}} many (up to 100) identical <b>subarrays.</b> The available area of the S. Y. Braude observatory exceeds one square kilometer. Construction of new <b>subarrays</b> is successive, spanning {{over a period of}} time, as resources become available. With increase of number of <b>subarrays</b> and effective area the number of astrophysical problems to be solved by GURT will increase significantly. Joint simultaneous observations of radio astronomical sources with many instruments {{all over the world are}} very important at low frequencies due to many hindering factors. Various RFI conditions, different impact of ionosphere at the site of radio telescope, various configurations and parameters of distant radio telescopes increase significantly the informativity of received signals.|$|R
5000|$|Partition: Using a {{carefully}} chosen mapKey function, divide the A2 into <b>subarrays</b> using {{the keys in}} A ...|$|R
30|$|First, {{we tested}} {{each of the}} {{elements}} in the four transmitter stations (i.e., TA 1, TA 2, TA 3, and TA 4). We then examined each of the third-level <b>subarrays</b> of the four transmitter stations and analyzed all of the measured waveforms {{as well as their}} corresponding spectra. Furthermore, we measured the horizontal directivity of the third-level <b>subarrays</b> as well as the horizontal and vertical directivities of the combined arc arrays.|$|R
5000|$|... #Caption: Fig. 8: EIRP x Gr/T versus {{number of}} antenna {{elements}} in a passive <b>subarray.</b>|$|E
5000|$|... {{for each}} key, compute the <b>subarray</b> it will map to, using {{an array of}} [...] "locations," [...] L ...|$|E
5000|$|... {{determine}} how many keys will map to the same <b>subarray,</b> using an array of [...] "hit counts," [...] H ...|$|E
5000|$|On modern computers, {{locality}} {{of reference}} {{can be of}} paramount importance in software optimization, because multilevel memory hierarchies are used. Cache-aware versions of the merge sort algorithm, whose operations have been specifically chosen to minimize the movement of pages {{in and out of}} a machine's memory cache, have been proposed. For example, the [...] algorithm stops partitioning <b>subarrays</b> when <b>subarrays</b> of size S are reached, where S is the number of data items fitting into a CPU's cache. Each of these <b>subarrays</b> is sorted with an in-place sorting algorithm such as insertion sort, to discourage memory swaps, and normal merge sort is then completed in the standard recursive fashion. This algorithm has demonstrated better performance [...] on machines that benefit from cache optimization.|$|R
5000|$|Collect: Visit the <b>subarrays</b> {{in order}} and put all the {{elements}} back into the original array, or simply use A2.|$|R
5000|$|... #Caption: Dynamic {{spectra of}} solar bursts of type III and IIIb-III {{received}} with GURT <b>subarrays</b> #9 and #10 on November 30, 2016 ...|$|R
