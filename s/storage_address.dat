18|262|Public
2500|$|The {{following}} example reads a disk record {{identified by}} a recorded key. [...] The track containing {{the record and}} the desired value of the key is known. [...] The device control unit will search the track to find the requested record. [...] In this example <> indicate that the channel program contains the <b>storage</b> <b>address</b> of the specified field.|$|E
2500|$|Technologies of [...] {{hydrogen}} economy, batteries, {{compressed air}} energy storage, and flywheel energy <b>storage</b> <b>address</b> the energy storage problem {{but not the}} source of primary energy. [...] Other technologies like fission power, fusion power, and solar power {{address the problem of}} a source of primary energy but not energy storage. [...] Vegetable oil addresses both the source of primary energy and of energy storage. The cost and weight to store a given amount of energy as vegetable oil is low compared to many of the potential replacements for fossil fuels.|$|E
2500|$|To load a system, a 24-byte {{data area}} is loaded into main storage {{from the first}} block of the {{selected}} IPL device at location 0 and {{the second and third}} 8 byte data areas, which are Read IPL-type CCWs, are initiated from the [...] "implied" [...] CCW, and this channel program continuation causes the first portion of the system loading software to be loaded elsewhere in main storage. The first 8 byte data area contains a PSW which, when fetched {{at the conclusion of the}} IPL, causes the CPU to branch to the bootstrap loader (called [...] "IPL Text") at the main <b>storage</b> <b>address</b> where it was just loaded. The IPL Text is then executed, and eventually the operating system's nucleus is loaded and is branched to, after which normal OS operations commences.|$|E
5000|$|Machine breakpointsEarly {{mainframe}} computers, {{such as the}} IBM/360, had console switches/dials {{that allowed}} breakpoints at specific instruction <b>storage</b> <b>addresses</b> and provided [...] "single cycle" [...] operation, permitting the contents of registers and memory to be observed directly on console lights. The advent of multitasking limited {{the use of this}} option since the entire machine was halted.|$|R
40|$|The optimal {{probability}} of activation {{and the corresponding}} performance is studied for three designs of Sparse Distributed Memory, namely, Kanerva's original design, Jaeckel's selected-coordinates design and Karlsson's modification of Jaeckel's design. We will assume that the hard locations (in Karlsson's case, the masks), the <b>storage</b> <b>addresses</b> and the stored data are randomly chosen, and we will consider different levels of random noise in the reading address. Keywords: Sparse Distributed Memory, Probability of Activation, Performance Contents 1. Introduction 2 2. General definitions and assumptions 2 3. The error probability and the signal-to-noise ratio 4 4. Determination of the signal-to-noise ratio 5 5. Discussion of the normal approximation of Z 9 6. Discussion of the randomness assumptions for hard locations, <b>storage</b> <b>addresses</b> etc. 10 7. Numerical calculations 12 8. Summary and conclusions 13 References 13 Tables 14 1 Real World Computing Partnership 2 Swedish Institute of C [...] ...|$|R
40|$|The optimal {{probability}} of activation {{and the corresponding}} performance is studied for three designs of Sparse Distributed Memory, namely, Kanerva's original design, Jaeckel's selected-coordinates design and Karlsson's modification of Jaeckel's design. We will assume that the hard locations (in Karlsson's case, the masks), the <b>storage</b> <b>addresses</b> and the stored data are randomly chosen, and we will consider different levels of random noise in the reading address. ...|$|R
50|$|The {{following}} {{example of}} a channel program reads a disk record identified by a Key field. The track containing the record and the desired value of the key is known. The SCU will search the track to find the requested record. In this example <> indicate that the channel program contains the <b>storage</b> <b>address</b> of the specified field.|$|E
50|$|A single (fast) lookup is {{performed}} {{to read the}} tag in the lookup table at the index specified by the lowest bits of the desired external <b>storage</b> <b>address,</b> and {{to determine if the}} memory address is hit by the cache. When a hit is found, no access to external memory is needed (except for write operations, where the cached value may need to be updated asynchronously to the slower memory after some time, or if the position in the cache must be replaced to cache another address).|$|E
50|$|Technologies of {{hydrogen}} economy, batteries, compressed air energy storage, and flywheel energy <b>storage</b> <b>address</b> the energy storage problem {{but not the}} source of primary energy. Other technologies like fission power, fusion power, and solar power {{address the problem of}} a source of primary energy but not energy storage. Vegetable oil addresses both the source of primary energy and of energy storage. The cost and weight to store a given amount of energy as vegetable oil is low compared to many of the potential replacements for fossil fuels.|$|E
5000|$|ESA/390 {{is arguably}} a 32-bit architecture; as with System/360, System/370, 370-XA, and ESA/370, the {{general-purpose}} registers are 32 bits long, and the arithmetic instructions support 32-bit arithmetic. Only byte-addressable real memory (Central Storage) and Virtual <b>Storage</b> <b>addressing</b> {{is limited to}} 31 bits. (IBM reserved the most significant bit to easily support applications expecting 24-bit addressing, {{as well as to}} sidestep a problem with extending two instructions to handle 32-bit unsigned addresses.) ...|$|R
40|$|The {{first book}} to {{consider}} intermittency {{as a key}} point of an energy system, Energy Intermittency describes different levels of variability for traditional and renewable energy sources, presenting detailed solutions for handling energy intermittency through trade, collaboration, demand management, and active energy <b>storage.</b> <b>Addressing</b> energy supply intermittency systematically, this practical text:Analyzes typical time-distributions and intervals between episodes of demand-supply mismatch and explores their dependence on system layouts and energy source characteristicsSimulates scenarios rega...|$|R
50|$|The CDC 1700 was a 16-bit word minicomputer, {{manufactured}} by the Control Data Corporation with deliveries beginning in May 1966. The 1700 used ones' complement arithmetic and an ASCII-based character set, and supported memory write protection {{on an individual}} word basis. It had one general-purpose register and two indexing registers (one of which was implemented as a dedicated memory location). The instruction set was fairly simple and supported seven <b>storage</b> <b>addressing</b> modes, including multilevel (chained) indirect addressing.|$|R
50|$|The {{language}} {{is unusual in}} having only one data type: a word, a fixed number of bits, usually chosen to align with the architecture's machine word and of adequate capacity to represent any valid <b>storage</b> <b>address.</b> For many machines of the time, this data type was a 16-bit word. This choice later {{proved to be a}} significant problem when BCPL was used on machines in which the smallest addressable item was not a word but a byte, or on machines with larger word sizes such as 32-bit or 64-bit.|$|E
50|$|Delivered from Lincoln Laboratory {{with only}} 4K of core, the machine {{no longer needed}} 16 bits to {{represent}} a <b>storage</b> <b>address.</b> After {{about a year and}} a half, the number of instruction bits was doubled to four, allowing a total of 16 instructions, and an index register was added. This dramatically improved programmability of the machine, but still left room for a later memory expansion to 8K (the four instruction bits and one-bit indexing flag left 13 bits for addressing). This newly modified TX-0 was used to develop a huge number of advances in computing, including speech and handwriting recognition, as well as the tools needed to work on such projects, including text editors and debuggers.|$|E
50|$|Unlike {{standard}} {{computer memory}} (random access memory or RAM) {{in which the}} user supplies a memory address and the RAM returns the data word stored at that address, a CAM is designed such that the user supplies a data word and the CAM searches its entire memory {{to see if that}} data word is stored anywhere in it. If the data word is found, the CAM returns a list of one or more storage addresses where the word was found (and in some architectures, it also returns the contents of that <b>storage</b> <b>address,</b> or other associated pieces of data). Thus, a CAM is the hardware embodiment of what in software terms would be called an associative array.The data word recognition unit was proposed by Dudley Allen Buck in 1955.|$|E
5000|$|Virtual Office - an [...] "out of the box" [...] {{web portal}} for end users {{providing}} access to e-mail, personal file <b>storage,</b> company <b>address</b> book, etc.|$|R
40|$|First {{authored}} book {{to address}} materials' {{role in the}} quest {{for the next generation of}} energy materials Energy balance, efficiency, sustainability, and so on, are some of many facets of energy challenges covered in current research. However, there has not been a monograph that directly covers a spectrum of materials issues in the context of energy conversion, harvesting and <b>storage.</b> <b>Addressing</b> one of the most pressing problems of our time, Materials in Energy Conversion, Harvesting, and Storage illuminates the roles and performance requirements of materials in energy a...|$|R
50|$|In 2012, WeTransfer {{implemented}} a re-design and introduced its premium ‘Plus’ offering, which included bigger file transfers {{as well as}} <b>storage,</b> an <b>address</b> book, {{and the ability to}} password protect your files.|$|R
5000|$|To load a system, a 24-byte {{data area}} is loaded into main storage {{from the first}} block of the {{selected}} IPL device at location 0 and {{the second and third}} 8 byte data areas, which are Read IPL-type CCWs, are initiated from the [...] "implied" [...] CCW, and this channel program continuation causes the first portion of the system loading software to be loaded elsewhere in main storage. The first 8 byte data area contains a PSW which, when fetched {{at the conclusion of the}} IPL, causes the CPU to branch to the bootstrap loader (called [...] "IPL Text") at the main <b>storage</b> <b>address</b> where it was just loaded. The IPL Text is then executed, and eventually the operating system's nucleus is loaded and is branched to, after which normal OS operations commences.|$|E
50|$|SanDisk/Fusion-io's NVMFS file system, {{formerly}} known as Direct File System (DFS), accesses flash memory via a virtual flash storage layer instead of using the traditional block layer API. This file system has two main novel features. First, it lays out files directly in a very large virtual <b>storage</b> <b>address</b> space. Second, it leverages the virtual flash storage layer to perform block allocations and atomic updates. As a result, NVMFS performs better and is much simpler than a traditional Unix file system with similar functionalities. Additionally, this approach avoids the log-on-log performance issues triggered by log-structured file systems. Microbenchmark results show that NVMFS can deliver 94,000 I/O operations per second (IOPS) for direct reads and 71,000 IOPS for direct writes with the virtualized flash storage layer {{on top of a}} first-generation Fusion-io ioDrive. For direct access performance, NVMFS is consistently better than ext3 on the same platform, sometimes by 20%. For buffered access performance, NVMFS is also consistently better than ext3, and sometimes by over 149%. Application benchmarks show that NVMFS outperforms ext3 by 7% to 250% while requiring less CPU power. Additionally, I/O latency is lower with NVMFS compared to ext3.|$|E
40|$|If the stored input {{patterns}} of Kanerva's Sparse Distributed Memory (SDM) are highly correlated, {{utilization of the}} storage capacity is very low compared {{to the case of}} uniformly distributed random input patterns. We consider a variation of SDM that has a better storage capacity utilization for correlated input patterns. This approach uses a separate selection threshold for each physical <b>storage</b> <b>address</b> or hard location. The selection of the hard locations for reading or writing can be done in parallel of which SDM implementations can benefit...|$|E
5000|$|Tesla Motors, {{to apply}} battery <b>storage</b> {{technology}} to <b>address</b> power {{needs in the}} US West (Northern California) region.|$|R
40|$|Survivable storage systems must {{maintain}} data {{and access to}} it in the face of malicious and accidental problems with storage servers, interconnection networks, client systems, and user accounts. These four component types can be grouped into two classes: server-side problems and client-side problems. The PASIS architecture addresses server-side problems, including the connections to those servers, by encoding data with threshold schemes and distributing trust amongst sets of storage servers. Self-securing <b>storage</b> <b>addresses</b> client and user account problems by transparently auditing accesses and versioning data within each storage server. Thus, PASIS clients use threshold schemes to protect themselves from compromised servers, and self-securing servers use full access auditing to protect their data from compromised clients. Together, these techniques can provide truly survivable storage systems...|$|R
50|$|Structured <b>storage</b> <b>addresses</b> some {{inherent}} {{difficulties of}} storing multiple data objects {{within a single}} file. One difficulty arises when an object persisted in the file changes in size due to an update. If the application that is reading/writing the file expects the objects in the file to remain in a certain order, everything following that object's representation in the file {{may need to be}} shifted backward to make room if the object grows, or forward to fill in the space left over if the object shrinks. If the file is large, this could be a costly operation. Of course, there are many possible solutions to this difficulty, but often the application programmer does not want to deal with low level details such as binary file formats.|$|R
40|$|Recoverable {{virtual memory}} refers to regions of a virtual This {{combination}} of circumstances {{is most likely}} to be found in situations involving the meta-data of <b>storage</b> <b>address</b> space on which transactional guarantees are repositories. Thus RVM can benefit a wide range of offered. This paper describes RVM, an efficient, portable, applications from distributed file systems and databases, to and easily used implementation of recoverable virtual object-oriented repositories, CAD tools, and CASE tools. memory for Unix environments. A unique characteristic RVM can also provide runtime support for persistent of RVM is that it allows independent control over the programming languages. Since RVM allows independent transactional properties of atomicity, permanence, and serializability. This leads to considerable flexibility in the use of RVM, potentially enlarging the range of applications than can benefit from transactions. It also control over the basic transactional properties of atomicity...|$|E
40|$|Laboratory {{simulations}} of Martian CO 2 <b>storage</b> <b>address</b> whether carbonate formation could have reduced CO 2 pressure from a hypothetical greater than 1 bar {{to the present}} 7 mbar in {{less than or equal}} to 3 to 4 billion years. This problem is addressed with experiments and analysis designed to verify and improve previous kinetic measurements, reaction mechanisms, and product characterizations, with the goal of improving existing models of Martian CO 2 history. A sensitive manometer monitored the pressure drop of CO 2 due to uptake by powdered silicate for periods of 3 to 100 + days. Pressure drops for diopside 1 and basalt show rapid short-term (approximately one day) CO 2 uptake and considerably slower long-term pressure drops. Curves for diopside 2, olivine 1, and olivine 2 are qualitatively similar to those for diopside 1, whereas quartz and plagioclase show near-zero short-term pressure drops and very slow long-term signals, indistinguishable from a leak (less than 10 (exp 11) mol/sq m/s) ...|$|E
40|$|For {{cloud service}} providers, {{lightweight}} virtualization {{is a more}} economical way of virtualization. While the user is worried {{about the safety of}} applications and data of the container, due to the container sharing the underlying interface and the kernel, therefore the security and trusted degree of lightweight virtualization container isolation mechanism is critical for the promotion of lightweight virtualization service. Because the user cannot directly participate in the process of the construction and management of container isolation mechanism, it is difficult for them to establish confidence in the security and trusted degree of container isolation mechanism. Based on the research and analysis of system credible and virtualization isolation mechanism, this paper puts forward a set of lightweight virtualization security isolation strategy mechanism, divides lightweight virtualization container <b>storage</b> <b>address</b> space into several parts, puts forward the definition of lightweight virtualization security isolation, gives the formal description and proof of container security isolation strategy, and combines with related technology to verify the feasibility of lightweight virtualization security isolation strategy mechanism. The mechanism has important guiding significance for cloud services providers to deploy container security isolation...|$|E
30|$|The Deployment Agent {{component}} {{is responsible for}} performing the desired (re)configuration and deployment autonomously (Step E in Fig.  3) including: adding more nodes in a cluster (i.e., scale out), remove nodes from the cluster, changing consistency level, increase system memory and <b>storage,</b> etc (<b>addresses</b> R 2).|$|R
5000|$|In many languages, {{notably the}} C family, l-values have <b>storage</b> <b>addresses</b> that are {{programmatically}} {{accessible to the}} running program (e.g., via some address-of operator like [...] "&" [...] in C/C++), meaning that they are variables or dereferenced references to a certain memory location. R-values can be l-values (see below) or non-l-values—a term only used to distinguish from l-values. Consider the C expression [...] When executed, the computer generates an integer value of 13, but because the program has not explicitly designated where in the computer this 13 is stored, the expression is a non l-value. On the other hand, if a C program declares a variable x and assigns the value of 13 to x, then the expression [...] has a value of 13 and is an l-value.|$|R
40|$|Quantum {{computers}} {{have the potential}} ability to replace the present day computing technology. Memory limitations of magneto-static storage have been a serious hindrance to build these systems practically. This paper supports an argument of using Holographic data storage to tackle these intricacies. The methods of data <b>storage,</b> retrieval, <b>addressing</b> algorithm are exhaustively analyzed...|$|R
40|$|This paper {{presents}} the design, implementation {{and evaluation of}} Direct File System (DFS) for virtualized flash storage. Instead of using traditional layers of abstraction, our layers of abstraction are designed for directly accessing flash memory devices. DFS has two main novel features. First, it lays out its files directly in a very large virtual <b>storage</b> <b>address</b> space provided by FusionIO’s virtual flash storage layer. Second, it leverages the virtual flash storage layer to perform block allocations and atomic updates. As a result, DFS performs better and it is much simpler than a traditional Unix file system with similar functionalities. Our microbenchmark results show that DFS can deliver 94, 000 I/O operations per second (IOPS) for direct reads and 71, 000 IOPS for direct writes with the virtualized flash storage layer on FusionIO’s ioDrive. For direct access performance, DFS is consistently better than ext 3 on the same platform, sometimes by 20 %. For buffered access performance, DFS is also consistently better than ext 3, and sometimes by over 149 %. Our application benchmarks show that DFS outperforms ext 3 by 7 % to 250 % while requiring less CPU power. ...|$|E
40|$|XML is {{emerging}} as a de facto standard for information exchange over internet. XML file is plan text fileand self explanatory therefore XML users are increase dramatically. There are two type of groups whohas interest on XML utilization effectively, the first group is mainly interested in XML as a humanlyconsumable exchange format. They are looking up for tools that allow easy manipulation andtransformation of small XML document. Second community is mainly interested in XML as a data storageformat. Their primary focus is on design of query languages for storage effectively. This data-orientedparadigm has taken more efforts in query evaluation. XML data doesnot have fix schema, managing thedocument is difficult job. It is therefore major challenge for database community to design querylanguages and storage methods that can retrieve data effectively. There has been a growing need fordeveloping high-performance techniques to query large XML [...] The proposed technique summarized XML document into an ‘x-store’, which store xml documentdistinct node :- element node, attribute node and value element node value, and path information. Theunique <b>storage</b> <b>address</b> is generated for each node and it is indexed on path name [...] Then we come up withthe novel method of query searching which utilize multi-way tries to answer the query effectively. Keywords- XML, XQuery, XPath, XML-XD...|$|E
40|$|A CAD {{tool for}} on chip {{controller}} synthesis to digital signal processors has been developed. Micro programmed digital signal processors {{often have a}} complicated control flow where structure {{and complexity of the}} micro program varies considerably between applications. Therefore, an advanced controller architecture adaptive to various algorithms is synthesized. The controller generates control words for datapath modules and can alter the control flow depending on signals generated in the datapath. Many applications require memories for coefficients and data <b>storage.</b> <b>Address</b> calculation to these memories is a natural part of the micro program. Hence, the controller synthesizer also generates memories and address processing units. Synchronization and communication with external circuitry {{is an important part of}} many signal processors. The controller synthesizer facilitates such functions. The controller synthesizer is part of a design system where algorithms are transformed from a high level description to an integrated circuit. No restrictions on datapath architecture or processor complexity, other than technology limitations, are set by the system. The controller synthesizer has proved useful for rapid design of complex digital signal processors and has been used for several designs of varying complexity. Complexity, partitioning and the size of synthesized controllers vary depending on the algorithm and the micro program. A main goal was to be technology independent and to be capable of interfacing to different cell libraries and thereby to various vendors. To verify this the synthesizer supports two different cell libraries...|$|E
40|$|Abstract. The Instruction Set Architecture (ISA) is {{the part}} of a computer’s {{architecture}} visible to programmers. It specifies basic data types, instructions, internal <b>storage,</b> <b>addressing</b> modes, memory architecture and interrupt/exception handling of a computer. Design decisions at ISA level not only determine the computer’s functional behaviour, but also influence non-functional properties such as performance, energy efficiency and even design effort. To allow computer architects to make informed decisions it is important that they can explore the impact of different design options at an early stage. For this, a generic modeling framework for ISAs is needed as a foundation. This paper introduces a generic ISA model in Event-B. The model is refined over four main abstraction levels in a series of horizontal and vertical refinement steps. At each level, choice points are built into the model, permitting exploration of different design options. The model was evaluated on a performance-optimized cryptographic processor...|$|R
40|$|Abstract – During {{the last}} few years, there is a revolutionary {{development}} {{in the field of}} mobile computing, multimedia communication and wireless technology. In this paper, we present study and comparative analyses of different technologies used for mobile multimedia <b>storage</b> and <b>address</b> different issues regarding its architecture and design; especially in cloud computing environment and suggest some solution for its improvements...|$|R
40|$|HCL is a {{hierarchical}} cellular logic, in which operations {{are applied to}} objects called bit-pyramids which themselves are functions on spaces called hierarchical domains. HCL provides an algebra for computations involving hierarchical, multiple-resolution representations of image data. PIPE is a newly-developed parallel architecture which supports multiple-resolution pyramid operations. This paper establishes that HCL is functionally equivalent to a subset of PIPE's instruction set, and that every HCL primitive operation corresponds to a single machine instruction in PIPE and executes in a single machine cycle. Further, the connectivity of HCL data-objects {{is embedded in the}} data-paths of the PIPE architecture. Thus, PIPE can operate upon the data-objects of HCL directly, without using extra storage for links or pointers, and without computation of <b>storage</b> <b>addresses.</b> As a result, PIPE programs implementing HCL may be expected to run enormously faster than corresponding programs for yon Neumann machines, or for other parallel machines which do not share PIPE'S architectural correspondence to the structures of HCL...|$|R
