2|588|Public
40|$|We {{describe}} favorable {{experience with}} automatic differentiation of mathematical programming problems expressed in AMPL, a modeling language for mathematical programming. Nonlinear expressions are translated to loop-free code, which makes analytically correct gradients and Jacobians particularly easy to compute [...] <b>static</b> <b>storage</b> <b>allocation</b> suffices. The nonlinear expressions may either be interpreted or, {{to gain some}} execution speed, converted to Fortran or C...|$|E
40|$|This paper {{describes}} {{ways that}} <b>storage</b> <b>allocation</b> optimization, though “correct”, can convert a running program into one that fails. A general “safety condition” is proposed {{and applied to}} some existing and proposed <b>storage</b> <b>allocation</b> optimizations. These are shown to be unsafe or not general. Application of the safety condition yields several classes of <b>storage</b> <b>allocations</b> that may safely be optimized to stack allocations. For one useful class of allocations optimization is shown to be NP-complete. Safety considerations for <b>storage</b> <b>allocation</b> optimizations...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> is an {{important}} part of a large class of computer programs written in C and C��. High-performance algorithms for dynamic <b>storage</b> <b>allocation</b> have been, and will continue to be, of considerable interest. This paper presents detailed measurements of the cost of dynamic <b>storage</b> <b>allocation</b> in 11 diverse C and C� � programs using five very different dynamic <b>storage</b> <b>allocation</b> implementations, including a conservative garbage collection algorithm. Four of the allocator implementations measured are publicly available on the Internet. A number of the programs used in these measurements are also available on the Internet to facilitate further research in dynamic <b>storage</b> <b>allocation.</b> Finally, the data presented in this paper is an abbreviated version of more extensive statistics that are also publicly available on the Internet. key words: Garbage collection Dynamic <b>storage</b> <b>allocation</b> Performance evaluation Conservative collection Dynamic memory managemen...|$|R
40|$|In {{computer}} information systems, {{some programs}} are used {{more frequently than}} others producing skewed distributions of program usages. We investigate the claim that static views of program usage frequencies are insufficient when they are used for <b>storage</b> <b>allocation</b> decisions making it necessary to study {{the implications of the}} use of dynamic frequencies in <b>storage</b> <b>allocation.</b> The use of dynamic frequencies provides a natural extension to previously presented static cost model literature for hierarchical <b>storage</b> <b>allocation.</b> In our work, we present the value of incorporating dynamic usage frequencies into program usage cost models. Thus, an optimization-based cost modeling methodology using Simon's Model for dynamic hierarchical <b>storage</b> <b>allocation</b> is presented. To illustrate, a simple example of program <b>storage</b> <b>allocation</b> is presented in both static and dynamic form. Cost-saving comparisons are then discussed...|$|R
40|$|In many recent {{computer}} system designs, hardware facilities {{have been provided}} for easing the problems of <b>storage</b> <b>allocation.</b> A method of characterizing dynamic <b>storage</b> <b>allocation</b> systems [...] accordlng to the functional capabilities provided and the underlying techniques used [...] is presented. The basic purpose of the paper {{is to provide a}} useful perspective from which the utility of Various hardware facilities may be assessed. A brief survey of <b>storage</b> <b>allocation</b> facilities in several representative {{computer system}}s is included as an appendix...|$|R
5000|$|Support for {{multiple}} volume groups for optimal <b>storage</b> <b>allocation</b> ...|$|R
40|$|An Inverted file is a {{commonly}} used index for both archival databases and free text where no updates are expected. Applications like information filtering and dynamic environments like the Internet require inverted files to be updated efficiently. Recently, extensible inverted files are proposed {{which can be}} used for fast online indexing. The effective <b>storage</b> <b>allocation</b> scheme for such inverted files uses the arrival rate to preallocate storage. In this article, this <b>storage</b> <b>allocation</b> scheme is improved by using information about both the arrival rates and their variability to predict the storage needed, as well as scaling the <b>storage</b> <b>allocation</b> by a logarithmic factor. The resultant, final storage utilization rate can be as high as 97 - 98 % after indexing about 1. 6 million documents. This compares favorably with the storage utilization rate of the original arrival rate <b>storage</b> <b>allocation</b> scheme. Our evaluation shows that the retrieval time for extensible inverted file on solid state disk is on average similar to the retrieval time for in-memory extensible inverted file. When file seek time is not an issue, our scalable <b>storage</b> <b>allocation</b> enables extensible inverted files to be used as the main index on disk. Our statistical <b>storage</b> <b>allocation</b> may be applicable to novel situations where the arrival of items follows a binomial, Poisson or normal distribution. Department of Computin...|$|R
40|$|AbstractWe use {{an on-line}} {{algorithm}} for coloring interval graphs {{to construct a}} polynomial time approximation algorithm WIC for Dynamic <b>Storage</b> <b>Allocation.</b> The performance ratio for WIC is at most six; the best previous upper bound on the performance ratio for a polynomial time approximation algorithm for Dynamic <b>Storage</b> <b>Allocation</b> had been 80...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> and {{automatic}} garbage collection {{are among the}} most popular features that high-level languages can offer. However, time-critical applications cannot be written in such languages unless the time taken to allocate and deallocate storage can be reasonably bounded. In this paper, we present algorithms for automatic <b>storage</b> <b>allocation</b> that are appropriate for real-time and embedded systems...|$|R
50|$|Norton Zone offered 5 GB {{of storage}} {{for free and}} larger <b>storage</b> <b>allocations</b> via subscription.|$|R
40|$|Nowadays {{automation}} is a {{trend of}} container terminals all over the world. Although not applied in current automated container terminals, <b>storage</b> <b>allocation</b> is indispensable in conventional container terminals, and promising for automated container terminals in future. This paper seeks into the <b>storage</b> <b>allocation</b> problem in automated container terminals and proposed a two level structure for the problem. A mixed integer programming model is built for the upper level, and a modified Particle Swarm Optimization (PSO) algorithm is applied to solve the model. The applicable conditions of the model is investigated by numerical experiments, so as {{the performance of the}} algorithm in different problem scales. It is left to future research the lower level of the problem and the potential benefit of <b>storage</b> <b>allocation</b> to automated container terminals...|$|R
5000|$|... {{infinite}} store : The programmer is {{not responsible}} for <b>storage</b> <b>allocation</b> and can create as many data objects as needed.|$|R
5000|$|Application Configuration - Access to {{application}} specific <b>static</b> <b>storage</b> for {{preference and}} other application settings.|$|R
5000|$|EN 15620 Steel <b>static</b> <b>storage</b> systems - Adjustable {{pallet racking}} - Tolerances, {{deformations}} and clearances ...|$|R
5000|$|EN 15512 Steel <b>static</b> <b>storage</b> systems - Adjustable {{pallet racking}} systems - Principles for {{structural}} design ...|$|R
40|$|Abstract. Dynamic <b>storage</b> <b>allocation</b> and {{automatic}} garbage collection {{are among the}} most popular features that high-level languages can offer. However, timecritical applications cannot be written in such languages unless the time taken to allocate and deallocate storage can be reasonably bounded. In this paper, we present algorithms for automatic <b>storage</b> <b>allocation</b> that are appropriate for realtime and embedded systems. We have implemented these algorithms, and results are presented that validate the predictability and efficiency of our approach. ...|$|R
50|$|In a <b>static</b> <b>storage</b> system such as {{standard}} shelving, stockers and pickers often {{do a lot}} of unnecessary travel.|$|R
40|$|Practical and {{theoretical}} {{results have been}} found concerning the use of global <b>storage</b> <b>allocation</b> for the instances of applied occurrences of an attribute. The practical results focus on the necessary and sufficient conditions to decide at evaluator construction time whether an evaluator can allocate the instances of an applied occurrence {{to a number of}} global variables, stackes and queues. Checking these conditions takes polynomial time for a simple multi-visit evaluator and exponential time for an absolutely non-circular evaluator. The theoretical results are concerned with the data structures that are required for the global <b>storage</b> <b>allocation</b> of the instances of applied occurrences in simple multi-X evaluators, where X € {pass, sweep, visit}. For this purpose, the general class of basic linear data structures is introduced. This class of data structures {{can also be used to}} explore the theoretical possibilities and limitations of <b>storage</b> <b>allocation</b> techniques in domains other than attribute grammars...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> is used {{heavily in}} many {{application}} areas including interpreters, simulators, optimizers, and translators. We describe research that can improve {{all aspects of the}} performance of dynamic <b>storage</b> <b>allocation</b> by predicting the lifetimes of short-lived objects when they are allocated. Using five significant, allocation-intensive C programs, we show that a great fraction of all bytes allocated are short-lived (? 90 % in all cases). Furthermore, we describe an algorithm for lifetime prediction that accurately predicts the lifetimes of 42 [...] 99 % of all objects allocated. We describe and simulate a storage allocator that takes advantage of lifetime prediction of short-lived objects and show that it can significantly improve a program's memory overhead and reference locality, and even, at times, improve CPU performance as well. 1 Introduction. Dynamic <b>storage</b> <b>allocation</b> (DSA) is used heavily in {{many application areas}} including interpreters, simulators, optimizers, and [...] ...|$|R
40|$|We {{examine the}} problem of {{counting}} interval graphs. We answer the question posed by Hanlon, of whether the formal power series generating function {{of the number of}} interval graphs on n vertices has a positive radius of convergence. We have found that it is zero. We have obtained a lower bound and an upper bound on the number of interval graphs on n vertices. We also study the application of interval graphs to the dynamic <b>storage</b> <b>allocation</b> problem. Dynamic <b>storage</b> <b>allocation</b> {{has been shown to be}} NP-complete by Stockmeyer. Coloring interval graphs on-line has applications to dynamic <b>storage</b> <b>allocation.</b> The most colors used by Kierstead 2 ̆ 7 s algorithm is 3 ω - 2, where ω is the size of the largest clique in the graph. We determine a lower bound on the colors used. One such lower bound is 2 ω - 1...|$|R
50|$|Variables {{declared}} {{within a}} block by default have automatic storage, as do those explicitly declared with the auto or register storage class specifiers. The auto and register specifiers {{may only be}} used within functions and function argument declarations; as such, the auto specifier is always redundant. Objects declared outside of all blocks and those explicitly declared with the <b>static</b> <b>storage</b> class specifier have <b>static</b> <b>storage</b> duration. <b>Static</b> variables are initialized to zero by default by the compiler.|$|R
40|$|Dynamic <b>Storage</b> <b>Allocation</b> is {{the problem}} of packing given axis-aligned {{rectangles}} into a horizontal strip of minimum height by sliding the rectangles vertically but not horizontally. Where L = LOAD is the maximum sum of heights of rectangles that intersect any vertical line and OPT is the minimum height of the enclosing strip, it is obvious that OPT LOAD; previous work showed that OPT 3 LOAD. We continue the study of the relationship between OPT and LOAD, proving that OPT = L + O((hmax=L)) L, where hmax is the maximum job height. Conversely, we prove that for any > 0, there exists a c > 0 such that for all suf- ciently large integers hmax, there is a Dynamic <b>Storage</b> <b>Allocation</b> instance with maximum job height hmax, maximum load at most L, and OPT L + c(hmax=L) L, for in nitely many integers L. En route, we construct several new polynomial-time approximation algorithms for Dynamic <b>Storage</b> <b>Allocation...</b>|$|R
40|$|<b>Storage</b> <b>allocation</b> affects {{important}} {{performance measures}} of distributed storage systems. Most previous {{studies on the}} <b>storage</b> <b>allocation</b> consider its effect separately either {{on the success of}} the data recovery or on the service rate (time) where it is assumed that no access failure happens in the system. In this paper, we go one step further and incorporate the access model and the success of data recovery into the service rate analysis. In particular, we focus on quasi-uniform <b>storage</b> <b>allocation</b> and provide a service rate analysis for both fixed-size and probabilistic access models at the nodes. Using this analysis, we then show that for the case of exponential waiting time distribution at individuals storage nodes, minimal spreading allocation results in the highest system service rate for both access models. This means that for a given storage budget, replication provides a better service rate than a coded storage solution. Comment: This paper has been accepted for presentation in IEEE ISIT 201...|$|R
40|$|Estimating {{the fault}} rate {{function}} Paging activity {{can be a}} major factor in determining whether a software workload will run on a given computer system. A program’s paging behavior is difficult to predict because it depends not only on the workload processed by the program, but also on the level of storage contention of the processor. A program’s fault rate function relates <b>storage</b> <b>allocation</b> to the page fault rate experienced while processing a given workload. Thus, with the workload defined, the fault rate function can be used to see how the program’s <b>storage</b> <b>allocation</b> is affected by varying levels of storage contention, represente...|$|R
40|$|Dynamic <b>Storage</b> <b>Allocation</b> is {{a problem}} {{concerned}} with storing items that each have weight and time restrictions. Approximate algorithms have been constructed through online coloring of interval graphs. We present a general-ization that uses online coloring of tolerance graphs. We utilize online-with-representation algorithms on tolerance graphs, which are online algorithms in which the corresponding tolerance representation of a vertex is also presented. We find linear bounds for the online-with-representation chromatic number of various classes of tolerance graphs and apply these results to a generalization of Dynamic <b>Storage</b> <b>Allocation,</b> giving us a polynomial time approximation algorithm with linear performance ratio...|$|R
40|$|This paper {{presents}} virtual allocation, {{a scheme}} for flexible <b>storage</b> <b>allocation.</b> It separates <b>storage</b> <b>allocation</b> from the file system. It employs an allocate-on-write strategy, which lets applications {{fit into the}} actual usage of storage space {{without regard to the}} configured file system size. This improves flexibility by allowing storage space to be shared across different file systems. This paper presents the design of virtual allocation and an evaluation of it through benchmarks. To illustrate our approach, we implemented a prototype system on PCs running Linux. We present the results from the prototype implementation and its evaluation. ...|$|R
40|$|The yard truck {{scheduling}} and the <b>storage</b> <b>allocation</b> are two important decision problems affecting {{the efficiency of}} container terminal operations. This paper proposes a novel approach that integrates these two problems into a whole. The objective is to minimize the weighted sum of total delay of requests and the total travel time of yard trucks. Due to the intractability of the proposed problem, a hybrid insertion algorithm is designed for effective problem solutions. Computational experiments are conducted to examine the key factors {{of the problem and}} the performance of the proposed heuristic algorithm. Container terminal operations Yard truck scheduling <b>Storage</b> <b>allocation</b> Heuristic algorithm...|$|R
25|$|As in C, C++ {{supports}} {{four types}} of memory management: <b>static</b> <b>storage</b> duration objects, thread storage duration objects, automatic storage duration objects, and dynamic storage duration objects.|$|R
40|$|AbstractThis paper {{proposes a}} new <b>storage</b> <b>allocation</b> rule based on target storage curves. Joint {{operating}} rules are also proposed {{to solve the}} operation problems of a multi-reservoir system with joint demands and water transfer-supply projects. The joint operating rules include a water diversion rule to {{determine the amount of}} diverted water in a period, a hedging rule based on an aggregated reservoir to determine the total release from the system, and a <b>storage</b> <b>allocation</b> rule to specify the release from each reservoir. A simulation-optimization model was established to optimize the key points of the water diversion curves, the hedging rule curves, and the target storage curves using the improved particle swarm optimization (IPSO) algorithm. The multi-reservoir water supply system located in Liaoning Province, China, including a water transfer-supply project, was employed as a case study to verify the effectiveness of the proposed join operating rules and target storage curves. The results indicate that the proposed operating rules are suitable for the complex system. The <b>storage</b> <b>allocation</b> rule based on target storage curves shows an improved performance with regard to system storage distribution...|$|R
40|$|Dynamic <b>storage</b> <b>allocation</b> has a {{significant}} impact on computer performance. A dynamic storage allocator manages space for objects whose lifetimes are not known by the system {{at the time of their}} creation. A good dynamic storage allocator should utilize storage efficiently and satisfy requests in as few instructions as possible. A dynamic storage allocator on a multiprocessor should have the ability to satisfy multiple requests concurrently. This paper examines parallel dynamic <b>storage</b> <b>allocation</b> algorithms and how performancescales with increasing numbers of processors. The highest throughputs and lowest instruction counts are achieved with multiple free list fit I. The best memory utilization is achieved using a best fit system...|$|R
5000|$|... int n = 0;struct C { {{explicit}} C(int) {} C(const C&) { ++n; } // {{the copy}} constructor has a visible side effect}; // it modifies an object with <b>static</b> <b>storage</b> duration ...|$|R
30|$|The map of {{the costs}} {{obtained}} with the simulation environment developed can be a decision support system to choose the best model evaluating the condition of production rate, preventive maintenance actions time required, and the buffer <b>storages</b> <b>allocation.</b>|$|R
5000|$|Chemical {{tanks are}} storage {{containers}} for chemicals. They {{come in a}} variety of sizes and shapes, and are used for <b>static</b> <b>storage,</b> processing, mixing, and transport of both raw materials and finished chemical products.|$|R
40|$|<b>Storage</b> <b>allocation</b> of {{outbound}} containers is a {{key factor}} {{of the performance of}} container handling system in automated container terminals. Improper storage plans of outbound containers make QC waiting inevitable; hence, the vessel handling time will be lengthened. A simulation-based optimization method is proposed in this paper for the <b>storage</b> <b>allocation</b> problem of outbound containers in automated container terminals (SAPOBA). A simulation model is built up by Timed-Colored-Petri-Net (TCPN), used to evaluate the QC waiting time of storage plans. Two optimization approaches, based on Particle Swarm Optimization (PSO) and Genetic Algorithm (GA), are proposed to form the complete simulation-based optimization method. Effectiveness of this method is verified by experiment, as the comparison of the two optimization approaches...|$|R
40|$|Distributed storage systems (DSSs) {{provide a}} {{scalable}} solution for reliably storing {{massive amounts of}} data coming from various sources. Heterogeneity of these data sources often means different data classes (types) exist in a DSS, each needing a different level of quality of service (QoS). As a result, efficient data storage and retrieval processes that satisfy various QoS requirements are needed. This paper studies <b>storage</b> <b>allocation,</b> meaning how data of different classes must be spread over the set of storage nodes of a DSS. More specifically, assuming a probabilistic access to the storage nodes, we aim at maximizing the weighted sum of the probability of successful data recovery of data classes, when for each class a minimum QoS (probability of successful recovery) is guaranteed. Solving this optimization problem for a general setup is intractable. Thus, we find the optimal <b>storage</b> <b>allocation</b> when the data of each class is spread minimally over the storage nodes, i. e. minimal spreading allocation (MSA). Using upper bounds {{on the performance of}} the optimal <b>storage</b> <b>allocation,</b> we show that the optimal MSA allocation approaches the optimal performance in many practical cases. Computer simulations are also presented to better illustrate the results...|$|R
25|$|Variables of {{this type}} {{are very similar to}} <b>static</b> <b>storage</b> {{duration}} objects. The main difference is the creation time is just prior to thread creation and destruction is done after the thread has been joined.|$|R
