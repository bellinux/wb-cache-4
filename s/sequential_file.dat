60|80|Public
2500|$|Insertions can be {{very slow}} in a sorted <b>sequential</b> <b>file</b> because room for the {{inserted}} record must be made. Inserting a record before the first record requires shifting all of the records down one. Such an operation is just too expensive to be practical. One solution is to leave some spaces. Instead of densely packing all the records in a block, the block can have some free space to allow for subsequent insertions. Those spaces would be marked {{as if they were}} [...] "deleted" [...] records.|$|E
5000|$|A <b>sequential</b> <b>file</b> is a {{data file}} {{that can be}} linearly read from start to finish. [...] files are {{commonly}} used to store documents or text files created by a word processor or other such editor. A <b>sequential</b> <b>file</b> is analogous to a flat file in Linux or UNIX, in {{that it has no}} specialized internal structure. It is not possible to position to any arbitrary location in a <b>sequential</b> <b>file,</b> as there is no analog of the [...] kernel call found in UNIX-like operating systems.|$|E
5000|$|... perform <b>sequential</b> <b>file</b> I/O (QSAM) {{operations}} from {{a script}} to a user-defined, external dataset; ...|$|E
50|$|<b>Sequential</b> <b>files</b> are {{somewhat}} more efficient {{in terms of}} space than line files and can be more efficient in terms of CPU time too when compared with large disorganized line files. But {{the main reason for}} the existence of SEQ files is that they supported long lines (up to 32767 characters) before line <b>files</b> did. <b>Sequential</b> <b>files</b> were less common once line files could support long lines. <b>Sequential</b> <b>files</b> are also used to force new lines to be appended {{to the end of the}} file without the need to give the line number range (LAST+1).|$|R
5000|$|<b>Sequential</b> <b>files,</b> {{in which}} records {{are stored in}} {{consecutive}} slots.|$|R
50|$|This data is then {{periodically}} dumped to <b>sequential</b> <b>files</b> (for example, tape drives) {{using the}} IFASMFDP SMF Dump Utility (or IFASMFDL when using log streams). IFASMFDP {{can also be}} used to split existing SMF <b>sequential</b> <b>files</b> and copy them to other files. The two dump programs produce the same output, so it does not involve changes in the SMF records elaboration chain, other than changing the JCL with the call of the new dump utility.|$|R
5000|$|Data: By {{splitting}} {{a single}} <b>sequential</b> <b>file</b> into smaller data files to provide parallel access ...|$|E
5000|$|... {{to support}} only {{selected}} commands of a manager, {{such as the}} ability to load and unload records from a <b>sequential</b> <b>file.</b>|$|E
5000|$|An undocumented {{internally}} used file type {{similar in}} structure to a <b>sequential</b> <b>file.</b> Creation of this file type must {{be accomplished by}} direct manipulation of the disk directory.|$|E
5000|$|... {{support for}} BIL (band {{interleaved}} by line files) and BSQ (band <b>sequential</b> in one <b>file)</b> {{added to the}} individual band <b>sequential</b> <b>files</b> supported by the earlier version; all formats can be 8-16 bits per pixel including swapped word order ...|$|R
5000|$|Insert+Cat - {{it allows}} {{creating}} a text file from a diskette directory, similarly, it allows {{to make a}} list of files on cassette. Additionally, it allows to convert <b>sequential</b> [...]Q <b>files</b> into text file (.Q <b>files</b> are <b>sequential</b> <b>files</b> used by diskette units Didaktik 40 and Didaktik 80).|$|R
50|$|Sequential With Line Number files ($CREATE name TYPE=SEQWL) {{are similar}} to <b>Sequential</b> <b>Files,</b> except that their line numbers were {{explicitly}} stored. They have all the restrictions of <b>Sequential</b> <b>Files,</b> except that the line number could be specifically supplied when writing to a file (as {{long as it is}} greater than the last line number written to the file). Unlike Line Files, the first read of an SEQWL file returns the first line of the file, even if it was negative.|$|R
5000|$|In {{the example}} above, SYSIN control cards {{are coming from}} an in-stream file, but you can instead point to any <b>sequential</b> <b>file</b> or a PDS member {{containing}} control cards or a temporary data-set, if you wish.Example of using SYSIN files would be something like this: ...|$|E
5000|$|... is a Transact-SQL {{statement}} that implements a bulk data-loading process, inserting multiple rows into a table, reading data from an external <b>sequential</b> <b>file.</b> Use of [...] results in better performance than processes that issue individual [...] statements for each row to be added. Additional details {{are available in}} MSDN.|$|E
5000|$|A {{relative}} file is {{a variation of}} the <b>sequential</b> <b>file</b> type, in which an indexing mechanism referred to as side-sectors is present to permit record-oriented access. Records may be a maximum of 254 bytes in size and are addressed by a one-based cardinal number, permitting true random access to any part of the file.|$|E
5000|$|MTS {{supports}} {{three types}} of <b>file,</b> line <b>files,</b> <b>sequential</b> <b>files,</b> and <b>sequential</b> with line number files, but line files were {{by far the most}} common: ...|$|R
40|$|The {{performance}} of batched search {{when applied to}} index <b>sequential</b> <b>files</b> is studied. Analysis provides exact formulae {{for the cost of}} searching when batching is applied {{as a function of the}} magnitude of the query and time. The analysis takes into account (a) accesses to the overflow area only, and (b) accesses to both primary and overflow area, as well as whether the records of the query are (a) distinct, or (b) nondistinct. Batched search is compared with the simple on-line search and a proposal is stated concerning the reorganization of index <b>sequential</b> <b>files...</b>|$|R
40|$|The BNL Archive and Dissemination (BNLAD) System was {{designed}} to operate on a homogeneous distributed data base in a computer network. Its primary function is to present a uniform logical and physical view of already existing <b>sequential</b> <b>files</b> of data, so [...] . "BNL- 22612; AMD 757 R 1. ""March 1977. "Includes bibliographical references (p. 21) The BNL Archive and Dissemination (BNLAD) System {{was designed}} to operate on a homogeneous distributed data base in a computer network. Its primary function is to present a uniform logical and physical view of already existing <b>sequential</b> <b>files</b> of data, so [...] . Mode of access: Internet...|$|R
50|$|When the {{integrals}} are computed by the integrals program {{they are}} written {{out to a}} <b>sequential</b> <b>file</b> along with the p,q,r,s indices which define them. The order in which the integrals are computed {{is defined by the}} algorithm used in the integration program. The most efficient algorithms do not compute the integrals in order, that is such that the p,q,r and s indices are ordered.|$|E
5000|$|Opening a file on a Commodore {{disk unit}} entails the {{processing}} {{of a number of}} parameters that are vaguely analogous to file opening procedures in other environments. Since the DOS is actually running in the drive's controller, the file opening sequence must pass enough information to the drive to assure unambiguous interpretation. A typical statement in BASIC to write to a <b>sequential</b> <b>file</b> would be as follows: ...|$|E
50|$|SAFR {{can access}} {{multiple}} types of mainframe-based data, including DB2. For example, it can read sequential files {{based on the}} input format specified, then look up certain fields in a VSAM file or in another <b>sequential</b> <b>file.</b> SAFR can produce output in yet another format with some additional calculations, as required. The entire process is called a VIEW, {{and any number of}} VIEWs can be defined. SAFR also commonly processes data from other platforms that are fed into its engine.|$|E
5000|$|The {{first step}} was to create a format. This command allowed the user to type a form {{directly}} onto the screen, using fixed text for headings, and indicating where variable data fields would get populated from the data file. The format could be associated with a data file created by an existing application, or used to create a new one by entering records interactively. v1.0 supported only <b>sequential</b> <b>files,</b> but search performance was predictably terrible, and multi-key indexed <b>sequential</b> <b>files</b> were quickly added in v2.0. Once the format was created and associated with a file, the user employed intuitive commands such as: ...|$|R
40|$|Primary file organization: – {{determines how}} {{the files of}} records are {{physically}} placed on the disk – heap <b>files,</b> <b>sequential</b> <b>files</b> (search key), hashed files (hash key) • Secondary organization: – allows efficient access to the records of a file based on alternate fields that those used for the primary file organizatio...|$|R
5000|$|Files had various types, like text <b>files</b> {{and index}} <b>sequential</b> data <b>files.</b>|$|R
5000|$|Insertions can be {{very slow}} in a sorted <b>sequential</b> <b>file</b> because room for the {{inserted}} record must be made. Inserting a record before the first record requires shifting all of the records down one. Such an operation is just too expensive to be practical. One solution is to leave some spaces. Instead of densely packing all the records in a block, the block can have some free space to allow for subsequent insertions. Those spaces would be marked {{as if they were}} [...] "deleted" [...] records.|$|E
50|$|Sequential files ($CREATE name TYPE=SEQ) are line-oriented files {{with the}} first line number being implicitly 1 and {{incremented}} by 1 for each line. Once written {{the length of a}} line (other than the last line of a file) can not be changed, although any line can be replaced by a line of the same length. Sequential files are generally only readable sequentially from start to end, or written by appending to the end. One can, however, request a reference for the current line of a <b>sequential</b> <b>file,</b> and use that reference to jump to that specific location again.|$|E
5000|$|A user-specified file has an {{internal}} structure that {{is identical to}} that of a <b>sequential</b> <b>file.</b> Commodore's original purpose for this file type was the facilitation of DOS development, as the file content could be copied into a drive buffer for execution by the drive's microprocessor. It is unknown if anyone found a use for the facility. Some applications that use non-standard low-level disk structures save data in USR format, which came to be considered a sort of [...] "leave me alone, don't try to copy or delete" [...] indication to the user. Most notably, GEOS' [...] "VLIR" [...] files show up as [...] files.|$|E
5000|$|Loading {{pointers}} into memory {{instead of}} the slow <b>sequential</b> text <b>file</b> methology ...|$|R
40|$|A new hidden-line {{algorithm}} is proposed for illustrating objects consisting of plane faces. The algorithm determines the degree of edge and classifies edges and faces into contoural and non-contoural. To reduce memory requirements, <b>sequential</b> <b>files</b> and sorting are used. The {{algorithm is}} particularly intended for illustrating complex objects, such as curved surfaces approximated by plane face...|$|R
5000|$|Partitioned {{datasets}} (PDS) were sequential datasets {{subdivided into}} [...] "members" [...] {{that could be}} processed as <b>sequential</b> <b>files</b> in their own right. The most important use of PDS was for program libraries - system administrators used the main PDS {{as a way to}} allocate disk space to a project and the project team then created and edited the members.|$|R
5000|$|Generation Data Groups (GDGs) were {{originally}} designed to support grandfather-father-son backup procedures - if a file was modified, the changed version became the new [...] "son", the previous [...] "son" [...] became the [...] "father", the previous [...] "father" [...] became the [...] "grandfather" [...] and the previous [...] "grandfather" [...] was deleted. But one could set up GDGs {{with a lot more}} than 3 generations and some applications used GDGs to collect data from several sources and feed the information to one program - each collecting program created a new generation of the file and the final program read the whole group as a single <b>sequential</b> <b>file</b> (by not specifying a generation in the JCL).|$|E
5000|$|Files {{can also}} be loaded and saved to with [...] and [...] commands. File name specifiers {{can also be}} used here, for example, [...] saves the BASIC program to a [...] (program) file and [...] saves the BASIC program to a <b>sequential</b> <b>file.</b> If the {{secondary}} address isn't specified or is specified as 0 (e.g. [...] ), the file is saved/loaded from the BASIC memory area (which, on the C64, starts by default at $0801). If the secondary address is specified as a non-zero value (e.g. [...] ), the program is loaded starting from the address specified by the file itself (the PRG header, which is the first two bytes of the file) - this form of command is more common when loading machine code programs.|$|E
50|$|For example, {{files in}} a file system are usually managed in units called blocks or clusters. When a file system is created, there is free space to store file blocks {{together}} contiguously. This allows for rapid <b>sequential</b> <b>file</b> reads and writes. However, as files are added, removed, and changed in size, the free space becomes externally fragmented, leaving only small holes {{in which to}} place new data. When a new file is written, or when an existing file is extended, the operating system puts the new data in new non-contiguous data blocks {{to fit into the}} available holes. The new data blocks are necessarily scattered, slowing access due to seek time and rotational latency of the read/write head, and incurring additional overhead to manage additional locations. This is called file system fragmentation.|$|E
5000|$|They had {{to support}} {{a wide range of}} {{application}} requirements. For example, some applications only needed to read through <b>sequential</b> <b>files</b> from start to finish; others needed fast, direct access to specific records in very large files; and a few applications spent nearly all their time doing calculations, with very little reading or writing of files.|$|R
40|$|RESTRUCT is a {{software}} tool that reformats <b>sequential</b> <b>files.</b> It {{can operate as}} a stand alone process or function as a filter in a sequence of operations. Using RESTHUC'l', one can express simple file transformations in a simple way. 1 t is driven by a specification-based data description language that includes record description at three levels of detail. record redefinition and field conversion capabilities...|$|R
50|$|The Distributed Network Operating System (DNOS) is {{a general}} purpose,multitasking {{operating}} system designed to operate with the Texas Instruments990/10, 990/10A and 990/12 minicomputers.DNOS includes a sophisticated file management package which provides supportfor key indexed <b>files,</b> <b>sequential</b> <b>files,</b> and relative record files.DNOS is a multiterminal system {{that is capable of}} making each of several usersappear to have exclusive control of the system.DNOS supports output spooling and program accessible accounting data.Job level and task level operations enable more efficient use of systemresources.|$|R
