57|118|Public
25|$|SQL Server Full Text Search {{service is}} a {{specialized}} indexing and querying service for unstructured text stored in SQL Server databases. The full text search index can be created on any column with character based text data. It allows for words to be searched for in the text columns. While it can be performed with the SQL LIKE operator, using SQL Server Full Text Search service can be more efficient. Full allows for inexact matching of the <b>source</b> <b>string,</b> indicated by a Rank value which can range from 0 to 1000—a higher rank means a more accurate match. It also allows linguistic matching ("inflectional search"), i.e., linguistic variants of a word (such as a verb in a different tense) {{will also be a}} match for a given word (but with a lower rank than an exact match). Proximity searches are also supported, i.e., if the words searched for do not occur in the sequence they are specified in the query but are near each other, they are also considered a match. T-SQL exposes special operators {{that can be used to}} access the FTS capabilities.|$|E
5000|$|Software {{is often}} {{localized}} by translating {{a list of}} strings out of context, and the translator may choose the wrong translation for an ambiguous <b>source</b> <b>string.</b>|$|E
50|$|FloopaLoo, Where Are You? is a French {{series by}} Marc du Pontavice, {{produced}} by the company Xilam in coproduction with the participation of France Télévisions and an association with Castelrosso and Rai Fiction. The series takes about 15 minutes for segment, the <b>source</b> <b>string</b> is France 5 in Zouzous.|$|E
5000|$|... for all {{possible}} <b>source</b> <b>strings.</b> Thus, combining everything and introducing some , have that ...|$|R
25|$|Note {{that the}} above code {{is not free}} from {{problems}} either; while a buffer overrun has been prevented this time, the strncpy library function does not null-terminate the destination buffer if the <b>source</b> <b>string's</b> length is {{greater than or equal}} to the size of the buffer (the third argument passed to the function), therefore A is, in this case, not null-terminated and cannot be treated as a valid C-style string.|$|R
40|$|AbstractSynchronous {{context-free}} grammars (SCFGs) can {{be learned}} from parallel texts that are annotated with target-side syntax, and can produce translations by building target-side syntactic trees from <b>source</b> <b>strings.</b> Ideally, producing syntactic trees would entail that the translation is grammatically well-formed, but in reality, this is often not the case. Focusing on translation into German, we discuss various ways in which string-to-tree translation models over- or undergeneralise. We show how these problems can be addressed by choosing a suitable parser and modifying its output, by introducing linguistic constraints that enforce morphological agreement and constrain subcategorisation, and by modelling the productive generation of German compounds...|$|R
50|$|Terminal {{symbols are}} literal symbols which may {{appear in the}} outputs of the {{production}} rules of a formal grammar and which cannot be changed using {{the rules of the}} grammar. Applying the rules recursively to a <b>source</b> <b>string</b> of symbols will usually terminate in a final output string consisting only of terminal symbols.|$|E
5000|$|... public {{interface}} StringProvider { public String getStringData (...)}public class ClassAFormat1 implements StringProvider { private ClassA classA = null; public ClassAFormat1(final ClassA a) { classA = a; } public String getStringData (...) { return format(classA.getStringData (...) [...] ); } private String format(final String sourceValue) { // Manipulate the <b>source</b> <b>string</b> into {{a format}} required [...] // by the object needing the source object's data return sourceValue.trim (...) }} ...|$|E
50|$|UTF-7 allows {{multiple}} {{representations of}} the same <b>source</b> <b>string.</b> In particular, ASCII characters can be represented as part of Unicode blocks. As such, if standard ASCII-based escaping or validation processes are used on strings that may be later interpreted as UTF-7, then Unicode blocks {{may be used to}} slip malicious strings past them. To mitigate this problem, systems should perform decoding before validation and should avoid attempting to autodetect UTF-7.|$|E
40|$|Hierarchical phrase-based machine trans-lation {{can capture}} global {{reordering}} with synchronous context-free grammar, but has little ability {{to evaluate the}} correctness of word orderings during decoding. We propose a method to integrate word-based reordering model into hierarchical phrase-based machine translation to overcome this weakness. Our approach extends the synchronous context-free grammar rules of hierarchical phrase-based model to in-clude reordered <b>source</b> <b>strings,</b> allowing efficient calculation of reordering model scores during decoding. Our experimen-tal results on Japanese-to-English basic travel expression corpus showed that the BLEU scores obtained by our proposed system were better than those obtained by a standard hierarchical phrase-based ma-chine translation system. ...|$|R
40|$|In this paper, {{we address}} the issue for {{learning}} better translation consensus in machine translation (MT) research, and explore the search of translation consensus from similar, rather than the same, source sentences or their spans. Unlike previous work on this topic, we formulate the problem as structured labeling over a much smaller graph, and we propose a novel structured label propagation for the task. We convert such graph-based translation consensus from similar <b>source</b> <b>strings</b> into useful features both for n-best output reranking and for decoding algorithm. Experimental results show that, our method can significantly improve machine translation performance on both IWSLT and NIST data, compared with a state-ofthe-art baseline. ...|$|R
40|$|We {{present a}} novel co-training method for {{statistical}} machine translation. Since cotraining requires independent {{views on the}} data, with each view being sufficient for the labeling task, we use <b>source</b> <b>strings</b> in multiple languages as views on translation. Co-training for statistical machine translation is therefore a type of multisource translation. We show that using five language pairs our approach can yield improvements of up to 2. 5 % in word error rates for translation models. Our experiments suggest that co-training is even more effective for languages with highly impoverished parallel corpora: starting with no human translations from German to English we produce a German to English translation model with 45 % accuracy using parallel corpora in other languages...|$|R
5000|$|Suppose {{a program}} is being run in an {{emulator}} {{and needs to}} copy a null-terminated string. The program is compiled originally for a very simple processor. This processor can only copy a byte at a time, and must do so by first reading it from the <b>source</b> <b>string</b> into a register, then writing it from that register into the destination string. The original program might look something like this: ...|$|E
5000|$|The {{problem of}} {{modeling}} the probability distribution [...] has been approached {{in a number}} of ways. One approach which lends itself well to computer implementation is to apply Bayes Theorem, that is , where the translation model [...] is the probability that the <b>source</b> <b>string</b> is the translation of the target string, and the language model [...] is the probability of seeing that target language string. This decomposition is attractive as it splits the problem into two subproblems. Finding the best translation [...] is done by picking up the one that gives the highest probability: ...|$|E
5000|$|... beginning: mov A,string pointer Put {{location}} of first character of <b>source</b> <b>string</b> in register A mov B,string pointer Put {{location of}} first character of destination string in register Bloop: movs B,A Copy 16 bytes at address in register A to address in register B, then increment A and B by 16 jnz loop If the zero flag isn't set then we haven't {{reached the end}} of the string, so go back and copy some more.end: If we didn't loop then we must have finished, so carry on with something else.|$|E
5000|$|Let [...] be {{the total}} number of {{possible}} messages. Next map each of the possible source output sequences to one of the messages randomly using a uniform distribution and independently from everything else. When a source is generated the corresponding message [...] is then transmitted to the destination. The message gets decoded to one of the possible <b>source</b> <b>strings.</b> In order to minimize the probability of error the decoder will decode to the source sequence [...] that maximizes , where [...] denotes the event that message [...] was transmitted. This rule is equivalent to finding the source sequence [...] among the set of source sequences that map to message [...] that maximizes [...] This reduction follows {{from the fact that the}} messages were assigned randomly and independently of everything else.|$|R
5000|$|... program (pass1, pass2) {{compiler}} begin <b>string</b> <b>source</b> := ...; tree parsetree; ... here pass1 (source, parsetree); ... instructions insts; here pass2 (parsetree, insts); ... end finish ...|$|R
40|$|Attribute Grammar Markus Schordan Institute of Computer Languages Vienna University of Technology 1040 Vienna, Austria markus@complang. tuwien. ac. at Daniel Quinlan Centre for Applied Scientific Computing Lawrence Livermore National Laboratory Livermore, CA 94551, USA dquinlan@llnl. gov Abstract We {{present a}} grammar based {{approach}} for specifying a transformation as {{a sequence of}} transformation operations that operate on an intermediate representation. The transformation sequence is specified in the semantic actions of an abstract attribute grammar. The mapping between the object-oriented design of the intermediate representation and the abstract grammar directly reflects the objectoriented design {{in the structure of}} the grammar. It has properties that permit utilizing grammar based tools at arbitrary abstraction levels of the language representation. The program fragments can be both <b>source</b> <b>strings</b> and fragments of the intermediate representation that can be used interchangeably in the specification...|$|R
5000|$|... beginning: mov A,string pointer Put {{location}} of first character of <b>source</b> <b>string</b> in register A mov B,string pointer Put {{location of}} first character of destination string in register Bloop: mov C,A Copy byte at address in register A to register C mov B,C Copy byte in register C {{to the address}} in register B inc A Increment the address in register A {{to point to the}} next byte inc B Increment the address in register B to point to the next byte cmp C,#0 Compare the data we just copied to 0 (string end marker) jnz loop If it wasn't 0 then we have more to copy, so go back and copy the next byteend: If we didn't loop then we must have finished, so carry on with something else.|$|E
5000|$|SQL Server Full Text Search {{service is}} a {{specialized}} indexing and querying service for unstructured text stored in SQL Server databases. The full text search index can be created on any column with character based text data. It allows for words to be searched for in the text columns. While it can be performed with the SQL [...] operator, using SQL Server Full Text Search service can be more efficient. Full allows for inexact matching of the <b>source</b> <b>string,</b> indicated by a Rank value which can range from 0 to 1000—a higher rank means a more accurate match. It also allows linguistic matching ("inflectional search"), i.e., linguistic variants of a word (such as a verb in a different tense) {{will also be a}} match for a given word (but with a lower rank than an exact match). Proximity searches are also supported, i.e., if the words searched for do not occur in the sequence they are specified in the query but are near each other, they are also considered a match. T-SQL exposes special operators {{that can be used to}} access the FTS capabilities.|$|E
40|$|A major {{challenge}} in {{statistical machine translation}} is mitigating the word order differences between source and target strings. While reordering and lexical translation choices are often conducted in tandem, <b>source</b> <b>string</b> permutation prior to translation is attractive for studying reordering using hierarchical and syntactic structure. This work contributes an approach for learning <b>source</b> <b>string</b> permutation via transfer of the source syntax tree. We present a novel discriminative, probabilistic tree transduction model, and contribute a set of empirical upperbounds on translation performance for Englishto-Dutch <b>source</b> <b>string</b> permutation under sequence and parse tree constraints. Finally, the translation performance of our learning model is shown to outperform the state-of-the-art phrase-based system significantly. ...|$|E
50|$|Small engines (usually 2‐stroke {{gasoline}} engines) are {{a common}} power <b>source</b> for lawnmowers, <b>string</b> trimmers, chain saws, leafblowers, pressure washers, snowmobiles, jet skis, outboard motors, mopeds, and motorcycles.|$|R
3000|$|... where u i [...] is {{the four}} {{velocity}} of the string and x i [...] representing the direction vector of anisotropy. The <b>string</b> <b>source</b> is along the z-axis, which is the axis of symmetry.|$|R
40|$|We find exact {{solutions}} describing Ricci {{flows of}} four dimensional pp-waves nonlinearly deformed by two/three dimensional solitons. Such solutions are parametrized by five dimensional metrics with generic off-diagonal terms and connections with nontrivial torsion {{which can be}} related, for instance, to antisymmetric tensor <b>sources</b> in <b>string</b> gravity. There are defined nontrivial limits to four dimensional configurations and the Einstein gravity. Comment: The variant accepted to IJMPA, with new affiliation, 16 page...|$|R
40|$|Given a <b>source</b> <b>string</b> u and {{a target}} string w, {{to decide whether}} w can be {{obtained}} by applying a string morphism on u (i. e., uniformly replacing the symbols in u by strings) constitutes an NP-complete problem. For example, the target string w := baaba can be obtained from the <b>source</b> <b>string</b> u := aba, by replacing a and b in u by the strings ba and a, respectively. In this paper, we contribute to the recently started investigation of the computational complexity of the string morphism problem by studying it in the framework of parameterised complexity...|$|E
40|$|Given {{a static}} {{reference}} string $R$ and a <b>source</b> <b>string</b> $S$, a relative compression of $S$ {{with respect to}} $R$ is an encoding of $S$ as a sequence of references to substrings of $R$. Relative compression schemes are a classic model of compression and have recently proved very successful for compressing highly-repetitive massive data sets such as genomes and web-data. We initiate the study of relative compression in a dynamic setting where the compressed <b>source</b> <b>string</b> $S$ is subject to edit operations. The goal is to maintain the compressed representation compactly, while supporting edits and allowing efficient random access to the (uncompressed) <b>source</b> <b>string.</b> We present new data structures that achieve optimal time for updates and queries while using space linear {{in the size of}} the optimal relative compression, for nearly all combinations of parameters. We also present solutions for restricted and extended sets of updates. To achieve these results, we revisit the dynamic partial sums problem and the substring concatenation problem. We present new optimal or near optimal bounds for these problems. Plugging in our new results we also immediately obtain new bounds for the string indexing for patterns with wildcards problem and the dynamic text and static pattern matching problem...|$|E
40|$|In {{this paper}} we {{describe}} the Institute for Logic, Language and Computation (University of Amsterdam) phrase-based statistical machine translation system for Englishto- German translation proposed within the EMNLP-WMT 2011 shared task. The main novelty of the submitted system is a syntaxdriven pre-translation reordering algorithm implemented as <b>source</b> <b>string</b> permutation via transfer of the source-side syntax tree...|$|E
40|$|We have {{developed}} an example-based machine translation (EBMT) system that uses the World Wide Web for two different purposes: First, we populate the system’s memory with translations gathered from rule-based MT systems located on the Web. The <b>source</b> <b>strings</b> input to these systems were extracted automatically from an extremely small subset of the rule types in the Penn-II Treebank. In subsequent stages, the (source, target) translation pairs obtained are automatically transformed {{into a series of}} resources that render the translation process more successful. Despite the fact that the output from on-line MT systems is often faulty, we demonstrate in a number of experiments that when used to seed the memories of an EBMT system, they can in fact prove useful in generating translations of high quality in a robust fashion. In addition, we demonstrate the relative gain of EBMT in comparison to on-line systems. Second, despite the perception that the documents available on the Web are of questionable quality, we demonstrate in contrast that such resources are extremely useful in automatically postediting translation candidates proposed by our system...|$|R
40|$|The trie-based radix sort {{algorithm}} stores pairwise different infinite binary strings in {{the leaves}} of a binary tree {{in a way that}} the Ulam-Harris coding of each leaf equals a prefix (that is, an initial segment) of the corresponding string, with the prefixes being of minimal length so that they are pairwise different. We investigate the radix sort tree chains [...] the tree-valued Markov chains that arise when successively storing infinite binary strings Z_ 1, [...] ., Z_n, n= 1, 2, [...] . according to the trie-based radix sort algorithm, where the <b>source</b> <b>strings</b> Z_ 1, Z_ 2, [...] . are independent and identically distributed. We establish a bijective correspondence between the full Doob [...] Martin boundary of the radix sort tree chain with a symmetric Bernoulli source (that is, each Z_k is a fair coin-tossing sequence) and the family of radix sort tree chains for which the common distribution of the Z_k is a diffuse probability measure on { 0, 1 }^∞. In essence, our result characterizes all the ways that it is possible to condition such a chain of radix sort trees consistently on its behavior "in the large". Comment: 15 pages, 0 figure...|$|R
40|$|We {{present a}} grammar based {{approach}} for specifying a transformation as {{a sequence of}} transformation operations that operate on an intermediate representation. The transformation sequence is specified in the semantic actions of an abstract attribute grammar. The mapping between the object-oriented design of the intermediate representation and the abstract grammar directly reflects the objectoriented design {{in the structure of}} the grammar. It has properties that permit utilizing grammar based tools at arbitrary abstraction levels of the language representation. The program fragments can be both <b>source</b> <b>strings</b> and fragments of the intermediate representation that can be used interchangeably in the specification. We demonstrate the applicability of the approach by using available attribute grammar tools and the source-tosource infrastructure ROSE for specifying and performing transformations of C++ programs. The results of data flow analysis tools using fixed point algorithms is integrated as available attributes that can be used for enabling or disabling transformation sequences. With the abstract attribute grammar the transformation is computed as an attribute value that represents a sequence of restructure operations. The composition of different transformation sequences permits the reuse of sub-transformation specifications. Eventually we discuss the correspondence to rewrite tools permitting a pattern based restructuring of the program representation. ...|$|R
40|$|We {{introduce}} a novel search algorithm for statisti-cal machine translation based on dynamic program-ming (DP). During the search process two statis-tical knowledge sources are combined: a translation model and a bigram language model. This search al-gorithm expands hypotheses along {{the positions of}} the target string while guaranteeing progressive cov-erage of the words in the <b>source</b> <b>string.</b> We present experimental results on the Verbmobil task. ...|$|E
40|$|Consider {{approximate}} (lossy) matching of a <b>source</b> <b>string</b> P, with {{a random}} codebook generated from reproduction distribution Q, at a specified distortion d. Recent work determined the minimum coding rate, R 1 = R(P; Q; d), for this setting. We observe that for large word length and with high probability, the matching codeword is typical with a distribution Q 1 which {{is different from}} Q. If a new random codebook is generated Q 1, then the <b>source</b> <b>string</b> will favor code words which are typical with a new distribution Q 2, resulting in minimum coding rate R 2 = R(P; Q 1; d), and so on. We show that the sequences of distributions Q 1; Q 2 : : : and rates R 1; R 2; : : :, generated by this procedure, converge to an optimum reproduction distribution Q, and the rate-distortion function R(P; d), respectively. We also derive a fixed rate-distortion slope version of this natural type selection process. In the latter case, an iteration of the process stochastically simulates a [...] ...|$|E
40|$|The Common Substring Alignment Problem {{is defined}} as follows: Given a set {{of one or more}} strings and a target string. is a common {{substring}} of all strings, that is. The goal is to compute the similarity of all strings with, without computing the part of again and again. Using the classical dynamic programming tables, each appearance of in a <b>source</b> <b>string</b> would require the computation of all the values in a dynamic programming table of size where is the size of. Here we describe an algorithm which is composed of an encoding stage and an alignment stage. During the first stage, a data structure is constructed which encodes the comparison of with. Then, during the alignment stage, for each comparison of a source with, the pre-compiled data structure is used to speed up the part of. We show how to reduce the alignment work, for each appearance of the common substring in a <b>source</b> <b>string,</b> to- at the cost of encoding work, which is executed only once...|$|E
5000|$|The Tcl {{programming}} language has a command called , which executes the source code provided as an argument. Tcl represents all <b>source</b> code as <b>strings,</b> with curly braces acting as quotation marks, {{so that the}} argument to [...] can have the same formatting as any other source code.|$|R
40|$|In {{this report}} we obtain {{explicit}} string-like solutions of {{equations of motion}} of massive heterotic supergravity recently obtained by Bergshoeff, Roo and Eyras. We also find consistent <b>string</b> <b>source</b> which can be embedded in these backgrounds when space-time dimension is {{greater than or equal}} to six. Comment: latex file, 7 pages, typos corrected, version to appear in Phys. Lett. ...|$|R
40|$|Abstract Colombeau’s {{theory of}} {{generalised}} functions {{is used to}} calculate the contributions, at the rotation axis, to the distributional curvature for a time-dependent radiating cosmic string, and hence the mass per unit length of the <b>string</b> <b>source.</b> This mass per unit length is compared with the mass at null infinity, giving evidence for a global energy conservation law. 1...|$|R
