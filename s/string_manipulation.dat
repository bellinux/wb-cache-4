133|24|Public
25|$|TTM Is a recursive, interpretive {{language}} designed {{primarily for}} <b>string</b> <b>manipulation,</b> text editing, macro definition and expansion, and other applications generally classified as systems programming. It is derived, primarily, from GAP and GPM.|$|E
25|$|SQL Server 2008 {{includes}} {{a total of}} 58 functions that perform relatively basic aggregation (12), math (23) and <b>string</b> <b>manipulation</b> (23) operations useful for analytics; it includes no native functions that perform more complex operations directly related to finance, statistics or engineering.|$|E
25|$|The main {{critique}} of formalism {{is that the}} actual mathematical ideas that occupy mathematicians are {{far removed from the}} <b>string</b> <b>manipulation</b> games mentioned above. Formalism is thus silent on the question of which axiom systems ought to be studied, as none is more meaningful than another from a formalistic point of view.|$|E
5000|$|The C or Calculation spec(s) are next. Total fields may be {{described}} and accumulated. Complex computations and <b>string</b> <b>manipulations</b> are possible. Indicators may be conditioned.|$|R
50|$|Many Unix {{utilities}} perform simple <b>string</b> <b>manipulations</b> {{and can be}} used {{to easily}} program some powerful string processing algorithms. Files and finite streams may be viewed as strings.|$|R
40|$|The Manipuller {{is a novel}} Gestural Controller {{based on}} <b>strings</b> <b>manipulation</b> and multi-dimensional force sensing technology. This paper {{describes}} its motivation, design and operational principles {{along with some of}} its musical applications. Finally the results of a preliminary usability test are presented and discussed...|$|R
25|$|A {{relatively}} obscure {{design in}} the West, it was {{a radical departure from}} NEC's previous V-series CPUs—the NEC V20-V50 series—, which were based on the Intel x86 model, although it retained the ability to emulate them. According to NEC's documentation, the architectural change was made due to the increasing demand and diversity of programs, calling for a processor with both power (the 32-bit internal bus) and flexibility, having large numbers of general-purpose registers—a common feature of RISC architectures and a benefit to the emerging high-level languages. The V60 architecture retained however CISC features (which its manual describe as mainframe-based) like variable-length instructions, memory-to-memory operations including <b>string</b> <b>manipulation,</b> and fairly complex operand addressing schemes.|$|E
500|$|An {{empirical}} {{study found}} that scripting languages (such as Python) are more productive than conventional languages (such as C and Java) for a programming problem involving <b>string</b> <b>manipulation</b> and search in a dictionary. Memory consumption was often [...] "better than Java and not much worse than C or C++".|$|E
2500|$|Formalism {{holds that}} {{mathematical}} statements may {{be thought of}} as statements about the consequences of certain <b>string</b> <b>manipulation</b> rules. For example, in the [...] "game" [...] of Euclidean geometry (which is seen as consisting of some strings called [...] "axioms", and some [...] "rules of inference" [...] to generate new strings from given ones), one can prove that the Pythagorean theorem holds (that is, one can generate the string corresponding to the Pythagorean theorem). According to formalism, mathematical truths are not about numbers and sets and triangles and the like—in fact, they are not [...] "about" [...] anything at all.|$|E
5000|$|The string {{formatting}} macro simplifies {{variables to}} <b>string</b> <b>manipulations</b> using $ notation:def s = $"The number is $i"; //insert {{the value of}} the variable i where $i is placed def s = $"$x + $y = $(x+y)"; // $(...) {{can be used to make}} calculations or access members ...|$|R
40|$|Text {{compaction}} {{for display}} on very small screens Very small screens, {{such as the}} LCD displays on cellular telephones, pose unique problems for the display of textual messages. This paper presents a collection of techniques used to compact email text for display on mobile devices. These techniques range from simple <b>string</b> <b>manipulations</b> to more sophisticated linguistic processing. The techniques have been implemented in a commercial produc...|$|R
40|$|This paper {{addresses}} {{the issue of}} identifiing buffer overrun vulnerabilities by statically analyzing C source code. We demonstrate a scalable analysis based on modeling C <b>string</b> <b>manipulations</b> as a linear program. We also present fast, scalable solvers based on linear programming, and demonstrate {{how to make the}} analysis context sensitive. Based on these techniques, we built a prototype and used it to identify several vulnerabilities in popular security critical applications...|$|R
2500|$|Macro {{assemblers}} often allow macros to take parameters. Some assemblers include quite sophisticated macro languages, incorporating such {{high-level language}} elements as optional parameters, symbolic variables, conditionals, <b>string</b> <b>manipulation,</b> and arithmetic operations, all usable during {{the execution of}} a given macro, and allowing macros to save context or exchange information. Thus a macro might generate numerous assembly language instructions or data definitions, based on the macro arguments. This {{could be used to}} generate record-style data structures or [...] "unrolled" [...] loops, for example, or could generate entire algorithms based on complex parameters. For instance, a [...] "sort" [...] macro could accept the specification of a complex sort key and generate code crafted for that specific key, not needing the run-time tests that would be required [...] for a general procedure interpreting the specification. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements. Underlining this point, macros were used to implement an early virtual machine in SNOBOL4 (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine, which was then targeted to physical machines by transpiled to a native assembler via a macro assembler. This allowed a high degree of portability for the time.|$|E
50|$|These {{were special}} {{operators}} for sophisticated <b>string</b> <b>manipulation,</b> particularly for business applications.|$|E
5000|$|... and [...] - {{classes for}} {{performing}} <b>string</b> <b>manipulation</b> ( [...] as of J2SE 5.0).|$|E
40|$|This paper {{addresses}} {{the issue of}} identifying buffer overrun vulnerabilities by statically analyzing C source code. We demonstrate a light-weight analysis based on modeling C <b>string</b> <b>manipulations</b> as a linear program. We also present fast, scalable solvers based on linear programming, and demonstrate techniques to make the program analysis context sensitive. Based on these techniques, we built a prototype {{and used it to}} identify several vulnerabilities in popular security critical applications. Categories and Subject Descriptor...|$|R
5000|$|Anglo Boer War (1999) - for voices, <b>strings</b> and {{electronic}} <b>manipulation</b> ...|$|R
40|$|In recent years, domain-specific {{languages}} {{have been}} proposed for modelling applications on {{a high level of}} abstraction. Although the usage of domain-specific languages offers clear advantages, their design is a highly complex task. Moreover, developing a compiler or interpreter for these languages that can fulfil the requirements of industrial application is hard. Existing tools for the generation of compilers or interpreters for domain-specific languages are still in an early stage and not yet appropriate for the usage in an industrial setting. This paper presents a pragmatic way for designing and using domain-specific languages. In this approach, the domain-specific language is defined {{on the basis of a}} general-purpose programming language. Thus, general programming mechanisms such as arithmetics, <b>string</b> <b>manipulations,</b> basic data structures etc. are automatically available in the domain-specific language. Additionally, the designer of the domain-specific language can define further domain-specific constructs, both data types and operations. These are defined without breaching the syntax of the underlying general-purpose language...|$|R
50|$|Strings covers {{extension}} {{elements and}} functions that provide facilities {{to do with}} <b>string</b> <b>manipulation.</b>|$|E
5000|$|Complex {{functionality}} such as I/O, <b>string</b> <b>manipulation,</b> {{and mathematical}} functions are consistently delegated to library routines.|$|E
5000|$|Analysis of {{algorithms}} [...] - [...] determining {{time and}} storage needed {{by a particular}} (e.g. <b>string</b> <b>manipulation)</b> algorithm ...|$|E
50|$|The {{core system}} has basic support for UTF-8 characters, however the <b>string</b> {{indexing}} and <b>manipulation</b> procedures are not UTF-8 aware. Here again {{there is an}} extension library which adds support for full UTF-8 awareness.|$|R
40|$|The {{introduction}} of the PowerPC 970 JS 20 blade server opens opportunities for vectorizing commercial applications using the integrated AltiVec unit. We examined the vectorization of applications from diverse fields such as XML parsing, UTF- 8 encoding, life sciences, <b>string</b> <b>manipulations,</b> and sorting. We obtained performance speedups (over optimized scalar code) for string comparisons (2 - 3), XML delimiter lookup (1. 5 - 5), and UTF- 8 conversion (2 - 4). The focus {{of this paper is}} on the process rather than on the results. Vectorizing commercial applications vastly differs from vectorizing graphic and image processing applications. In addition to the results achieved, we describe the pitfalls encountered, {{the advantages and disadvantages of}} the AltiVec unit, and what is missing in its current implementation. Sorting presents an interesting example. Vectorizing the quicksort algorithm was not successful due to low parallelism and misaligned data accesses. Vectorization of the combsort algorithm was very successful, with speedups of 5. 0, until the data spilled from the L 2 cache. Combining both approaches, by first partitioning the input using quicksort and then continuing with combsort, yielded speedups of over 2. 0. This research led to several patent disclosures, many algorithmic enhancements, and an insight into the correct integration of software with the AltiVec unit. The wealth of information collected during this study is being conveyed to the auto-vectorization teams of the relevant compilers. ...|$|R
40|$|Abstract — Regular {{expressions}} {{are extremely}} useful, because they {{allow us to}} work with text in terms of patterns. They are considered the most sophisticated means of performing operations such as <b>string</b> searching, <b>manipulation,</b> validation, and formatting in all applications that deal with text data. Character recognition problem scenarios in sequence analysis that are ideally suited {{for the application of}} regular expression algorithms. This paper describes a use of regular expressions in this problem domain, and demonstrates how the effective use of regular expressions that can serve to facilitate more efficient and more effective character recognition. Index Terms — Regular expression, edit distance method, feature extraction, preprocessing I...|$|R
50|$|In {{computer}} programming, trimming (trim) or stripping (strip) is a <b>string</b> <b>manipulation</b> {{in which}} leading and trailing whitespace {{is removed from}} a string.|$|E
50|$|The Gnat Ada Compiler {{comes with}} a package (GNAT.Spitbol) which {{implements}} all of the Spitbol <b>string</b> <b>manipulation</b> semantics. This can be called from within an Ada program.|$|E
50|$|These tasks {{consist of}} simple control-flow and <b>string</b> <b>manipulation</b> {{mechanisms}} that cover {{a lot of}} common usages like searching and replacing string in files, or counting occurrences of strings (frequency counting).|$|E
50|$|Some domain-specific {{languages}} expand {{over time}} to include full-featured programming tools, which further complicates {{the question of whether}} a language is domain-specific or not. A good example is the functional language XSLT, specifically designed for transforming one XML graph into another, which has been extended since its inception to allow (particularly in its 2.0 version) for various forms of filesystem interaction, <b>string</b> and date <b>manipulation,</b> and data typing.|$|R
30|$|The “How” {{questions}} {{are related to}} the steps to perform some task during the app development. In Android MSECO, topics cover the game development, app deployment over a real device, operation of authentication services such as Facebook and email, and, finally, behavior of elements that make up the app screen. In iOS MSECO, topics involve coding of controllers for reuse of component interface, configuration of permissions and verification within the app, design patterns aspects, and conversion of interface component values to <b>string</b> for <b>manipulation</b> of value informed by a user within the app. In Windows Phone MSECO, developers have questions on how to perform the steps to use notification service, use of sensors debugging mechanisms, and data persistence with databases.|$|R
40|$|In 2002, we will {{celebrate}} the tenth anniversary of Arden Syntax as an open standard. Coincident with this anniversary, Arden Syntax 2. 1, {{the latest version}} of the standard, will be balloted and, hopefully, approved by the membership of Health Level Seven, Inc. (HL 7), the sponsoring body for Arden Syntax. The changes to Arden Syntax include the addition of new operators for <b>string</b> and time <b>manipulation,</b> the removal of a deprecated trigger statement, and the addition of explicit support for structured messages...|$|R
5000|$|Uncertainty Axioms/String Manipulation Axioms are {{standard}} axioms for arithmetic, calculus, probability theory, and <b>string</b> <b>manipulation</b> {{that allow for}} the construction of proofs related to future variable values within the Gödel machine.|$|E
50|$|TTM Is a recursive, interpretive {{language}} designed {{primarily for}} <b>string</b> <b>manipulation,</b> text editing, macro definition and expansion, and other applications generally classified as systems programming. It is derived, primarily, from GAP and GPM.|$|E
50|$|A class {{used for}} <b>string</b> <b>manipulation,</b> {{representing}} a Unicode string (most typically using UTF-16 as its internal format). NSString is immutable, {{and thus can}} only be initialized but not modified. NSMutableString is a modifiable version.|$|E
50|$|Montage also {{provides}} <b>string</b> and value <b>manipulation,</b> serialization, and other functions {{that are not}} directly tied to the graphical user interface. It uses getters and setters to bind properties, so it maintains performance even {{as the number of}} bindings grows. It implements a managed draw cycle, {{a key part of the}} Montage architecture, that separates read and write operations at scheduled intervals, so it doesn't compromise performance. And it uses event delegation to manage event handling and dispatching to improve application performance.|$|R
40|$|In an {{artificial}} grammar learning (AGL) experiment, participants were trained with instances of one grammatical structure before completing a test phase {{in which they}} were required to discriminate grammatical from randomly created strings. Importantly, the underlying structure used to generate test strings was different from that used to generate the training strings. Despite the fact that grammatical training strings were more similar to nongrammatical test strings than they were to grammatical test <b>strings,</b> this <b>manipulation</b> resulted in a positive transfer effect, as compared with controls trained with nongrammatical strings. It is suggested that training with grammatical strings leads to an appreciation of set variance that aids the detection of grammatical test strings in AGL tasks. The analysis presented demonstrates that it is useful to conceptualize test performance in AGL as a form of unsupervised category learning...|$|R
5000|$|BASIC is a {{widespread}} programming language commonly adapted to desktop computers and pocket computers. The most common languages now used in high range calculators are proprietary BASIC-style dialects as used by CASIO and TI (TI-BASIC). These BASIC dialects are optimised for calculator use, combining the advantages of BASIC and keystroke programming. They {{have little in common}} with mainstream BASIC. [...] The version for the Ti-89 and subsequent is more fully featured, including the full set of <b>string</b> and character <b>manipulation</b> functions and statements in standard Basic.|$|R
