61|10000|Public
25|$|Several <b>state</b> <b>transition</b> <b>table</b> {{types are}} used. The most common {{representation}} is shown below: {{the combination of}} current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using state tables (see also virtual finite-state machine).|$|E
500|$|These methods take {{polynomial}} time, {{proportional to}} {{the square of the}} size of the <b>state</b> <b>transition</b> <b>table</b> of the input automaton. A related algorithm of [...] determines whether a given rule is surjective when applied to finite-length arrays of cells with periodic boundary conditions, and if so, for which lengths.|$|E
2500|$|The {{turnstile}} {{state machine}} {{can be represented}} by a <b>state</b> <b>transition</b> <b>table,</b> showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input: ...|$|E
50|$|<b>State</b> <b>transition</b> <b>tables</b> are {{typically}} two-dimensional tables. There are two common forms for arranging them.|$|R
40|$|Given the immanent gene {{expression}} mapping covering whole genomes during development, health and disease, we seek computational methods to maximize functional inference from such large data sets. Is it possible, in principle, to completely infer a complex regulatory network architecture from input/output patterns of its variables? We investigated this possibility using binary models of genetic networks. Trajectories, or <b>state</b> <b>transition</b> <b>tables</b> of Boolean nets, resemble time series of {{gene expression}}. By systematically analyzing the mutual information between input states and output states, one {{is able to}} infer the sets of input elements controlling each element or gene in the network. This process is unequivocal and exact for complete <b>state</b> <b>transition</b> <b>tables.</b> We implemented this REVerse Engineering ALgorithm (REVEAL) in a C program, and found the problem to be tractable within the conditions tested so far. For n= 50 (elements) and k= 3 (inputs per element), the analysis of incomplete <b>state</b> <b>transition</b> <b>tables</b> (100 <b>state</b> <b>transition</b> pairs {{out of a possible}} 10 15) reliably produced the original rule and wiring sets. While this study is limited to synchronous Boolea...|$|R
5000|$|The LR(1) parser is a {{deterministic}} automaton {{and as such}} {{its operation}} is based on static <b>state</b> <b>transition</b> <b>tables.</b> These codify the grammar of the language it recognizes and are typically called [...] "parsing tables".|$|R
2500|$|There is a {{wide variety}} of {{representations}} possible and one can express a given Turing machine program as a sequence of machine tables (see more at finite-state machine, <b>state</b> <b>transition</b> <b>table</b> and control table), as flowcharts and drakon-charts (see more at state diagram), or as a form of rudimentary machine code or assembly code called [...] "sets of quadruples" [...] (see more at Turing machine).|$|E
2500|$|In {{computer}} science, simulation {{has some}} specialized meanings: Alan Turing {{used the term}} [...] "simulation" [...] to refer to {{what happens when a}} universal machine executes a <b>state</b> <b>transition</b> <b>table</b> (in modern terminology, a computer runs a program) that describes the state transitions, inputs and outputs of a subject discrete-state machine. [...] The computer simulates the subject machine. Accordingly, in theoretical computer science the term simulation is a relation between state transition systems, useful in the study of operational semantics.|$|E
5000|$|Consider the {{classical}} deterministic finite automaton {{given by the}} <b>state</b> <b>transition</b> <b>table</b> ...|$|E
50|$|If the set {{of states}} Q is finite, then the {{transition}} functions are commonly represented as <b>state</b> <b>transition</b> <b>tables.</b> The construction of all possible transitions driven by strings in the free group has a graphical depiction as de Bruijn graphs.|$|R
5000|$|PALASM is {{an early}} {{hardware}} description language, used to translate Boolean functions and <b>state</b> <b>transition</b> <b>tables</b> into a fuse map for use with Programmable Array Logic (PAL) devices introduced by Monolithic Memories, Inc. The language was developed by John Birkner in the early 1980s. It is not case-sensitive.|$|R
50|$|DEVS abbreviating Discrete Event System Specification is a modular and {{hierarchical}} formalism for {{modeling and}} analyzing general systems {{that can be}} discrete event systems which might be described by <b>state</b> <b>transition</b> <b>tables,</b> and continuous <b>state</b> systems which might be described by differential equations, and hybrid continuous state and discrete event systems. DEVS is a timed event system.|$|R
50|$|<b>State</b> <b>transition</b> <b>table</b> is a table showing {{relation}} between an input and a state.|$|E
50|$|An {{example of}} a <b>state</b> <b>transition</b> <b>table</b> for a machine M {{together}} with the corresponding state diagram is given below.|$|E
5000|$|Implement a finite-state machine, using a <b>state</b> <b>transition</b> <b>table</b> and goto {{to switch}} between states (in absence of tail call elimination), {{particularly}} in automatically generated C code. For example, goto in the canonical LR parser.|$|E
50|$|Stateflow (developed by MathWorks) is {{a control}} logic tool used to model {{reactive}} systems via state machines and flow charts within a Simulink model. Stateflow uses {{a variant of}} the finite-state machine notation established by David Harel, enabling the representation of hierarchy, parallelism and history within a state chart. Stateflow also provides <b>state</b> <b>transition</b> <b>tables</b> and truth tables.|$|R
5000|$|Black-box testing {{treats the}} {{software}} as a [...] "black box", examining functionality without {{any knowledge of}} internal implementation, without seeing the source code. The testers are only aware of what the software is supposed to do, not how it does it. Black-box testing methods include: equivalence partitioning, boundary value analysis, all-pairs testing, <b>state</b> <b>transition</b> <b>tables,</b> decision table testing, fuzz testing, model-based testing, use case testing, exploratory testing and specification-based testing.|$|R
30|$|FORWARD_BACKWARD_MESSAGE {{receives}} {{only the}} result of FORWARD_MESSAGE and BACKWARD_MESSAGE, while LLR_ESTIMATES takes as input the forward–backward message resulting from FORWARD_BACKWARD_MESSAGE {{as well as the}} <b>state</b> <b>transition</b> output <b>table.</b>|$|R
5000|$|The {{turnstile}} {{state machine}} {{can be represented}} by a <b>state</b> <b>transition</b> <b>table,</b> showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input: ...|$|E
50|$|Simultaneous {{transitions}} in multiple finite state machines {{can be shown}} in what is effectively an n-dimensional <b>state</b> <b>transition</b> <b>table</b> in which pairs of rows map (sets of) current states to next states. This is an alternative to representing communication between separate, interdependent state machines.|$|E
50|$|Frances Grodzinsky et al. {{considered}} artificial {{systems that}} could be modelled as finite state machines. They posited that if the machine had a fixed <b>state</b> <b>transition</b> <b>table,</b> then {{it could not be}} morally responsible. If the machine could modify its table, then the machine's designer still retained some moral responsibility.|$|E
50|$|The Richards {{controller}} is {{a method}} of implementing a finite state machine using simple integrated circuits and combinational logic. The method has been named after its inventor, Charles L. Richards. One of the distinct advantages of this method over conventional finite state machine design methods {{is that it allows}} for easier design of complex finite state machines than the traditional techniques of <b>state</b> diagrams, <b>state</b> <b>transition</b> <b>tables</b> and Boolean algebra offer. Using Richards technique, it becomes relatively easy to implement machines with many hundreds or even thousands of states.|$|R
40|$|Abstract. The paper {{starts from}} the human influenza’s {{spreading}} phenomenon, as a complex of observable occurrences, and develops a stochastic process, defined {{as a set of}} procedures that convert its initial state into a sequence of different states during the phenomenon’s lifespan. The Monte Carlo simulation method for a stochastic discrete event system is used. This system is completely described in terms of: entities, sequential <b>states,</b> <b>transition</b> <b>tables</b> of <b>states,</b> sets of input/output events, internal/external transition function, events/time advance function, input/output parameters. The simulation can encompass several contagion schema and health policy responses. Finally, some information about the software in the field is given...|$|R
5000|$|Risk-based testing (RBT) {{is a type}} of {{software}} testing that functions as an organizational principle used to prioritize the tests of features and functions in software, based on the risk of failure, the function of their importance and likelihood or impact of failure. In theory, there are an infinite number of possible tests. Risk-based testing uses risk (re-)assessments to steer all phases of the test process, i.e., test planning, test design, test implementation, test execution and test evaluation. This includes for instance, ranking of tests, and subtests, for functionality; test techniques such as boundary-value analysis, all-pairs testing and <b>state</b> <b>transition</b> <b>tables</b> aim to find the areas most likely to be defective.|$|R
5000|$|These methods take {{polynomial}} time, {{proportional to}} {{the square of the}} size of the <b>state</b> <b>transition</b> <b>table</b> of the input automaton. A related algorithm of [...] determines whether a given rule is surjective when applied to finite-length arrays of cells with periodic boundary conditions, and if so, for which lengths.|$|E
50|$|For a nondeterministic finite {{automaton}} (NFA), a new input may cause {{the machine to}} be {{in more than one}} state, hence its non-determinism. This is denoted in a <b>state</b> <b>transition</b> <b>table</b> by a pair of curly braces { } with the set of all target states between them. An example is given below.|$|E
5000|$|As with Turing machines, {{the actions}} are {{specified}} by a <b>state</b> <b>transition</b> <b>table</b> listing the current internal {{state of the}} turmite {{and the color of}} the cell it is currently standing on. For example, the turmite shown in the image {{at the top of this}} page is specified by the following table: ...|$|E
40|$|Lexical analyzers {{partition}} input characters into tokens. When ambiguities arise during lexical analysis, the longest-match rule {{is generally}} adopted {{to resolve the}} ambiguities. The longest-match rule causes the look-ahead problem in traditional lexical analyzers, {{which are based on}} Moore machines. In Moore machines, output tokens are associated with states of the automata. By contrast, because Mealy machines associate output tokens with <b>state</b> <b>transitions,</b> the look-ahead behaviors can be encoded in their <b>state</b> <b>transition</b> <b>tables.</b> Therefore, we believe that lexical analyzers should be based on Mealy machines, rather than Moore machines, in order to solve the look-ahead problem. We propose techniques to construct Mealy machines from regular expressions and to perform sequential and data-parallel lexical analysis with these Mealy machines. Key Words: automata, finite-lookahead automata, lexical analysis, Mealy machines, Moore machines, parallel algorithms, regular expressions, suffix autom [...] ...|$|R
40|$|In this paper, {{we present}} a 4 -state {{solution}} to the Firing Squad Synchronization Problem (FSSP) based on hybrid rule 60 / 102 Cellular Automata(CA). This solution solves the problem on the line of length 2 ^n with two generals. Previous work on FSSP for 4 -state systems focused mostly on linear cellular automata, where synchronizes {{an infinite number of}} lines but not all possible lines. We give time-optimal solutions to synchronize an infinite number of lines by rule 60 and rule 102 respectively, and construct a hybrid rule 60 and 102 <b>states</b> <b>transition</b> <b>table.</b> Compared to the known solutions of cellular automata, the hybrid CA way is simpler and faster, the minimal time is (n- 1) step. Comment: 8 pages, 6 figure...|$|R
40|$|This paper {{presents}} a new method of fitting probabilistic Boolean networks (PBNs) to time-course state data. The critical {{issue to be}} addressed is to identify {{the contributions of the}} PBN's constituent Boolean networks in a sequence of temporal data. The sequence must be partitioned into sections, each corresponding to a single model with fixed parameters. We propose an approach to subsequence identification based on 'purity functions' derived from <b>state</b> <b>transition</b> <b>tables,</b> to be used in conjunction with a method for the identification of predictor genes and functions. We also present the estimation of the network switching probability, selection probabilities, perturbation rate, as well as observations on the inference of input genes, predictor functions and their relation with the length of the observed data sequence...|$|R
5000|$|State {{diagrams}} {{can be used}} to graphically represent finite state machines. This {{was introduced}} by C.E. Shannon and W. Weaver in their 1949 book [...] "The Mathematical Theory of Communication". Another source is Taylor Booth in his 1967 book [...] "Sequential Machines and Automata Theory". Another possible representation is the <b>State</b> <b>transition</b> <b>table.</b>|$|E
50|$|Several <b>state</b> <b>transition</b> <b>table</b> {{types are}} used. The most common {{representation}} is shown below: {{the combination of}} current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using state tables (see also virtual finite-state machine).|$|E
5000|$|There is a {{wide variety}} of {{representations}} possible and one can express a given Turing machine program as a sequence of machine tables (see more at finite-state machine, <b>state</b> <b>transition</b> <b>table</b> and control table), as flowcharts and drakon-charts (see more at state diagram), or as a form of rudimentary machine code or assembly code called [...] "sets of quadruples" [...] (see more at Turing machine).|$|E
30|$|To {{obtain the}} {{automaton}} A_P, we show its structure in Fig.  1 and its <b>state</b> <b>transitions</b> in <b>Table</b> 2. For general case of P and S, the A_P {{can be obtained}} by automata technique in some similar way [15] to get automata for KMP algorithm, which we ignore for the restriction of our framework (Fig. 2).|$|R
40|$|Abstract. While Object Oriented (OO) methodologies {{have some}} {{advantages}} over structured methods, OO {{is not as}} mature as structured analysis and design and does not contain all of the tools/ techniques needed to support a large system design. By using both OO models and Structured models (e. g., data flow diagrams, control flow diagrams, <b>state</b> <b>transition</b> <b>tables)</b> during systems analysis, a more complete understanding of the system requirements can be developed. During the design process, the software architecture components can be designed and built either as OO modules or structured modules depending upon {{the requirements of the}} module. Since both views of the system (OO and structured) have been built during the analysis phase, there is no “translation/conversion ” from one methodology to the other. By combining models and approaches from both OO and structured methods in one process we {{can take advantage of the}} strengths of both methodologies...|$|R
40|$|This paper {{presents}} the results of a contract between ARL and the University of Delaware to develop a formal specification of the link layer of 188 - 220 using the ISO International Standard Formal Description Technique Estelle. This formal specification aims at discovering and resolving ambiguities in the original English document that would cause interpretation problems for implementors. The specification considers Type 1 connectionless (CL) operation of the link layer. It contains the complete set of command and response PDUs for the CL mode (UI, XID, URR, URNR, TEST). The paper discusses state diagrams and <b>state</b> <b>transition</b> <b>tables</b> needed for the Estelle specification. It also summarizes several ambiguities that were discovered in developing the Estelle specification. 1. Introduction The military standard "Interoperability Standard for Digital Message Transfer Device Subsystems" (MIL-STD- 188220) [5, 6] re{{presents the}} army's focused efforts to digitize the battlefield. The army is hopi [...] ...|$|R
