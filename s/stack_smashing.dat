34|3|Public
50|$|Transparent {{implementation}} of PaX address space layout randomizations and <b>stack</b> <b>smashing</b> protections using ELF shared objects as executables.|$|E
5000|$|... #Caption: Fig. 3 A <b>stack</b> <b>smashing</b> attack. The {{target of}} the attack keeps the same address; but the payload moves with the stack.|$|E
50|$|Sigreturn-oriented {{programming}} (SROP) is {{a technique}} similar to return-oriented programming (ROP), since it employs code reuse to execute code {{outside the scope of}} the original control flow.In this sense the adversary {{need to be able to}} carry on a <b>stack</b> <b>smashing</b> attack, usually through a stack buffer overflow, to overwrite the return address contained inside the call stack.|$|E
5000|$|One For My Baby: The number {{took two}} and a half days to shoot, after seven days of full set rehearsal. After a drunken {{rendition}} of the song, he furiously tap dances up and down the bar, pausing only to <b>smash</b> <b>stacked</b> racks of glasses and a mirror. Astaire's first drunk dance was the comic routine You're Easy To Dance With in Holiday Inn, but this solo marks his first clear departure from a carefully crafted screen image of urbane charm.|$|R
40|$|This {{dissertation}} {{proposes a}} novel, cooperative hardware/software mechanism, called DISE (dynamic instruction stream editor), for efficiently transforming programs. DISE transforms programs using programmable instruction macro-expansion. It resides within the processor inspecting every fetched instruction. Based on user-defined rules, it macro-expands {{some of those}} instructions into parameterized replacement sequences. ^ DISE can express {{a broad range of}} transformations including transformations for profiling program characteristics, implementing interactive debugging primitives, decompressing compressed programs, and detecting <b>stack</b> and pointer <b>smashing</b> attacks. This dissertation describes the functionality, interface, and system architecture of DISE and proposes one implementation of this architecture. Our evaluation demonstrates that DISE transformation is highly efficient. Unlike transformation mechanisms implemented entirely in software, DISE has no impact on instruction cache performance because it transforms instructions within the processor. Furthermore, the performance cost of macro-expanding instructions is neglible, which is not true of software mechanisms (although some mechanisms transform code statically rather than at runtime). The only significant performance cost of DISE transformation is executing the additional instructions, and this overhead is usually less than 25 % for most transformations and benchmarks. ...|$|R
5000|$|Dickerson {{returned}} to action in November 1944 with her arrival at Aitape, New Guinea. After escort duty in New Guinea, she sailed 27 December {{for the invasion}} of Lingayen Gulf, Luzon, on 9 January 1945, again supporting the operations of an underwater demolition team. She reported to Ulithi {{at the end of}} January for repairs, and then joined the screen of a logistics support force for the invasion of Iwo Jima 19 February. She {{returned to}} Leyte with 58 prisoners of war, then departed again 24 March with an LST-LSM convoy which was assigned to capture the island of Keise Shima, on which heavy artillery would be placed for the bombardment of Okinawa. Her mission complete, Dickerson was with the transports southwest of Okinawa on the night of 2 April, when the Japanese attacked in strength. One of the kamikaze planes approached the destroyer in a long, low glide, and slashed off the tops of her two <b>stacks</b> before <b>smashing</b> into the base of her bridge, toppling her mast and starting intense gasoline fires. Almost simultaneously another plane scored a direct hit on the center of her forecastle. The explosion tore a hole in the deck almost the complete width of the ship. Despite immediate fire and damage control measures, Dickersons crew was forced to abandon ship when the raging fires threatened her forward magazine. Fifty-four officers and men, including the commanding officer, were lost. [...] and [...] stood by to rescue survivors, and Bunch succeeded in putting out the fires which had virtually demolished Dickerson. The smoldering hulk was towed by [...] to a captured Japanese Base, Kerama Retto, the dead and salvageable material were removed, then it was towed out to sea and sunk on 4 April 1945.|$|R
50|$|Buffer overflows, {{a common}} {{software}} security vulnerability, happen when a process tries to store data beyond a fixed-length buffer. For example {{if you have}} 8 slots to store items in, and try to put 9 items you {{will end up with}} a problem. In computer memory the overflowed data may overwrite data in the next location which can result in a security vulnerability (<b>stack</b> <b>smashing)</b> or program termination (segmentation fault).|$|E
50|$|Stack buffer {{overflow}} {{can be caused}} deliberately {{as part of an}} attack known as <b>stack</b> <b>smashing.</b> If the affected program is running with special privileges, or if it accepts data from untrusted network hosts (for example, a public webserver), then the bug is a potential security vulnerability that allows an attacker to inject executable code into the running program and take control of the process. This {{is one of the oldest}} and more reliable methods for attackers to gain unauthorized access to a computer.|$|E
50|$|Various {{mechanisms}} were enabled {{to reduce}} the possibility of malicious code being injected and/or executed inside the Linux kernel, including dividing kernel memory into logical segments for code and data, with page access permissions of read-only and no-execute as appropriate. The kernel was also restricted from directly accessing user space memory, and stronger stack protection was enabled in the GCC compiler to reduce <b>stack</b> <b>smashing.</b> To limit exposure of the kernel to potentially malicious code, perf was disabled by default, ioctl commands were restricted by SELinux, and seccomp-bpf was enabled to grant processes the ability to restrict system calls.|$|E
50|$|Stack buffer {{overflow}} {{can be caused}} deliberately {{as part of an}} attack known as <b>stack</b> <b>smashing.</b> If the affected program is running with special privileges, or accepts data from untrusted network hosts (e.g. a webserver) then the bug is a potential security vulnerability. If the stack buffer is filled with data supplied from an untrusted user then that user can corrupt the stack {{in such a way as}} to inject executable code into the running program and take control of the process. This is one of the oldest and more reliable methods for attackers to gain unauthorized access to a computer.|$|E
50|$|Malicious {{parties may}} attempt a <b>stack</b> <b>smashing</b> attack that takes {{advantage}} {{of this type of}} implementation by providing oversized data input to a program that does not check the length of input. Such a program may copy the data in its entirety to a location on the stack, and in so doing it may change the return addresses for procedures that have called it. An attacker can experiment to find a specific type of data that can be provided to such a program such that the return address of the current procedure is reset to point to an area within the stack itself (and within the data provided by the attacker), which in turn contains instructions that carry out unauthorized operations.|$|E
5000|$|NetBSD {{provides}} {{various features}} in the security area. The Kernel Authorization framework (or Kauth) is a subsystem managing all authorization requests inside the kernel, and used as system-wide security policy. It allows external modules to plug-in the authorization process. NetBSD also incorporates exploit mitigation features, ASLR, restricted mprotect (...) and Segvguard from the PaX project, and GCC <b>Stack</b> <b>Smashing</b> Protection (SSP, or also known as ProPolice, enabled by default since NetBSD 6.0) compiler extensions. Verified Executables (or Veriexec) is an in-kernel file integrity subsystem in NetBSD. It allows the user to set digital fingerprints (hashes) of files, and take {{a number of different}} actions if files do not match their fingerprints. For example, one can allow Perl to run only scripts that match their fingerprints. The cryptographic device driver (CGD) allows using disks or partitions (including CDs and DVDs) for encrypted storage.|$|E
5000|$|Return-oriented {{programming}} is an advanced {{version of a}} <b>stack</b> <b>smashing</b> attack. Generally, these types of attacks arise when an adversary manipulates the call stack {{by taking advantage of}} a bug in the program, often a buffer overrun. In a buffer overrun, a function that does not perform proper bounds checking before storing user-provided data into memory will accept more input data than it can store properly. If the data is being written onto the stack, the excess data may overflow the space allocated to the function's variables (e.g., [...] "locals" [...] in the stack diagram to the right) and overwrite the return address. This address will later be used by the function to redirect control flow back to the caller. If it has been overwritten, control flow will be diverted to the location specified by the new return address.|$|E
5000|$|Adding {{the cast}} may mask failure {{to include the}} header , in which the {{prototype}} for [...] is found. In {{the absence of a}} prototype for , the C90 standard requires that the C compiler assume [...] returns an [...] If there is no cast, C90 requires a diagnostic when this integer is assigned to the pointer; however, with the cast, this diagnostic would not be produced, hiding a bug. On certain architectures and data models (such as LP64 on 64-bit systems, where [...] and pointers are 64-bit and [...] is 32-bit), this error can actually result in undefined behaviour, as the implicitly declared [...] returns a 32-bit value whereas the actually defined function returns a 64-bit value. Depending on calling conventions and memory layout, this may result in <b>stack</b> <b>smashing.</b> This issue is less likely to go unnoticed in modern compilers, as C99 does not permit implicit declarations, so the compiler must produce a diagnostic even if it does assume [...] return.|$|E
40|$|Problem 2. 1 : <b>stack</b> <b>smashing</b> attack {{protection}} (2 + 2 + 4 + 2 = 10 points) Buffer overflows {{and more}} specifically <b>stack</b> <b>smashing</b> attacks are {{the most widely used}} exploits to attack systems. A number of techniques have been proposed to prevent or at least detect such attacks. The paper by Cowan et. al. [1] proposes a compiler technique which aims to detect <b>stack</b> <b>smashing</b> attacks while the paper by Baratloo etc. al. [2] describes two libraries that provide protection against <b>stack</b> <b>smashing</b> attacks. Network Intrusion Detection Systems (IDSs) try to detect attack codes in the network by identifying attack signatures. More recent attack strings use polymorphic attach codes and are therefore harder to detect by IDSs. The paper by Pasupulati et. al. [3] describes an extension for the open network intrusion detection system called snort which can detect polymorphic attack codes. Your task is to read the papers and to answer the following questions. a) Briefly summarize the techniques described in [1] and [2] and evaluate their strong and weak points. b) Paper [2] outlines a speficic situation where they use trap instructions. Why are they neede...|$|E
40|$|Abstract. The paper {{addresses}} {{the problem of}} <b>stack</b> <b>smashing</b> or stack overflows in modern operating systems. We focus on a security solution for this problem, namely compiler generated canary protection and, to be more specific, we consider the <b>Stack</b> <b>Smashing</b> Protector (SSP) present in the most popular C compiler, the GCC. We first analyze {{the limitations of the}} GCCs SSP and then present three improvements that will harden the security offered by the SSP making an attackers attempt more difficult. All improvements refer to the most recent version of GCC, 4. 6. 2...|$|E
40|$|<b>Stack</b> <b>smashing</b> {{attacks were}} the most {{exploited}} security vulnerability in the past decade, according to CERT. Using a method called <b>stack</b> <b>smashing,</b> a malicious user overflows a buffer in the stack frame, overwriting critical stack state. The return address of the current function, which is saved in the function's stack frame, is overwritten when the buffer overflows. The new return address points to the attacker's code. So, when the function is exited, control is transferred to the attacker's code instead of back to the calling function. A common way to prevent overflow-based <b>stack</b> <b>smashing</b> is to insert bounds checking code or insert sentinel values on the stack, but this requires recompilation. We propose a hardware-based method that does not require recompilation, {{based on the idea}} that an attack of this kind produces an unexpected return address. The processor maintains a separate hardware stack, called the shadow stack, and monitors the dynamic instruction stream for subroutine calls and returns. When a call instruction is retired, its return address is pushed on the shadow stack. When a return instruction is retired, the address at the top of the shadow stack is popped and compared to the target of the retur...|$|E
40|$|The ICAT {{statistics}} {{over the}} past few years have shown at least one out of every five CVE and CVE candidate vulnerabilities have been due to buffer overflows. This constitutes a significant portion of today’s computer related security concerns. In this paper we introduce a novel method for detecting <b>stack</b> <b>smashing</b> and buffer overflow attacks. Our runtime method extracts return addresses from the program call stack and uses these return addresses to extract their corresponding invoked addresses from memory. We demonstrate how these return and invoked addresses can be represented as a directed weighted graph and used in the detection of <b>stack</b> <b>smashing</b> attacks. We introduce the concept of a Greedy Hamiltonian Call Path and show how the lack of such a path can be used to detect stack-smashing attacks...|$|E
40|$|Stack {{shielding}} {{technologies have}} been developed to protect programs against exploitation of stack based buffer overflows. Among different types of protections, we can separate two major groups. Those that modify the environment where applications are executed, for example PaX now integrated into the OpenWall project[4], and those that alter the way programs are compiled. We will focus on the last group, specially in StackGuard, StackShield, and Microsoft’s new <b>stack</b> <b>smashing</b> protection. Techniques that exploit stack based buffer overflows on protected programs and environment have been presented in the past in [3], [2] and [16]. Here we’ll describe how the studied protections work, and then we’ll present four more tricks to bypass <b>stack</b> <b>smashing</b> protections, some of which are extentions of older techniques, and some we think are novel...|$|E
40|$|<b>Stack</b> <b>smashing</b> {{is still}} one of the most popular {{techniques}} for computer system attack. In this paper we present an anti-stack-smashing defense technique for Microsoft Windows systems. Our approach works at install-time, and does not rely on having access to the source-code: The user decides when and which executables to vaccinate. Our technique consists of instrumenting a given executable with a mechanism to detect <b>stack</b> <b>smashing</b> attacks. We developed a prototype implementing our technique and verified that it successfully defends against actual exploit code. We then extended our prototype to vaccinate DLLs, multi-threaded applications and DLLs used by multi-threaded applications, which present significant additional complications. We present promising performance results measured on SPEC 2000 benchmarks: Vaccinated executables were no more than 8 % slower than their un-vaccinated originals...|$|E
40|$|Buffer {{overflow}} {{attacks have}} been causing serious security problems for decades. With more embedded systems networked, {{it becomes an}} important research problem to defend embedded systems against buffer overflow attacks. In this paper, we propose the Hardware/Software Address Protection (HSAP) technique to solve this problem. We first classify buffer overflow attacks into two categories (<b>stack</b> <b>smashing</b> attacks and function pointer attacks) and then provide two corresponding defending strategies. In our technique, hardware boundary check method and function pointer XOR method are used to protect a system against <b>stack</b> <b>smashing</b> attacks and function pointer attacks, respectively. Although {{the focus of the}} HSAP technique is on embedded systems because of the availability of hardware support, we show that the HSAP technique can be applied to any type of processors to defend against buffer overflow attacks. We use four classes of processors to illustrate that the applicability of our technique is independent of architectures. We experiment with our HSAP technique in ARM Evaluator- 7 T simulation development environments. The results show that our HSAP technique can defend a system against more types of buffer overflow attacks with little overhead than the previous work. ...|$|E
40|$|Buffer {{overflow}} vulnerability {{is one of}} {{the most}} common security bugs existing in today’s software systems. In this paper, we propose a microarchitectural design of a return address stack aiming to detect and stop <b>stack</b> <b>smashing.</b> This approach has been used in other proposals to guard against buffer overflow vulnerabilities. Our contribution is a design that handle multi-path execution, speculative execution, abnormal control flow, and extended call depth. Our solution makes no assumption about the presence of architecturally visible calls and returns. ...|$|E
40|$|Abstract — This paper covers {{defensive}} security technologies and secure programming techniques {{employed in the}} OpenBSD operating system. Privilege separation, a secure design pattern which is implemented in many privileged processes, is discussed based on the network time protocol daemon OpenNTPD. Afterwards {{a closer look at}} address space and memory protection techniques like WˆX and the <b>Stack</b> <b>Smashing</b> Protector is taken. Finally the process of gathering entropy in order to produce high quality random numbers is discussed based on examples found in the OpenBSD operating system. I...|$|E
40|$|In {{this paper}} we present an {{efficient}} countermeasure against <b>stack</b> <b>smashing</b> attacks. Our countermeasure does {{not rely on}} secret values (such as canaries) and protects against attacks that are not addressed by state-of-the-art countermeasures. Our technique splits the standard stack into multiple stacks. The allocation of data types {{to one of the}} stacks is based on the chances that a specific data element is either a target of attacks and/or an attack vector. We have implemented our solution in a C-compiler for Linux. The evaluation shows that the overhead of using our countermeasure is negligible. ...|$|E
40|$|Since 1998, StackGuard patches to GCC {{have been}} used to protect entire {{distributions}} from <b>stack</b> <b>smashing</b> buffer overflows. Performance overhead and software compatibility issues have been minimal. In its history, the parts of GCC that StackGuard has operated in have twice changed enough to require complete overhauls of the StackGuard patch. Since StackGuard is a mature technology, even see-ing re-implementations in other compilers, we propose that GCC adopt StackGuard as a stan-dard feature. This paper describes our recent work to bring StackGuard fully up to date with current GCC, introduce architecture indepen-dence, and extend the protection of stack data structures, while keeping the StackGuard patch as small, simple, and modular as possible. ...|$|E
40|$|Abstract — Recent {{advances}} in buffer-overflow protection {{are able to}} eliminate several common types of buffer-overflow attacks (e. g. <b>stack</b> <b>smashing,</b> jump table). In this paper, we introduce arbitrary copy, a type of buffer-overflow attack {{that is capable of}} bypassing most buffer-overflow solutions. By overflowing both source and destination pointers of any string copy (or similar) function, arbitrary copy is able to utilize a useful local address for attacking a system. This method can bypass even the most promising buffer-overflow protection that enforces the integrity of address such as Secure Bit [24] and MINOS [8]. Later, we analyze conditions necessary for the success of this attack. Though satisfying all necessary conditions for this attack should be difficult, our conclusion {{is that it is a}} potential threat and requires consideration. Index Terms—Buffer overflow, Buffer-Overflow Attacks...|$|E
40|$|Abstract—Stack smashing {{is still}} one of the most popular {{techniques}} for computer system attack. In this work, we present an antistack-smashing defense technique for Microsoft Windows systems. Our approach works at install-time, and does not rely on having access to the source-code: The user decides when and which executables to vaccinate. Our technique consists of instrumenting a given executable with a mechanism to detect <b>stack</b> <b>smashing</b> attacks. We developed a prototype implementing our technique and verified that it successfully defends against actual exploit code. We then extended our prototype to vaccinate DLLs, multithreaded applications, and DLLs used by multithreaded applications, which present significant additional complications. We present promising performance results measured on SPEC 2000 benchmarks: Vaccinated executables were no more than 8 percent slower than their unvaccinated originals. Index Terms—Computer security, buffer overflow, instrumentation...|$|E
40|$|Buffer Overflows are {{responsible}} for many vulnerabilities in operating systems and application programs, actually {{dating back to the}} famous Morris worm in 1988. Descriptions of buffer overflow exploitation techniques are, however, in many cases either only scratching the surface or quite technical, including program source code, assembler listings and debugger usage, which scares away a lot of people without a solid programming Key fingerprint background. = AF 19 FA 27 2 F 94 998 D FDB 5 DE 3 D F 8 B 5 06 E 4 A 169 4 E 46 This paper tries to fill the gap between those two categories by striking a good balance between depth and breadth of the presentation, covering the <b>stack</b> <b>smashing,</b> frame pointer overwrite, return-into-libc, and heap based overflow techniques as well as possibl...|$|E
40|$|FreeBSD {{is widely}} {{accepted}} {{as one of}} the most reliable and performance-driven operating systems currently available in both the open source and proprietary worlds. While the exploitation of kernel vulnerabilities has been researched in the context of the Windows and Linux operating systems, FreeBSD, and BSD-based systems in general, have not received the same attention. This paper will initially examine the exploitation of kernel stack overflow vulnerabilities on FreeBSD. The development process of a privilege escalation kernel <b>stack</b> <b>smashing</b> exploit will be documented for vulnerability CVE- 2008 - 3531. The second part of the paper will present a detailed security analysis of the Universal Memory Allocator (UMA), the FreeBSD kernel's memory allocator. We will examine how UMA overflows can lead to arbitrary code execution in the context of the latest stable FreeBSD kernel (8. 0 -RELEASE), and we will develop an exploitation methodology for privilege escalation and kernel continuation...|$|E
40|$|With more {{embedded}} systems networked, {{it becomes an}} important research problem to effectively defend {{embedded systems}} against buffer overflow attacks and efficiently check if systems have been protected. In this paper, we propose the HSDefender (Hardware/Software Defender) technique that considers the protection and checking together to solve this problem. Our basic idea is to design a secure instruction set and require third-party software developers to use secure instructions to call functions. Then the security checking can be easily performed by system integrators even without {{the knowledge of the}} source code. We first classify buffer overflow attacks into two categories, <b>stack</b> <b>smashing</b> attacks and function pointer attacks, and then provide two corresponding defending strategies. We analyze the HSDefender technique in respect of hardware cost, security, and performance, and experiment with it on the SimpleScalar/ARM simulator using benchmarks from MiBench. The results show that HSDefender can defend a system against more types of buffer overflow attacks with less overhead compared with the previous work. ...|$|E
40|$|Abstract. We are {{developing}} a secure and certified e-mail system AnZen-Mail that provides an experimental testbed for our cutting-edge security enhancement technologies. In addition to a provably secure message transfer protocol, we have designed and implemented a server (MTU) and a client (MUA) in order that they could survive recent malicious attacks such as server-cracking and e-mail viruses. The AnZenMail server is implemented in Java, a memory-safe language, {{and so it is}} free from <b>stack</b> <b>smashing.</b> Some of its safety properties have been formally verified in Coq mostly at the source code level by manually translating Java methods into Coq functions. The AnZenMail client is designed to provide a support for secure execution of mobile code arriving as e-mail attachments. It has plug-in interfaces for code inspection and execution modules such as static analysis tools, runtime/inline reference monitors, and an anti-virus engine, which are currently being developed by members of our research project. ...|$|E
40|$|Abstract—Debugging {{wireless}} {{sensor network}} (WSN) applica-tions has been complicated for multiple reasons, among which the lack of visibility {{is one of the}} most challenging. To address this issue, in this paper, we present a systematic approach to record and replay WSN applications at the granularity of instructions. This approach differs from previous ones in that it is purely software based, therefore, no additional hardware component is needed. Our key idea is to combine the static, structural information of the assembly-level code with their dynamic, run-time traces as measured by timestamps and basic block counters, so that we can faithfully infer and replay the actual execution paths of applications at instruction level in a post-mortem manner. The evaluation results show that this approach is feasible despite of the resource constraints of sensor nodes. We also provide two case studies to demonstrate that our instruction level record-and-replay approach can be used to: (1) discover randomness of EEPROM writing time; (2) localize <b>stack</b> <b>smashing</b> bugs in sensor network applications. I...|$|E
40|$|This paper {{makes two}} {{contributions}} to architectural support for software debugging. First, it proposes a novel statistics-based, onthe -fly bug detection method called PC-based invariant detection. The idea {{is based on}} the observation that, in most programs, a given memory location is typically accessed by only a few instructions. Therefore, by capturing the invariant of the set of PCs that normally access a given variable, we can detect accesses by outlier instructions, which are often caused by memory corruption, buffer overflow, <b>stack</b> <b>smashing</b> or other memory-related bugs. Since this method is statistics-based, it can detect bugs that do not violate any programming rules and that, therefore, are likely to be missed by many existing tools. The second contribution is a novel architectural extension called the Check Look-aside Buffer (CLB). The CLB uses a Bloom filter to reduce monitoring overheads in the recentlyproposed iWatcher architectural framework for software debugging. The CLB significantly reduces the overhead of PC-based invariant debugging...|$|E
40|$|The use of {{insecure}} programming practices {{has led to}} a {{large number}} of vulnerable programs that can be exploited for malicious purposes. These vulnerabilities are often difficult to find during traditional software testing. In response to these difficulties, various program-based security mechanisms have been proposed to help protect potentially vulnerable programs. Testing these security mechanisms, however, also can be difficult and is currently rather adhoc. In this paper, we describe the design, implementation, and evaluation of an attack simulator that enables the systematic and semi-automatic testing and evaluation of the effectiveness of current and future security mechanisms by automatically providing numerous contexts for testing the reliability of the mechanisms. Capable of automatically creating attacks on running programs by dynamically adding code (but not modifying existing code), the attack simulator can run in different modes and simulate attacks at various program points systematically. Through a case study, we demonstrate how our tool can be used to test two wellknown security mechanisms for <b>stack</b> <b>smashing</b> attacks in several different testing modes. 1...|$|E
40|$|Buffer {{overflow}} {{attacks are}} the predominant {{threat to the}} secure operation of network and in particular, Internetbased applications. <b>Stack</b> <b>smashing</b> is a common mode of buffer overflow attack for hijacking system control. This paper evaluates two architecture-based techniques to defend systems against such attacks: (1) the split control and data stack, and (2) secure return address stack (SRAS). The split stack approach separates control and data stack to prevent the function return address from being overwritten. This approach can be implemented with compiler support or with architectural support by modifying the semantics of call and return instructions. The compiler implementation shows slight performance overhead (e. g., 2 % for ftp server), and the architectural support eliminates the overhead of the software solution. The SRAS is a hardware-based solution for detecting attacks. It uses the redundant copy of the return address maintained by the processor to validate return addresses and thereby detect malicious attacks. SRAS has been implemented in the SimpleScalar processor simulator. Simulation {{results show that the}} maximum overhead is 0. 02 % with a SRAS size of 64 entries for SPECINT 2000 benchmarks...|$|E
40|$|With {{the growing}} {{popularity}} of the Internet of Things (IoT), embedded devices continue to integrate more into our daily lives. For this reason, security for embedded devices is a vital issue to address. Attacks such as <b>stack</b> <b>smashing,</b> code injection, data corruption and Return Oriented Programming (ROP) are still a threat to embedded systems. As new methods are developed to defend embedded systems against such attacks, a benchmark to compare these methods is not present. In this work, a benchmark is presented that is aimed at testing the security of new techniques that defend against these common attacks. Two programs are developed that carry three key values needed for a benchmark: realistic embedded application, complex control flow, and being deterministic. The first application is a pin lock system and the second is a compression data logger. A complexity evaluation of the two applications revealed that the pin lock system contained 171 functions and 190 nodes with 252 edges in the control-flow graph, and the compression data logger contained 192 functions and 1, 357 nodes with 2, 123 edges in the control-flow graph. The current benchmark will be improved in the future by adding more applications with a wider range of complexity...|$|E
