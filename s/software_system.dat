10000|10000|Public
5|$|In compilers, {{straight}} line code (that is, sequences of statements without loops or conditional branches) may {{be represented by}} a DAG describing the inputs and outputs {{of each of the}} arithmetic operations performed within the code. This representation allows the compiler to perform common subexpression elimination efficiently. At a higher level of code organization, the acyclic dependencies principle states that the dependencies between modules or components of a large <b>software</b> <b>system</b> should form a directed acyclic graph.|$|E
5|$|Milius {{recruited}} his friend, Basil Poledouris, {{to produce}} the score for Conan; they had had a successful collaboration on Big Wednesday. The film industry's usual practice was to contract a composer to start work after the main scenes had been filmed, but Milius hired Poledouris before principal photography had started. The composer was {{given the opportunity to}} compose the film's music based on the initial storyboards and to modify it throughout filming before recording the score near the end of production. Poledouris made extensive use of Musync, a music and tempo editing hardware and <b>software</b> <b>system</b> invented by Robert Randles (subsequently nominated for an Oscar for Scientific Achievement), to modify the tempo of his compositions and synchronize them with the action in the film. The system helped make his job easier and faster; it could automatically adjust tempos when the user changed the positioning of beats. In the montage where Conan grows up, for example, Poledouris had Randles prepare, over the phone, a long accelerando that landed on precise moments in the picture along the way. Poledouris would otherwise have had to conduct the orchestra and adjust his compositions on the fly. Conan is the first film to list Musync in its credits.|$|E
5|$|Before any {{products}} are sold, the company pre-cooks the ingredients and holds {{them in a}} heated holding cabinet. To ensure that product consistency is maintained and {{to reduce the amount}} of products discarded as waste, Burger King utilizes a computerized monitoring system created by Integrated Control Corp, or ICC. The system, called Kitchen Minder, monitors time and temperature in the cabinets and notifies staff and managers when to prepare more food and discard older products. Initially developed from 1998 to 2000, the system is designed to work with a holding cabinet system that was developed by Duke. The initial test designs were time-consuming to program because each bay in the holding units had to be programmed manually. This meant several minutes were required for each product, which added up to several hours to program up to six units with eight bays each. When BK finally deployed the system in 2001, the updated units utilized a Palm Pilot to configure the units using a custom program designed to easily configure the units via Infrared or serial port. A kitchen flow <b>software</b> <b>system</b> that helps centralize information about the system was deployed in 2007; combined with the new equipment, it helped further reduce costs for the company and its franchises by calculating projected sales and actual usage. Along with the holding system, Burger King deployed newer high-speed toasters to decrease make times; the new toasters, while faster, require more maintenance, which increases overall labor costs.|$|E
40|$|In {{this paper}} we have {{provided}} a formal model for <b>software</b> <b>systems</b> speci cation and for the <b>software</b> <b>systems</b> composition operation. Using the notion of information system as a basis, we can model any information <b>system</b> using both <b>software</b> services and software interfaces. Doing this, we can develop a formal model for <b>software</b> <b>systems</b> composition. This formal model may be used both in formal speci cation of <b>software</b> <b>systems</b> (structure, functionality, requirements) and in <b>software</b> <b>systems</b> composition expressions...|$|R
5000|$|In May 1981, Informatics {{acquired}} Professional <b>Software</b> <b>Systems.</b> [...] In {{so doing}} the Professional <b>Software</b> <b>Systems</b> Division was created.|$|R
5000|$|Building Resource Adaptive <b>Software</b> <b>Systems</b> (BRASS): Creation of long-lived, survivable <b>software</b> <b>systems</b> that {{adapt to}} {{changing}} conditions on their own.|$|R
25|$|In 2010, GroupLens won {{the annual}} ACM <b>software</b> <b>system</b> award.|$|E
25|$|SAGE, {{the open}} source {{mathematics}} <b>software</b> <b>system,</b> contains a matroid package.|$|E
25|$|For compartmental determinsitc models, {{the best}} {{parameter}} values to fit experimental {{data can be}} estimated using algorithms developed by the COPASI <b>software</b> <b>system.</b> These tools are available witihin VCell.|$|E
50|$|September 2015: Pulse <b>Software</b> <b>Systems</b> {{acquisition}} - Pulse <b>Software</b> <b>Systems,</b> {{a leading}} provider of portfolio management software for private asset managers.|$|R
40|$|The {{subject of}} this thesis is the usage of various {{mathematical}} models to measure the reliability of <b>software</b> <b>systems.</b> <b>Software</b> Engineering is the science that encompasses the description, the constructionand the maintenance of <b>software</b> <b>systems.</b> <b>Software</b> <b>systems</b> are characterised by quality, automation, productivity and minimal production and maintenance costs. It {{is often the case}} that <b>software</b> <b>systems</b> require modifications in the code of their componentsΕθνικό Μετσόβιο Πολυτεχνείο [...] Μεταπτυχιακή Εργασία. Διεπιστημονικό-Διατμηματικό Πρόγραμμα Μεταπτυχιακών Σπουδών (Δ. Π. Μ. Σ.) “Μαθηματική Προτυποποίηση σε Σύγχρονες Τεχνολογίες στην Οικονομία...|$|R
40|$|Abstract. The need {{to develop}} secure <b>software</b> <b>systems</b> is well {{recognized}} by academics and industrialists alike. Current <b>software</b> <b>systems</b> contain sensitive information and therefore {{it is important that}} considerable efforts are made to secure such information. To improve the security of <b>software</b> <b>systems,</b> recent research has identified that security analysis should be integrated into software engineering techniques and security should be considered from {{the early stages of the}} <b>software</b> <b>systems</b> development process. Although, researchers have focused their efforts towards this direction, recent studies have identified that educational curriculum is not properly addressing this issue. In this experience paper we present the experiences and lessons learned from developing and running a module in Secure <b>Software</b> <b>Systems</b> Engineering at MSc Level...|$|R
25|$|Is there a {{standard}} methodology {{for determining the}} availability of a <b>software</b> <b>system?</b> Under a DoD effort, we are trying to define a methodology that is used to derive an availability number.|$|E
25|$|The Laos Ministry of Post and Telecommunications asked local {{technicians}} {{to develop}} a <b>software</b> <b>system</b> of international standard that would enable the Phetsarath OT font to be like other font systems that local users could access.|$|E
25|$|Luxembourg {{becomes the}} final banking {{location}} of VP Bank Group {{to integrate the}} Avaloq banking <b>software</b> <b>system.</b> As a result, the products and services of the entire VP Bank Group can be efficiently and easily harmonised and adapted to client needs.|$|E
40|$|Abstract. Describing the {{architecture}} of complex <b>software</b> <b>systems</b> need a comprehensive models and complete tools. The description of <b>software</b> <b>systems</b> {{can be achieved by}} using an architecture description language (ADL) or an object oriented modeling language. In this article, we show how we can build a hybrid model to describe {{the architecture}} of <b>software</b> <b>systems.</b> This model is based on the two approaches. First we define a metamodel for software architecture, next based on this metamodel we implement an environment for describing {{the architecture of}} <b>software</b> <b>systems...</b>|$|R
40|$|Software {{evolution}} and update {{play a vital}} role in software engineering. It has many advantages, such as improving the efficiency of programming, reducing the cost of maintenance and promoting the development of <b>software</b> <b>systems.</b> This paper further analyzes the {{evolution and}} update processes of three typical kinds of real-world object-oriented <b>software</b> <b>systems</b> by using the tools of complex networks. It discovers some underlying dynamical evolution characteristics and rules of the object-oriented <b>software</b> <b>systems.</b> These results are very useful for the design and development of the objectoriented <b>software</b> <b>systems...</b>|$|R
50|$|Major {{categories}} of <b>software</b> <b>systems</b> include those based on application software, programming <b>software</b> and <b>system</b> <b>software,</b> although the distinction {{can sometimes be}} difficult. Examples of <b>software</b> <b>systems</b> include operating systems, computer reservations systems, air traffic control systems, military command and control systems, telecommunication networks, content management systems, database management systems, expert systems, embedded systems etc.|$|R
25|$|Pinterest is a web {{and mobile}} {{application}} startup that operates a <b>software</b> <b>system</b> designed to discover {{information on the}} World Wide Web, mainly utilizing images and on a shorter scale, GIFs and videos. The site was founded by Ben Silbermann, Paul Sciarra and Evan Sharp.|$|E
25|$|In {{computer}} science, program optimization or software optimization is {{the process}} of modifying a <b>software</b> <b>system</b> to make some aspect of it work more efficiently or use fewer resources. In general, a computer program may be optimized so that it executes more rapidly, or is capable of operating with less memory storage or other resources, or draw less power.|$|E
25|$|The Unix {{system is}} {{composed}} of several components that were originally packaged together. By including the development environment, libraries, documents and the portable, modifiable source code {{for all of these}} components, in addition to the kernel of an operating system, Unix was a self-contained <b>software</b> <b>system.</b> This was one of the key reasons it emerged as an important teaching and learning tool and has had such a broad influence.|$|E
40|$|Our {{research}} aims {{to study}} and characterize the redundancy of <b>software</b> <b>systems.</b> Intuitively, a <b>software</b> is redundant when it can perform the same functionality in different ways. Researches have successfully defined several techniques that exploit various form of redundancy, for example for tolerating failures at runtime and for testing purposes. We aim to formalize and study the redundancy of <b>software</b> <b>systems</b> in general. In particular, {{we are interested in}} the intrinsic redundancy of <b>software</b> <b>systems,</b> that is a form of undocumented redundancy present in <b>software</b> <b>systems</b> as consequence of various design and implementation decisions. In this thesis we will formalize the intuitive notion of redun-dancy. On the basis of such formalization, we will investigate the pervasiveness and the fundamental characteristics of the intrinsic redundancy of <b>software</b> <b>systems.</b> We will study the nature, the origin, and various forms of such redundancy. We will also develop techniques to automatically identify the intrinsic redundancy of <b>software</b> <b>systems...</b>|$|R
40|$|For {{real-world}} {{software to}} remain satisfactory to its stakeholders requires its continual enhancement and adaptation. Acceptance of this phenomenon, termed software evolution, as intrinsic to real world software {{has led to}} an increasing interest in disciplined and systematic planning, management and improvement of the evolution process. Almost all of the previous work on software evolution has been concerned with the evolution of large scale real-world <b>software</b> <b>systems</b> developed within a single company using traditional management techniques, or with the large scale open source <b>software</b> <b>systems</b> (LSOSSS). However, there is to our knowledge little or no work that has considered small scale open source <b>software</b> <b>systems</b> (SSOSSS). This paper presents an analysis of the evolution behavior of two small size open source <b>software</b> <b>systems,</b> the Barcode Library and Zlib. Surprisingly, unlike large scale open source <b>software</b> <b>systems,</b> the evolution behavior of these small size open source <b>software</b> <b>systems</b> appears to follow Lehman's laws for software evolution...|$|R
50|$|<b>System</b> <b>software,</b> or <b>systems</b> <b>software,</b> is {{computer}} software {{designed to provide}} services to other <b>software.</b> Examples of <b>system</b> <b>software</b> include operating <b>systems,</b> computational science <b>software,</b> game engines, industrial automation, and {{software as a service}} applications.|$|R
25|$|Among PARC's {{distinguished}} {{researchers were}} three Turing Award winners: Butler W. Lampson (1992), Alan Kay (2003), and Charles P. Thacker (2009). The Association for Computing Machinery (ACM) <b>Software</b> <b>System</b> Award recognized the Alto system in 1984, Smalltalk in 1987, InterLisp in 1992, and the {{remote procedure call}} in 1994. Lampson, Kay, Bob Taylor, and Charles P. Thacker received the National Academy of Engineering's prestigious Charles Stark Draper Prize in 2004 for their work on the Alto.|$|E
25|$|The Free Software Foundation {{was founded}} in 1985 as a {{non-profit}} corporation supporting free software development. It continued existing GNU projects such as the sale of manuals and tapes, and employed developers of the free <b>software</b> <b>system.</b> Since then, it has continued these activities, as well as advocating for the free software movement. The FSF is also the steward of several free software licenses, meaning it publishes them and {{has the ability to}} make revisions as needed.|$|E
25|$|The example given above {{establishes}} a user story for a <b>software</b> <b>system</b> under development. This user story identifies a stakeholder, a business effect {{and a business}} value. It also describes several scenarios, each with a precondition, trigger and expected outcome. Each of these parts is exactly identified by the more formal part of the language (the term Given might be considered a keyword, for example) and may therefore be processed in some way by a tool that understands the formal parts of the ubiquitous language.|$|E
40|$|We {{present a}} {{multi-level}} formation model for complex <b>software</b> <b>systems.</b> The previous works extract the <b>software</b> <b>systems</b> to <b>software</b> networks for further studies, but usually investigate the software networks at the class level. In contrast to these works, our treatment of <b>software</b> <b>systems</b> as multi-level networks is more realistic. In particular, the software networks are organized by {{three levels of}} granularity, which represents the modularity and hierarchy in the formation process of real-world <b>software</b> <b>systems.</b> More importantly, simulations based on this model have generated more realistic structural properties of software networks, such as power-law, clustering and modularization. On {{the basis of this}} model, how the structure of <b>software</b> <b>systems</b> effects <b>software</b> design principles is then explored, and it could be helpful for understanding software evolution and software engineering practices...|$|R
40|$|Rich Services {{addresses}} {{the challenges of}} building and integrating distributed <b>software</b> <b>systems.</b> These include the need for managing multiple stake holder concerns, for integrating distributed <b>software</b> <b>systems</b> as a single entity into higher level distributed <b>software</b> <b>systems</b> behind interfaces, for adapting to changing requirements and for providing scalability. There {{is a need for}} software libraries that support the development of <b>software</b> <b>systems</b> designed using the Rich Services architecture. Rich Services/Erlang is the first software library that supports the creation of distributed <b>software</b> <b>systems</b> designed using the Rich Services architecture. Erlang is a functional programming language which explicitly supports the development of distributed, concurrent software. The library leverages the features of Erlang and the Rich Services architecture to empower developers to focus on the design and application logic of their <b>software</b> <b>systems,</b> rather than the implementation complexity of the integration and messaging system. We begin with an introduction of the challenges encountered in the creation of distributed <b>software</b> <b>systems</b> and with a discussion of the need for the Rich Services architecture. We continue with an overview of Erlang and then the introduction to Rich Services/Erlang. The following chapter includes a description of the process used to develop Rich Services <b>software</b> <b>systems</b> using the library. The final chapter about Rich Services/Erlang discusses the run-time view of systems implemented with it. The next few chapters present our enterprise integration patterns and chat system case studies. The thesis finishes with our evaluation and our conclusio...|$|R
40|$|Several {{characteristics}} distinguish today's complex <b>software</b> <b>systems</b> from "traditional" ones. Examples {{in different}} areas show that these characteristics, already the focus of agent-oriented software en-gineering research, influence many application domains. These char-acteristics will impact how <b>software</b> <b>systems</b> are modeled and engi-neered. We are {{on the edge of}} a revolutionary shift of paradigm, pio-neered by the multi-agent systems community, and likely to change our very attitudes in <b>software</b> <b>systems</b> modeling and engineering...|$|R
25|$|Layered graph drawing methods (often called Sugiyama-style drawing) {{are best}} suited for {{directed}} acyclic graphs or graphs that are nearly acyclic, such as the graphs of dependencies between modules or functions in a <b>software</b> <b>system.</b> In these methods, the nodes of the graph are arranged into horizontal layers using methods such as the Coffman–Graham algorithm, {{in such a way}} that most edges go downwards from one layer to the next; after this step, the nodes within each layer are arranged in order to minimize crossings.|$|E
25|$|In computing, a hyperlink, {{or simply}} a link, is a {{reference}} to data that the reader can directly follow either by clicking, tapping, or hovering. A hyperlink points to a whole document or to a specific element within a document. Hypertext is text with hyperlinks. The text that is linked from is called anchor text. A <b>software</b> <b>system</b> that is used for viewing and creating hypertext is a hypertext system, {{and to create a}} hyperlink is to hyperlink (or simply to link). A user following hyperlinks is said to navigate or browse the hypertext.|$|E
25|$|In the {{beginning}} of the 1990s there was a big interest in the mathematical approach to modeling and simulation of parallel processes. This approach may be applied to the analysis of correctness of parallel and distributed programs. The Distributed Computer Network (DCN) research group at Saint Petersburg Technical University developed such a <b>software</b> <b>system</b> for the analysis of program correctness; the new tool was named COVERS (Concurrent Verification and Simulation). This system allowed graphical modeling notation for system structure and behavior. The tool was applied for the research granted by Hewlett Packard.|$|E
50|$|In {{the paper}} Hierarchical Small Worlds in Software Architecture {{they argue that}} most large <b>software</b> <b>systems</b> are built in a modular and {{hierarchical}} fashion, and they use node graphs to analyze large <b>software</b> <b>systems.</b> In fact {{a large number of}} software analysis papers often use node graphs to analyze large <b>software</b> <b>systems</b> suggesting that node graphs are good models of the internal structure and operation of the software.|$|R
30|$|Feedback loops {{within and}} among the {{research}} community, system developers, users, and funding bodies govern the development of <b>software</b> <b>systems</b> that involve fire effects predictions. Recently, the interagency Joint Fire Sciences Program has reviewed fire-related <b>software</b> <b>systems.</b> The program is funding development of an IFT-DSS and further development in BlueSky as models of software platforms that support distributed collaboration among fire and fuel managers (Wells 2009). Sporadic funding by funding bodies of the process-based research models that will form the foundation of future fire effects <b>software</b> <b>systems</b> is of concern to researchers. Funding bodies {{are concerned that the}} research community has developed a profusion of <b>software</b> <b>systems,</b> while users are calling for one-stop-shopping. Given the several kinds of information needed by users, a handful of <b>software</b> <b>systems</b> will result (e.g., BlueSky, WFDSS, IFT-DSS). A commitment to steady funding support of research model development by the funding agencies, acknowledgement of the value in the separation of research and software development functions by researchers, and funding support for the coordinated development of fewer, yet more comprehensive <b>software</b> <b>systems</b> are all needed.|$|R
40|$|Abstract: The {{industry}} of software applications has been increased significantly {{because of the}} high demand of using the software applications. This revolution leads on developing many concurrent <b>software</b> <b>systems.</b> Noticeably, some of these concurrent <b>software</b> <b>systems</b> have falsely report data race condition to one or more of their shared variables. Debugging such concurrent <b>software</b> <b>systems</b> to find the race condition is a challenge, especially for large and complex <b>software</b> <b>systems.</b> Since the race condition concerned mostly ignored in the concurrent <b>software</b> <b>systems,</b> adopting it could help to ensure the efficiency of these <b>software</b> <b>systems.</b> There are few detector tools that have been known in the industry focusing on data race detectors. This paper aims to study those tools. We are going to conduct empirical study of data race using well known tools in order to measure the correctness, performances and effectiveness of those tools in practical by using some benchmarks. Those benchmarks will be tested on each tool and compare it with others to see the similarity and differentiate...|$|R
