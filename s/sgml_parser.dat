15|14|Public
50|$|In 1974, he {{designed}} SGML and subsequently {{wrote the first}} <b>SGML</b> <b>parser,</b> ARCSGML. Goldfarb went on working to turn SGML into the ISO 8879 standard, and served as its editor in the standardization committee.|$|E
50|$|The {{short-term}} {{agenda for}} tkWWW included an <b>SGML</b> <b>parser</b> and {{the separation of}} the browser from the editor, in order to simplify user experience.The long-term plan included new functions like word processing, directory navigation, file transfer, and news and email reading.|$|E
5000|$|A {{report on}} an early {{implementation}} of a parser for basic SGML, the Amsterdam <b>SGML</b> <b>Parser,</b> [...] notes [...] the DTD-grammar in SGML must conform to a notion of unambiguity which closely resembles the LL(1) conditions [...] and specifies various differences.|$|E
5000|$|Some {{applications}} (but not XML or <b>SGML</b> <b>parsers</b> themselves) {{also allow}} referencing notations indirectly by naming {{them in the}} [...] "URN:name" [...] value of a standard CDATA attribute, everywhere a URI can be specified. However this behaviour is application-specific, and requires that the application maintains a catalog of known URNs to resolve them into the notations that have been parsed in a standard <b>SGML</b> or XML <b>parser.</b> This use allows notations to be defined only in a DTD stored as an external entity and referenced only as the external subset of documents, and allows these documents to remain compatible with validating XML or <b>SGML</b> <b>parsers</b> that have no direct support for notations.|$|R
50|$|Notations {{are also}} {{completely}} opaque for XML and <b>SGML</b> <b>parsers,</b> {{so they are}} not differentiated {{by the type of}} the external entity that they may reference (for these parsers they just have a unique name associated to a public identifier (an FPI) and/or a system identifier (a URI)).|$|R
5000|$|... parsed {{external}} entities (most often defined with a SYSTEM identifier {{indicating the}} URI of their content) {{that are not}} associated in their definition to a named annotation, in which case validating XML or <b>SGML</b> <b>parsers</b> retrieve their contents and parse {{them as if they}} were declared as internal entities (the external entity containing their effective replacement text); ...|$|R
50|$|SP and Jade, the {{associated}} DSSSL processors, are {{maintained by the}} OpenJade project, and are common parts of Linux distributions. A general archive of SGML software and materials resides at SUNET. The original HTML parser class, in Sun System's implementation of Java, is a limited-features <b>SGML</b> <b>parser,</b> using SGML terminology and concepts.|$|E
5000|$|The charter for the {{recently}} revived World Wide Web Consortium HTML Working Group says, [...] "the Group will {{not assume that}} an <b>SGML</b> <b>parser</b> is used for 'classic HTML'". Although HTML syntax closely resembles SGML syntax with the default reference concrete syntax, HTML5 abandons any attempt to define HTML as an SGML application, explicitly defining its own parsing rules, which more closely match existing implementations and documents. It does, however, define an alternative XHTML serialization, which conforms to XML and therefore to SGML as well.|$|E
50|$|SGML generalizes and {{supports}} {{a wide range}} of markup languages as found in the mid 1980s. These ranged from terse Wiki-like syntaxes to RTF-like bracketed languages to HTML-like matching-tag languages. SGML did this by a relatively simple default reference concrete syntax augmented with a large number of optional features that could be enabled in the SGML Declaration. Not every <b>SGML</b> <b>parser</b> can necessarily process every SGML document. Because each processor's System Declaration can be compared to the document's SGML Declaration it is always possible to know whether a document is supported by a particular processor.|$|E
5000|$|An entity {{declaration}} {{may have a}} literal value, or may have some combination of an optional [...] identifier, which allows <b>SGML</b> <b>parsers</b> to process an entity's string referent as a resource identifier, and an optional [...] identifier, which identifies the entity independent of any particular representation. In XML, a subset of SGML, an {{entity declaration}} {{may not have a}} [...] identifier without a [...] identifier.|$|R
2500|$|One of {{the most}} {{noticeable}} differences between HTML and XHTML is the rule that all tags must be closed: empty HTML tags such as [...] must either be closed with a regular end-tag, or replaced by a special form: [...] (the space before the '/' on the end tag is optional, but frequently used because it enables some pre-XML Web browsers, and <b>SGML</b> <b>parsers,</b> to accept the tag). Another is that all attribute values in tags must be quoted. Finally, all tag and attribute names within the XHTML namespace must be lowercase to be valid. HTML, on the other hand, was case-insensitive.|$|R
5000|$|This {{declares}} the MIME type {{of external}} images with this type, and associates {{it with a}} notation name [...] "type-image-svg". However, notation names usually follow a naming convention that is specific to the application generating or using the notation: notations are interpreted as additional meta-data whose effective content is an external entity and either a PUBLIC FPI, registered in the catalogs used by XML or <b>SGML</b> <b>parsers,</b> or a SYSTEM URI, whose interpretation is application dependent (here a MIME type, interpreted as a relative URI, {{but it could be}} an absolute URI to a specific renderer, or a URN indicating an OS-specific object identifier such as a UUID).|$|R
5000|$|Within {{the body}} of the SGML document, these {{referenced}} external entities (whose name is specified between [...] "&" [...] and [...] ";") are not replaced like usual named entities (defined with a CDATA value), but are left as distinct unparsed tokens that may be used either as the value of an element attribute (like above) or within the element contents, provided that either the DTD allows such external entities in the declared content type of elements or in the declared type of attributes (here the ENTITY type for the data attribute), or the <b>SGML</b> <b>parser</b> is not validating the content.|$|E
50|$|The W3C XML (Extensible Markup Language) is {{a profile}} (subset) of SGML {{designed}} {{to ease the}} implementation of the parser compared to a full <b>SGML</b> <b>parser,</b> primarily for use on the World Wide Web. In addition to disabling many SGML options present in the reference syntax (such as omitting tags and nested subdocuments) XML adds a number of additional restrictions on the kinds of SGML syntax. For example, despite enabling SGML shortened tag forms, XML does not allow unclosed start or end tags. It also relied on many of the additions made by the WebSGML Annex. XML currently is more widely used than full SGML. XML has lightweight internationalization based on Unicode. Applications of XML include XHTML, XQuery, XSLT, XForms, XPointer, JSP, SVG, RSS, Atom, XML-RPC, RDF/XML, and SOAP.|$|E
40|$|The Standard Generalized Markup Language (SGML) is an ISO {{standard}} {{that provides a}} syntactic meta-language for the definition of textual markup systems, which are used to indicate the structure of documents {{so that they can}} be electronically typeset, searched, and communicated. We address only one problem raised by the standard, namely: In SGML, the right-hand sides of context-free productions are regular expressions, called content models, that are restricted to be what the standard calls "unambiguous, " but what is more appropriately called deterministic. We solve the problem of how to define determinism precisely, how to recognize deterministic regular expressions efficiently, and how to recognize deterministic regular languages. Any <b>SGML</b> <b>parser</b> must check that a given document grammar conforms to the standard; that is, it must validate it. Hence, our results are an important step in the clarification of the standard and in the efficient implementation of an <b>SGML</b> <b>parser</b> f [...] ...|$|E
40|$|Developing SGML {{applications}} involves {{making choices}} driven by end user requirements {{and by the}} availability and functionality of third party <b>SGML</b> <b>parsers,</b> authoring tools, search engines, browsers, and data converters. Capabilities of HTML and the World Wide Web should factor into these decisions as well if users are geographically dispersed or have diverse computing platforms. SGML application developers typically build {{some or all of}} the following components: a DTD; legacy data conversion tools; a DTD-tailored authoring environment; a document repository; browsing and searching interfaces; and tools for producing formatted output. For each component, we discuss design and implementation alternatives, the approach we decided to use in building our SGML environment for authoring and accessing STEP product data exchange standards, and our rationale for choosing that approach. Keywords : SGML; STEP; DTD; data conversion; authoring; search engine; formatting; Tcl; HTML Trade names an [...] ...|$|R
50|$|Note that {{attribute}} list declarations are ignored by non-validating <b>SGML</b> and XML <b>parsers</b> (in which cases any attribute is accepted within {{all elements of}} the parsed document), but these declarations are still checked for well-formedness and validity.|$|R
50|$|Note {{that element}} type {{declarations}} are ignored by non-validating <b>SGML</b> and XML <b>parsers</b> (in which cases, any elements are accepted in any order, {{and in any}} number of occurrences in the parsed document), but these declarations are still checked for form and validity.|$|R
40|$|The Standard Generalized Markup Language (SGML), is an ISO Standard that {{specifies}} {{a language}} for document representation. This paper gives a short introduction to SGML and describes the Amsterdam <b>SGML</b> <b>Parser</b> {{and the problems}} we encountered in implementing the Standard. These problems include interpretation of the Standard in the places where it is ambiguous and the technical problems in parsing SGML documents. KEY WORDS SGML Structured documents Document preparation Parser generator...|$|E
40|$|The Standard Generalized Markup Language (SGML) {{is used to}} {{represent}} documents in an application-independent manner. In a recent paper, Nordin et al. analyze concisely which properties of the SGML language are hindering its more widespread use and acceptance. In particular, they identify a number of features in the SGML standard that {{make it difficult to}} apply commonly used implementation tools and techniques to build an <b>SGML</b> <b>parser.</b> One feature, however, or rather one combination of two features, escapes their notice. Unambiguity and the & operator were both intended to make SGML document grammars easier to read by humans. It is questionable, though, whether this goal is really achieved. At least, the combination of unambiguity and the & operator raises unforeseen problems in validating the grammars and in parsing the documents by machines. I am describing these problems here in detail. On the basis of this analysis, the standards committees that are currently revising the standard ca [...] ...|$|E
40|$|This {{document}} {{describes the}} Normalised SGML Library (NSL), {{which consists of}} a set of C programs for manipulating SGML files and a C application program interface (API) designed to ease the writing of C programs which manipulate SGML documents. LRE Project 62 - 050 Multext Workpackage 2 Milestone C D NSL: SGML Tools 4 1 Introduction In pursuit of a development environment for SGML-based corpus and document processing, with support for multiple versions and multiple levels of annotation, LTG have developed an integrated set of SGML tools and a developers tool-kit, including a C-based API. This software described here contains everything required to process a very wide range of conformant SGML documents. Its initial parsing module incorporates v 0. 4 of James Clark's SP software, arguably the broadest coverage <b>SGML</b> <b>parser</b> available anywhere, commercial or not. The basic architecture is one in which an arbitrary SGML document is processed on the way in, as it were, yielding two results: [...] ...|$|E
40|$|SGML (Standard Generalized Markup Language) is well {{established}} in electronic publishing industry. The number of users {{and the number of}} applications grows everyday. If we look at the market the choice of available tools is very wide. We have tools for every purpose and for each price. However, from a technical point of view there are still some open areas for research and improvement. In this work we will address the parsing technology. Can we improve it? Or, is there another way to do it? Can we achieve better results? These are some of the questions that we will try to answer along this paper. <b>SGML</b> <b>parsers</b> are normally implemented using traditional technology: syntax directed translation. In the <b>SGML</b> context these <b>parsers</b> are good and offer a good performance. The problems emerge when we want to do something else besides structural validation. For example, to build an extension to perform semantic checking or to have on-line validation instead of batch validation. The focus of this paper will be a DTD (Document Type Definition) editor that generates specific editors for each specific type of document. To implement this editor we develop an AG (Attribute Grammar) for SGML syntax. But the most important part it is not this grammar. The editor has a built-in generator that at any moment translates the DTD being edited to a generic AG. In this paper we will discuss the methodology used to develop this DTD editor and we will make a detailed presentation of the conversion performed between DTDs and Attribute Grammars. At the end we will show a glimpse of the intended environment that along with this editor includes a style editor and a semantics editor. Graphic Communications Associatio...|$|R
50|$|XML allows parsers to {{separate}} the process of interpreting the document syntax and its structure. In HTML and <b>SGML,</b> a <b>parser</b> needed to know certain rules about elements during parsing, such as what elements could be contained within other elements and which elements implicitly close the previous element. This is because in HTML and SGML, closing tags and even opening tags were optional on some elements. By requiring all elements to have explicit opening and closing tags, XML parsers can parse the document and produce a document tree without any knowledge of the document type. This allows parsers to be universal and very light-weight, and {{to be separated from}} the process of validating or interpreting the document.|$|R
50|$|Note {{that any}} valid SGML or XML {{document}} that references an external subset in its DTD, or whose body contains references to parsed external entities declared in its DTD (including those declared within its internal subset), {{may only be}} partially parsed but cannot be fully validated by validating <b>SGML</b> or XML <b>parsers</b> in their standalone mode (this means that these validating parsers don't attempt to retrieve these external entities, and their replacement text is not accessible).|$|R
40|$|The best {{database}} {{engine for}} a SGML (Standard Generalized Markup Language) document database {{was to be}} found. Three DBMSs were tested, one relational, one object-relational hybrid and one object-oriented. By using a <b>SGML</b> <b>parser</b> to split up the documents in its SGML components and storing each of these in the database, with version control and digital signatures, a far more advanced document handling would be possible implement. This would render guaranteed consistency and possibilities of reusing components for several different output formats and in different documents. Database models were created fully extended to store necessary data. A test application for each database was implemented for import and export of SGML documents and performance was measured. One of the applications was then extended to implement a user-interface for users unfamiliar with SGML vocabulary. The relational database {{was found to be}} improper for SGML data, due to poor performance. The hybrid and the pure [...] ...|$|E
40|$|OBJECTIVE: To {{report on}} the use of SGML and XML (a proper subset of SGML) as {{transfer}} syntaxes for HL 7 Version 2. 3 and Version 3. 0 messages. METHODS: The methodology has focused largely on two questions: Can it be done? How best to do it? The first question is addressed by attempting to build an SGML/XML representation of HL 7 messages. The second question requires a consideration of several metrics: message length, speed of message creation and parsing, interversion compatibility, local customization, conformance determination, and the availability of software tools and skill on the format. RESULTS: Detailed specifications for expressing HL 7 in SGML and XML have been developed. Some HL 7 requirements are not readily expressed, while some ambiguous areas of the HL 7 standard are made explicit in the SGML/XML representation. With the current design, an SGML/XML parser can extract any component of any data type from a message. CONCLUSIONS: SGML and XML can both serve as implementable message specifications for HL 7 Version 2. 3 and Version 3. 0 messages. The ability to explicitly represent an HL 7 requirement in SGML/XML confers the ability to validate that requirement with an <b>SGML</b> <b>parser.</b> The optimal message representation will be a balance of functional, technical, and practical requirements...|$|E
40|$|This {{contribution}} describes INES (Integrated Standard Editor {{based on}} SGML), an advanced context sensitive SGML editor {{based on the}} publishing system Interleaf 5. This editor was developed at ZGDV to support working with the DTD of the German Institute of Standards (DIN) to write standard documents. The goal of the development was a complete SGML editor combining the advantages of WYSIWYG with the advantages of structured SGML editing. The editor should guarantee the DTD conformance of the document. Interleaf 5, which offers an object-oriented LISP programming interface, was improved by the following SGML features: (1) SGML kernel to manage the data of the DTD and its instances, (2) context sensitive editor (CSE) as a shell around this kernel which builds the connection to the user interface and the layout components, (3) interactive attribute editor to handle the SGML attributes and to control the layout, (4) online help for elements and attributes, and (5) layout editor to define the context-dependent layout. INES was developed without using the Interleaf product Interleaf Developers Toolkit. The CSE supervises {{the actions of the}} user constantly to guarantee that the document is in accordance with the DTD at any time, i. e. no postprocessing with an <b>SGML</b> <b>parser</b> is necessary. The editor realizes this with context-dependent menus for the creation of elements and entities, with controlled keyboard input, and with a special handling of cut, copy and paste. The CSE guarantees also that all required elements and attributes exist in the document. It is possible to load arbitrary DTDs into INES...|$|E
50|$|However, such {{documents}} are still fully parsable in the non-standalone mode of validating parsers, which signals an error if it can't locate these external entities with their specified public identifier (FPI) or system identifier (a URI), or are inaccessible. (Notations declared in the DTD are also referencing external entities, but these unparsed entities are not {{needed for the}} validation of documents in the standalone mode of these parsers: the validation of all external entities referenced by notations is left to the application using the <b>SGML</b> or XML <b>parser).</b> Non-validating parsers may eventually attempt to locate these external entities in the non-standalone mode (by partially interpreting the DTD only to resolve their declared parsable entities), but do not validate the content model of these documents.|$|R

