1|39|Public
40|$|We have {{reported}} previously that {{the addition of}} dexamethasone to cultured quiescent suckling rat hepatocytes {{in the presence of}} insulin, a culture condition which does not cause growth activation, induces a selective increase in the synthesis of the 49 -kD/ 55 -kD cytokeratin (CK 49 /CK 55) pair over a 24 -h period. This increased synthesis coincides with the formation of dense filament networks reminiscent of those observed in situ at the cell periphery (Marceau, N., H. Baribault, and I. Leroux-Nicollet. 1985. Can. J. Biochem. Cell Biol. 63 : 448 - 457). We show {{here for the first time}} that when EGF is added 48 h after insulin and dexamethasone, there is an early preferential phosphorylation of the CK 55 of the CK 49 /CK 55 pair, an induced filament rearrangement from the cell periphery to the cytoplasm, and a subsequent entry into S phase and mitosis after a lag period of 8 h. Indirect immunofluorescence microscopy with monoclonal antibodies to CK 49 and CK 55 indicate that, while before EGF treatment the cytokeratin filaments were mainly distributed near the cell periphery, the addition of EGF resulted in their reorganization to a predominantly cytoplasmic localization within less than 3 h. Antitubulin and anti-actin antibodies showed no detectable alteration in the distribution of microtubules and microfilaments. Pulse-chase measurements with [35 S]methionine showed no apparent change in the turnover of either CK 49 or CK 55 during the period that precedes the initiation of DNA synthesis. 32 P-labeling in vivo followed by SDS-PAGE demonstrated that CK 55 was phosphorylated at a much higher level than CK 49 in nonstimulated hepatocytes, and that the addition of EGF resulted in a selective stimulation of 32 P-CK 55 labeling within less than 30 min. Comparative analyses by two-dimensional PAGE of [35 S]methionine and 32 P- labeled cytokeratins at various times after EGF stimulation demonstrated a rapid increase in a first phosphorylated form of CK 55 and the appearance of a second phosphorylated form at 30 min poststimulation. The changes in the relative proportion of nonphosphorylated and phosphorylated forms were confirmed by immunoblotting with the anti-CK 55 monoclonal antibody. Determinations of the 32 P-labeled phosphoamino acids of CK 55 extracted from the gels demonstrated that the radioactivity was mostly in serine residues. Labeling of Triton-permeabilized hepatocytes with gamma 32 P-ATP after treatment with EGF for 30 min to 3 h at 37 degrees C, also demonstrated a phosphorylation of CK 55 and CK 49 as well, implying that the EGF- responsive serine protein kinase is detergent insoluble and probably part of the surface membrane <b>skeleton.</b> (<b>ABSTRACT</b> TRUNCATED AT 400 WORDS...|$|E
40|$|To manage load {{on large}} and dynamic {{networks}} {{we have developed}} Autonomous Mobile Programs (AMPs) that periodically use a cost model to decide where to execute. A disadvantage of directly programming AMPs is that the cost model, mobility decision function, and network interrogation are all explicit in the program. This paper proposes autonomous mobility skeletons (AMS) that encapsulate selfaware mobile coordination for common patterns of computation over collections. Autonomous mobility skeletons are akin to algorithmic skeletons in being polymorphic higher order functions, but where algorithmic <b>skeletons</b> <b>abstract</b> over parallel coordination, autonomous mobility <b>skeletons</b> <b>abstract</b> over autonomous mobile coordination. We present the automap, autofold and autoiter autonomous mobility skeletons, together with performance measurements of Jocaml, Java Voyager, and JavaGo implementations on small networks. autoiter is an unusual <b>skeleton,</b> <b>abstracting</b> over the Iterator interface commonly used with Java collections...|$|R
40|$|Developments in {{distributed}} system technology facilitate {{the sharing of}} computational resources, even at a global level. To share resource in open {{distributed system}}s we have developed autonomous mobile programs, which are aware of their resource needs and sensitive to {{the environment in which}} they execute. Autonomous mobile programs periodically use a cost model to decide where to execute in a network. Unusually this form of autonomous mobility affects only where the program executes and not what it does. In an autonomous mobile program, the program must contain explicitly control of self-aware mobile coordination. To encapsulate self-aware mobile coordination for common patterns of computation over collections, autonomous mobility skeletons are built. Autonomous mobility skeletons are akin to algorithmic skeletons in being polymorphic higher-order functions, but where algorithmic <b>skeletons</b> <b>abstract</b> over parallel coordination, autonomous mobility <b>skeletons</b> <b>abstract</b> over autonomous mobile coordination...|$|R
40|$|We present {{behavioural}} skeletons for the CoreGrid Component Model, {{which are}} an abstraction aimed at simplifying {{the development of}} GCM-based self-management applications. Behavioural <b>skeletons</b> <b>abstract</b> component self-man-agent in component-based design as design patterns abstract class design in classic OO development. As here {{we just want to}} introduce the behavioural skeleton framework, emphasis is placed on general skeleton structure rather than on their autonomic management policies...|$|R
50|$|The Structured Coordination Language (SCL) {{was one of}} the {{earliest}} skeleton programming languages. It provides a co-ordination language approach for skeleton programming over software components. SCL is considered a base language, and was designed to be integrated with a host language, for example Fortran or C, used for developing sequential software components. In SCL, skeletons are classified into three types: configuration, elementary and computation. Configuration <b>skeletons</b> <b>abstract</b> patterns for commonly used data structures such as distributed arrays (ParArray). Elementary skeletons correspond to data parallel skeletons such as map, scan, and fold. Computation <b>skeletons</b> which <b>abstract</b> the control flow and correspond mainly to task parallel skeletons such as farm, SPMD, and iterateUntil. The coordination language approach was used in conjunction with performance models for programming traditional parallel machines as well as parallel heterogeneous machines that have different multiple cores on each processing node.|$|R
40|$|Algorithmic <b>skeletons</b> <b>abstract</b> commonly-used {{patterns}} of parallel computation, communication, and interaction. They provide top-down design composition and control inheritance {{throughout the whole}} structure. Parallel programs are expressed by interweaving parameterised skeletons analogously to the way sequential structured programs are constructed. This design paradigm, known as structured parallelism, provides a high-level parallel programming method which allows the abstract description of programs and fosters portability. That is to say, structured parallelism requires {{the description of the}} algorithm rather than its implementation, providing a clear and consistent meaning across platforms while their associated structure depends on the particular implementation. By decoupling the structure from the meaning of a parallel program, it benefits entirely from any performance improvements in the systems infrastructure...|$|R
40|$|Program Shaping is {{the process}} of {{transforming}} a sequential program in order to better enable the introduction of parallelism. While algorithmic <b>skeletons</b> <b>abstract</b> away the low-level aspects of parallel programming that often plague traditional techniques, skeletons cannot always be readily introduced to sequential code. Data may not always be in a compatible format, function design may not be conducive to a single point of invocation, or there may be dependencies between functions and data obstructive to the introduction of parallelism. Program Shaping can be used to transform such code, producing a form to which skeletons can be introduced. We present a series of generic Program Shaping rewrite rules, and their implementation as refactorings, and demonstrate their application to an Erlang Multi-Agent System (MAS) ...|$|R
40|$|A {{scheme for}} {{arbitrary}} nesting of algorithmic skeletons is explained {{which is based}} on the idea of groups in MPI. Two skeletons were developed which run in a nested mode: a binary divide and conquer and a process farm for a parallel implementation of fold and map HOFs respectively. An Example showing various cases for nesting the two skeletons is presented. The experiment was conducted on the Fujitsu AP 1000 parallel machine. 1 Introduction It is well known that parallelism adds an additional level of difficulty to software development. Following Cole's characterisation[1], algorithmic skeletons have been recognised widely as a valuable basis for parallel software construction. A <b>skeleton</b> <b>abstracts</b> a control structure which may be instantiated subsequently with specific functions to carry out specific tasks. Therefore, the encapsulation of parallel algorithms into skeletons is a promising approach to high-level specification of parallel algorithms. Normally, functional programming la [...] ...|$|R
40|$|Communications {{libraries}} like MPI enable architecture independent {{parallel program}} development but cannot alone guarantee performance consistency across different architectures. Here an algorithmic skeleton for a process farm is discussed and an architecture independent performance model is developed for it. The skeleton has been ported from a Meiko Computing Surface to a Cray T 3 D and a Fujitsu AP 1000, demonstrating consistent behaviour. Preliminary performance prediction accuracy on the Cray T 3 D is around 90 %, {{on a test}} application based on arbitrary length arithmetic. (The performance model is currently being instantiated for the other systems. This will be reported in the final paper.) 1 Introduction It {{is well known that}} parallelism adds an additional level of difficulty to software development. Following Cole's characterisation[3], algorithmic skeletons have been recognised widely as a valuable basis for parallel software construction. A <b>skeleton</b> <b>abstracts</b> a control structure whi [...] ...|$|R
40|$|Trees are {{important}} datatypes {{that are often}} used in representing structured data such as XML. Though trees are widely used in sequential programming, {{it is hard to}} write efficient parallel programs manipulating trees, because of their irregular and ill-balanced structures. In this paper, we propose a solution based on the skeletal approach. We formalize a set of <b>skeletons</b> (<b>abstracted</b> computational patterns) for rose trees (general trees of arbitrary shapes) based on the theory of Constructive Algorithmics. Our skeletons for rose trees are extensions of those proposed for lists and binary trees. We show that we can implement the skeletons efficiently in parallel, by combining the parallel binary-tree skeletons for which efficient parallel implementations are already known. As far as we are aware, we are the first who have formalized and implemented a set of simple but expressive parallel skeletons for rose trees. Ó 2006 Elsevier B. V. All rights reserved...|$|R
40|$|Abstract. Resource {{security}} {{pertains to}} the prevention of unauthorized usage of system resources that may not directly cause corruption or leakage of information. A common breach of resource security is the class of attacks called DoS (Denial of Service) attacks. This paper proposes an architecture called TINMAN whose goal is to efficiently and effectively safeguard resource security for mobile source code written in C. We couple resource usage checks at the programming language level and at the run-time system level. This is achieved by the generation of a resource skeleton from source code. This resource <b>skeleton</b> <b>abstracts</b> the resource consumption behavior of the program which is validated {{by means of a}} resource usage certificate that is derived from proof generation. TIN-MAN uses resource-usage checking tools to generate proof obligations required of the resource usage certificate and provides full coverage by monitoringany essential property not guaranteed by the certificates. We shall describe the architecture of TINMAN and give some experimental results of the preliminary TINMAN implementation. ...|$|R
40|$|Algorithmic <b>skeletons</b> <b>abstract</b> {{commonly}} used patterns of parallel computation, communication, and interaction. Based on the algorithmic skeleton concept, structured parallelism provides a high-level parallel programming technique {{that allows the}} conceptual description of parallel programs while fostering platform independence and algorithm abstraction. This work presents a methodology to improve skeletal parallel programming in heterogeneous distributed systems by introducing adaptivity through resource awareness. As we hypothesise that a skeletal program {{should be able to}} adapt to the dynamic resource conditions over time using its structural forecasting information, we have developed adaptive structured parallelism (ASPARA). ASPARA is a generic methodology to incorporate structural information at compilation into a parallel program, which will help it to adapt at execution. ASPARA comprises four phases: programming, compilation, calibration, and execution. We illustrate the feasibility of this approach and its associated performance improvements using independent case studies based on two algorithmic skeletons—the task farm and the pipeline—evaluated in a non-dedicated heterogeneous multi-cluster system...|$|R
40|$|Algorithmic <b>skeletons</b> <b>abstract</b> {{commonly}} used patterns of parallel computation, communication, and interaction. By demonstrating a predictable communication and computation structure, {{they provide a}} foundation for performance modelling and estimation. Grids pose a challenge to known distributed systems techniques {{as a result of}} their dynamism. One of the most prominent research areas concerns the availability of proved programming paradigms with special emphasis on the performance side. Thus, adaptable performance improvement techniques have been the subject of intense scrutiny. Scant research has been conducted on using the skeletal predicting information to enhance performance in heterogeneous environments. We propose the use of these predicting properties to adaptively enhance the performance of skeletons, in particular of a task farm, within a computational grid. Hence, the problem addressed in this paper is: given a skeletal task farm, find an effective way to improve its performance on a heterogeneous distributed environment by incorporating information at compile time that helps it to adapt at execution time. This work provides a grid-enabled, adaptive task farm model, using the NWS statistical predictions on bandwidth, latency and processor availability. The central case study implements an ad-hoc task farm based on C/MPI and employs PACX-MPI for inter-node communication. We present initial promising results of parallel executions of an artificially-generated numerical code in a grid...|$|R
40|$|This paper {{considers}} {{how to use}} program {{shaping and}} algorithmic skeletons to parallelise a multi-agent system that is written in Erlang. Program shaping {{is the process of}} transforming a program to better enable the introduction of parallelism. Whilst algorithmic <b>skeletons</b> <b>abstract</b> away the low-level aspects of parallel programming that often plague traditional techniques, it is not always easy to introduce them into an arbitrary program, especially one that has not been written with parallelism in mind. Amongst other issues, data may not always be in a compatible format, function calls may need to be replicated to support alternative uses, side-effects may need to be isolated, or there may be dependencies between functions and data that obstruct the introduction of parallelism. Program shaping can be used to transform such code to a form that allows skeletons to be more easily introduced. In this paper, we present a series of generic program shaping rewrite rules, provide their implementation as refactorings, and show how they can be used to parallelise an Evolutionary Multi-Agent System (MAS) written in Erlang. We show that we can significantly speed up this application, obtaining super-linear speedups of over 70 times the original sequential performance on a 64 -core shared-memory machine...|$|R
50|$|In mathematics, the Perkel graph, {{named after}} Manley Perkel, is a 6-regular graph with 57 {{vertices}} and 171 edges. It is the unique distance-regular graph with intersection array (6, 5, 2; 1, 1, 3). The Perkel graph is also distance-transitive. It {{is also the}} <b>skeleton</b> of an <b>abstract</b> regular polytope, the 57-cell.|$|R
40|$|<b>Abstract.</b> <b>Skeletons</b> model partial {{information}} about regular (honest) behavior in an {{execution of a}} cryptographic protocol. A homomorphism between skeletons is an information-preserving map. Much protocol analysis may be regarded as {{an exploration of the}} properties of the category of skeletons and homomorphisms. In particular, the strand space authentication tests are special homomorphisms. These ideas suggest an approach to mechanizing protocol analysis. ...|$|R
40|$|Efficient {{programming}} {{of general}} purpose many-core accelerators poses several challenging problems. The {{high number of}} cores available, the peculiarity of the interconnection network, and the complex memory hierarchy organization, all contribute to make efficient programming of such devices difficult. We propose to use parallel design patterns, implemented using algorithmic <b>skeletons,</b> to <b>abstract</b> and hide most of the difficulties related to the efficient programming of many-core accelerators. In particular, we discuss the porting of the FastFlow framework on the Tilera TilePro 64 architecture and the results obtained running synthetic benchmarks as well as true application kernels. These results demonstrate the efficiency achieved while using patterns on the TilePro 64 both to program stand-alone skeleton-based parallel applications and to accelerate existing sequential code...|$|R
40|$|<b>Abstract.</b> <b>Skeleton</b> driven {{animation}} is {{a popular}} method for the animation of deformable human and creature characters. The main advantage is its computational performance. However it suffers {{from a number of}} problems, such as collapsing elbow and candy wrapper joint. In this paper, we present a new method which is able to solve these defects; reduce the animator’s manual work still allowing his/her full control over the process; and realistically simulate the fat bulge effect around a joint. ...|$|R
40|$|<b>Abstract.</b> <b>Skeleton</b> is a shape {{descriptor}} which {{summarizes the}} general form of objects. It {{can be expressed}} in terms of the fundamental morphological operations. The limitation of that characterization is that its construction based on digital disks such that cannot provide good approximation to the Euclidean disks. In this paper we define a new type of skeleton based on neighborhood sequences that is much closer to the Euclidean skeleton. A novel method for quantitative comparison of skeletonization algorithms is also proposed...|$|R
40|$|In this paper, {{we propose}} a {{straightforward}} {{solution to the}} problems of compositional parallel programming by using skeletons as the uniform mechanism for structured composition. In our approach parallel programs are constructed by composing procedures in a conventional base language using a set of high-level, predefined, functional, parallel computational forms known as skeletons. The ability to compose skeletons provides us with the essential tools for building further and more complex application-oriented skeletons specifying important aspects of parallel computation. Compared with the process network based composition approach, such as PCN, the <b>skeleton</b> approach <b>abstracts</b> away the fine details of connecting communication ports to the higher level mechanism of making data distributions conform, thus avoiding the complexity of using lower level ports as the means of interaction. Thus, the framework provides a natural integration of the compositional programming approach with the dat [...] ...|$|R
40|$|The {{skeleton}} {{approach to}} programming parallel machines promises {{to offer a}} high-level of abstraction to the programmer, whilst providing the implementation with sufficient information to effectively manage the resources available. Each skeleton captures a common pattern of computation and has associated with it parallel implementations. Functional programming languages are a suitable framework for exploring this approach as skeletons can be elegantly represented as higher-order functions. Applications are naturally expressed as combinations of several skeletons. This thesis explores the problem of optimising combinations of skeletons, where each skeleton may {{have more than one}} underlying parallel implementation. A skeleton approach suitable for expressing programs as combinations of skeletons is presented. The primitive skeletons of this approach are operators of parallel <b>abstract</b> data types. <b>Skeletons</b> are combined together using a set of combining <b>skeletons</b> which <b>abstract</b> patterns of [...] ...|$|R
40|$|This is {{an initial}} case on {{exploring}} {{the application of}} algorithmic <b>skeletons</b> to <b>abstract</b> low-level interprocess communication in MPI. The main purpose is intended to illustrate the competitive performance demonstrated by the skeletal approach when compared to utilization of the pure MPI, whilst providing an abstraction with reusability advantages. This initial work involves {{the implementation of the}} Wagar’s hyperquicksort algorithm in conjunction with the MPI-based eSkel skeleton library. The reported results compare three MPI-based implementations of hyperquicksort. Firstly a canonic MPI one; secondly, two implementations using the MPI-based skeletal library eSkel. Lastly, the S 3 L_sort routine, part of its optimized numerical libraries from Sun, is employed as baseline. This overall comparison demonstrates that the use of algorithmic skeletons caused a slight performance degradation, while providing some promising guidance on the use of abstraction for low-level communication operations using the eSkel model...|$|R
40|$|We {{present the}} dynamic {{composite}} adapter design pattern to achieve modular, dynamic, non-invasive component adaptation. The pattern allows a clean separation between an abstract framework component and a concrete application component, while supporting the dynamic "gluing" of the two. This allows the different system concerns to be carved into separate components, which may then be dynamically composed. We also present a scoping construct for succinctly defining the dynamic gluing of Java components. A collaboration {{can be implemented}} as a white-box framework, i. e. a set of abstract classes, a set of abstract primitive operations, {{and a set of}} concrete template methods that define the collaboration <b>skeleton.</b> The <b>abstract</b> framework model is easily customized by an application through static subclassing. However, this solution is invasive in that it requires modification of the application classes. It is also not modular, as the framework deployment is scattered among the appli [...] ...|$|R
40|$|Module Cm: A Concrete Module Instantiation of Concrete Modules as {{collection}} of processes Step 3 Step 2 : Add Application Code Step 3 : Instantiate FIGURE X. 1. Relationships between a parallel architectural <b>skeleton,</b> an <b>abstract</b> module and a module a skeleton by specifying the parameters {{associated with the}} attributes, as needed by the application at hand. Figure X. 1 approximately illustrates the various phases of application development using parallel architectural skeletons. As shown in the figure, di#erent extensions of the same skeleton can result in somewhat di#erent abstract parallel computing modules (abbreviated as an abstract module). An abstract module {{is yet to be}} filled in with application code. Once an abstract module is supplied with application code, it results in a concrete parallel computing module (abbreviated as a concrete module or simply a module). A parallel application is a systematic {{collection of}} mutually interacting, instantiated modules...|$|R
40|$|Algorithmic <b>skeletons</b> (`skeletons') <b>abstract</b> commonly-used {{patterns}} of parallel computation, communication, and interaction. They provide top-down design composition and control inheritance {{throughout the whole}} structure. The efficient execution of skeletal applications on a heterogeneous environment has long been {{of interest to the}} research community. Arguably, executing a coarse-grained resource-intensive skeletal workloads ought to achieve higher resource utilisation and, ultimately, better job makespan on heterogeneous systems due to the structured parallelism model. This paper presents a heterogeneous OpenCL-based GPU back-end for FastFlow, a widely-used skeletal framework. Our back-end allows the user to easily write any arbitrary OpenCL code inside an heterogeneous algorithmic skeleton and seamlessly control the allocation of OpenCL kernel over the hybrid (CPU/GPU) architecture. Our performance evaluation indicate that a skeletal program which employs our back-end is around one order of magnitude faster than a skeletal parallel program using the traditional homogeneous FastFlow skeletons with the serial version of OpenCL code...|$|R
40|$|A new {{category}} of algebro-geometric objects is defined. This construction {{is a vast}} generalization of existing F 1 -theories, as it contains the the theory of monoid schemes {{on the one hand}} and classical algebraic theory, e. g. Grothendieck schemes, on the the other. It also gives a handy description of Berkovich subdomains and thus contains Berkovich's approach to <b>abstract</b> <b>skeletons.</b> Further it complements the theory of monoid schemes in view of number theoretic applications as congruence schemes encode number theoretical information as opposed to combinatorial data which are seen by monoid schemes...|$|R
40|$|<b>Abstract.</b> <b>Skeletons</b> {{are common}} {{patterns}} of parallelism like, e. g., farm, pipeline {{that can be}} abstracted and offered to the application programmer as programming primitives. We describe the use and implementation of skeletons in a distributed grid environment, with the Java-based system Lithium as our reference implementation. Our main contribution are optimization techniques based on an asynchronous, optimized RMI interaction mechanism, which we integrated into the macro data flow (MDF) implementation technology of Lithium. We report initial experimental results that demonstrate the achieved improvements through the proposed optimizations on a simple grid testbed. ...|$|R
40|$|Skeletons are {{well-known}} {{representations that}} accommodate shape abstraction and qualitative shape matching. However, skeletons are sometimes unstable to compute and sensitive to shape detail, thus making shape abstraction and matching difficult. To address these problems, we propose a principled framework that generates a simplified, <b>abstracted</b> <b>skeleton</b> hierarchy {{by analyzing the}} quasi-stable points of a Bayesian-inspired energy function. The resulting model is parameterized by both boundary and internal structure variations corresponding to object scale and abstraction dimensions, and trades-off reconstruction accuracy and representation parsimony. Our experimental {{results show that the}} method can produce useful multi-scale skeleton representations at a variety of abstraction levels. ...|$|R
40|$|<b>Abstract.</b> <b>Skeleton</b> can {{be viewed}} as a compact shape {{representation}} in that the shape can be completely reconstructed form the skeleton. We present a novel method for skeleton pruning that is based on this fundamental skeleton property. We iteratively remove skeleton end braches with smallest relevance for shape reconstruction. The relevance of branches is measured as their contribution to shape reconstruction. The proposed pruning method allows us to overcome the instability of skeleton representation: a small boundary deformation leads to large changes in skeleton topology. Consequently, we are able to obtain very stable skeleton representation of planar shapes...|$|R
40|$|Recently, the {{technological}} development of manipulator robot increases {{very quickly and}} provides a positive impact to human life. The implementation of the manipulator robot technology offers more efficiency and high performance for several human’s tasks. In reality, efforts published in this context are focused on implementing control algorithms with already preprogrammed desired trajectories (passive robots case) or trajectory generation based on feedback sensors (active robots case). However, gesture based control robot {{can be considered as}} another channel of system control which is not widely discussed. This paper focuses on a Kinect-based real-time interactive control system implementation. Based on LabVIEW integrated development environment (IDE), a developed human-machine-interface (HMI) allows user to control in real time a Lynxmotion robotic arm. The Kinect software development kit (SDK) provides a tool to keep track of human body <b>skeleton</b> and <b>abstract</b> it into 3 -dimensional coordinates. Therefore, the Kinect sensor is integrated into our control system to detect the different user joints coordinates. The Lynxmotion dynamic has been implemented in a real-time sliding mode control algorithm. The experimental results are carried out to test the effectiveness of the system, and the results verify the tracking ability, stability, and robustness...|$|R
40|$|<b>Abstract.</b> <b>Skeletons</b> are {{important}} shape descriptors in object representation and recognition. Typically, skeletons of volumetric models are computed via an iterative thinning process. However, traditional thinning methods often generate skeletons with complex structures that are unsuitable for shape description, and appropriate pruning methods are lacking. In this paper, {{we present a}} new method for computing skeletons on volumes by alternating thinning and a novel skeleton pruning routine. Our method creates a family of skeletons parameterized by two user-specified numbers that determine respectively the size of curve and surface features on the skeleton. As demonstrated on both real-world models and medical images, our method generates skeletons with simple and meaningful structures that are particularly suitable for describing cylindrical and plate-like shapes. ...|$|R
40|$|Developments in {{distributed}} system technology facilitate {{the sharing of}} resources, even at a global level. This thesis explores sharing computational resources using mobile computations, agents, and autonomic techniques. We propose autonomous mobile programs (AMPs) which are aware of their resource needs and sensitive to {{the environment in which}} they execute. AMPs periodically use a cost model to decide where to execute in a network. Unusually this form of autonomous mobility affects only where the program executes and not what it does. We present a generic AMP cost modei, together with a validated instantiation and comparative performance results for four AMPs. We demonstrate that AMPs are able to dynamically relocate themselves to minimise execution time in the presence of varying network resources. Collections of AMPs effectively perform decentralised dynamic load balancing. Experiments on small LANs show that collections of AMPs quickly obtain and maintain optimal or near-optimal ball 1 nce. The advantages of our decentralised approach are that {{it has the potential to}} scale to very large and dynamic networks, and to achieve improved balance, and offers guarantees to limit overheads under reasonable assumptions. In an autonomous mobile program, the program must contain explicit control of self-aware mobile coordination. To encapsulate this for common patterns of computation over collections, autonomous mobility skeletons (AMSs) are proposed. These are akin to algorithmic skeletons in being polymorphic higher order functions, but where algorithmic <b>skeletons</b> <b>abstract</b> over parallel coordination, AMSs abstract over autonomous mobile coordination. AMS cost models have been built over collection iterations. The automap, autofold and Autolterator AMSs are presented, together with performance measurements for Jocaml, Java Voyager, and JavaGo implementations on LANs. An AMS considers only the cost of the current collective computation, but it is more useful to know the cost of the entire program. We have extended our AMS cost models to be parameterised on the cost of the remainder of the program. A cost calculus to estimate the costs for the remainder of a computation at arbitrary points has been built. An automatic Jocaml cost analyser based oil the calculus produces cost equations parameterised on program variables in context, and may be used to find both cost in higher-order functions and the cost for the remainder of the program. Costed autonomous mobility skeletons (CAMSs) have been built, which not only encapsulate common patterns of autonomous mobility but take additional cost parameters to provide costs for the remainder of the program. Potential performance improvements are assessed by comparing CAMS to AMS programs. The results show that CAMS programs perform more effectively than AMS programs, because they have more accurate cost information. Hence a CAMS program may move to a faster location when the corresponding AMS program does not. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
40|$|WebML is a {{high-level}} language for specifying the content structure of data-intensive Web applications, {{and the organization}} and presentation of such content through a hypertext structure. This paper concentrates on the conceptual design of structural schemas and hypertexts, which represents the core aspect of the WebML design process. In particular, the paper introduces a set of WebML <b>skeletons,</b> i. e., <b>abstract</b> and simplified versions of structural and hypertext schemas that are recurrent within Web applications. Then, it shows how skeletons can be composed to obtain several WebML application frameworks, which provide a classification of Web sites {{from the viewpoint of}} their predominant information-delivery mission (or business model). WebML skeletons and frameworks can be assumed as the initial start-point of design sessions, as well as paradigms for better understanding and classifying data-intensive Web applications...|$|R
40|$|<b>Abstract.</b> <b>Skeletons</b> {{are often}} used as a {{framework}} for part-based shape analysis. This paper describes some useful strategies that can be employed to improve the performance of such shape matching algorithms. Four key strategies are proposed. The first is to incorporate ligature-sensitive information into the part decomposition and shape matching processes. The second is to treat part decomposition as a dynamic process in which the selection of the final decomposition of a shape is deferred until the shape matching stage. The third is the need to combine both local and global measures when computing shape dissimilarity. Finally, curvature error between skeletal segments must be weighted by the limb-width profile along the skeleton. Experimental results show that the incorporation of these strategies significantly improves the retrieval accuracy when applied to LEMS’s 99 and 216 silhouette database [10]. ...|$|R
40|$|<b>Abstract.</b> <b>Skeleton</b> of 3 D mesh is a {{fundamental}} shape feature, and is useful for shape description and other many applications in 3 D Digital Geometry Processing. This paper presents a novel skeleton extraction algorithm based on feature point and core extraction by the Multidimensional scaling (MDS) transformation. The algorithm first straights the folded prominent branch up, {{as well as the}} prominent shape feature points of mesh are computed, a meaningful segmentation is applied under the direction of feature points. The Node-ring of all segmented components is defined by discrete geodesic path on mesh surface, and then the skeleton of every segmented component is defined as the link of the Node-ring’s center. As to the core component without prominent feature points, principal curve is used to fit its skeleton. Our algorithm is simple, and invariant both to the pose of the mesh and to the different proportions of model’s components...|$|R
40|$|The task of {{skeletal}} shape deformation (aka skinning) is {{to provide}} intuitive, user friendly means of controlling {{the shape of a}} 3 D object using a skeleton. The <b>skeleton</b> is an <b>abstract</b> auxiliary structure; in case of character models, it corresponds to an articulated rigid structures, i. e., bones connected with joints. The main challenge consists in automatically translating the skeletal pose to plausible and smooth deformations of an input shape, such as the human body. There are two main classes of methods to approach this problem: direct and variational methods. Variational methods pose the task as an optimization problem and minimizing an objective function (deformation energy), typically using iterative methods. This report focuses on direct methods, which compute the resulting deformations in a direct, closed-form way. These methods are often very fast and suitable for massively parallel computing, making them particularly attractive for interactive, real-time applications and GPU implementations...|$|R
