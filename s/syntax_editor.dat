12|53|Public
50|$|He was <b>syntax</b> <b>editor</b> for {{the first}} edition of the Encyclopedia of Language and Linguistics and was joint editor, with Jim Miller, of A Concise Encyclopedia of Linguistic Theories and A Concise Encyclopedia of Grammatical Categories (Pergamon Press,1997 and 1998). He was also a joint editor of Common Denominators in Art and Science (Aberdeen UniversityPress, 1983) as well as Language, Reasoning and Inference (Academic Press, 1986).|$|E
40|$|We {{present an}} {{approach}} to multilingual web content based on multilingual grammars and syntax editing for a controlled language. Content can be edited in any supported language and it is automatically kept within a controlled language fragment. We have implemented a web-based <b>syntax</b> <b>editor</b> for Grammatical Framework (GF) grammars which allows both direct abstract syntax tree manipulation and text input {{in any of the}} languages supported by the grammar. With this <b>syntax</b> <b>editor</b> and the GF JavaScript API, GF grammars can be used to build multilingual web applications. As a demonstration, we have implemented an example application in which users can add, edit and review restaurants in English, Spanish and Swedish...|$|E
40|$|This paper {{shows how}} a {{dialogue}} system for information-seeking dialogues {{can be implemented}} in a type-theory-based <b>syntax</b> <b>editor,</b> originally developed for editing mathematical proofs. The implementation gives a simple logical metatheory to such dialogue systems and also suggests new functions for them, e. g. a local undo operation. The method developed provides a logically based declarative way of implementing simple dialogue systems that is easy to port to new domains...|$|E
40|$|A <b>syntax</b> {{directed}} <b>editor</b> is {{an editor}} oriented towards a particular language. This paper describes a general table-driven <b>syntax</b> directed <b>editor</b> and an algorithm for automatically generating a <b>syntax</b> directed <b>editor</b> for a language from a description of that language. Aside from the convenience of a <b>syntax</b> directed <b>editor,</b> {{it is also a}} very efficient parser. No syntactic error recovery is required since the editor does not permit the user to make syntactic errors. Some of the implications of <b>syntax</b> directed <b>editors</b> for data structure manipulation and two dimensional languages are briefly discussed. (Author) supported by the Foundation Research Program of the Naval Postgraduate School with funds provided by the Chief of Naval Research,[URL] N 0001481 WR 10034 N...|$|R
5000|$|Editing: <b>syntax</b> {{highlighted}} <b>editor</b> with immediate {{visual feedback}} ...|$|R
40|$|This paper {{describes}} CEP A G E 1, {{an editor}} for structured documents, designed {{for ease of}} use on modern terminals. The design of CEPAGE {{is the result of}} work on <b>syntax</b> <b>editors,</b> full-screen editors and advanced software environments. CEP AGE is a universal editor, in which the language description is merely a parameter; its external interface is designed for the children of the video age. Although itself a prototype, CEPAGE embodies the properties which a structural editor usable in an industrial environment should possess...|$|R
40|$|This master’s {{thesis is}} focused on a new {{production}} technology of a rotational part. The SolidWorks software was used for create the component design. According to the proposed models, CNC program using parametric programming using mathematical functions {{was created in the}} CNC <b>Syntax</b> <b>Editor</b> Free Edition program. The final step was the experimental verification of the functionality and components compared with other type and the economical evaluation of manufactured components...|$|E
40|$|This article {{describes}} the syntax editing concepts used by the Operations Sustaining Engineering Section in implementing System Performance Test software for the Mark 4 -A era. The processing functions are discussed, {{as well as the}} necessary data structures and table generation macros used in implementing those functions. In addition, the procedural and software interfaces which have been developed for users of the <b>syntax</b> <b>editor</b> are described, including the forms required for establishing directive and parameter characteristics...|$|E
40|$|Abstract We give an {{extended}} abstract {{of a work}} in progress concerning &quot;gram-lets&quot;. A gramlet is a program automatically produced from a GF (Grammatical Framework) grammar. Given a GF grammar, the cor-responding gramlet provides some of the functionality of GF [...] specialized for that grammar. The gramlet could for instance function asa <b>syntax</b> <b>editor</b> in which you can edit and linearize the syntax trees described by the grammar. One application of gramlets is for usingGF on handheld computers. 1 Overview In this extended abstract we introduce the concept of &quot;gramlets&quot;. Westart with a quick briefing on the Grammatical Framework, and move on with a general discussion of and motivation for our ideas aboutgramlets. We conclude with a description of our work in progress on implementing these ideas...|$|E
25|$|The ed {{commands}} {{are often}} imitated in other line-based editors. For example, EDLIN in early MS-DOS versions and 32-bit versions of Windows NT has a somewhat similar <b>syntax,</b> and text <b>editors</b> in many MUDs (LPMud and descendants, for example) use ed-like <b>syntax.</b> These <b>editors,</b> however, are typically more limited in function.|$|R
40|$|This is {{the second}} report of a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code generator, and supports programming in a small applicative language. The present report extends the interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter and debugger to accomodate block-structured identifier declaration and reference. Chief of Naval Research, Arlington, VA[URL]...|$|R
40|$|This is {{the first}} report of a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code generator, and supports programming in a small applicative language. The present report describes the interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter and debugger for a subset of the language, namely arithmetic expressions. Prepared for: Chief of Naval Research[URL]...|$|R
40|$|Evolution towards {{specifications}} environment: {{experiences with}} syntax editors Language-based editors have been thoroughly studied {{over the last}} 10 years and {{have been found to}} be less effective than orig-inally thought. The paper reviews some relevant aspects of such editors, describes experiences with one such editor (Support), and then describes two current projects that extend the syntax-editing paradigm to the specifications and design phases of the sol?ware life-cycle. software design, environments, specification, syntax editors SYNTAX EDITORS Syntax-editing (or alternatively language-based editing) is a technique that had its beginning about 20 years ago (e. g., Emily I) and blossomed into a major research activity 10 years later (e. g., Mentor % CPS 3) [...] During the mid- 1980 s, major conferences were often dominated by syntax-editing techniques 4,s. Many of these projects, however, have since been terminated or have taken a much lower profile. There are few widely used commer-cial products that use this technology. Why? This paper briefly introduces the concept of syntax editing, describes one particular editor, and explains some experiences in using it. It is then shown how the syntax-editing paradigm is powerful but perhaps misap-plied in the domain of source-program generation. Just using a <b>syntax</b> <b>editor</b> for source-code production does not result in significantly higher productivity. By integrating specification generation with this source-code production, however, the author believes that increased productivity can be provided by making more of the life-cycle visible to the programmer. Two extensions to the current environment are described that apply syntax editing within a specifications environment to provide additional functionality over that of standard syntax editors. With a conventional editor, the user may insert an arbitrary string of characters at any point in a file, and a later compilation phase will determine if there are any errors. With a <b>syntax</b> <b>editor,</b> however, only those choice...|$|E
40|$|This thesis {{describes}} {{a number of}} practical experiments rather than theoretical investigations {{in the area of}} natural language processing. The basis for the work presented is Grammatical Framework (GF). It is a very complex system, which comprises among other things a grammar formalism based on type theory and its implementation written in Haskell. GF is intended for high-quality machine translation (of INTERLINGUA type) in the restricted language domains. The primary concern of this thesis is however limited to the usage of GF as a piece of software. The main results are: • Implementing a <b>syntax</b> <b>editor,</b> which provides a graphical user interface (GUI) for the command-line GF core. • Writing a part of code for automatic generation of gramlets — pure Java programs with limited (compared to GF) functionality that can be run on PDA (Portable Device Assistants) and as applets in a browser...|$|E
40|$|Software architects design {{systems to}} achieve quality {{attributes}} like security, reliability, and performance. Key to achieving these quality attributes are design constraints governing how {{components of the}} system are configured, communicate and access resources. Unfortunately, identifying, specifying, communicating and enforcing important design constraints – achieving architectural control – can be difficult, particularly in large software systems. We argue {{for the development of}} architectural frameworks, built to leverage language mechanisms that provide for domain-specific <b>syntax,</b> <b>editor</b> services and explicit control over capabilities, that help increase architectural control. In particular, we argue for concise, centralized architectural descriptions which are responsible for specifying constraints and passing a minimal set of capabilities to downstream system components, or explicitly entrusting them to individuals playing defined roles within a team. By integrating these architectural descriptions directly into the language, the type system can help enforce technical constraints and editor services can help enforce social constraints. We sketch our approach in the context of distributed systems...|$|E
40|$|This is {{the last}} report of a series {{exploring}} {{the use of the}} Omega programming notation to prototype a programming environment. This environment includes an interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code -generator, and supports programming in a small applicative language. This report presents a universal (i. e., table-driven) <b>syntax</b> directed <b>editor</b> and unparser, which requires only 53 rules to express. A running implementation of these ideas is listed in the appendices. Office of Naval Research[URL]...|$|R
40|$|This is the. third {{report of}} a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code generator, and supports programming in a small applicative language. The present report extends the interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter and debugger to accommodate comments (which are used both statically and dynamically) and conditional expressions. A running implementation of these ideas is listed in the appendices. supported by Contract from the Office of Naval Research[URL]...|$|R
5000|$|<b>Syntax</b> {{highlighting}} in <b>editor</b> {{to distinguish}} between instructions, operands, comments etc.|$|R
40|$|The {{basis for}} the work {{presented}} is Grammatical Framework (GF) — a grammar formalism based on type theory. It is also a powerful language processor that provides a convenient framework for various multilingual applications. The primary concern of this thesis is the usage of GF {{as a piece of}} software. The main results are: • Implementing a <b>syntax</b> <b>editor,</b> which provides a graphical user interface (GUI) for the command-line GF core. • Writing the Russian resource grammar that takes care of the most basic morphological and syntactic rules and serves as a standard library for building application grammars (describing sublanguage domains) in Russian. These results contribute to language engineering in GF on two different levels: • Author level (end-user) — constructing documents in natural languages. • Grammarian level — building a grammar description, which is later used on the author level. One can also distinguish between application and resource grammars. An application grammar focuses of a particular sub-language domain, while resource grammar is a general-purpose grammar that forms a basis for application grammars...|$|E
5000|$|An {{interactive}} debugger for batch files, {{including a}} built-in <b>syntax</b> highlighting text <b>editor</b> ...|$|R
40|$|This is {{the fourth}} report of a series {{exploring}} {{the use of the}} Q programming notation to prototype a programming environment. This environment includes an interpreter, unparser. <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code generator, and supports programming in a small applicative language. The present report extends the interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter and debugger to accommodate recursive function definition and invocation, and completes the extension of the language into an applicative programming system supporting higher-order functions. An implementation of these ideas is listed in the appendices. Prepared for: Chief of Naval Researchsupported by Contract from the Office of Naval Research[URL]...|$|R
50|$|The editor uses {{a variety}} of {{techniques}} for syntax highlighting in the source. It can use auto completion and hints to assist in editing source code. Previews of HTML/ASP/PHP code are supported. A <b>syntax</b> file <b>editor</b> is included.|$|R
5000|$|XML <b>Editor</b> <b>Syntax</b> Highlighting Rules: Some XML editors use Schematron {{rules to}} conditionally {{highlight}} XML files for errors. Not all XML editors support Schematron.|$|R
40|$|Ada+SQL is a {{programming}} environment for Ada 95 extended with basic SQL single user capabilities. It incorporates {{a very fast}} compiler and interpreter, with debugging options, library generator and browser, <b>syntax</b> template <b>editors,</b> programmer wizard, SQL interactive interface and hypertext documentation on the environment, Ada 95 and SQL. Several implementation aspects are discussed...|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe Computer Aided Prototyping System (CAPS) is an integrated set of software engineering tools {{developed at the}} Naval Postgraduate School (NPS). It is designed to support rapid prototyping of real-time systems. CAPS consists of four major subcomponents; the graphics/text editor, the user interface, the software database system, and the execution support system. Reports from users of CAPS, particularly novices, indicated that the clumsy and unintuitive multi windowed graphics/text editor present in the system hampered {{the use of the}} tool set. This thesis presents the substitution and integration of an efficient and user-friendly <b>syntax</b> directed <b>editor</b> into CAPS. The new <b>syntax</b> directed <b>editor</b> consists of a package of seven Ada 95 parsers that recognize the elements of the Prototype System Description Language (PSDL) and an enhanced C[URL] United States Marine Corp...|$|R
40|$|This paper {{presents}} two {{new tools}} integrated in the <b>Syntax</b> Driven <b>Editor</b> for VHDL: sdev[1]. The first tool allows {{the user to}} build his own VHDL subset. The second is a tool which allows to verify if a VHDL source belongs to a given VHDL subset. This paper is illustrated through {{the example of the}} subset used for the synopsys synthesis tool...|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe formal specification language Spec {{is used for}} writing black-box specifications for large software systems. These black-box specifications describe the interface beteen a system and its users, as well as internal interfaces between modules. Systems analysts use specifications written in Spec to verify the customer's requirements during {{the development of a}} software system. This thesis demonstrates the feasibility of designing and implementing a <b>syntax</b> directed <b>editor</b> for a subset of the specification language Spec. The editor is a software tool for writing Spec specifications that ensures syntactic correctness of such specifications. The <b>syntax</b> directed <b>editor</b> is created using the Synthesizer Generator, a Computer-Aided Software Engineering (CASE) tool for generating language-based editors. The specification for the editor is written in the Synthesizer Specification Language (SSL) which is based on an attribute grammar. The software tool developed in this thesis supports the Requirements Analysis phase of the software development cycle. [URL] Commander, United States Nav...|$|R
50|$|Google Mashup Editor was {{an online}} mashup {{creation}} service created by Google {{that has been}} discontinued. It used CodePress as its <b>syntax</b> highlighting code <b>editor,</b> which also has been discontinued.|$|R
50|$|EAGs were {{introduced}} and studied by D.A. Watt in 1974; recognizers were {{developed at the}} University of Nijmegen between 1985 and 1995. The EAG compiler developed there will generate either a recogniser, a transducer, a translator, or a <b>syntax</b> directed <b>editor</b> for a language described in the EAG formalism. The formalism is quite similar to Prolog, {{to the extent that}} it borrowed its cut operator.|$|R
50|$|Horton was {{introduced}} to UNIX at Wisconsin, creating an enhanced UNIX text editor called hed. At Berkeley, she contributed {{to the development of}} Berkeley UNIX, including the vi text editor, uuencode (the first mechanism for Email attachments), w and load averages, termcap, and curses. Her Ph.D. dissertation was {{the creation of a new}} type of <b>syntax</b> directed <b>editor</b> with a textual interface. This technology was later used to create computer-aided software engineering tools.|$|R
50|$|Text editors {{intended}} for use with HTML usually provide at least <b>syntax</b> highlighting. Some <b>editors</b> additionally feature templates, toolbars and keyboard shortcuts to quickly insert common HTML elements and structures. Wizards, tooltip prompts and autocompletion may help with common tasks.|$|R
40|$|This is {{the fifth}} report of a series {{exploring}} {{the use of the}} £ 7 programming notation to prototype a programming environment. This environment includes an interpreter, unparser, <b>syntax</b> directed <b>editor,</b> command interpreter, debugger and code generator, and supports programming in a small applicative language. The present report presents a code generator operating on abstract syntax trees. The code generation process is implemented as an evaluator over a nonstandard domain. An implementation of the code generator is listed in the appendices. supported by Contract from the Office of Naval Research[URL]...|$|R
50|$|LEXX is a {{text editor}} which was {{possibly}} {{the first to}} use live parsing and colour syntax highlighting. It was written by Mike Cowlishaw of IBM around 1985. The name was chosen because he wrote it as a tool for lexicographers, during an assignment for Oxford University Press's second edition of the Oxford English Dictionary. The program ran (and still, 2012, runs) on mainframes under VM/CMS. LEXX's design was chosen as a middle ground between specialized <b>syntax</b> directed <b>editors</b> such as Grif and JANUS and general purpose editors such as the contemporary Emacs and XEDIT.|$|R
50|$|WinShell {{includes}} a text <b>editor,</b> <b>syntax</b> highlighting, project management, spell checking, a table wizard, BibTeX front-end, Unicode support, different toolbars, user configuration options {{and it is}} portable (e.g. on a USB drive).It is not a LaTeX system; an additional LaTeX compiler system for Microsoft Windows (such as MiKTeX or TeX Live) is required.|$|R
40|$|The STAPLE project {{investigated}} (at {{the end of}} the eighties), {{a persistent}} architecture for functional programming. Work has been done in two directions: the development of a programming environment for a functional language within a persistent system and an experiment on transferring the expertise of functional prototyping into industry. This paper is a report on the first activity. The first section gives a general description of Absynte - the abstract <b>syntax</b> tree <b>editor</b> developed within the Project. Following sections make an attempt at measuring the effectiveness of such an editor and discuss the problems raised by structured syntax editing - specially environments based on abstract syntax trees. Comment: This is an old paper (1990) of 29 page...|$|R
40|$|Although {{techniques}} for implementing or generating incremental semantic evaluators have been explored and refined {{for more than}} two decades, several pragmatic concerns still impede the use of such techniques in practical development environments. This report not only addresses some of these concerns, but furthermore demonstrates the need to consider the problem of incremental semantic evaluation in context. The practical concerns addressed here stem from both user interaction and architectural requirements. In particular an innovative preemptive evaluation scheme is presented which helps to reduce delays associated with semantic evaluation over a sequence of edits. Furthermore, a technique for assigning attributes to syntactically erroneous material (the introduction of which is inevitable in a <b>syntax</b> recognition <b>editor)</b> is described, as well as a novel approach to handling "long-distance" semantic effects using fine-grained incremental evaluation of relations...|$|R
