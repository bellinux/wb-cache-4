0|18|Public
40|$|During {{the past}} years, {{distributed}} computing approach is most popular approach {{among the other}} computing approaches. In this approach, the execution time of the processes has been reduced and the setup cost of distributed systems is very low. The process is defined as subtasks, <b>subroutines,</b> <b>macro’s</b> etc. In the present work, a static interconnection of the computer systems is defined and called as the static step topology. By {{the use of this}} topology, N numbers of hand-held devices and other computer systems may be attached. As the size of network increases, the space complexities are computer by varying the length of the cable segments. Node failures are also computed in the static step topology. A Unified Modeling Language (UML) is used to demonstrate the dynamic execution of process in step topology and represented through sequence diagram...|$|R
50|$|Simulations, or Missions as IMPRINT {{refers to}} them, contain a task network called a Network Diagram. The network diagram {{contains}} {{a series of}} tasks connected by paths which determine control flow. System objects called entities flow through the system to create a simulation. IMPRINT also includes more low level features such as global variables and <b>subroutines</b> called <b>macros.</b>|$|R
40|$|In {{the current}} scenario, {{distributed}} computing approach is most popular approach for computing the processes known as subtasks, <b>subroutines,</b> <b>macro’s</b> etc due to low cost involvement and minimum execution time. In the present work, the computer systems are attached {{with the help}} of static interconnection through step topology in which one machine is working as server and Endian operating system is loaded on the server. A Unified Modeling Language (UML) is used to demonstrate the model of working of Endian operating system. The performance of Endian operating system in terms of firewall execution is monitored for the various user identification controlled connected by Internet Protocol (IP Version 4) where the users are connected through static topology. The loading and balancing are also performed by Endian operating system for transferring of data from one machine to another machine and results are depicted in terms of tables and graphs...|$|R
5000|$|MTS Volume I: Introduction; Concepts and facilities; Calling conventions; Batch, Terminal, Tape, and Data Concentrator user's guides; Description of UMMPS and MTS; Files and devices; Command language; User Programs; <b>Subroutine</b> and <b>macro</b> library descriptions; Public or library file descriptions; and Internal specifications: Dynamic loader (UMLOAD), File and Device Management (DSRI prefix and postfix), Device Support Routines (DSRs), and File {{routines}} ...|$|R
40|$|Several {{techniques}} {{have been developed}} for allowing genetic programming systems to produce programs that make use of <b>subroutines,</b> <b>macros,</b> and other modular program struc-tures. A recently proposed technique, based on the“tagging” and tag-based retrieval of blocks of code, has been shown to have novel and desirable features, but this was demonstrated only {{within the context of the}} PushGP genetic programming system. Following a suggestion in the GECCO- 2011 publi-cation on this technique we show here how tag-based mod-ules can be incorporated into a more standard tree-based ge-netic programming system. We describe the technique in de-tail along with some possible extensions, outline arguments for its simplicity and potential power, and present results obtained using the technique on problems for which other modularization {{techniques have}} been shown to be useful. The results are mixed; substantial benefits are seen on the lawnmower problem but not on the Boolean even- 4 -parity problem. We discuss the observed results and directions for future research...|$|R
50|$|The {{format of}} a <b>macro</b> (<b>subroutine)</b> call may be {{illustrated}} by the following example. Macro A in this example adds the two parameters passed to it from the main program, and returns the sum {{on the top of}} the stack.|$|R
50|$|PLCs {{have many}} types of special blocks. They include timers, {{arithmetic}} operators and comparisons, table lookups, text processing, PID control, and filtering functions. More powerful PLCs can operate {{on a group of}} internal memory locations and execute an operation on a range of addresses, for example, to simulate a physical sequential drum controller or a finite state machine. In some cases, users can define their own special blocks, which effectively are <b>subroutines</b> or <b>macros.</b> The large library of special blocks along with high speed execution has allowed use of PLCs to implement very complex automation systems.|$|R
50|$|The name {{subprogram}} {{suggests a}} subroutine behaves {{in much the}} same way as a computer program that is used as one step in a larger program or another subprogram. A subroutine is often coded so that it can be started (called) several times and from several places during one execution of the program, including from other subroutines, and then branch back (return) to the next instruction after the call, once the subroutine's task is done. Maurice Wilkes, David Wheeler, and Stanley Gill are credited with the invention of this concept, which they termed a closed subroutine, contrasted with an open <b>subroutine</b> or <b>macro.</b>|$|R
40|$|By design, the SRC- 6 {{reconfigurable}} {{computer is}} programmed in the MAP C programming language {{within the framework}} provided by the SRC Carte ™ development environment. The functionality of the original language can be extended via third party <b>subroutines,</b> called <b>macros.</b> These macros, typically implemented in Verilog Hardware Description Language, are brought into the MAP C program via configuration files that define the interface between the macros and the MAP C language. In this paper, we describe a process of using the Verilog source for SRC macros generated from the MathWorks Simulink ® designs built using Xilinx System Generator ™ for DSP and Xilinx Blockset. We also describe an example application that takes advantage of this programming model...|$|R
5000|$|IMPRINT has {{a number}} of global {{variables}} used by the system throughout a simulation. IMPRINT provides the public global variable Clock which tracks the simulation’s current time. IMPRINT also has private variables such as operator workload values. IMPRINT allows the modeler to create custom global variables which can be accessed and modified in any task node. Variables can be of any type native to C#, but the software provides a list of suggested variable types including C# primitive data types and basic data structures. IMPRINT also provides the programmer with the functionality to create globally accessible <b>subroutines</b> called <b>macros.</b> Macros work as C# functions and can specify parameters, manipulate data, and return data.|$|R
5000|$|Several {{attempts}} have been made, {{with varying degrees of}} success, to implement coroutines in C with combinations of <b>subroutines</b> and <b>macros.</b> Simon Tatham's contribution, based on Duff's device, {{is a good example of}} the genre, and his own comments provide a good evaluation of the limitations of this approach. The use of such a device truly can improve the writability, readability and maintainability of a piece of code, but is likely to prove controversial. In Tatham's words: [...] "Of course, this trick violates every coding standard in the book... but any coding standard which insists on syntactic clarity at the expense of algorithmic clarity should be rewritten. If your employer fires you for using this trick, tell them that repeatedly as the security staff drag you out of the building." ...|$|R
40|$|Development and {{evolution}} of Microsoft Office and Microsoft Windows shells is based in general on the special methodology of Software creation and implementation such as <b>macros,</b> <b>subroutine,</b> custom commands and specialized features; this methodology of Microsoft Software shells is analyzed. The universal methodology of Adaptable Software creation is proposed. Present result evaluates from [Tod- 08. 1] which is a evolution of the Fulbright research project no. 22131 “Societal Information Systems’ Adaptable Tools“ performed in the University of Omaha at Nebraska, USA in the 1997 / 1998 academic year [Tod- 98]...|$|R
40|$|Introduction Modern {{programming}} languages {{support the}} production of structured, modular programs through several mechanisms including <b>subroutines,</b> coroutines, and <b>macros.</b> Koza has previously shown {{that the power of}} a genetic programming system can often be enhanced by allowing for the simultaneous evolution of a main program and a collection of subroutines [Koza 1994 a]. Additional studies have investigated factors underlying the performance of Koza's automatically defined functions (ADFs) along with alternative techniques for the automatic generation of subroutines. For example, Angeline and Pollack developed an alternative technique called Module Acquisition (MA) [Angeline and Pollack 1992, Angeline 1994] and Kinnear compared the utility of ADFs with that of MA [Kinnear 1994]. Additional alternatives have also been proposed [Iba et al. 1993, Rosca and Ballard 1995]. While subroutines promote program modularity and code reuse, they do not normally provide programmers with th...|$|R
40|$|This paper {{describes}} the dotplot data visualization technique {{and its potential}} for contributingto the identification of design patterns. Pattern languages {{have been used in}} architectural design and urban planning to codify related rules-of-thumb for constructing vernacular buildings and towns. When applied to software design, pattern languages promote reuse while allowing novice designers to learn from the insights of experts. Dotplots have been used in biology to study similarity in genetic sequences. When applied to software, dotplots identify patterns that range in abstraction from the syntax of programming languages to the organizational uniformity of large, multi-component systems. Dotplots are useful for design by successive abstraction [...] -replacing duplicated code with <b>macros,</b> <b>subroutines,</b> or classes. Dotplots reveal a pervasive design pattern for simplifying algorithms by increasing the complexity of initializations. Dotplots also reveal patterns of wordiness in languages [...] -one [...] ...|$|R
40|$|During {{the past}} years, the {{distributed}} computing approach {{has become very}} popular due to various advantages over centralized approach. In the distributed approach, the execution of a process has reduced and also it requires low cost for installation. Many of the researchers are using the modeling approach for solution of the software and hardware architecture research problems. The most popular approach of modeling is known as Unified Modeling Language based on the object-oriented technology. In the present work, a method of deadlock detection is explained for the newly proposed static step topology for the distributed network. In the step topology, the processes are taken as a task, sub task, <b>macro,</b> <b>subroutine,</b> etc which are executed in reflexive and symmetric manners when the systems are interconnected to each other under distributed environment and avoidance technique is also presented for the same. The deadlock detection technique is presented through a UML class model. </p...|$|R
40|$|This chapter {{shows how}} a genetic {{programming}} {{system can be}} used to simultaneously evolve programs and their control structures. Koza has previously shown that the performance of a genetic programming system can sometimes be improved by allowing for the simultaneous evolution of a main program and a collection of automatically defined functions (ADFs). This chapter shows how related techniques {{can be used to}} simultaneously evolve a main program and a collection of automatically defined macros (ADMs). Examples are provided to show how the use of ADMs can lead to the production of useful new control structures during evolution, and data is presented to show that ADMs sometimes provide a greater benefit than do ADFs. The chapter includes a discussion of characteristics of problems that may benefit most from the use of ADMs or from architectures that include both ADFs and ADMs. It is suggested that ADMs are likely to be useful for evolving intelligent action systems for complex environments, and data is presented to show that this is the case for one such application. The chapter concludes with a discussion of several directions for further research. Modern programming languages support the production of structured, modular programs through several mechanisms including <b>subroutines,</b> coroutines, and <b>macros.</b> Koza has previousl...|$|R
50|$|A {{pseudocode}} {{comparison of}} imperative, procedural, and object oriented approaches {{used to calculate}} the area of a circle (πr²), assuming no <b>subroutine</b> inlining, no <b>macro</b> preprocessors, register arithmetic, and weighting each instruction 'step' as only 1 instruction - as a crude measure of instruction path length - is presented below. The instruction step that is conceptually performing the state change is highlighted in bold typeface in each case. The arithmetic operations used to compute the area of the circle are the same in all three paradigms, with the difference being that the procedural and object-oriented paradigms wrap those operations in a subroutine call that makes the computation general and reusable. The same effect could be achieved in a purely imperative program using a macro preprocessor at only the cost of increased program size (only at each macro invocation site) without a corresponding pro rata runtime cost (proportional to n invocations - that may be situated within an inner loop for instance). Conversely, subroutine inlining by a compiler could reduce procedural programs to something similar in size to the purely imperative code. However, for object-oriented programs, even with inlining, messages still must be built (from copies of the arguments) for processing by the object-oriented methods. The overhead of calls, virtual or otherwise, is not dominated by the control flow alteration - but by the surrounding calling convention costs, like prologue and epilogue code, stack setup and argument passing (see here for more realistic instruction path length, stack and other costs associated with calls on an x86 platform). See also here for a slide presentation by Eric S. Roberts ("The Allocation of Memory to Variables", chapter 7) - illustrating the use of stack and heap memory use when summing three rational numbers in the Java object-oriented language.|$|R
40|$|We {{conducted}} {{a comparison of}} three DPOAE protocols, testing cubic 2 F 1 - F 2 distortion products, in order to define the most feasible protocol for a universal hearing screening programme. The protocols used asymmetrical stimulus intensities (L 1 > L 2) with a frequency ratio of 1. 22, in the following format: (P 1), L 1 = 60, L 2 = 50 dB SPL; (P 2), L 1 = 65, L 2 = 55 dB SPL; and (P 3), L 1 = 75, L 2 = 65 dB SPL. Linear TEOAE responses evoked by click stimuli of 75 dB p. e. SPL were used as controls of the normal cochlear function. Five 2 F 1 - F 2 frequencies, 1. 5, 2. 0, 3. 0, 4. 0, 5. 0 kHz, were tested with a ILO- 92 <b>macro</b> <b>subroutine.</b> The project included randomly selected recordings from 1, 200 well-baby nursery (WBN) infants (age 48 hours) and 50 very low birth weight NICU infants. Statistical analyses comparing the signal-to-noise ratios (S/N), at the predefined F 2 frequencies, indicated that the P 1 and P 2 DPOAE protocols perform similarly. Significant S/N differences were observed in the P 3 to P 2 and P 3 to P 1 data-set comparisons. DPOAE scoring criteria were estimated from the P 3 data set, using one-sided distribution-free tolerance boundaries. The scoring criteria for a 'pass' were estimated as a minimum S/N of 6. 0, 7. 0 and 6. 0 dB at 2. 0, 3. 0 and 4. 0 kHz respectively. In terms of feasibility, the P 3 protocol generated responses in 98 % of the WBN and 76 % of the NICU infants. All three DPOAE protocols demonstrated smaller time-recording requirements than the TEOAE standard. The false-positive ratio for the NICU infants was estimated as 8 %...|$|R

