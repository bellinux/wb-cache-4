1|3|Public
40|$|JRelix is a {{relational}} database implementation that supports not only traditional relational algebra and domain algebra but also complex data type and recursive nesting with powerful database programming language. This thesis documents some new features and operators of JRelix. Among them, type polymorphism (union type domain) and the relational pattern search (grep) operator are especially useful {{when dealing with}} semistructured data in a {{relational database}}. We use union type domains to increase the flexibility of rigid type definition in relational databases. In addition, we implement the grep operator in the relational algebra to facilitate queries on semistructured data. Grep returns a relation which could contain the type and name of the attribute where it finds the match and the position in that attribute and value of the match. Moreover, we also implement top-level scalar and <b>substring</b> <b>function</b> which are also very useful in a relational database language...|$|E
40|$|M 4 is a macro {{processor}} available on UNIX† and GCOS. Its primary use {{has been as}} a front end for Ratfor for those cases where parameterless macros are not ad-equately powerful. It has also been used for languages as disparate as C and Cobol. M 4 is particularly suited for functional languages like Fortran, PL/I and C since macros are specified in a functional notation. M 4 provides features seldom found even in much larger {{macro processor}}s, including •arguments •condition testing •arithmetic capabilities •string and <b>substring</b> <b>functions</b> •file manipulation This paper is a user’s manual for M 4...|$|R
5000|$|Meta-SQL expands to platform-specific SQL <b>substrings,</b> causes another <b>function</b> to be called, or {{substitutes}} a value. Meta-SQL constructs {{are used}} in functions that pass SQL strings, such as the following: ...|$|R
40|$|We {{address the}} problem of {{learning}} a morphological automaton directly from a monolingual text corpus without recourse to additional resources. Like previous work in this area, our approach exploits orthographic regularities in a search for possible morphological segmentation points. Instead of affixes, however, we search for affix transformation rules that express correspondences between term clusters induced from the data. This focuses the system on <b>substrings</b> having syntactic <b>function,</b> and yields cluster-to-cluster transformation rules which enable the system to process unknown morphological forms of known words accurately. A stem...|$|R

