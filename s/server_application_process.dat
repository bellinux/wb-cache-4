1|10000|Public
5000|$|The company's {{flagship}} product is a server monitoring solution called RevealCloud. Originally launched in July 2011, RevealCloud provides real-time server monitoring for Linux, Windows, FreeBSD and Mac OS X servers. [...] The 5 second on-screen performance updates are {{visible through the}} SaaS application. Some of the key unique features include a less than 10 second install and a Web 2.0 graphical interface. CopperEgg further extended the product by introducing <b>server</b> <b>application</b> <b>process</b> monitoring with an update in 2012.|$|E
5000|$|... #Caption: A dynamic {{web page}} needs a support-server, an <b>application</b> <b>server</b> to <b>process</b> its {{server-side}} language.|$|R
40|$|The {{bachelor}} thesis "Application {{for real}} network traffic processing in OPNET Modeler environment" concerns about cooperation of simulation tool OPNET Modeler with real computer network environment. In this thesis I describe creating module that implements <b>server</b> <b>application</b> that <b>processes</b> data coming from real network and sends them to OPNET Modeler simulation. I also describe all necessary modifications inside OPNET Modeler simulation and steps for successful running the simulation...|$|R
50|$|In computing, {{configuration}} files (or config files) are files used {{to configure}} the parameters and initial settings for some computer programs. They {{are used for}} user <b>applications,</b> <b>server</b> <b>processes</b> and operating system settings.|$|R
5000|$|Web site {{administrators and}} programmers can {{find that the}} {{separation}} of web applications from the web server in FastCGI has many advantages over embedded interpreters (mod_perl, mod_php, etc.). This separation allows <b>server</b> and <b>application</b> <b>processes</b> to be restarted independently [...] - [...] an important consideration for busy web sites. It also enables the implementation of per-application / hosting service security policies, which is an important requirement for ISPs and web hosting companies. [...] Different types of incoming requests can be distributed to specific FastCGI servers which have been equipped to handle those particular types of requests efficiently.|$|R
40|$|<b>Server</b> <b>applications</b> must <b>process</b> {{requests}} {{as quickly}} as possible. Because some requests depend on earlier requests, {{there is often a}} tension between increasing throughput and maintaining the proper semantics for dependent requests. Operating system transactions make it easier to write reliable, high-throughput <b>server</b> <b>applications</b> because they allow the application to execute non-interfering requests in parallel, even if the requests operate on OS state, such as file data. By changing less than 200 lines of application code, we improve performance of a replicated Byzantine Fault Tolerant (BFT) system by up to 88 % using server-side speculation, and we improve concurrent performance up to 80 % for an IMAP email server by changing only 40 lines. Achieving these results requires substantial enhancements to system transactions, including the ability to pause and resume transactions, and an API to commit transactions in a pre-defined order...|$|R
40|$|Using XML (Extensible Markup Language) {{processing}} {{can result}} into significant runtime overhead in a XML-based infrastructural middleware, such as multi-thread <b>server</b> <b>application.</b> Based on well-formed pairs of named-marking tags, XML element’s structure contribute to its cross-platform and vender neutrality characteristics, but require extra computation in processing. In this paper we analyze XML processing overhead {{for the most}} known XML parsers and decide what parser is most suited for a multi-thread <b>server</b> <b>application</b> that will <b>process</b> many streams of XML content, streams {{that can be very}} large. Based on the analysis that was carried on, we offer a solution for XML binding...|$|R
50|$|In {{computer}} networking, upstream {{refers to}} {{the direction in which}} data can be transferred from the client to the server (uploading). This differs greatly from downstream not only in theory and usage, but also in that upstream speeds are usually at a premium. Whereas downstream speed is important to the average home user for purposes of downloading content, uploads are used mainly for web <b>server</b> <b>applications</b> and similar <b>processes</b> where the sending of data is critical. Upstream speeds are also important to users of peer-to-peer software.|$|R
5000|$|Perlbal also {{features}} a so-called [...] "re-proxy" [...] mechanism. This allows a backend webapp to send back a small response to Perlbal which acts as an [...] "internal redirect" [...] and causes it to get the response data from elsewhere. This is often used so that expensive <b>application</b> <b>server</b> <b>processes</b> can defer to much simpler, faster HTTP servers to serve static files, freeing up the <b>application</b> <b>server</b> for other computing work. This is most commonly {{used in conjunction with}} MogileFS.|$|R
40|$|Diploma {{thesis is}} about {{creating}} <b>server</b> <b>application</b> that <b>process</b> and interprets {{data from the}} database. Main aim of such application is able to process {{a large number of}} database requests in real-time environment. Provided database contains records of measuring download speed and quality of mobile connection via different radio technology from various providers. Those measured data are sent from users all around the world and amount of data collected is still growing. Therefore created <b>server</b> <b>application</b> can adapt to increasing size of database thanks to aggregation. This method of aggregation and use of index in database tables are further discussed in the theoretical part. Mainly putting indexes in tables produce significant acceleration of processing database requests. Final product of this thesis is an application that consist of three components: a <b>server</b> <b>application</b> running aggregation, website that interprets measured data and back-end interface providing measured data as well. Data at the website are presented in form of graphs for different countries and used radio technologies. Web address and user manual for finished applications are provided in the fourth chapter of diploma thesis. In the last part of thesis are performed various speed tests of programmed application that confirm the effectiveness of selected and described methods to accelerate work with the database...|$|R
40|$|Abstract- CMP {{processors}} {{are already}} replacing complex single core superscalar processor architectures. They offer better performance per watt and area. This {{is especially true}} in TLP rich <b>server</b> and web <b>applications.</b> <b>Process</b> / thread synchronization is important since CMP consists of multiple processor cores sharing cache resources including shared data structures. This work proposes a locked cache-based shared memory technique suitable for CMP synchronization. A proposed cache coherence protocol, called Lockbased Cache Coherence Protocol (LCCP) was designed and its performance was compared with well known synchronization primitives (LL, SC) using MESI cache coherence protocol. Experiments were performed on the modified MP_Simplesim simulator to implement current proposal. Simulation results show that LCCP outperforms the MESI protocol on the benchmark program...|$|R
40|$|This paper {{describes}} a novel framework used to characterize a J 2 EE (Java Enterprise Edition) application and develop {{models of the}} application by using Java method tracing in a Java-technology based <b>application</b> <b>server.</b> <b>Application</b> <b>servers</b> are critical to large-scale, online servers and serve as middleware to provide secure access to transactional, legacy and web services. The tracing tool in this framework gives a detailed and comprehensive view of the sequences of methods invoked as the <b>application</b> <b>server</b> <b>processes</b> requests. The output of this tool is processed and automatically summarized into a set of transaction profiles which form the input for a simulation model of the <b>application</b> <b>server</b> and its related components. These profiles {{have proven to be}} a useful abstraction of the behavior of the transactions processed by the system. After describing the tool and the model, the paper provides results of validation runs and discusses the usefulness of quantitative measurement, analysis and modeling in some areas of system design and system deployment. The models help architects, designers, developers and deployers explore the different facets of performance during all stages of an application's life-cycle, especially during concept development and prototyping...|$|R
5000|$|JMX is {{supported}} by Java <b>application</b> <b>servers</b> such as OpenCloud Rhino <b>Application</b> <b>Server</b> http://www.opencloud.com/products/rhino-application-server/real-time-application-server/, JBoss, JOnAS, WebSphere <b>Application</b> <b>Server,</b> WebLogic, SAP NetWeaver <b>Application</b> <b>Server,</b> Oracle <b>Application</b> <b>Server</b> 10g and Sun Java System <b>Application</b> <b>Server.</b>|$|R
5000|$|Signaling <b>server</b> <b>applications,</b> {{which include}} SS7 products, handle control {{services}} for calls, such as routing, session control, and status. Signaling <b>server</b> <b>applications</b> {{are characterized by}} sub-millisecond real-time requirements and large numbers of simultaneous connections (10,000 or more). An example signaling <b>server</b> <b>application</b> would include control processing for a rack of line cards.|$|R
40|$|<b>Server</b> <b>applications</b> {{augmented}} with behavioural adaptation logic {{can react}} to environmental changes, creating self-managing <b>server</b> <b>applications</b> with improved {{quality of service}} at runtime. However, developing adaptive <b>server</b> <b>applications</b> is challenging due {{to the complexity of}} the underlying server technologies and highly dynamic application environments. This paper presents an architecture framework, the Adaptive Server Framework (ASF) to facilitate the development of adaptive behaviour for legacy <b>server</b> <b>applications.</b> ASF provides a clear separation between the implementation of adaptive behavior and the business logic of the <b>server</b> <b>application.</b> This means a <b>server</b> <b>application</b> can be extended with programmable adaptive features through the definition and implementation of control components defined in ASF. Furthermore, ASF is a lightweight architecture in that it incurs low CPU overhead and memory usage. We demonstrate the effectiveness of ASF through a case study, in which a <b>server</b> <b>application</b> dynamically determines the resolution and quality to scale an image based on the load of the server and network connection speed. The experimental evaluation demonstrates the performance gains possible by adaptive behavior and the low overhead introduced by ASF...|$|R
5000|$|... iPlanet <b>Application</b> <b>Server</b> (a Java EE <b>application</b> <b>server</b> system, {{based on}} the Netscape <b>Application</b> <b>Server</b> and NetDynamics <b>Application</b> <b>Server)</b> ...|$|R
5000|$|... wlst - Oracle Weblogic <b>Server</b> <b>Application</b> <b>Server</b> tool {{scripting}} using Jython ...|$|R
5000|$|Clients {{can include}} {{database}} <b>servers,</b> <b>application</b> <b>servers,</b> file servers, and individual workstations.|$|R
50|$|SysMaster {{can be used}} {{to monitor}} and manage the {{performance}} of web <b>servers,</b> web <b>application</b> <b>servers,</b> TP monitors, <b>application</b> <b>servers,</b> etc.|$|R
5000|$|TNAPS <b>Application</b> <b>Server,</b> {{freeware}} <b>application</b> <b>server,</b> {{developed by}} TN LLC ...|$|R
40|$|This thesis {{deals with}} the {{development}} of a client-server application for Red Hat company. Client participates in testing process of JBoss platform and gets user-defined performance data which sends during testing to the <b>server</b> <b>application</b> by platform independent communication. The <b>server</b> <b>application</b> allows to analyze the received data which can be also compared by several perspectives. These services for data analysis and comparison are accessible for server users using the web client. The <b>server</b> <b>application</b> supports the import of the performance data stored in the XML file and also their export for qVue portal. The client part of the application is implemented in Java and the <b>server</b> <b>application</b> is based on Java EE platform...|$|R
5000|$|In computing, <b>Server</b> <b>Application</b> Programming Interface (SAPI) is {{the direct}} module {{interface}} to web servers {{such as the}} Apache HTTP Server, Microsoft IIS, and Oracle iPlanet Web Server. Microsoft uses the term Internet <b>Server</b> <b>Application</b> Programming Interface (ISAPI), and the defunct Netscape web server used the term Netscape <b>Server</b> <b>Application</b> Programming Interface (NSAPI) for the same purpose. [...] In other words, SAPI is an application programming interface (API) provided by the web server to help other developers in extending the web server capabilities.|$|R
5000|$|... #Subtitle level 3: Mobile <b>application</b> <b>servers</b> vs. <b>application</b> <b>servers</b> vs. {{web servers}} ...|$|R
5000|$|ISAPI Internet <b>Server</b> <b>Application</b> Programming Interface (Microsoft) ...|$|R
5000|$|Session {{poisoning}} (also {{referred to}} as [...] "session data pollution" [...] and [...] "session modification") is a method to exploit insufficient input validation within a <b>server</b> <b>application.</b> Typically a <b>server</b> <b>application</b> that is vulnerable {{to this type of}} exploit will copy user input into session variables.|$|R
30|$|The {{load on the}} <b>server</b> <b>applications</b> is reduced.|$|R
40|$|<b>Server</b> <b>applications</b> with {{adaptive}} behaviors {{can adapt}} their functionality {{in response to}} environmental changes, and significantly reduce the on-going costs of system deployment and administration. However, developing adaptive <b>server</b> <b>applications</b> is challenging due {{to the complexity of}} server technologies and highly dynamic application environments. This paper presents an architecture framework, known as the Adaptive Server Framework (ASF). ASF provides a clear separation between the implementation of adaptive behaviors and the <b>server</b> <b>application</b> business logic. This means a <b>server</b> <b>application</b> can be cost effectively extended with programmable adaptive features through the definition and implementation of control components defined in ASF. Furthermore, ASF is a lightweight architecture in that it incurs low CPU overhead and memory usage. We demonstrate the effectiveness of ASF through a case study, in which a <b>server</b> <b>application</b> dynamically determines the resolution and quality to scale an image based on the load of the server and network connection speed. The experimental evaluation demonstrates the performance gains possible by adaptive behaviors and the low overhead introduced by ASF...|$|R
5000|$|Perform and {{schedule}} actions on <b>servers,</b> <b>applications</b> and services ...|$|R
5000|$|Diameter Network Access <b>Server</b> <b>Application</b> (NASREQ, RFC 7155)(Obsoletes: RFC 4005) ...|$|R
50|$|Front-end {{processes}} {{relates to}} the software interface between the user (client) and the <b>application</b> <b>processes</b> (<b>server)</b> in the client/server architecture. The user enters input (data) into the front-end process where it is collected and processed {{in such a way}} that it conforms to what the receiving application (back end) on the server can accept and process. As an example, the user enters a URL into a GUI (front-end process) such as Microsoft Internet Explorer. The GUI then processes the URL {{in such a way that}} the user is able to reach or access the intended web pages on the web <b>server</b> (<b>application</b> <b>server</b> known as the “back end” process). Front-end processors or communications processors relates to efficient use of the host CPU by off-loading processing for peripheral control, as an example, to another device or controller.|$|R
40|$|The core of {{this thesis}} is to {{describe}} in detail the design of communication protocol for client/server communication and creation of a functioning <b>server</b> <b>application</b> prototype. REST design approach was used for this communication. This approach uses mainly GET and POST functions of HTTP transport protocol. The <b>server</b> <b>application</b> prototype is created in PHP {{with the help of}} Silex micro-framework. The protocol is designed for mobile clients, which are used for registering into queues and also for administrative clients, which can control and manage the queues. Testing of the designed protocol with <b>server</b> <b>application</b> prototype is described {{at the end of this}} thesis...|$|R
50|$|A CMIS server library allows {{developers}} to create CMIS <b>server</b> <b>applications.</b>|$|R
40|$|General-purpose {{operating}} systems provide inadequate support for large-scale <b>servers.</b> <b>Server</b> <b>applications</b> lack sufficient control over scheduling {{and management of}} machine resources, which {{makes it difficult to}} enforce priority policies, and to provide robust and controlled service. For example, <b>server</b> <b>applications</b> cannot provide differentiated quality of service to requests from different clients. The root cause of these problems is a fundamental mismatch between the original design assumptions underlying the resource management mechanisms of current general-purpose {{operating systems}}, and the behavior of modern <b>server</b> <b>applications.</b> In particular, the notions of protection domain and resource principal coincide in the process abstraction of current operating systems. Moreover, these operating systems provide insufficient control to an application over the resources that are consumed inside the kernel on behalf of the application. These aspects of current operating systems prevent a server process that manages large numbers of network connections, for example, from properly allocating system resources among those connections. This dissertation addresses the lack of operating system support for fine-grained resource management in large-scale server systems. It starts by characterizing the nature of the mismatch between the design assumptions of current general-purpose operating systems, and the behavior of <b>server</b> <b>applications.</b> The traditional design of core operating system abstractions and APIs is reevaluated {{in the light of the}} requirements of <b>server</b> <b>applications.</b> This reevaluation leads to a set of novel operating system abstractions and APIs that serve to provide effective support for <b>server</b> <b>applications...</b>|$|R
40|$|This {{work was}} also {{published}} as a Rice University thesis/dissertation: [URL] operating systems provide inadequate support for large-scale <b>servers.</b> <b>Server</b> <b>applications</b> lack sufficient control over scheduling {{and management of}} machine resources, which {{makes it difficult to}} enforce priority policies, and to provide robust and controlled service. For example, <b>server</b> <b>applications</b> cannot provide differentiated quality of service to requests from different clients. The root cause of these problems is a fundamental mismatch between the original design assumptions underlying the resource management mechanisms of current general-purpose operating systems, and the behavior of modern <b>server</b> <b>applications.</b> In particular, the notions of protection domain and resource principal coincide in the process abstraction of current operating systems. Moreover, these operating systems provide insufficient control to an application over the resources that are consumed inside the kernel on behalf of the application. These aspects of current operating systems prevent a server process that manages large numbers of network connections, for example, from properly allocating system resources among those connections. This dissertation addresses the lack of operating system support for fine-grained resource management in large-scale server systems. It starts by characterizing the nature of the mismatch between the design assumptions of current general-purpose operating systems, and the behavior of <b>server</b> <b>applications.</b> The traditional design of core operating system abstractions and APIs is reevaluated {{in the light of the}} requirements of <b>server</b> <b>applications.</b> This reevaluation leads to a set of novel operating system abstractions and APIs that serve to provide effective support for <b>server</b> <b>applications...</b>|$|R
5000|$|Arxan Code Protection {{to secure}} Mobile, IoT & Embedded, Desktop and <b>Server</b> <b>applications</b> ...|$|R
5000|$|... 15.08, August 2015. Improved EiffelWeb {{solution}} to build web <b>server</b> <b>application.</b> (press release).|$|R
