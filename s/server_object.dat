37|275|Public
5000|$|<b>Server</b> <b>Object</b> Model. Data {{model that}} allows {{developers}} to leverage different services.|$|E
50|$|The rack <b>server</b> <b>object</b> returns a {{response}} which contains three parts: the status, headers and the body.|$|E
5000|$|Keyword Services Platform <b>Server</b> <b>Object</b> Models and Shared Services enable KSP Service Providers {{and stored}} {{procedure}} developers to access server-side objects and functionalities easily and consistently. The object model {{consists of the}} following three collections: ...|$|E
5000|$|... {{translating}} {{incoming data}} from the stub to the correct up-calls to <b>server</b> <b>objects</b> ...|$|R
40|$|This paper {{describes}} {{the design and}} performance of a distributed, multi-tier architecture for scientific data visualization. A novel aspect of this framework is its integration of Java IDL, the CORBA distributed object computing middleware with JavaBeans, the Java Component model to provide a flexible, interactive framework for distributed, highperformance scientific data visualization. CORBA <b>server</b> <b>objects</b> running in a distributed collaborative environment provide data acquisition and perform data-intensive computations. Clients as Java Bean components use these <b>server</b> <b>objects</b> for data retrieval and provide an environment for visualization. The <b>server</b> <b>objects</b> use JDBC, the Java application programming interface to SQL databases, to retrieve data from the database. We discuss the system framework and its components and describe an example application and its performance...|$|R
40|$|<b>Object</b> <b>servers</b> {{offer the}} {{potential}} of improved client caching. However, in comparison to page <b>servers,</b> <b>object</b> <b>servers</b> must perform additional disk reads. These installation reads are required to install modified objects onto their corresponding disk pages. In this paper, we introduce the opportunistic log: a new technique that significantly reduces the cost of these installation reads in <b>object</b> <b>servers.</b> The opportunistic log provides a large pool of pending installation reads that can be scheduled efficiently. Using simulations, we show that the opportunistic log substantially enhances the performance of reliable <b>object</b> <b>servers.</b> An <b>object</b> <b>server</b> without the opportunistic log requires much better client caching to outperform a page server. With an opportunistic log, only a small client cache improvement suffices. Our results affect the fundamental design choice between page-based and object-based servers and imply that efficient scheduling of installation reads is important in future di [...] ...|$|R
5000|$|... class [...] - [...] this is {{the client}} which gets the {{reference}} (a proxy) to the remote object living on the server and invokes its method to get a message. If the <b>server</b> <b>object</b> implemented java.io.Serializable instead of java.rmi.Remote, it would be serialized and passed to the client as a value.|$|E
50|$|A {{skeleton}} acts as gateway {{for server}} side objects and all incoming clients requests are routed through it. The skeletonwraps <b>server</b> <b>object</b> functionality and exposes {{it to the}} clients, moreover by adding the network logic ensures the reliable communication channel between clients and server. Skeletons can be written up manually or generated automatically depending on chosen communication protocol.|$|E
50|$|The <b>server</b> <b>object</b> is {{actually}} a single Java Servlet that gets instantiated at startup, it reads the world definition from its descriptive DXW file and re-creates it in memory. From then on, the main servlet keeps the word's state in memory and accepts client commands to update the position of characters and items of the managed world.|$|E
40|$|Current {{client-server}} object {{database management}} systems employ either a page <b>server</b> or an <b>object</b> <b>server</b> architecture. Both of these architectures have their respective strengths, {{but they also}} have key drawbacks for important system and workload configurations. We propose a new hybrid server architecture which combines the best features of both page <b>server</b> and <b>object</b> <b>server</b> architectures while avoiding their problems. The new archi-tecture incorporates new or adapted versions of data transfer, recovery, and cache consistency al-gorithms; in this paper we focus only on the data transfer and recovery issues. The data transfer mechanism allows the hybrid server to dynami-cally behave as both page and <b>object</b> <b>server.</b> The performance comparison of the hybrid <b>server</b> with <b>object</b> and page <b>servers</b> indicates that the perfor-mance of the hybrid server is more robust than the others. ...|$|R
5000|$|Collaboration Data Objects (CDO), {{previously}} {{known as}} OLE Messaging or Active Messaging, is an {{application programming interface}} included with Microsoft Windows and Microsoft Exchange Server products. The library allows developers to access the Global Address List and other <b>server</b> <b>objects,</b> {{in addition to the}} contents of mailboxes and public folders.|$|R
40|$|Commercially {{available}} middleware systems today offer best-effort Quality-of-Service (QoS) to {{the application}} programs. Due to the natural limitation of resources and {{the differences between the}} priorities and demands of applications, middleware systems must have the capability to offer varying degrees of QoS. The QoS requirements of middleware applications can be monitored and fulfilled by configuring the middleware [1]. This could be implemented, for example, by encapsulating the specific QoS concerns of middleware within the components and by installing the most suitable component on a particular QoS demand. Unfortunately, not all the QoS concerns of a distributed system [2] can be defined and encapsulated by the interfaces of components. So-called crosscutting aspects [3] hinder the adaptation of middleware systems since the implementations of QoS support techniques cannot be restricted to the implementations of components. Consider, for example, a client object that sends a message to a set of <b>server</b> <b>objects.</b> The TCP/IP protocol can be used for this, in case only a few <b>server</b> <b>objects</b> have to receive the message. If, however, the client object wants to send the same message to a large set of <b>server</b> <b>objects,</b> a multicast protocol would be considerably more efficient than the TCP/IP protocol [5]. Transparent QoS management requires the system to automatically switch from TCP/IP to a multicast protocol {{in order to meet the}} QoS demands...|$|R
5000|$|User-User: Allows {{remote access}} by {{the client to}} objects on the server. The User-User {{specification}} goes beyond the definition of specific <b>server</b> <b>object</b> classes to define classes local to the client, {{as well as some}} of the interaction with other parts of the system. The distributed object model is based on CORBA. Objects are accessed using the internet inter-ORB protocol (IIOP), with some optional extensions. Two subsets, [...] "core" [...] and [...] "extended", are defined. In the model, some clients may also load content onto the server.|$|E
50|$|A {{standard}} method to package distributed objects is via an Interface Definition Language (IDL). An IDL shields the client {{of all of}} the details of the distributed <b>server</b> <b>object.</b> Details such as which computer the object resides on, what programming language it uses, what operating system, and other platform specific issues. The IDL is also usually part of a distributed environment that provides services such as transactions and persistence to all objects in a uniform manner. Two of the most popular standards for distributed objects are the Object Management Group's CORBA standard and Microsoft's DCOM.|$|E
40|$|Object-oriented {{frameworks}} {{are structured}} {{in terms of}} client/server relationships between objects; an object's services are invoked by client objects through the operations of its interface. A common design requirement is for a <b>server</b> <b>object</b> to maintain state for each client that it is serving. Typically this is implemented by returning handles or untyped pointers to the client {{that are used to}} identify the per-client data structure holding its state. The lack of strong typing can lead to obscure errors that complicate debugging and maintenance. This paper presents the Type-Safe Session pattern which allows objects to maintain per-client state with full type safety and no loss of efficiency. Intent Allow a <b>server</b> <b>object</b> with many client objects to maintain per-client state and maintain type-safety. Also Known As Service Access Point (SAP), Context, Service Handler. Motivation Object-oriented frameworks are structured in terms of client/server 1 relationships between objects; an [...] ...|$|E
40|$|The Naval Security Group {{currently}} {{requires a}} modem architecture to merge existing command databases {{into a single}} Enterprise Information System through which each command may manipulate administrative data. There are numerous technologies available to build and implement such a system. Component- based architectures are extremely well-suited for creating scalable and flexible three-tier Client/Server systems because the data and business logic are encapsulated within objects, allowing them to be located anywhere on a network. The first tier represents the visual aspects of the data on the client side. The middle tier consists of <b>server</b> <b>objects</b> that represent the persistent data and enforce the business logic functions. The third tier maintains the database management systems. The client interacts with the middle-tier <b>server</b> <b>objects</b> via Common Object Request Broker Architecture. CORBA provides a language and platform independent architecture that enables objects to transparently make requests and receive responses in a distributed environment. Java is an object- oriented, multi-threaded, secure mobile code system that allows applications to run on all major computing platforms. This thesis examines the design of an EIS using Java Applets that use Inter-Orb Protocol to communicate with CORBA middle- tier <b>server</b> <b>objects.</b> The third tier will incorporate Java Database Connectivity to communicate with database management systems. Turkish Army author. U. S. Navy (U. S. N.) author...|$|R
5000|$|SVCO Extension (integrated version-control for Oracle {{database}} <b>server</b> schema <b>objects)</b> ...|$|R
40|$|This {{document}} is a tutorial for Jgroup programmers and describes the Jgroup API. 1. Department of Computer Science, University of Bologna, Mura Anteo Zamboni 7, Bologna 40127 (Italy), Email: fmontresor,davoli,babaoglug@CS. UniBO. IT 1 1 Introduction 1 Introduction The {{last few years}} have seen the emergence of several programming environments that greatly simplify the development of distributed applications. Among them, notable examples are CORBA [9] and Java Remote Method Invocation (RMI) [11]. In order to abstract {{the complexity of the}} system and to promote modularity and reusability, these middleware platforms are based on object-oriented concepts like abstraction, encapsulation, inheritance and polymorphism, and enable client/server interactions among distributed objects: <b>server</b> <b>objects</b> encapsulate an internal state and make it accessible through a well-defined interface; client objects are allowed to access services provided by <b>server</b> <b>objects</b> by issuing remote method invocations o [...] ...|$|R
40|$|Location {{transparency}} {{removes the}} need for client objects to explicitly know or de#ne {{the location of a}} <b>server</b> <b>object</b> when communicating. If a <b>server</b> <b>object</b> is capable of migration, relocation transparency maintains reference validity throughout the migration. Several models for providing location transparency exist, including the home location, forwarding locations and Stub-Scion Pair chain models. This paper proposes a model that uses a distributed registry system and dynamic reference updating to provide location and relocation transparency. A comparison of the models is presented. 1 Introduction A mobile object is an object that is capable of moving, or being moved, readily from one place to another. Mobility within a distributed object system allows mobile enabled objects to move freely between nodes within the distributed system, supporting load balancing #bymoving objects from heavily loaded nodes to lightly loaded nodes#, fault tolerance #bymoving objects to new nodes in res [...] ...|$|E
40|$|The {{intrinsic}} {{features of}} wireless communications remain {{the key factor}} that still limits the performance of mobile applications. It is therefore crucial to provide enabling middleware technology to mask wireless communications limitations and to ease mo-bile and recent pervasive, applications development. This article describes a frame-work, called Domint, which adapts legacy CORBA applications {{so that they can}} keep working when weakly connected or even disconnected. A proxy object represent-ing the remote <b>server</b> <b>object</b> called “disconnected object”, is deployed automatically within the client execution unit. Connectivity management relies on a reconfigurable hysteresis mechanism to avoid too frequent state transfers and switchings between the disconnected object and the remote <b>server</b> <b>object.</b> Application-transparent switch-ing is provided at the middleware level through the use of portable interceptors. We show performance results of a prototype on both PC (with Windows 2000 and Redhat Linux) and an iPAQ PDA (with Windows CE and Linux Familiar). ...|$|E
40|$|ORB. An ORB is the {{software}} bus that connects all {{the objects in}} the system. It enables objects to transparently make requests to-and to receive responses from-other objects located locally or remotely. The client is {{not aware of the}} mechanisms used to communicate with, active, or store the <b>server</b> <b>object.</b> The following figure illustrates the primary components in the CORBA ORB architecture...|$|E
50|$|Ganymede has an {{elaborate}} XML data format {{which can be}} used to import and export the <b>server's</b> <b>object</b> database schema and object data. Importing XML will typically result in the creation, modification, or deletion of database objects, and will trigger one or more network directory service rebuilds just as using the GUI client would do.|$|R
5000|$|JSF as the {{technology}} to develop web based Java applications. The main components of this technology are: an API that presents graphical user interface components able to manage their state, controlling events, execute data validation and transformation client and server side, manage navigation between pages, with multi-language capabilities, accessibility, a set of JSP personalised tags able to represent visual components and bind them towards <b>server</b> <b>objects.</b>|$|R
40|$|In {{this paper}} we present {{the design of}} IRL (Interoperable Replication Logic), a FT-CORBA {{compliant}} platform that provides transparent client-server interactions and server failovers to application clients by using a set of replicated CORBA objects (IRL components). As cooperation among IRL components is carried out using standard CORBA invocations, IRL allows deployments of CORBA <b>server</b> <b>objects</b> and IRL components over ORBs from distinct vendors satisfying the interoperability property...|$|R
40|$|In this thesis, we {{developed}} and implemented the AQuA architecture, which allows a distributed CORBA application {{to request a}} desired level of dependability during the application's runtime. AQuA provides fault-tolerance mechanisms {{to ensure that a}} CORBA client can obtain reliable services, even if the CORBA <b>server</b> <b>object</b> that provides the desired services may suffer from crash failures and value faults. AQuA include...|$|E
40|$|Static {{invocation}} – interface {{is directly}} {{generated in the}} form of stubs by IDL compiler – stub interface is bound at compile time – provides a local method invocation-like semantics – type checking is enforced at compile time – provides much faster performance than dynamic invocation (no preparation for request build-up!) � useful for frequently invoked service Dynamic invocation – provides a more flexible environment – allows to add new classes without requiring changes in the client code – run-time service search is allowed � client can discover <b>server</b> <b>object</b> at run-tim...|$|E
3000|$|In addition, we {{configured}} the emulated MDA setup {{with two}} man-in-the-middle objects. These objects {{are responsible for}} modifying the authentication request frames sent from a mobile client to the cloud server, and authentication response frames sent from the cloud server to a mobile device. Upon creation of the mobile device object, we perform the registration process by sending the registration request to the cloud server. The cloud <b>server</b> <b>object</b> uses SHA 1 algorithm to generate the client and cloud message digests. RSA Keypair generation is performed at the cloud server and the Pk_pub_cloud is sent along with the M [...]...|$|E
40|$|Object-Oriented {{computing}} is {{fast becoming}} the de-facto standard for software development. Optimal deployment strategies for <b>object</b> <b>servers</b> change given variations in <b>object</b> <b>servers,</b> client applications, operational missions, hardware modifications, and various other changes to the environment. Once distributed <b>object</b> <b>servers</b> become more prevalent, {{there will be a}} need to optimize the deployment of <b>object</b> <b>servers</b> to best serve the end usergass changing needs. Having a system that automatically generates <b>object</b> <b>server</b> deployment strategies would allow users {{to take full advantage of}} their network of computers. Many systems have very predictable points in time where the usage of a network changes. These systems are usually characterized by shift changes where the manning and functions preformed change from shift to shift. We propose a pro-active optimization approach that uses predictable indicators like season, mission, and other foreseeable periodic events. The proposed method profiles <b>object</b> <b>servers,</b> client applications, user inputs and network resources. These profiles determine a system of equations that is solved to produce an optimal deployment strategy for the predicted upcoming usage by the users of the system of computers and servers...|$|R
50|$|The <b>server</b> side <b>object</b> {{participating}} in distributed object communication {{is known as}} a skeleton (or stub; term avoided here).|$|R
40|$|This paper {{presents}} {{the design and}} the implementation of Jgroup, {{an extension of the}} Java distributed object model based on the group communication paradigm. Aim of Jgroup is to support the development of dependable applications in partitionable distributed systems. Jgroup consists of a partitionable group communication service that simplifies the cooperation among groups of replicated <b>server</b> <b>objects,</b> and a client-side mechanism to transparently invoke methods on object groups as if they were single, nonreplicated entities...|$|R
40|$|With {{the growing}} {{emphasis}} on distributed applications, sophisticated programming models for handling replication become important. Control replication {{as an issue}} {{has so far been}} considered in the larger context of distributed systems such as ISIS and Arjuna. We present a programming model called ShadowObjects for programming replicated services to cater to the needs of control replication in distributed object oriented systems. The ShadowObjects model provides primitives for building highly available and redundant services. Replication in ShadowObjects is encapsulated and a replica access control mechanism is provided. Messages accessing the services exported by a <b>server</b> <b>object</b> can be captured on-the-fly, and can be appropriately scheduled on the replicas. The ShadowObjects model can be used to develop applications for distributed systems. (C) 199...|$|E
40|$|As {{organizational}} {{computer network}} grows, {{the need to}} manage the network also grows. Some organization using servers sometimes experience prolonged down time due to non- existence or inefficient monitoring system on those applications. This research was carried out on Network Monitoring System with Reference to Application Servers also called Application Server Monitor (ASM) to improve the monitoring system of organization that may be using application servers. The Application detects faults on either TCP server or HTTP server and alerts the operator by displaying {{the states of the}} server on the screen or by making three different sounds signifying various states of the <b>server.</b> <b>Object</b> Oriented Analysis and Design Methodology (OOADM) was adopted in the development of this system. MSc/MASoftware I...|$|E
40|$|Reliability Issues with CORBA Event Channels 		 	X. Defago In {{order to}} {{increase}} flexibility and reduce complexity, the use of distributed platforms such as CORBA for building complex distributed systems is growing significantly. Although CORBA platforms provide a better support than conventional RPC mechanisms for deploying large distributed applications, few developments have been made so far to offer the necessary support for increasing reliability and fault-tolerance. We present here the behavior of inter-object communications in the CORBA reference, and compare it {{with the requirements of}} some type of applications, by focusing on reliability issues. Then we show how it is possible {{to bridge the gap between}} the specification and our requirements, when considering the problem of a <b>server</b> <b>object</b> generating information for a number of independent clients...|$|E
40|$|In a {{distributed}} object system, remoting architecture {{refers to}} the infrastructure that allows client programs to invoke methods on remote <b>server</b> <b>objects</b> in a transparent way. In this paper, we study the strength and limitations of current remoting architecture of COM (Component Object Model), and propose a new architecture called COMERA (COM Extensible Remoting Architecture) to enhance the extensibility and flexibility. We describe several application scenarios and implementations to demonstrate the power of such a componentized remoting architecture...|$|R
50|$|The Ganymede server {{is meant}} to be {{programmed}} by the adopter, who can define arbitrary object data types along with custom logic to interact with the user through the GUI and to maintain consistency within and between objects. Adopters can also create custom tasks which can be executed at specified times by the internal Ganymede scheduler. Such custom tasks can make changes in the <b>server's</b> <b>object</b> database and/or can run external scripts to update external services.|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedDistributed object oriented (OO) computing such as RMI, COBRA and SOAP etc {{is fast becoming}} the defacto standard for software development. The aim of the system designer {{is to determine the}} optimal deployment strategy for the system to perform efficiently. This is an enormous task especially when multiple <b>object</b> <b>servers</b> are fielded on hardware of different specifications. The number of possible deployment strategy of <b>object</b> <b>servers</b> to hardware grows exponentially with increase number of <b>object</b> <b>server</b> and machine. For example, with 3 machines and 10 <b>object</b> <b>servers</b> there are 59049 possible deployment patterns. Eventually, the number of possible deployment makes it impossible for system designer to setup test bed to determine the optimal deployment strategy. The main goal of the simulation model is to analyze the <b>object</b> <b>server</b> deployment, verify an existing optimization model and to determine the optimal deployment strategy that will reduce the client response time. In one of the experiment conducted with the simulation model, in an environment with 3 machine and 10 <b>object</b> <b>servers,</b> it will take 53 years to attempt all deployment patterns in the lab environment. The simulation model will take only 13 days, which is an improvement of 1480 %. Civilian, Ministry of Defense Singapor...|$|R
