0|617|Public
40|$|Abstract — Zerotrees of wavelet {{coefficients}} {{have shown}} a good adaptability for the compression of three dimensional images. EZW, the original algorithm using zerotree, shows good performance and was successfully adapted to 3 D image compression. This paper focuses on the adaptation of EZW for the compression of hyperspectral images. The subordinate pass is suppressed to remove the necessity to keep the significant pixels in memory. To compensate the loss due to this removal, <b>signed</b> <b>binary</b> <b>digit</b> representations are used {{to increase the efficiency}} of zerotrees. Contextual arithmetic coding with very limited contexts is also used. Finally, we show that this simplified version of 3 D-EZW performs almost as well as the original one. Index Terms — Compression, EZW, hyperspectral, <b>signed</b> <b>binary</b> <b>digit</b> representation...|$|R
40|$|Abstract: We {{present an}} {{approach}} to verified programs for exact real number com-putation {{that is based on}} inductive and coinductive definitions and program extrac-tion from proofs. We informally discuss the theoretical background of this method and give examples of extracted programs implementing the translation between the representation by fast converging rational Cauchy sequences and the <b>signed</b> <b>binary</b> <b>digit</b> representations of real numbers...|$|R
40|$|Abstract [...] This work {{presents}} an improved {{design for a}} carryfree adder featuring on-line error detection. The salient contribution of this work is an extremely quick and costeffective method of conversion from either two's complement or signed magnitude format into the internal 1 -out-of- 3 code used within this adder. Index Terms [...] carry-free addition, on-line error detection, <b>signed</b> <b>binary</b> <b>digits,</b> 1 -out-of- 3 cod...|$|R
30|$|Zerotrees of wavelet {{coefficients}} {{have shown}} a good adaptability for the compression of three-dimensional images. EZW, the original algorithm using zerotree, shows good performance and was successfully adapted to 3 D image compression. This paper focuses on the adaptation of EZW for the compression of hyperspectral images. The subordinate pass is suppressed to remove the necessity to keep the significant pixels in memory. To compensate the loss due to this removal, <b>signed</b> <b>binary</b> <b>digit</b> representations are used {{to increase the efficiency}} of zerotrees. Contextual arithmetic coding with very limited contexts is also used. Finally, we show that this simplified version of 3 D-EZW performs almost as well as the original one.|$|R
40|$|In {{this paper}} {{we present a}} method for {{improving}} the performance of RSA-type exponentiations. The scheme {{is based on the}} observation that replacing the exponent d by d 0 = d + k'(n) has no arithmetic impact but results in significant speed-ups when k is properly chosen. Statistical analysis, verified by extensive simulations, confirms a performance improvement of 9. 3 % for the square-and-multiply scheme and 4. 3 % for the <b>signed</b> <b>binary</b> <b>digit</b> algorithm. However, the most attractive feature of our method seems to be the fact that in most cases, existing exponentiation black-boxes can be accelerated by simple external one-time pre-computations without any internal code or hardware modifications...|$|R
40|$|Zerotrees of wavelet {{coefficients}} {{have shown}} a good adaptability for the compression of three-dimensional images. EZW, the original algorithm using zerotree, shows good performance and was successfully adapted to 3 D image compression. This paper focuses on the adaptation of EZW for the compression of hyperspectral images. The subordinate pass is suppressed to remove the necessity to keep the significant pixels in memory. To compensate the loss due to this removal, <b>signed</b> <b>binary</b> <b>digit</b> representations are used {{to increase the efficiency}} of zerotrees. Contextual arithmetic coding with very limited contexts is also used. Finally, we show that this simplified version of 3 D-EZW performs almost as well as the original one. </p...|$|R
40|$|Title: <b>Binary</b> <b>Signed</b> <b>Digit</b> Representations of Integers in Cryptanalysis of Hash Functions Author: Jiří Vábek Department: Department of Algebra Supervisor: doc. RNDr. Jiří Tůma, DrSc., Department of Algebra Abstract: The work {{summarizes}} {{two main}} papers, A New Type of 2 -block Colli- sions in MD 5 and On the Number of <b>Binary</b> <b>Signed</b> <b>Digit</b> Representations of a Given Weight, while containing also the wider {{introduction to the}} topic of crypt- analysis of MD 5 and <b>binary</b> <b>signed</b> <b>digit</b> representations (BSDR's). In the first paper we have implemented and applied Stevens algorithm to the newly proposed initial message differences and constructed a new type of collisions in MD 5. In the second paper we have introduced and proved a new improved bound for the number of optimal BSDR's and also a new recursive bound for the number of BSDR's of a given integer with a given overweight. In addition to the results in mentioned papers, the generalized result is stated with the new bound for the number of optimal D-representations of natural numbers with D = { 0, 1, 3 }. Keywords: hash function, MD 5, <b>binary</b> <b>signed</b> <b>digit</b> representation (BSDR), non- adjacent form (NAF) ...|$|R
40|$|In {{this paper}} a {{comparator}} is designed using Redundant <b>Binary</b> <b>Signed</b> <b>Digit</b> (RBSD) Number System. Radix- 2 or <b>signed</b> <b>binary</b> <b>digit</b> number representations {{are of particular}} interest here. The redundant number system can be implemented by a digit set which has more digits in the set than {{the value of the}} radix and the set consists of digits} 1, 0, 1 { + −. This allows a given number to have more than one representation. Each digit within these digit sets with the exception of zero is present in both positive and negative polarities. The RBSD comparator is designed by VHDL as well as in Verilog and its RTL view is generated by its FPGA implementation. Keeping view the low power VLSI design, the gate level circuit is implemented by CMOS with the help of Verilog and its mask level Layout is designed and simulated. The FPGA Implementation is done by Libero IDE v 6 environment, which is a product of Actel Inc. The mask level layout design is done by the high end EDA tool i. e. Microwind 2. For the performance evaluation it is compared with binary comparator...|$|R
40|$|Several cryptosystems rely on fast {{calculations}} of linear combinations in groups. One {{way to achieve}} this is to use joint <b>signed</b> <b>binary</b> <b>digit</b> expansions of small “weight. ” We study two algorithms, one based on non adjacent forms of the coefficients of the linear combination, the other based on a certain joint sparse form specifically adapted to this problem. Both methods are sped up using the sliding windows approach combined with precomputed lookup tables. We give explicit and asymptotic results {{for the number of}} group operations needed assuming uniform distribution of the coefficients. Expected values, variances and a central limit theorem are proved using generating functions. Furthermore, we provide a new algorithm which calculates the digits of an optimal expansion of pairs of integers from left to right. This avoids storing the whole expansion, which is needed with the previously known right to left methods, and allows an online computation...|$|R
40|$|Abstract. SRT {{division}} schemes {{are presented}} {{based on a}} redundant number operand format aiming high speed operation. The proposed SRT division method based on a redundant binary adder (RBA) and one based on a recoded <b>binary</b> <b>signed</b> <b>digit</b> adder (RBSDA) show a 33 % and 50 % speed improvement, respectively. The time complexity of the proposed division based on redundant number is O(n); importantly, the redundant number based design is easy to implement due to its structural regularity...|$|R
40|$|Abstract. We give a coinductive {{characterisation}} {{of the set}} {{of continuous}} functions defined on a compact real interval, and extract certified programs that construct and combine exact real number algorithms {{with respect to the}} <b>binary</b> <b>signed</b> <b>digit</b> representation of real numbers. The data type corresponding to the coinductive definition of continuous functions consists of finitely branching non-wellfounded trees describing when the algorithm writes and reads digits. This is a pilot study in using proof-theoretic methods for obtaining certified algorithms in exact real arithmetic. ...|$|R
40|$|Based {{on a new}} coinductive {{characterization}} of continuous functions we extract certified programs for exact real number computation from constructive proofs. The extracted programs construct and combine exact real number algorithms {{with respect to the}} <b>binary</b> <b>signed</b> <b>digit</b> representation of real numbers. The data type corresponding to the coinductive definition of continuous functions consists of finitely branching non-wellfounded trees describing when the algorithm writes and reads digits. We discuss several examples including the extraction of programs for polynomials up to degree two and the definite integral of continuous maps...|$|R
40|$|We {{present the}} {{analysis}} and design of a FIR filter with balanced ternary coefficients (i. e., - 1, 0, + 1) suitable for FPGA implementation. The ternary filter taps were generated using a S-M process in MATLAB® and the filter implemented in VHDL. An efficient fast adder structure accumulates the partial multiplication products. Two alternative implementations in 2 &# 039;s complement and redundant <b>binary</b> <b>signed</b> <b>digit</b> representations are compared {{on a range of}} commercial FPGA devices for both pipelined and nonpipelined organizations. Using a high performance device, the filter can operate at clock rates of more than 400 MHz...|$|R
40|$|Abstract. We study a realisability {{interpretation}} for inductive and coinductive {{definitions and}} discuss {{its application to}} program extraction from proofs. A speciality of this interpretation is that realisers are given by terms that correspond directly to programs in a lazy functional programming language such as Haskell. Programs extracted from proofs using coinduction {{can be understood as}} perpetual processes producing infinite streams of data. Typical applications of such processes are computations in exact real arithmetic. As an example we show how to extract a program computing the average of two real numbers w. r. t. to the <b>binary</b> <b>signed</b> <b>digit</b> representation. ...|$|R
40|$|Side channel {{attacks are}} a very serious menace to {{embedded}} devices with cryptographic applications. To counteract such attacks many randomization techniques have been proposed. One efficient technique in elliptic curve cryptosystems randomizes addition chains with <b>binary</b> <b>signed</b> <b>digit</b> (BSD) representations of the secret key. However, when such countermeasures have been used alone, {{most of them have}} been broken by various simple power analysis attacks. In this paper, we consider combinations which can enhance the security of countermeasures using BSD representations by adding additional countermeasures. First, we propose several ways the improved countermeasures based on BSD representations can be attacked. In an actual statistical power analysis attack, the number of samples plays an important role. Therefore, we estimate the number of samples needed in the proposed attack...|$|R
40|$|Applications of signed digit {{representations}} of an integer include computer arith-metic, cryptography, and digital signal processing. An integer of length n bits can have several <b>binary</b> <b>signed</b> <b>digit</b> (BSD) representations and their number {{depends on its}} value and varies with its length. In this paper, we present an algorithm that calculates {{the exact number of}} BSD {{representations of}} an integer of a certain length. We formulate the integer that has the maximum number of BSD representations among all integers of the same length. We also present an algorithm to generate a random BSD representation for an integer starting from the most significant end and its modified version which gener-ates all possible BSD representations. We show how the number of BSD representations of k increases as we prepend 0 s to its binary representation. ...|$|R
40|$|The {{objective}} {{of this paper is}} to provide a theoretical foundation for program extraction from inductive and coinductive proofs geared to practical applications. The novelties consist in the addition of inductive and coinductive definitions to a realizability interpretation for first-order proofs, a soundness proof for this system, and applications to the synthesis of non-trivial provably correct programs in the area of exact real number computation. We show that realizers, although per se untyped, can be assigned polymorphic recursive types and hence represent valid programs in a lazy functional programming language such as Haskell. Programs extracted from proofs using coinduction can be understood as perpetual processes producing infinite streams of data. Typical applications of such processes are computations in exact real arithmetic. As an example we show how to extract a program computing the average of two real numbers w. r. t. the <b>binary</b> <b>signed</b> <b>digit</b> representation. ...|$|R
40|$|Abstract. The recent {{development}} of side channel attacks has lead implementers to use increasingly sophisticated countermeasures in critical operations such as modular exponentiation, or scalar multiplication on elliptic curves. A {{new class of}} countermeasures is based on inserting random decisions when choosing one representation of the secret scalar out of a large set of representations of the same value. For instance, {{this is the case}} of countermeasures proposed by Oswald and Aigner, or Ha and Moon, both based on randomized <b>Binary</b> <b>Signed</b> <b>Digit</b> (BSD) representations. Their advantage is to offer excellent speed performances. However, the first countermeasure and a simplified version of the second one were already broken using Markov chain analysis. In this paper, we take a different approach to break the full version of Ha-Moon’s countermeasure using a novel technique based on detecting local collisions in the intermediate states of computation. We also show that randomized BSD representations present some fundamental problems and thus recommend not to use them as a protection against side-channel attacks. ...|$|R
40|$|It is {{essential}} to secure the implementation of cryptosystems in embedded devices agains side-channel attacks. Namely, in order to resist differential (DPA) attacks, randomization techniques should be employed to decorrelate the data processed by the device from secret key parts resulting {{in the value of}} this data. Among the countermeasures that appeared in the literature were those that resulted in a random representation of the key known as the <b>binary</b> <b>signed</b> <b>digit</b> representation (BSD). We have discovered some interesting properties related to the number of possible BSD representations for an integer and we have proposed a different randomization algorithm. We have also carried our study to the τ-adic representation of integers which is employed in elliptic curve cryptosystems (ECCs) using Koblitz curves. We have then dealt with another randomization countermeasure which is based on randomly splitting the key. We have investigated the secure employment of this countermeasure in the context of ECCs...|$|R
40|$|International audienceThe recent {{development}} of side channel attacks has lead implementers to use increasingly sophisticated countermeasures in critical operations such as modular exponentiation, or scalar multiplication on elliptic curves. A {{new class of}} countermeasures is based on inserting random decisions when choosing one representation of the secret scalar out of a large set of representations of the same value. For instance, {{this is the case}} of countermeasures proposed by Oswald and Aigner, or Ha and Moon, both based on randomized <b>Binary</b> <b>Signed</b> <b>Digit</b> (BSD) representations. Their advantage is to offer excellent speed performances. However, the first countermeasure and a simplified version of the second one were already broken using Markov chain analysis. In this paper, we take a different approach to break the full version of Ha-Moons countermeasure using a novel technique based on detecting local collisions in the intermediate states of computation. We also show that randomized BSD representations present some fundamental problems and thus recommend not to use them as a protection against side-channel attacks...|$|R
25|$|In computers, {{the main}} numeral systems {{are based on}} the {{positional}} system in base2 (binary numeral system), with two <b>binary</b> <b>digits,</b> 0 and 1. Positional systems obtained by grouping <b>binary</b> <b>digits</b> by three (octal numeral system) or four (hexadecimal numeral system) are commonly used. For very large integers, bases232 or 264 (grouping <b>binary</b> <b>digits</b> by 32 or 64, the length of the machine word) are used, as, for example, in GMP.|$|R
50|$|In 1998 Simon Plouffe gave a ruler and compass {{algorithm}} {{that can}} be used to compute <b>binary</b> <b>digits</b> of certain numbers.The algorithm involves the repeated doubling of an angle and becomes physically impractical after about 20 <b>binary</b> <b>digits.</b>|$|R
50|$|The {{symbol for}} <b>binary</b> <b>digit</b> is either simply bit (recommended by the IEC 80000-13:2008 standard) or {{lowercase}} b (recommended by the IEEE 1541-2002 standard). A {{group of eight}} <b>binary</b> <b>digits</b> is commonly called one byte, but historically {{the size of the}} byte is not strictly defined.|$|R
5000|$|The bit (a {{portmanteau}} of <b>binary</b> <b>digit)</b> is a {{basic unit}} of information used in computing and digital communications. A <b>binary</b> <b>digit</b> can have only one of two values, and may be physically represented with a two-state device. These state values are most commonly represented as either a [...]|$|R
50|$|The octal and {{hexadecimal}} {{systems are}} often used in computing because of their ease as shorthand for <b>binary.</b> Every hexadecimal <b>digit</b> corresponds to a sequence of four <b>binary</b> <b>digits,</b> since sixteen is the fourth power of two; for example, hexadecimal 7816 is binary 2. A similar relationship holds between every octal digit and every possible sequence of three <b>binary</b> <b>digits,</b> since eight is the cube of two.|$|R
40|$|This paper {{presents}} {{the design and}} synthesis of a single-bit ternary fi nite impulse response fi lter with balanced ternary coeffi cients (ie. &ndash; 1, 0, + 1) implemented in VHDL on small commercial fi eld programmable gate arrays (FPGAs). A comparison is made between implementations based on 2 s complement, redundant <b>binary</b> <b>signed</b> <b>digit</b> (RBSD) and canonical signed digit (CSD) encoding techniques. Through simulation, the area and performance of an example fi lter are analysed using pipelined and non-pipelined modes for all three techniques. The simulation results show that, unlike in the equivalent multi-bit fi lters, CSD offers no advantages in single-bit sigma-delta modulated (ΣΔM) systems. Similarly, RBSD occupies twice the area and exhibits much poorer performance compared to a conventional 2 s complement representation due to the small symbol size in single-bit systems. These results demonstrate that simple, short word length ΣΔM fi lters will be useful in greatly {{reducing the number of}} general-purpose digital multipliers in general purpose digital signal processor applications using FPGA and especially ASIC...|$|R
5000|$|Equivalently, {{expressed}} as strings of <b>binary</b> <b>digits,</b> the codewords are: ...|$|R
5000|$|... so the 8th to 11th <b>binary</b> <b>digits</b> in the <b>binary</b> {{expansion}} of ln(2) are 1, 0, 1, 1. Note {{that we have}} not calculated the values of the first seven <b>binary</b> <b>digits</b> - indeed, all information about them has been intentionally discarded by using modular arithmetic in the [...] "head" [...] sum.|$|R
5000|$|The {{symbol rate}} {{is related to}} gross bit rate {{expressed}} in bit/s.The term baud has sometimes incorrectly been used to mean bit rate, since these rates are the same in old modems {{as well as in}} the simplest digital communication links using only one bit per symbol, such that <b>binary</b> <b>digit</b> [...] "0" [...] is represented by one symbol, and <b>binary</b> <b>digit</b> [...] "1" [...] by another symbol. In more advanced modems and data transmission techniques, a symbol may have more than two states, so it may represent more than one bit. A bit (<b>binary</b> <b>digit)</b> always represents one of two states.|$|R
50|$|Append the {{remaining}} N <b>binary</b> <b>digits</b> to this representation of N+1.|$|R
5000|$|The Ehrenfeucht-Mycielski {{sequence}}, {{a sequence}} of <b>binary</b> <b>digits</b> with pseudorandom properties ...|$|R
5000|$|... 18 <b>binary</b> <b>digits</b> have [...] (1000000 octal, 40000 hexadecimal) {{distinct}} combinations.|$|R
5000|$|Append the {{remaining}} N <b>binary</b> <b>digits</b> of x to this representation of N.|$|R
40|$|AbstractA {{new family}} of {{increasing}} sequences of positive integers is proposed. The integers n {{for which the}} sum of <b>binary</b> <b>digits</b> {{is equal to the}} sum of <b>binary</b> <b>digits</b> of n 2 are an example of sequence of this family and this sequence is more accurately studied. Some structure and asymptotic properties are proved and a conjecture about its counting function is discussed...|$|R
50|$|The {{message is}} written with only four basic symbols {{representing}} the <b>binary</b> <b>digits</b> one and zero and {{open and close}} brackets. Numbers are represented as a string of <b>binary</b> <b>digits</b> between a pair of brackets and expressions are represented as a string of numbers between brackets. Identifiers for operations are arbitrarily-assigned numbers and their functions can be defined within the message itself.|$|R
2500|$|... 1995– Simon Plouffe discovers Bailey–Borwein–Plouffe formula {{capable of}} finding the nth <b>binary</b> <b>digit</b> of π.|$|R
