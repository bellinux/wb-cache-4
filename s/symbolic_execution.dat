1016|31|Public
500|$|His paper [...] "Symbolic {{evaluation}} {{and the global}} value graph" [...] (1977, with his student John Reif) concerned data-flow analysis and <b>symbolic</b> <b>execution</b> in compilers.|$|E
50|$|Implementation of {{traditional}} <b>symbolic</b> <b>execution</b> based testing requires {{the implementation of}} a full-fledged symbolic interpreter for a programming language. Concolic testing implementor noticed that implementation of a full-fledged <b>symbolic</b> <b>execution</b> can be avoided if <b>symbolic</b> <b>execution</b> can be piggy-backed with the normal execution of a program through instrumentation. This idea of simplifying implementation of <b>symbolic</b> <b>execution</b> gave birth to concolic testing.|$|E
5000|$|Dynamic <b>symbolic</b> <b>execution.</b> In <b>symbolic</b> <b>execution</b> {{programs}} are executed and monitored symbolically, that is, without concrete inputs. One <b>symbolic</b> <b>execution</b> {{of the system}} may cover a large set of concrete inputs. Off-the-shelf constraint solving or satisfiability checking techniques are often used to drive symbolic executions or to systematically explore their space. When the underlying satisfiability checkers cannot handle a choice point, then a concrete input can be generated to pass that point; this combination of concrete and <b>symbolic</b> <b>execution</b> is {{also referred to as}} concolic execution.|$|E
5000|$|Detecting runtime {{exceptions}} {{by means}} of <b>symbolic</b> code <b>execution,</b> for Java only ...|$|R
30|$|The {{semantics}} {{of program}} consists of data abstractions and control flows. Checking complete semantics {{is the best}} for detecting changes in the software, but it needs computationally expensive methods, such as flawless <b>symbolic</b> <b>executions.</b> IoT devices are constrained in computation and power to support such expensive operations. Hence, we narrow our focus on more effective targets; CodeDog detects the change of control flow in the program binary code. To do so, it injects semantics markers to the binary code before and after control transfer statements. The semantics markers also bear the conditions of branches. Thus, unintended changes in control flows can be revealed with only semantics markers in the program code.|$|R
5000|$|Almost {{all of the}} popes {{are shown}} within cage like {{structures}} and screaming or about to scream. Bacon identified as a Nietzschean and atheist, and some contemporary critics saw the series as <b>symbolic</b> <b>executions</b> scenes, as if Bacon sought to follow through the Nietzsche's God is dead declaration by killing his representative on earth. Other critics say it as a symbolic killing of a father figure However Bacon balked at such literal translations, and later {{said that it was}} Velázquez himself he sought to [...] "triumph over". He said that {{in the same way that}} Velázquez cooled Titian, he sought to [...] "cool" [...] Velázquez.|$|R
50|$|The {{concept of}} <b>symbolic</b> <b>execution</b> was {{introduced}} academically with descriptions of: the Select system,the EFFIGY system,the DISSECT system,and Clarke's system.See a bibliography of more technical papers published on <b>symbolic</b> <b>execution.</b>|$|E
50|$|The <b>Symbolic</b> <b>Execution</b> Debugger visualizes {{the control}} flow {{of a program}} as a <b>symbolic</b> <b>execution</b> tree that {{contains}} all feasible execution paths through the program {{up to a certain}} point. It is provided as a plugin to the Eclipse development platform.|$|E
50|$|<b>Symbolic</b> <b>execution</b> is a white-box {{technique}} that executes a program symbolically, computes constraints along different paths, {{and uses a}} constraint solver to generate inputs that satisfy the collected constraints along each path. <b>Symbolic</b> <b>execution</b> {{can also be used}} to generate input for differential testing.|$|E
40|$|We {{introduce}} a <b>symbolic</b> interpretation and <b>execution</b> technique for Extended Finite Automata (EFAs) {{and provide an}} interpreter that symbolically interprets and executes EFAs w. r. t. their (internal) variables. More specifically, the interpreter iterates over the EFA transitions, and by passing each transition, it symbolically interprets and evaluates the condition on the transition w. r. t. the known values of variables, and leaves other variables intact, and when it terminates, it returns the residual model. It is shown that {{the behavior of the}} residual system with respect to the original system is left unchanged. Finally, we demonstrate the effectiveness and necessity of the <b>symbolic</b> interpretation and <b>execution</b> combined with abstractions for the nonblocking supervisory control of two manufacturing systems...|$|R
40|$|The {{systematic}} {{exploration of}} the space of all the behaviours of a software system forms the basis of numerous approaches to verification. However, existing approaches face many challenges with scalability and precision. We propose a framework for validating programs based on statistical sampling of inputs guided by statically generated constraints, that steer the simulations towards more “desirable ” traces. Our approach works iteratively: each iteration first simulates the system on some inputs sampled from a restricted space, while recording facts about the simulated traces. Subsequent iterations of the process attempt to steer the future simulations away from what has already {{been seen in the}} past iterations. This is achieved by two separate means: (a) we perform <b>symbolic</b> <b>executions</b> in order to guide the choice of inputs, and (b) we sample from the input space using a probability distribution specified by means of previously observed test data using a Markov Chain Monte-Carlo (MCMC) technique. As a result, the sampled inputs generate traces that are likely to be significantly different from the observations in the previous iterations in some user specified ways. We demonstrate that our approach is effective. It can rapidly isolate rare behaviours of systems that reveal more bugs...|$|R
40|$|International audienceWe {{present in}} this paper the {{application}} of constraint solving techniques to the validation and automated test cases generation for Java programs, annotated with JML specifications. The Java/JML code is translated into a constraint representation based on {{a subset of the}} set-theory, which is well-suited for modelling object-oriented programs. <b>Symbolic</b> code <b>execution</b> techniques can then be applied to produce test cases, using classical structural test selection criteria, or to detect possible runtime errors, and non-conformances between the Java code and its embedded JML model...|$|R
5000|$|... #Subtitle level 3: Constraint logic {{programming}} and <b>symbolic</b> <b>execution</b> ...|$|E
50|$|Entire test suites or {{test cases}} exposing real bugs can be {{automatically}} generated by software using model checking or <b>symbolic</b> <b>execution.</b> Model checking can ensure all {{the paths of}} a simple program are exercised, while <b>symbolic</b> <b>execution</b> can detect bugs and generate a test case that will expose the bug when the software is run using this test case.|$|E
5000|$|Sireum/Kiasan, a <b>symbolic</b> <b>execution</b> based static {{analyzer}} which supports JML as a contract language.|$|E
40|$|In this {{functional}} pearl, {{we examine}} the use of definitional interpreters {{as a basis for}} abstract interpretation of higher-order programming languages. As it turns out, definitional interpreters, especially those written in monadic style, can provide a nice basis {{for a wide variety of}} collecting semantics, abstract interpretations, <b>symbolic</b> <b>executions,</b> and their intermixings. But the real insight of this story is a replaying of an insight from Reynold's landmark paper, Definitional Interpreters for Higher-Order Programming Languages, in which he observes definitional interpreters enable the defined-language to inherit properties of the defining-language. We show the same holds true for definitional abstract interpreters. Remarkably, we observe that abstract definitional interpreters can inherit the so-called "pushdown control flow" property, wherein function calls and returns are precisely matched in the abstract semantics, simply by virtue of the function call mechanism of the defining-language. The first approaches to achieve this property for higher-order languages appeared within the last ten years, and have since been the subject of many papers. These approaches start from a state-machine semantics and uniformly involve significant technical engineering to recover the precision of pushdown control flow. In contrast, starting from a definitional interpreter, the pushdown control flow property is inherent in the meta-language and requires no further technical mechanism to achieve...|$|R
40|$|We {{study the}} {{fundamental}} issue of decidability of satisfiability over string logics with concatenations and finite-state transducers as atomic operations. Although restricting to {{one type of}} operations yields decidability, {{little is known about}} the decidability of their combined theory, which is especially relevant when analysing security vulnerabilities of dynamic web pages in a more realistic browser model. On the one hand, word equations (string logic with concatenations) cannot precisely capture sanitisation functions (e. g. htmlescape) and implicit browser transductions (e. g. innerHTML mutations). On the other hand, transducers suffer from the reverse problem of being able to model sanitisation functions and browser transductions, but not string concatenations. Naively combining word equations and transducers easily leads to an undecidable logic. Our main contribution is to show that the "straight-line fragment" of the logic is decidable (complexity ranges from PSPACE to EXPSPACE). The fragment can express the program logics of straight-line string-manipulating programs with concatenations and transductions as atomic operations, which arise when performing bounded model checking or dynamic <b>symbolic</b> <b>executions.</b> We demonstrate that the logic can naturally express constraints required for analysing mutation XSS in web applications. Finally, the logic remains decidable in the presence of length, letter-counting, regular, indexOf, and disequality constraints. Comment: Full version of POPL' 16 pape...|$|R
40|$|Increasing {{complexity}} in development of real-time systems {{accompanied by the}} demand for enabling their configurability requires the integration of aspect-oriented software development with real-time system development. Since software technology for building real-time systems has to support predictability in the time domain, methods and tools for analyzing temporal behavior of the aspectoriented software are needed. Knowing worst-case execution time is of primary importance for timing analysis of real-time systems. We contribute by providing support for predictable aspect-oriented software development, by enabling <b>symbolic</b> worst-case <b>execution</b> time analysis of the aspect-oriented software systems...|$|R
5000|$|... {{state space}} enumeration, {{symbolic}} state space enumeration, abstract interpretation, symbolic simulation, symbolic trajectory evaluation, <b>symbolic</b> <b>execution</b> ...|$|E
5000|$|... {{bytecode}} factories - {{to provide}} alternative execution semantics of bytecode instructions (e.g. to implement <b>symbolic</b> <b>execution)</b> ...|$|E
5000|$|Jalangi is an {{open-source}} concolic {{testing and}} <b>symbolic</b> <b>execution</b> tool for JavaScript. Jalangi supports integers and strings.|$|E
40|$|<b>Symbolic</b> and concolic <b>execution</b> find {{important}} {{applications in}} a number of security-related program analyses, including analysis of malicious code. However, malicious code tend to very often be obfuscated, and current concolic analysis tech-niques have trouble dealing with some of these obfuscations, leading to imprecision and/or excessive resource usage. This paper discusses three such obfuscations: two of these are al-ready found in obfuscation tools used by malware, while the third is a simple variation on an existing obfuscation tech-nique. We show empirically that existing symbolic analyses are not robust against such obfuscations, and propose ways in which the problems can be mitigated using a combination of fine-grained bit-level taint analysis and architecture-aware constraint generations. Experimental results indicate that our approach is effective in allowing <b>symbolic</b> and concolic <b>execution</b> to handle such obfuscations...|$|R
40|$|Artículo de publicación ISIWe {{study the}} {{fundamental}} issue of decidability of satisfiability over string logics with concatenations and finite-state transducers as atomic operations. Although restricting to {{one type of}} operations yields decidability, {{little is known about}} the decidability of their combined theory, which is especially relevant when analysing security vulnerabilities of dynamic web pages in a more realistic browser model. On the one hand, word equations (string logic with concatenations) cannot precisely capture sanitisation functions (e. g. htmlescape) and implicit browser transductions (e. g. innerHTML mutations). On the other hand, transducers suffer from the reverse problem of being able to model sanitisation functions and browser transductions, but not string concatenations. Naively combining word equations and transducers easily leads to an undecidable logic. Our main contribution is to show that the "straightline fragment" of the logic is decidable (complexity ranges from PSPACE to EXPSPACE). The fragment can express the program logics of straight-line string-manipulating programs with concatenations and transductions as atomic operations, which arise when performing bounded model checking or dynamic <b>symbolic</b> <b>executions.</b> We demonstrate that the logic can naturally express constraints required for analysing mutation XSS in web applications. Finally, the logic remains decidable in the presence of length, letter counting, regular, indexOf, and disequality constraints. Yale-NUS College through the MoE 	 R- 607 - 265 - 056 - 121 IG 15 -LR 001 Millenium Nucleus Center for Semantic Web Research 	 NC 12000...|$|R
25|$|Captain De Jong {{was acquitted}} of the charge of treason, for lack of evidence, but {{he was convicted of}} {{dereliction}} of duty. He was cashiered; had to undergo a <b>symbolic</b> simulated <b>execution</b> (whereby a sword was swung over his head), and was banished for life. The trials were then suspended in hope that the absent officers would become available. In July 1801 the trial was resumed with new indictments against officers who had surrendered ships on earlier occasions or been otherwise derelict. Several other officers were punished in an attempt to make clear to the officer corps that surrender without a fight was unacceptable.|$|R
5000|$|During that, program {{modalities}} {{are eliminated}} by <b>symbolic</b> <b>execution.</b> For instance, the formula [...] is logically equivalent to [...] As this example shows, <b>symbolic</b> <b>execution</b> in dynamic logic {{is very similar}} to calculating weakest preconditions. Both [...] and [...] essentially denote the same thing - with two exceptions: Firstly, [...] is a function of some meta-calculus while [...] really is a formula of the given calculus. Secondly, <b>symbolic</b> <b>execution</b> runs through the program forward just as an actual execution would. To save intermediate results of assignments, KeY introduces a concept called updates, which are similar to substitutions but are only applied once the program modality has been fully eliminated. Syntactically, updates are consist of parallel (side-effect free) assignments written in curly braces in front of a modality. An example of <b>symbolic</b> <b>execution</b> with updates: [...] is transformed to [...] in the first step and to [...] in the second step. The modality then is empty and [...] "backwards application" [...] of the update to the postcondition yields a precondition where [...] could take any value.|$|E
5000|$|<b>Symbolic</b> <b>execution,</b> as used {{to derive}} {{mathematical}} expressions representing {{the value of}} mutated variables at particular points in the code.|$|E
5000|$|Programs {{interact}} with their environment by performing system calls, receiving signals, etc. Consistency problems may arise when execution reaches components that are not under control of the <b>symbolic</b> <b>execution</b> tool (e.g., kernel or libraries). Consider the following example:This program opens a file and, based on some condition, writes different kind of data to the file. It then later reads back the written data. In theory, <b>symbolic</b> <b>execution</b> would fork two paths at line 5 and each path from there on would have its own copy of the file. The statement at line 11 would therefore return data {{that is consistent with}} the value of [...] "condition" [...] at line 5. In practice, file operations are implemented as system calls in the kernel, and are outside the control of the <b>symbolic</b> <b>execution</b> tool. The main approaches to address this challenge are: ...|$|E
40|$|Abstract. Extending a {{compositional}} protocol logic with an induction {{rule for}} secrecy, we prove soundness for a conventional <b>symbolic</b> protocol <b>execution</b> model, adapt and extend previous composition theorems, and illustrate the logic by proving properties of two key agreement protocols. The first {{example is a}} variant of the Needham-Schroeder protocol that illustrates the ability to reason about temporary secrets. The second example is Kerberos V 5. The modular nature of the secrecy and authentication proofs for Kerberos makes it possible to reuse proofs about the basic version of the protocol for the PKINIT version that uses public-key infrastructure instead of shared secret keys in the initial steps. ...|$|R
40|$|Abstract. <b>Symbolic</b> binary <b>execution</b> is {{a dynamic}} {{analysis}} method which explores program paths to generate test cases for compiled code. Throughout execution, a program is evaluated with a bit-vector theorem prover and a runtime interpreter as a mix of symbolic expressions and concrete values. Left untended, these symbolic expressions grow to negatively impact interpretation performance. Wedescribeanexpressionreductionsystemwhichrecoverssound,contextinsensitive expression reduction rules at run time from programs during symbolic evaluation. These rules are further refined offline into general rules which match larger classes of expressions. We demonstrate that our optimizer significantly reduces the number of theorem solver queries and solver time on hundreds of commodity programs compared to a default ad-hoc optimizer from a popular symbolic interpreter. ...|$|R
40|$|This paper {{makes the}} idea of memory {{shadowing}} (Bryant and Velev, 1997) applicable to symbolic ternary simulation. Memory shadowing, an extension of Burch and Dill 2 ̆ 7 s (1994) pipeline verification method to the bit level, is a technique for providing on-the-fly identical initial memory state to two different memory execution sequences. We also present an algorithm which compares the final states of two memories for ternary correspondence, {{as well as an}} approach for generating efficiently the initial state of memories. These techniques allow us to verify that a pipelined circuit has behavior corresponding to that of its unpipelined specification by simulating two <b>symbolic</b> ternary <b>execution</b> sequences and comparing their memory states. Experimental results show the potential of the new idea...|$|R
5000|$|Semantic Analyser (also {{known as}} <b>symbolic</b> <b>execution).</b> This reveals the exact {{functional}} relationship between all {{inputs and outputs}} over all semantically-feasible paths through the code.|$|E
50|$|Concolic testing (a {{portmanteau}} {{of concrete}} and symbolic) is a hybrid software verification technique that performs <b>symbolic</b> <b>execution,</b> a classical technique that treats program variables as symbolic variables, along a concrete execution (testing on particular inputs) path. <b>Symbolic</b> <b>execution</b> is {{used in conjunction with}} an automated theorem prover or constraint solver based on constraint logic programming to generate new concrete inputs (test cases) with the aim of maximizing code coverage. Its main focus is finding bugs in real-world software, rather than demonstrating program correctness.|$|E
5000|$|<b>Symbolic</b> <b>execution</b> and {{automated}} theorem provers have {{limitations on}} the classes of constraints they can represent and solve. For example, a theorem prover based on linear arithmetic {{will be unable to}} cope with the nonlinear path condition xy = 6. Any time that such constraints arise, the <b>symbolic</b> <b>execution</b> may substitute the current concrete value of one of the variables to simplify the problem. An important part of the design of a concolic testing system is selecting a symbolic representation precise enough to represent the constraints of interest.|$|E
40|$|We {{extend a}} {{previously}} proposed symbolic model transformation property prover for the DSLTrans transformation language. The original prover generated {{the set of}} path conditions (i. e., <b>symbolic</b> transformation <b>executions),</b> and verified atomic contracts (constraints on input-output model relations) on these path conditions. The prover evaluated atomic contracts to yield either true or false for the transformation when run on any input model. In this paper we extend the prover such that it can verify atomic contracts and more complex properties composed of atomic contracts. Besides demonstrating our prover on a simple transformation, we use it to verify different kinds of properties of an industrial transformation. Experiments on this transformation using our prover show a speed-up in verification run-time by two orders of magnitude over another verification tool that we evaluated in previous research...|$|R
40|$|String {{analysis}} {{is the problem}} of reasoning about how strings are manipulated by a program. It has numerous applications including automatic detection of cross-site scripting, and automatic test-case generation. A popular string analysis technique includes <b>symbolic</b> <b>executions,</b> which at their core use constraint solvers over the string domain, a. k. a. string solvers. Such solvers typically reason about constraints expressed in theories over strings with the concatenation operator as an atomic constraint. In recent years, researchers started to recognise the importance of incorporating the replace-all operator (i. e. replace all occurrences of a string by another string) and, more generally, finite-state transductions in the theories of strings with concatenation. Such string operations are typically crucial for reasoning about XSS vulnerabilities in web applications, especially for modelling sanitisation functions and implicit browser transductions (e. g. innerHTML). Although this results in an undecidable theory in general, it was recently shown that the straight-line fragment of the theory is decidable, and is sufficiently expressive in practice. In this paper, we provide the first string solver that can reason about constraints involving both concatenation and finite-state transductions. Moreover, it has a completeness and termination guarantee for several important fragments (e. g. straight-line fragment). The main challenge addressed in the paper is the prohibitive worst-case complexity of the theory (double-exponential time), which is exponentially harder than the case without finite-state transductions. To this end, we propose a method that exploits succinct alternating finite-state automata as concise symbolic representations of string constraints. In contrast to previous approaches using nondeterministic automata, alternation offers not only exponential savings in space when representing Boolean combinations of transducers, but also a possibility of succinct representation of otherwise costly combinations of transducers and concatenation. Reasoning about the emptiness of the AFA language requires a state-space exploration in an exponential-sized graph, for which we use model checking algorithms (e. g. IC 3). We have implemented our algorithm and demonstrated its efficacy on benchmarks that are derived from cross-site scripting analysis and other examples in the literature...|$|R
40|$|International audienceWe {{define the}} {{semantics}} of a synthesizable VHDL subset in a quantifier-free, first-order {{logic of the}} ACL 2 theorem prover, and build the model of a VHDL design in this logic. This single model {{can be used for}} three tasks : <b>execution,</b> <b>symbolic</b> simulation, and formal verification. To verify designs made of components, we introduce abstract functions representing an unspecified system (surrounding environment) through the ACL 2 construction encapsulate. This approach supports compositional reasoning, which means that system properties follow from component properties, without flattening the design or examining actual component definitions...|$|R
