4|28|Public
50|$|Some free {{software}} advocates {{use the term}} free and open source software (FOSS) as an inclusive compromise, drawing on both philosophies to bring both {{free software}} advocates and open source software advocates together to work on projects with more cohesion. Some users believe that a compromise term encompassing both aspects is ideal, to promote both the user's freedom with the software and also to promote the perceived superiority of an open source development model. This eclectic view {{is reinforced by the}} fact that the overwhelming majority of OSI-approved licenses and self-avowed open source programs are also compatible with the free <b>software</b> <b>formalisms</b> and vice versa.|$|E
40|$|Despite the {{well-known}} benefits {{of separation of}} concerns, and {{despite the presence of}} mechanisms to achieve separation of concerns in all modern <b>software</b> <b>formalisms,</b> software artifacts continue to exhibit properties associated with poor separation of concerns. Comprehensibility degrades over time; impact of change is high; reuse and traceability are limited. We have hypothesized that these limitations are largely caused by the "tyranny of the dominant decomposition: " existing languages and formalisms generally provide only one, "dominant" dimension along which to separate concerns [...] e. g., by object or by function. Achieving many software engineering goals depends on the ability to separate all concerns of importance. We therefore introduced the notion of multi-dimensional separation of concerns: simultaneous separation according to multiple, potentially overlapping concerns. This paper explores the structure of the space of concerns, to which we refer as hyperspace, partially formal [...] ...|$|E
40|$|An {{integration}} of traditional verification techniques and formal specifications in software engineering is presented. Advocates of such techniques claim that mathematical formalisms {{allow them to}} produce quality, verifiably correct, or at least highly dependable software and that the testing and maintenance phases are shortened. Critics {{on the other hand}} maintain that <b>software</b> <b>formalisms</b> are hard to master, tedious to use and not well suited for the fast turnaround times demanded by industry. In this paper some popular formalisms and the advantages of using these during the early phases of the software development life cycle are presented. Employing the Floyd-Hoare verification principles during the formal specification phase facilitates reasoning about the properties of a specification. Some observations that may help to alleviate the formal-methods controversy are established and a number of formal methods successes is presented. Possible conditions for an increased acceptance of formalisms in oftware development are discussed...|$|E
40|$|We {{introduce}} {{an architectural}} <b>software</b> <b>formalism,</b> buffer automata, for the specification, implementation {{and analysis of}} a particular class of discrete interactive systems and devices. The approach defines a layer between the physical user interface and the application (if any) and provides a clear framework for highlighting a number of interaction design issues, in particular around modes and undo. Author Keywords Buffer automata; modes; undo; interaction programming; structural usability...|$|R
30|$|The {{presented}} {{formal specification}} {{can be considered}} as a first step towards the modeling of smart grid using a <b>Software</b> Engineering <b>formalism.</b> It also demonstrates how formal specification can be used to model complex systems in general, and the smart grid, in particular.|$|R
40|$|Interval Temporal Logic {{provides}} time-dependant {{formal description}} of hardware and <b>software.</b> Such <b>formalism</b> {{is needed for}} description of behaviors of the middleware of AOmLE project, depending on different scenarios of operation. In order to use ITL, we need an interpreter. Tempura provides executable ITL framework, written in C language. We cannot use Tempura as is, because AOmLE is developed entirely in Java. For this reason we need Java version of Tempura. This paper describes our plan for reengineering of CTempura and creating Java version if the ITL interpreter...|$|R
40|$|School of Computing, UNISA, Pretoria, South Africa An {{integration}} of traditional verification techniques and formal specifications in software engineering is presented. Advocates of such techniques claim that mathematical formalisms {{allow them to}} produce quality, verifiably correct, or at least highly dependable software and that the testing and maintenance phases are shortened. Critics {{on the other hand}} maintain that <b>software</b> <b>formalisms</b> are hard to master, tedious to use and not well suited for the fast turnaround times demanded by industry. In this paper some popular formalisms and the advantages of using these during the early phases of the software development life cycle are presented. Employing the Floyd-Hoare verification principles during the formal specification phase facilitates reasoning about the properties of a specification. Some observations that may help to alleviate the formal-methods controversy are established and a number of formal methods successes is presented. Possible conditions for an increased acceptance of formalisms in software development are discussed...|$|E
40|$|We {{show the}} {{advantages}} of modular and hierarchical design in obtaining fault-tolerant software. Modularity enables the identification of faulty software units simplifying key operations, like software removal and replacement. We describe three approaches to repair faulty software based on replication, namely, Passive Replication, N-Version Replication, and Active Replication, based on modular components. We show that the key construct to represent these tactics {{is the ability to}} make ad hoc changes in software topologies. We consider hierarchical mobility as a useful operation to introduce new software units for replacing faulty ones. For illustration purposes, we use connecton, a hierarchical, modular, and self-modifying <b>software</b> specification <b>formalism,</b> and its implementation in the Desmos framework...|$|R
40|$|Software {{production}} processes {{are subject to}} changes during their life-time. Therefore, <b>software</b> process <b>formalism</b> must include mechanisms to support the analysis and dynamic modification of process models, even while they are being enacted. It is thus necessary for a process model {{to have the ability}} to reason about its own structure. Petri net based process languages have been criticized because of the lack of these reflective features and their inability to effectively support process evolution. In this paper we present the reflective features offered by SLANG, a process formalism based on an high-level Petri net notation. In particular, we discuss the mechanisms to create and modify different net fragments while the modeled process is being enacted...|$|R
40|$|Card Shark and Thespis are two newly-implemented {{hypertext}} {{systems for}} creating hypertext narrative. Both systems depart dramatically from the tools currently popular for writing hypertext fiction, and these departures may help {{distinguish between the}} intrinsic nature of hypertext and the tendencies of particular <b>software</b> tools and <b>formalisms.</b> The implementation of these systems raises interesting questions about the assumptions underlying recent discussion of immersive, interactive fictions, and suggests new opportunities for hypertext research...|$|R
40|$|This paper {{describes}} {{a method for}} applying formal specifications to automate a system design process based on reusable components and architectures. The focus is on identification and retrieval of components pertinent to a problem, and selection and application of architectures available for adapting these components. Component retrieval is facilitated by a heuristic based on specification semantics for approximating specification matches that indicate component reusability. To support adaptation, a formal model of architectures is developed that uses algebraic theories to specify relationships between the system and component specifications. Adaptation is performed by placing or replacing components within an architecture theory. Keywords Software reuse, specification-based retrieval, <b>software</b> architecture <b>formalisms.</b> INTRODUCTION As <b>software</b> systems are becoming larger and more complex, the demand for high levels of reliability and productivity is also increasing. New techniques [...] ...|$|R
40|$|When {{modelling}} manufacturing systems, {{different approaches}} can be followed {{giving rise to}} two model categories: mathematical and simulation models. Mathematical models come from two areas. Queuing networks, Markov chains, perturbation analysis, and the like, stem from operations research. Petri Nets and concurrent programming provide examples of models from computing science. An important feature of the latter ones is that except for providing a basis for formal reasoning, {{they can also be}} used for simulation purposes. Originally developed for modelling and analysis of computer hardware and <b>software,</b> these <b>formalisms</b> are also well suited to model information and control flows in manufacturing systems usually exhibiting concurrency and nondeterminism. In this paper, we discuss application of concurrent programming to specification of manufacturing systems. 1 Introduction In manufacturing systems, there is more going on than just creation of products. Organisational aspects of product [...] ...|$|R
40|$|Determining {{conclusively}} {{whether a}} new version of software creatively exceeds a previous version or a third party sys-tem is difficult, yet very important for scientific approaches in Computational Creativity research. We argue that software product and process need to be assessed simultaneously in assessing progress, and we introduce a diagrammatic formal-ism which exposes various timelines of creative acts in the construction and execution of successive versions of artefact-generating <b>software.</b> The <b>formalism</b> enables estimations of progress or regress from system to system by comparing their diagrams and assessing changes in quality, quantity and va-riety of creative acts undertaken; audience perception of be-haviours; and the quality of artefacts produced. We present a case study in the building of evolutionary art systems, and we use the formalism to highlight various issues in measuring progress in the building of creative systems...|$|R
40|$|A major {{application}} of computers {{has been to}} control physical processes in which the computer is embedded within some large physical process and is required to control concurrent physical processes. The main difficulty with these systems is their event-driven characteristics, which complicate their modelling and analysis. Although {{a number of researchers}} in the process system community have approached the problems of modelling and analysis of such systems, there is still a lack of standardised <b>software</b> development <b>formalisms</b> for the system (controller) development, particular at early stage of the system design cycle. This research forms part of a larger research programme which is concerned with the development of real-time process-control systems in which software is used to control concurrent physical processes. The general objective of the research in this thesis is to investigate the use of formal techniques in the analysis of such systems at their early stages of development, with a particular bias towards an application to high speed machinery. Specifically, the research aims to generate a standardised <b>software</b> development <b>formalism</b> for real-time process-control systems, particularly for software controller synthesis. In this research, a graphical modelling formalism called Sequential Function Chart (SFC), a variant of Grafcet, is examined. SFC, which is defined in the international standard IEC 1131 as a graphical description language, has been used widely in industry and has achieved an acceptable level of maturity and acceptance. A comparative study between SFC and Petri nets is presented in this thesis. To overcome identified inaccuracies in the SFC, a formal definition of the firing rules for SFC is given. To provide a framework in which SFC models can be analysed formally, an extended time-related Petri net model for SFC is proposed and the transformation method is defined. The SFC notation lacks a systematic way of synthesising system models from the real world systems. Thus a standardised approach to the development of real-time process control systems is required such that the system (software) functional requirements can be identified, captured, analysed. A rule-based approach and a method called system behaviour driven method (SBDM) are proposed as a development formalism for real-time process-control systems...|$|R
40|$|Since {{nowadays}} {{more and}} more control systems are realised within software on electronic control units, a conceptual integration of control systems engineering and software engineering must be aimed at. Within this work, we build on a recent proposal to use the <b>software</b> requirements <b>formalism</b> i* to enable a combined investigation of control systems' and software requirements. While i*'s modelling means {{have turned out to}} be sufficiently expressive, two characteristics of control systems still need to be addressed: firstly, how to incorporate domain knowledge especially about the system to be controlled in the requirements development process and secondly, how to specifically support small and medium-sized companies (SMEs) that are the main driver for innovations in this domain. Due to their innovativeness and flexibility, the SMEs usually follow a project-oriented customer-specific development approach. To be nonetheless cost-effective, especially during the offer development phase, we develop a mechanism and a tool to compare a current requirements model with requirements models of control systems from earlier projects. Altogether this reduces time and increases reliability in regard to the identification of reusable software artefacts...|$|R
40|$|Smart grid can be {{considered}} as {{the next step in the}} evolution of power systems. It comprises of different entities and objects ranging from smart appliances, smart meters, generators, smart storages, and more. One key problem in modeling smart grid is that while currently there is a considerable focus on the practical aspects of smart grid, there are very few modeling attempts and even lesser attempts at formalization. To the best of our knowledge, among other formal methods, formal specification has previously not been applied in the domain of smart grid. In this paper, we attempt to bridge this gap by presenting a novel approach to modeling smart grid components using a formal specification approach. We use a state-based formal specification language namely Z (pronounced as `Zed') since we believe Z is particularly suited for modeling smart grid components. We demonstrate the application of Z on key smart grid components. The presented formal specification can {{be considered}} as first steps towards modeling of smart grid using a <b>Software</b> Engineering <b>formalism.</b> It also demonstrates how complex systems, such as the smart grid, can be modeled elegantly using formal specification. Comment: 8 page...|$|R
40|$|Abstract. Embedded <b>software</b> {{requires}} concurrency <b>formalisms</b> {{other than}} threads and mutexes used in traditional programming languages like C. Actor-oriented design presents {{a high level}} abstraction for composing concurrent components. However, high level abstraction often introduces overhead and results in slower system. We {{address the problem of}} generating efficient implementation for the systems with such a high level description. We use partial evaluation as an optimized compilation technique for actor-oriented models. We use a helper-based mechanism, which results in flexible and extensible code generation framework. The end result is that the benefit offered by high level abstraction comes with (almost) no performance penalty. The code generation framework has been released in open source form as part of Ptolemy II 6. 0. 1. ...|$|R
40|$|Abstract: Taking {{inspiration}} from natural self-organizing systems {{is a successful}} strategy to solve computational problems in distributed systems. Faced with a particular problem, application designers have to identify an appropriate dynamical behavior and decide how to induce similar behavioral modes. In order to consolidate these ad-hoc activities to a systematic dynamical design method, we discuss and exemplify a behavioral modeling approach that describes the macroscopic behavior of agent-based <b>software</b> systems. This <b>formalism</b> is used to catalog the dynamic behavior of prominent examples of natural self-organizing systems. These here presented models represent generic, reusable templates for decentralized system adaptations that serve as analysis templates for application designs. A tailored programming model allows to supplement these templates in agent-based software applications with minimal intervention in the agent models...|$|R
40|$|There exist many formalisms for {{modeling}} {{the behavior of}} (<b>software)</b> systems. These <b>formalisms</b> serve different purposes. Process algebras are used for algebraic and axiomatic reasoning about the behavior of distributed systems. UML state machines are suitable for automatic software generation. We have developed a transformation from the process algebra ACP into UML state machines to enable automatic software generation from process algebra models. This transformation needs to preserve both behavioral and structural properties. The combination of these preservation requirements {{gives rise to a}} semantic gap. It implies that we cannot transform ACP models into UML state machines on a syntactic level only. We address this semantic gap and propose a way of bridging it. To validate our proposal, we have implemented a tool for automatic transformation of ACP process algebra models into UML state machines...|$|R
40|$|The Fourth International Conference on Software Engineering Advances [ICSEA 2009] held between September 20 - 25, 2009 in Porto, Portugal, {{continued}} {{a series}} of events including a broad spectrum of software-related topics. The conference covered fundamentals on designing, implementing, testing, validating and maintaining various kinds of software. Several tracks were proposed to treat the topics from theory to practice, in terms of methodologies, design, implementation, testing, use cases, tools, and lessons learned. The conference topics covered advances in fundamentals for software development, advances in software testing, specialized software advanced applications, open source software, agile software techniques, software deployment and maintenance, software engineering techniques, metrics and <b>formalisms,</b> <b>software</b> performance, advanced design tools for developing software, software economics, adoption, and education, software security, privacy and safeness, advanced mechanisms for software development and advanced facilities for accessing software...|$|R
40|$|Abstract. There exist many formalisms for {{modeling}} {{the behavior of}} (<b>software)</b> systems. These <b>formalisms</b> serve different purposes. Process algebras are used for algebraic and axiomatic reasoning about the be-havior of distributed systems. UML state machines are suitable for au-tomatic software generation. We have developed a transformation from the process algebra ACP into UML state machines to enable automatic software generation from process algebra models. This transformation needs to preserve both behavioral and structural properties. The combi-nation of these preservation requirements {{gives rise to a}} semantic gap. It implies that we cannot transform ACP models into UML state machines on a syntactic level only. We address this semantic gap and propose a way of bridging it. To validate our proposal, we have implemented a tool for automatic trans-formation of ACP process algebra models into UML state machines. ...|$|R
40|$|In {{this paper}} we present AToM³, A Tool for Multi-formalism Meta-Modelling, and show {{how it can}} be used to {{generate}} CASE tools. AToM 3 has a meta-modelling layer which allows one to model <b>formalisms</b> (simulation <b>formalisms,</b> <b>software</b> modelling notations, etc.) and is able to generate custom tools to process (create, edit, simulate, optimize, etc.) models expressed in these formalisms. AToM 3 relies on graph rewriting techniques and graph grammars to express such model processing. AToM³ has been designed and used mostly for modelling and simulation of physical systems. In this paper we show that it can also be used to describe tools for analysis, design abd synthesis of software. We demonstrate this by creating tools for structured analysis and design, and by dening some graph grammars to automatically transform Data Flow Diagrams into Structure Charts and to 'optimize' these models...|$|R
40|$|Most <b>software</b> process {{modeling}} <b>formalisms</b> are well-suited {{to one of}} two levels of specification, but not both. Some process languages concentrate on global control flow and synchronization; these languages make it easy to define the broad outline of a process, but harder (or even impossible) to refine the process by expressing constraints and policies on individual tools and data. Other process formalisms are inherently local: it is easy to define constraints, but far from straightforward to express control flow. We propose combining global and local formalisms to produce single but bi-level {{process modeling}} languages. We present our bi-level Activity Structures Language, which combines constrained expressions with rules, and its implementation on top of the MARVEL 3. 0 multi-user environment. Copyright Ó 1992 Gail E. Kaiser, Steven S. Popovich and Israel Z. Ben-Shaul The Programming Systems Laboratory is supported by National Science Foundation grants CCR- 9106368 and CCR- 8858029, by gr [...] ...|$|R
40|$|Abstract. In <b>software</b> engineering, {{graphical}} <b>formalisms,</b> like state-transition {{tables and}} automata, are very often indispensable {{parts of the}} specifications. Such a formalism usually leads to specification re-finement that maintains the simulation/bisimulation relation between an implementation and a specification. We investigate how to use formal techniques to generate suggestions for repairing a program that breaks the bisimulation relation with a graphical specification. We use state graphs as a unified representation of the program models and specifica-tions. We propose a technique that may evaluate {{the cost of a}} repair. We present a PTIME heuristic algorithm that suggests how to repair a model state graph. We then explain how to derive repair suggestions for programs from the repair for state graphs. Finally, we report our experi-ment that checks the performance of our repair algorithms and the costs of our repairs. Key words: state graph, state transition relation, repair, graph theory, cost, evaluation, equivalence, bisimulation...|$|R
40|$|Abstract. In {{this paper}} we {{evaluate}} transition systems {{as a tool}} for providing a rule-based specification of the operational aspects of autonomous agents. By our technique, different aspects of an agent can be analyzed and designed in a loosely coupled way, enabling the possibility of studying their properties in isolation. We take as a use case the ParADE framework for building intelligent agents, which leverages a FIPA-like ACL semantics to support semantic interoperability. Our grey-boxing technique is exploited to provide a specification where aspects related to the ACL, the adopted ontology, the agent social role, and the other agent internal details are described separately, in an incremental way. 1 <b>Formalisms,</b> <b>Software</b> Engineering, and Agents This paper addresses the issue of sound multi-agent design trying to keep a system engineering perspective; that is, both when analyzing a problem and when synthesizing a solution the focus is kept on the whole, large-scale structur...|$|R
40|$|In {{this thesis}} two <b>software</b> process {{modelling}} <b>formalisms,</b> TEMPO and SOCCA, {{will be discussed}} and compared. The TEMPO formalism has been developed at the Laboratoire de Gnie Informatique, Universit Joseph Fourier, Grenoble (France) and the SOCCA formalism has been developed at the University of Leiden (The Netherlands). During the modelling of some examples in both formalisms, several interesting aspects came into light. This has resulted into some extensions of the SOCCA formalism. Further more several role concepts found in the different software process modelling approaches will be presented and a proposition for the role concept in SOCCA will be given. The {{last part of the}} thesis describes the R. A. P. P. diagram. This is a diagram which can possibly be used on top of SOCCA (or other <b>formalisms),</b> to describe <b>software</b> processes on a more global level of abstraction. Contents 1. General Introduction [...] ...|$|R
40|$|We have {{developed}} a framework for specifying high-level software designs. The core of the framework is a very simple visual notation. This notation enables designers to document designs as labelled rectangles and directed edges. In addition to the notation, our framework features a supporting formalism, called ISF (Interconnection Style Formalism). This formalism enables designers to customize the simple design notation by specifying the type of entities, relations, legal configurations of entities and relations, as well as scoping rules of the custom notation. In this paper we present the formal definition of ISF and use ISF to specify two custom design notations. We also describe how ISF specifications, using deductive database technology, are used to generate supporting tools for these custom notations. Keywords: Visual <b>Formalism,</b> <b>Software</b> Design, Deductive Databases. 1 Introduction The structure of a large software system typically consists of hundreds, often thousands, of type [...] ...|$|R
40|$|Keywords: Role-based modeling, Open multi-agent <b>software</b> systems, Object-Z <b>formalism,</b> A-R mapping. Abstract: Multi-agent systems (MAS) {{are rapidly}} {{emerging}} as a powerful paradigm for modeling and developing distributed information systems. In an open multi-agent system, agents can not only join or leave an agent society at will, but also take or release roles dynamically. Most of existing work on MAS uses role modeling for system analysis; however, role models are only used at conceptual level with no realizations in the implemented system. In this paper, we propose a methodology for role-based modeling of open multiagent software systems. We specify role organization and role space as containers of conceptual roles and role instances, respectively. Agents in an agent society can take or release roles from a role space dynamically. The relationships between agents are deduced through a mechanism called A-R mapping. As a potential solution for automated MAS development, we summarize the procedures to generate a role-based design of open multi-agent software systems. ...|$|R
40|$|This paper {{introduces}} {{the concept of}} active documents and shows {{how it can be}} used for making the user interface of applications that handle programs. A system for active documents is briefly presented as well as a few examples of its use for building syntax-driven editors. 1 Introduction A number of formalisms are used for representing the entities manipulated in a software development environment. Many of them are textual and need a complex layout with various styles of characters. Many others are graphical, using such representations as graphs, trees, charts, tables, etc. Because of the importance of these <b>formalisms,</b> <b>software</b> engineers need efficient tools for handling them. Currently, a number of software engineering tools are built with such user interface toolkits as OSF/MOTIF or OpenLook. Although they provide developers with useful services, these toolkits are not sufficient for various reasons:. Most of the widgets they propose are dedicated to the dialogue between the [...] ...|$|R
40|$|Interest in {{open source}} {{software}} has emerged in many different research communities. Much of this interest has focused attention primarily onto the products of open software development (source code), and secondarily onto the processes and productive units that facilitate such development. My research is focused to understanding the processes, practices, and communities {{that give rise to}} {{open source software}}. My research group is studying (a) the role of <b>software</b> informalisms (vs. <b>formalisms</b> and standards found in software engineering), (b) the emergence and articulation of open software requirements, (c) the forms and constituencies of the social worlds of open software, and (d) other processes and practices across multiple open software development communities [Scacchi 2001 b, 2002]. I am prepared to discuss early results, work in progress, and the need for further research on all of these topics at the workshop. However, the remainder of this position paper identifies what I believe are areas, topics, or basic questions requiring further research in the arena of open source software development. These follow in an unordered manner. Understanding the quality of open source software from a socio-technical perspective What is the best, most effective way to determine the quality of open source software product...|$|R
40|$|One of the {{key factors}} that hold {{shopfloor}} control (SFC) software evolution back is the exorbitant cost, time, complexity, and inflexibility of developing customized SFC software solutions. The development and maintenance life-cycle of SFC software is characterized by lock-in problems. It {{is a fact that}} shopfloor environments constantly are changing, while the technology surrounding and supporting them often is changing faster. To handle these changes, the necessary software evolution has become the bottleneck. In this thesis, a literature survey shows that there exists a uniform view of general requirements on generic structures for shopfloor controllers. This work has adopted these general requirements in the design for a shopfloor control concept named Production Activity Control (PAC++). To gain experience and knowledge about modeling requirements, three pilot cases were defined. The objective in each pilot case is to gain an understanding of the development and implementation phases of shopfloor control models. The cases were placed on the work station-, cell-, and shop level in the National Institute of Standards and Technology (NIST) hierarchical architecture. The PAC++ concept shows that by using a consistent modeling and implementation <b>formalism,</b> <b>software</b> modules become distributed and scalable. This gives the advantage to start with small and well-defined projects, while retaining the possibility to use an incrementally growing approach to a full-scale Shopfloor Control System, SFCS. Finally, the PAC++ has the built-in flexibility to improve and enhance its functionality during the whole life-cycle of a shopfloor control system, justifying development cost and time...|$|R
40|$|A {{methodology}} for formally modeling and analyzing software architecture of mobile agent systems provides a solid basis to develop high quality mobile agent systems, and the methodology {{is helpful to}} study other distributed and concurrent systems as well. However, {{it is a challenge}} to provide the methodology because of the agent mobility in mobile agent systems. ^ The methodology was defined from two essential parts of <b>software</b> architecture: a <b>formalism</b> to define the architectural models and an analysis method to formally verify system properties. The formalism is two-layer Predicate/Transition (PrT) nets extended with dynamic channels, and the analysis method is a hierarchical approach to verify models on different levels. The two-layer modeling formalism smoothly transforms physical models of mobile agent systems into their architectural models. Dynamic channels facilitate the synchronous communication between nets, and they naturally capture the dynamic architecture configuration and agent mobility of mobile agent systems. Component properties are verified based on transformed individual components, system properties are checked in a simplified system model, and interaction properties are analyzed on models composing from involved nets. Based on the formalism and the analysis method, this researcher formally modeled and analyzed a software architecture of mobile agent systems, and designed an architectural model of a medical information processing system based on mobile agents. The model checking tool SPIN was used to verify system properties such as reachability, concurrency and safety of the medical information processing system. ^ From successful modeling and analyzing the software architecture of mobile agent systems, the conclusion is that PrT nets extended with channels are a powerful tool to model mobile agent systems, and the hierarchical analysis method provides a rigorous foundation for the modeling tool. The hierarchical analysis method not only reduces the complexity of the analysis, but also expands the application scope of model checking techniques. The results of formally modeling and analyzing the software architecture of the medical information processing system show that model checking is an effective and an efficient way to verify software architecture. Moreover, this system shows a high level of flexibility, efficiency and low cost of mobile agent technologies. ...|$|R

