96|70|Public
5|$|On July 13, 2004, PHP 5 was released, {{powered by}} the new Zend Engine II. PHP 5 {{included}} new features such as improved support for object-oriented programming, the PHP Data Objects (PDO) extension (which defines a lightweight and consistent interface for accessing databases), and numerous performance enhancements. In 2008 PHP 5 became the only stable version under development. Late <b>static</b> <b>binding</b> had been missing from PHP and was added in version 5.3.|$|E
25|$|Late <b>static</b> <b>binding</b> is {{a variant}} of binding somewhere between static and dynamic binding. The binding of names before the program is run is called static (early); {{bindings}} performed as the program runs are dynamic (late or virtual).|$|E
50|$|An {{example of}} a <b>static</b> <b>binding</b> is a direct C {{function}} call: the function referenced by the identifier cannot change at runtime.|$|E
50|$|C++ exemplifies another extreme: {{it relies}} heavily on {{templates}} and overloading and other <b>static</b> <b>bindings</b> at compile-time, {{which in turn has}} certain flexibility problems.|$|R
5000|$|Porting from <b>static</b> Python <b>bindings</b> PyGTK to PyGObject, {{which uses}} GObject Introspection ...|$|R
50|$|In some respects, SOA {{could be}} {{regarded}} as an architectural evolution {{rather than as a}} revolution. It captures many of the best practices of previous software architectures. In communications systems, for example, little development of solutions that use truly <b>static</b> <b>bindings</b> to talk to other equipment in the network has taken place. By embracing a SOA approach, such systems can position themselves to stress the importance of well-defined, highly inter-operable interfaces. Other predecessors of SOA include Component-based software engineering and Object-Oriented Analysis and Design (OOAD) of remote objects, for instance, in CORBA.|$|R
50|$|Late <b>static</b> <b>binding</b> is {{a variant}} of binding somewhere between static and dynamic binding. The binding of names before the program is run is called static (early); {{bindings}} performed as the program runs are dynamic (late or virtual).|$|E
5000|$|Late <b>static</b> <b>binding</b> is {{a variant}} of binding somewhere between static and dynamic binding. Consider the {{following}} PHP example:class A { static $word = [...] "hello"; static function hello (...) { print self::$word; }}class B extends A { static $word = [...] "bye";}B::hello (...) ...|$|E
5000|$|In this example, the PHP {{interpreter}} binds the keyword [...] inside [...] {{to class}} , {{and so the}} call to [...] produces the string [...] "hello". If the semantics of [...] had been based on late <b>static</b> <b>binding,</b> then the result would have been [...] "bye".|$|E
50|$|The JNA library uses a small native library called foreign {{function}} interface library (libffi) to dynamically invoke native code. The JNA library uses native functions allowing code to load {{a library}} {{by name and}} retrieve a pointer to a function within that library, and uses libffi library to invoke it, all without <b>static</b> <b>bindings,</b> header files, or any compile phase. The developer uses a Java interface to describe functions and structures in the target native library. This makes it quite easy {{to take advantage of}} native platform features without incurring the high development overhead of configuring and building JNI code.|$|R
5000|$|An XML Event is the {{representation}} of some [...] occurrence (such as a mouse button click) that gets associated with a data element in an XML document. XML Events provides a <b>static,</b> syntactic <b>binding</b> to the DOM Events interface, allowing the event to be handled.|$|R
40|$|SmallEiffel is an Eiffel {{compiler}} {{which uses}} a fast simple type inference mechanism to remove most late binding calls, replacing them by <b>static</b> <b>bindings.</b> Starting from the system's entry point, it compiles only statically living code, which saves compiling and then removing dead code. As the whole system is analyzed at compile time, multiple inheritance and genericity do not cause any overhead. SmallEiffel features a coding scheme which {{eliminates the need for}} virtual function tables. Dynamic dispatch is implemented without any array access but uses a simple static binary branch code. We show that this implementation makes it possible to use modern hardware very efficiently. It also allows us to inline more calls even when dynamic dispatch is required. Some more dispatch sites are removed after the type inference algorithm has been performed, if the different branches of a dispatch site lead to the same code. The advantage of this approach is that it greatly speeds up execution time and considerably decreases the amount of generated code...|$|R
5000|$|Beginning with PHP version 5.3, late <b>static</b> <b>binding</b> is supported. [...] Specifically, if [...] in {{the above}} were changed to [...] {{as shown in the}} {{following}} block, where the keyword [...] would only be bound at runtime, then the result of the call to [...] would be [...] "bye": ...|$|E
50|$|A {{more subtle}} example {{is that of}} a {{function}} that has a free variable, i.e., depends on some input that is not explicitly passed as a parameter. This is then resolved according to name binding rules to a non-local variable, such as a global variable, a variable in the current execution environment (for dynamic binding), or a variable in a closure (for <b>static</b> <b>binding).</b> Since this variable can be altered without changing the values passed as parameter, the results of subsequent calls to the function may differ even if the parameters are identical. However, in pure functional programming, destructive assignment is not allowed, and thus if the free variable is statically bound to a value, the function is still referentially transparent, as neither the non-local variable nor its value can change, due to <b>static</b> <b>binding</b> and immutability, respectively.|$|E
50|$|Throughout the 1990s and {{beginning}} with MSC 6 (their first ANSI C compliant compiler) Microsoft re-focused their C compilers on the emerging Windows market, {{and also on}} OS/2 and {{in the development of}} GUI programs. Mixed language compatibility remained through MSC 6 on the MS-DOS side, but the API for Microsoft Windows 3.0 and 3.1 was written in MSC 6. MSC 6 was also extended to provide support for 32-bit assemblies and support for the emerging Windows for Workgroups and Windows NT which would form the foundation for Windows XP. A programming practice called a thunk was introduced to allow passing between 16 and 32 bit programs that took advantage of runtime binding (dynamic linking) rather than the <b>static</b> <b>binding</b> that was favoured in monolithic 16 bit MS-DOS applications. <b>Static</b> <b>binding</b> is still favoured by some native code developers but does not generally provide the degree of code reuse required by newer best practices like the Capability Maturity Model (CMM).|$|E
40|$|Cette publi est considérée comme un journal (ACM SIGPLAN Notices) dans la communauté. International audienceSmallEiffel is an Eiffel {{compiler}} {{which uses}} a fast simple type inference mechanism to remove most late binding calls, replacing them by <b>static</b> <b>bindings.</b> Starting from the system's entry point, it compiles only statically living code, which saves compiling and then removing dead code. As the whole system is analyzed at compile time, multiple inheritance and genericity do not cause any overhead. SmallEiffel features a coding scheme which {{eliminates the need for}} virtual function tables. Dynamic dispatch is implemented without any array access but uses a simple static binary branch code. We show that this implementation makes it possible to use modern hardware very efficiently. It also allows us to inline more calls even when dynamic dispatch is required. Some more dispatch sites are removed after the type inference algorithm has been performed, if the different branches of a dispatch site lead to the same code. The advantage of this approach is that it greatly speeds up execution time and considerably decreases the amount of generated code...|$|R
5000|$|The fragile {{base class}} {{problem has been}} blamed on open {{recursion}} (dynamic dispatch of methods on [...] ), with the suggestion that invoking methods on [...] default to closed recursion (<b>static</b> dispatch, early <b>binding)</b> rather than open recursion (dynamic dispatch, late binding), only using open recursion when it is specifically requested; external calls (not using [...] ) would be dynamically dispatched as usual.|$|R
40|$|Abstract. Promise theory {{defines a}} {{method by which}} <b>static</b> service <b>bindings</b> are made in a network, but little {{work has been done}} on {{handling}} the dynamic case in which bindings must change over time due to both contingencies and changes in policy. We define two new kinds of promises that provide temporal scope for a conditional promise. We show that simple temporally-scoped promises can describe common network behaviors such as leasing and failover, and allow an agent to completely control the sequence of sets of promises to which it commits with another agent, over time. This allows agents to adapt to changing conditions by making short-term bilateral agreements rather than the long-term unilateral agreements provided by previous promise constructions. ...|$|R
5000|$|Almost all prototype-based {{systems are}} based on {{interpreted}} and dynamically typed languages. Systems based on statically typed languages are technically feasible, however. The Omega language discussed in Prototype-Based Programming {{is an example of}} such a system, though according to Omega's website even Omega is not exclusively static, but rather its [...] "compiler may choose to use <b>static</b> <b>binding</b> where this is possible and may improve the efficiency of a program." ...|$|E
50|$|On July 13, 2004, PHP 5 was released, {{powered by}} the new Zend Engine II. PHP 5 {{included}} new features such as improved support for object-oriented programming, the PHP Data Objects (PDO) extension (which defines a lightweight and consistent interface for accessing databases), and numerous performance enhancements. In 2008 PHP 5 became the only stable version under development. Late <b>static</b> <b>binding</b> had been missing from PHP and was added in version 5.3.|$|E
50|$|With early binding, or <b>static</b> <b>binding,</b> in an {{object-oriented}} language, the compilation phase fixes {{all types}} of variables and expressions. This is usually stored in the compiled program as an offset in a virtual method table ("v-table") and is very efficient. With late binding the compiler {{does not have enough}} information to verify the method even exists, let alone bind to its particular slot on the v-table. Instead the method is looked up by name at runtime.|$|E
40|$|Type Binding is {{the process}} of {{assigning}} a type to a variable. A distinction is made between <b>static</b> and dynamic <b>binding</b> depending on whether the binding occurs at compile-time or at run-time respectively. Type Strength refers to the effectiveness with which a type system prevents type errors. A strongly typed language prevents any operation on the wrong type of data. In weakly typed languages there are ways to escap...|$|R
5000|$|Most {{work was}} done in a macro {{assembly}} language, with a fairly powerful macro language facility allowing great flexibility in code configuration and generation. <b>Static</b> variable <b>binding,</b> like Fortran, was the norm {{and the use of}} arbitrary subroutine call patterns was rare. The machines were usually deployed for very fixed jobs with a rigidly planned set of software. This often extended to the real-time interrupt latency, using the 4 levels of priority and the carefully crafted software paths to ensure guaranteed latencies. Fortran and a PL/1 subset (PL/7) compilers were available no later than 1976 as larger configurations became more affordable and more complex data processing was required. System/7 programmers still needed {{to be aware of the}} actual instructions that were available for use.|$|R
40|$|We have {{investigated}} structure and properties of small metal clusters using all-electron ab initio theoretical methods {{based on the}} Hartree-Fock approximation and density functional theory, perturbation theory and compared results of our calculations with the available experimental data {{and the results of}} other theoretical works. We have systematically calculated the optimized geometries of neutral and singly charged sodium clusters having up to 20 atoms, their multipole moments (dipole and quadrupole), <b>static</b> polarizabilities, <b>binding</b> energies per atom, ionization potentials and frequencies of normal vibration modes. Our calculations demonstrate the great role of many-electron correlations in the formation of electronic and ionic structure of small metal clusters and form a good basis for further detailed study of their dynamic properties, as well as structure and properties of other atomic cluster systems. Comment: 47 pages, 16 figure...|$|R
40|$|Most {{programming}} languages adopt <b>static</b> <b>binding,</b> but for distributed programming {{an exclusive}} reliance on <b>static</b> <b>binding</b> is too restrictive: dynamic binding {{is required in}} various guises, for example when a marshalled value is received from the network, containing identifiers that must be rebound to local resources. Typically it is provided only by ad-hoc mechanisms that lack clean semantics...|$|E
40|$|A Hoare-style {{programming}} logic for the sequential {{kernel of}} Java is presented. It handles recursive methods, class and interface types, subtyping, inheritance, dynamic and <b>static</b> <b>binding,</b> aliasing via object references, and encapsulation. The logic is proved sound w. r. t. an SOS semantics by embedding both into higher-order logic...|$|E
40|$|Online {{interaction}} with computer systems and applications allows developers to monitor, experiment with, and debug long-running, resource-intensive applications at runtime. Traditionally, developers statically bind a monitoring mechanism to each application-specific instrumentation point. This approach has shortcomings for online, interactive monitoring. Namely, <b>static</b> <b>binding</b> limits portability among monitoring systems; it may mismatch monitoring mechanisms to interactive requests for monitoring data; and, predictions {{for the performance}} and execution paths of instrumentation for static bindings are left to the developer. To address these concerns, we have created a new technique called monitoring assertions that allows monitoring systems to delay binding of monitoring mechanisms to application-specific instrumentation points until runtime. Our empirical results show that we can alter the performance of both the application and the monitoring system by removing <b>static</b> <b>binding</b> requirem [...] ...|$|E
30|$|<b>Static</b> {{raclopride}} PET <b>binding</b> {{images from}} 20 patients with suspected parkinsonian syndrome were normalized to MNI space using the PET template. Following normalization, the maximum probability atlas (Hammers N 30 R 83) {{was applied for}} VOI definition. As a standard of reference, {{the definition of the}} atlas VOIs was verified in three orthogonal image planes by an experienced nuclear medicine physicist and manually optimized if necessary. The data was analyzed in both MNI space and OIS.|$|R
40|$|Most user {{interfaces}} are constructed by programs, {{so there is}} no direct relationship between the program, its structure and the user interface it implements. For example, graphics drawn on a screen need have no correspondence with regions of the screen sensitive to the user's input. View binding is introduced as a binding scheme (related to <b>static</b> or lexical <b>binding</b> schemes) whereby the user's browsing the user interface also manipulates the program's environment in a particular way...|$|R
40|$|The binding of Triton X- 100 (Tx) to {{bovine serum}} albumin(BSA) was studied using {{fluorescence}} spectroscopy. It was shown that TX {{has a strong}} ability to quench the BSA fluorescence mainly via a <b>static</b> quenching. The <b>binding</b> constant K {{and the number of}} bindig n were obtained from the fluorescence quenching results. It was revealed that K and n were changed with varying concentrations of TX: below cmc of TX, K was 440 mol/L, n was 0. 91; above cmc, K was 10 mg/L, n was 0. 42. The hydrophobic interactions {{played a major role in}} the binding process. The binding of Triton X- 100 (Tx) to bovine serum albumin(BSA) was studied using fluorescence spectroscopy. It was shown that TX has a strong ability to quench the BSA fluorescence mainly via a <b>static</b> quenching. The <b>binding</b> constant K and the number of bindig n were obtained from the fluorescence quenching results. It was revealed that K and n were changed with varying concentrations of TX: below cmc of TX, K was 440 mol/L, n was 0. 91; above cmc, K was 10 mg/L, n was 0. 42. The hydrophobic interactions played a major role in the binding process...|$|R
40|$|<b>Static</b> <b>binding</b> is the {{standard}} binding discipline in programming languages. However, the demands of developing distributed, highly dynamic applications have led to an increasing interest in dynamic programming languages and mechanisms. Typically, this needs are satisfied by hoc mechanisms that lack clean semantics. In this paper, we adopt a foundational approach, developing a core dynami...|$|E
40|$|Software {{product lines}} (SPLs) and {{adaptive}} systems aim at variability {{to cope with}} changing requirements. Variability {{can be described in}} terms of features, which are central for development and configuration of SPLs. In traditional SPLs, features are bound statically before runtime. By contrast, adaptive systems support feature binding at runtime and are sometimes called dynamic SPLs (DSPLs). DSPLs are usually built from coarse-grained components, which reduces the number of possible application scenarios. To overcome this limitation, we closely integrate <b>static</b> <b>binding</b> of traditional SPLs and runtime adaptation of DSPLs. We achieve this integration by statically generating a tailor-made DSPL from a highly customizable SPL. The generated DSPL provides only the runtime variability required by a particular application scenario and the execution environment. The DSPL supports self-configuration based on coarse-grained modules. We provide a feature-based adaptation mechanism that reduces the effort of computing an optimal configuration at runtime. In a case study, we demonstrate the practicability of our approach and show that a seamless integration of <b>static</b> <b>binding</b> and runtime adaptation reduces the complexity of the adaptation process...|$|E
40|$|Scalable {{software}} composition by reusing software assets {{is one of}} {{the major}} challenges in software engineering since many years. The goal of software product line engineering is to provide a systematic approach for reuse for a set of similar programs, called a software product line (SPL). The programs of an SPL can be distinguished in terms of features, which describe commonalities and differences between the programs. This allows SPL engineers to describe a program by listing its features. There are several SPL development techniques that support composition of assets to derive a tailor-made program according to a selection of required features. A main difference between existing techniques is their support for different feature binding times, i. e., the time at which a feature is included in a program. We can distinguish between static and dynamic binding. While <b>static</b> <b>binding</b> occurs before runtime (e. g., at compile-time), dynamic binding occurs during program start or in a running program. Both binding times have benefits and drawbacks. <b>Static</b> <b>binding</b> is used to generat...|$|E
40|$|Abstract. We {{propose a}} hybrid {{approach}} to partial evaluation to achieve self-application of realistic online partial evaluators. Whereas the o ine approach to partial evaluation leads to e cient specializers and self-application, online partial evaluators perform better specialization {{at the price}} of e-ciency. Moreover, no online partial evaluator for a realistic language has been successfully self-applied. We present a binding-time analysis for an online partial evaluator for a higher-order subset of Scheme. The analysis distinguishes between <b>static,</b> dynamic,andunknown <b>binding</b> times. Thus, it makes some reduce/residualize decisions o ine while leaving others to the specializer. The analysis does not introduce unnecessary generalizations. We have implemented the binding-time analysis and an online specializer to go with it. After some standard binding-time improvements, our partial evaluator successfully self-applies. Moreover, it is amenable to e ective specialization with an o ine partial evaluator...|$|R
40|$|Acanthamoeba granulomatous {{encephalitis}} (AGE), {{caused by}} Acanthamoeba castellanii, is a fatal infection of immunocompromised individuals. The pathogenesis of blood-brain barrier (BBB) breach remains unknown. Using a novel in vitro BBB infection model under flow conditions, demonstrates that increases in flow rates lead to decreased binding of A. castellanii to host cells. This {{is a distinct}} departure from previous findings under static conditions. However, similarly to <b>static</b> conditions <b>binding</b> of A. castellanii to host cells is host mannose dependent. Disruption of the host cell monolayer was independent of amoeba binding, but dependent on secreted serine proteases. For {{the first time we}} report the binding dynamics of A. castellanii under physiological conditions, showing that BBB disruption is not directly linked to binding, instead it is reliant on secreted proteases. Our results offer a platform on which therapies designed at modulating physiological parameters can improve the outcome of infection with A. castellanii...|$|R
40|$|AbstractThe {{interaction}} of human serum albumin (HSA) with osthole was investigated by fluorescence spectroscopy. Osthole can quench the fluorescence of HSA and the quenching mechanism is a <b>static</b> process. The <b>binding</b> site number n and apparent binding constant K were measured at different temperatures. The thermodynamic parameters ΔΗ 0, ΔG 0 and ΔS 0 were calculated at different temperatures. The {{results indicated that}} electrostatic forces {{played a major role}} in the {{interaction of}} osthole with HSA. Results of osthole synchronous fluorescence and UV absorption spectra showed that the microenvironment and conformation of HSA were changed...|$|R
