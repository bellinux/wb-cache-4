10000|10000|Public
5|$|In {{computer}} science, integer <b>sorting</b> is the algorithmic {{problem of}} <b>sorting</b> {{a collection of}} data values by numeric keys, {{each of which is}} an integer. Algorithms designed for integer <b>sorting</b> may also often be applied to <b>sorting</b> problems in which the keys are floating point numbers, rational numbers, or text strings. The ability to perform integer arithmetic on the keys allows integer <b>sorting</b> algorithms to be faster than comparison <b>sorting</b> algorithms in many cases, depending on the details of which operations are allowed in the model of computing and how large the integers to be sorted are.|$|E
5|$|Integer <b>sorting</b> {{algorithms}} including pigeonhole sort, counting sort, and radix sort {{are widely}} used and practical. Other integer <b>sorting</b> algorithms with smaller worst-case time bounds are not believed to be practical for computer architectures with 64 or fewer bits per word. Many such algorithms are known, with performance depending {{on a combination of}} the number of items to be sorted, number of bits per key, and number of bits per word of the computer performing the <b>sorting</b> algorithm.|$|E
5|$|Apple added deep {{learning}} capabilities for <b>sorting</b> and searching in the Photos app.|$|E
5000|$|... {{implements}} <b>sort,</b> bubble <b>sort,</b> quick <b>sort,</b> heap <b>sort</b> {{and insert}} <b>sort</b> algorithm.|$|R
40|$|We adapt merge <b>sort</b> for {{a single}} SPU of the Cell Broadband Engine. This {{adaptation}} {{takes advantage of the}} vector instructions supported by the SPU. Experimental results indicate that our merge <b>sort</b> adaptation is faster than other <b>sort</b> algorithms (e. g., AA <b>sort,</b> Cell <b>sort,</b> quick <b>sort)</b> proposed for the SPU as well as faster than our SPU adaptations of shaker <b>sort</b> and brick <b>sort.</b> An added advantage is that our merge <b>sort</b> adaptation is a stable <b>sort</b> whereas none of the other <b>sort</b> adaptations is stable...|$|R
25|$|A variant named binary merge <b>sort</b> uses {{a binary}} {{insertion}} <b>sort</b> to <b>sort</b> groups of 32 elements, {{followed by a}} final <b>sort</b> using merge <b>sort.</b> It combines the speed of insertion <b>sort</b> on small data sets {{with the speed of}} merge <b>sort</b> on large data sets.|$|R
5|$|Cognitive {{flexibility}} varies {{during the}} lifespan of an individual. Researchers have more specifically described cognitive flexibility as {{the capacity to}} shift or switch one’s thinking and attention between different tasks or operations typically {{in response to a}} change in rules or demands. For example, when <b>sorting</b> cards based on specific rules, children are considered cognitively flexible if they are able to successfully switch from <b>sorting</b> cards based on the color of the object to <b>sorting</b> based on the type of object on the card.|$|E
5|$|In the Multiple Classification Card <b>Sorting</b> Task, {{children}} are shown cards {{and asked to}} sort them based on two different dimensions (e.g. by color, such as yellow and blue, and object type, such as animals and food) simultaneously into four piles within a matrix (e.g. yellow animals, yellow foods, blue animals and blue foods). This task {{appears to be more}} difficult as research has shown that seven-year-old children were incapable of <b>sorting</b> cards based on the two dimensions simultaneously. These children focused on the two dimensions separately, whereas at the age of eleven, children were capable of <b>sorting</b> cards based on these two dimensions simultaneously. This demonstrates an increase in cognitive flexibility between the ages of seven and eleven.|$|E
5|$|Occurrences {{have been}} coded {{to allow for}} {{identification}} and <b>sorting</b> by group membership (accidents and related incidents versus attacks).|$|E
40|$|In {{this paper}} I extend the {{standard}} first-order resolution method with special reasoning mechanisms for <b>sorts.</b> <b>Sorts</b> are one place predicates. Literals built {{from one place}} predicates are called <b>sort</b> literals. Negative <b>sort</b> literals can be compiled into restrictions of the relevant variables to <b>sorts</b> or can be deleted if they fulfill special conditions. Positive <b>sort</b> literals define the <b>sort</b> structure for <b>sorted</b> unification. <b>Sorted</b> unification exploits the <b>sort</b> restrictions of variables. As the occurrence of <b>sort</b> literals is not restricted, it might be necessary to add additional literals to resolvents and factors and to dynamically change the set of positive <b>sort</b> literals used by <b>sorted</b> unification during the deduction process. The calculus I propose thus extends the standard resolution method by <b>sorted</b> unification, residue literals and a dynamic processing of the <b>sort</b> information. I show that this calculus generalizes and improves existing approaches to <b>sorted</b> reasoning. Finally I give some applications to automated theorem proving and abduction...|$|R
2500|$|Assuming the k+1st element's rank is random, {{insertion}} <b>sort</b> will {{on average}} require shifting {{half of the}} previous k elements, while selection <b>sort</b> always requires scanning all unplaced elements. So for unsorted input, insertion <b>sort</b> will usually perform about half as many comparisons as selection <b>sort.</b> If the input array is reverse-sorted, insertion <b>sort</b> performs as many comparisons as selection <b>sort.</b> If the input array is already <b>sorted,</b> insertion <b>sort</b> performs as few as n-1 comparisons, thus making insertion <b>sort</b> more efficient when given <b>sorted</b> or [...] "nearly sorted" [...] arrays.|$|R
5000|$|A Merge <b>Sort</b> {{partitions}} {{the data}} to be <b>sorted,</b> [...] into two roughly equal halves, [...] and , then <b>sorts</b> each half recursive, and then merges the two <b>sorted</b> halves into a fully <b>sorted</b> vector. The number of Bubble <b>Sort</b> swaps is equal to: ...|$|R
5|$|The empty wagons {{would then}} be shunted to the <b>sorting</b> sidings.|$|E
5|$|Billy Elliot – a 2000 film {{directed}} by Stephen Daldry. The power {{station and the}} smelter both feature as an industrial backdrop in the film's cemetery scenes. The power station's coal <b>sorting</b> area is used to represent a colliery.|$|E
5|$|Eventually, the 25 {{personnel}} of the Comité {{joined the}} CIA officers in <b>sorting</b> and processing the seized documents. The CIA officers had a separate side {{entrance to the}} building in which the operations took place, {{in order to maintain}} the image that the operation was a Guatemalan internal affair. The task of <b>sorting</b> through the papers proved to be daunting: by September, the main index of the material contained 15,800 cards. All hand-written material was preserved, and multiple copies of printed material were kept. Every document had to be reproduced, because the original copies of every document was to remain in Guatemala. Approximately half of the paper that had been gathered was incinerated. The CIA gave the highest priority to the documents seized from the PGT.|$|E
40|$|Summary. In {{this paper}} {{definitions}} of many <b>sorted</b> closure system and many <b>sorted</b> closure operator are introduced. These notations are also introduced in [11], {{but in another}} meaning. In this article closure system is absolutely multiplicative subset family of many <b>sorted</b> sets and in [11] is many <b>sorted</b> absolutely multiplicative subset family of many <b>sorted</b> sets. Analogously, closure operator is function between many <b>sorted</b> sets and in [11] is many <b>sorted</b> function from a many <b>sorted</b> set into a many <b>sorted</b> set...|$|R
50|$|Bulgarian {{has several}} pronouns of quality which have no direct {{parallels}} in English - kakav (what <b>sort</b> of); takuv (this <b>sort</b> of); onakuv (that <b>sort</b> of - colloq.); nyakakav (some <b>sort</b> of); nikakav (no <b>sort</b> of); vsyakakav (every <b>sort</b> of); {{and the relative}} pronoun kakavto (the <b>sort</b> of...that...). The adjective ednakuv ("the same") derives from the same radical.|$|R
5000|$|... #Caption: An {{example of}} stable <b>sort</b> on playing cards. When the cards are <b>sorted</b> by rank with a stable <b>sort,</b> the two 5s must {{remain in the}} same order in the <b>sorted</b> output that they were {{originally}} in. When they are <b>sorted</b> with a non-stable <b>sort,</b> the 5s may end up in the opposite order in the <b>sorted</b> output.|$|R
5|$|However, {{despite their}} {{theoretical}} advantages, these algorithms {{are not an}} improvement for the typical ranges of these parameters that arise in practical <b>sorting</b> problems.|$|E
5|$|In the Dimensional Change Card <b>Sorting</b> Task (DCCS), {{children}} are initially asked to sort cards {{by a single}} dimension (such as color), and are subsequently required to alter their strategy to sort cards based on a second dimension (such as shape). Typically, three-year-old {{children are}} able to sort cards based on a single dimension, but are unable to switch to sort the cards based on a second dimension. However, five-year-old children are able to sort cards based on one dimension and can then switch to <b>sorting</b> cards on a second dimension.|$|E
5|$|Integer <b>sorting</b> {{provides}} {{one of the}} six benchmarks in the DARPA High Productivity Computing Systems Discrete Mathematics benchmark suite, and one {{of eleven}} benchmarks in the NAS Parallel Benchmarks suite.|$|E
50|$|A most {{significant}} digit (MSD) radix <b>sort</b> {{can be used to}} <b>sort</b> keys in lexicographic order. Unlike a least significant digit (LSD) radix <b>sort,</b> a {{most significant}} digit radix <b>sort</b> does not necessarily preserve the original order of duplicate keys. An MSD radix <b>sort</b> starts processing the keys from the {{most significant digit}}, leftmost digit, to the least significant digit, rightmost digit. This sequence is opposite that of least significant digit (LSD) radix <b>sorts.</b> An MSD radix <b>sort</b> stops rearranging the position of a key when the processing reaches a unique prefix of the key. Some MSD radix <b>sorts</b> use one level of buckets in which to group the keys. See the counting <b>sort</b> and pigeonhole <b>sort</b> articles. Other MSD radix <b>sorts</b> use multiple levels of buckets, which form a trie or a path in a trie. A postman's <b>sort</b> / postal <b>sort</b> is a kind of MSD radix <b>sort.</b>|$|R
40|$|In {{this article}} I {{investigate}} {{the properties of}} unification in <b>sort</b> theories. The usual notion of a <b>sort</b> consisting of a <b>sort</b> symbol is extended {{to a set of}} <b>sort</b> symbols. In this language <b>sorted</b> unification in elementary <b>sort</b> theories is of unification type finitary. The rules of standard unification with the addition of four <b>sorted</b> rules form the new <b>sorted</b> unification algorithm. The algorithm is proved sound and complete. The rule based form of the algorithm is not suitable for an implementation because there is no control and the used data structures are weak. Therefore we transform the algorithm into a deterministic <b>sorted</b> unification procedure. For the procedure <b>sorted</b> unification in pseudo-linear <b>sort</b> theories is proved decidable. The notions of a <b>sort</b> and a <b>sort</b> theory are developed in a way such that a standard calculus can be turned into a <b>sorted</b> calculus by replacing standard unification with <b>sorted</b> unification. To this end <b>sorts</b> may denote the empty set. <b>Sort</b> theories may contain clauses with more than one declaration and may change dynamically during the deduction process. The applicability of the approach is exemplified for the resolution and the tableau calculus...|$|R
50|$|A merge <b>sort</b> {{splits the}} records of a dataset into <b>sorted</b> runs of records and then {{repeatedly}} merges <b>sorted</b> runs into larger <b>sorted</b> runs until only one run, the <b>sorted</b> dataset, remains.|$|R
5|$|Perl {{also has}} many {{built-in}} functions that provide tools {{often used in}} shell programming (although many of these tools are implemented by programs external to the shell) such as <b>sorting,</b> and calling operating system facilities.|$|E
5|$|Pigeonhole sort, {{counting}} sort, radix sort, and Van Emde Boas tree <b>sorting</b> {{all work}} best when the key size is small; for large enough keys, they become slower than comparison <b>sorting</b> algorithms. However, when the key size or the word size is very large {{relative to the}} number of items (or equivalently when the number of items is small), it may again become possible to sort quickly, using different algorithms that take advantage of the parallelism inherent in the ability to perform arithmetic operations on large words.|$|E
5|$|The Canadian Union of Postal Workers {{objected to}} the {{automated}} <b>sorting</b> system mainly because the wages of those who ran the new automated machines were much lower {{than those who had}} hand-sorted mail.|$|E
40|$|Integrating <b>sorts</b> (types) into logic {{programming}} languages increases expressiveness and evaluation efficiency. To support richer <b>sort</b> {{structures such as}} parametric and inclusion polymorphism, static <b>sort</b> checking is insufficient. Therefore efficient dynamic <b>sort</b> checking {{is an important issue}} in <b>sorted</b> {{logic programming}}. We first compare existing techniques for dynamic <b>sort</b> checking in the literature. Aiming to achieve more efficient dynamic <b>sort</b> checking, we propose a new evaluation procedure, based on constraint consistency checking, for <b>sorted</b> logic programs and goals...|$|R
40|$|Although mathematically elegant, partial orders {{limit the}} {{representation}} of taxonomic knowledge to subsort-supersort (or isa) relationships. We cannot, for example, directly state that two <b>sorts</b> are incompatible or define one <b>sort</b> as the intersection {{of a set of}} other <b>sorts.</b> This poses problems for specifying more complete taxonomic relationships as well as for denotational semantics in <b>sorted</b> logic. Research on many <b>sorted</b> logics has addressed this issue by expanding the expressive power of relationships among <b>sorts.</b> In this paper we propose the extraction of <b>sort</b> reasoning from the application, whether this is within a logic, a programming language or a knowledge representation system. This specialized <b>sort</b> reasoner is given information about <b>sorts</b> in the form of assertions and can be called upon to answer queries regarding the <b>sort</b> structure specified. We develop a sound and complete propositional <b>sort</b> logic with which the <b>sort</b> reasoner operates. Unfortunately, general <b>sort</b> reaso [...] ...|$|R
40|$|I {{would like}} to thank my colleages at the Max-Planck-Institut for many helpful com-ments on this paper. In this article I {{investigate}} the properties of unification in <b>sort</b> theories. The usual notion of a <b>sort</b> consisting of a <b>sort</b> symbol is extended to a set of <b>sort</b> symbols. In this language <b>sorted</b> unification in elementary <b>sort</b> theories is of unification type finitary. The rules of standard unification with the addition of four <b>sorted</b> rules form the new <b>sorted</b> unification al-gorithm. The algorithm is proved sound and complete. The rule based form of the algorithm is not suitable for an implementation because there is no control and the used data structures are weak. Therefore we trans-form the algorithm into a deterministic <b>sorted</b> unification procedure. For the procedure <b>sorted</b> unification in pseudo-linear <b>sort</b> theories is proved decidable. The notions of a <b>sort</b> and a <b>sort</b> theory are developed in a way such that a standard calculus can be turned into a <b>sorted</b> calculus by replacing standard unification with <b>sorted</b> unification. To this end <b>sorts</b> may denote the empty set. <b>Sort</b> theories may contain clauses with more than one declaration and may change dynamically during the deduction process. The applicability of the approach is exemplified for the resolution and the tableau calculus...|$|R
5|$|The Wisconsin Card <b>Sorting</b> Test (WCST) {{is used to}} {{determine}} an individual's competence in abstract reasoning, {{and the ability to}} change problem-solving strategies when needed.|$|E
5|$|The {{introduction}} {{of such a}} code system allowed Canada Post to easily speed up and simplify the flow of mail in the country, with <b>sorting</b> machines being able to handle 26,640 objects an hour.|$|E
5|$|The {{library is}} fully wheelchair-accessible, with {{multiple}} elevators. There are public use touchscreen computers, a dedicated computer lab, wireless internet, and conference and community rooms. An automatic conveyor belt system links the book drops to a dedicated <b>sorting</b> room. It handled 80,000 books in July 2015.|$|E
50|$|An {{example of}} a list that proves this point is the list (2,3,4,5,1), which would only need to go through one pass of {{cocktail}} <b>sort</b> to become <b>sorted,</b> but if using an ascending bubble <b>sort</b> would take four passes. However one cocktail <b>sort</b> pass should be counted as two bubble <b>sort</b> passes. Typically cocktail <b>sort</b> is less than two times faster than bubble <b>sort.</b>|$|R
60|$|Callicoes, divers <b>Sorts.</b> Hollands, {{and several}} <b>sorts</b> of Sheeting Linnen. Several <b>sorts</b> of Diapers and Table-Cloths. Several <b>sorts</b> of Cambricks. Mantua Silks, and Grassets. Beryllan, and plain Callimanco. Tamie yard-wide. Men's dyed shammie Gloves. Women's Ditto, Lamb. Stitching Silk, Thread and Silk. Twist for Women. Silk and Ribbands. Double Thread Stockings. Men's white shammie Gloves. Silk Handkerchiefs, & other <b>sorts</b> of Handkerchiefs. Men's glaz'd Gloves, Topp'd. Men's Shoe-Buckles, Bath-metal. Masks for Women. Several <b>sorts</b> of Penknives. Plain metal Buttons for Men's Coats and Jackets. Ivory Case-Knives, and several <b>sorts</b> of Pocket-Knives. Dowlasses several <b>sorts.</b> Huckabags, and Russia Linnen. Oznaburghs. Several <b>sorts</b> of Looking Glasses. Garlicks and brown Holland. Bag-Holland Ditto. Several <b>sorts</b> of Druggets. Fine Kerseys. Superfine double-mill'd Drab. Broad-Cloths. London Shalloons. Fine and coarse Hats. Men and Women's English Shoes. Stockings, several <b>sorts,</b> for Men, Women and Children. Several <b>sorts</b> of Caps. Women's Bonnets. Several <b>sorts</b> of Horn and Ivory Combs. Gun-powder, Shot, and Flints. Bibles of several <b>sorts.</b> Testaments, Psalters and Primers. Large Paper Books, and small ones, with Pocket-Books, and other Stationary Ware. Several <b>sorts</b> of Checquer'd Linnen. Flannels and Duroys. Scots-Snuff.|$|R
25|$|Insertion <b>sort</b> is {{very similar}} to {{selection}} <b>sort.</b> As in selection <b>sort,</b> after k passes through the array, the first k elements are in <b>sorted</b> order. For selection <b>sort</b> these are the k smallest elements, while in insertion <b>sort</b> they are whatever the first k elements were in the unsorted array. Insertion <b>sort's</b> advantage is that it only scans as many elements as needed to determine the correct location of the k+1st element, while selection <b>sort</b> must scan all remaining elements to find the absolute smallest element.|$|R
