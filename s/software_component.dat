1777|8270|Public
5|$|Kaspersky {{himself is}} the {{co-author}} of several patents, including one for a constraint-and-attribute-based security system for controlling <b>software</b> <b>component</b> interaction.|$|E
25|$|WebKit is a {{layout engine}} <b>software</b> <b>component</b> for {{rendering}} web pages in web browsers. It powers Apple's Safari web browser.|$|E
25|$|Previously {{known as}} Plex Media Center, Plex Home Theater is the <b>software</b> <b>component</b> {{used for a}} long time as the {{front-end}} media player for Plex's back-end server component Plex Media Server.|$|E
40|$|Abstract: Today, it is {{important}} for software companies to build software systems in a short time-interval, to reduce costs and to have a good market position. Therefore well organized and systematic development approaches are required. Reusing <b>software</b> <b>components,</b> which are well tested, can be a good solution to develop software applications in effective manner. The reuse of <b>software</b> <b>components</b> is less expensive and less time consuming than a development from scratch. But it is dangerous to think that <b>software</b> <b>components</b> can be match together without any problems. <b>Software</b> <b>components</b> itself are well tested, of course, but even if they composed together problems occur. Most problems are based on interaction respectively communication. Avoiding such errors a framework has to be developed for analysing <b>software</b> <b>components.</b> That framework determines the compatibility of corresponding <b>software</b> <b>components.</b> The promising approach discussed here presents a novel technique for analysing <b>software</b> <b>components</b> by applying an abstract syntax language tree (ASLT). A supportive environment will be designed that checks the compatibility of black-box softwar...|$|R
40|$|Handling of {{reusable}} <b>software</b> <b>components</b> {{will be a}} {{step towards}} creating a discipline {{in the field of}} reusable <b>software</b> <b>components.</b> The concept of handling emerges from the idea that the reusable components should be used, transacted, stimulated, and retrieved by adhering to proper guidelines and standards. As the guidelines and standards are followed while handling with the other entities, the <b>software</b> <b>components</b> should also be dealt with the same way. If the guidelines and standards are not followed while handling the <b>software</b> <b>components,</b> there won’t be any regularity on the components. Therefore, the study has provided with the standards and guidelines for handling of reusable <b>software</b> <b>components.</b> It would affect the quality of reusable <b>software</b> <b>components.</b> Consequently, the quality of software products composed from these components will be affected. Also, the lack of handling will {{have a negative impact on}} the whole market of reusable components. The study also stated the process and the elements involved in the process of handling of reusable <b>software</b> <b>components...</b>|$|R
40|$|Today, it is {{important}} for software companies to build software systems in a short time-interval, to reduce costs and to have a good market position. Therefore well organized and systematic development approaches are required. Reusing <b>software</b> <b>components,</b> which are well tested, can be a good solution to develop software applications in effective manner. The reuse of <b>software</b> <b>components</b> is less expensive and less time consuming than a development from scratch. But it is dangerous to think that <b>software</b> <b>components</b> can be match together without any problems. <b>Software</b> <b>components</b> itself are well tested, of course, but even if they composed together problems occur. Most problems are based on interaction respectively communication. Avoiding such errors a framework has to be developed for analysing <b>software</b> <b>components.</b> That framework determines the compatibility of corresponding <b>software</b> <b>components.</b> The promising approach discussed here, presents a novel technique for analysing <b>software</b> <b>components</b> by applying an Abstract Syntax Language Tree (ASLT). A supportive environment will be designed that checks the compatibility of black-box <b>software</b> <b>components.</b> This article is concerned to the question how can be coupled <b>software</b> <b>components</b> verified by using an analyzer framework and determines the usage of the ASLT. Black-box <b>Software</b> <b>Components</b> and Abstract Syntax Language Tree are the basis for developing the proposed framework and are discussed here to provide the background knowledge. The practical implementation of this framework is discussed and shows the result by using a test environment. Comment: 20 pages, exposed on 5 th International Conference "Actualities and Perspectives on Hardware and Software" - APHS 2009, Timisoara, Romani...|$|R
25|$|On September 2, 2010, Plex {{announced}} {{a partnership with}} LG to integrate the <b>software</b> <b>component</b> into LG 2011 NetCast™ enabled HDTVs and Blu-ray devices. Now, only NeCast models from 2013 and models running webOS are supported.|$|E
25|$|Late 2000s {{versions}} of Google Earth require a <b>software</b> <b>component</b> {{running in the}} background that will automatically download and install updates. Several users expressed concerns that there is not an easy way to disable this updater, as it runs without the permission of the user.|$|E
25|$|ReadyBoost (codenamed EMD) is a disk caching <b>software</b> <b>component</b> {{developed}} by Microsoft for Windows Vista and included in later {{versions of the}} Windows operating system. ReadyBoost enables NAND memory mass storage devices, including CompactFlash, SD cards, and USB flash drives, {{to be used as}} a write cache between a hard drive and random access memory in an effort to increase computing performance. ReadyBoost relies on the SuperFetch technology and, like SuperFetch, adjusts its cache based on user activity. Other features, including ReadyDrive, are implemented in a manner similar to ReadyBoost.|$|E
40|$|Abstract: The {{globalization}} {{of the software}} market leads to crucial problems for software companies. More competition between software companies arises and leads to the force on companies to develop ever newer software products in ever shortened time interval. Therefore the time to market for software systems is shortened and obviously the product life cycle is shortened too. Thus software companies shortened the time interval for research and development. Due to the fact of competition between software companies software products have to develop low-priced and {{this leads to a}} smaller return on investment. A big challenge for software companies is the use of an effective research and development process to have these problems under control. A way to control these problems can be the reuse of existing <b>software</b> <b>components</b> and adapt those <b>software</b> <b>components</b> to new functionality or accommodate mismatched interfaces. Complete redevelopment of software products is more expensive and time consuming than to develop <b>software</b> <b>components.</b> The approach introduced here presents novel technique together with a supportive environment that enables developers to cope with the adaptability of black-box <b>software</b> <b>components.</b> A supportive environment will be designed that checks the compatibility of black-box <b>software</b> <b>components</b> with the assistance of their specifications. Generated adapter <b>software</b> <b>components</b> can take over the part of adaptation and advance the functionality. Besides, a pool of <b>software</b> <b>components</b> can be used to compose an application to satisfy customer needs. Certainly this pool of <b>software</b> <b>components</b> consists of black-box <b>software</b> <b>components</b> and adapter <b>software</b> <b>components</b> which can be connected on demand. ...|$|R
40|$|Component-based {{software}} engineering (CBSE) is {{the construction of}} software systems from <b>software</b> <b>components.</b> <b>Software</b> <b>components</b> are independently deployable units of executable code that can be assembled into a system based on their externally visible properties, which are made available to system developers via the <b>components</b> interface specifications. <b>Software</b> <b>components</b> provide a means for large-scale reuse o...|$|R
40|$|Heterogeneous {{computing}} {{creates a}} need for transparent communication between distributed <b>software</b> <b>components.</b> Transparent communication is often handled by preexisting low-level communication software packages. A high-level abstract communication architecture leverages off of a pre-existing low-level communication software package to facilitate the creation of distributed <b>software</b> <b>components</b> and to provide simple methods for their integration into distributed applications. BORG is a high-level abstract communication architecture that fosters the evolution of legacy systems into an object model by providing tools that simplify the creation, acquisition and use of distributed <b>software</b> <b>components</b> within that legacy system. A distributed bulletin board assists applications in obtaining and integrating distributed <b>software</b> <b>components</b> which have been created from the legacy system. Distributed <b>software</b> <b>components</b> can be crafted from the legacy system via tools that abstract and encapsulate [...] ...|$|R
2500|$|The Dulwich {{implementation}} of Git {{is a pure}} Python <b>software</b> <b>component</b> for Python 2.7, 3.4 and 3.5 ...|$|E
2500|$|DirectSound is a {{deprecated}} <b>software</b> <b>component</b> of the Microsoft DirectX {{library for}} the [...] Windows operating system. DirectSound provides a low-latency interface to sound card drivers written for Windows 95 through Windows XP and {{can handle the}} mixing and recording of multiple audio streams.|$|E
2500|$|In December 2009, {{the project}} {{evolved into a}} {{commercial}} software business owned and developed by a single for-profit startup company, Plex, Inc., a U.S.-based high tech firm {{that is responsible for}} the development of the Plex Media Server and media player app front- and back-ends, its client–server model, all accompanying software under the Plex brand name, as well as the exclusive, copyrighted, proprietary parts, whether distributed on its own or as a third-party <b>software</b> <b>component</b> in products manufactured via a strategic partnership. [...] Elan Feingold, Scott Olechowsi and Cayce Ullman were the three founders, with Ullman and Feingold taking on full-time roles as the CEO and CTO, respectively.|$|E
40|$|<b>Software</b> <b>components</b> are {{increasingly}} central to efficient, cost-effective <b>software</b> development. <b>Components</b> are the special {{status of the}} software system, so the formal description of the components is very important. First, the concept and characteristics of components are given. Second, the definition of OR-transition Colored Petri Net is given. Third, in according to the properties of <b>software</b> <b>components,</b> a formal definition of component is presented. And based on OR-transition Colored Petri Net, an approach is put forward to modeling the <b>software</b> <b>components</b> formally. Finally, an example is given...|$|R
40|$|Software {{industry}} is moving towards a component-based development but {{more research is}} still needed for reliable and efficient <b>software</b> <b>components.</b> The objective of this work is to propose an approach to developing <b>software</b> <b>components</b> of the system from use cases. This approach consists of four stages {{and is based on}} the decomposition of use cases into elementary actions and the factorization of the past for system <b>software</b> <b>components...</b>|$|R
5000|$|Hooking - {{range of}} {{techniques}} used to alter or augment {{the behavior of}} an operating system, of applications, or of other <b>software</b> <b>components</b> by intercepting function calls or messages or events passed between <b>software</b> <b>components</b> ...|$|R
2500|$|Windows Installer (previously {{known as}} Microsoft Installer, codename Darwin) is a <b>software</b> <b>component</b> and {{application}} programming interface (API) of Microsoft Windows used for the installation, maintenance, and removal of software. The installation information, and optionally the files themselves, are packaged in installation packages, loosely relational databases structured as COM Structured Storages and commonly known as [...] "MSI files", from their default filename extensions. Windows Installer contains significant changes from its predecessor, Setup API. New features include a GUI framework and automatic generation of the uninstallation sequence. [...] Windows Installer is positioned {{as an alternative to}} stand-alone executable installer frameworks such as older versions of InstallShield and NSIS.|$|E
2500|$|OLE DB (also called OLEDB or OLE-DB) allows MDAC {{applications}} {{access to}} {{different types of}} (...) stores in a uniform manner. Microsoft has used this technology to separate the application from data can store in the website the data store {{that it needs to}} access. This was done because different applications need access to different types and sources of data, and do not necessarily {{need to know how to}} access technology-specific functionality. The technology is conceptually divided into consumers and providers. The consumers are the applications that need access to the data, and the provider is the <b>software</b> <b>component</b> that exposes an OLE DB interface through the use of the Component Object Model (or COM).|$|E
50|$|The {{concept of}} the NWDI starts with a product and a <b>software</b> <b>component</b> (SC). The normal case {{is to have a}} {{one-to-one}} relationship between product and <b>software</b> <b>component,</b> one product is being developed and the relations between the components comprising the product are kept within a <b>software</b> <b>component.</b>|$|E
40|$|The {{construction}} of software systems from pre-existing, independently developed <b>software</b> <b>components</b> will only occur when application builders can adapt <b>software</b> <b>components</b> {{to suit their}} needs. We propose that <b>software</b> <b>components</b> provide two interfaces [...] one for behavior and one for adapting that behavior as needed. The ADAPT framework {{presented in this paper}} supports both component designers in creating components that can easily be adapted, and application builders in adapting <b>software</b> <b>components.</b> The motivating example, using JavaBeans, shows how adaptation, not customization, is the key to component-based <b>software.</b> KEYWORDS <b>Software</b> <b>components,</b> JavaBeans, Adaptation 1 INTRODUCTION An important aim of software engineering is to produce reliable and robust software systems. As software systems grow in size, however, it becomes infeasible to design and construct software systems from scratch. Most software developers are familiar with reusing code from component libraries to speed [...] ...|$|R
40|$|This paper explores how to {{characterize}} security properties of <b>software</b> <b>components,</b> {{and how to}} reason about their suitability for a trustworthy compositional contract. Our framework provides an explicit opportunity for software composers as well as <b>software</b> <b>components</b> to test a priori security properties of <b>software</b> <b>components</b> in a system composition. The proposed framework uses logic programming {{as a tool to}} represent security properties of atomic components and reason about their compositional matching with other <b>components.</b> This enables <b>software</b> <b>components</b> as well as composers to "test" possible matches and mismatches between the security properties of the candidate components and the security requirements of the enclosing applications systems...|$|R
40|$|Moebius is a {{representation}} and interface language {{based on a}} subset of English. It is designed {{for use as a}} means of encoding information and as a means of conveying information between <b>software</b> <b>components</b> and other <b>software</b> <b>components,</b> between <b>software</b> <b>components</b> and humans, and between data repositories and their users [...] human or machine. This report describes the structure and use of the Moebius language and presents three applications of the language to date...|$|R
50|$|In {{computer}} programming, {{a third-party}} <b>software</b> <b>component</b> is a reusable <b>software</b> <b>component</b> developed {{to be either}} freely distributed or sold by an entity other than the original vendor of the development platform. The third-party <b>software</b> <b>component</b> market thrives because many programmers believe that component-oriented development improves the efficiency {{and the quality of}} developing custom applications. Common third-party software includes macros, bots, and software/scripts to be run as add-ons for popular developing software.|$|E
50|$|A <b>software</b> <b>component</b> {{comprises}} {{one or more}} development components (DC). A development component {{consists of}} a normal project created with the Netweaver Developer Studio, i.e. a Dynpro application. The <b>software</b> <b>component</b> can also have dependencies to other SCs.|$|E
50|$|BS 7925-2 is BSI's <b>software</b> <b>component</b> testing standard.|$|E
40|$|We {{argue that}} delayed-evaluation, self-optimising {{scientific}} <b>software</b> <b>components,</b> which dynamically change their behaviour {{according to their}} calling context at runtime offer a possible way of bridging the apparent conflict between the quality of scientific software and its performance. Rather than equipping scientific <b>software</b> <b>components</b> with a performance interface which allows the caller to supply the context information that is lost when building abstract <b>software</b> <b>components,</b> we propose to recapture this lost context information at runtime...|$|R
50|$|A {{computer}} running several <b>software</b> <b>components</b> {{is often}} called an application server. This combination of application servers and <b>software</b> <b>components</b> is usually called distributed computing. Typical real-world application of this is in, e.g., financial applications or business software.|$|R
40|$|This paper characterizes {{refinement}} of state-based <b>software</b> <b>components</b> modeled as pointed coalgebras for some Set endofunctors. The proposed characterization is parametric on a specification {{of the underlying}} behaviour model introduced as a strong monad. This provides a basis to reason about (and transform) state-based software designs. In particular it is shown how refinement {{can be applied to}} the development of the inequational subset of a calculus of generic <b>software</b> <b>components.</b> Key words: <b>software</b> <b>components,</b> refinement, coalgebra...|$|R
50|$|Constraint {{analysis}} {{evaluates the}} design of a <b>software</b> <b>component</b> against restrictions imposed by requirements and real-world limitations. The design must be responsive to all known or anticipated restrictions on the <b>software</b> <b>component.</b> These restrictions may include timing, sizing, and throughput constraints, input and output data limitations, equation and algorithm limitations, and other design limitations.|$|E
5000|$|Free Component Library (FCL): High-level <b>software</b> <b>component</b> {{library for}} general {{programming}} tasks ...|$|E
5000|$|JESAM: Open source {{parallel}} scalable DNA alignment engine with optional clustering <b>software</b> <b>component</b> ...|$|E
40|$|The component-based {{model of}} code {{execution}} imposes some requirements on the <b>software</b> <b>components</b> themselves, {{and at the}} same time lays some constraints on the modern run-time environment. <b>Software</b> <b>components</b> need to store descriptive metadata, and the run-time system must access this `reflectively' in order to implement dynamic linking. <b>Software</b> <b>components</b> also undergo dynamic evolution whereby a client component experiences the effects of modifications, made to a service component even though these occurred after the client was built...|$|R
40|$|The {{increasing}} number of available <b>software</b> <b>components</b> and competing interoperability standards render the selection, composition, and configuration of <b>software</b> <b>components</b> increasingly complex. In order to support the domain expert in these processes comprehensive, comparable, and sufficiently abstract component descriptions are required. In this paper, we abstract from {{the specifics of the}} component models COM, EJB, and CCM, and propose a unifying component description language for integrated descriptions of structure and behaviour of <b>software</b> <b>components</b> and component-based <b>software</b> systems...|$|R
40|$|A key {{challenge}} in Component-Based Software Engineering (CBSE) approaches to build software systems using pre-existing <b>software</b> <b>components</b> is searching and selecting appropriate <b>software</b> <b>components</b> for reuse. A component broker that allows component vendors {{to make available}} their modules, and allows component integrators to search and select components matching its requirements will provide {{a solution to this}} problem. In the present thesis, we present the design and architecture of ComponentXchange, an E-Exchange for buying and selling of <b>software</b> <b>components</b> over the World Wide Web...|$|R
