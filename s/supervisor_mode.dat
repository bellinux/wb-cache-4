70|15|Public
25|$|At {{power-on}} or reset, {{the system}} begins in <b>supervisor</b> <b>mode.</b> Once an operating system kernel {{has been loaded}} and started, the boundary between user mode and <b>supervisor</b> <b>mode</b> (also known as kernel mode) can be established.|$|E
25|$|In a {{monolithic}} kernel, {{the operating system}} runs in <b>supervisor</b> <b>mode</b> and the applications run in user mode. Other types of operating systems, like those with an exokernel or microkernel, do not necessarily share this behavior.|$|E
25|$|DOS (for {{as long as}} no 386 memory manager such as EMM386 is loaded), as well {{as other}} simple {{operating}} systems and many embedded devices run in <b>supervisor</b> <b>mode</b> permanently, meaning that drivers can be written directly as user programs.|$|E
5000|$|Clear {{separation}} between user <b>mode</b> and <b>supervisor</b> (kernel) <b>mode.</b>|$|R
50|$|There are two {{operational}} <b>modes,</b> <b>supervisor</b> and user <b>mode.</b> Besides {{the difference}} in memory referencing described above, supervisor-mode programs can execute input/output operations.|$|R
40|$|Talisman is a {{simulator}} that models {{the execution}} semantics {{and timing of}} a multicomputer. Talisman is unique in combining high semantic accuracy, high timing accuracy, portability, and good performance. This good performance allows users to run significant programs on large simulated multicomputers. The combination of high accuracy and good performance yields an ideal tool for evaluating architectural trade-offs. Talisman models the semantics of virtual memory, a circuit-switched internode interconnect, I/O devices, and instruction execution in both user and <b>supervisor</b> <b>modes.</b> It also models the timing of processor pipelines, caches, local memory buses, and a circuit-switched interconnect. Talisman executes the same program binary images as a hardware prototype {{at a cost of}} about 100 host instructions per simulated instruction. On a suite of accuracy benchmarks run on the hardware and the simulator, Talisman and the prototype differ in reported running times by only a few percent. ...|$|R
25|$|A {{system call}} is a {{mechanism}} {{that is used}} by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from <b>supervisor</b> <b>mode</b> to protected mode. This is where the operating system performs actions like accessing hardware devices or the memory management unit. Generally the operating system provides a library that sits between the operating system and normal programs. Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to <b>supervisor</b> <b>mode.</b> System calls include close, open, read, wait and write.|$|E
25|$|Linux and Windows are two {{operating}} systems that use supervisor/user mode. To perform specialized functions, user mode code must perform a system call into <b>supervisor</b> <b>mode</b> {{or even to}} the kernel space where trusted code of the operating system will perform the needed task and return the execution back to the userspace.|$|E
25|$|In both {{segmentation}} and paging, certain {{protected mode}} registers specify to the CPU what memory address it should allow a running program to access. Attempts to access other addresses trigger an interrupt which cause the CPU to re-enter <b>supervisor</b> <b>mode,</b> placing the kernel in charge. This {{is called a}} segmentation violation or Seg-V for short, and since it is both difficult to assign a meaningful result to such an operation, {{and because it is}} usually a sign of a misbehaving program, the kernel generally resorts to terminating the offending program, and reports the error.|$|E
50|$|If the {{hardware}} provides multiple rings or CPU modes, the microkernel {{may be the}} only software executing at the most privileged level, which is generally referred to as <b>supervisor</b> or kernel <b>mode.</b> Traditional operating system functions, such as device drivers, protocol stacks and file systems, are typically removed from the microkernel itself and are instead run in user space.|$|R
40|$|Abstract. A hybrid {{control system}} is {{proposed}} for regulating an unknown nonlinear plant. The interface between the continuous-state plant and the discrete-event supervisor is designed using a fuzzy logic approach. The fuzzy logic interface partitions the continuous-state space into {{a finite number}} of regions. In each region, the original unknown nonlinear plant is approximated by a fuzzy logic-based linear model, then state-feedback controllers are designed for each linear model. A high-level <b>supervisor</b> coordinates (<b>mode</b> switching) the set of closed-loop systems in a stable and safe manner. The stability of the system is studied using nonsmooth Lyapunov functions. For illustration and verification purposes, this technique has been applied to the well-known inverted pendulum balancing problem. 1...|$|R
50|$|The CPU {{contains}} eight general-purpose 16-bit registers (R0 to R7). Register R7 is {{the program}} counter (PC). Although any register {{can be used}} as a stack pointer, R6 is the stack pointer (SP) used for hardware interrupts and traps. R5 is often used to point to the current procedure call frame. To speed up context switching, some PDP-11 models provide separate stack pointers for Kernel, <b>Supervisor,</b> and User <b>modes,</b> which also have separate memory maps, and dual R1-R5 register sets.|$|R
25|$|In the Unix model, the {{operating}} system consists of two parts; first, the huge collection of utility programs that drive most operations, the other the kernel that runs the programs. Under Unix, from a programming standpoint, {{the distinction between the}} two is fairly thin; the kernel is a program, running in <b>supervisor</b> <b>mode,</b> that acts as a program loader and supervisor for the small utility programs making {{up the rest of the}} system, and to provide locking and I/O services for these programs; beyond that, the kernel didn't intervene at all in user space.|$|E
25|$|These {{types of}} kernels consist {{of the core}} {{functions}} of the operating system and the device drivers {{with the ability to}} load modules at runtime. They provide rich and powerful abstractions of the underlying hardware. They provide a small set of simple hardware abstractions and use applications called servers to provide more functionality. This particular approach defines a high-level virtual interface over the hardware, with a set of system calls to implement operating system services such as process management, concurrency and memory management in several modules that run in <b>supervisor</b> <b>mode.</b>|$|E
2500|$|<b>Supervisor</b> <b>mode</b> {{is used by}} the kernel for {{low level}} tasks that need {{unrestricted}} access to hardware, such as controlling how memory is accessed, and communicating with devices such as disk drives and video display devices. User mode, in contrast, is used for almost everything else. Application programs, such as word processors and database managers, operate within user mode, and can only access machine resources by turning control over to the kernel, a process which causes a switch to <b>supervisor</b> <b>mode.</b> [...] Typically, the transfer of control to the kernel is achieved by executing a software interrupt instruction, such as the Motorola 68000 TRAP instruction. [...] The software interrupt causes the microprocessor to switch from user mode to <b>supervisor</b> <b>mode</b> and begin executing code that allows the kernel to take control.|$|E
40|$|The {{principles}} of Washington and {{the destiny of}} the republic [...] Industrial educaton [...] The death of Verdi [...] Memorial exercises [...] The dedication of the Goethe Schiller monument [...] Welcome to President McKinley [...] The death of President McKinley [...] Memorial services [...] Debate with imperial Chinese Consul, Ho Yow, at the Unitarian Club, on the Chinese question [...] Valedictory address to the Board of <b>Supervisors,</b> January, 1902. <b>Mode</b> of access: Internet. BANC; F 869. S 3. P 4 : Printing master available (85 - 1746). Shelved with Main's negativesBANC; F 869. S 3. P 4 : Bancroft also has positive microfil...|$|R
50|$|There {{is also a}} sub-mode of {{operation}} in 32-bit protected mode (a.k.a. 80386 protected mode) called virtual 8086 mode, also known as V86 mode. This is basically a special hybrid operating mode that allows real mode programs and operating systems to run while {{under the control of}} a protected <b>mode</b> <b>supervisor</b> operating system. This allows for a great deal of flexibility in running both protected mode programs and real mode programs simultaneously. This mode is exclusively available for the 32-bit version of protected mode; it does not exist in the 16-bit version of protected mode, or in long mode.|$|R
40|$|ABSTRACT: When {{hardware}} intemrpt priorities don't {{match the}} needs of software, operating system designers often just suffer in silence. '!Ve describe an alternative here: simulating the hardware priority interrupt queueing mechanism in software, but assigning the (software) intemrpt priorities as we wish. This was done on an AMD 29200 microconffoller [Advanced Micro Devices 19941 which has effectively only two intemrpt levels: the clock and ever¡hing else. An interrupr is an asynchronous exception or processor trap, typically generated by a peripheral device to notify the CPU of the completion of some VO operation. This exception typically produces a trap to <b>supervisor</b> (or kernel) <b>mode</b> at an address reserved for interrupts, and leaves some indication of what caused th...|$|R
2500|$|In {{computer}} terms, <b>supervisor</b> <b>mode</b> is a hardware-mediated flag {{which can}} be changed by code running in system-level software. System-level tasks or threads will have this flag set while they are running, whereas userspace applications will not. This flag determines {{whether it would be}} possible to execute machine code operations such as modifying registers for various descriptor tables, or performing operations such as disabling interrupts. The idea of having two different modes to operate in comes from [...] "" [...] a program in <b>supervisor</b> <b>mode</b> is trusted never to fail, since a failure may cause the whole computer system to crash.|$|E
2500|$|Modern {{microprocessors}} (CPU or MPU) support multiple {{modes of}} operation. CPUs with this capability offer {{at least two}} modes: user mode and <b>supervisor</b> <b>mode.</b> In general terms, <b>supervisor</b> <b>mode</b> operation allows unrestricted access to all machine resources, including all MPU instructions. [...] User mode operation sets limits on instruction use and typically disallows direct access to machine resources. CPUs might have other modes similar to user mode as well, such as the virtual modes in order to emulate older processor types, such as 16-bit processors on a 32-bit one, or 32-bit processors on a 64-bit one.|$|E
2500|$|In user mode, {{programs}} {{usually have}} access to a restricted set of microprocessor instructions, and generally cannot execute any instructions that could potentially cause disruption to the system's operation. [...] In <b>supervisor</b> <b>mode,</b> instruction execution restrictions are typically removed, allowing the kernel unrestricted access to all machine resources.|$|E
50|$|Although {{mainframe}} {{applications are}} naturally synchronous processes, {{the operating system}} itself is naturally asynchronous, although the system also supports many processes which are naturally synchronous. When an application requests a system service which is naturally asynchronous, such as input/output processing, a mechanism for synchronizing the application and the operating system must be employed. This essential mechanism is through functions which are built into the operating system, or are specifically supported by it, including: WAIT (temporarily halt application processing until an external event has occurred); POST (indicate occurrence of an external event so application processing may continue); and SYNCH (change system processing <b>modes</b> (<b>supervisor</b> to user), while preserving system integrity, and synchronously perform a function {{on behalf of the}} application, after which application processing may continue).|$|R
40|$|The {{purpose of}} this study was to {{evaluate}} whether or not <b>supervisors</b> changed their <b>modes</b> of communication after participating in Bank of California's workshop, The Elements of Personnel Management (Heslet et. al., 1971). Ten supervisors took part in simulated employee interviews both before and after the workshop. The responses they made during the interviews were subsequently evaluated by five raters according to a specially designed scale. Statistical analysis of the data revealed that the over-all proportions of positively rated responses did not change. However, the number of individual supervisors who improved, as indicated by the frequencies of their positive responses, did differ significantly from the number who did not improve. It was therefore concluded that the workshop did effect a slight change in the supervisors' communication behavior...|$|R
40|$|A {{computer}} simulation of a remote manipulation task and a rate-controlled manipulator is described. Some low-level automatic decision making ability {{which could be}} used at the operator's discretion to augment his direct continuous control was built into the manipulator. Experiments were made on the effect of transmission delay, dynamic lag, and intermittent vision on human manipulative ability. Delay does not make remote manipulation impossible. Intermittent visual feedback, and the absence of rate information in the display presented to the operator do not seem to impair the operator's performance. A small-capacity visual feedback channel may be sufficient for remote manipulation tasks, or one channel might be time-shared between several operators. In other experiments the operator called in sequence various on-site automatic control programs of the machine, and thereby acted as a <b>supervisor.</b> The supervisory <b>mode</b> of operation has some advantages when the task to be performed is difficult for a human controlling directly...|$|R
2500|$|<b>Supervisor</b> <b>mode</b> is [...] "an {{execution}} mode on some processors {{which enables}} execution of all instructions, including privileged instructions. It may also give {{access to a}} different address space, to memory management hardware and to other peripherals. This is the mode in which the operating system usually runs." ...|$|E
2500|$|A PTE [...] {{may also}} include {{information}} {{about whether the}} page has been written to (the [...] "dirty bit"), when it was last used (the [...] "accessed bit," [...] for a least recently used (LRU) page replacement algorithm), what kind of processes (user mode or <b>supervisor</b> <b>mode)</b> may read and write it, and {{whether it should be}} cached.|$|E
2500|$|The term [...] "user mode resource" [...] {{generally}} {{refers to}} one or more CPU registers, which contain information that the running program isn't allowed to alter. Attempts to alter these resources generally causes a switch to <b>supervisor</b> <b>mode,</b> where the operating system can deal with the illegal operation the program was attempting, for example, by forceably terminating ("killing") the program).|$|E
40|$|The IBM PowerPC {{instruction}} set architecture and the implementations of it have powered many different computer systems. It {{is a second}} generation RISC design that incorporates many instruction extensions designed to ease the generation of quality code by modern compilers. The RISC design lends itself to scaling from very small implementations designed for embedded applications, through super–computers, to standalone desktop and server machines. Although the design is fundamentally RISC, the IBM designers have explored much of the landscape of modern computer architectures, from large super–scalar processors down to tiny single issue pipelined processor cells, suitable for use in custom designed ASICs. This paper explores {{the history of the}} architecture and some of the unusual {{instruction set}} choices that the original PowerPC designers made, before investigating some of the PowerPC implementations. Modern PowerPC processors, such as the POWER 4, have very powerful and general <b>supervisor</b> and hypervisor <b>mode</b> functionality. The later sections of this paper discusses operating system design and some of the some of the issues posed by the POWER 4 architecture. ...|$|R
5000|$|All {{that changed}} with the {{announcement}} of the System/360 (S/360) in April, 1964. The System/360 was a single series of compatible models for both commercial and scientific use. The number [...] "360" [...] suggested a [...] "360 degree," [...] or [...] "all-around" [...] computer system. System/360 incorporated features which had previously been present on only either the commercial line (such as decimal arithmetic and byte addressing) or the engineering and scientific line (such as floating point arithmetic). Some of the arithmetic units and addressing features were optional on some models of the System/360. However, models were upward compatible and most were also downward compatible. The System/360 was also the first computer in wide use to include dedicated hardware provisions for the use of operating systems. Among these were <b>supervisor</b> and application <b>mode</b> programs and instructions, as well as built-in memory protection facilities. Hardware memory protection was provided to protect the operating system from the user programs (tasks) and the user tasks from each other. The new machine also had a larger address space than the older mainframes, 24 bits addressing 8-bit bytes vs. a typical 18 bits addressing 36-bit words.|$|R
40|$|For many dangerous, dirty or dull tasks like {{in search}} and rescue missions, {{deployment}} of autonomous teams of robots can be beneficial due to several reasons. First, robots can replace humans in the workspace. Second, autonomous robots reduce the workload of a human compared to teleoperated robots, and therefore multiple robots can in principle be supervised by a single human. Third, teams of robots allow distributed operation in time and space. This thesis investigates concepts of how to efficiently enable a human to supervise and support an autonomous robot team, as common concepts for teleoperation of robots do not apply {{because of the high}} mental workload. The goal is to find a way in between the two extremes of full autonomy and pure teleoperation, by allowing to adapt the robots’ level of autonomy to the current situation and the needs of the human supervisor. The methods presented in this thesis make use of the complementary strengths of humans and robots, by letting the robots do what they are good at, while the human should support the robots in situations that correspond to the human strengths. To enable this type of collaboration between a human and a robot team, the human needs to have an adequate knowledge about {{the current state of the}} robots, the environment, and the mission. For this purpose, the concept of situation overview (SO) has been developed in this thesis, which is composed of the two components robot SO and mission SO. Robot SO includes information about the state and activities of each single robot in the team, while mission SO deals with the progress of the mission and the cooperation between the robots. For obtaining SO a new event-based communication concept is presented in this thesis, that allows the robots to aggregate information into discrete events using methods from complex event processing. The quality and quantity of the events that are actually sent to the supervisor can be adapted during runtime by defining positive and negative policies for (not) sending events that fulfill specific criteria. This reduces the required communication bandwidth compared to sending all available data. Based on SO, the supervisor is enabled to efficiently interact with the robot team. Interactions can be initiated either by the human or by the robots. The developed concept for robot-initiated interactions is based on queries, that allow the robots to transfer decisions to another process or the <b>supervisor.</b> Various <b>modes</b> for answering the queries, ranging from fully autonomous to pure human decisions, allow to adapt the robots’ level of autonomy during runtime. Human-initiated interactions are limited to high-level commands, whereas interactions on the action level (e. g., teleoperation) are avoided, to account for the specific strengths of humans and robots. These commands can in principle be applied to quite general classes of task allocation methods for autonomous robot teams, e. g., in terms of specific restrictions, which are introduced into the system as constraints. In that way, the desired allocations emerge implicitly because of the introduced constraints, and the task allocation method does not need to be aware of the human supervisor in the loop. This method is applicable to different task allocation approaches, e. g., instantaneous or time-extended task assignments, and centralized or distributed algorithms. The presented methods are evaluated by a number of different experiments with physical and simulated scenarios from urban {{search and rescue}} as well as robot soccer, and during robot competitions. The results show that with these methods a human supervisor can significantly improve the robot team performance...|$|R
2500|$|The {{philosophy}} governing {{preemptive multitasking}} {{is that of}} ensuring that all programs are given regular time on the CPU. This implies that all programs must be limited in how much time {{they are allowed to}} spend on the CPU without being interrupted. To accomplish this, modern operating system kernels make use of a timed interrupt. A protected mode timer is set by the kernel which triggers a return to <b>supervisor</b> <b>mode</b> after the specified time has elapsed. (See above sections on Interrupts and Dual Mode Operation.) ...|$|E
2500|$|The CPU {{has eight}} 32-bit {{general-purpose}} data registers (D0-D7), and eight address registers (A0-A7). The last address register is the stack pointer, and assemblers accept the label SP as equivalent to A7. This {{was a good}} number of registers at the time in many ways. It was small enough to allow the 68000 to respond quickly to interrupts (even in the worst case where all 8 data registers D0–D7 and 7 address registers A0–A6 needed to be saved, 15 registers in total), and yet large enough to make most calculations fast, because they could be done entirely within the processor without keeping any partial results in memory. (Note that an exception routine in <b>supervisor</b> <b>mode</b> can also save the user stack pointer A7, which would total 8 address registers. However, the dual stack pointer (A7 and supervisor-mode A7') design of the 68000 makes this normally unnecessary, except when a task switch is performed in a multitasking system.) ...|$|E
50|$|OpenBSD has {{supported}} <b>Supervisor</b> <b>Mode</b> Access Prevention {{and the related}} <b>Supervisor</b> <b>Mode</b> Execution Prevention since 2012, with OpenBSD 5.3 being the first release with support for the feature enabled.|$|E
5000|$|<b>Supervisor</b> <b>Mode</b> Access Prevention (SMAP) is {{a feature}} of some CPU {{implementations}} such as the Intel Broadwell microarchitecture that allows <b>supervisor</b> <b>mode</b> programs to optionally set user-space memory mappings so that access to those mappings from <b>supervisor</b> <b>mode</b> will cause a trap. This {{makes it harder for}} malicious programs to [...] "trick" [...] the kernel into using instructions or data from a user-space program.|$|E
50|$|At {{power-on}} or reset, {{the system}} begins in <b>supervisor</b> <b>mode.</b> Once an operating system kernel {{has been loaded}} and started, the boundary between user mode and <b>supervisor</b> <b>mode</b> (also known as kernel mode) can be established.|$|E
50|$|<b>Supervisor</b> <b>Mode</b> Access Prevention is {{designed}} to complement <b>Supervisor</b> <b>Mode</b> Execution Prevention (SMEP), which was introduced earlier. SMEP {{can be used to}} prevent supervisor-mode code from unintentionally executing user-space code. SMAP extends this protection to reads and writes.|$|E
