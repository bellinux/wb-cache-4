4|4|Public
40|$|ISBN: 0818605405 Strongly code {{disjoint}} (SCD) checkers {{are defined}} and shown to include totally <b>self-checking</b> <b>code</b> disjoint checkers. This type of checker is necessary companion of the strongly fault-secure networks defined by J. E. Smith and G. Metze (1978). SCD checkers {{are the largest}} class of checkers with which a combinatorial system may achieve the totally self-checking goal. Some examples are given to illustrate the design of SCD checkers...|$|E
40|$|Abstract-Arithmetic {{error codes}} {{constitute}} {{a class of}} error codes that are preserved during most arithmetic operations. Effectiveness studies for arithmetic error codes have shown their value for concurrent detection of faults in arithmetic processors, data transmission subsystems, and main storage units in fault-tolerant computers In this paper, it is shown that the same class of codes is also quite effective for detecting storage errors in both shift-register and magnetic-recording mass memories. Some of the results are more general and deal with properties of arithmetic error codes in detecting unidirectional failures. For example, it is shown that a low-cost arithmetic error code with check modulus A = 2 - 1 can detect any unidirectional failure which affects fewer than N bits. The use of arithmetic error codes for checking of mass memories is further justified since it {{eliminates the need for}} hard-core or <b>self-checking</b> <b>code</b> translators and reduces the number of different types of cod...|$|E
40|$|Abstract. This paper {{presents}} {{a framework that}} lets a component developer provide a component user with different kinds of information, depending on the specific context and needs. The framework is based on presenting this information {{in the form of}} metadata. Metadata describe static and dynamic aspects of the component, can be accessed by the user, and can be used for different tasks throughout the software engineering lifecycle. The framework is defined in a general way, so that the metadata can be easily extended if new types of data have to be provided. In our approach, we define a unique format and a unique tag for each kind of metadata provided. The tag lets the user of the component both treat the information provided as metadata in the correct way and query for a specific piece of information. We motivate the untapped potential of component metadata by showing the need for metadata in the context of testing and analysis of distributed component-based systems, and introduce our framework {{with the help of an}} example. We sketch a possible scenario consisting of an application developer who wants to perform two different software engineering tasks on her application: generating <b>self-checking</b> <b>code</b> and program slicing...|$|E
40|$|Abstract — Innovative {{techniques}} {{for improving the}} quality indices of engineering devices or systems (e. g. <b>self-checking</b> <b>codes)</b> based on the combinatorial configurations, namely the concept of Ideal Ring Bundles (IRBs), is given. There are one- and multidimensional IRBs. One-dimensional IRBs form perfect partitions of a finite interval [1,S] of integers. The sums of connected sub-sequences of an IRB enumerate the set of integers [1,S] exactly R-times. Example 1 : The IRB { 1, 2, 4 } containing three elements allows an enumeration of all numbers 1 = 1, 2 = 2, 3 = 1 + 2, 4 = 4, 5 = 4 + 1, 6 = 2 + 4, 7 = 1 + 2 + 4 exactly once. Multidimensional IRBs form perfect tD vectors, t � 2. The modular sums of connected tD vectors of an tD IRB enumerate the set of tD cyclic array nodes exactly R times. This property makes IRBs useful in applications which need to partition set with the smallest possible number of intersections. The favourable qualities of the combinatorial structures provide many opportunities to apply them to numerous branches of sciences and advanced engineering. Remarkable property of one- and multidimensional IRBs has been embedded in structural relationships of circular symmetry and asymmetry as being basic law of while-world harmony...|$|R
40|$|Abstract—Agile {{development}} {{methods have}} gained {{momentum in the}} last few years and, as a consequence, test-driven development has become more prevalent in practice. However, test cases are not sufficient for producing dependable software and we rather advocate approaches that emphasize the use of assertions or contracts over that of test cases. Yet, writing <b>self-checks</b> in <b>code</b> has been shown to be difficult and is itself prone to errors. A standard technique to specify runtime properties is design-by-contract (DbC). But how can one test if the contracts themselves are sensible and sufficient? We propose a measure to quantify the goodness of contracts (or assertions in a broader sense). We introduce meta-mutations at the source code level to simulate common programmer errors that the self-checks are supposed to detect. We then use random mutation testing to determine a lower and upper bound on the detectable mutations and compare these bounds with the number of mutants detected by the contracts. Contracts are considered “good ” if they detect a certain percentage of the detectable mutations. We have evaluated our tools on Java classes with contracts specified using the Java Modeling Language (JML). We have additionally tested the contract quality of 19 implementations, written independently by students, based on the same specification...|$|R
40|$|This paper {{presents}} a novel method for designing Totally <b>Self-Checking</b> (TSC) m-out-of-n <b>code</b> checkers {{taking into account}} a realistic fault model including stuck-at, transistor stuck-on, transistor stuck-open, resistive bridging faults and breaks. The proposed design method is the first method in the open literature {{that takes into account}} a realistic fault model and can be applied for most practical values of m and n. Apart from the above the proposed checkers are very compact and very fast. The single output checkers are near optimal with respect to the number of transistors required for their implementation. Another benefit of the proposed TSC checkers is that all faults are tested by a very small set of single pattern tests, thus the probability of achieving the TSC goal is greater than in checkers requiring two-pattern tests. The single output TSC checkers proposed in this paper are the first known single output TSC checkers for m-out-of-n codes...|$|R
40|$|Executing {{binaries}} without interference by {{an outside}} adversary {{has been an}} ongoing duel between protection methods and attacks. Recently, an efficient kernel-patch attack has been presented against commonly used <b>self-checking</b> <b>code</b> techniques that use checksumming ahead of execution. While methods based on self-modifying code can defend against this attack, such techniques depend on low-level architectural details {{and may not be}} practical in the long run. An alternative defense is to use oblivious hashing (OH). Instead of checking code integrity prior to execution, OH can verify untampered runtime behavior continuously. However, earlier OH approaches have some weaknesses, particularly with binary code: Physical instruction bytes cannot be easily checked during execution, and an attacker may be able to detect and remove OH checks, since OH alone does not provide tamper-resistance or obfuscation. In our approach, we deliberately overlap a program’s basic blocks so that they share instruction bytes. This increases tamperresistance implicitly because malicious modifications affect multiple instructions simultaneously. Also, our scheme facilitates explicit anti-tampering checks via injection of OH instructions overlapped with target code, enabling OH that can verify integrity of both runtime state and executing instructions. Thus, our method addresses anti-checksum attacks without resorting to self-modifying code, and also extends OH to verify physical code, not only program state. In addition, overlapping facilitates resistance against disassembly and decompilation. Our approach works on processor architectures and byte-codes that support variable-length instructions. To our knowledge, this is the first technique that blends tamper-resistance into architecture and therefore significantly improves robustness of binaries...|$|E
40|$|Malware — {{a generic}} term that {{encompasses}} viruses, trojans, spywares and other intrusive code — is widespread today. Malware analysis is a multi-step process providing insight into malware structure and functionality, facilitating {{the development of}} an antidote. Behavior monitoring, an important step in the analysis process, is used to observe malware interaction with respect to the system and is achieved by employing dynamic coarse-grained binary-instrumentation on the target system. However, current research involving dynamic binary-instrumentation, categorized into probebased and just-in-time compilation (JIT), fail in the context of malware. Probe-based schemes are not transparent. Most if not all malware are sensitive to code modification incorporating methods to prevent their analysis and even instrument the system themselves for their functionality and stealthness. Current JIT schemes, though transparent, do not support multithreading, selfmodifying and/or <b>self-checking</b> (SM-SC) <b>code</b> and are unable to capture code running in kernel-mode. Also, they are an overkill in terms of latency for coarse-grained instrumentation. To address this problem, we have developed a new dynamic coarse-grained binary-instrumentation framework codenamed SPiKE, that aids in the construction of powerful malware analysis tools to combat malware that are becoming increasingly hard to analyze. Our goal is to provide a binary-instrumentation framework that is unobtrusive, portable, efficient, easy-to-use and reusable, supporting multithreading and SM-SC code, both in user- and kernel-mode. In this paper, we discuss the concept of unobtrusive binary-instrumentation and present the design, implementation and evaluation of SPiKE. We also illustrate the framework utility by describing our experience with a tool employing SPiKE to analyze a real world malware...|$|R

