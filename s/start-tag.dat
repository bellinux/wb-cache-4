12|4|Public
25|$|Tag {{names are}} case-sensitive; the <b>start-tag</b> and end-tag must match exactly.|$|E
25|$|An {{element is}} a logical {{document}} component that either begins with a <b>start-tag</b> and ends with a matching end-tag or consists only of an empty-element tag. The characters between the <b>start-tag</b> and end-tag, if any, are the element's content, and may contain markup, including other elements, which are called child elements. An example is <greeting>Hello, world!</greeting>. Another is <line-break/>.|$|E
25|$|The <b>start-tag,</b> end-tag, and empty-element tag that delimit {{elements}} are correctly nested, with none missing and none overlapping.|$|E
5000|$|For example, XML permits {{whitespace}} {{to occur}} {{at various points}} within <b>start-tags,</b> and attributes to be specified in any order. Such differences are seldom if ever used to convey meaning, and so these forms are generally considered equivalent: ...|$|R
25|$|SGML found wide {{acceptance}} and use in fields with very large-scale documentation requirements. However, many found it cumbersome {{and difficult to}} learn—a side effect of its design attempting {{to do too much}} and be too flexible. For example, SGML made end tags (or <b>start-tags,</b> or even both) optional in certain contexts, because its developers thought markup would be done manually by overworked support staff who would appreciate saving keystrokes.|$|R
40|$|Abstract. Model {{checking}} {{is often}} cited as a success story for transi-tioning and engineering ideas rooted in logics and automata to practice. In this paper, we discuss how the efforts aimed at improving the scope and effectiveness of model checking tools have revived the study of logics and automata leading to unexpected theoretical advances whose impact {{is not limited to}} model checking. In particular, we describe how our ef-forts to add context-free specifications to software model checking led us to the model of nested words as a representation of data with both a linear ordering and a hierarchically nested matching of items. Such dual structure occurs in diverse corners of computer science ranging from ex-ecutions of structured programs where there is a well-nested matching of entries to and exits from functions and procedures, to XML documents with the hierarchical structure specified by <b>start-tags</b> matched with end-tags. Finite-state acceptors of nested words define the class of regular languages of nested words that has all the appealing theoretical prop-erties that the class of regular word languages enjoys. We review the emerging theory of nested words, its extension to nested trees, and its potential applications...|$|R
25|$|A pull parser {{creates an}} {{iterator}} that sequentially visits the various elements, attributes, and data in an XML document. Code that uses this iterator can test the current item (to tell, for example, {{whether it is}} a <b>start-tag</b> or end-tag, or text), and inspect its attributes (local name, namespace, values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements that are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.|$|E
2500|$|An {{attribute}} is a markup construct {{consisting of}} a name–value pair that exists within a <b>start-tag</b> or empty-element tag. An example is <img src="madonna.jpg" [...] alt="Madonna" [...] />, where {{the names of the}} attributes are [...] "src" [...] and [...] "alt", and their values are [...] "madonna.jpg" [...] and [...] "Madonna" [...] respectively. Another example is <step number="3">Connect A to B.</step>, where the name of the attribute is [...] "number" [...] and its value is [...] "3". An XML attribute can only have a single value and each attribute can appear at most once on each element. In the common situation where a list of multiple values is desired, this must be done by encoding the list into a well-formed XML attribute with some format beyond what XML defines itself. Usually this is either a comma or semi-colon delimited list or, if the individual values are known not to contain spaces, a space-delimited list can be used. <div class="inner greeting-box">Welcome!</div>, where the attribute [...] "class" [...] has both the value [...] "inner greeting-box" [...] and also indicates the two CSS class names [...] "inner" [...] and [...] "greeting-box".|$|E
5000|$|The macro {{definition}} for until:(defmacro until (test &body body) (let ((<b>start-tag</b> (gensym [...] "START")) (end-tag (gensym [...] "END"))) `(tagbody ,<b>start-tag</b> (when ,test (go ,end-tag)) (progn ,@body) (go ,<b>start-tag)</b> ,end-tag))) ...|$|E
5000|$|An {{element is}} a logical {{document}} component that either begins with a <b>start-tag</b> and ends with a matching end-tag or consists only of an empty-element tag. The characters between the <b>start-tag</b> and end-tag, if any, are the element's content, and may contain markup, including other elements, which are called child elements. An example is [...] Another is [...]|$|E
50|$|In XML, an {{attribute}} is a markup construct {{consisting of a}} name/value pair that exists within a <b>start-tag</b> or empty-element tag. Markup languages, such as HTML and XML, use attributes to describe data and the formatting of data.|$|E
50|$|A SAX parser only {{needs to}} report each parsing event as it happens, and {{normally}} discards {{almost all of}} that information once reported (it does, however, keep some things, for example {{a list of all}} elements that have not been closed yet, in order to catch later errors such as end-tags in the wrong order). Thus, the minimum memory required for a SAX parser is proportional to the maximum depth of the XML file (i.e., of the XML tree) and the maximum data involved in a single XML event (such as the name and attributes of a single <b>start-tag,</b> or the content of a processing instruction, etc.).|$|E
50|$|A pull parser {{creates an}} {{iterator}} that sequentially visits the various elements, attributes, and data in an XML document. Code that uses this iterator can test the current item (to tell, for example, {{whether it is}} a <b>start-tag</b> or end-tag, or text), and inspect its attributes (local name, namespace, values of XML attributes, value of text, etc.), and can also move the iterator to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements that are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.|$|E
5000|$|An {{attribute}} is a markup construct {{consisting of}} a name-value pair that exists within a <b>start-tag</b> or empty-element tag. An example is , where {{the names of the}} attributes are [...] "src" [...] and [...] "alt", and their values are [...] "madonna.jpg" [...] and [...] "Madonna" [...] respectively. Another example is , where the name of the attribute is [...] "number" [...] and its value is [...] "3". An XML attribute can only have a single value and each attribute can appear at most once on each element. In the common situation where a list of multiple values is desired, this must be done by encoding the list into a well-formed XML attribute with some format beyond what XML defines itself. Usually this is either a comma or semi-colon delimited list or, if the individual values are known not to contain spaces, a space-delimited list can be used. , where the attribute [...] "class" [...] has both the value [...] "inner greeting-box" [...] and also indicates the two CSS class names [...] "inner" [...] and [...] "greeting-box".|$|E
40|$|NFC and RFID {{technologies}} {{have found their}} way into current mobile phones and research has presented a variety of applications using NFC/RFID tags for interaction between physical objects and mobile devices. Since this type of interaction is widely novel for most users, there is a considerable initial inhibition threshold for them. In order to get novice users started with this physical interaction and its applications, we have designed different ways to increase the learnability and guidance of such applications. Their effectiveness was evaluated in a qualitative and quantitative user study with 40 participants, who interacted with NFC-equipped posters in different ways. We report on the types of usage errors observed and show that future designs of NFC/RFID-based mobile applications should consider using a dedicated <b>start-tag</b> for interaction...|$|E

