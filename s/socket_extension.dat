10|27|Public
5000|$|In computing, the Java Secure <b>Socket</b> <b>Extension</b> (JSSE) {{provides}} {{a set of}} packages that enable secure Internet communications. It implements a Java technology version of the Secure Sockets Layer (SSL) and the Transport Layer Security (TLS) [...] protocols. It includes functionality for data encryption, server authentication, message integrity, and optional client-authentication.|$|E
50|$|The {{lower body}} of Dextre has {{a pair of}} {{orientable}} colour TV cameras with lights, a platform for stowing ORUs, and a tool holster. The tool holster is equipped with two Robotic Micro Conical Tools (RMCTs), which allow an arm to grasp additional types of ORU fixtures. The <b>Socket</b> <b>Extension</b> Tool (SET) extends {{the length of the}} grasping socket on an arm, and the Robotic Off-Set Tool (ROST) allows an arm to grasp difficult to reach targets.|$|E
50|$|This is {{the most}} basic of the CDC family of {{profiles}} hackedis a set of Java APIs tuned for low-footprint devices that have limited resources that do not need a graphical user interface system. It provides a complete Java ME application environment for consumer products and embedded devices but without a standards-based GUI system. Version 1.1.2 is specified in JSR 219 and implements a subset of Java SE 1.4.2, including a set of security-related optional packages, such as Java Authentication and Authorization Service (JAAS), Java Secure <b>Socket</b> <b>Extension</b> (JSSE), and Java Cryptography Extension (JCE).|$|E
50|$|Using handle or <b>socket</b> <b>extensions</b> {{requires}} no adjustment of the torque setting.|$|R
5000|$|... #Subtitle level 3: Mode 1: Household <b>socket</b> and <b>extension</b> cord ...|$|R
5000|$|RFC 6458 <b>Sockets</b> API <b>Extensions</b> for the Stream Control Transmission Protocol (SCTP) ...|$|R
40|$|This paper {{presents}} an UDP-based <b>socket</b> <b>extension</b> called the Resilient Mobile Socket (RMS), which provides application-layer mobility support by encapsulating other sockets {{into a new}} aggregated socket abstraction. Encapsulated sockets can then be added or removed without disturbing running applications. RMS also provides a method for soft handovers where several encapsulated sockets are used simultaneously during a handover. As a proof o...|$|E
40|$|Abstract — This paper {{presents}} an UDP-based <b>socket</b> <b>extension</b> called the Resilient Mobile Socket (RMS), which provides application-layer mobility support by encapsulating other sockets {{into a new}} aggregated socket abstraction. Encapsulated sockets can then be added or removed without disturbing running applications. RMS also provides a method for soft handovers where several encapsulated sockets are used simultaneously during a handover. As a proof of concept, a working prototype has been built by integrating RMS with Marratech Pro, a commercially available E-meeting application. This prototype {{has been used to}} evaluate RMS and to investigate how GSM audio quality is affected by handovers. The result from the investigation shows that soft handovers can be executed without loosing packets or causing extra latency, while a hard handover in average took around 200 ms to complete. This indicates that proactive handovers and redundancy are important, but that more work must be done to predict disconnections...|$|E
40|$|As a {{countermeasure}} {{against the}} famous Bleichenbacher attack on RSA based ciphersuites, all TLS RFCs starting from RFC 2246 (TLS 1. 0) propose “to treat incorrectly formatted messages {{in a manner}} indistinguishable from correctly formatted RSA blocks”. In this paper we show that this objective has not been achieved yet (cf. Table 1) : We present four new Blei-chenbacher side channels, and three successful Bleichen-bacher attacks against the Java Secure <b>Socket</b> <b>Extension</b> (JSSE) SSL/TLS implementation and against hardware security appliances using the Cavium NITROX SSL ac-celerator chip. Three of these side channels are timing-based, {{and two of them}} provide the first timing-based Bleichenbacher attacks on SSL/TLS described in the lit-erature. Our measurements confirmed that all these side channels are observable over a switched network, with timing differences between 1 and 23 microseconds. We were able to successfully recover the PreMasterSecret using three of the four side channels in a realistic mea-surement setup. ...|$|E
5000|$|Gilligan, R. E., Thomson, S., Bound, J., and Stevens, W. R. 1999. [...] "Basic <b>Socket</b> Interface <b>Extensions</b> for IPv6," [...] RFC 2553 ...|$|R
5000|$|Anything {{mounted on}} the cores (e.g. the <b>sockets</b> on an <b>extension</b> reel) ...|$|R
5000|$|Four <b>extension</b> <b>sockets</b> (2 TX, 2 RX) {{in order}} to connect 2-4 daughterboards.|$|R
40|$|While the address-oriented {{datagram}} {{and reliable}} stream services {{supported by the}} UDP and TCP protocols are the foundation of distributed computing, other forms of communication are increasingly being used to build contemporary systems and applications. A popular alternative to datagram- and stream-based communication is the Publish/Subscribe (P/S) paradigm, where message forwarding and reception is done based on a topic or content descriptions instead of an address. Several middleware systems have been built to support this form of communication, {{on top of the}} socket API. Taking a different approach, we discuss how P/S networking can be supported through the socket API, so that this can serve as a universal interface for supporting different communication abstractions. To this end we introduce a new address family and extend the semantics of selected socket primitives to support P/S functions. Also, we describe a proof-of-concept implementation of the proposed <b>socket</b> <b>extension,</b> which features two protocols for ad-hoc and infrastructure-based P/S communication, respectively. © 2013 ACM...|$|E
40|$|We present {{tools to}} support model-based {{security}} engineering {{on both the}} model and the code level. In the approach supported by these tools, one firstly specifies the securitycritical {{part of the system}} (e. g. a crypto protocol) using the UML security extension UMLsec. The models are automatically verified for security properties using automated theorem provers. These are implemented within a framework that supports implementing verification routines, based on XMI output of the diagrams from UML CASE tools. Advanced users can use this open-source framework to implement verification routines for the constraints of self-defined security requirements. In a second step, one verifies that security-critical parts of the model are correctly implemented in the code (which might be a legacy implementation), and applies security hardening transformations where is that not the case. This is supported by tools that (1) establish traceability through refactoring scripts and (2) modularize security hardening advices through aspect-oriented programming. The proposed method has been applied to an open-source implementation of a cryptographic protocol implementation (Jessie) in Java to build up traceability mappings and security aspects. In that application, we found a security weakness which could be fixed using our approach. The resulting refactoring scripts and security aspects have found reusability in the Java Secure <b>Socket</b> <b>Extension</b> (JSSE) library...|$|E
40|$|This paper {{introduces}} DIDUCE, {{a practical}} and effective tool that aids programmers in detecting complex program errors and identifying their root causes. By instrumenting a program and observing its behavior as it runs, DIDUCE dynamically formulates hypotheses of invariants obeyed by the program. DIDUCE hypothesizes the strictest invariants at the beginning, and gradually relaxes the hypothesis as violations are detected {{to allow for}} new behavior. The violations reported help users to catch software bugs {{as soon as they}} occur. They also give programmers new visibility into the behavior of the programs such as identifying rare corner cases in the program logic or even locating hidden errors that corrupt the program’s results. We implemented the DIDUCE system for Java programs and applied it to four programs of significant size and complexity. DIDUCE succeeded in identifying the root causes of programming errors in each of the programs quickly and automatically. In particular, DIDUCE is effective in isolating a timing−dependent bug in a released JSSE (Java Secure <b>Socket</b> <b>Extension)</b> library, which would have taken an experienced programmer days to find. Our experience suggests that detecting and checking program invariants dynamically is a simple and effective methodology for debugging many different kinds of program errors across a wide variety of application domains. 1...|$|E
40|$|AbstractAn {{important}} {{missing link}} {{in the construction of}} secure systems is finding a practical way to establish a correspondence between a software specification and its implementation. We address this problem for the case of crypto-based Java implementations (such as crypto protocols) with an approach using automated theorem provers for first-order logic, by linking the implementation to a specification model. In this paper, we present details on an application of this approach to the open-source Java implementation Jessie of the SSL protocol. We also shortly comment on how these results can be transferred to the standard Java Secure <b>Sockets</b> <b>Extension</b> (JSSE) library that was recently open-sourced by Sun...|$|R
40|$|An {{important}} {{missing link}} {{in the construction of}} secure systems is finding a practical way to establish a correspondence between a software specification and its implementation. In this paper, we show to make use of interface specifications to address this problem for the case of crypto-based Java implementations (such as crypto protocols). We explain this using an approach using automated theorem provers for first-order logic which links the implementation to a specification model, which has been presented in earlier work. We present the details at the hand of an application to the open-source Java implementation Jessie of the SSL protocol. In ongoing work, we apply the approach to the standard Java Secure <b>Sockets</b> <b>Extension</b> (JSSE) library that was recently open-sourced by Sun...|$|R
5000|$|Nezhinskoye ** Training and Production Enterprise [...] "UTOS" [...] - {{covers of}} metal for home canning, switches, {{electric}} <b>sockets,</b> nails, clips, <b>extension</b> cords.|$|R
40|$|We {{describe}} a largely automated {{and systematic analysis}} of TLS implementations by what we call ‘protocol state fuzzing’: we use state machine learning to infer state ma-chines from protocol implementations, using only black-box testing, and then inspect the inferred state machines to look for spurious behaviour which might be an indica-tion of flaws in the program logic. For detecting the pres-ence of spurious behaviour the approach is almost fully automatic: we automatically obtain state machines and any spurious behaviour is then trivial to see. Detecting whether the spurious behaviour introduces exploitable security weaknesses does require manual investigation. Still, we take {{the point of view}} that any spurious func-tionality in a security protocol implementation is danger-ous and should be removed. We analysed both server- and client-side implemen-tations with a test harness that supports several key ex-change algorithms and the option of client certificate au-thentication. We show that this approach can catch an interesting class of implementation flaws that is appar-ently common in security protocol implementations: in three of the TLS implementations analysed new security flaws were found (in GnuTLS, the Java Secure <b>Socket</b> <b>Extension,</b> and OpenSSL). This shows that protocol state fuzzing is a useful technique to systematically analyse security protocol implementations. As our analysis of different TLS implementations resulted in different and unique state machines for each one, the technique can also be used for fingerprinting TLS implementations. ...|$|E
5000|$|Wobble <b>extensions</b> {{have their}} <b>socket</b> {{attachment}} ends ground {{to allow the}} socket-extension interface to bend up to about 15 degrees. This additional flexibility often makes using a <b>socket</b> + <b>extension</b> in a cramped location easier. A 1" [...] to 1-1/2" [...] long wobble extension added {{to the end of}} any extension will convert it to a slightly longer [...] "wobble" [...] extension.|$|R
40|$|This paper {{describes}} extensions to {{the popular}} socket programming interface that provide applications {{direct access to the}} services of ATM networks. Instead of designing an entirely new API or adding new socket function calls, the existing calls were slightly modified to provide the necessary functionality, leaving the basic socket model unchanged. This will enable existing socket applications to be easily ported to ATM and encourage programmers to write new applications exploiting ATM networks, including the use of quality of service (QoS) without going through the TCP or UDP and IP protocol layers. By offering a familiar API and client/server model, it will foster the exploitation of ATM network features by existing and new multimedia applications. The <b>socket</b> <b>extensions</b> described in this paper are implemented in IBM's AIX operating system Release 4. 2, operating over the TurboWays family of ATM network adapters. 1 Motivation The first priority of ATM equipment vendors was to provid [...] ...|$|R
40|$|As dynamic web {{content and}} {{security}} capabilities are becoming popular in current web sites, the performance demand on application servers that host the sites is increasing, leading sometimes these servers to overload. As a result, response times may grow to unacceptable levels and the server may saturate or even crash. In this paper {{we present a}} session-based adaptive overload control mechanism based on SSL (Secure Socket Layer) connections differentiation and admission control. The SSL connections differentiation is a key factor because the cost of establishing a new SSL connection {{is much greater than}} establishing a resumed SSL connection (it reuses an existing SSL session on server). Considering this big difference, we have implemented an admission control algorithm that prioritizes the resumed SSL connections to maximize performance on session-based environments and limits dynamically the number of new SSL connections accepted depending on the available resources and the current number of connections in the system to avoid server overload. In order to allow the differentiation of resumed SSL connections from new SSL connections we propose a possible extension of the Java Secure <b>Sockets</b> <b>Extension</b> (JSSE) API. Our evaluation demonstrates the benefit of our proposal for preventing server overload. We use the RUBiS auction site benchmark to stress a Tomcat application server with the overload control mechanism incorporated running on a commodity 4 -way multiprocessor Intel platform with Linux. 1...|$|R
50|$|A power cord, line cord, or {{mains cable}} is an {{electrical}} cable that temporarily connects an appliance to the mains electricity supply via a wall <b>socket</b> or <b>extension</b> cord. The terms are generally used for cables using a power plug to connect to a single-phase alternating current power source at the local line voltage - (generally 100 to 240 volts, depending on the location). The terms power cable, mains lead, flex or kettle lead are also used. A lamp cord (also known as a zip cord) is a light-weight, ungrounded, single-insulated two-wire cord used for small loads such as a table or floor lamp.|$|R
40|$|Security-critical {{systems are}} {{challenging}} {{to design and}} implement correctly and securely. A lot of vulnerabilities {{have been found in}} current software systems both at the specification and the implementation levels. This paper presents a comprehensive approach for model-based security assurance. Initially, it allows one to formally verify the design models against high-level security requirements such as secrecy and authentication on the specification level, and helps to ensure that their implementation adheres to these properties, if they express a system’s run-time behaviour. As such, it provides a traceability link from the design model to its implementation by which the actual system can then be verified against the model while it executes. This part of our approach relies on a technique also known as run-time verification. The extra effort for it is small as most of the computation is automated; however, additional resources at run-time may be required. If during run-time verification a security weakness is uncovered, it can be removed using aspectoriented security hardening transformations. Therefore, this approach also supports the evolution of software since the traceability mapping is updated when refactoring operations are regressively performed using our tool-supported refactoring technique. The proposed method has been applied to the Java-based implementation JESSIE of the Internet security protocol SSL, in which a security weakness was detected and fixed using our approach. We also explain how the traceability link can be transformed to the official implementation of the Java Secure <b>Sockets</b> <b>Extension</b> (JSSE) that was recently made open source by Sun...|$|R
5000|$|It {{was built}} from 1991 to 1997. From 1991 to 1993, it used tuned {{multi-port}} fuel injection, made 200-210 hp (150-160 kW) at 5200 rpm and 215 lbft Nm of torque at 4000 rpm. From 1994 to 1997, it used sequential port fuel injection, making [...] at 5200 rpm and 215 lbft Nm of torque at 4000 rpm. In 1996, the heads were redesigned for better flow {{as well as}} now making the engine an interference design and adapting the engine for federally mandated OBDII emissions. Output for the 1996-1997 LQ1 is [...] and 220 lbft Nm. It had four large valves per cylinder. The 3.4 L engine used a cogged belt to drive the four overhead camshafts and a chain to drive the intermediate shaft, which is mounted in the same slot where the camshaft would go in {{on any of the}} pushrod engines in the 60-degree family. Adapting a pushrod block for the LQ1's overhead cams was difficult, and the 60° angle made this a very tall engine. The power output for this engine was impressive during its time; however, this engine has never been well liked by auto mechanics, as important maintenance such as spark plug and timing belt changes is very troublesome, especially on later models. Spark plug changes for the three rear cylinders are thought by some to require removing the upper intake manifold when performed as directed by factory service manual, and timing belt changes have a labor rate of 5 hours as opposed to 2-3 for a typical belt-driven engine. In fact, cylinders 1, 3, and 5 spark plugs can be changed by removing the crosswise stabilizer bar from atop strut towers, and using proper <b>socket</b> <b>extensions</b> and a mirror. Timing belt procedure has been posted to You Tube with some labor-saving tips.|$|R
50|$|<b>Sockets</b> and <b>extensions</b> for impact {{wrenches}} {{are made}} of high tensile metal, as any spring effect will greatly reduce the torque available at the fastener. Even so, {{the use of multiple}} extensions, universal joints, and so forth will weaken the impacts, and the operator needs to minimize their use. Using non-impact sockets or accessories with an impact wrench will often result in bending, fracturing, or otherwise damaging the accessory, as most are not capable of withstanding the sudden high torque of an impact tool, and can result in stripping the head on the fastener. Non-impact sockets and accessories {{are made of}} a harder more brittle metal. Safety glasses should always be worn when working with impact tools, as the strong impacts can generate high-speed shrapnel if a socket, accessory, or fastener fails.|$|R
40|$|Sockets Application Program Interface (API) for Multihoming Shim This {{document}} specifies <b>sockets</b> API <b>extensions</b> for the multihoming shim layer. The API aims {{to enable}} interactions between applications and the multihoming shim layer for advanced locator management, {{and access to}} information about failure detection and path exploration. This document {{is based on an}} assumption that a multihomed host is equipped with a conceptual sub-layer (hereafter called "shim sublayer") inside the IP layer that maintains mappings between identifiers and locators. Examples of the shim are Shim 6 and the Host Identity Protocol (HIP). Status of This Memo This document is not an Internet Standards Track specification; it is published for informational purposes. This document {{is a product of the}} Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|R
40|$|There {{has been}} a {{significant}} amount of work devoted to the static verification of security protocol designs Virtually all of these results, when applied to an actual implementation of a security protocol, rely on certain implicit assumptions on the implementation (for example, that the cryptographic checks that according to the design have to be performed by the protocol participants are carried out correctly) So far {{there seems to be no}} approach that would enforce these implicit assumptions for a given implementation of a security protocol (in particular regarding legacy implementations which have not been developed with formal verification in mind) In this paper, we use a code assurance technique called "runtime verification" to solve this open problem Runtime verification determines whether or not the behaviour observed during the execution of a system matches a given formal specification of a "reference behaviour". By applying runtime verification to an implementation of any of the participants of a security protocol, we can make sure during the execution of that implementation that the implicit assumptions that had to be made to ensure the security of the overall protocol will be fulfilled The overall assurance process then proceeds in two steps First, a design model of the security protocol in UML is verified against security properties such as secrecy of data Second, the implicit assumptions on the protocol participants are derived from the design model, formalised in linear-time temporal logic, and the validity of these formulae at runtime is monitored using runtime verification The aim is to increase one's confidence that statically verified properties are satisfied not only by a model of the system, but also by the actual running system Itself We demonstrate the approach at the hand of the open source implementation Jessie of the de-facto Internet security protocol standard SSL We also briefly explain how to transfer the results to the SSL-implementation within the Java Secure <b>Sockets</b> <b>Extension</b> (JSSE) recently made open source by Sun Microsystems...|$|R
50|$|Strictly speaking, a {{textbook}} installation will only actually use pins 2, 5 (for the voice) and 3 (for the ringer). Having said this, most modern telephones contain their own ringing capacitor, to cater for the Irish telephone system {{which does not}} have a capacitor built into the <b>socket,</b> and 2-wire <b>extensions,</b> which means that extension wiring can usually be run with only pins 2 and 5. Often where multi-core cable is used, the remaining cables are used for wiring extensions on additional incoming telephone lines.|$|R
50|$|In the {{standard}} Internet protocols TCP and UDP, a socket address {{is the combination}} of an IP address and a port number, much like {{one end of a}} telephone connection is the combination of a phone number and a particular <b>extension.</b> <b>Sockets</b> need not have an address, for example, for only sending data, but if a program binds a socket to an address, the socket can be used to receive data sent to that address. Based on this address, Internet sockets deliver incoming data packets to the appropriate application process.|$|R
40|$|Conventional power sockets are {{equipped}} with an extension cord. Even with anti-overload devices, incidents of accidental discharge or damage to electrical appliances may still incur due to external factors. To address this problem, this study integrated the voice control and lighting functions {{to the design of}} the power <b>socket</b> with an <b>extension</b> cord. The proposed design is space-efficient and versatile, and can be used in living rooms, bedrooms, and other places having electrical appliances. The proposed design also integrated emergency lighting and flashlight functions, so as to expand the practicality and safety of the power socket...|$|R
50|$|Until recently, this socket {{contained}} an enclosed spark gap, SP1, that could safely flash over internally to provide high voltage surge protection. This component {{is no longer}} used due to negative effects on VDSL speeds. The socket includes a 1.8 µF capacitor (bell circuit) to feed the AC ringing and a 470 kΩ resistor (R1, out-of-service resistor) to permit remote testing when no telephones are plugged into any <b>sockets.</b> Additional internal <b>extension</b> (secondary) <b>sockets</b> are wired off the master socket (connected in parallel using the IDC system) but not containing the surge protector, bell circuit capacitor, and the out-of-service resistor.|$|R
2500|$|There is a {{specific}} requirement in the standard to ensure that Europlugs and other two-pin plugs {{may not be used}} with BS1363 sockets It shall not be possible to operate a shutter by inserting a 2-pin plug into a 3-pin socket-outlet. [...] However, many <b>extension</b> <b>sockets</b> will allow a plug to be inserted upside down, i.e. only the earth pin, defeating the shutter mechanism. This method is sometimes used to allow a Europlug (with two small round pins and no earth pin) to be forced into the open [...] and neutral ports. The UK Electrical Safety Council has drawn attention to the fire risk associated with forcing Europlugs into BS1363 sockets.|$|R
5000|$|As {{the output}} of an impact wrench, when hammering, is a very short impact force, the actual {{effective}} torque is difficult to measure, with several different ratings in use. As the tool delivers a fixed amount of energy with each blow, rather than a fixed torque, the actual output torque changes with {{the duration of the}} output pulse. If the output is springy or capable of absorbing energy, the impulse will simply be absorbed, and virtually no torque will ever be applied, and somewhat counter-intuitively, if the object is very springy, the wrench may actually turn backwards as the energy is delivered back to the anvil, while it is not connected to the hammer and able to spin freely. [...] A wrench that is capable of freeing a rusted nut on a very large bolt may be incapable of turning a small screw mounted on a spring. [...] "Maximum torque" [...] is the number most often given by manufacturers, which is the instantaneous peak torque delivered if the anvil is locked into a perfectly solid object. [...] "Working torque" [...] is a more realistic number for continually driving a very stiff fastener. [...] "Nut-busting torque" [...] is often quoted, with the usual definition being that the wrench can loosen a nut tightened with the specified amount of torque in some specified time period. Accurately controlling the output torque of an impact wrench is very difficult, and even an experienced operator will have a hard time making sure a fastener is not undertightened or overtightened using an impact wrench. Special <b>socket</b> <b>extensions</b> are available, which take advantage of the inability of an impact wrench to work against a spring, to precisely limit the output torque. Designed with spring steel, they act as large torsion springs, flexing at their torque rating, and preventing any further torque from being applied to the fastener. Some impact wrenches designed for product assembly have a built-in torque control system, such as a built-in torsion spring and a mechanism that shuts the tool down when the given torque is exceeded. When very precise torque is required, an impact wrench is only used to snug down the fastener, with a torque wrench used for the final tightening. Due to the lack of standards when measuring the maximum torque, some manufacturers are believed to inflate their ratings, or to use measurements with little bearing on how the tool will perform in actual use. Many air impact wrenches incorporate a flow regulator into their design, either as a separate control or part of the reversing valve, allowing torque to be roughly limited in one or both directions, while electric tools may use a variable speed trigger for the same effect.|$|R
40|$|This memo {{provides}} {{information for the}} Internet community. This memo does not specify an Internet standard of any kind. Distribution of this memo is unlimited. The de facto standard application program interface (API) for TCP/IP applications is the "sockets " interface. Although this API was developed for Unix in the early 1980 s {{it has also been}} implemented {{on a wide variety of}} non-Unix systems. TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv 6 applications. But changes are required to the sockets API to support IPv 6 and this memo describes these changes. These include a new socket address structure to carry IPv 6 addresses, new address conversion functions, and some new <b>socket</b> options. These <b>extensions</b> are designed to provide access to the basic IPv 6 features required b...|$|R
40|$|In 1972, R. Carter {{introduced}} admissible diagrams {{to classify}} conjugacy classes in a finite Weyl group W. We say that an admissible diagram Γ is a Carter diagram if any edge α, β with inner product (α, β) > 0 (resp. (α, β) 4) into another Carter diagram containing only 4 -cycles. Thus, all Carter diagrams containing long cycles can be {{eliminated from the}} classification list. There exist diagrams determining two conjugacy classes in W. It is shown that any connected Carter diagram Γ containing a 4 -vertex pattern D_ 4 or D_ 4 (a_ 1) determines a single conjugacy class. The main approach is studying different extensions of Carter diagrams. Let Γ̃ be the Carter diagram obtained from a certain Carter diagram Γ by adding a single vertex α connected to Γ at n points, n ≤ 3. Let a socket be the set of vertices of Γ connected to α. If the number of <b>sockets</b> available for <b>extensions</b> is equal to 2, {{then there is a}} pair of extensions Γ < Γ̃_L and Γ < Γ̃_R, called mirror extensions and the pair elements w_L and w_R associated with Γ̃_L and Γ̃_R. We show that w_R = T^- 1 w_LT for some T ∈ W, where the map T is explicitly constructed for all mirror extensions. In Carter's description of the conjugacy classes in a Weyl group a key result (Carter's theorem) states that every element in a Weyl group is a product of two involutions. One of the goals of this paper and its sequels is to prepare the notions and framework in which we give the proof of this fact without appealing to the classification of conjugacy classes. Comment: 91 pages, 169 figures. Substantially revised and rewritten versio...|$|R
