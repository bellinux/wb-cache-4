33|200|Public
25|$|The {{original}} IEEE 754 standard, however, {{failed to}} recommend operations to handle such sets of arithmetic exception flag bits. So while these were implemented in hardware, initially programming language implementations typically {{did not provide}} a means to access them (apart from assembler). Over time some programming language standards (e.g., C99/C11 and Fortran) have been updated to specify methods to access and change <b>status</b> <b>flag</b> bits. The 2008 version of the IEEE 754 standard now specifies a few operations for accessing and handling the arithmetic flag bits. The programming model {{is based on a}} single thread of execution and use of them by multiple threads has to be handled by a means outside of the standard (e.g. C11 specifies that the flags have thread-local storage).|$|E
2500|$|Here, the {{required}} default method of handling exceptions according to IEEE 754 is discussed (the IEEE-754 optional trapping and other [...] "alternate exception handling" [...] modes are not discussed). Arithmetic exceptions are (by default) {{required to be}} recorded in [...] "sticky" [...] <b>status</b> <b>flag</b> bits. That they are [...] "sticky" [...] means {{that they are not}} reset by the next (arithmetic) operation, but stay set until explicitly reset. The use of [...] "sticky" [...] flags thus allows for testing of exceptional conditions to be delayed until after a full floating-point expression or subroutine: without them exceptional conditions that could not be otherwise ignored would require explicit testing immediately after every floating-point operation. By default, an operation always returns a result according to specification without interrupting computation. For instance, 1/0 returns +∞, while also setting the divide-by-zero flag bit (this default of ∞ is designed so as to often return a finite result when used in subsequent operations and so be safely ignored).|$|E
2500|$|David Watt's 2004 {{textbook}} also analyzes {{exception handling}} {{in the framework}} of sequencers (introduced in this article in the section on early exits from loops). Watt notes that an abnormal situation, generally exemplified with arithmetic overflows or input/output failures like file not found, is a kind of error that [...] "is detected in some low-level program unit, but [...] a handler is more naturally located in a high-level program unit". For example, a program might contain several calls to read files, but the action to perform when a file is not found depends on the meaning (purpose) of the file in question to the program and thus a handling routine for this abnormal situation cannot be located in low-level system code. Watts further notes that introducing status flags testing in the caller, as single-exit structured programming or even (multi-exit) return sequencers would entail, results in a situation where [...] "the application code tends to get cluttered by tests of status flags" [...] and that [...] "the programmer might forgetfully or lazily omit to test a <b>status</b> <b>flag.</b> In fact, abnormal situations represented by status flags are by default ignored!" [...] Watt notes that in contrast to status flags testing, exceptions have the opposite default behavior, causing the program to terminate unless the programmer explicitly deals with the exception in some way, possibly by adding explicit code to ignore it. Based on these arguments, Watt concludes that jump sequencers or escape sequencers aren't as suitable as a dedicated exception sequencer with the semantics discussed above.|$|E
50|$|Examples of FIFO <b>status</b> <b>flags</b> include: full, empty, almost full, almost empty, etc.|$|R
5000|$|... 2 other output {{lines for}} the <b>status</b> <b>flags</b> N (negative) and Z (zero).|$|R
5000|$|Update the {{condition}} codes from the ALU <b>status</b> <b>flags</b> (negative, zero, overflow, and carry) ...|$|R
5000|$|Each address has {{a unique}} Ordnance Survey Address Point {{reference}} (OSAPR). In addition, Address Point carries a <b>status</b> <b>flag</b> to define the quality and accuracy of each address as well as indicators for change and source currency." ...|$|E
50|$|A status register, flag register, or {{condition}} code register {{is a collection}} of <b>status</b> <b>flag</b> bits for a processor. An example is the FLAGS register of the x86 architecture or flags in a program status word (PSW) register.|$|E
50|$|The {{standard}} defines five exceptions, each {{of which}} returns a default value and has a corresponding <b>status</b> <b>flag</b> that (except in certain cases of underflow) is raised when the exception occurs. No other exception handling is required, but additional non-default alternatives are recommended (see below).|$|E
2500|$|IEEE 754 {{specifies}} five arithmetic exceptions {{that are}} to be recorded in the <b>status</b> <b>flags</b> ("sticky bits"): ...|$|R
40|$|Minor {{update to}} the LEHD Schema: V 4. 1. 3 	 2017 - 08 - 15 : Updated LEHD shape files for Texas WIB {{definitions}} 	 2017 - 08 - 15 : Update the source links of metro definitions from [URL] (broken) to [URL] 	 2017 - 08 - 21 : Corrected naming {{of three of}} the <b>status</b> <b>flags</b> that have "Rate" at the end. That should be just "R". Also contains minor edits of errors in previous releases. These are not separately released. V 4. 1. 0. 2 	 2017 - 08 - 21 : Corrected naming {{of three of the}} <b>status</b> <b>flags</b> that have "Rate" at the end. That should be just "R". V 4. 1. 1. 1 	 2017 - 08 - 21 : Corrected naming of three of the <b>status</b> <b>flags</b> that have "Rate" at the end. That should be just "R". V 4. 1. 2. 1 	 2017 - 08 - 21 : Corrected naming of three of the <b>status</b> <b>flags</b> that have "Rate" at the end. That should be just "R"...|$|R
5000|$|As the IEEE 754 <b>status</b> <b>flags</b> are {{manipulated}} in this function, this #pragma {{is needed}} to avoid the compiler incorrectly rearranging such tests when optimising.|$|R
50|$|In a {{computer}} processor the negative flag or sign flag {{is a single}} bit in a system <b>status</b> (<b>flag)</b> register used to indicate whether {{the result of the}} last mathematical operation resulted in a value whose most significant bit was set. In a two's complement interpretation of the result, the negative flag is set if the result was negative.|$|E
50|$|This {{solution}} uses {{computers that}} {{are connected to}} the Internet to crawl Internet addresses in the background. Upon downloading crawled web pages, they are compressed and sent back together with a <b>status</b> <b>flag</b> (e.g. changed, new, down, redirected) to the powerful central servers. The servers, which manage a large database, send out new URLs to clients for testing.|$|E
50|$|Each {{address is}} coordinated on the National Grid, with eastings and northings {{normally}} quoted to {{a resolution of}} 0.1 metres. The accuracy of each georeference is classified within the <b>status</b> <b>flag,</b> in which is indicated whether the coordinates are due to be improved (PQ1) or {{as good as they}} can be (PQ3). Resources are directed towards continually improving the proportion of records with the PQ3 classification.|$|E
25|$|By default, an IEEE 754 {{exception}} is resumable and is handled by substituting a predefined value for different exceptions, e.g. infinity for a divide by zero exception, and providing <b>status</b> <b>flags</b> for later checking {{of whether the}} exception occurred (see C99 programming language for a typical example of handling of IEEE 754 exceptions). An exception-handling style enabled {{by the use of}} <b>status</b> <b>flags</b> involves: first computing an expression using a fast, direct implementation; checking whether it failed by testing status flags; and then, if necessary, calling a slower, more numerically robust, implementation.|$|R
40|$|The {{software}} for selected space shuttle components are examined for potential problem areas and possible suboptimal coding techniques. Errors {{discovered in the}} procedure termination routine are discussed. The technique used to store <b>status</b> <b>flags</b> is found not to be as efficient as possible, from both the standpoints of memory usage and processing time. Self-test routines are examined {{with the intent of}} providing a more detailed description of multiplexer/demultiplexer and display and control outputs. An example of a reconfiguration is presented with a block diagram to indicate the critical paths. A cross-reference table of <b>status</b> <b>flags</b> is given to aid in tracing the functional activity of software modules...|$|R
50|$|<b>Status</b> <b>flags</b> enable an {{instruction}} to act {{based on the}} result of a previous instruction. In pipelined processors, such as superscalar and speculative processors, this can create hazards that slow processing or require extra hardware to work around them.|$|R
5000|$|According to SlashNET's website, a [...] "hands-off" [...] {{approach}} to administration is used. More specifically, SlashNET claims that IRC Operators are just regular users with a <b>status</b> <b>flag</b> {{next to their}} nicknames. SlashNET's administration officially decries the use of mission statements and other business-like [...] "buzzwords" [...] for IRC networks and rejects the notion that these are necessary for the operation of a network. The overall objective of the administration as described by the network's website is [...] "keep the servers running." ...|$|E
50|$|The 6502's {{registers}} {{include one}} 8-bit accumulator register (A), two 8-bit index registers (X and Y), 7 processor <b>status</b> <b>flag</b> bits (P), an 8-bit stack pointer (S), and a 16-bit program counter (PC). The stack's address space is hardwired to memory page $01, i.e. the address range $0100 - $01FF (256 - 511). Software {{access to the}} stack is done via four implied addressing mode instructions, whose functions are to push or pop (pull) the accumulator or the processor status register. The same stack is also used for subroutine calls via the JSR (Jump to Subroutine) and RTS (Return from Subroutine) instructions and for interrupt handling.|$|E
50|$|The {{original}} IEEE 754 standard, however, {{failed to}} recommend operations to handle such sets of arithmetic exception flag bits. So while these were implemented in hardware, initially programming language implementations typically {{did not provide}} a means to access them (apart from assembler). Over time some programming language standards (e.g., C99/C11 and Fortran) have been updated to specify methods to access and change <b>status</b> <b>flag</b> bits. The 2008 version of the IEEE 754 standard now specifies a few operations for accessing and handling the arithmetic flag bits. The programming model {{is based on a}} single thread of execution and use of them by multiple threads has to be handled by a means outside of the standard (e.g. C11 specifies that the flags have thread-local storage).|$|E
5000|$|Supports all modes {{in which}} {{transfer}} speeds differ, from [...] "Mode 0" [...] to [...] "Mode 2". Using data transmission by DTC, CPU load is reduced sharply (Approx. 1/2). Using abundant error <b>status</b> <b>flags</b> to realize appropriate error processing.link ...|$|R
25|$|<b>Status</b> <b>flags</b> {{are used}} to inform all drivers of the general status of the course during a race. In addition, the green, yellow, and red flags {{described}} below may be augmented or replaced by lights at various points around the circuit.|$|R
50|$|In the ARM {{processor}} architecture, 26-bit {{refers to}} the design used in the original ARM processors where the Program Counter (PC) and Processor Status Register (PSR) were combined into one 32-bit register (R15), the <b>status</b> <b>flags</b> filling the high 6 bits and the Program Counter taking up the lower 26 bits.|$|R
50|$|In {{computer}} processors the {{carry flag}} (usually indicated as the C flag) {{is a single}} bit in a system <b>status</b> (<b>flag)</b> register used to indicate when an arithmetic carry or borrow has been generated out {{of the most significant}} ALU bit position. The carry flag enables numbers larger than a single ALU width to be added/subtracted by carrying (adding) a binary digit from a partial addition/subtraction to the least significant bit position of a more significant word. It is also used to extend bit shifts and rotates in a similar manner on many processors (sometimes done via a dedicated X flag). For subtractive operations, two (opposite) conventions are employed as most machines set the carry flag on borrow while some machines (such as the 6502 and the PIC) instead reset the carry flag on borrow (and vice versa).|$|E
5000|$|Here, the {{required}} default method of handling exceptions according to IEEE 754 is discussed (the IEEE-754 optional trapping and other [...] "alternate exception handling" [...] modes are not discussed). Arithmetic exceptions are (by default) {{required to be}} recorded in [...] "sticky" [...] <b>status</b> <b>flag</b> bits. That they are [...] "sticky" [...] means {{that they are not}} reset by the next (arithmetic) operation, but stay set until explicitly reset. The use of [...] "sticky" [...] flags thus allows for testing of exceptional conditions to be delayed until after a full floating-point expression or subroutine: without them exceptional conditions that could not be otherwise ignored would require explicit testing immediately after every floating-point operation. By default, an operation always returns a result according to specification without interrupting computation. For instance, 1/0 returns +∞, while also setting the divide-by-zero flag bit (this default of ∞ is designed so as to often return a finite result when used in subsequent operations and so be safely ignored).|$|E
5000|$|DS:SI = {{points to}} the 16-byte MBR {{partition}} table entry (in the relocated MBR) corresponding with the activated VBR. PC-MOS 5.1 depends on this to boot if no partition in the partition table is flagged as bootable. In conjunction with LOADER, Multiuser DOS and REAL/32 boot sectors use this to locate the boot sector of the active partition (or another bootstrap loader like IBMBIO.LDR at a fixed position on disk) if the boot file (LOADER.SYS) could not be found. PTS-DOS 6.6 and S/DOS 1.0 use this in conjunction with their Advanced Active Partition (AAP) feature. In addition to support for LOADER and AAPs, DR-DOS 7.07 can use this to determine the necessary INT 13h access method when using its dual CHS/LBA VBR code and it will update the boot drive / <b>status</b> <b>flag</b> field in the partition entry according to the effectively used DL value. Darwin bootloaders (Apple's , , and David Elliott's [...] ) depend on this pointer as well, but additionally they don't use DS, but assume it to be set to 0000hex instead. This will cause problems if this assumption is incorrect. The MBR code of OS/2, MS-DOS 2.0 to 8.0, PC DOS 2.0 to 7.10 and Windows NT/2000/XP provides this same interface as well, although these systems do not use it. The Windows Vista/7 MBRs no longer provide this DS:SI pointer. While some extensions only depend on the 16-byte partition table entry itself, other extensions may require the whole 4 (or 5 entry) partition table to be present as well.|$|E
50|$|This design enabled more {{efficient}} program execution, as the Program Counter and <b>status</b> <b>flags</b> {{could be saved}} and restored with a single operation. This resulted in faster subroutine calls and interrupt response than traditional designs, which {{would have to do}} two register loads or saves when calling or returning from a subroutine.|$|R
50|$|Some {{very long}} {{instruction}} word processors dispense with the <b>status</b> <b>flags.</b> A single instruction both performs a test and indicates on which outcome of that test {{to take an}} action, such as Compare a with b and Jump to c if Equal. The result of the test is not saved for subsequent instructions.|$|R
50|$|The IMP-16 is a {{bit-slice}} processor. Each RALU chip {{provides a}} 4-bit {{slice of the}} register and arithmetic portion of a processor. Multiple RALU chips work in parallel, providing a longer word length. Each RALU chip provides 4 bits of the program counter, several registers, the ALU, a 16-word LIFO stack, and the <b>status</b> <b>flags.</b>|$|R
5000|$|David Watt also {{analyzes}} {{exception handling}} {{in the framework}} of sequencers (introduced in this article in the previous section on early exits.) Watt notes that an abnormal situation (generally exemplified with arithmetic overflows or input/output failures like file not found) is a kind of error that [...] "is detected in some low-level program unit, but which a handler is more naturally located in a high-level program unit". For example, a program might contain several calls to read files, but the action to perform when a file is not found depends on the meaning (purpose) of the file in question to the program and thus a handling routine for this abnormal situation cannot be located in low-level system code. Watts further notes that introducing status flags testing in the caller, as single-exit structured programming or even (multi-exit) return sequencers would entail, results in a situation where [...] "the application code tends to get cluttered by tests of status flags" [...] and that [...] "the programmer might forgetfully or lazily omit to test a <b>status</b> <b>flag.</b> In fact, abnormal situations represented by status flags are by default ignored!" [...] He notes that in contrast to status flags testing, exceptions have the opposite default behavior, causing the program to terminate unless the programmer explicitly deals with the exception in some way, possibly by adding code to willfully ignore it. Based on these arguments, Watt concludes that jump sequencers or escape sequencers (discussed in the previous section) aren't as suitable as a dedicated exception sequencer with the semantics discussed above.|$|E
30|$|GPRS {{stations}} use the PRACH {{to initiate}} a packet transfer by sending their requests {{for access to the}} GPRS network service, and listen to the PAGCH for a packet uplink assignment. The uplink assignment message includes the list of PDCH (Packet Data CHannels) and the corresponding Uplink <b>Status</b> <b>Flag</b> (USF) values per PDCH. GPRS stations keep listening to the USFs of the allocated PDCHs. If the corresponding USF is set, it means that the GPRS station has now been granted access to the next PDCH block.|$|E
40|$|At the ATLAS experiment, the Detector Control System (DCS) is used {{to oversee}} {{detector}} conditions and supervise the running of equipment. It is essential that information from the DCS {{about the status of}} individual sub-detectors be extracted and taken into account when determining the quality of data taken and its suitability for different analyses. DCS information is written to the ATLAS conditions database and then summarised to provide a <b>status</b> <b>flag</b> for each sub-detector and displayed on the web. We discuss how this DCS information should be used, and the technicalities of making this summary. © 2010 IOP Publishing Ltd...|$|E
50|$|The Clipper had 16 integer {{registers}} (R15 {{was used}} as stack pointer), 16 floating-point registers (limited to 8 in early implementations), plus a program counter (PC), a processor status word (PSW) containing ALU and FPU <b>status</b> <b>flags</b> and trap enables, and a system status word (SSW) containing external interrupt enable, user/supervisor mode, and address translation control bits.|$|R
5000|$|Bit operations. These take a {{register}} number {{and a bit}} number, and perform one of 4 actions: set or clear a bit, and test and skip on set/clear. The latter are used to perform conditional branches. The usual ALU <b>status</b> <b>flags</b> are available in a numbered register so operations such as [...] "branch on carry clear" [...] are possible.|$|R
25|$|The ARM2 {{featured}} a 32-bit data bus, 26-bit address space and 2732-bit registers. Eightbits {{from the program}} counter register were available for other purposes; the top sixbits (available because of the 26-bit address space) served as <b>status</b> <b>flags,</b> and the bottom twobits (available because the program counter was always word-aligned) were used for setting modes. The address bus was extended to 32bits in the ARM6, but program code still had to lie within the first 64MB of memory in 26-bit compatibility mode, due to the reserved bits for the <b>status</b> <b>flags.</b> The ARM2 had a transistor count of just 30,000, compared to Motorola's six-year-older 68000 model with around 40,000. Much of this simplicity came {{from the lack of}} microcode (which represents about one-quarter to one-third of the 68000) and from (like most CPUs of the day) not including any cache. This simplicity enabled low power consumption, yet better performance than the Intel 80286. A successor, ARM3, was produced with a 4KB cache, which further improved performance.|$|R
