64|239|Public
25|$|Limited {{whitespace}} {{is allowed}} and ignored around or between syntactic elements (values and punctuation, but not within a <b>string</b> <b>value).</b> Only four specific characters are considered whitespace for this purpose: space, horizontal tab, line feed, and carriage return. In particular, the byte order mark {{must not be}} generated by a conforming implementation (though it may be accepted when parsing JSON). JSON does not provide syntax for comments.|$|E
500|$|Misunderstanding of how Null {{works is}} the cause of a great number of errors in SQL code, both in ISO {{standard}} SQL statements and in the specific SQL dialects supported by real-world database management systems. These mistakes are usually the result of confusion between Null and either 0 (zero) or an empty string (a <b>string</b> <b>value</b> with a length of zero, represented in SQL as [...] ). [...] Null is defined by the SQL standard as different from both an empty string and the numerical value 0, however. While Null indicates the absence of any value, the empty string and numerical zero both represent actual values.|$|E
5000|$|... import evo.RemoteObject;import evo.exception.RemoteException;public class EvoImpl extends RemoteObject {{implements}} Evo { private <b>String</b> <b>value</b> = [...] "sample"; [...] public EvoImpl (...) {} public EvoImpl (Properties env) throws RemoteException { super (env); } public void setValue (<b>String</b> <b>value)</b> throws RemoteException { this.value = value; }} ...|$|E
5000|$|Formatting numeric or <b>string</b> <b>values</b> into a {{printable}} output string ...|$|R
50|$|<b>String</b> <b>values</b> can be {{computed}} if {{it represents}} a math formula.|$|R
5000|$|... statements, with [...] and [...] commands, for {{representing}} numerical and <b>string</b> <b>values</b> {{in quantity}} ...|$|R
5000|$|PlyCount: <b>String</b> <b>value</b> {{denoting}} {{total number}} of half-moves played.|$|E
5000|$|... foreach(phonebook; string key; <b>string</b> <b>value)</b> { write("%s:%s\n", key, value);} ...|$|E
5000|$|For this reason, most Web browsers use a User-Agent <b>string</b> <b>value</b> as follows: ...|$|E
25|$|The dex format {{defined by}} Dalvik also {{uses the same}} {{modified}} UTF-8 to represent <b>string</b> <b>values.</b>|$|R
5000|$|... :eqs: returns t {{for true}} if two <b>strings</b> <b>values</b> are {{identical}} in characters, case and length ...|$|R
5000|$|Aligning to Wikidata (formerly Freebase): this {{involves}} reconciliation — mapping <b>string</b> <b>values</b> in cells to entities in Wikidata.|$|R
5000|$|... {{bad file}} data: attempt {{to read a}} number into a <b>string</b> <b>value,</b> etc.|$|E
5000|$|Some {{databases}} support enumerated types directly. MySQL {{provides an}} enumerated type [...] with allowable values specified as strings when a table is created. The values are stored as numeric indices with the empty string stored as 0, the first <b>string</b> <b>value</b> stored as 1, the second <b>string</b> <b>value</b> stored as 2, etc. Values {{can be stored}} and retrieved as numeric indexes or string values.|$|E
5000|$|... import evo.ERemote;import evo.annotation.*;import evo.exception.*;@RemoteInterfacepublic {{interface}} Evo extends ERemote { @RemoteMethod public void setValue (<b>String</b> <b>value)</b> throws RemoteException;} ...|$|E
5000|$|... leveldb, a fast {{key-value}} {{storage library}} written at Google that provides an ordered mapping from string keys to <b>string</b> <b>values</b> ...|$|R
40|$|This paper {{presents}} a formal correctness proof for some properties of restricted finite directed acyclic graphs (DAGs). A restricted graph {{has a single}} root and arbitrary siblings. The siblings are assigned integers, <b>string</b> <b>values,</b> or restricted DAGs. Leafs must be assigned <b>string</b> <b>values.</b> The main property is the transitive closure. Our restricted graphs and the properties are formalized in ACL 2, and an ACL 2 book has been prepared for reuse. 1...|$|R
50|$|Back {{referencing}} allows replacing {{of property}} names and/or short (64 bytes or less) <b>String</b> <b>values</b> with 1- or 2-byte reference ids.|$|R
5000|$|Likewise, any {{argument}} can precede the argument list:template VariadicTemplate(T, <b>string</b> <b>value,</b> alias symbol, Args...) { /* Body */ } ...|$|E
50|$|A {{variable}} {{definition is}} a line that specifies a text <b>string</b> <b>value</b> for a variable that can be substituted into the text later.|$|E
5000|$|As an example, an {{implementation}} of a simple distributed hashtable over Cassandra is listed. /** * Insert a new value keyed by key * @param key Key for the value * @param value the <b>String</b> <b>value</b> to insert */ public void insert(final String key, final <b>String</b> <b>value)</b> throws Exception { execute(new Command (...) { public Void execute(final Keyspace ks) throws Exception { ks.insert(key, createColumnPath(COLUMN_NAME), bytes(value)); return null; } }); } /** * Get a <b>string</b> <b>value.</b> * @return The string value; null if no value exists for the given key. */ public String get(final String key) throws Exception { return execute(new Command (...) { public String execute(final Keyspace ks) throws Exception { try { return string(ks.getColumn(key, createColumnPath(COLUMN_NAME)).getValue (...) [...] ); } catch (NotFoundException e) { return null; } } }); } /** * Delete a key from cassandra */ public void delete(final String key) throws Exception { execute(new Command (...) { public Void execute(final Keyspace ks) throws Exception { ks.remove(key, createColumnPath(COLUMN_NAME)); return null; } }); } ...|$|E
5000|$|... :converts the <b>string</b> <b>values</b> {{of all the}} nodes {{found by}} the XPath {{argument}} into numbers, according to the built-in casting rules, then returns the sum of these numbers.|$|R
50|$|XPL {{includes}} a minimal runtime support library for allocating and garbage-collecting XPL <b>string</b> <b>values.</b> The source code for this library {{must be included}} into most every program written in XPL.|$|R
50|$|In programming, string {{concatenation}} generally {{occurs at}} run time, as <b>string</b> <b>values</b> {{are not in}} general known until run time. However, {{in the case of}} <b>string</b> literals, the <b>values</b> are known at compile time, and thus string concatenation can be done at compile time, either via string literal concatenation or via constant folding.|$|R
5000|$|... package com.annotation;public @interface UnderConstruction { String owner (...) default [...] "Patrick Naughton"; <b>String</b> <b>value</b> (...) default [...] "Object is Under Construction."; String createdBy (...) default [...] "Mike Sheridan"; String lastChanged (...) default [...] "2011-07-08";} ...|$|E
5000|$|... str {{indicates}} a string expression is required. This {{can be a}} static <b>string</b> <b>value</b> (in quotes), a string variable, or other function or expression that returns a string of characters.|$|E
50|$|In Swift, a new <b>String</b> <b>value</b> can {{be created}} from a mix of constants, variables, literals, and {{expressions}} by including their values inside a string literal. Each item inserted into the string literal is wrapped {{in a pair of}} parentheses, prefixed by a backslash.|$|E
50|$|YAML {{associative}} arrays {{are also}} called map elements or key-value pairs. YAML places no {{restrictions on the}} type of keys; in particular, they are not restricted to being scalar or <b>string</b> <b>values.</b>|$|R
30|$|In real scenarios, some {{values are}} not numerical. In this case, {{we have to}} extend our {{framework}} to non-numerical <b>values,</b> mostly <b>string</b> <b>values.</b> We will first give some definitions {{for the sake of}} further discussion.|$|R
40|$|Copyright © 2015 ISSR Journals. This is an {{open access}} article {{distributed}} under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. ABSTRACT: This paper presents the systematic way of hashing <b>string</b> <b>values</b> using NFO and NOF collision resolution strategies. NFO and NOF are techniques used for hashing numeric keys. The same principles and techniques for hashing numeric keys are deployed in the hashing of <b>string</b> <b>values</b> but with slight modifications in the hashing process and implementations. These variants followed the standard ways of evaluating and implementing algorithms to resolve collisions in hash tables. They are very effective in resolving the problem of collisions of <b>string</b> keys or <b>values</b> in the same slot of a hash table...|$|R
5000|$|A GeneralizedTime is a {{time format}} in the ASN.1 notation.It {{consists}} of a <b>string</b> <b>value</b> representing the calendar date, as defined in ISO 8601, a time of day with an optional fractional seconds element and the optional local time differential factor as defined in ISO 8601.|$|E
50|$|This {{function}} can {{be thought}} of as the primary mechanism for producing triples with nodes that match the corresponding terms and term pattern provided.A conjunctive query can be indicated by either providing a value of NULL/None/Empty <b>string</b> <b>value</b> for context or the identifier associated with the Conjunctive Graph.|$|E
5000|$|In Delphi the [...] {{function}} {{can be used}} {{to achieve}} the same as [...] If the [...] library is used, the [...] function returns a numeric value such as an Integer, Double or Extended. If the [...] library is used, this function can also return a <b>string</b> <b>value.</b>|$|E
30|$|For data preparation, we select {{products}} from several related categories like computers and digital devices. Since the attributes generally take <b>string</b> <b>values,</b> we transform the attribute by methods derived from Section 7.2. We {{also tried to}} prune the data for consistency.|$|R
40|$|Abstract Strings are an {{important}} part of most real application multivalued contexts. Their conceptual treatment requires the definition of substring scales, i. e., sets of relevant substrings, so as to form informative concepts. However these scales are either defined by hand, or derived in a context-unaware manner (e. g., all words occuring in <b>string</b> <b>values).</b> We present an efficient algorithm based on suffix trees that produces complete and concise substring scales. Completeness ensures that every possible concept is formed, like when considering the scale of all substrings. Conciseness ensures the number of scale attributes (substrings) is less than the cumulated size of all <b>string</b> <b>values.</b> This algorithm is integrated in Camelis, and illustrated on the set of all ICCS paper titles. ...|$|R
50|$|<b>String</b> <b>values</b> (literals) must be {{enclosed}} by quotes. Enclosing a string in double quotes allows {{the values of}} variables whose names appear in the string to automatically replace the variable name (or be interpolated) in the string. Enclosing a string in single quotes prevents variable interpolation.|$|R
