0|9125|Public
40|$|A {{number of}} {{security}} systems for programming languages have recently appeared, including systems for enforcing {{some form of}} access control. The Java JDK 1. 2 security architecture is one such system that is widely studied and used. While the architecture has many appealing features, access control checks are all implemented via dynamic method calls. This is a highly non-declarative form of specification which is hard to read, and which leads to additional run-time overhead. In this paper, we present a novel security type system that enforces the same <b>security</b> <b>guarantees</b> <b>as</b> Java Stack Inspection, but via a static type system with no additional run-time checks. The system allows security properties of programs to be clearly expressed within the types themselves. We also define and prove correct an inference algorithm for security types, meaning that the system {{has the potential to}} be layered on top of the existing Java architecture, without requiring new syntax. 1. INTRODUCTION Securit [...] ...|$|R
40|$|Apart (CAPTCHAs) are {{systems that}} allow a {{computer}} to distinguish between another computer and a human. Reading-based HIP challenges typically comprise a segmentation challenge followed by recognition challenges. The currently available CAPTCHAs have been broken with varying success, using the weakness in the methods used to generate the images. The {{state of the art}} of CAPTCHA design suggests that such text-based schemes should rely on segmentation resistance to provide <b>security</b> <b>guarantee,</b> <b>as</b> individual character recognition after segmentation can be solved with a high success rate by standard methods such as neural networks. A good CAPTCHA must be not only human friendly, but also robust enough to resist computer programs that attackers write to automatically pass CAPTCHA tests (or challenges). In this paper we propose a multi level approach using hard image segmentation and embedded text to enhance the security of HIPs. The shadow of distorted text is embedded into sparse backgrounds. The effect of different backgrounds, into which the characters are distorted and embedded, is studied...|$|R
40|$|Dynamic Information Flow Tracking (DIFT) is a {{promising}} security technique. With hardware support, DIFT prevents {{a wide range}} of attacks on vulnerable software with minimal performance impact. DIFT architectures, however, require significant changes in the processor pipeline that increase design and verification complexity and may affect clock frequency. These complications deter hardware vendors from supporting DIFT. This paper makes hardware support for DIFT cost-effective by decoupling DIFT functionality onto a simple, separate coprocessor. Decoupling is possible because DIFT operations and regular computation need only synchronize on system calls. The coprocessor is a small hardware engine that performs logical operations and caches 4 -bit tags. It introduces no changes to the design or layout of the main processor’s logic, pipeline, or caches, and can be combined with various processors. Using a full-system hardware prototype and realistic Linux workloads, we show that the DIFT coprocessor provides the same <b>security</b> <b>guarantees</b> <b>as</b> current DIFT architectures with low runtime overheads...|$|R
40|$|We {{revisit the}} notion of {{achieving}} a protected communication path for applications connected via the Internet using SELinux. Last year, we discussed the mechanism for integrating IPsec with SELinux security labels, {{but we did not}} consider the system goals for using such labels. Toward this end, we revisit early SELinux proposals for what is called a protected path. A protected path is a secure communication path that has the same <b>security</b> <b>guarantees</b> <b>as</b> if the two ends are directly connected on a trusted platform and mutually authenticated. If a protected path can be constructed over the Internet in a reliable manner, then distributed applications can be as secure as two applications running on the same, isolated environment. A variety of challenges remain in building a protected path system, but interestingly, efforts are underway in most areas, with the notable exception of secure windowing systems. This talk will outline an approach to protected paths {{in the context of a}} distributed computing example, what work is underway toward achieving protected paths, and what is required of that work to compose protected paths with SELinux. ...|$|R
40|$|We {{introduce}} {{the problem of}} Multi-Input Functional Encryption, where a secret key SKf can correspond to an n-ary function f that takes multiple ciphertexts as input. Multi-input functional encryption is a general tool for computing on encrypting data which allows for mining aggregate information from several different data sources (rather than just a single source as in single input functional encryption). We show wide applications of this primitive to running SQL queries over encrypted database, non-interactive differentially private data release, delegation of computation, etc. We formulate both indistinguishability-based and simulation-based definitions of security for this notion, and show close connections with indistinguishability and virtual black-box def-initions of obfuscation. Assuming indistinguishability obfuscation for circuits, we present con-structions achieving indistinguishability security for a large class of settings. We show how to modify this construction to achieve simulation-based security as well, in those settings where simulation security is possible. Assuming differing-inputs obfuscation [Barak et al., FOCS’ 01], we also provide a construction with similar <b>security</b> <b>guarantees</b> <b>as</b> above, but where the keys and ciphertexts are compact...|$|R
40|$|Abstract. Oblivious {{transfer}} (OT) is {{a fundamental}} primitive used in many cryptographic protocols, including general secure function evalua-tion (SFE) protocols. However, interaction is a primary feature of any OT protocol. In this paper, we show how to remove the interaction require-ment in an OT protocol when parties participating in the protocol have access to slightly modified Trusted Platform Modules, as defined by Sar-menta et al. in proposing the notion of count-limited objects (clobs) [8]. Specifically, we construct a new cryptographic primitive called “gener-alized non-interactive oblivious transfer”(GNIOT). While {{it is possible to}} perform GNIOT using clobs in a straightforward manner, with mul-tiple clobs, we show how to perform this efficiently, by using a single clob regardless of the number of values that need to be exchanged in an oblivious manner. Additionally, we provide clear definitions and a formal proof of the security of our construction. We apply this primitive to mo-bile agent applications and outline a new secure agent protocol called the GTX protocol which provides the same <b>security</b> <b>guarantees</b> <b>as</b> existing agent protocols while removing the need for interaction, thus improving efficiency. ...|$|R
40|$|CAPTCHA is {{now almost}} a {{standard}} security technology. The {{most widely used}} CAPTCHAs rely on the sophisticated distortion of text images rendering them unrecognisable {{to the state of}} the art of pattern recognition techniques, and these textbased schemes have found widespread applications in commercial websites. The state of the art of CAPTCHA design suggests that such text-based schemes should rely on segmentation resistance to provide <b>security</b> <b>guarantee,</b> <b>as</b> individual character recognition after segmentation can be solved with a high success rate by standard methods such as neural networks. In this paper, we analyse the security of a textbased CAPTCHA designed by Microsoft and deployed for years at many of their online services including Hotmail, MSN and Windows Live. This scheme was designed to be segmentation-resistant, and it has been well studied and tuned by its designers over the years. However, our simple attack has achieved a segmentation success rate of higher than 90 % against this scheme. It took ~ 80 ms for our attack to completely segment a challenge on a desktop computer with a 1. 86 GHz Intel Core...|$|R
40|$|Logging and {{auditing}} is {{an important}} system facility for monitoring correct system operation and for detecting potential security problems. We present an architecture for implementing user-level auditing monitors which: (i) does not require superuser privileges; (ii) makes it simple to create user defined monitors which are transparent; and (iii) provides <b>security</b> <b>guarantees</b> such <b>as</b> mandatory and reliable monitoring while maintaining confidentiality of setuid processes. We avoid problems of self-referential monitoring. Monitor use policies can be specified to increase flexibility. We show that our framework can be tailored {{so that it is}} very efficient with low overhead on macro and micro benchmarks. This demonstrates that it is feasible to make use of arbitrary and programmable user-level monitors for system security and auditing applications...|$|R
40|$|We {{narrow the}} gap between {{concrete}} implementations of cryptographic protocols and their ver-ified models. We develop and verify a small functional implementation of the Transport Layer Security protocol (TLS 1. 0). We {{make use of the}} same executable code for interoperability testing against mainstream implementations, for automated symbolic cryptographic verification, and for automated computational cryptographic verification. We rely on a combination of recent tools, and we also develop a new tool for extracting computational models from executable code. We obtain strong <b>security</b> <b>guarantees</b> for TLS <b>as</b> used in typical deployments...|$|R
40|$|Abstract—Standard {{implementations}} {{of common}} data {{structures such as}} hash tables can leak information, e. g. the operation history, to attackers with later access to a machine’s memory. This leakage is particularly damaging whenever the history of operations performed on a data structure must remain secret, such as in voting machines. We show how unique representation—the requirement that a data structure have canonical machine representations—can be used to perform modular verification of information flow policies in programs that compose data structures with their clients. We present a compositional verification system based on Relational Hoare Type Theory (RHTT) that uses unique representation to enforce end-to-end <b>security</b> <b>guarantees</b> such <b>as</b> noninterference for such programs. We validate our system and technique with examples drawn from arrays, multisets, hash tables, and a medical database application. The system, theorems, and examples have all been verified in Coq. I...|$|R
50|$|US {{retreat from}} {{unconditional}} defense guarantees to lesser allies in general was driven {{as much by}} financial concerns as by policy re-examination of strategic and foreign policy objectives, reflected in Nixon's goals of détente and nuclear arms control with the Soviet Union, and establishment of formal diplomatic relations with the People's Republic of China. As a consequence of this shift, direct sales of weaponry to nations no longer under the nuclear umbrella of previous US <b>security</b> <b>guarantees</b> dramatically increased <b>as</b> US <b>guarantees</b> were withdrawn. In South Korea, 20,000 of the 61,000 US troops stationed there were withdrawn by June 1971.|$|R
40|$|Historically, {{cryptography}} arose as a {{means to}} enable parties to maintain privacy of the information they send to each other, even in the presence of an adversary with access to the communication channel. While providing privacy remains a central goal, the field has expandeded to encompass many others, including not just other goals of communication <b>security,</b> such <b>as</b> <b>guaranteeing</b> integrit...|$|R
40|$|We propose new constructions for identity-based {{broadcast}} encryption (IBBE) {{and fuzzy}} identity-based encryption (FIBE) in composite-order groups {{equipped with a}} bilinear pairing. Our starting point is the IBBE scheme of Delerablée (Asiacrypt 2007) and the FIBE scheme of Herranz et al. (PKC 2010) proven secure under parameterised assumptions called generalised decisional bilinear Diffie-Hellman (GDDHE) and augmented multi-sequence of exponents Diffie-Hellman (aMSE-DDH) respectively. The two schemes are described in the prime-order pairing group. We transform the schemes into the setting of (symmetric) composite-order groups and prove security from two static assumptions (subgroup decision). The Déjà Q framework of Chase et al. (Asiacrypt 2016) is known to cover a large class of parameterised assumptions (dubbed "Uber assumption"), that is, these assumptions, when defined in asymmetric composite-order groups, are implied by subgroup decision assumptions in the underlying composite-order groups. We argue that the GDDHE and aMSE-DDH assumptions {{are not covered by}} the Déjà Q ¨ uber assumption framework. We therefore work out direct security reductions for the two schemes based on subgroup decision assumptions. Furthermore, our proofs involve novel extensions of Déjà Q techniques of Wee (TCC 2016 -A) and Chase et al. Our constructions have constant-size ciphertexts. The IBBE has constant-size keys as well and achieves a stronger <b>security</b> <b>guarantee</b> <b>as</b> compared to Delerablée's IBBE, thus making it the first compact IBBE known to be selectively secure without random oracles under simple assumptions. The fuzzy IBE scheme is the first to simultaneously feature constant-size ciphertexts and security under standard assumptions...|$|R
40|$|Abstract. Recent revelations by Edward Snowden [PLS 13,BBG 13,Gre 14] {{show that}} a user’s own {{hardware}} and software can be used against her in various ways (e. g., to leak her private information). And, a series of recent announcements has shown that widespread implementations of cryptographic software often contain serious bugs that cripple security (e. g., [LHA+ 12,CVE 14 b,CVE 14 a,CVE 14 c]). This motivates us to consider the following (seemingly absurd) question: How can we <b>guarantee</b> a user’s <b>security</b> when she may be using a malfunctioning or arbitrarily compromised machine? To that end, we introduce {{the notion of a}} cryptographic reverse firewall (RF). Such a machine sits between the user’s computer and the outside world, potentially modifying the messages that she sends and receives as she engages in a cryptographic protocol. A good reverse firewall accomplishes three things: (1) itmaintains functionality, so that if the user’s computer is working correctly, the RF will not break the functionality of the underlying protocol; (2) it preserves security, so that regardless of how the user’s machine behaves, the presence of the RF will provide the same <b>security</b> <b>guarantees</b> <b>as</b> the properly implemented protocol; and (3) it resists exfiltration, so that regardless of how the user’s machine behaves, the presence of the RF will prevent the machine from leaking any information to the outside world. Importantly, we do not model the firewall as a trusted party. It does not share any secrets with the user, and the protocol should be both secure and functional without the firewall (when it is implemente...|$|R
40|$|CAPTCHA is {{now almost}} a {{standard}} Security technology. The most widely deployed CAPTCHAs are text-based schemes, which typically require users {{to solve a}} text recognition task. The {{state of the art}} of CAPTCHA design suggests that Such text-based schemes should rely on segmentation resistance to provide <b>Security</b> <b>guarantee,</b> <b>as</b> individual character recognition after segmentation can be solved with a high Success rate by standard methods such as neural networks. In this paper, we present new character segmentation techniques of general Value to attack a number of text CAPTCHAs, including the schemes designed and deployed by Microsoft, Yahoo and Google. In particular, the Microsoft CAPTCHA has been deployed since 2002 at many of their online services including Hotmail, MSN and Windows Live. Designed to be segmentation-resistant, this scheme has been studied and tuned by its designers over the years. However, our simple attack has achieved a segmentation success rate of higher than 90 % against this scheme. It took on average similar to 80 ms for the attack to completely segment a challenge on an ordinary desktop computer. As a result, we estimate that this CAPTCHA Could be instantly broken by a malicious hot with an overall (segmentation and then recognition) Success rate of more than 60 %. On the contrary, the design goal was that automated attacks Should not achieve a success rate of higher than 0. 01 %. For the first time, this paper shows that CAPTCHAs that are carefully designed to be segmentation-resistant are Vulnerable to novel but simple attacks...|$|R
40|$|Program {{obfuscation}} is {{the software}} analog {{to the problem}} of tamper-proofing hardware. The goal of program obfuscation is to construct a compiler, called an "obfuscator," that garbles the code of a computer program while maintaining its functionality. Commercial products exist to perform this procedure, but they do not provide a rigorous <b>security</b> <b>guarantee.</b> Over the past decade, program obfuscation has been studied by the theoretical cryptography community, where rigorous definitions of security have been proposed and obfuscators have been constructed for some families of programs. This thesis presents three contributions based on the virtual black-box security definition of Barak et al [10]. First, we show tight connections between obfuscation and symmetric-key encryption. Specifically, obfuscation can be used to construct an encryption scheme with strong leakage resilience and key-dependent message security. The converse is also true, and these connections scale with the level of security desired. As a result, the known constructions and impossibility results for each primitive carry over to the other. Second, we present two new security definitions that augment the virtual black-box property to incorporate non-malleability. The virtual black-box definition does not prevent an adversary from modifying an obfuscated program intelligently. By contrast, our new definitions provide software with the same <b>security</b> <b>guarantees</b> <b>as</b> tamper-proof and tamper-evident hardware, respectively. The first definition prohibits tampering, and the second definition requires that tampering is detectable after the fact. We construct non-malleable obfuscators of both favors for some program families of interest. Third, we present an obfuscator for programs that test for membership in a hyperplane. This generalizes prior works that obfuscate equality testing. We prove the security of the obfuscator under a new strong variant of the Decisional Diffie-Hellman assumption that holds in the generic group model. Additionally, we show a cryptographic application of the new obfuscator to leak-ageresilient one-time digital signatures. The thesis also includes a survey of the prior results in the field. by Mayank Varia. Thesis (Ph. D.) [...] Massachusetts Institute of Technology, Dept. of Mathematics, 2010. This electronic version was submitted by the student author. The certified thesis is available in the Institute Archives and Special Collections. Cataloged from student submitted PDF version of thesis. Includes bibliographical references (p. 159 - 164) ...|$|R
30|$|It is {{important}} to point out that the aforementioned benefits do not come without more complex deployment, policy, control and coordination requirements. The added complexity can reduce the overall <b>security</b> and privacy <b>guarantees,</b> <b>as</b> more components come under the influence of an attacker. Immediate and major challenges arising from decentralization are distributed infrastructure protection, identity lifecycle and cryptographic key management (i.e. secure generation, distribution, exchange, storage, use, and replacement of credentials and keys). These are rather classical problems, but they receive new undertones which may allow interesting trade-offs and novel solutions in the context of Fog computing.|$|R
40|$|Much of {{the value}} of cloud {{services}} lies in leveraging client data, which often conflicts with the client’s desire to keep that data private. Reconciling these contradictory requirements is an important research and engineering problem, whose efficient solution would have a far-reaching business impact. Generic theoretical approaches, such as fully-homomorphic encryption, are inefficient. Ad hoc approaches, such as order-preserving encryption (OPE), provide solutions to a limited class of problems (e. g., evaluating encrypted range queries). Security achieved in real systems, even if an “ideal OPE ” is employed, is hard to evaluate, and is often only illusory, since the ability to order ciphertexts may reveal a lot about the underlying plaintexts. We concentrate on a typical application of OPE, encrypted searchable webmail service. We describe how the use of OPE in this setting may divulge information and discuss approaches to minimize its impact. The main avenue to improve privacy is to appropriately limit the type of interactions that should be allowed with a webmail server. © 2012 Alcatel-Lucent. inefficient, and seems unlikely to become truly practi-cal in the foreseeable future. Although a significant effort is underway in the theoretical community to improve the performance of FHE, it is unlikely that fully-homomorphic encryption will approach the effi-ciency of current public key encryption (PKE) schemes any time soon. Intuitively, this is because a fully-homomorphic cryptosystem must provide the same strong <b>security</b> <b>guarantees</b> <b>as</b> PKE, while supporting the additional algebraic structure to allow for homo-morphic operations. The extra structure weakens security and leads to a need for countermeasures, which are implemented at the cost of performance. Further, even performance equivalent to that of a “regular ” public-key encryption scheme such as RSA i...|$|R
40|$|Abstract: CAPTCHA is {{now almost}} a {{standard}} security technology. The {{most widely used}} CAPTCHAs rely on the sophisticated distortion of text images rendering them unrecognisable {{to the state of}} the art of pattern recognition techniques, and these text-based schemes have found widespread applications in commercial websites. The state of the art of CAPTCHA design suggests that such text-based schemes should rely on segmentation resistance to provide <b>security</b> <b>guarantee,</b> <b>as</b> individual character recognition after segmentation can be solved with a high success rate by standard methods such as neural networks. In this paper, we analyse the security of a text-based CAPTCHA designed by Microsoft and deployed for years at many of their online services including Hotmail, MSN and Windows Live. This scheme was designed to be segmentation-resistant, and it has been well studied and tuned by its designers over the years. However, our simple attack has achieved a segmentation success rate of higher than 90 % against this scheme. It took on average ~ 80 ms for the attack to completely segment a challenge on a desktop computer with a 1. 86 GHz Intel Core 2 CPU and 2 GB RAM. As a result, we estimate that this Microsoft scheme can be broken with an overall (segmentation and then recognition) success rate of more than 60 %. On the contrary, its design goal was that "automatic scripts should not be more successful than 1 in 10, 000 " attempts (i. e. a success rate of 0. 01 %). For the first time, we show that a CAPTCHA that is carefully designed to be segmentation-resistant is vulnerable to novel but simple attacks. Our results show that it is not a trivial task to design a CAPTCHA scheme that is both usable and robust...|$|R
40|$|The Sancus {{security}} architecture for networked embedded devices was proposed in 2013 at the USENIX Security conference. It supports remote (even third-party) software installation on devices while maintaining strong <b>security</b> <b>guarantees.</b> More specifically, Sancus can remotely attest to a software provider that a specific software module is running uncompromised, and {{can provide a}} secure communication channel between software modules and software providers. Software modules can securely maintain local state, and can securely interact with other software modules that they choose to trust. Over the past three years, significant experience has been gained with applications of Sancus, and several extensions of the architecture have been investigated – both by the original designers {{as well as by}} independent researchers. Informed by these additional research results, this journal version of the Sancus paper describes an improved design and implementation, supporting additional <b>security</b> <b>guarantees</b> (such <b>as</b> confidential deployment) and a more efficient cryptographic core. We describe the design of Sancus 2. 0 (without relying on any prior knowledge of Sancus), and develop and evaluate a prototype FPGA implementation. The prototype extends an MSP 430 processor with hardware support for the memory access control and cryptographic functionality required to run Sancus. We report on our experience with using Sancus in a variety of application scenarios, and discuss some important avenues of ongoing and future work. status: publishe...|$|R
40|$|Cryptographic hash {{functions}} {{form the}} basis of the security of today's digital environment, and find applications in numerous cryptographic systems such as tamper detection, key derivation functions, and digital signatures. Ideally, hash functions behave like a random oracle, a function that returns random outputs for each new input, but in practice such a construction does not exist. Usually, a hash function is designed to give strong confidence that it is indeed secure, and it is presumed secure until it is broken. In 2004 - 2005, cryptanalytic breakthroughs have raised doubts about the security of many widely employed hash functions, such as MD 5 and SHA- 1. As a response, in 2007 the US National Institute for Standards and Technology (NIST) announced a call for the design of a new SHA- 3 hashing algorithm. This dissertation deals with the fundamental security properties of hash functions. It is divided into two parts. In {{the first part of the}} dissertation, we analyze existing hash functions and introduce design methodologies. We particularly search for the limits within the provable security framework, by considering minimalist designs with maximal security. Firstly, we look at double block length 3 n-to- 2 n-bit compression functions based on block ciphers with an n-bit message and key space. We consider the MDC- 4 hash function, and improve its collision and preimage security bounds. Next, we present a family of designs that make three cipher calls and achieve optimal collision security and very good preimage security. Furthermore, we consider the possibility of compression functions based on permutations, and provide a full security classification of all 2 n-to-n-bit compression functions solely built of XOR operators and three permutations. As a final contribution of this part, we propose the family of parazoa functions as a generalization of the sponge hash function design, and prove that parazoa functions are indifferentiable from a random oracle. The sponge is a popular hash function design and many derivatives, called sponge-like functions, appeared in literature. However, these sponge-like functions do not automatically enjoy the same <b>security</b> <b>guarantees</b> <b>as</b> the original sponge. Our generalized parazoa family applies to a wide class of sponge-like functions, and the indifferentiability proof for parazoa naturally carries over. In the second part of the dissertation, we consider NIST's SHA- 3 hash function competition from a provable security point of view. We provide a detailed survey of the five SHA- 3 finalists, in which we analyze and compare their <b>security</b> <b>guarantees.</b> We consider collision, preimage, and second preimage resistance and indifferentiability of all finalists, and solve open problems where needed. status: publishe...|$|R
40|$|One of {{the major}} {{security}} aspects in mobile communication networks concerns information about the localization of the (mobile) network user. This information may be protected by establishing a trusted third party {{that is responsible for}} creating suitable pseudonyms for the user identity. Distributing the maintenance of pseudonyms among n independent trusted parties allows to increase further the security of location information. In this paper, a method is proposed that <b>guarantees</b> <b>security</b> <b>as</b> long as {{at least one of the}} n parties may definitely be trusted whereas the other parties may turn out to be corrupt. The pseudonym collision probability is derived analytically before a detailed OPNET simulation evaluates the cost of the new approach compared to standard GSM...|$|R
40|$|The {{generalized}} {{knapsack problem}} is the following: given m random elements a 1, [...] ., am ∈ R for some ring R, and a target t ∈ R, find elements z 1, [...] ., zm ∈ D such that � aizi = t where D is some given subset of R. In (Micciancio, FOCS 2002), it was proved that for appropriate choices of R and D, solving the generalized compact knapsack problem on the average is as hard as solving certain worst-case problems for cyclic lattices even for almost constant values of m. This immediately yields very efficient one-way functions whose security is based on worst-case hardness assumptions. A problem left open in (Micciancio, FOCS 2002) is whether these functions satisfy stronger <b>security</b> <b>guarantees,</b> such <b>as</b> collision resistance. We show that the function proposed in (Micciancio, 2002) is not collision resistant, {{but it can be}} easily modified to achieve collision resistance under essentially the same complexity assumptions on cyclic lattices. Our modified function is obtained as a special case of a more general result, which yields efficient collision resistant hash functions that are at least hard to break as solving the worst case instance of various new problems. These include new problems from algebraic number theory, as well as classic lattice problems (e. g., the shortest vector problem) over ideal lattices, a new class of lattices that includes cyclic lattices as a special case...|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedU. S. policy makers claim that {{nuclear weapons are}} needed to <b>guarantee</b> <b>security</b> commitments and discourage the international spread of nuclear weapons. This thesis evaluates the link between <b>security</b> <b>guarantees</b> and efforts to prevent nuclear proliferation. It draws three conclusions based on case studies {{of the use of}} conventional security commitments and nuclear <b>security</b> <b>guarantees</b> to prevent nuclear weapons development in South Korea and Taiwan. First, nuclear <b>security</b> <b>guarantees</b> alone are not sufficient to prevent proliferation. Second, strong conventional commitments made credible by visible presence of forces are sufficient to prevent nuclear proliferation when the direct security threat is conventional. Third, when the security threat being faced includes nuclear weapons, nuclear proliferation prevention requires both a nuclear <b>security</b> <b>guarantee</b> and a physically evident conventional military guarantee. Two implications for security policy follow from these findings. First, nuclear weapons are necessary in the modem security environment. Second, nuclear <b>security</b> <b>guarantees</b> are not credible without the stationing of conventional forces[URL] United States Nav...|$|R
40|$|We {{investigate}} {{the effect of}} employer job <b>security</b> <b>guarantees</b> on employee perceptions of job insecurity. Using linked employer-employee data from the 1998 British Workplace Employee Relations Survey, we find job <b>security</b> <b>guarantees</b> reduce employee perceptions of job insecurity. This finding is robust to endogenous selection of job <b>security</b> <b>guarantees</b> by employers engaging in organizational change and workforce reductions. Furthermore, {{there is no evidence}} that increased job <b>security</b> through job <b>guarantees</b> results in greater work intensification, stress, or lower job satisfaction. Copyright 2009 The Authors. Journal compilation 2009 CEIS, Fondazione Giacomo Brodolini and Blackwell Publishing Ltd [...] ...|$|R
40|$|Abstract. The goal of Multi-Party Computation (MPC) is {{to perform}} an {{arbitrary}} computation in a distributed, private, and fault-tolerant way. For this purpose, a fixed set of n parties runs a protocol that tolerates an adversary corrupting {{a subset of the}} participating parties, and still preserves certain <b>security</b> <b>guarantees.</b> Most MPC protocols provide <b>security</b> <b>guarantees</b> in an all-or-nothing fashion: Either the set of corrupted parties is tolerated and the protocol provides all specified <b>security</b> <b>guarantees,</b> or the set of corrupted parties is not tolerated and the protocol provides no <b>security</b> <b>guarantees</b> at all. Similarly, corruptions are in an all-or-nothing fashion: Either a party is fully honest, or it is fully corrupted. For example, an actively secure protocol is rendered completely insecure when just one party is corrupted additionally to what is tolerated, even if all corrupted parties are only passive. In this paper, we provide the first treatment of MPC with graceful degradation of both security and corruptions. First of all, our protocols provide graceful degradation of security, i. e., different <b>security</b> <b>guarantees</b> depending on the actual number of corrupted parties: the more corruptions, the weaker the <b>security</b> <b>guarantee.</b> We consider all security properties generally discussed in the literature (secrecy, correctness, robustness, fairness, and agreement on abort). Furthermore, the protocols provid...|$|R
40|$|International audienceIn {{the model}} of Secure Network Coding, a sender is {{connected}} to several receivers by a network, i. e. a directed graph with a single source node and several destination nodes, where each node can perform operations on the values received via the incoming edges and sends the results via the outbound edges. An active adversary controls some of the edges; this means that he can read every symbol transmitted over the edges under his control {{and replace them with}} symbols of his choice. The goal of Secure Network Coding is to design protocols that allow transmission of a secret message from the sender to all receivers in a private and reliable way. Classically, only one-way communication (from sender to receivers) has been studied; in this setting, <b>security</b> can be <b>guaranteed</b> <b>as</b> long as the number of edges controlled by the adversary is less than one third of the network connectivity. In this paper, we present a procedure where receivers are allowed to send feedback to the sender; with this feature, <b>security</b> is <b>guaranteed</b> against a stronger adversary: namely, the number of corrupted edges only needs to be smaller than one half of the connectivity. Furthermore, like previous state-of-the-art work on the single-round scenario, our scheme is universal, i. e. it does not require knowledge of the network code...|$|R
5000|$|<b>Security</b> <b>guarantees</b> {{for all the}} {{participants}} of negotiations.|$|R
25|$|<b>Security</b> <b>guarantees</b> for judges, {{prosecutors}} {{and other public}} servants.|$|R
5000|$|... no {{guarantees}} of military aid or <b>security</b> <b>guarantees</b> to Ukraine ...|$|R
40|$|Abstract—With high expansibility and {{efficient}} power usage, tiered {{wireless sensor networks}} are widely deployed in many fields as {{an important part of}} Internet of Things (IoTs). It is challenging to process range query while protecting sensitive data from adversaries. Moreover, most existing work focuses on privacy-preserving range query neglecting collusion attacks and probability attacks, which are more threatening to network security. In this paper, we first propose a secure range query protocol called secRQ, which not only protects data privacy, but also resists collusion attacks and probability attacks in tiered wireless sensor networks. Generalized inverse matrices and distance-based range query mechanism are used to <b>guarantee</b> <b>security</b> <b>as</b> well as high efficiency and accuracy. Besides, we propose the mutual verification scheme to verify the integrity of query results. Finally, both theoretical analysis and experimental results confirm the security, efficiency and accuracy of secRQ...|$|R
5000|$|Following the May 1998 riots of Indonesia, the Minister of Immigration {{announced}} {{new regulations}} surrounding {{the requirement for}} visas for citizens travelling from certain countries. [...] This {{was an attempt to}} prevent Indonesians of Chinese ethnicity from seeking refugee status in New Zealand {{in the aftermath of the}} violence that was taking place, particularly in Java. The RSAA ruled on a refugee claim in 1999 where it was held that any claim based on the assertion that Chinese Indonesians are at risk of persecution by virtue of their race alone is bound to fail and that the discrimination experienced by Chinese Indonesians does not rise to the level of persecution. [...] The RSAA left open questions surrounding whether an atmosphere of insecurity is a violation of the rights to personal <b>security</b> <b>as</b> <b>guaranteed</b> by Article 9(1) of the International Covenant on Civil and Political Rights.|$|R
40|$|Security policy {{enforcement}} {{and control over}} user programs traditionally operate by guarding {{the lowest level of}} the services provided by an operating system. While arguably secure and complete, these sandboxing engines have a room for improvement. In this work, we discuss the design, implementation, performance, and ease-of-use aspects of a framework known as SecModule. This framework allows arbitrary {{policy enforcement}}s on the user’s ability to invoke protected functions held securely inside a module. In other words, SecModule allows the level of protection provided by a sandbox to the library level. SecModule gives the ability to place arbitrary policy level control over the rights to invoke arbitrarily complex functions held in libraries. An apt programming language analogy here is that existing sandboxes protect the primitive “assembly level ” of possible operations provided by an Operating System. As software grows bigger and more complex, more useful evaluations and protection strategies are made possible by raising the protective shield to arbitrary compositions of such primitives, the same way that higher level programming languages allow programmers to be more productive in comparison to coding at the lowest level. The prototype framework described herein can be used to build, use, and distribute such protected libraries. Discussions pertaining to SecModule’s system <b>security</b> <b>guarantees,</b> performance issues, <b>as</b> well as ease-of-use factors follow. ...|$|R
50|$|Bernstein {{offers a}} <b>security</b> <b>guarantee</b> for qmail and djbdns; while some claim {{there is a}} dispute over a {{reported}} potential qmail exploit, a functioning exploit targeting qmail running on 64-bit platforms has been published. Bernstein claims that the exploit does not fall within {{the parameters of the}} qmail <b>security</b> <b>guarantee.</b> In March 2009, Bernstein awarded $1000 to Matthew Dempsky for finding a security hole in djbdns.|$|R
25|$|<b>Security</b> <b>guarantees</b> for {{political}} activities, {{through the creation}} of a Comprehensive Security System. These <b>security</b> <b>guarantees</b> would be aimed at protecting those who participate in politics by respecting their human rights and dignity, preventing violence and instilling a culture of tolerance and coexistence to prevent stigmatization and persecution of political leaders. The <b>security</b> <b>guarantees,</b> including the structure of the Comprehensive Security System, were fleshed out on June 23, 2016. The Comprehensive Security System, led by a high-level body and a technical committee, would implement a protection program to protect members of the new party or movement founded by the FARC. For such purposes, a dedicated sub-unit of the National Protection Unit (which would include demobilized members of the FARC) and a security and protection body (with members of the FARC's political movement in liaison with the National Police), would be created. A National Commission of <b>Security</b> <b>Guarantees,</b> chaired by the President, would design and monitor public and criminal policies aimed at the dismantlement of any organization contravening the agreement. The <b>security</b> <b>guarantees</b> would also extend to social movements, human rights defenders, <b>Security</b> and protection <b>guarantees</b> are particularly important for the FARC, whose greatest fear is a repeat of the extermination of the Patriotic Union (UP) in the 1980s, when over one thousand members of the left-wing political party (founded in 1985 with the FARC's participation following the La Uribe ceasefire agreement in 1984) were assassinated by paramilitaries and agents of the state.|$|R
40|$|Using unique nationally {{representative}} workplace data this paper shows that unionization increased {{the probability of}} within-workplace job cuts and the incidence of job <b>security</b> <b>guarantees.</b> As theory predicts, both are more prevalent among market-sector workplaces with higher union density and multi-unionism. In the public sector, levels of unionization affect only job <b>security</b> <b>guarantees,</b> not job cuts. Explanations are developed in terms of union bargaining power and union voice services...|$|R
