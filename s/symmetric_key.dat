1147|455|Public
5|$|The <b>symmetric</b> <b>key</b> is {{randomly}} generated {{and will}} not assist other victims. At no point is the attacker's private key exposed to victims and the victim need only send a very small ciphertext (the encrypted symmetric-cipher key) to the attacker.|$|E
25|$|PGP {{can be used}} to send {{messages}} confidentially. For this, PGP combines symmetric-key encryption and public-key encryption. The message is encrypted using a symmetric encryption algorithm, which requires a <b>symmetric</b> <b>key.</b> Each <b>symmetric</b> <b>key</b> is used only once and is also called a session key. The message and its session key are sent to the receiver. The session key must be sent to the receiver so they know how to decrypt the message, but to protect it during transmission it is encrypted with the receiver's public key. Only the private key belonging to the receiver can decrypt the session key.|$|E
25|$|<b>Symmetric</b> <b>key</b> ciphers are {{implemented}} as either block ciphers or stream ciphers. A block cipher enciphers input in blocks of plaintext {{as opposed to}} individual characters, the input form used by a stream cipher.|$|E
5000|$|RSA Security {{claims that}} 1024-bit RSA keys are {{equivalent}} in strength to 80-bit <b>symmetric</b> <b>keys,</b> 2048-bit RSA <b>keys</b> to 112-bit <b>symmetric</b> <b>keys</b> and 3072-bit RSA <b>keys</b> to 128-bit <b>symmetric</b> <b>keys.</b> RSA claims that 1024-bit keys {{are likely to}} become crackable some time between 2006 and 2010 and that 2048-bit keys are sufficient until 2030. An RSA key length of 3072 bits should be used if security is required beyond 2030. NIST key management guidelines further suggest that 15360-bit RSA keys are equivalent in strength to 256-bit <b>symmetric</b> <b>keys.</b>|$|R
50|$|Strong {{random number}} {{generation}} is important throughout every phase of public key cryptography. For instance, if a weak generator {{is used for}} the <b>symmetric</b> <b>keys</b> that are being distributed by RSA, then an eavesdropper could bypass the RSA and guess the <b>symmetric</b> <b>keys</b> directly.|$|R
5000|$|Symmetric master key: A <b>symmetric</b> master <b>key</b> is used {{to derive}} other <b>symmetric</b> <b>keys</b> (e.g., data {{encryption}} keys, key wrapping keys, or authentication <b>keys)</b> using <b>symmetric</b> cryptographic methods.|$|R
25|$|In the Microsoft Windows {{family of}} {{operating}} systems EFS enables this measure, although on NTFS drives only, and does so {{using a combination}} of public key cryptography and <b>symmetric</b> <b>key</b> cryptography to make decrypting the files extremely difficult without the correct key.|$|E
25|$|In cryptography, modular {{arithmetic}} directly underpins {{public key}} {{systems such as}} RSA and Diffie–Hellman, and provides finite fields which underlie elliptic curves, and is used {{in a variety of}} <b>symmetric</b> <b>key</b> algorithms including Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), and RC4. RSA and Diffie–Hellman use modular exponentiation.|$|E
25|$|In cryptography, Camellia is a <b>symmetric</b> <b>key</b> {{block cipher}} with a block size of 128 bits and key sizes of 128, 192 and 256 bits. It was jointly {{developed}} by Mitsubishi Electric and NTT of Japan. The cipher {{has been approved}} {{for use by the}} ISO/IEC, the European Union's NESSIE project and the Japanese CRYPTREC project. The cipher has security levels and processing abilities comparable to the Advanced Encryption Standard.|$|E
5000|$|Different {{kinds of}} keys are {{compared}} {{in the document}} (e.g. RSA keys vs. EC keys). This [...] "translation table" [...] {{can be used to}} roughly equate keys of other types of algorithms with symmetric encryption algorithms. In short, 128 bit <b>symmetric</b> <b>keys</b> are said to be equivalent to 3248 bits RSA keys or 256-bit EC <b>keys.</b> <b>Symmetric</b> <b>keys</b> of 256 bits are roughly equivalent to 15424 bit RSA keys or 512 bit EC keys. Finally 2048 bit RSA keys are said to be equivalent to 103 bit <b>symmetric</b> <b>keys.</b>|$|R
40|$|Abstract. Consider a {{communication}} network where each process needs to securely exchange messages with its neighboring processes. In this network, each sent message is encrypted using one or more <b>symmetric</b> <b>keys</b> that are shared only between two processes: the process that sends the message and the neighboring process that receives the message. A straightforward scheme for assigning <b>symmetric</b> <b>keys</b> to the different processes in such a network is to assign each process O(d) keys, where d is {{the maximum number of}} neighbors of any process in the network. In this paper, we present a more efficient scheme for assigning <b>symmetric</b> <b>keys</b> to the different processes in {{a communication}} network. This scheme, which is referred to as logarithmic keying, assigns O(log d) <b>symmetric</b> <b>keys</b> to each process in the network. We show that logarithmic keying can be used in rich classes of communication networks that include star networks, acyclic networks, limited- cycle networks, and planar networks...|$|R
5000|$|Key encapsulation, an {{alternative}} to padding for public key systems used to exchange <b>symmetric</b> <b>keys</b> ...|$|R
25|$|In cryptography, {{a stream}} cipher is a <b>symmetric</b> <b>key</b> cipher where {{plaintext}} bits are {{combined with a}} pseudorandom cipher bit stream, typically by an exclusive-or (xor) operation. In a stream cipher the plaintext digits are encrypted one at a time, and the transformation of successive digits varies during the encryption. Also known as a state cipher, the stream cipher was invented in 1917 by Gilbert Sandford Vernam at Bell Labs.|$|E
25|$|During this turmoil, Zimmermann's team {{worked on}} {{a new version of}} PGP {{encryption}} called PGP 3. This new version was to have considerable security improvements, including a new certificate structure which fixed small security flaws in the PGP 2.x certificates as well as permitting a certificate to include separate keys for signing and encryption. Furthermore, the experience with patent and export problems led them to eschew patents entirely. PGP 3 introduced use of the CAST-128 (a.k.a. CAST5) <b>symmetric</b> <b>key</b> algorithm, and the DSA and ElGamal asymmetric key algorithms, all of which were unencumbered by patents.|$|E
25|$|Quantum key {{distribution}} is only {{used to produce}} and distribute a key, not to transmit any message data. This key can then be used with any chosen encryption algorithm to encrypt (and decrypt) a message, which can then be transmitted over a standard communication channel. The algorithm most commonly associated with QKD is the one-time pad, as it is provably secure when used with a secret, random key. In real-world situations, it is often also used with encryption using <b>symmetric</b> <b>key</b> algorithms like the Advanced Encryption Standard algorithm.|$|E
40|$|Consider a {{communication}} network where each process needs to securely exchange messages with its neighboring processes. In this network, each sent message is encrypted using one or more <b>symmetric</b> <b>keys</b> that are shared only between two processes: the process that sends the message and the neighboring process that receives the message. A straightforward scheme for assigning <b>symmetric</b> <b>keys</b> to the different processes in such a network is to assign each process O(d) keys, where d is {{the maximum number of}} neighbors of any process in the network. In this paper, we present a more efficient scheme for assigning <b>symmetric</b> <b>keys</b> to the different processes in {{a communication}} network. This scheme, which is referred to as logarithmic keying, assigns O(log d) <b>symmetric</b> <b>keys</b> to each process in the network. We show that logarithmic keying can be used in rich classes of communication networks that include star networks, acyclic networks, limited-cycle networks, planar networks, and dense bipartite networks. In addition, we present a construction that utilizes efficient keying schemes for general bipartite networks to construct efficient keyin...|$|R
5000|$|A secure {{distribution}} mechanism {{based on}} GDOI and the IKEv2 protocol is presented for {{the usage of}} <b>symmetric</b> <b>keys,</b> e.g. session keys.|$|R
40|$|Cryptosystem {{provides}} a cornerstone for secure information. Cryptosystems list many mechanisms on which security techniques and technologies are built. This paper demonstrates {{the generation of}} multiple <b>symmetric</b> <b>keys</b> to secure information. Preliminary studies of Newton-Raphson method, RSA algorithm, Modified Newton-Raphson method and proposed model using multiple <b>symmetric</b> <b>keys</b> are presented. It {{is well known that}} the cryptosystems convert readable data into gibberish to provide security for vital information. A cryptosystem takes a plaintext as input and produces encrypted tex...|$|R
25|$|However, other {{cryptographic}} algorithms do {{not appear}} to be broken by those algorithms. Some public-key algorithms are based on problems other than the integer factorization and discrete logarithm problems to which Shor's algorithm applies, like the McEliece cryptosystem based on a problem in coding theory. Lattice-based cryptosystems are also not known to be broken by quantum computers, and finding a polynomial time algorithm for solving the dihedral hidden subgroup problem, which would break many lattice based cryptosystems, is a well-studied open problem. It has been proven that applying Grover's algorithm to break a symmetric (secret key) algorithm by brute force requires time equal to roughly 2n/2 invocations of the underlying cryptographic algorithm, compared with roughly 2n in the classical case, meaning that <b>symmetric</b> <b>key</b> lengths are effectively halved: AES-256 would have the same security against an attack using Grover's algorithm that AES-128 has against classical brute-force search (see Key size). Quantum cryptography could potentially fulfill some of the functions of public key cryptography.|$|E
25|$|Chaos {{theory has}} been used for many years in cryptography. In the past few decades, chaos and {{nonlinear}} dynamics have been used in the design of hundreds of cryptographic primitives. These algorithms include image encryption algorithms, hash functions, secure pseudo-random number generators, stream ciphers, watermarking and steganography. The majority of these algorithms are based on uni-modal chaotic maps and a big portion of these algorithms use the control parameters and the initial condition of the chaotic maps as their keys. From a wider perspective, without loss of generality, the similarities between the chaotic maps and the cryptographic systems is the main motivation for the design of chaos based cryptographic algorithms. One type of encryption, secret key or <b>symmetric</b> <b>key,</b> relies on diffusion and confusion, which is modeled well by chaos theory. Another type of computing, DNA computing, when paired with chaos theory, offers a way to encrypt images and other information. Many of the DNA-Chaos cryptographic algorithms are proven to be either not secure, or the technique applied is suggested to be not efficient.|$|E
500|$|The {{attacker}} {{receives the}} payment, deciphers the asymmetric ciphertext with the attacker's private key, and sends the <b>symmetric</b> <b>key</b> to the victim. The victim deciphers the encrypted data with the needed <b>symmetric</b> <b>key</b> thereby completing the cryptovirology attack.|$|E
3000|$|... {{can achieve}} this through a nonce (which is a {{unpredictable}} random number). In the proposed scheme, before unicasting the <b>symmetric</b> <b>keys</b> by the gateways, sensor node [...]...|$|R
50|$|The {{cryptographic}} material {{handled by}} most HSMs are asymmetric key pairs (and certificates) used in public-key cryptography. Some HSMs can also handle <b>symmetric</b> <b>keys</b> and other arbitrary data.|$|R
3000|$|As {{a result}} of this {{registration}} process, the user obtains some <b>symmetric</b> <b>keys</b> to communicate with the vendor during the purchase process. The different messages exchanged in this process are: [...]...|$|R
500|$|To {{carry out}} the cryptoviral {{extortion}} attack, the malware generates a random <b>symmetric</b> <b>key</b> and encrypts the victim's data with it. It uses the public key in the malware to encrypt the <b>symmetric</b> <b>key.</b> This is known as hybrid encryption and it results in a small asymmetric ciphertext {{as well as the}} symmetric ciphertext of the victim's data. It zeroizes the <b>symmetric</b> <b>key</b> and the original plaintext data to prevent recovery. It puts up a message to the user that includes the asymmetric ciphertext and how to pay the ransom. The victim sends the asymmetric ciphertext and e-money to the attacker.|$|E
2500|$|EFS {{works by}} {{encrypting}} a file with a bulk <b>symmetric</b> <b>key,</b> {{also known as}} the File Encryption Key, or FEK. It uses a symmetric encryption algorithm because it takes less time to encrypt and decrypt large amounts of data than if an asymmetric key cipher is used. [...] The symmetric encryption algorithm used will vary depending on the version and configuration of the operating system; see Algorithms used by Windows version below. [...] The FEK (the <b>symmetric</b> <b>key</b> that is used to encrypt the file) is then encrypted with a public key that is associated with the user who encrypted the file, and this encrypted FEK is stored in the $EFS alternate data stream of the encrypted file. To decrypt the file, the EFS component driver uses the private key that matches the EFS digital certificate (used to encrypt the file) to decrypt the <b>symmetric</b> <b>key</b> that is stored in the $EFS stream. The EFS component driver then uses the <b>symmetric</b> <b>key</b> to decrypt the file. Because the encryption & decryption operations are performed at a layer below NTFS, it is transparent to the user and all their applications.|$|E
2500|$|Information theory {{leads us}} to believe {{it is much more}} {{difficult}} to keep secrets than it might first appear. [...] A brute force attack can break systems based on asymmetric key algorithms or on most commonly used methods of <b>symmetric</b> <b>key</b> algorithms (sometimes called secret key algorithms), such as block ciphers. [...] The security of all such methods currently comes from the assumption that no known attack can break them in a practical amount of time.|$|E
50|$|Transport Layer Security {{pre-shared key}} ciphersuites (TLS-PSK) {{is a set}} of {{cryptographic}} protocols that provide secure communication based on pre-shared keys (PSKs). These pre-shared <b>keys</b> are <b>symmetric</b> <b>keys</b> shared in advance among the communicating parties.|$|R
5000|$|Usually, Transport Layer Security (TLS) uses {{public key}} {{certificates}} or Kerberos for authentication. TLS-PSK uses <b>symmetric</b> <b>keys,</b> shared in advance among the communicating parties, {{to establish a}} TLS connection. There are several reasons to use PSKs: ...|$|R
30|$|In this paper, we {{investigate}} secure clustering of wireless sensor nodes with evaluating their survivability concurrently. To date, numerous key establishment schemes {{have been proposed}} for homogeneous WSNs incorporating <b>symmetric</b> <b>keys,</b> that is, what is mentioned in [1, 11, 14 – 17]. In these schemes, the secure connectivity {{is based on the}} probability of sharing some <b>symmetric</b> <b>keys</b> and key materials among sensor nodes. Note that these schemes not only suffer from high computation cost, communication overhead, and large memory requirements, but also there is no guarantee for secure key establishment among all sensor nodes. Moreover, due to the resource constraint nature of sensor nodes, employing asymmetric and public key cryptography in WSNs using these schemes is slow, complex, and infeasible [18].|$|R
2500|$|In the {{original}} version, the RSA algorithm {{was used to}} encrypt session keys. RSA's security depends upon the [...] one-way function nature of mathematical integer factoring. Similarly, the <b>symmetric</b> <b>key</b> algorithm used in PGP version 2 was IDEA, which might {{at some point in}} the future be found to have previously undetected cryptanalytic flaws. Specific instances of current PGP or IDEA insecurities (if they exist) are not publicly known. As current versions of PGP have added additional encryption algorithms, their cryptographic vulnerability varies with the algorithm used. However, none of the algorithms in current use are publicly known to have cryptanalytic weaknesses.|$|E
2500|$|Public-key {{algorithms}} {{are most}} often based on the computational complexity of [...] "hard" [...] problems, often from number theory. For example, the hardness of RSA {{is related to the}} integer factorization problem, while Diffie–Hellman and DSA are related to the discrete logarithm problem. More recently, elliptic curve cryptography has developed, a system in which security is based on number theoretic problems involving elliptic curves. Because of the difficulty of the underlying problems, most public-key algorithms involve operations such as modular multiplication and exponentiation, which are much more computationally expensive than the techniques used in most block ciphers, especially with typical key sizes. As a result, public-key cryptosystems are commonly hybrid cryptosystems, in which a fast high-quality symmetric-key encryption algorithm is used for the message itself, while the relevant <b>symmetric</b> <b>key</b> is sent with the message, but encrypted using a public-key algorithm. Similarly, hybrid signature schemes are often used, in which a cryptographic hash function is computed, and only the resulting hash is digitally signed.|$|E
2500|$|One {{of these}} techniques, known as secret sharing made short, {{combines}} Rabin's information dispersal algorithm (IDA) with Shamir's secret sharing. [...] Data is first encrypted with a randomly generated key, using a symmetric encryption algorithm. [...] Next this data is split into N pieces using Rabin's IDA. [...] This IDA is configured with a threshold, {{in a manner}} similar to secret sharing schemes, but unlike secret sharing schemes the size of the resulting data grows by a factor of (number of fragments / threshold). [...] For example, if the threshold were 10, and the number of IDA-produced fragments were 15, the total size of all the fragments would be (15/10) or 1.5 times the size of the original input. [...] In this case, this scheme is 10 times more efficient than if Shamir's scheme had been applied directly on the data. [...] The final step in secret sharing made short is to use Shamir secret sharing to produce shares of the randomly generated <b>symmetric</b> <b>key</b> (which is typically on the order of 16–32 bytes) and then give one share and one fragment to each shareholder.|$|E
30|$|This message {{allows the}} vendor to {{register}} his account with the broker {{as well as}} the master keys that the broker will use to provide <b>symmetric</b> <b>keys</b> to the clients in order to communicate with the vendor in a way that guarantees authentication, integrity and confidentiality.|$|R
50|$|A social VPN uses online social {{networks}} to distribute public keys and advertise node address to friends. The acquired public keys {{are used to}} establish encrypted communication between two endpoints. <b>Symmetric</b> <b>keys</b> are exchanged {{during the process of}} establishing an end-to-end link by two social VPN peers.|$|R
40|$|Abstract. In large-scale, {{wireless}} networks, it {{is possible}} to achieve confidentiality and integrity using asymmetric keys, but availability (i. e. resistance to jamming) has always required <b>symmetric</b> <b>keys.</b> Key management for these <b>symmetric</b> <b>keys</b> is becoming increasingly difficult, and in some cases physically impossible. Recently, the first algorithm was proposed to achieve availability without symmetric keys: BBC coding, which is an unkeyed coding system built up from a hash function. However, no security analysis of it has ever been published. In this paper, we prove BBC has unconditional security with high probability in the random oracle model. Furthermore, we prove BBC has unconditional security with high probability for particular families of polynomial-time and-space hash functions. Unlike the random oracle proof, the latter proof applies to systems that can actually be implemented in practice. In addition, we prove that certain families of hash functions that might naturally be considered are actually insecure, and we give methods for breaking them. Finally, we describe the open question of whether BBC is secure for certain families of simple hash functions. 1...|$|R
