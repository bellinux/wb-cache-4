4484|4140|Public
5|$|According to Russian {{psychiatrist}} Emmanuil Gushansky, psychiatry is {{the only}} medical specialty in which the doctor is given the right to violence {{for the benefit of}} the patient. The application of violence must be based on the mental health law, must be as much as possible transparent and monitored by representatives of the interests of persons who are in need of involuntary examination and treatment. While being hospitalized in a psychiatric hospital for urgent indications, the patient should be accompanied by his relatives, witnesses, or other persons authorized to control the actions of doctors and law-enforcement agencies. Otherwise, psychiatry becomes an obedient maid for administrative and governmental agencies and is deprived of its medical function. It is the police that must come to the aid of citizens and is responsible for their security. Only later, after the appropriate legal measures for social protection have been taken, the psychiatrist must respond to the queries of law enforcement and judicial authorities by solving the issues of involuntary hospitalization, sanity, etc. In Russia, all that goes by opposites. The psychiatrist is vested with punitive functions, is involved in involuntary hospitalization, the <b>state</b> <b>machine</b> hides behind his back, actually manipulating the doctor. The police are reluctant to investigate offences committed by the mentally ill. After receiving the information about their disease, the bodies of inquiry very often stop the investigation and do not bring it to the level of investigative actions. Thereby psychiatry becomes a cloak for the course of justice and, by doing so, serves as a source for the rightlessness and stigmatization of both psychiatrists and persons with mental disorders. The negative attitude to psychiatrists is thereby supported by the <b>state</b> <b>machine</b> and is accompanied by the aggression against the doctors, which increases during the periods of social unrest.|$|E
5|$|The final Computer Space design uses no {{microprocessor}} or memory; {{the entire}} computer {{system is a}} <b>state</b> <b>machine</b> made of 74-series TTL chips, with graphic elements held in diode arrays. The array designs, which Bushnell designed to let him rotate the rocket in 16 directions with only 4 arrays, are {{laid out in the}} shape of the ships, which made it obvious to game operators what would need to be replaced if something broke. The ships themselves are projected on the screen as a pattern of dots, rather than connected lines, and the monitor they are projected on is a General Electric 15-inch black and white television screen, specially modified for the game. The rudimentary artificial intelligence constructed by Bushnell has the enemy ships firing towards the quadrant of the screen that the player's rocket is in, rather than a more complicated tracking algorithm.|$|E
25|$|In {{addition}} to PBFT and UpRight, {{there is the}} BFT-SMaRt library, a high-performance Byzantine fault-tolerant <b>state</b> <b>machine</b> replication library developed in Java. This library implements a protocol very similar to PBFT's, plus complementary protocols which offer state transfer and on-the-fly reconfiguration of hosts. BFT-SMaRt is the most recent effort to implement <b>state</b> <b>machine</b> replication, still being actively maintained.|$|E
40|$|Abstract: We {{introduce}} {{the concepts of}} T-generalized <b>state</b> <b>machines</b> and coverings of products of them. Also some of algebraic properties of them are investigated. Finely some products such as direct sum and sum of T-generalized <b>state</b> <b>machines</b> are introduced. An interesting distributive property of cascade product over the sum of T-generalized <b>state</b> <b>machines</b> concern to covering of T-generalized <b>state</b> <b>machines</b> is stablished...|$|R
5000|$|The term [...] "UML state machine" [...] {{can refer}} to two kinds of state machines: {{behavioral}} <b>state</b> <b>machines</b> and protocol <b>state</b> <b>machines.</b> Behavioral <b>state</b> <b>machines</b> {{can be used to}} model the behavior of individual entities (e.g., class instances). Protocol <b>state</b> <b>machines</b> are used to express usage protocols and can be used to specify the legal usage scenarios of classifiers, interfaces, and ports.|$|R
40|$|UML <b>state</b> <b>machines</b> {{provide an}} {{operational}} {{view of the}} behavior of software systems. However, properties of the execution history of <b>state</b> <b>machines</b> cannot be expressed modularly. This often leads to model elements addressing the same concern scattered all over the machine. We present an initial approach to aspect-oriented <b>state</b> <b>machines,</b> which show considerably better modularity in designs of history dependent behavior than normal UML <b>state</b> <b>machines...</b>|$|R
25|$|A {{classifier}} is a {{generalization of}} a finite <b>state</b> <b>machine</b> that, similar to an acceptor, produces a single output on termination but {{has more than}} two terminal states.|$|E
25|$|The watch's {{firmware}} {{operating system}} {{is based on}} a FreeRTOS kernel and uses Newlib, the STM32 Peripheral Lib, the Ragel <b>state</b> <b>machine</b> compiler, and an unnamed UTF-8 Decoder.|$|E
25|$|Counter machine – {{the most}} {{primitive}} and reduced theoretical {{model of a}} computer hardware. Lacks indirect addressing. Instructions are in the finite <b>state</b> <b>machine</b> {{in the manner of}} the Harvard architecture.|$|E
40|$|Dynamic {{modeling}} of object-oriented software {{makes use of}} scenario diagrams, i. e. descriptions of particular uses of a system in terms of message flow between the objects belonging to the system. Such diagrams help the designer to specify the general behavior of objects as <b>state</b> <b>machines</b> or as collections of methods. Several techniques are discussed for building automated tool support for the dynamic modeling aspects of object-oriented software development. The discussed techniques include synthesis of <b>state</b> <b>machines</b> and method descriptions {{on the basis of}} scenario diagrams, constructing scenario diagrams with the support of existing <b>state</b> <b>machines,</b> visualizing the run-time behavior of an object system, extracting <b>state</b> <b>machines</b> of objects from running systems, consistency checking between scenario diagrams and <b>state</b> <b>machines,</b> automated simplification of <b>state</b> <b>machines</b> using OMT notation, and automated layout for <b>state</b> <b>machines.</b> 1 Introduction The basic problem of any software design [...] ...|$|R
25|$|The Unified Modeling Language has a {{notation}} {{for describing}} <b>state</b> <b>machines.</b> UML <b>state</b> <b>machines</b> overcome {{the limitations of}} traditional finite <b>state</b> <b>machines</b> while retaining their main benefits. UML <b>state</b> <b>machines</b> introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML <b>state</b> <b>machines</b> have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both {{the state of the}} system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.|$|R
30|$|In this study, ERTMS {{system is}} {{described}} {{by a set of}} <b>State</b> <b>machines</b> (that describe the behaviour of objects) and that Sequence diagrams are used to emphasize specific patterns of interactions among <b>State</b> <b>machines.</b> The proposed analysis is based on the combined use of Sequence diagrams and <b>State</b> <b>machines</b> because of the consistency between these two types of UML diagrams. For instance, components of the Sequence Diagram are those of <b>State</b> <b>machines,</b> or are a proper subset.|$|R
25|$|Random access machine (RAM) – {{a counter}} machine with {{indirect}} addressing and, usually, an augmented instruction set. Instructions {{are in the}} finite <b>state</b> <b>machine</b> {{in the manner of}} the Harvard architecture.|$|E
25|$|A nondeterministic finite {{automaton}} (NFA), or nondeterministic finite <b>state</b> <b>machine,</b> {{does not need}} to obey these restrictions. In particular, every DFA is also an NFA. Sometimes the term NFA is used in a narrower sense, referring to a NDFA that is not a DFA, but not in this article.|$|E
25|$|A (possibly infinite) set of symbol sequences, aka. formal {{language}}, {{is called}} a regular language {{if there is some}} Finite <b>State</b> <b>Machine</b> that accepts exactly that set. For example, the set of binary strings with an even number of zeroes is a regular language (cf. Fig. 5), while the set of all strings whose length is a prime number is not.|$|E
40|$|This paper {{describes}} {{a method to}} implement fault-tolerant services in distributed systems {{based on the idea}} of fused <b>state</b> <b>machines.</b> The theory of fused <b>state</b> <b>machines</b> uses a combination of coding theory and replication to ensure efficiency as well as savings in storage and messages during normal operations. Fused <b>state</b> <b>machines</b> may incur higher overhead during recovery from crash or Byzantine faults, but that may be acceptable if the probability of fault is low. Assuming n different <b>state</b> <b>machines,</b> pure replication based schemes require n (f + 1) replicas to tolerate f crash faults in a system and n(2 f + 1) replicas to tolerate f Byzantine faults. For crash faults, we give an algorithm that requires the optimal f backup <b>state</b> <b>machines</b> for tolerating f faults in the system of n machines. For Byzantine faults, we propose an algorithm that requires only n f + f additional <b>state</b> <b>machines,</b> as opposed to 2 n f <b>state</b> <b>machines.</b> Our algorithm combines ideas from coding theory with replication to provide low overhead during normal operation while keeping the number of copies required to tolerate f faults small. Implementing Fault-Tolerant Services Using <b>State</b> <b>Machines...</b>|$|R
40|$|Abstract. Hierarchical <b>state</b> <b>machines</b> are nite <b>state</b> <b>machines</b> whose <b>states</b> {{themselves}} can be other machines. In {{spite of their}} popularity in many modeling tools for software design, very little is known concer-ning their complexity and expressiveness. In this paper, we study these questions for hierarchical <b>state</b> <b>machines</b> {{as well as for}} communicating hierarchical <b>state</b> <b>machines,</b> that is, nite <b>state</b> <b>machines</b> extended with both hierarchy and concurrency. We present a comprehensive set of re-sults characterizing (1) the complexity of the reachability, emptiness and universality problems, (2) the complexity of the language inclusion and equivalence problems, and (3) the succinctness relationships between dif-ferent types of machines. ...|$|R
40|$|Software {{specification}} {{and implementation}} techniques based on <b>state</b> <b>machines</b> simplify design, coding, and validation. However, large systems require complex <b>state</b> <b>machines.</b> Incremental construction techniques can control this complexity. In this paper, {{we present a}} construction technique that permits derivation of complex <b>state</b> <b>machines</b> from simpler <b>state</b> <b>machines.</b> The technique uses subclassing, composition, delegation, and genericity to incrementally modify and combine simpler machines. In addition, we present a novel implementation technique that uses exactly one table-lookup and one addition to dispatch events on derived <b>state</b> <b>machines,</b> no matter {{the depth of the}} derivation. As an example, we describe the derivation of a complicated distributed virtual memory scheme from a simple paging virtual memory scheme. 1 Introduction Many designers advocate the use of <b>state</b> <b>machines</b> to specify and implement software systems. For example, reactive system designs [10] and object-oriented anal [...] ...|$|R
25|$|A finite <b>state</b> <b>machine</b> {{can be used}} as a {{representation}} of a Markov chain. Assuming a sequence of independent and identically distributed input signals (for example, symbols from a binary alphabet chosen by coin tosses), if the machine is in state y at time n, then the probability that it moves to state x at time n+1 depends only on the current state.|$|E
25|$|With the {{addition}} of valid transitions between individual classes of a classification, classifications {{can be interpreted as}} a <b>state</b> <b>machine,</b> and therefore the whole classification tree as a Statechart. This defines an allowed order of class usages in test steps and allows to automatically create test sequences. Different coverage levels are available, such as state coverage, transitions coverage and coverage of state pairs and transition pairs.|$|E
25|$|However, {{with only}} 4 registers, this machine has not nearly {{big enough to}} build a RASP that can execute the {{multiply}} algorithm as a program. No matter how big we build our finite <b>state</b> <b>machine</b> {{there will always be}} a program (including its parameters) which is larger. So by definition the bounded program machine that does not use unbounded encoding tricks such as Gödel numbers cannot be universal.|$|E
40|$|Hierarchical <b>state</b> <b>machines</b> are finite <b>state</b> <b>machines</b> whose <b>states</b> {{themselves}} can be other machines. In {{spite of their}} popularity in many modeling tools for software design, very little is known concerning their complexity and expressiveness. In this paper, we study these questions for hierarchical <b>state</b> <b>machines</b> {{as well as for}} communicating hierarchical <b>state</b> <b>machines,</b> that is, finite <b>state</b> <b>machines</b> extended with both hierarchy and concurrency. We present a comprehensive set of results characterizing (1) the complexity of the reachability, emptiness and universality problems, (2) the complexity of the language inclusion and equivalence problems, and (3) the succinctness relationships between different types of machines. 1 Introduction Finite <b>state</b> <b>machines</b> (FSMs) are widely used in the modeling of systems in various areas. Descriptions using FSMs are useful to represent the flow of control (as opposed to data manipulation) and are amenable to formal analysis such as model checking [...] ...|$|R
5000|$|In an MSC, the {{vertical}} lines are autonomous execution entities. They usually represent <b>state</b> <b>machines</b> executing in parallel. The <b>state</b> <b>machines</b> {{need not be}} on the same computer.|$|R
40|$|In {{this paper}} the finite <b>state</b> <b>machines</b> are defined and formalized. There are {{presented}} the collaborative banking systems and their correspondence {{is done with}} finite <b>state</b> <b>machines.</b> It highlights the role of finite <b>state</b> <b>machines</b> in the complexity analysis and performs operations on very large virtual databases as finite <b>state</b> <b>machines.</b> It builds the state diagram and presents the commands and documents transition between the collaborative systems states. The paper analyzes the data sets from Collaborative Multicash Servicedesk application and performs a combined analysis {{in order to determine}} certain statistics. Indicators ar...|$|R
25|$|There {{are also}} hardware-level differences. Some chips combine MOSI and MISO {{into a single}} data line (SI/SO); this is {{sometimes}} called 'three-wire' signaling (in contrast to normal 'four-wire' SPI). Another variation of SPI removes the chip select line, managing protocol <b>state</b> <b>machine</b> entry/exit using other methods. Anyone needing an external connector for SPI defines their own: UEXT, JTAG connector, Secure Digital card socket, etc. Signal levels depend entirely on the chips involved.|$|E
25|$|Although {{this meant}} fewer clock cycles per instruction, {{compared}} to the Z80 for instance, the latter's higher resolution <b>state</b> <b>machine</b> allowed clock frequencies 3-5 times as high without demanding faster memory chips, which was often the limiting factor. This is because the Z80 combines two full (but short) clock cycles into a relatively long memory access period {{compared to the}} clock, while the more asynchronous 6809 instead has relatively short memory access times: depending on version and speed grade, approximately 60% of a single clock cycle was typically available for memory access in a 6809 (see data sheets).|$|E
25|$|Modern {{readers are}} more often {{introduced}} to Orwell as a novelist, particularly through his enormously successful titles Animal Farm and Nineteen Eighty-Four. The former is often thought to reflect degeneration in the Soviet Union after the Russian Revolution {{and the rise of}} Stalinism; the latter, life under totalitarian rule. Nineteen Eighty-Four is often compared to Brave New World by Aldous Huxley; both are powerful dystopian novels warning of a future world where the <b>state</b> <b>machine</b> exerts complete control over social life. In 1984, Nineteen Eighty-Four and Ray Bradbury's Fahrenheit 451 were honoured with the Prometheus Award for their contributions to dystopian literature. In 2011 he received it again for Animal Farm.|$|E
40|$|The {{subject of}} this master thesis are <b>state</b> <b>machines</b> and their testing. To this purpose, an {{application}} is described, which is able to test these <b>state</b> <b>machines</b> autonomously. Application have two parts, first generator and editor of data is built and second part is testing procedure, which is able to test <b>state</b> <b>machines</b> in question and to give corresponding test report...|$|R
40|$|We {{present a}} method for the modular {{specification}} and abstract implementation of distributed systems {{as well as for}} proving their safety and liveness properties. We represent systems by data flow nets. These systems consist of encapsulated subsystems called components cooperating by asynchronous message passing. The components of such nets are data flow nodes. Their black box behavior is specified by relational specifications. Relational specifications describe relations, called history relations, on the communication histories of the input/output channels. <b>State</b> <b>machines</b> are described by state transition rules with input and output. <b>State</b> <b>machines</b> implement systems. History relations are an abstraction of <b>state</b> <b>machines.</b> <b>State</b> <b>machines</b> provide implementations of history relations. Safety properties are captured by logical formulas called system invariants. We work with such invariants to prove safety properties about <b>state</b> <b>machines.</b> Liveness properties of <b>state</b> <b>machines</b> are represented by formulas of linear time temporal logic. This way we provide a methodological bridge from state-based system models defined by state transitions to the more abstract history-based models. ...|$|R
40|$|The control {{software}} of the CERN Compact Muon Solenoid experiment contains over 27 500 finite <b>state</b> <b>machines.</b> These <b>state</b> <b>machines</b> are organised hierarchically: commands {{are sent}} down the hierarchy and state changes are sent upwards. The {{sheer size of}} the system makes it virtually impossible to fully understand the details of its behaviour at the macro level. This is fuelled by unclarities that already exist at the micro level. We have solved the latter problem by formally describing the finite <b>state</b> <b>machines</b> in the mCRL 2 process algebra. The translation has been implemented using the ASF+SDF meta-environment, and its correctness was assessed by means of simulations and visualisations of individual finite <b>state</b> <b>machines</b> and through formal verification of subsystems of the control software. Based on the formalised semantics of the finite <b>state</b> <b>machines,</b> we have developed dedicated tooling for checking properties that can be verified on finite <b>state</b> <b>machines</b> in isolation. © 2012 Elsevier B. V. All rights reserved...|$|R
25|$|In {{the early}} 1980s, Evans & Sutherland (E) {{decoupled}} their PS300 graphics processor/display, which contained its own display information transformable through a dataflow architecture. Complex graphical objects could be downloaded over a serial line (e.g. 9600, 56K baud) or Ethernet interface and then manipulated without {{impact on the}} host. The architecture was excellent for high performance display but very inconvenient for domain-specific calculations, such as electron-density fitting and energy calculations. Many crystallographers and modellers spent arduous months trying to fit such activities into this architecture. E designed a card for the PS-300 which had several calculation algorithms using a 100 bit wide finite <b>state</b> <b>machine</b> {{in an attempt to}} simplify this process but it was so difficult to program that it quickly became obsolete.|$|E
500|$|The adder is {{designed}} to overflow when {{the sum of the}} absolute value of its operands exceeds its capacity (2N−1). The overflow bit is discarded so the output word width is always equal to its input word width. The remainder , called the residual, is stored in the register and the cycle repeats, starting this time from [...] (see figure 2). Since a phase accumulator is a finite <b>state</b> <b>machine,</b> eventually the residual at some sample K must return to the initial value [...] The interval K {{is referred to as the}} grand repetition rate (GRR) given by ...|$|E
500|$|The {{assumptions}} {{underlying the}} nativist view {{have also been}} criticised in Jeffrey Elman's Rethinking Innateness: A Connectionist Perspective on Development, which defends the connectionist approach that Pinker attacked. In his 1996 book Impossible Minds, the machine intelligence researcher Igor Aleksander calls The Language Instinct excellent, and argues that Pinker presents a relatively soft claim for innatism, accompanied by a strong dislike of the 'Standard Social Sciences Model' or SSSM (Pinker's term), which supposes that development is purely dependent on culture. Further, Aleksander writes that while Pinker criticises some attempts to explain language processing with neural nets, Pinker later makes use of a neural net to create past tense verb forms correctly. Aleksander concludes that while he doesn't support the SSSM, [...] "a cultural repository of language just seems the easy trick for an efficient evolutionary system armed with an iconic <b>state</b> <b>machine</b> to play." ...|$|E
40|$|Abstract—This paper {{describes}} {{a method to}} implement faulttolerant services in distributed systems {{based on the idea}} of fused <b>state</b> <b>machines.</b> The theory of fused <b>state</b> <b>machines</b> uses a combination of coding theory and replication to ensure efficiency as well as savings in power and storage during normal operations. Fused <b>state</b> <b>machines</b> may incur higher overhead during recovery from crash or Byzantine faults, but that may be acceptable if the probability of fault is low. Assuming k different <b>state</b> <b>machines,</b> pure replication based schemes require k(f + 1) replicas to tolerate f crash faults in a system and k(2 f + 1) replicas to tolerate f Byzantine faults. For crash faults, we give an algorithm that requires the optimal f backup <b>state</b> <b>machines</b> for tolerating f faults in the system of k machines. For Byzantine faults, we propose an algorithm that requires only kf + f additional <b>state</b> <b>machines,</b> as opposed to 2 kf <b>state</b> <b>machines.</b> Our algorithm combines ideas from coding theory with replication to provide low overhead during normal operation while keeping the number of copies required to tolerate f faults small. I...|$|R
40|$|Abstract. We {{study the}} {{semantics}} and refinement of mobile objects, considering {{an extension of}} core UML <b>state</b> <b>machines</b> by primitives that designate the location of objects and their moves within a network. Our contribution is twofold: first, we formalize the semantics of <b>state</b> <b>machines</b> in MTLA, an extension of Lamport’s Temporal Logic of Actions with spatial modalities. Second, we study refinement concepts for <b>state</b> <b>machines</b> that are semantically justified in MTLA. ...|$|R
40|$|A new {{methodology}} {{to teach}} about the topic of Finite <b>State</b> <b>Machines</b> is presented in this paper. For this purpose, nine learning objectives which are classified into the three categories Basics of Finite <b>State</b> <b>Machines,</b> parallels between Finite <b>State</b> <b>Machines</b> and stock trading, {{and the application of}} Finite <b>State</b> <b>Machines</b> were developed and implemented into a Serious Game solution. This paper covers the third category about the application of Finite <b>State</b> <b>Machines</b> and its use to create Artificial Intelligence. The learning objectives were determined by using the widely-known Taxonomy of Bloom and integrated into the Serious Game The Finite State Trading Game (FSTG). In this turn-based trading game, the user aims to beat a Non-Player Character by skillfully trading shares while the user faces increasing complexity throughout the game. For the evaluation of the Serious Game approach a pre-test and post-test setting was performed with students of a local upper vocational school class at the Technical University of Munich. The results of the following analysis demonstrated significant progress in terms of the students’ knowledge about Finite <b>State</b> <b>Machines</b> for every tested statement...|$|R
