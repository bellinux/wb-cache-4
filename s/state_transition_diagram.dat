139|10000|Public
5000|$|To {{illustrate}} the check-out/check-in synchronization model, this section contains {{an example of}} how this process works. The figure below contains a <b>state</b> <b>transition</b> <b>diagram</b> of a CI.|$|E
50|$|Given that PLCs usually {{control systems}} which are easily {{represented}} by a <b>state</b> <b>transition</b> <b>diagram,</b> {{the use of a}} very high-level programming language such as state logic greatly helps the PLC programmer in making intuitive control programs.|$|E
50|$|A state {{logic control}} system uses a <b>state</b> <b>transition</b> <b>diagram</b> {{as a model}} of reality, thus using the {{fundamentals}} of finite-state machine theory as the basis of a programming language. State logic enables users to model the application they are trying to control by using a hierarchy that consists of Tasks, subdivided by States which are described by Statements.|$|E
50|$|Mills Mess <b>State</b> <b>Transition</b> <b>Diagrams</b> - Mills Mess is {{a popular}} pattern in which the arms cross and uncross. Mills Mess <b>State</b> <b>Transition</b> <b>Diagrams</b> {{can be used to}} track these basic arm movements.|$|R
50|$|Behavioral {{perspective}} gives {{a description}} of system dynamics. The main concepts in behavioral perspective are <b>states</b> and <b>transitions</b> between <b>states.</b> <b>State</b> <b>transitions</b> are triggered by events. <b>State</b> <b>Transition</b> <b>Diagrams</b> (STD/STM), <b>State</b> charts and Petri-nets are some examples of well-known behaviorally oriented modeling languages. Different types of <b>State</b> <b>Transition</b> <b>Diagrams</b> are used particularly within real-time systems and telecommunications systems.|$|R
50|$|<b>State</b> <b>transition</b> {{modeling}} {{makes use}} of <b>state</b> <b>transition</b> <b>diagrams</b> to describe system behavior. These <b>state</b> <b>transition</b> <b>diagrams</b> use distinct <b>states</b> to define system behavior and changes. Most current modeling tools contain some kind of ability to represent <b>state</b> <b>transition</b> modeling. The use of <b>state</b> <b>transition</b> models can be most easily recognized as logic state diagrams and directed graphs for finite-state machines.|$|R
50|$|Organize {{workshop}} {{activities and}} exercises: The facilitator must design workshop exercises and activities to provide interim deliverables that build towards the final {{output of the}} workshop. The pre-workshop activities help design those workshop exercises. For example, for a Business Area Analysis, what's in it? A decomposition diagram? A high-level entity-relationship diagram? A normalized data model? A <b>state</b> <b>transition</b> <b>diagram?</b> A dependency diagram? All of the above? None of the above? It is important to define the level of technical diagramming that is appropriate to the environment. The {{most important thing about}} a diagram is that it must be understood by the users. Once the diagram choice is made, the facilitator designs exercises into the workshop agenda to get the group to develop those diagrams. A workshop combines exercises that are serially oriented to build on one another, and parallel exercises, with each sub-team working on a piece of the problem or working on the same thing for a different functional area. High-intensity exercises led by the facilitator energize the group and direct it towards a specific goal. Low-intensity exercises allow for detailed discussions before decisions. The discussions can involve the total group or teams can work out the issues and present a limited number of suggestions for the whole group to consider. To integrate the participants, the facilitator can match people with similar expertise from different departments. To help participants learn from each other, the facilitator can mix the expertise. It's up to the facilitator to mix and match the sub-team members to accomplish the organizational, cultural, and political objectives of the workshop. A workshop operates on both the technical level and the political level. It is the facilitator's job to build consensus and communications, to force issues out early in the process. There is no need to worry about the technical implementation of a system if the underlying business issues cannot be resolved.|$|E
50|$|An {{empirical}} {{strength of}} sequence analysis is {{its emphasis on}} methods for visualizing otherwise seemingly overly complex social phenomena. A variety of visual aids - especially graphs and network diagrams - {{make it easier to}} detect sequence patterns. One visual aid, known as a transition plot, replace the numbers in the cells of a transition matrix with a visual symbol that reflects the magnitude of the relationship between two given states or phenomena. In this kind of graph, the symbols size or shape varies with the corresponding transition probabilities. Transitions that occur within a set of sequences can also be depicted using a network-like diagram called a <b>state</b> <b>transition</b> <b>diagram,</b> which displays elements as nodes in a network. This way, relationships between elements can be emphasized using graphical aids, such as by adjusting the thickness of lines between states. Transition plots and state transition diagrams are useful for depicting patterns of first-order (Markovian) transitions. They do not provide information about when transitions occur or overall sequence patterns. One visual aid that is useful in both of these respects is the sequence index plot, an example of which is provided {{on the right side of}} this page. This kind of graph displays every sequence in the sample. The y-axis includes all of the observations, stacked on top of each other. The x-axis depicts the sequence positions in order. The observations in the sequence index plot are arranged such that cases with the same sequence order are grouped adjacent to each other on the y-axis. A similar graph, called the state distribution graph, can be used to simplify the patterns that are latent in sequence index plots. Like sequence index plots, state distribution graphs array sequence positions in order along the x-axis. The main difference is that the y-axis contains not individual cases, but the prevalence of each element at each position on the x-axis. A special type of state distribution graph is the tempogram, which is designed specifically for temporally ordered sequence data. Finally, sequences are often depicted as networks, in which multiple subjects’ sequences are shown to intersect with each other art specific events or instances. This approach is most common in analyses of sequence networks, especially narrative networks.|$|E
40|$|Abstract. In this paper, we {{consider}} incremental development of state transition diagrams by adding features, which add new states and transitions. The {{goal is to}} capture when properties of a <b>state</b> <b>transition</b> <b>diagram</b> are preserved when adding a feature. We classify several typical cases of such <b>state</b> <b>transition</b> <b>diagram</b> extensions and show when commonly used properties are preserved. In some cases, we add restrictions to the input events. In others, we need to transform properties to account for new failure cases. Properties are specified on the externally visible input and output events. To formalize the properties and to reason about internal <b>state</b> <b>transition</b> <b>diagram</b> extensions we use a computation tree logic with states and events. ...|$|E
40|$|In this paper, {{we present}} a general concept of <b>state</b> <b>transition</b> <b>diagrams</b> well-suited for various {{modeling}} purposes. Our notation is tailored for the description of asynchronous time-independent agents. We start by proposing a graphical and textual syntax, and define an abstract syntax for both notations. The semantics of <b>state</b> <b>transition</b> <b>diagrams</b> defined by translating the abstract syntax into timed port automata and to timed input/output relations on streams. To make the graphical notation practical, we partition the (possibly infinite) state space of the <b>state</b> <b>transition</b> <b>diagrams</b> with <b>state</b> predicates and define transitions with pre- and post-conditions...|$|R
5000|$|... the {{definition}} of the actions taken at each entity, defined by the <b>state</b> <b>transition</b> <b>diagrams.</b>|$|R
40|$|Summary. <b>State</b> <b>transition</b> <b>diagrams</b> are {{a graphic}} {{notation}} {{that has long}} been used to represent computing systems. Two basic models of <b>state</b> <b>transition</b> <b>diagrams</b> were introduced simultaneously by G. H. Mealy and E. F. Moore in the mid fifties, and have {{played a major role in}} hardware design for a long time. These basic models have been expanded significantly in the recent past to include such features as the ability to represent hierarchy, timing and communication, and have been used to model complex software systems. In this section, we discuss the original models of <b>state</b> <b>transition</b> <b>diagrams,</b> their semantic definition and their extensions; then we discuss current application domains and support tools. 1...|$|R
3000|$|... [...]. The <b>state</b> <b>transition</b> <b>diagram</b> of the Markov chain model {{shown in}} Figure 3 has the {{following}} transition probabilities: [...]...|$|E
40|$|Producing {{reliable}} {{computer programs}} {{is a difficult}} and expensive task, and the constant demand {{for more and more}} complex systems does not make the task easier. In this thesis we present some program verification tools and techniques which can improve the situation. We introduce a testing technique, where the idea is to first run the system with some test data, thereby creating traces of events and states. Then, using an abstraction function specified by the user, an abstract <b>state</b> <b>transition</b> <b>diagram</b> of the system is automatically generated from the traces. We have created a special language for expressing the abstraction functions. The abstract <b>state</b> <b>transition</b> <b>diagram</b> can be nicely visualized and thus greatly helps in debugging the system. Lastly, formal requirements of the system specified in temporal logic can be checked automatically for the abstract <b>state</b> <b>transition</b> <b>diagram.</b> We present a new implementation of a leader election algorithm used in the generic leader behavior known as gen leader. The new implementation is base...|$|E
30|$|Cellular automata (Christos and Lafortune 2008) are grids of cells, each {{of which}} has a <b>state</b> <b>transition</b> <b>diagram.</b> Uniform {{cellular}} automata have a single <b>state</b> <b>transition</b> <b>diagram</b> for every cell. Non-uniform cellular automata can have state transition diagrams that vary by cell. Brown et al. (2005) discuss cellular automata in relation to spatial agent-based modeling. They observe that cellular automata tend to yield Eulerian (i.e., field-oriented) models versus Langrangian (i.e., individual-oriented) representations. Here we conclude that this limits cellular automata as a foundation for proving properties about agent-based models, since many are domains are naturally Langrangian.|$|E
5000|$|Structured Analysis (SA) editors for {{entity-relationship}} diagrams, {{data and}} event flow <b>diagrams,</b> <b>state</b> <b>transition</b> <b>diagrams,</b> function refinement trees, transaction-use tables and function-entity type tables.|$|R
40|$|Abstract. Traditional {{resources}} in scheduling are simple machines where a capacity {{is the main}} restriction. However, in practice there frequently appear resources with more complex behaviour that is described using <b>state</b> <b>transition</b> <b>diagrams.</b> This paper presents new filtering rules for constraints modelling the <b>state</b> <b>transition</b> <b>diagrams.</b> These rules {{are based on the}} idea of extending traditional precedence graphs by direct precedence relations. The proposed model also assumes optional activities and it can be used as an open model accepting new activities during the solving process. ...|$|R
40|$|One {{dimensional}} binary valued cylindrical cellular automata can {{be represented}} as polynomials in roots of unity. Doing so allows several advantages over the more conventional representation as dipolynomials and connects directly with representation as circulant matrices. In addition, this allows easy classification of these cellular automata into equivalence classes based on permutations of eigenvalues of the associated circulant matrix. We show that these permutations also preserve <b>state</b> <b>transition</b> <b>diagrams,</b> connecting with recent more general work on rules with isomorphic <b>state</b> <b>transition</b> <b>diagrams.</b> Academic & Professional Development Fund (A&PDF...|$|R
40|$|Finite State Machine is used {{to model}} the {{requirement}} specification of the system by formal description languages. In this paper, I have presented a approach which {{is used to}} represent the requirement specification and automatically generate all possible test cases which should be executed to test that particular system [5]. Requirement specification are represented using extended finte state machine which uses the <b>state</b> <b>transition</b> <b>diagram</b> that shows how system changes states and action and variable used during each transition. Based on information given in the <b>state</b> <b>transition</b> <b>diagram,</b> all possible test cases are generating by traversing the graph using Depth First Search...|$|E
40|$|We {{present a}} semi-formal {{analysis}} method for fault-tolerant distributed algorithms {{written in the}} distributed functional programming language Erlang. In this setting, standard model checking techniques are often too expensive or too limiting, whereas testing techniques often do not cover enough of the state space. Our idea is to first run instances of the algorithm on generated stimuli, thereby creating traces of events and states. Then, using an abstraction function specified by the user, our tool generates from these traces an abstract <b>state</b> <b>transition</b> <b>diagram</b> of the system, which can be nicely visualized and thus greatly helps in debugging the system. Lastly, formal requirements of the system specified in temporal logic can be checked automatically to hold for the generated abstract <b>state</b> <b>transition</b> <b>diagram.</b> Because the <b>state</b> <b>transition</b> <b>diagram</b> is abstract, {{we know that the}} checked requirements hold for a lot more traces than just the traces we actually ran. We have applied our method to a commonly used open-source fault-tolerant leader election algorithm, and discovered two serious bugs. We have also implemented a new algorithm that does not have these bugs...|$|E
30|$|Step 3 : (Building {{the system}} {{dynamics}} simulation model). In this step, the <b>state</b> <b>transition</b> <b>diagram</b> {{of the system}} will be converted into equivalent MSD model. The resulting model is called as system dynamics model.|$|E
40|$|In this paper, {{the optimal}} control {{problem of a}} {{probabilistic}} Boolean network (PBN), {{which is one of}} the significant models in gene regulatory networks, is discussed. In the existing methods of optimal control for PBNs, it is necessary to compute <b>state</b> <b>transition</b> <b>diagrams</b> with 2 ^n nodes for a given PBN with n states. To avoid this computation, a polynomial optimization approach is proposed. In the proposed method, a PBN is transformed into a polynomial system, and the optimal control problem is reduced to a polynomial optimization problem. Since <b>state</b> <b>transition</b> <b>diagrams</b> are not computed, the proposed method is convenient for users...|$|R
40|$|This paper {{introduces}} a graphical notation called algebraic <b>state</b> <b>transition</b> <b>diagrams</b> (ASTD), {{which allows for}} the combination of <b>state</b> <b>transition</b> <b>diagrams</b> using classical process algebra operators like sequence, iteration, parallel composition, quantified choice and quantified synchronization. It is inspired from automata, statecharts and process algebras. Hence, it combines the strength of all these notations: graphical representation, hierarchy, orthogonality, compositionality, abstraction. Quantification {{is one of the}} salient features of ASTDs, because it provides a powerful mechanism for modeling an arbitrary number of instances of an ASTD. A formal operational semantics is given. Our target application domain is the specification of information systems, but ASTDs are presented in a generic manner...|$|R
50|$|These {{are also}} called <b>State</b> <b>Transition</b> <b>Diagrams.</b> They define the {{behaviour}} of the system. They are usually modelled {{in the initial}} stages. There are 2 main states- initial and final <b>state.</b> The <b>transition</b> from one <b>state</b> to another is based on conditions/actions. The behavioural diagram is further refined to details.|$|R
40|$|Abstract:- Finite State Machine is used {{to model}} the {{requirement}} specification of the system by formal description languages. In this paper, I have presented a approach which {{is used to}} represent the requirement specification and automatically generate all possible test cases which should be executed to test that particular system [5]. Requirement specification are represented using extended finte state machine which uses the <b>state</b> <b>transition</b> <b>diagram</b> that shows how system changes states and action and variable used during each transition. Based on information given in the <b>state</b> <b>transition</b> <b>diagram,</b> all possible test cases are generating by traversing the graph using Depth First Search. KEYWORDS:- Regression testing, extended finite state machine...|$|E
30|$|Call {{duration}} Tcall is exponentially distributed {{with a mean}} of 1 /μ, where μ is {{the average}} call completion rate. Hence, the call completion (termination) probability Pterm = P (Tcall ≤ Tth), where Tth is the time unit for the user <b>state</b> <b>transition</b> <b>diagram,</b> as shown in Figure 5.|$|E
40|$|We {{consider}} transformations between attractor basins of binary cylindrical cellular automata {{resulting from}} mutations. A t-point mutation {{of a state}} consists in toggling t sites in that state. Results of such mutations are described by a rule-dependent probability matrix. The structure of this matrix is studied {{in relation to the}} structure of the <b>state</b> <b>transition</b> <b>diagram</b> and several theorems relating these are proved for the case of additive rules. It is shown that the steady state of the Markov process defined by the probability matrix is always the uniform distribution over the <b>state</b> <b>transition</b> <b>diagram.</b> Some results on eigenvalues are also obtained. Comment: 42 pages, 3 figures. Requires AMSmath and elsart. cls. Submitted for publication in the special issue of Theoretical Computer Science on the Theoretical Aspects of Cellular Automat...|$|E
50|$|In 1967 at Ericsson, Jacobson {{proposed}} {{the use of}} software components in {{the new generation of}} software controlled telephone switches Ericsson was developing. In doing this he invented sequence diagrams, and developed collaboration diagrams. He also used <b>state</b> <b>transition</b> <b>diagrams</b> to describe the message flows between components.|$|R
30|$|Systems S 1 and S 2 {{have been}} {{formulated}} {{by following the}} mnemonic rule discussed {{in the work of}} (Gupta et al. [2005 a], [b]) using <b>transition</b> <b>diagrams.</b> The resulting Chapman-Kolmogorov first-order differential-difference equations for both systems under probabilistic considerations of each state discussed in <b>state</b> <b>transition</b> <b>diagrams</b> (Figures  2 and 3) are obtained as shown in the succeeding sections.|$|R
40|$|This paper {{presents}} {{a new approach}} to representing and detecting computer penetrations in real-time. The approach, called <b>state</b> <b>transition</b> analysis, models penetrations as a series of state changes that lead from an initial secure state to a target compromised <b>state.</b> <b>State</b> <b>transition</b> <b>diagrams,</b> the graphical representation of penetrations, identify precisely the requirements for and the compromise of a penetration and present only the critical events that must occur for the successful completion of the penetration. <b>State</b> <b>transition</b> <b>diagrams</b> are written to correspond to the states of an actual computer system, and these diagrams form the basis of a rule-based expert system for detecting penetrations, called the <b>State</b> <b>Transition</b> Analysis Tool (STAT). The design and implementation of a UNIX-specific prototype of this expert system, called USTAT, is also presented. This prototype provides a further illustration of the overall design and functionality of this intrusion detection approach. La [...] ...|$|R
40|$|We {{present a}} {{tractable}} method for synthesizing arbitrarily large concurrent programs from specifications expressed in temporal logic. Our method does not explicitly construct the global <b>state</b> <b>transition</b> <b>diagram</b> {{of the program}} to be synthesized, and thereby avoids state explosion. Instead, it constructs a <b>state</b> <b>transition</b> <b>diagram</b> for each pair of component processes (of the program) that interact. This "pairprogram " embodies all possible interactions of the two processes. Our method proceeds in two steps. First, we construct a pair-program for every pair of "connected" processes, and analyze these pair-programs for desired correctness properties. We then take the "pair processes" of the pair-programs, and "compose" them {{in a certain way}} to synthesize the large concurrent program. We establish a "large model" theorem which shows that the synthesized large program inherits correctness properties from the pair-programs. 1 Introduction We exhibit a method of automatically synthesizing [...] ...|$|E
40|$|This paper proposes several {{algorithms}} {{and their}} Cellular Automata Machine (CAM) for drawing the <b>State</b> <b>Transition</b> <b>Diagram</b> (STD) of an arbitrary Cellular Automata (CA) Rule (any neighborhood, uniform/ hybrid and null/ periodic boundary) {{and length of}} the CA n. It also discusses the novelty, hardware cost and the complexities of these algorithms. Comment: 21 pages, 11 figures and 6 table...|$|E
40|$|Abstract. The {{declarative}} language STR (State Transition Rule) is proposed to describe service specifications and programs. Given that telecommunication service specifications {{can be represented}} {{in the form of}} a <b>state</b> <b>transition</b> <b>diagram,</b> STR describes conditions for state transitions {{in the form of a}} production rule. STR specifications, description examples, categories of feature interactions, examples of feature interactions, interaction detection method, and application to Active Networks are described...|$|E
40|$|The statechart formalism, {{proposed}} by Harel [6] {{as an extension}} of conventional fi-nite state machines, is a visual language for specifying reactive systems. It addresses the state explosion problem of <b>state</b> <b>transition</b> <b>diagrams</b> when modeling systems with parallel threads of control by introducing the concepts of hierarchy, concurrency, an...|$|R
50|$|Prosa Structured Analysis Tool is {{a visual}} systems and {{software}} development environment which supports industry standard SA/SD/RT structured analysis and design with real-time extensions modeling method. Prosa supports data flow <b>diagrams,</b> <b>state</b> <b>transition</b> <b>diagrams</b> and entity relationship diagrams using Chen's and Bachmans ER notations. Prosa has integrated data dictionary.|$|R
5000|$|There {{are many}} {{different}} ways to measure {{the performance of a}} network, as each network is different in nature and design. Performance can also be modeled and simulated instead of measured; one example of this is using <b>state</b> <b>transition</b> <b>diagrams</b> to model queuing performance or to use a Network Simulator ...|$|R
