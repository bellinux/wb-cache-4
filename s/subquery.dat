105|220|Public
500|$|... {{produces}} no rows because IN is {{translates to}} an iterated version of equality over the argument set and 1<>NULL is Unknown, {{just as a}} 1=NULL is Unknown. (The CAST in this example is needed only in some SQL implementations like PostgreSQL, which would reject it with a type checking error otherwise. In many systems plain SELECT NULL works in the <b>subquery.)</b> The missing case above is of course: ...|$|E
50|$|In a SQL {{database}} query, a correlated <b>subquery</b> (also {{known as}} a synchronized <b>subquery)</b> is a <b>subquery</b> (a query nested inside another query) that uses values from the outer query. Because the <b>subquery</b> may be evaluated once for each row processed by the outer query, it can be inefficient.|$|E
50|$|A <b>subquery</b> can use {{values from}} the outer query, in which case it {{is known as a}} {{correlated}} <b>subquery.</b>|$|E
40|$|One of {{the most}} {{powerful}} features of SQL is the use of nested queries. Most research work on the optimization of nested queries focuses on aggregate <b>subqueries.</b> However, the solutions proposed for non-aggregate <b>subqueries</b> are still limited, especially for queries having multiple <b>subqueries</b> and null values. In this paper, we show that existing approaches to queries containing non-aggregate <b>subqueries</b> proposed in the literature (including rewrites) are not adequate. We then propose a new efficient approach, the nested relational approach, based on the nested relational algebra. Our approach directly unnests non-aggregate <b>subqueries</b> using hash joins, and treats all <b>subqueries</b> in a uniform manner, being able to deal with nested queries of any type and any level. We report on experimental work that confirms that existing approaches have difficulties dealing with non-aggregate <b>subqueries,</b> and that our approach offers better performance. We also discuss some possibilities for algebraic optimization and the issue of integrating our approach in a relational database system. 1...|$|R
50|$|The {{effect of}} {{correlated}} <b>subqueries</b> can {{in some cases}} be obtained using joins. For example, the queries above (which use inefficient correlated <b>subqueries)</b> may be rewritten as follows.|$|R
40|$|The {{issue of}} <b>subqueries</b> in SPARQL has {{appeared}} in different papers as an extension point to the original SPARQL query language. Particularly, nested CONSTRUCT in FROM clauses are a feature that has been discussed as a potential input for SPARQL 1. 1 which was resolved {{to be left out}} in favour of select <b>subqueries</b> under the - unproven - conjecture that such <b>subqueries</b> can express nested construct queries. In this paper, we show that it is indeed possible to unfold nested SPARQL construct queries into <b>subqueries</b> in SPARQL 1. 1; our transformation, however, requires an exponential blowup in the nesting depth. This suggests that nested construct queries are indeed a useful syntactic feature in SPARQL that cannot compactly be replaced by <b>subqueries...</b>|$|R
5000|$|A derived {{table is}} the use of {{referencing}} an SQL <b>subquery</b> in a FROM clause. Essentially, the derived table is a <b>subquery</b> that can be selected from or joined to. The derived table functionality allows the user to reference the <b>subquery</b> as a table. The inline view is also referred to as an inline view [...] or a subselect.|$|E
5000|$|An {{example of}} a {{recursive}} query computing the factorial of numbers from 0 to 9 is the following:WITH RECURSIVE temp (n, fact) AS (SELECT 0, 1 -- Initial <b>Subquery</b> UNION ALL [...] SELECT n+1, (n+1)*fact FROM temp -- Recursive <b>Subquery</b> [...] WHERE n < 9)SELECT * FROM temp; ...|$|E
50|$|Correlated {{subqueries}} {{may appear}} elsewhere besides the WHERE clause; for example, this query uses a correlated <b>subquery</b> in the SELECT clause to print the entire list of employees alongside {{the average salary}} for each employee's department. Again, because the <b>subquery</b> is correlated with a column of the outer query, it must be re-executed for each row of the result.|$|E
40|$|Abstract. The <b>Subqueries</b> {{functionality}} is {{a powerful}} feature which allows to enforce reuse, composition, rewriting and optimization in a query language. In this paper we perform a comprehensive study of the incorporation of <b>subqueries</b> into SPARQL. We consider several possible choices {{as suggested by the}} experience of similar languages, as well as features that developers are incorporating and/or experimenting with. Based on this study, we present an extension of SPARQL, with syntax and formal semantics, which incorporates all known types of <b>subqueries</b> in a modular fashion and preserves the original semantics. ...|$|R
40|$|Abstract—The {{introduction}} of <b>subqueries</b> {{is one of}} the most interesting feature included in the latest SPARQL 1. 1 specifica-tion. Existing distributed RDF storage and querying systems have not studied the evaluation of this newly included query feature. The evaluation of <b>subqueries</b> in distributed environment may be very inefficient and expensive in term of query response time and bandwidth usage, particularly for the correlated <b>subqueries,</b> where the inner query block is evaluated once for each solution of the outer query. In this paper, we study the problem of evaluating SPARQL <b>subqueries</b> over RDF data stored in 3 nuts p 2 p network. We study semijoin based optimization technique, and transformation algorithms to transform correlated queries to equivalent uncorrelated once, that would improve the efficiency of nested query evaluation in distributed environment. I...|$|R
40|$|Abstract. <b>Subqueries</b> are a poweful feature {{which allows}} to enforce reuse, composition, {{rewriting}} and optimization in a query language. In this paper we perform a {{comprehensive study of}} the incorporation of <b>subqueries</b> into SPARQL. We consider the many possible choices {{as suggested by the}} experience of similar languages, as well as features that developers are incorporating and/or experimenting with. Our study includes the discussion in the SPARQL case of common design issues concerning <b>subqueries</b> (i. e., query correlation, scope of datasets, and optimization), show the interplay among them, and study their implications in terms of expressive power. Based on this study, we present an extension of SPARQL, with syntax and formal semantics, which incorporates all knwon types of <b>subqueries</b> in a modular fashion and preserving the original semantics. ...|$|R
5000|$|... where a <b>subquery</b> is an {{arbitrarily}} {{long list}} of tags, concatenated as directories: ...|$|E
50|$|CTEs can {{be thought}} of as {{alternatives}} to derived tables (<b>subquery),</b> views, and inline user-defined functions.|$|E
50|$|Embedded queries {{supported}} include <b>subquery</b> expressions, expr IN (subselect), quantified comparisons, and the EXISTS (subselect) predicate.|$|E
40|$|As {{database}} {{technology is}} applied {{to more and more}} application domains, user queries are becoming increasingly complex (e. g. involving a large number of joins and a complex query structure). Query optimizers in existing database management systems (DBMS) were not developed for efficiently processing such queries and often suffer from problems such as intolerably long optimization time and poor optimization results. To tackle this challenge, we present a new similarity-based approach to optimizing complex queries in this paper. The key idea is to identify similar <b>subqueries</b> that often appear in a complex query and share the optimization result among similar <b>subqueries</b> in the query. Different levels of similarity for <b>subqueries</b> are introduced. Efficient algorithms to identify similar queries in a given query and optimize the query based on similarity are presented. Related issues, such as choosing good starting nodes in a query graph, evaluating identified similar <b>subqueries</b> and analyzing algorithm complexities, are discussed. Our experimental results demonstrate that the proposed similarity-based approach is quite promising in optimizing complex queries with similar <b>subqueries</b> in a DBMS...|$|R
5000|$|Composability, which removes {{restrictions}} on where <b>subqueries</b> can be used.|$|R
50|$|Through data abstraction, federated {{database}} {{systems can}} provide a uniform user interface, enabling users and clients to store and retrieve data from multiple noncontiguous databases with a single query—even if the constituent databases are heterogeneous. To this end, a federated database system {{must be able to}} decompose the query into <b>subqueries</b> for submission to the relevant constituent DBMSs, after which the system must composite the result sets of the <b>subqueries.</b> Because various database management systems employ different query languages, federated database systems can apply wrappers to the <b>subqueries</b> to translate them into the appropriate query languages.|$|R
5000|$|In ANSI SQL the [...] keyword {{can be used}} to {{transform}} a <b>subquery</b> into a collection expression: ...|$|E
5000|$|... is {{a general}} select {{that can be used}} as <b>subquery</b> {{expression}} of another more general query, while ...|$|E
5000|$|The EXISTS {{condition}} {{uses the}} SQL standard keyword [...] {{to determine whether}} rows exist in a <b>subquery</b> result.|$|E
40|$|A formal {{basis for}} {{extending}} SQL {{in a natural}} way to complex object databases is laid. N SQL, a language equivalent to the standard algebra for nested relational databases, is obtained. It is also shown that, when allowing <b>subqueries</b> in the from-clause, the facility of <b>subqueries</b> in where-clauses becomes redundant with regard to expressive power...|$|R
50|$|Cassandra cannot do joins or <b>subqueries.</b> Rather, Cassandra {{emphasizes}} denormalization through {{features like}} collections.|$|R
5000|$|Version 4.1: beta from June 2004, {{production}} release October 2004 (R-trees and B-trees, <b>subqueries,</b> prepared statements).|$|R
5000|$|Delete rows from mytable using a <b>subquery</b> in the where condition:DELETE FROM mytable WHERE id IN ( [...] SELECT id FROM mytable2 [...] ); ...|$|E
5000|$|... {{transforms}} the <b>subquery</b> into a collection expression {{that can be}} used in another query, or in assignment to a column of appropriate collection type.|$|E
50|$|Here is {{an example}} for a typical {{correlated}} <b>subquery.</b> In this example, {{the objective is to}} find all employees whose salary is above average for their department.|$|E
40|$|We {{describe}} {{a method for}} the streaming evaluation of XPath queries that have <b>subqueries</b> in predicates. Our method rewrites XPath queries into a set of predicate-free labeled linear-form expressions (LFEs). These LFEs are used to generate a pushdown transducer that enables efficient management of a buffer and hierarchical index at runtime. To {{the best of our}} knowledge, our method is the first to support XPath <b>subqueries</b> in a streaming environment. Our method also provides optimal buffering, minimum-latency output, and optimal predicate evaluation. The method has been fully implemented and publicly released in the XSQ system. We present an experimental study of XSQ and related systems on both real-life and synthetic datasets, and investigate how <b>subqueries</b> and other features affect the performance of these systems. ...|$|R
40|$|Federated query engines allow data {{consumers}} to execute queries over the federation of Linked Data (LD). However, as federated queries are decomposed into potentially thousands of <b>subqueries</b> distributed among SPARQL endpoints, data providers {{do not know}} federated queries, they only know <b>subqueries</b> they process. Consequently, unlike warehousing approaches, LD data providers {{have no access to}} secondary data. In this paper, we propose FETA (FEderated query TrAcking), a query tracking algorithm that infers Basic Graph Patterns (BGPs) processed by a federation from a shared log maintained by data providers. Concurrent execution of thousand <b>subqueries</b> generated by multiple federated query engines makes the query tracking process challenging and uncertain. Experiments with Anapsid show that FETA is able to extract BGPs which, even in a worst case scenario, contain BGPs of original queries...|$|R
40|$|The tree-based {{languages}} XQuery and XSLT for XML {{are widely}} supported. Many tools {{do not yet}} support the new RDF graph query language SPARQL. We propose to embed SPARQL <b>subqueries</b> into XQuery/XSLT, such that XQuery and XSLT benefit from the graph query language constructs of SPARQL, and SPARQL benefits from features of XQuery/XSLT, which SPARQL does not support. The embedding enables XQuery/XSLT tools to handle {{at the same time}} XML queries and SPARQL <b>subqueries,</b> and XML and RDF data...|$|R
5000|$|In {{the above}} query the outer query is SELECT employee_number, name FROM {{employees}} AS emp WHERE salary > ...and the inner query (the correlated <b>subquery)</b> is SELECT AVG(salary) FROM employees WHERE department = emp.department ...|$|E
5000|$|Since 1999 the SQL {{standard}} allows [...] clauses for subqueries, i.e. named subqueries, {{usually called}} common table expressions (also called <b>subquery</b> factoring). CTEs {{can also be}} recursive by referring to themselves; the resulting mechanism allows tree or graph traversals (when represented as relations), and more generally fixpoint computations.|$|E
5000|$|...- This <b>subquery</b> is not {{correlated}} with the outer query, and is therefore -- executed only once, regardless {{of the number of}} employees. SELECT employees.employee_number, employees.name FROM employees INNER JOIN (SELECT department, AVG(salary) AS department_average FROM employees GROUP BY department) AS temp ON employees.department = temp.department WHERE employees.salary > temp.department_average; ...|$|E
40|$|Abstract. We {{introduce}} a new method for optimization of SQL queries with nested <b>subqueries.</b> The method {{is based on the}} idea of Boolean aggregates, aggregates that compute the conjunction or disjunction of a set of conditions. When combined with grouping, Boolean aggregates allow us to compute all types of non-aggregated <b>subqueries</b> in a uniform manner. The resulting query trees are simple and amenable to further optimization. Our approach can be combined with other optimization techniques and can be implemented with a minimum of changes in any cost-based optimizer. ...|$|R
40|$|Abstract: In {{order to}} access data from various {{different}} data repositories, in Global-As-View approaches an input query is decomposed into several <b>subqueries.</b> Normally, this decomposition {{is based on}} a set of mappings, which describe the correspondence of data elements between a global schema and local ones. However, building mappings is a difficult task, especially when the number of participating local schemas is large. In our approach, an input query is automatically decomposed into <b>subqueries</b> without using mappings. An algorithm is proposed to transform a global path expression (e. g., an XPath query) into local path expressions executable in local schemas. This algorithm considers parts of a path expression from right to left, i. e., the algorithm traverses from the bottom {{to the top of a}} schema tree depending on the structure of local schemas. Compared to top-down approaches, such as by Lausen and Marron (LM), our algorithm can reduce the time for forming <b>subqueries</b> for local (e. g., XML) schemas to a large extent...|$|R
40|$|Finding similar {{patterns}} {{in a time}} sequence is a well-known problem that has been addressed by many authors. Most of the current techniques work well for queries of a prespecified length, but fail for variable length queries. We propose a new indexing technique that works well for variable length queries. Our idea is to store index structures at different resolutions for a given dataset. The resolutions are based on wavelets. A number of <b>subqueries</b> at different resolutions are generated for each variable length query. The ranges of the <b>subqueries</b> are progressively refined based on results from previous <b>subqueries.</b> Our experiments show that the total cost for our method is 4 to 20 times less than the current techniques including Linear Scan. Because {{of the need to}} store information at multiple resolution levels, the storage requirement of our method could potentially be large. In {{the second part of the}} paper, we show how the index information can be compressed with minimal inf [...] ...|$|R
