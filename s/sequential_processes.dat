814|1990|Public
5|$|Mathematically, {{these models}} can be {{represented}} in several ways. Petri nets, which were introduced in Carl Adam Petri's 1962 doctoral thesis, were an early attempt to codify the rules of consistency models. Dataflow theory later built upon these, and Dataflow architectures were created to physically implement the ideas of dataflow theory. Beginning in the late 1970s, process calculi such as Calculus of Communicating Systems and Communicating <b>Sequential</b> <b>Processes</b> were developed to permit algebraic reasoning about systems composed of interacting components. More recent additions to the process calculus family, such as the π-calculus, have added the capability for reasoning about dynamic topologies. Logics such as Lamport's TLA+, and mathematical models such as traces and Actor event diagrams, have also been developed to describe the behavior of concurrent systems.|$|E
25|$|VerilogCSP {{is a set}} of macros {{added to}} Verilog HDL to support {{communicating}} <b>sequential</b> <b>processes</b> channel communications.|$|E
25|$|In {{computer}} science, communicating <b>sequential</b> <b>processes</b> (CSP) is {{a formal}} language for describing patterns of interaction in concurrent systems. It {{is a member}} of the family of mathematical theories of concurrency known as process algebras, or process calculi, based on message passing via channels. CSP was highly influential in the design of the occam programming language, and also influenced the design of programming languages such as Limbo, RaftLib, Go, Crystal, and Clojure's core.async.|$|E
40|$|Locating {{good design}} {{solutions}} within a <b>sequential</b> <b>process</b> environment {{is necessary to}} improve the quality and overall productivity of the <b>processes.</b> Multi-objective, multi-stage <b>sequential</b> <b>process</b> design is a complex problem involving large number of design variables and sequential relationship between any two stages. The aim {{of this paper is to}} propose a novel framework to handle real-life <b>sequential</b> <b>process</b> optimisation problems using a Genetic Algorithm (GA) based technique. The research validates the proposed GA based framework using a real-life case study of optimising the multi-pass rolling system design. The framework identifies a number of near optimal designs of the rolling system...|$|R
3000|$|For any <b>sequential</b> <b>process</b> s, Definition 10 {{ensures that}} s ∈sub(s); hence, the thesis follows trivially.|$|R
3000|$|Product development, in this process, {{goes through}} a <b>sequential</b> <b>process,</b> while in reality, it is {{otherwise}} [...]...|$|R
25|$|In a one-page {{paper from}} 1965 Dijkstra {{introduced}} the 'mutual exclusion problem' for n processes and discussed {{a solution to}} it. It was probably the first published concurrent algorithm. The notion, standard by now, of a 'critical section' was also introduced in this paper. Per Brinch Hansen, {{a pioneer in the}} field of concurrent computing, considers Dijkstra's Cooperating <b>Sequential</b> <b>Processes</b> (1965) to be the first classic paper in concurrent programming. As Brinch Hansen notes, 'Dijkstra lays the conceptual foundation for abstract concurrent programming' with that paper.|$|E
2500|$|Dijkstra, Edsger W. [...] (1971). Hierarchical Ordering of <b>Sequential</b> <b>Processes.</b> Acta Inf. 1: 115-138 ...|$|E
2500|$|Dijkstra, Edsger W. (1965). Cooperating <b>Sequential</b> <b>Processes</b> (Technische Hogeschool Eindhoven). Reprinted in F. Genuys (ed.), Programming Languages, Academic Press, Orlando, Florida, 1968, pp.43–112 ...|$|E
50|$|Figure 4 {{displays}} {{a model of}} the ISPL acquisition process.The acquisition process consists of three <b>sequential</b> <b>process</b> steps.|$|R
25|$|Graded motor {{imagery is}} a <b>sequential</b> <b>process</b> that {{consists}} of (a) laterality reconstruction, (b) motor imagery, and (c) mirror therapy.|$|R
30|$|By {{induction}} on {{the structure}} of the <b>sequential</b> <b>process</b> s and then by induction on the rules in Table 9.|$|R
2500|$|As {{its name}} suggests, CSP allows the {{description}} of systems in terms of component processes that operate independently, and {{interact with each other}} solely through message-passing communication. However, the [...] "Sequential" [...] part of the CSP name is now something of a misnomer, since modern CSP allows component processes to be defined both as <b>sequential</b> <b>processes,</b> and as the parallel composition of more primitive processes. The relationships between different processes, and the way each process communicates with its environment, are described using various process algebraic operators. Using this algebraic approach, quite complex process descriptions can be easily constructed from a few primitive elements.|$|E
2500|$|The {{version of}} CSP {{presented}} in Hoare's original 1978 paper {{was essentially a}} concurrent programming language rather than a process calculus. It had a substantially different syntax than later versions of CSP, did not possess mathematically defined semantics, {{and was unable to}} represent unbounded nondeterminism. Programs in the original CSP were written as a parallel composition of a fixed number of <b>sequential</b> <b>processes</b> communicating with each other strictly through synchronous message-passing. In contrast to later versions of CSP, each process was assigned an explicit name, and the source or destination of a message was defined by specifying the name of the intended sending or receiving process. For example, the process ...|$|E
2500|$|Dijkstra {{organized}} {{the design of}} the system in layers {{in order to reduce the}} overall complexity of the software. Though the term 'architecture' had not yet been used to describe software design, this was certainly considered the first glimpse of software architecture. It introduced a number of design principles which have become part of the working vocabulary of every professional programmer: levels of abstraction, programming in layers, the semaphore, and cooperating <b>sequential</b> <b>processes.</b> His original paper on the THE operating system was reprinted in the 25th Anniversary issue of Communications of the ACM, in January 1983. By way of introduction, the Editor-in-Chief says, [...] "This project initiated a long line of research in multilevel systems architecture — a line that continues to the present day because hierarchical modularity is a powerful approach to organizing large systems." ...|$|E
50|$|Graded motor {{imagery is}} a <b>sequential</b> <b>process</b> that {{consists}} of (a) laterality reconstruction, (b) motor imagery, and (c) mirror therapy.|$|R
3000|$|Mature seed cones from {{interspecific}} hybrid crosses {{are the first}} ‘product’ in the <b>sequential</b> <b>process</b> of tree breeding as it contains the F [...]...|$|R
40|$|I study a <b>sequential</b> <b>process</b> {{in which}} {{different}} pairs of traders bargain over {{the terms of}} trade of an indivisible good. I consider both one-sided and two-sided offers based bargaining at the stage-game level. The <b>sequential</b> <b>process</b> is modelled as an infinite stage-game of incomplete information and the paper studies the efficiency properties of its equilibria. It is shown: With one-sided offers, all equilibria are long-run ex post efficient; with two-sided offers, examples of equilibria are constructed with widely varying efficiency properties...|$|R
2500|$|Erlang's main {{strength}} is support for concurrency. It {{has a small}} but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the occam programming language, though it recasts the ideas of communicating <b>sequential</b> <b>processes</b> (CSP) in a functional framework and uses asynchronous message passing. Processes are the primary means to structure an Erlang application. [...] They are neither operating system processes nor operating system threads, but lightweight processes that are scheduled by Erlang's BEAM VM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 words. Thus, many processes can be created without degrading performance. A benchmark with 20 million processes has been successfully performed. Erlang has supported symmetric multiprocessing since release R11B of May 2006.|$|E
2500|$|Following the {{publication}} of the original version of CSP, Hoare, Stephen Brookes, and A. W. Roscoe developed and refined the theory of CSP into its modern, process algebraic form. The approach taken in developing CSP into a process algebra was influenced by Robin Milner's work on the Calculus of Communicating Systems (CCS), and vice versa. The theoretical version of CSP was initially presented in a 1984 article by Brookes, Hoare, and Roscoe, and later in Hoare's book Communicating <b>Sequential</b> <b>Processes,</b> which was published in 1985. In September 2006, that book was still the [...] computer science reference of all time according to Citeseer (albeit an unreliable source {{due to the nature of}} its sampling). The theory of CSP has undergone a few minor changes since {{the publication}} of Hoare's book. Most of these changes were motivated by the advent of automated tools for CSP process analysis and verification. Roscoe's The Theory and Practice of Concurrency describes this newer version of CSP.|$|E
5000|$|Communicating <b>sequential</b> <b>processes,</b> the {{mathematics}} underlying JCSP ...|$|E
3000|$|The <b>sequential</b> <b>process</b> of {{contacts}} between {{employers and employees}} is as follows. Unemployed job seekers contact firms at rate λ, while employed job seekers contact firms at [...]...|$|R
40|$|We {{compare the}} most common methods for selling a company or other asset when {{participation}} is costly: a simple simultaneous auction, and a <b>sequential</b> <b>process</b> in which potential buyers decide in turn {{whether or not to}} enter the bidding. The <b>sequential</b> <b>process</b> is always more efficient. But pre-emptive bids transfer surplus from the seller to buyers. Because the auction is more conducive to entry- precisely because of its inefficiency- it usually generates higher expected revenue. We also discuss the effects of lock-ups, matching rights, break-up fees (as in takeover battles), entry subsidies, etc...|$|R
50|$|The {{fundamental}} unit of execution was a <b>sequential</b> <b>process</b> {{in contrast to}} the Actor model in which execution was fundamentally concurrent. Sequential execution is problematical because multi-processor computers are inherently concurrent.|$|R
5000|$|... occam—influenced heavily by {{communicating}} <b>sequential</b> <b>processes</b> (CSP) ...|$|E
50|$|In Tony Hoare's {{communicating}} <b>sequential</b> <b>processes</b> (CSP) McIlroy's pipes {{are further}} developed.|$|E
5000|$|SFC (sequential {{function}} chart) {{is convenient}} for programming <b>sequential</b> <b>processes</b> and flows ...|$|E
40|$|We {{compare the}} most common methods for selling a company or other asset when {{participation}} is costly: a simple simultaneous auction, and a <b>sequential</b> <b>process</b> in which potential buyers decide in turn {{whether or not to}} enter the bidding. The <b>sequential</b> <b>process</b> is always more efficient. But pre-emptive bids transfer surplus from the seller to buyers. Because the auction is more conducive to entry - precisely because of its inefficiency - it usually generates higher expected revenue. We also discuss the effects of lock-ups, matching rights, break-up fees (as in takeover battles), entry subsidies, etc. Auctions, jump bidding, sequential sales, procurement, entry...|$|R
30|$|Note {{that for}} any {{processes}} p and q, if the <b>sequential</b> <b>process</b> p {{is such that}} p ∈sub(q), then sub(p) ⊆sub(q). This is because the definition of sub(q) recursively calls itself on all of its sequential subterms.|$|R
5000|$|Order Management {{requires}} multiple {{steps in}} a <b>sequential</b> <b>process</b> like Capture, Validation, Fraud Check, Payment Authorization, Sourcing, Backorder management, Pick, pack, ship and associated customer communications. Order management systems usually have workflow capabilities to manage this process.|$|R
5000|$|Dijkstra, Edsger W. (1971). Hierarchical Ordering of <b>Sequential</b> <b>Processes.</b> Acta Inf. 1: 115-138 ...|$|E
5000|$|C. A. R. Hoare, Communicating <b>Sequential</b> <b>Processes,</b> 1985. [...] {{hardback}} or [...] paperback.|$|E
50|$|JCSP is an {{implementation}} of Communicating <b>Sequential</b> <b>Processes</b> (CSP) for the Java programming language.|$|E
40|$|We analyze {{stability}} of self-enforcing climate agreements, considering a <b>sequential</b> coalition formation <b>process</b> of heterogeneous and farsighted players. Players can make proposals which are either accepted or countered by alternative proposals. We discuss the conceptual difficulties of implementing and solving such {{a game and}} the strategic options arising in a <b>sequential</b> <b>process.</b> This is illustrated with simple examples and with numerical simulations using the CLIMNEG world simulation model (CWSM) ...|$|R
50|$|Order {{processing}} is a <b>sequential</b> <b>process</b> involving: processing withdrawal list, picking (selective {{removal of}} items from loading units), sorting (assembling items based on destination), package formation (weighting, labeling and packing), order consolidation (gathering packages into loading units for transportation, control and bill of lading).|$|R
50|$|This {{process has}} {{continued}} into the electronic age where the mechanical wheel {{is no longer a}} physical device, but an order is still sent to the kitchen and then returned to the server once completed via a <b>sequential</b> <b>process</b> of first in - first out.|$|R
