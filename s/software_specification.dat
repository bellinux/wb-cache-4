427|1138|Public
25|$|NEPOMUK, an {{open-source}} <b>software</b> <b>specification</b> for a Social Semantic desktop uses RDF as {{a storage}} format for collected metadata. NEPOMUK is mostly known {{because of its}} integration into the KDE SC 4 desktop environment.|$|E
5000|$|Verigraph, a <b>software</b> <b>specification</b> and {{verification}} {{system based}} on graph rewriting (Haskell).|$|E
5000|$|... {{as a part}} of requirements-gathering {{phase in}} a {{software}} engineering or designing a <b>software</b> <b>specification</b> ...|$|E
5000|$|ZETA {{open-source}} {{system for}} development <b>software</b> <b>specifications</b> in Z ...|$|R
40|$|Although model {{checking}} {{has proven}} remarkably effective in detecting errors in hardware designs, its {{success in the}} analysis of <b>software</b> <b>specifications</b> has been limited. Model checking algorithms for hardware verification commonly use Binary Decision Diagrams (BDDs) to represent predicates involving the many Boolean variables commonly found in hardware descriptions. Unfortunately, BDD representations may be less effective for analyzing <b>software</b> <b>specifications,</b> which usually contain not only Booleans but variables spanning a wide range of data types. Further, <b>software</b> <b>specifications</b> typically have huge, sometimes infinite, state spaces that cannot be model checked directly using conventional symbolic methods. One promising but largely unexplored approach to model checking software [...] ...|$|R
40|$|As part of {{software}} engineering, requirements analysis based on contextual domain knowledge {{plays an important}} role in providing precise <b>software</b> <b>specifications</b> that are appropriate for subsequent software development. In this paper, we present a formal approach to domain knowledge modeling based on Jackson’s problem frames, which can then be transformed into <b>software</b> <b>specifications</b> using the techniques of Hoare’s communicating sequential processes...|$|R
5000|$|Typical human-machine {{interface}} design {{consists of the}} following stages: interaction specification, interface <b>software</b> <b>specification</b> and prototyping: ...|$|E
5000|$|Common {{practices}} for interface <b>software</b> <b>specification</b> include use cases, constrain enforcement by interaction protocols (intended to avoid use errors).|$|E
50|$|Samy Kamkar {{released}} the SkyJack hardware and <b>software</b> <b>specification</b> on December 2, 2013, as open source and detailed the creation on his website.|$|E
5000|$|Axel van Lamsweerde. Requirements Engineering: From System Goals to UML Models to <b>Software</b> <b>Specifications.</b> Wiley, 9 feb. 2009 ...|$|R
5000|$|Ensure {{that the}} [...] "build-to" [...] {{baseline}} contains detailed hardware and <b>software</b> <b>specifications</b> that can meet functional and performance requirements ...|$|R
50|$|ACE and its related tools {{have been}} used in the fields of <b>software</b> <b>specifications,</b> theorem proving, text summaries, ontologies, rules, querying, medical {{documentation}} and planning.|$|R
5000|$|Pujari A.K., S.L. Mehndiratta: A unified {{approach}} to database system specification and representation, Third International workshop on <b>Software</b> <b>Specification</b> and design, August 1985, U.K.|$|E
5000|$|The AUTOSAR General <b>Software</b> <b>Specification</b> (SRS_BSW_00007) {{requires}} that all Basic SW Modules written in C language shall {{conform to the}} MISRA C 2012 Standard.|$|E
5000|$|Pujari A.K., S.L. Mehndiratta:A unified {{approach}} to database system specification and design, Fourth International Workshop on <b>software</b> <b>Specification</b> and Design, April 1987, California, U.S.A., (Position paper selected for participation).|$|E
40|$|Although model {{checking}} {{has proven}} remarkably effective in detecting errors in hardware designs, its {{success in the}} analysis of <b>software</b> <b>specifications</b> has been quite limited. Model checking algorithms for hardware verification commonly use Binary Decision Diagrams (BDDs), a highly effective technique for analyzing specifications with the scores of Boolean variables commonly found in hardware descriptions. Unfortunately, BDDs are relatively ineffective for analyzing <b>software</b> <b>specifications,</b> which usually contain not only Booleans but variables spanning a wide range of data types. Further, <b>software</b> <b>specifications</b> have huge, often infinite, state spaces that cannot be model checked directly using conventional symbolic methods. One promising, but largely unexplored technique for limiting the size of the state space to be analyzed by model checking is to extract a model with a smaller state space from a complete specification using sound abstraction methods. Users of model checkers routinely analyze reduced models but most often generate the models in ad hoc ways. As a result, the reduced models are often incorrect. This paper first describes how one can model check a complete requirements specification expresse...|$|R
30|$|Acceptance tests {{based on}} {{satisfaction}} of requirements: ATs are constructed with conditions {{that must be}} met {{at the completion of}} variant execution (Pullum [2001]). These conditions might arise from the problem statement of the <b>software</b> <b>specifications.</b>|$|R
40|$|Specifications play {{a crucial}} role in the {{development}} of many types of <b>software</b> systems. Formal <b>specification</b> techniques are often used to help ensure that the requirements are correctly captured and to prove or check properties of the developed software. This is especially true in systems such as concurrent software systems, due to the critical nature that such systems may have. Though the growing importance of the specification phase shows the emerging need for extending measurement to it, few measures have been defined for specifications. The main reason is that specifications have often been written in informal languages, which made it hard to define and collect measures for <b>software</b> <b>specifications.</b> Instead, formal specifications would have a great potential for being measured. This paper proposes a set of measures for capturing a number of internal attributes (i. e., size, length, complexity, and coupling) of <b>software</b> <b>specifications</b> written with Petri nets, a well-known formal technique for modeling concurrent systems. These measures are theoretically validated against a collection of axiom sets that have been proposed in the literature. This theoretical validation provides evidence that the measures really capture the internal attributes they purport to measure. This is a necessary precondition in the development of a set of measures for the internal attributes of concurrent <b>software</b> <b>specifications...</b>|$|R
5000|$|NEPOMUK, an {{open-source}} <b>software</b> <b>specification</b> for a Social Semantic desktop uses RDF as {{a storage}} format for collected metadata. NEPOMUK is mostly known {{because of its}} integration into the KDE SC 4 desktop environment.|$|E
50|$|The Matita {{tutorial}} {{provides a}} pragmatic {{introduction to the}} main functionalities of the Matita interactive theorem prover, offering a guided tour {{through a set of}} not trivial examples in the field of <b>software</b> <b>specification</b> and verification.|$|E
50|$|ALE 1.0 was {{the first}} <b>software</b> <b>specification</b> to be {{ratified}} by EPCglobal in September 2005. The next version, ALE 1.1 extends over ALE 1.0 and adds {{a host of new}} features. This version is ratified by EPCglobal in February 2008.|$|E
50|$|In a {{software}} development team, {{a software}} analyst {{is the person}} who studies the software application domain, prepares <b>software</b> requirements, and <b>specification</b> (<b>Software</b> Requirements <b>Specification)</b> documents. The <b>software</b> analyst is the seam between the software users and the software developers. They convey the demands of software users to the developers.|$|R
5000|$|OpenCable {{is a set}} of {{hardware}} and <b>software</b> <b>specifications</b> under development in the United States by CableLabs to [...] "define the next-generation digital consumer device" [...] for the cable television industry. The consumer-facing brand tru2way was introduced in January, 2008.|$|R
40|$|In {{an ideal}} world, <b>software</b> <b>specifications</b> are machine {{readable}} (can be parsed) {{much of the}} tedious verification tasks could be automated by tools. But even if the specification can be processed by one specifi tool it is often worthless to other tools {{not to mention that}} machine readable specifi cations are normally not easily read by humans. The first step to solve these obstacles is to develop and define a standard which allows communicate, meaning exchange semantical as well as typesetting information of <b>software</b> <b>specifications</b> between different tools and word processing systems including browsers. The Extensible Markup Language XML allows to represent semantical as well as formatting information of a document. Purpose {{of this paper is to}} propose a standard called OpenSpec based on XML. The OpenSpec standard is designed to communicate formal and semi-formal <b>software</b> <b>specifications.</b> Further, OpenSpec allows to have different "views" of the same document. The presented approach is not restricted to one particular type of specification notation but is intended to be acceptable to "all" approaches to formal and informal specifications. Special consideration is given to support tabular speci cations. We developed several software tools for parsing, writing, transforming, and type checking OpenSpec documents...|$|R
50|$|A virtual finite {{state machine}} is a {{finite state machine}} (FSM) defined in a virtual environment. The VFSM concept {{provides}} a <b>software</b> <b>specification</b> method to describe the behaviour of a control system using assigned names of input control properties and of output actions.|$|E
50|$|For {{concurrent}} {{software and}} systems, Petri nets, process algebra, and finite state machines (which {{are based on}} automata theory - see also virtual finite state machine or event driven finite state machine) allow executable <b>software</b> <b>specification</b> {{and can be used}} to build up and validate application behavior.|$|E
50|$|ARINC 653 (Avionics Application Standard Software Interface) is a <b>software</b> <b>specification</b> {{for space}} and time {{partitioning}} in safety-critical avionics real-time operating systems (RTOS). It allows the hosting of multiple applications of different software levels on the same hardware {{in the context of}} an Integrated Modular Avionics architecture.|$|E
5000|$|Real {{security}} {{begins with}} security policy. The Information Security professional {{must ensure that}} the security policy covers telecommuting/teleworking and who may telework, services available to teleworkers, information restrictions, identification/authentication/authorization, equipment and <b>software</b> <b>specifications,</b> integrity and confidentiality, maintenance guidelines, and robust user education." ...|$|R
5000|$|Requirements {{analysis}} {{resulting in}} a <b>software</b> requirements <b>specification</b> ...|$|R
5000|$|... #Subtitle level 2: Types of <b>software</b> {{development}} <b>specifications</b> ...|$|R
50|$|GLOBAL was a {{language}} developed in industry and sold off privately {{as an expert}} system. It was used to design several biopharmaceutical products, and sold to Tularik (Amgen). Prometheus used for drug system design was written using GLOBAL and is described on this Cray <b>software</b> <b>specification.</b>|$|E
5000|$|The JAUS Tool Set (JTS) {{is a set}} of {{open source}} <b>software</b> <b>specification</b> and {{development}} tools accompanied by an open source software framework to develop Joint Architecture for Unmanned Systems (JAUS) designs and compliant interface implementations for simulations and control of robotic components per SAE-AS4 standards. JTS consists of the components: ...|$|E
50|$|The Internet Protocol Suite is the standards-based {{networking}} {{model and}} <b>software</b> <b>specification</b> for forming {{small and large}} computer networks, from local area networks to global communication systems, such as the Internet. It is usually implemented by software and hardware features that use Ethernet network interface cards, cabling, and networking switches or hubs.|$|E
50|$|<b>Software</b> {{requirements}} <b>specification</b> {{establishes the}} basis for an agreement between customers and contractors or suppliers (in market-driven projects, these roles may be played by the marketing and development divisions) on what the software product is to {{do as well as}} what it is not expected to do. <b>Software</b> requirements <b>specification</b> permits a rigorous assessment of requirements before design can begin and reduces later redesign. It should also provide a realistic basis for estimating product costs, risks, and schedules. Used appropriately, <b>software</b> requirements <b>specifications</b> can help prevent software project failure.|$|R
50|$|Its {{standardized}} part {{is defined as}} a <b>software</b> interface <b>specification.</b>|$|R
40|$|Abstract — Software {{is often}} built without specificatioon. Specification mining is a machine {{learning}} approach for discovering formal specifications of the protocols that code must obey when interacting with an {{application program interface}} or abstract data type. There has been much work on reverse engineering or mining <b>software</b> <b>specifications</b> using dynamic analysis techniques...|$|R
