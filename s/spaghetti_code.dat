48|2|Public
25|$|Some {{assemblers}} {{have incorporated}} structured programming elements to encode execution flow. The earliest {{example of this}} approach was in the Concept-14 macro set, originally proposed by Dr. Harlan Mills (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks. This {{was a way to}} reduce or eliminate the use of GOTO operations in assembly code, one of the main factors causing <b>spaghetti</b> <b>code</b> in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).|$|E
500|$|One {{cause of}} <b>spaghetti</b> <b>code</b> was the [...] statement. Attempts to remove s from COBOL code, however, {{resulted}} in convoluted programs and reduced code quality. s were largely {{replaced by the}} [...] statement and procedures, which promoted modular programming and gave easy access to powerful looping facilities. However, [...] could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand.|$|E
500|$|Constantine Hantzopoulos {{directed}} Flight Unlimited II, {{which was}} published by Eidos Interactive in 1997. The team could not continue using the real-time computational fluid dynamics of Flight Unlimited because, according to Hantzopoulos, it was [...] "all black box <b>spaghetti</b> <b>code</b> from Seamus". The aerobatics focus of its predecessor was dropped in favor of general civilian aviation. The development of Flight Combat was hinted at during the production of Flight Unlimited II. A third game, Flight Unlimited III, was published by Electronic Arts in 1999; and it continued the focus on general aviation. That year, Flight Combat was officially announced as the World War II-themed, Electronic Arts-published Flight Combat: Thunder Over Europe, but its name was eventually changed to Jane's Attack Squadron. The game was canceled {{as a consequence of}} Looking Glass Studios' closure in 2000. However, it was later finished by developer Mad Doc Software and released in 2002 by publisher Xicat Interactive.|$|E
40|$|Computers today {{rely heavily}} on good {{utilization}} of their cache memory subsystems. Compilers are optimized for business applications, not scientific computing ones, however. Automatic tiling of basic numerical algorithms is simply not provided by any compiler. Thus, absolutely terrible cache performance is normal for scientific computing applications. Multigrid algorithms combine several numerical algorithms into a more complicated algorithm. In this paper, an algorithm is derived that allows for data to pass through cache exactly once per multigrid level during a V cycle before the level changes. This is optimal cache usage for large problems that do not fit entirely in cache. The new algorithm {{would appear to be}} quite complicated to implement, leading to <b>spaghetti</b> <b>coding.</b> Actually, an efficient implementation of the algorithm requires a rigid, highly structured coding style. A coding example is given that is suitable for almost all common discretization methods. Numerical experimen [...] ...|$|R
40|$|We {{will present}} how we transitioned from legacy <b>spaghetti</b> UI <b>code</b> {{to a more}} coherent, easier to {{understand}} and maintain ecosystem of front-end technologies and facilities with a strong emphasis in reusable components. In particular, we will share with you: 1) how we use Sass to maintain our home-baked CSS, 2) how we survive in 2017 without front-end Javascript frameworks, and 3) how we use template macros and WTForms for generating consistent HTML transparently...|$|R
500|$|In March 1996, PC Gamer US {{reported}} that Flight Combat was [...] "still taxiing across the design board", {{and that the}} team planned to focus [...] "on how the aerial manoeuvres are performed as you fight". Looking Glass designer Constantine Hantzopoulos told the magazine that {{a modified version of}} the Flight Unlimited engine was being used to develop Flight Combat and Flight Unlimited II. Hantzopoulos commented that Flight Combat was [...] "the project everybody at Looking Glass wants to work on". The team expected to be finished with the game in roughly one year. By June 1997, GameSpot {{reported that}} Flight Unlimited II was running on the new ZOAR engine, coded from scratch by programmer James Fleming. In addition, the real-time CFDs model from Flight Unlimited had been discarded, as its programming was [...] "all black box <b>spaghetti</b> <b>code</b> from Seamus". GameSpot's T. Liam MacDonald noted that the Flight Unlimited II team expected soon to use the same engine for a combat flight simulator set in World War II. Computer Gaming World similarly reported that the company was [...] "definitely hot" [...] to develop Flight Combat, and that it might be created after Flight Unlimited II. Following that game's completion, the team could not decide between developing Flight Unlimited III or Flight Combat. As a result, they decided to develop them simultaneously, and Flight Combat began production in early 1998. Unlike all of the studio's other games, development of Flight Combat was funded through an insured bond, in an attempt to guarantee that the game would be finished. The company's Tim Stellmach later said that this setup was [...] "a real pain for [...] in some ways".|$|E
5000|$|<b>Spaghetti</b> <b>code</b> is a pejorative {{phrase for}} source code {{that has a}} complex and tangled control structure, {{especially}} one using many GOTO statements, exceptions, threads, or other [...] "unstructured" [...] branching constructs. It is named such because program flow is conceptually like a bowl of spaghetti, i.e. twisted and tangled. <b>Spaghetti</b> <b>code</b> {{can be caused by}} several factors, such as continuous modifications by several people with different programming styles over a long life cycle. Structured programming greatly decreases the incidence of <b>spaghetti</b> <b>code.</b>|$|E
50|$|LabVIEW, being graphical, {{provides}} {{a unique opportunity}} for developers to write <b>spaghetti</b> <b>code</b> that literally looks like spaghetti.|$|E
5000|$|Here follows {{what would}} be {{considered}} a trivial example of <b>spaghetti</b> <b>code</b> in BASIC. The program prints each of the numbers 1 to 100 to the screen along with its square. Indentation is not used to differentiate the various actions performed by the code, and that the program's [...] statements create a reliance on line numbers. The flow of execution from one area to another is harder to predict. Real-world occurrences of <b>spaghetti</b> <b>code</b> are more complex and can add greatly to a program's maintenance costs.|$|E
5000|$|If much code takes {{advantage}} of the lack of encapsulation, the result is a scarcely maintainable maze of interactions, commonly known as a rat's nest or <b>spaghetti</b> <b>code.</b>|$|E
50|$|A loop-switch {{sequence}} (also {{known as}} the for-case paradigm or Anti-Duff's Device) is a programming antipattern where a clear set of steps is implemented as a switch-within-a-loop. The loop-switch sequence is a specific derivative of <b>spaghetti</b> <b>code.</b>|$|E
50|$|When {{using the}} {{many forms of}} {{assembly}} language (and also the underlying machine code) the danger of writing <b>spaghetti</b> <b>code</b> is especially great. Some scripting languages have the same deficiencies: this applies to the batch scripting language of DOS and DCL on VMS.|$|E
50|$|This was a {{structured}} language allowing complex programs to be built, free from BASIC's <b>Spaghetti</b> <b>code</b> while being near {{as fast as}} compiled languages. Not only was about 10 times faster than BASIC, it also allowed easy implementation of machine code routines, if needed for a particular critical task.|$|E
5000|$|GOTO-style {{branching}} {{can lead}} to the development of <b>spaghetti</b> <b>code.</b> (See Considered harmful, Structured programming.) Even in some later versions of BASIC that still mandated line numbers, the use of line number-controlled GOTOs was phased out whenever possible in favor of cleaner constructs such as the for loop and while loop.|$|E
5000|$|If {{integration}} is applied without following a structured EAI approach, point-to-point connections grow across an organization. Dependencies are added on an impromptu basis, {{resulting in a}} complex structure {{that is difficult to}} maintain. This is commonly referred to as spaghetti, an allusion to the programming equivalent of <b>spaghetti</b> <b>code.</b> For example: ...|$|E
50|$|The Jupiter Ace was {{the first}} of its class to use a very fast {{structured}} language, free of <b>spaghetti</b> <b>code,</b> without the need to be loaded or even bought. The language was also the first (and only) adapted to use a cassette tape recorder (without the disk/tape drives of highly priced systems).|$|E
50|$|Type {{generalization}} is {{a technique}} commonly used in refactoring. The idea is {{to draw on the}} benefits of object-orientation and make more-generalized types, thus enabling more code sharing, leading to better maintainability as there is less code to write. Too-general code can, however, become completely useless, leading to <b>spaghetti</b> <b>code</b> doing effectively nothing.|$|E
50|$|Ravioli code is a pejorative {{phrase for}} source code {{with lots of}} tiny, tightly-coupled objects. The tangled but {{explicit}} control structure of <b>Spaghetti</b> <b>code</b> is replaced with equally tangled but now implicit control flow using polymorphism. Overzealous separation and encapsulation of code can bloat call stacks and make navigation through the code for maintenance purposes more difficult.|$|E
5000|$|Program {{flow control}} in MBASIC was {{controlled}} by [...] conditional tests, [...] loops, and [...] and [...] instructions. No [...] statement was available, although an (computed GOTO) provided multi-way branches. Subroutines had no parameters and all variables were global. MBASIC did not make structured programming mandatory for programmers and {{it was easy to}} write <b>spaghetti</b> <b>code.</b>|$|E
50|$|The program jumps {{from one}} area to another, but this jumping is formal and more easily predictable, because for loops and {{functions}} provide flow control whereas the goto statement encourages arbitrary flow control. Though this example is small, real world programs {{are composed of}} many lines of code and are difficult to maintain when written in a <b>spaghetti</b> <b>code</b> fashion.|$|E
5000|$|It is {{not clear}} when the phrase <b>spaghetti</b> <b>code</b> came into common usage; however, several {{references}} appeared in 1977 including Macaroni is Better Than Spaghetti by Steele published in Proceedings of the 1977 symposium on artificial intelligence and programming languages. In the 1978 book A primer on disciplined programming using PL/I, PL/CS, and PL/CT, Richard Conway used the term to describe types of programs that [...] "have the same clean logical structure as a plate of spaghetti", a phrase repeated in the 1979 book An Introduction to Programming he co-authored with David Gries. In the 1988 paper A spiral model of software development and enhancement, the term is {{used to describe the}} older practice of the code and fix model, which lacked planning and eventually {{led to the development of}} the waterfall model. In the 1979 book Structured programming for the COBOL programmer, author Paul Noll uses the phrases <b>spaghetti</b> <b>code</b> and rat's nest as synonyms to describe poorly structured source code.|$|E
50|$|Its {{stronger}} {{appeal was}} both delivering a structured language allowed complex programs to be built, free from BASIC's <b>Spaghetti</b> <b>code,</b> and being nearly {{as fast as}} the compiled languages loaded by more expensive computers. Forth programs tend to be more memory-efficient than the bigger programs; as they become bigger, they reuse more previously-defined code. Its starting base memory was equivalent to 2kB up to 4kB in a more common system.|$|E
5000|$|One {{cause of}} <b>spaghetti</b> <b>code</b> was the [...] statement. Attempts to remove s from COBOL code, however, {{resulted}} in convoluted programs and reduced code quality. s were largely {{replaced by the}} [...] statement and procedures, which promoted modular programming and gave easy access to powerful looping facilities. However, [...] could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand.|$|E
5000|$|C++ {{supports}} [...] statements, {{which may}} lead to <b>spaghetti</b> <b>code</b> programming. With {{the exception of the}} goto statement (which is very rarely seen in real code and highly discouraged), both Java and C++ have basically the same control flow structures, designed to enforce structured control flow, and relies on break and continue statements to provide some -like functions. Some commenters point out that these labelled flow control statements break the single point-of-exit property of structured programming.|$|E
5000|$|In early {{programming}} languages, especially some dialects of BASIC in the 1980s home computers, an [...] statement {{could only}} contain [...] statements. This {{led to a}} hard-to-read style of programming known as spaghetti programming, with programs in this style called <b>spaghetti</b> <b>code.</b> As a result, structured programming, which allows (virtually) arbitrary statements {{to be put in}} statement blocks inside an [...] statement, gained in popularity, until it became the norm even in most BASIC programming circles. Such mechanisms and principles were based on the older but more advanced ALGOL family of languages, and ALGOL-like languages such as Pascal and Modula-2 influenced modern BASIC variants for many years. While it is possible while using only [...] statements in [...] statements to write programs that are not <b>spaghetti</b> <b>code</b> and are just as well structured and readable as programs written in a structured programming language, structured programming makes this easier and enforces it. Structured [...] statements like the example above are one of the key elements of structured programming, and they are present in most popular high-level programming languages such as C, Java, JavaScript and Visual Basic [...]|$|E
5000|$|Donald Knuth criticized {{this form}} of the proof, which results in {{pseudocode}} like the one below, {{by pointing out that}} the structure of the original program is completely lost in this transformation. Similarly, Bruce Ian Mills wrote about this approach that [...] "The spirit of block structure is a style, not a language. By simulating a Von Neumann machine, we can produce the behavior of any <b>spaghetti</b> <b>code</b> within the confines of a block-structured language. This does not prevent it from being spaghetti." ...|$|E
50|$|Developers {{had to pay}} {{attention}} to routing of wiring, and to commenting inputs and outputs, to keep their diagrammatic code clean. In the Prograph Database Operation example above, two of the paths cross because one of the wires from the input bar must flow to a certain input on the update operation. This could be avoided by simply dragging and repositioning the 'indexA' and 'sort' icons to be inside the leftmost wire, but in general terms {{there was no way to}} avoid this sort of literal <b>spaghetti</b> <b>code.</b>|$|E
50|$|Some {{assemblers}} {{have incorporated}} structured programming elements to encode execution flow. The earliest {{example of this}} approach was in the Concept-14 macro set, originally proposed by Dr. Harlan Mills (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks. This {{was a way to}} reduce or eliminate the use of GOTO operations in assembly code, one of the main factors causing <b>spaghetti</b> <b>code</b> in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).|$|E
50|$|As {{with most}} other {{calculator}} programming languages of the 1980s, a FOCAL {{program is a}} linear list of instructions. Each instruction (or step) roughly correspond to a key (or key combination) press, and thus correspond to what the user would do if he was to perform the computation himself on the calculator. This paradigm made FOCAL programming relatively easy for the newcomer, but program maintenance could be a nightmare.Besides that, the use of GOTO instructions - including going to a program step based on a value in a data register ("GTO IND"), a technique known as computed goto - , easily led to <b>spaghetti</b> <b>code.</b>|$|E
5000|$|UBASIC has line numbers. It {{does not}} use {{indentation}} to control structure. It has subroutines and user functions with passed parameters and local variables. Parameters can be passed by value or by name. User functions and subroutines may be passed as parameters. It has limited labels. It has various options for conditional functions. Users can indent as much as needed or not at all, and can have as much structure as wanted or <b>spaghetti</b> <b>code.</b> It {{is a mistake to}} consider UBASIC as [...] "not modern" [...] (as might be inferred by a reader of articles that confuse indentation with structure and don't favor line numbers). Having line numbers allows easy jumping to an intermediate point in a routine, which can sometimes save duplicating lines.|$|E
50|$|As {{soon the}} {{elementary}} OS {{has heard the}} news of Yorba's demise, they started planning the next steps of Geary future and adopted the code base in a few days. Since November 2015, {{as part of their}} Pantheon Mail fork, they removed support and workarounds for very old Linux distributions, which was not taking advantage of modern toolkit features. That old <b>spaghetti</b> <b>code</b> was replaced by new code reported to be much easier to read and maintain. They ported the build system to CMake. They removed support for controlling notifications from the app itself, which was unneeded as modern desktop environments like Plasma, GNOME, all provide these features in their own system settings. They addressed a bunch of issues regarding translations and polished the UI and iconography of the software. Pantheon Mail can be installed alongside Geary without conflicts. The software has been packaged for other Linux distributions.|$|E
5000|$|Constantine Hantzopoulos {{directed}} Flight Unlimited II, {{which was}} published by Eidos Interactive in 1997. The team could not continue using the real-time computational fluid dynamics of Flight Unlimited because, according to Hantzopoulos, it was [...] "all black box <b>spaghetti</b> <b>code</b> from Seamus". The aerobatics focus of its predecessor was dropped in favor of general civilian aviation. The development of Flight Combat was hinted at during the production of Flight Unlimited II. A third game, Flight Unlimited III, was published by Electronic Arts in 1999; and it continued the focus on general aviation. That year, Flight Combat was officially announced as the World War II-themed, Electronic Arts-published Flight Combat: Thunder Over Europe, but its name was eventually changed to Jane's Attack Squadron. The game was canceled {{as a consequence of}} Looking Glass Studios' closure in 2000. However, it was later finished by developer Mad Doc Software and released in 2002 by publisher Xicat Interactive.|$|E
5000|$|Entry 17.10 in comp.lang.c FAQ list {{addresses}} {{the issue of}} GOTO use directly, stating [...] Programming style, like writing style, is somewhat of an art and cannot be codified by inflexible rules, although discussions about style often seem to center exclusively around such rules. In {{the case of the}} goto statement, it has long been observed that unfettered use of goto's quickly leads to unmaintainable <b>spaghetti</b> <b>code.</b> However, a simple, unthinking ban on the goto statement does not necessarily lead immediately to beautiful programming: an unstructured programmer is just as capable of constructing a Byzantine tangle without using any goto's (perhaps substituting oddly-nested loops and Boolean control variables, instead). Many programmers adopt a moderate stance: goto's are usually to be avoided, but are acceptable in a few well-constrained situations, if necessary: as multi-level break statements, to coalesce common actions inside a switch statement, or to centralize cleanup tasks in a function with several error returns. (...) Blindly avoiding certain constructs or following rules without understanding them can lead to just as many problems as the rules were supposed to avert. Furthermore, many opinions on programming style are just that: opinions. They may be strongly argued and strongly felt, they may be backed up by solid-seeming evidence and arguments, but the opposing opinions may be just as strongly felt, supported, and argued. It's usually futile to get dragged into [...] "style wars", because on certain issues, opponents can never seem to agree, or agree to disagree, or stop arguing.|$|E
5000|$|In March 1996, PC Gamer US {{reported}} that Flight Combat was [...] "still taxiing across the design board", {{and that the}} team planned to focus [...] "on how the aerial manoeuvres are performed as you fight". Looking Glass designer Constantine Hantzopoulos told the magazine that {{a modified version of}} the Flight Unlimited engine was being used to develop Flight Combat and Flight Unlimited II. Hantzopoulos commented that Flight Combat was [...] "the project everybody at Looking Glass wants to work on". The team expected to be finished with the game in roughly one year. By June 1997, GameSpot {{reported that}} Flight Unlimited II was running on the new ZOAR engine, coded from scratch by programmer James Fleming. In addition, the real-time CFDs model from Flight Unlimited had been discarded, as its programming was [...] "all black box <b>spaghetti</b> <b>code</b> from Seamus". GameSpots T. Liam MacDonald noted that the Flight Unlimited II team expected soon to use the same engine for a combat flight simulator set in World War II. Computer Gaming World similarly reported that the company was [...] "definitely hot" [...] to develop Flight Combat, and that it might be created after Flight Unlimited II. Following that games completion, the team could not decide between developing Flight Unlimited III or Flight Combat. As a result, they decided to develop them simultaneously, and Flight Combat began production in early 1998. Unlike all of the studios other games, development of Flight Combat was funded through an insured bond, in an attempt to guarantee that the game would be finished. The companys Tim Stellmach later said that this setup was [...] "a real pain for team in some ways".|$|E
40|$|The action [...] . 5 <b>Spaghetti</b> <b>code</b> [...] . 7 Reserved file names [...] . ...|$|E
40|$|Continuations are the raw {{material}} of control. They {{can be used to}} explain a wide variety of control behaviours, including calling/returning (procedures), raising/handling (exceptions), labelled jumping (goto statements), process switching (coroutines), and backtracking. In the most powerful form, represented by callcc and its cousins, the programmer can manipulate continuations as first-class values. It can be argued, however, that unrestricted use of continuations, especially when combined with state, can give rise to intractable higher-order <b>spaghetti</b> <b>code.</b> Hence, few languages give the user direct, reified, access to continuations; rather, they are &quot;behind the scenes&quot;, implementing other control behaviours, and their use is highly stylised...|$|E
