7332|2842|Public
5|$|The {{language}} {{is intended for}} use in developing <b>software</b> <b>components</b> suitable for deployment in distributed environments.|$|E
5|$|A Folding@home {{participant}} installs {{a client}} program {{on their personal}} computer. The user interacts with the client, which manages the other <b>software</b> <b>components</b> in the background. Through the client, the user may pause the folding process, open an event log, check the work progress, or view personal statistics. The computer clients run continuously in the background at a very low priority, using idle processing power so that normal computer use is unaffected. The maximum CPU use can be adjusted via client settings. The client connects to a Folding@home server and retrieves a work unit and may also download the appropriate core for the client's settings, operating system, and the underlying hardware architecture. After processing, the work unit is returned to the Folding@home servers. Computer clients are tailored to uniprocessor and multi-core processor systems, and graphics processing units. The diversity and power of each hardware architecture provides Folding@home {{with the ability to}} efficiently complete many types of simulations in a timely manner (in a few weeks or months rather than years), which is of significant scientific value. Together, these clients allow researchers to study biomedical questions formerly considered impractical to tackle computationally.|$|E
25|$|OLE 1.0 later {{evolved to}} become an {{architecture}} for <b>software</b> <b>components</b> known as the Component Object Model (COM), and later DCOM.|$|E
40|$|The method {{involves}} determining (110) {{running time}} request of <b>software</b> <b>component</b> (102). The resources required for migration of <b>software</b> <b>component</b> are determined (112) based on running time requests. The {{point of time}} to which determined resources for migration of <b>software</b> <b>component</b> of hardware platform (104 - 1) are obtained on objective hardware platform is determined (114). The <b>software</b> <b>component</b> of hardware platform is migrated (116) on objective hardware platform at predetermined point of time. Independent claims are included for the following: (1) computer program for migrating <b>software</b> <b>component</b> of distributed embedded system; and (2) control device for controlling migration <b>software</b> <b>component</b> of distributed embedded system...|$|R
50|$|The {{concept of}} the NWDI starts with a product and a <b>software</b> <b>component</b> (SC). The normal case {{is to have a}} {{one-to-one}} relationship between product and <b>software</b> <b>component,</b> one product is being developed and the relations between the components comprising the product are kept within a <b>software</b> <b>component.</b>|$|R
40|$|The paper {{presents}} a <b>software</b> <b>component</b> that enables NetSolve with direct communications between servers in a non-intrusive and incremental way. Non-intrusiveness {{means that the}} <b>software</b> <b>component</b> is supplementary, working {{on top of the}} original system, which does not change at all. Increment means that the <b>software</b> <b>component</b> {{does not have to be}} installed on all computers to enable applications with the new feature. It can be done incrementally, step by step, and the new feature will be enabled in part, with the completeness dependent on how many nodes have been upgraded with the <b>software</b> <b>component.</b> The paper describes the design and implementation of the <b>software</b> <b>component.</b> The paper also reports on experiments with three typical scientific NetSolve applications having different communication structures: (i) protein tertiary structure prediction, (ii) image processing using sequential algorithms, and (iii) the matrix chain product. The presented experimental results show that the performance of these Grid applications can be easily and significantly improved by using the proposed supplementary <b>software</b> <b>component.</b> ...|$|R
25|$|A {{representation}} of a system, including a mapping of functionality onto hardware and <b>software</b> <b>components,</b> a mapping of the software architecture onto the hardware architecture, and human interaction with these components.|$|E
25|$|Internet resources, hardware, and <b>software</b> <b>components</b> are {{the target}} of {{criminal}} or malicious attempts to gain unauthorized control to cause interruptions, commit fraud, engage in blackmail or access private information.|$|E
25|$|OpenBSD {{includes}} {{a number of}} third-party <b>software</b> <b>components,</b> many with OpenBSD-specific patches; examples include the X.Org Server, GNU Compiler Collection (which acts as the default compiler), Perl, NSD, Unbound, Ncurses, GNU Binutils, GNU Debugger and Awk.|$|E
40|$|A {{search engine}} for <b>software</b> <b>component</b> helps {{developers}} to reuse <b>software</b> <b>component</b> {{and to understand}} its behavior. We are studying about a <b>software</b> <b>component</b> search engine and constructs SPARS-J for Java source codes. SPARS-J provides useful information obtained by static analysis of source codes in a repository. However, we also consider that SPARS-J provides more useful information by using the analysis result of its retrieval history. In this paper, we suggest a recommendation method by using collaborative filtering technique, and evaluated {{the effectiveness of the}} system implemented of SPARS-J Keywords: <b>Software</b> <b>Component,</b> <b>Software</b> Retrieve, Collaborative Filtering...|$|R
50|$|In {{computer}} programming, {{a third-party}} <b>software</b> <b>component</b> is a reusable <b>software</b> <b>component</b> developed {{to be either}} freely distributed or sold by an entity other than the original vendor of the development platform. The third-party <b>software</b> <b>component</b> market thrives because many programmers believe that component-oriented development improves the efficiency {{and the quality of}} developing custom applications. Common third-party software includes macros, bots, and software/scripts to be run as add-ons for popular developing software.|$|R
50|$|A <b>software</b> <b>component</b> {{comprises}} {{one or more}} development components (DC). A development component {{consists of}} a normal project created with the Netweaver Developer Studio, i.e. a Dynpro application. The <b>software</b> <b>component</b> can also have dependencies to other SCs.|$|R
25|$|Pathak, J., Caragea, D., and Honavar, V. Ontology-Extended Component-Based Workflows: A Framework for Constructing Complex Workflows from Semantically Heterogeneous <b>Software</b> <b>Components.</b> VLDB-04 Workshop on Semantic Web and Databases. Springer-Verlag Lecture Notes in Computer Science., Toronto, Springer-Verlag. Vol. 3372. pp.41–56, 2004.|$|E
25|$|SeaMonkey (formerly the Mozilla Application Suite) is a {{free and}} open source cross {{platform}} suite of Internet <b>software</b> <b>components</b> including a web browser component, a client for sending and receiving email and Usenet newsgroup messages, an HTML editor (Mozilla Composer) and the ChatZilla IRC client.|$|E
25|$|Reconfigurable Manufacturing Systems: a {{production}} system designed {{at the outset}} for rapid change in its structure, {{as well as its}} hardware and <b>software</b> <b>components,</b> in order to quickly adjust its production capacity and functionality within a part family in response to sudden market changes or intrinsic system change.|$|E
50|$|BS 7925-2 is BSI's <b>software</b> <b>component</b> testing standard.|$|R
40|$|An {{evaluation}} of the compatibility of a <b>software</b> <b>component</b> is based typically only on a vendor’s presentation. This means that end users select a <b>software</b> <b>component</b> only based on high-level matches of functional requirements. This can result in an underestimation of the actual cost and effort required for integration of the new <b>software</b> <b>component</b> with existing components. In this paper, we provide a suitability measure that can help determine the actual integration efforts. The measure, which is built upon typical semantic similarity measures, attempts to quantify compatibility by focusing on information exchange requirements. 1...|$|R
40|$|To {{select a}} <b>software</b> <b>component</b> from several similar {{candidates}} {{is a complex}} task, since each project pursues different objectives. We intend to use the Analytic Hierarchy Process in the taking of multicriteria decisions for <b>software</b> <b>component</b> reuse. This method is called BAREMO. It will help the software engineer to make estimations which will enable him/her to choose the appropriate component. The article presents {{a case study of}} the application of the method, where a project manager assesses a certain <b>software</b> <b>component</b> in order to consider its reuse in the domain of image processing...|$|R
25|$|Play Store filters {{the list}} of apps to those {{compatible}} with the user's device. Developers can target specific hardware components (such as compass), <b>software</b> <b>components</b> (such as widget), and Android versions (such as 7.0 Nougat). Carriers can also ban certain apps from being installed on users' devices, for example tethering applications.|$|E
25|$|The trusted {{computing}} base (TCB) of {{a computer}} system is the set of all hardware, firmware, and/or <b>software</b> <b>components</b> that are critical to its security, {{in the sense that}} bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system. By contrast, parts of a computer system outside the TCB must not be able to misbehave {{in a way that would}} leak any more privileges than are granted to them in accordance to the security policy.|$|E
25|$|One of the {{elements}} of the package will be the software package. The software package is a package in itself, because it consists of the different <b>software</b> <b>components</b> that together form the product. In contrast with the overall package, the software package is always a technical package in which all the files needed are combined in order to run the software product. Another concept of the software package is the version. This keeps track of the modifications made to the software product. By relating it to the software package the vendor and the customer are able {{to keep track of the}} functionality and properties of the product the customer is using.|$|E
40|$|The CADAT system {{consists}} {{of a number of}} computer programs written in FORTRAN that provide the capability to simulate, lay out, analyze, and create the artwork for large scale microelectronics. The function of each <b>software</b> <b>component</b> of the system is described with references to specific documentation for each <b>software</b> <b>component...</b>|$|R
40|$|Abstract. A <b>software</b> <b>component</b> model should {{define what}} {{components}} are, {{and how they}} can be composed. That is, it should define a theory of components and their composition. Current <b>software</b> <b>component</b> models tend to use objects or port-connector type architectural units as components, with method calls and port-to-port connections as composition mechanisms. However, these models do not provide a proper composition theory, in particular for key underlying concepts such as encapsulation and compositionality. In this paper, we outline our notion of these concepts, and give a preliminary formalisation of a <b>software</b> <b>component</b> model that embodies these concepts. ...|$|R
40|$|In {{relation}} to <b>software</b> <b>component</b> reuse and object oriented analysis design (OOAD), {{this paper presents}} an overview of software reuse, including the history of software reuse, current state, development and benefit and constraints. On {{the second part of}} the paper, a discussion of the relevance of <b>software</b> <b>component</b> reuse and Object Oriented and Analysis Design in terms of opportunities and challenge is given. After that, there is a provision of some general guidelines on when and how reusable components could be identified and developed. Toward the end, the paper discusses strategies and future directions of software engineering in {{relation to}} <b>software</b> <b>component</b> reuse...|$|R
25|$|In {{order to}} deliver the {{developed}} product to the customer, the vendor needs to package the different components of its product into a package. By doing this, the customer will receive all the information and <b>software</b> <b>components</b> at once fulfilling all its needs. After combining all elements into one package the software vendor will carefully have to check if the package is complete. The package will have to provide the customer with all the tools and information to use the product. When {{this is not the}} case the software vendor will get a lot of questions from its customers which will consume a lot of time. It is therefore very important that the package is checked carefully before it is shipped. The package can be a physical combination of different elements packed into for example a box, but it can also be a digital combination of files which contain all the elements. Within the CCU process it is stated that a package will consist of five elements, being: software package, system description, manual, and license and management information. In the following paragraphs is explained how these elements fit into the CCU delivery phase.|$|E
500|$|The {{multiplayer}} [...] "Storyteller" [...] mode {{was conceived}} {{early in the}} development cycle. Diverting from the typical death match or co-operative gameplay multiplayer modes, Storyteller required Nihilistic to develop an interface that could give one player, the Storyteller, enough control to run a particular scenario, and change events in the game in real time without making it too complex to understand for the average player. Much of the technology was simple to implement, requiring typical multiplayer <b>software</b> <b>components</b> that would allow users to connect with each other. The largest task required {{the development of an}} interface that could provide the Storyteller with control over the aspects of a multiplayer game without it becoming too complex. The interface had to contain lists of objects, characters, and other resources, and options to manipulate those resources. It had to be mostly accessible using a mouse as input, reserving the keyboard for less common and more advanced commands. The mode was inspired by the text-based Multi-User Dungeon, a multiplayer real-time virtual world in which high-ranking users can manipulate the game's environment and dynamically create adventures.|$|E
2500|$|Hardware, OS, middleware, <b>software</b> <b>components</b> and {{database}} independence ...|$|E
40|$|The fast {{growth of}} {{high-bandwidth}} wide-area networks has encouraged {{the development of}} computational grids. To deal with the increasing complexity of grid applications, the <b>software</b> <b>component</b> technology seems very appealing since it emphasizes software composition and re-use. However, current <b>software</b> <b>component</b> models only support explicit data transfers between components. The distributed shared memory paradigm has demonstrated its utility by enabling a transparent access to data via a globally shared data space. This paper proposes to extend <b>software</b> <b>component</b> models with shared memory capabilities, enabling transparent access to shared data across components and leading to further decreased software complexity...|$|R
50|$|Constraint {{analysis}} {{evaluates the}} design of a <b>software</b> <b>component</b> against restrictions imposed by requirements and real-world limitations. The design must be responsive to all known or anticipated restrictions on the <b>software</b> <b>component.</b> These restrictions may include timing, sizing, and throughput constraints, input and output data limitations, equation and algorithm limitations, and other design limitations.|$|R
5000|$|Free Component Library (FCL): High-level <b>software</b> <b>component</b> {{library for}} general {{programming}} tasks ...|$|R
2500|$|When {{the user}} clicks the [...] "Install" [...] button {{in a typical}} MSI {{installation}} wizard, installation proceeds to the Execute phase, in which <b>software</b> <b>components</b> are actually installed. The Execute phase makes system changes, {{but it does not}} display any user interface elements.|$|E
2500|$|A library portal {{is defined}} as [...] "a {{combination}} of <b>software</b> <b>components</b> that unify the user experience of discovering and accessing information" [...] {{in contrast to a}} [...] "single technology" [...] to provide [...] "services that support discovery, access and effective use of information." ...|$|E
2500|$|The 4D-RCS Reference Model Architecture is a {{reference}} model for military unmanned vehicles {{developed by the}} NIST, which describes how <b>software</b> <b>components</b> of military unmanned vehicles should be identified and organized. Albus has extended the reference model to a cognitive architecture for Intelligent Multi-Agent Systems. Albus (2009) described: ...|$|E
40|$|This paper {{discusses}} {{the problem of}} characterizing a <b>software</b> <b>component,</b> which is essential to understand what components are {{and how they can}} be classified. First, we classify what should be characterized about a component into three categories: Informal Descriptions, Internals, and Externals. Then, using this classification, we derive a set of features to characterize a <b>software</b> <b>component.</b> Introduction CBSE is emerging as a beneficial software development paradigm because it delivers on many of the promises of software reuse. Many would refer to components as Javabeans, CORBA or DCOM objects [12, 4], other would refer to components as fragments of source code or a functional procedure. Several definitions of a <b>software</b> <b>component</b> have emerged. A component can be considered an independent replaceable part of the application that provides a clear distinct function [1]. A <b>software</b> <b>component</b> is a unit of composition, with pre-defined dependencies on other components [13]. Business [...] ...|$|R
5000|$|JESAM: Open source {{parallel}} scalable DNA alignment engine with optional clustering <b>software</b> <b>component</b> ...|$|R
50|$|The Dulwich {{implementation}} of Git {{is a pure}} Python <b>software</b> <b>component</b> for Python 2.|$|R
