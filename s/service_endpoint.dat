29|109|Public
50|$|The <b>service</b> <b>endpoint</b> URL that accepts JSON-WSP POST request objects.|$|E
50|$|In {{contrast}} to a remote interface, a Web <b>service</b> <b>endpoint</b> interface is not accompanied by a home interface, which defines the bean's life-cycle methods. The only methods of the bean that may be invoked by a Web service client are the business methods that are defined in the Web <b>service</b> <b>endpoint</b> interface.|$|E
5000|$|A web <b>service</b> <b>endpoint</b> that {{presents}} three web services: InvoiceCreate, InvoiceSearch, and InvoiceDetailGet ...|$|E
5000|$|The {{other main}} purpose of XRDS {{documents}} is to assert the services associated with a resource, called <b>service</b> <b>endpoints</b> or SEPs. For instance, the example XRDS document above asserts four <b>service</b> <b>endpoints</b> for the represented resource: ...|$|R
5000|$|Web <b>Services</b> <b>Endpoint</b> Language (WSEL) was an XML format {{proposed}} {{to be used}} to description of non-operational characteristics of <b>service</b> <b>endpoints,</b> such as quality-of-service, cost, or security properties. Format was proposed as a part of report which published Web Service Flow Language [...] It never gained wide acceptance.|$|R
5000|$|OAuth {{discovery}} for locating OAuth <b>service</b> <b>endpoints</b> and capabilities.|$|R
5000|$|A soap based {{web service}} can be {{implemented}} as a single java class.An endpoint interface, {{also known as a}} <b>service</b> <b>endpoint</b> interface (SEI), is a term used in Java Platform, Enterprise Edition when exposing Enterprise JavaBeans as a Web service (see also Service Implementation Bean (SIB)). It is annotated with [...] and is a component interface, which declares all the abstract methods that are exposed to the client. As it extends the [...] interface, all methods must throw the [...] A Web service client accesses a stateless session bean through the bean's Web <b>service</b> <b>endpoint</b> interface. Like a remote interface, a Web <b>service</b> <b>endpoint</b> interface defines the business methods of the bean.|$|E
50|$|Publishing a Web service {{involves}} {{creating a}} software artifact {{and making it}} accessible to potential consumers. Web Service Providers augment a Web <b>service</b> <b>endpoint</b> with an interface description using the Web Services Description Language (WSDL) so that a consumer can use the service.|$|E
50|$|A Service Implementation Bean (SIB), is a {{term used}} in Java Platform, Enterprise Edition, for a Java object {{implementing}} a web service. It can be either a POJO or a Stateless Session EJB. The Java interface of an SIB is called a <b>Service</b> <b>Endpoint</b> Interface (SEI).|$|E
5000|$|The XDI {{data sharing}} {{protocol}} for discovery of XDI <b>service</b> <b>endpoints</b> and capabilities.|$|R
50|$|For full {{details of}} XRDS <b>service</b> <b>endpoints,</b> see XRI Resolution 2.0, Sections 4.2 and 13.|$|R
50|$|Domains {{are created}} on a domain server to {{represent}} {{each of the}} service domains provided by that server. Service Groups are created to contain <b>services</b> <b>endpoints.</b> These endpoints can therefore be grouped together to ease the process of sharing.|$|R
50|$|Web Services Addressing (WS-Addressing) is a {{specification}} of transport-neutral mechanism that allows web services to communicate addressing information. It essentially {{consists of two}} parts: a structure for communicating {{a reference to a}} Web <b>service</b> <b>endpoint,</b> and a set of message addressing properties which associate addressing information with a particular message.|$|E
50|$|SADI (Semantic Automated Discovery and Integration) is a Semantic Web Service {{initiative}} {{that consists of}} a set of design-practices for Semantic Web Service publishing that minimizes the use of non-standard protocols and message structures. SADI Services natively consume data in RDF Resource Description Framework format, where input and output data must be instances of (OWL Individuals of) input and output Classes defined in OWL-DL. Unlike canonical Web Services, SADI Services do not use the SOAP messaging protocol, and unlike SSWAP, SADI services have no project-specific messaging scaffold; services are invoked by passing RDF instance data to the <b>Service</b> <b>endpoint</b> through HTTP POST, and multiplexing is achieved by sending more than one OWL Individual in the HTTP POST invocation. SADI imposes a single constraint on the behavior of the Service: that the URI of the output individual must be the same as the URI of the corresponding input individual. In practice, this results in Services that create semantic linkages between the input and output of the service. Thus, chaining SADI services together into a workflow results in an uninterrupted Linked Data graph.|$|E
30|$|GetSensorParameters and GetOrganizationParameters results both {{include the}} organization’s {{parameter}} IDs {{for use in}} querying data by parameter directly from the organization’s <b>service</b> <b>endpoint.</b> The catalog harvests metadata from registered organizations’ service endpoints daily.|$|E
5000|$|The {{controller}} {{manager is}} the process that the core Kubernetes controllers like DaemonSet Controller and Replication Controller run in. The controllers communicate with the API server to create, update and delete the resources they manage (pods, <b>service</b> <b>endpoints,</b> etc.) ...|$|R
5000|$|Message Interceptor Gateway pattern shows {{a single}} entry point {{solution}} for centralization of security enforcement for incoming and outgoing XML Web Service messages. It helps to apply transport-level and message-level security mechanisms required for securely communicating with a Web <b>services</b> <b>endpoint.</b>|$|R
5000|$|With {{the release}} of the [...]NET Framework 3.5 in November 2007, Microsoft {{released}} an encoder that added support for the JSON serialization format to WCF. This allows WCF <b>service</b> <b>endpoints</b> to <b>service</b> requests from AJAX-powered Web pages which only accept JSON.|$|R
40|$|A Web service (WS*-) is a {{software}} {{system designed to}} support interoperable machine-to-machineinteraction over a network (WSDL) i. e between a client and a service. It has an interface described in amachine-processable format. Other systems interact with the Web service in a manner prescribed by itsdescription using SOAP messages which is a protocol define by world wide web consortium, typicallyconveyed using HTTP with an XML serialization {{in conjunction with other}} Web-related standards. WindowsCommunication Foundation (WCF) is a framework for building service-oriented applications. Using WCF,you can send data as asynchronous messages from one <b>service</b> <b>endpoint</b> to another. A <b>service</b> <b>endpoint</b> canbe part of a continuously available service hosted by IIS, or it can be a service hosted in an application likean. exe file. An endpoint can be a client of a service that requests data from a <b>service</b> <b>endpoint.</b> The messagescan be as simple as a single character or word sent as XML document, or as complex as a stream of binarydata. In this paper,We gave the Adavantages that are Available by using wcf,instead of webservices andother...|$|E
30|$|Finally, PROV-AQ (Provenance Access and Query) [55] is a W 3 C {{standard}} specification proposed {{to obtain the}} information about provenance on the Web. The specification introduces mechanisms for accessing and querying provenance. Specifically, it elaborates on a protocol based on HTTP (Hypertext Transfer Protocol) for provenance access and on how to locate a SPARQL <b>service</b> <b>endpoint.</b> But it seems that not many follow-up works use PROV-AQ yet.|$|E
40|$|Web Services {{technology}} enables organisations {{to exploit}} software as a service. Services are accessed by method invocations. Method interfaces are described and published, {{and may be}} freely available. In Web Services environments, access control is required to cross the borders of security domains, to be implemented between heterogeneous systems. Interaction is between remotely located parties who may know little about each other. Access control generally assumes that identity is established. To overcome the limitations of identity-based solutions, domain-independent access control information is added to a message. As a Web <b>Service</b> <b>endpoint</b> is required to integrate such information into its access control decision-making process, issues arise such as; whom to accept access control information from; what the format of such information must be; how to inform the requestor of the format; and how to give access to methods based on presented access control information. To address such issues, a logic-based access control approach is defined for a Web <b>Service</b> <b>endpoint.</b> A logic-based authorization manager is described, that provides a formal foundation of logical reasoning, to enable the enforcement of consistent access control decisions over the resources of Web Services...|$|E
50|$|Echo {{performs}} {{well with}} a 'good' (low latency) Internet connection which minimizes processing time due to minimal communication round trips, streamable responses and geo-distributed <b>service</b> <b>endpoints.</b> While the app is free, an Amazon account is required, and setup is not possible without one.|$|R
50|$|WS-MetaDataExchange is a web {{services}} protocol specification, published by BEA Systems, IBM, Microsoft, and SAP. WS-MetaDataExchange {{is part of}} theWS-Federation roadmap; and is designed to work in conjunction with WS-Addressing, WSDL and WS-Policy to allow retrieval of metadataabout a Web <b>Services</b> <b>endpoint.</b>|$|R
40|$|Describes {{how to use}} Composite Application Validation System {{initiators}} and simulators to test AIA service integrations. Test initiators simulate service invocations and simulators simulate <b>service</b> <b>endpoints.</b> Describes how to use {{error handling}} and logging components, including error notifications and trace and error logs, to support service...|$|R
40|$|Abstract—Service Oriented Architecture {{perfectly}} {{manifests itself}} in Web services, which create seamless and looselycoupled interactions. Web service utilizes supportive functionalities such as security, reliability and so on. These functionalities are called as handlers, which incrementally add new capabilities. However, adding new handlers into the execution path may cause performance and scalability problems. Distribution of handlers solves these problems by providing abundant computing resources. However, pulling a handler out of its native place and positioning it away from Web <b>service</b> <b>endpoint</b> brings additional costs. Hence, we will investigate the overhead of handler distribution for various environments...|$|E
30|$|CopperEgg [92] is a {{monitoring}} as {{a service}} tool which provides server, EC 2, database and website monitoring. CopperEgg is similar to New Relic and other SaaS monitoring tools in that it utilises a small monitoring agent to push state from monitored hosts to a <b>service</b> <b>endpoint.</b> CopperEggs most notable unique feature is integration with numerous current tools including Redis, MongoDB, Chef, PostresQL, MySQL and Apache. Thus, unlike New Relic, CopperEgg is capable of providing a significant range of application monitoring metrics in addition to more basic resource usage metrics. CopperEgg provides an intuitive web front end for interrogating monitoring data which surpasses the available interfaces of most non SaaS tools.|$|E
30|$|A {{very recent}} {{development}} is monitoring as a service: SaaS applications that abstract {{much of the}} complexity of monitoring away from the user. This class of monitoring tool, presumably, makes use of similar architectures to existing tools but introduces a novel separation of concerns between where data is generated and where it is collected. In these systems a users installs a small agent which periodically pushes monitoring state to a <b>service</b> <b>endpoint,</b> all functionality beyond that is the prerogative of the monitoring provider. This alleviates complexity on behalf of the user but exacerbates the complexity of the service provider who must provide multi-tenanted monitoring services.|$|E
30|$|In {{the past}} the problem of web service {{discovery}} has been addressed by primarily two approaches. The first approach uses a centralized registry, which is updated by the service providers [2]. The second approach uses crawling algorithms which harvest search engine application programming interfaces (APIs), such as the Google search API, {{in order to obtain}} standard web map <b>services</b> <b>endpoints</b> [1, 3, 4].|$|R
50|$|The Feature pack {{provides}} a GUI interface within Business Space {{in which such}} domains can be accessed. <b>Service</b> <b>endpoints</b> can then be grouped for sharing. The groups can then be shared between domains in a federation. Additional qualities of service can be added by defining service proxies that are automatically deployed {{as part of the}} operation of creating a share.|$|R
5000|$|... {{provides}} {{ability to}} invoke and consume {{a variety of}} data services. These data services may be REST, RSS/ATOM, or SOAP services. [...] also supports Web clipping by allowing HTML pages to be specified as <b>service</b> <b>endpoints.</b> , , , and [...] protocols are supported in [...] HTTP Header and cookie support is also available thus providing capability to consume {{a wide variety of}} REST/SOAP Web services. It is possible to use [...] with a proxy server.|$|R
30|$|Dynamicity of {{attribute}} values can {{be modeled}} in our capability meta-model with constraints or data-fetching endpoints. There are various reasons to have dynamic attribute {{values in the}} service description, e.g.: attribute inter-dependency, inherent dynamicity and etc. Modeling the dynamicity empowers us to derive capability offers at run-time with information unavailable at design time. We leverage the datafetching technique described in [14] to retrieve dynamic information and create service offers. We distinguish between conditional values and dynamic values. Conditions and constraints are expressed with SPARQL query segments and dynamic values will give an <b>service</b> <b>endpoint</b> as an access point for datafetching. During service discovery phase the discovery engine will use the SPARQL segments and URIs to construct semantic descriptions for the service offers and match them against search requests.|$|E
40|$|SOAP/WSDL and REST are two {{architectural}} {{styles to}} build web services. SOAP/WSDL follows operation centric and REST follows resource centric approach. SOAP/WSDL has standard registry where producer can register service specification and consumer can discover <b>service</b> <b>endpoint</b> using UDDI. Recently RESTful web service gained momentum in development of distributed application and research community already started discussion about RESTful based Service Oriented Architecture(SOA) {{but there is}} no standard central repository exist where producer can register and consumer can search RESTful service based on Quality of Services or based on their specification. In this research paper, we proposed framework: XML based RESTRegistry – central repository with Quality of Service through which producer can easily register services and consumer can search it easily. We also developed Travel Schedule benchmark application to test proposed framework in real world...|$|E
40|$|This {{specification}} (WS-MakeConnection) {{describes a}} protocol that allows messages {{to be transferred}} between nodes implementing this protocol by using a transport-specific back-channel. The protocol is described in this specification in a transport-independent manner allowing it to be implemented using different network technologies. To support interoperable Web services, a SOAP binding is defined within this specification. The protocol defined in this specification depends upon other Web services specifications for the identification of <b>service</b> <b>endpoint</b> addresses and policies. How these are identified and retrieved are detailed within those specifications and are out of scope for this document. By using the XML [XML], SOAP [SOAP 1. 1], [SOAP 1. 2] and WSDL [WSDL 1. 1] extensibility model, SOAP-based and WSDL-based specifications {{are designed to be}} composed with each other to define a 3...|$|E
50|$|This release added {{improved}} UI Business Space widgets, allowing sophisticated configuration. Report hosting {{and activity}} monitoring {{can now be}} done from the UI. Full text search capability (based on Apache Lucene technology) is now included. The WSRR studio configuration tool has additional functionality to make configuration quicker including click to assign lifecycles, an access control editor and governance policy authoring. Upgrade performance has been improved. SCA <b>Service</b> <b>endpoints</b> {{have been added to}} allow governance of SCA endpoints.|$|R
30|$|Metadata are {{harvested}} into a centralized catalog {{that provides a}} REST Service API for sensor discovery. Users can discover data by querying for specific parameters, or using spatial boundaries such as HUC, county, a buffered point, or a user defined polygon. The sensor results are returned as GeoJSON, {{which can be used}} to create maps. The API also provides the <b>service</b> <b>endpoints</b> for the sensors, which can be used to access the continuous data to create charts or download the data for other analysis.|$|R
40|$|Advances in the Internet and {{telecommunications}} technologies have spurred many research efforts in integrated communication systems which integrate heterogeneous devices (such as desktop phone, cellular phone, PSTN phone or pager) and networks (like the Public Switch Telephone Network, cellular networks, or the pager networks) {{on top of}} the Internet and enables communications among any devices or <b>service</b> <b>endpoints.</b> In this paper, we explore the service creation model and framework for such a system, which allows easy, flexible and rapid communication service customization and extension...|$|R
