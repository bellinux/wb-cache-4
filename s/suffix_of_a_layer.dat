0|10000|Public
50|$|<b>A</b> <b>suffix</b> <b>of</b> <b>a</b> string is any {{substring}} of {{the string}} which includes its last letter, including itself. <b>A</b> proper <b>suffix</b> <b>of</b> <b>a</b> string is not {{equal to the}} string itself. A more restricted interpretation {{is that it is}} also not empty. A suffix can be seen as <b>a</b> special case <b>of</b> <b>a</b> substring.|$|R
50|$|Suffix array: Represents the lexicographic rank <b>of</b> each <b>suffix</b> <b>of</b> <b>an</b> array.|$|R
5000|$|<b>A</b> <b>suffix</b> <b>of</b> <b>a</b> {{lower-case letter}} a, b, or c {{indicates}} increasingly unsymmetrical isomers.|$|R
40|$|In {{this paper}} we {{describe}} a "light" algorithm for the on-line construction <b>of</b> <b>a</b> small automaton recognising <b>a</b> finite set <b>of</b> words. The algorithm runs in linear time. We carried out good experimental {{results on the}} <b>suffixes</b> <b>of</b> <b>a</b> text, showing how this automaton is small. For the <b>suffixes</b> <b>of</b> <b>a</b> text, we propose a modified construction that leads to an even smaller automaton...|$|R
40|$|This paper gives a linear-time {{algorithm}} for {{the construction}} <b>of</b> the <b>suffix</b> tree <b>of</b> <b>a</b> tree. The <b>suffix</b> tree <b>of</b> <b>a</b> tree is used to obtain an efficient algorithm for the minimization of sequential transducers. 1 Introduction The <b>suffix</b> tree <b>of</b> <b>a</b> string is a compact trie representing all <b>suffixes</b> <b>of</b> the string. The suffix tree {{has proven to be}} an extremely useful data structure in <b>a</b> wide variety <b>of</b> string processing algorithms [3, 6]. Kosaraju [10] defined the generalized <b>suffix</b> tree <b>of</b> all <b>suffixes</b> <b>of</b> <b>a</b> set <b>of</b> strings which are represented by a tree. Kosaraju mentions that Weiner's [14] suffix tree construction algorithm can be easily modified to construct the <b>suffix</b> tree <b>of</b> <b>a</b> tree in O(n log n) time, and that it might even be possible to do so in O(n) time. In this paper we give an O(n) time algorithm {{for the construction}} <b>of</b> the <b>suffix</b> tree <b>of</b> <b>a</b> tree, if the input symbols are drawen from a constant size alphabet. We then use the new suffix tree construction algorithm in the minimizat [...] ...|$|R
5000|$|In {{many parts}} of England, [...] "borough" [...] is {{pronounced}} [...] as an independent word, and as [...] when <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> place-name. As a suffix, it is sometimes spelled [...] "-brough".|$|R
40|$|AbstractThis paper gives a linear-time {{algorithm}} for {{the construction}} <b>of</b> the <b>suffix</b> tree <b>of</b> <b>a</b> tree, which was introduced by Kosaraju, as <b>a</b> natural generalization <b>of</b> the <b>suffix</b> tree <b>of</b> <b>a</b> string. The <b>suffix</b> tree <b>of</b> <b>a</b> tree is used to obtain an efficient algorithm for the minimization of sequential transducers...|$|R
50|$|Kodacolor {{was also}} {{available}} in Type A, balanced for 3400K photolamps. <b>A</b> <b>suffix</b> <b>of</b> <b>A</b> on the type number indicated Type A, such as C828A.|$|R
25|$|The word is used {{together}} as <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> numeral indicating the number <b>of</b> <b>a</b> pagoda's tiers (three tiers= san-jū-no-tō, five tiers= go-jū-no-tō, seven tiers = nana-jū-no-tō, etc.).|$|R
40|$|The notion <b>of</b> <b>a</b> self-insertion <b>of</b> <b>a</b> data graph {{yields a}} simple and natural {{definition}} <b>of</b> <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> data graph. For addressable data graphs, addressing schemes yield a useful alternative definition <b>of</b> <b>suffix,</b> which also suggests <b>a</b> generalized version <b>of</b> <b>suffix.</b> Examples <b>of</b> addressable data graphs and their suffixes include: trees and their subtrees, and arrays with their (possibly lower dimensional) subarrays. Thus a suffix {{can be viewed as}} a highly structured type <b>of</b> substructure <b>of</b> <b>a</b> data graph. Necessary and sufficient conditions for <b>a</b> <b>suffix</b> <b>of</b> <b>an</b> addressable data graph to be addressable are derived. It is further shown that suffix data graphs, even when not addressable, often enjoy a slightly weaker property termed quasi-addressability; in fact <b>suffixes</b> <b>of</b> so-called deep-rooted data graphs are always quasi-addressable...|$|R
40|$|We {{present a}} linear time {{algorithm}} to sort all the <b>suffixes</b> <b>of</b> <b>a</b> string over <b>a</b> large alphabet <b>of</b> integers. The sorted order <b>of</b> <b>suffixes</b> <b>of</b> <b>a</b> string is also called suffix array, a data structure introduced by Manber and Myers that has numerous applications in computational biology. Though the <b>suffix</b> tree <b>of</b> <b>a</b> string {{can be constructed}} in linear time and the sorted order <b>of</b> <b>suffixes</b> derived from it, a direct algorithm for <b>suffix</b> sorting is <b>of</b> great interest due to the space requirements <b>of</b> <b>suffix</b> trees. Our result improves upon the best known direct algorithm for suffix sorting, which takes O(n log n) time. We also show how to construct suffix trees in linear time from our suffix sorting result. Apart from being simple and applicable for alphabets not necessarily of fixed size, this method <b>of</b> constructing <b>suffix</b> trees is more space efficient. ...|$|R
40|$|Abstract. We {{present a}} linear time {{algorithm}} to sort all the <b>suffixes</b> <b>of</b> <b>a</b> string over <b>a</b> large alphabet <b>of</b> integers. The sorted order <b>of</b> <b>suffixes</b> <b>of</b> <b>a</b> string is also called suffix array, a data structure introduced by Manber and Myers that has numerous applications in pattern matching, string processing, and computational biology. Though the <b>suffix</b> tree <b>of</b> <b>a</b> string {{can be constructed}} in linear time and the sorted order <b>of</b> <b>suffixes</b> derived from it, a direct algorithm for <b>suffix</b> sorting is <b>of</b> great interest due to the space requirements <b>of</b> <b>suffix</b> trees. Our result improves upon the best known direct algorithm for suffix sorting, which takes O(n log n) time. We also show how to construct suffix trees in linear time from our suffix sorting result. Apart from being simple and applicable for alphabets not necessarily of fixed size, this method <b>of</b> constructing <b>suffix</b> trees is more space efficient. ...|$|R
5000|$|Find {{for each}} <b>suffix</b> <b>of</b> <b>a</b> pattern , {{the length of}} the longest match between <b>a</b> prefix <b>of</b> [...] and <b>a</b> {{substring}} in [...] in [...] time. This is termed the matching statistics for [...]|$|R
40|$|AbstractWe {{present a}} linear time {{algorithm}} to sort all the <b>suffixes</b> <b>of</b> <b>a</b> string over <b>a</b> large alphabet <b>of</b> integers. The sorted order <b>of</b> <b>suffixes</b> <b>of</b> <b>a</b> string is also called suffix array, a data structure introduced by Manber and Myers that has numerous applications in pattern matching, string processing, and computational biology. Though the <b>suffix</b> tree <b>of</b> <b>a</b> string {{can be constructed}} in linear time and the sorted order <b>of</b> <b>suffixes</b> derived from it, a direct algorithm for <b>suffix</b> sorting is <b>of</b> great interest due to the space requirements <b>of</b> <b>suffix</b> trees. Our result {{is one of the}} first linear time suffix array construction algorithms, which improve upon the previously known O(nlogn) time direct algorithms for suffix sorting. It can also be used to derive a different linear time construction algorithm for suffix trees. Apart from being simple and applicable for alphabets not necessarily of fixed size, this method <b>of</b> constructing <b>suffix</b> trees is more space efficient...|$|R
50|$|In {{computer}} science, a suffix array is <b>a</b> sorted array <b>of</b> all <b>suffixes</b> <b>of</b> <b>a</b> string. It is a {{data structure}} used, among others, in full text indices, data compression algorithms {{and within the}} field of bibliometrics.|$|R
40|$|We {{present a}} {{parallel}} algorithm for lexicographically sorting the <b>suffixes</b> <b>of</b> <b>a</b> string. <b>Suffix</b> sorting has applications in string processing, data compression and computational biology. The ordered list <b>of</b> <b>suffixes</b> <b>of</b> <b>a</b> string stored in an array {{is known as}} Suffix Array, an important data structure in string processing and computational biology. Our focus is on deriving a practical implementation that works well for typical inputs rather than achieving the best possible asymptotic running-time for artificial, worst-case inputs. We experimentally evaluated our algorithm on an IBM SP- 2 using genomes of several organisms. Our experiments show that the algorithm delivers good, scalable performance. Keywords: Burrows-Wheeler transform, computational biology, suffix arrays, suffix trees. ...|$|R
5000|$|Prefix and suffix {{are special}} cases <b>of</b> {{substring}}. <b>A</b> prefix <b>of</b> <b>a</b> string [...] is <b>a</b> substring <b>of</b> [...] that {{occurs at the}} beginning <b>of</b> [...] <b>A</b> <b>suffix</b> <b>of</b> <b>a</b> string [...] is a substring that occurs {{at the end of}} [...]|$|R
50|$|The infinitive in Russian has the suffix -ть or -ти, or {{ends with}} -чь (but -чь is not <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> verb) (-ся/сь/ся {{respectively}} is added after it). It {{is the basic}} form <b>of</b> <b>a</b> verb for most purposes of study.|$|R
5000|$|A third usage, {{related to}} the second, is [...] "servant of God", [...] "devotee," [...] "votary" [...] or [...] "one who has {{surrendered}} to God"; dasa may be <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> given name to indicate a [...] "servant" [...] <b>of</b> <b>a</b> revered person or deity.|$|R
25|$|The <b>suffix</b> <b>of</b> <b>a</b> verbal complex can {{indicate}} one of {{the following}} eight categories: past actual punctual, past actual continuous or future positive continuous, past irrealis, present actual, present irrealis, future positive punctual, future negative, or imperative. Positive and irrealis forms require the potential prefix u-.|$|R
40|$|Blumer et al. showed (cf. [3, 2]) {{that the}} <b>suffix</b> {{automaton}} <b>of</b> <b>a</b> word w must {{have at least}} |w|+ 1 states and at most 2 |w|- 1 states. In this paper we characterize the language L of all binary words w whose minimal suffix automaton S(w) has exactly |w| + 1 states; they are precisely all prefixes of standard Sturmian words. In particular, we give <b>an</b> explicit construction <b>of</b> <b>suffix</b> automaton <b>of</b> words that are palindromic prefixes of standard words. Moreover, we establish a necessary and sufficient condition on S(w) which ensures that if w ∈ L and a ∈ { 0, 1 } then wa ∈ L. By using such a condition, we show how to construct the automaton S(wa) from S(w). More generally, we provide a simple construction that by starting from an automaton recognizing all <b>suffixes</b> <b>of</b> <b>a</b> word w over a finite alphabet A, allows to obtain an automaton that recognizes the <b>suffixes</b> <b>of</b> wa, <b>a</b> ∈ A...|$|R
50|$|Other Eastern Slavonic {{languages}} use {{the same}} adjectives of their literal translation, if they differ from Russian analogue. All the Eastern Slavonic languages are synthetic languages: therefore the grammar genders are used, which implies that the <b>suffix</b> <b>of</b> <b>an</b> adjective varies dependently on {{the sex of the}} recipient.|$|R
3000|$|For X = ABCB all prefixes are ∅, A, AB, ABC, ABCB and all {{possible}} suffixes are ∅,B,CB,BCB,ABCB. Empty string ∅∈∑^* [...] has length zero and is both prefix {{as well as}} <b>suffix.</b> Hence number <b>of</b> prefixes and <b>suffixes</b> <b>of</b> <b>a</b> string X is | X |. Given a string X all prefixes as well suffixes can be computed in time [...] |X| each. The ordered arrangement <b>of</b> all |X| <b>suffixes</b> <b>of</b> string X in a compact TRIE {{is known as the}} <b>suffix</b> tree T <b>of</b> X.|$|R
40|$|We {{propose a}} fast and memory {{efficient}} algorithm for sorting <b>suffixes</b> <b>of</b> <b>a</b> text in lexicographic order. It {{is important to}} sort suffixes because <b>an</b> arrayof indexes <b>of</b> <b>suffixes</b> is called suffix array {{and it is a}} memory efficient alternative <b>of</b> the <b>suffix</b> tree. Sorting suffixes is also used for the Burrows-Wheeler transformation in the Block Sorting text compression, therefore fast sorting algorithms are desired. We compar...|$|R
50|$|<b>A</b> <b>suffix</b> <b>of</b> (C) {{indicates}} <b>a</b> controlled cryptographic item.|$|R
40|$|AbstractWe {{propose a}} fast and memory-efficient {{algorithm}} for lexicographically sorting the <b>suffixes</b> <b>of</b> <b>a</b> string, {{a problem that}} has important applications in data compression as well as string matching. Our algorithm eliminates much of the overhead of previous specialized approaches while maintaining their robustness for degenerate inputs. For input size n, our algorithm operates in only two integer arrays of size n, and has worst-case time complexity O(nlogn). We demonstrate experimentally that our algorithm has stable performance compared with other approaches...|$|R
40|$|Sorting all the <b>suffixes</b> <b>of</b> <b>a</b> string x = x[1 [...] n] into {{lexicographical}} {{order is}} the most computationally expensive step in the Burrows-Wheeler Transformation for lossless compression [2]. One tool for achieving a suffix sort is the suffix array [12]. Suffix arrays are also the basis for <b>a</b> variety <b>of</b> compressed text indexing systems that allow arbitrary queries, fo...|$|R
40|$|International audienceIn {{this paper}} we {{describe}} a ''light'' algorithm for the on-line construction <b>of</b> <b>a</b> small automaton recognising <b>a</b> finite set <b>of</b> words. The algorithm runs in linear time. We carried out good experimental results on real dictionaries, on biological sequences {{and on the}} sets <b>of</b> <b>suffixes</b> (resp. factors) <b>of</b> <b>a</b> set <b>of</b> words that shows how our automaton is near to the minimal one. For the <b>suffixes</b> <b>of</b> <b>a</b> text, we propose a modified construction that leads to an even smaller automaton. We moreover construct linear algorithms for the insertion and deletion <b>of</b> <b>a</b> word in a finite set, directly from the constructed automaton...|$|R
5000|$|A {{substring}} (or factor) <b>of</b> <b>a</b> string [...] is {{a string}} , where [...] and [...] <b>A</b> substring <b>of</b> <b>a</b> string is <b>a</b> prefix <b>of</b> <b>a</b> <b>suffix</b> <b>of</b> the string, and equivalently <b>a</b> <b>suffix</b> <b>of</b> <b>a</b> prefix. If [...] is <b>a</b> substring <b>of</b> , {{it is also}} a subsequence, which is a more general concept. Given a pattern , you can find its occurrences in a string [...] with a string searching algorithm. Finding the longest string which is equal to <b>a</b> substring <b>of</b> two or more strings is known as the longest common substring problem.|$|R
50|$|<b>A</b> <b>suffix</b> <b>of</b> (P) {{indicates}} <b>a</b> plug in module or component <b>of</b> <b>a</b> system.|$|R
40|$|A suffix array {{represents}} the <b>suffixes</b> <b>of</b> <b>a</b> string in sorted order. Being a simpler and more compact alternative to suffix trees, {{it is an}} important tool for full text indexing and other string processing tasks. We introduce the skew algorithm for suffix array construction over integer alphabets that can be implemented to run in linear time using integer sorting as its only nontrivial subroutine:...|$|R
5000|$|Amirzade, the son ({{hence the}} Persian patronymic <b>suffix</b> -zade) <b>of</b> <b>a</b> prince, hence the Persian princely title Mirza.|$|R
3000|$|The finite state {{transducer}} (FST)-based morphological analyzer {{described in}} [16] is used here to identify suffixes. The analyzer generates the root morpheme and the <b>suffixes</b> <b>of</b> <b>a</b> given word. Both inflectional and derivational {{features of the}} morphemes are produced. Nominal features (case, person/number agreement, possessive agreement) and verbal features (tense, aspect, modality, and voice) are indicated with special tags. An example output of the morphological analyzer is [...]...|$|R
5000|$|In {{computer}} science, a suffix automaton or directed acyclic word graph is {{a finite}} automaton that recognizes the set <b>of</b> <b>suffixes</b> <b>of</b> <b>a</b> given string. It {{can be thought}} <b>of</b> as <b>a</b> compressed form <b>of</b> the <b>suffix</b> tree, <b>a</b> data structure that efficiently represents the <b>suffixes</b> <b>of</b> the string. For example, a suffix automaton for the string [...] "suffix" [...] can be queried for other strings; it will report [...] "true" [...] {{for any of the}} strings [...] "suffix", [...] "uffix", [...] "ffix", [...] "fix", [...] "ix" [...] and [...] "x", and [...] "false" [...] for any other string.|$|R
40|$|AbstractIt {{is shown}} how {{to compute the}} lexicographically maximum <b>suffix</b> <b>of</b> <b>a</b> string <b>of</b> n⩾ 2 {{characters}} over a totally ordered alphabet using at most (4 / 3) n− 5 / 3 three-way character comparisons. The best previous bound, which has stood unchallenged for more than 25 years, is (3 / 2) n−O(1) comparisons. We also prove <b>an</b> interesting property <b>of</b> <b>an</b> algorithm for computing the maximum suffix both {{with respect to a}} total order...|$|R
40|$|The {{comparison}} of genomes {{is based on}} substrings, called MUMs, that appear only once in each genome and are maximal. The set of MUMs determines the skeleton from which a global comparison can be established. The search of MUMs is handled with Suffix trees which are those trees that store all <b>suffixes</b> <b>of</b> <b>a</b> given sequence. The searching algorithm builds a generalized suffixtree for each pair and finds the MUMs between them. Postprint (published version...|$|R
