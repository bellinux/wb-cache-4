0|3006|Public
40|$|High-resolution, gamma- and X-my {{spectrometry}} {{are used}} routinely in nuclear materials safeguards vetication measurements. These measurements are mostly performed with high-purity germanium (HJ?Ge) detectors, which require cooling at liquid-nitrogen temperatures, thus limiting their utility in field and unattended safeguards measurement applications. Sodium iodide (NaI) scintillation detectors {{do not require}} cooling, but their energy resolution (10 % at 122 keV) is insu&ient for many verification measurements. Semiconductor detectors that operate at room temperatures, such as cadmium-zinc-telhuide (CZT) detectors, with energy resolution performance reaching 2. 0 % at 122 keV {{may be used for}} certain <b>safeguards</b> <b>verification</b> applications. We have developed hardware to utilize CZT detectors in X- and gamma-ray measurement, systems and software to apply such a system in measuring 215 U enrichment for <b>safeguards</b> <b>verification</b> purposes. The paper reports on the CZT detector-based measurement system and measurement results obtained with it. The paper also discusses work on additional improvements to broaden the applications of th...|$|R
40|$|The {{motivation}} for creating and verifying process plant models is briefly described. Verification is defined. <b>Verification</b> <b>techniques</b> for signed directed graphs models of process plants are detailed. Two case studies are presented {{to evaluate the}} <b>verification</b> <b>techniques.</b> A limitation with the verification is detailed...|$|R
40|$|There {{is a lack}} of {{sufficient}} understanding and realization of the importance of simulation model verification in the simulation community. The demands placed on the software which serves as a computer-executable representation of a simulation model are increasing. In the field of software engineering, there is an abundance of software <b>verification</b> <b>techniques</b> that are applicable for simulation model verification. This paper is intended to reduce the communication gap between the software engineering and simulation communities by presenting software <b>verification</b> <b>techniques</b> applicable for simulation model verification in a terminology understandable by a simulationist. A taxonomy of <b>verification</b> <b>techniques</b> is developed to guide the simulationist in selecting and using such techniques. Characteristics, advantages, and disadvantages of <b>verification</b> <b>techniques</b> under each category are described...|$|R
40|$|The {{presentation}} {{focuses on}} the verification of wired automotive buses and addresses the following topics: historical perspective of <b>verification</b> <b>techniques,</b> review of the different sets of messages and <b>verification</b> <b>techniques</b> along the development cycle, performance metrics and end-to-end constraints, early stage verification technique: schedulability analysis versus simulation...|$|R
5000|$|Biometrics System (Sensors, Integration, Data Analysis, <b>Verification</b> <b>Techniques)</b> ...|$|R
40|$|This paper {{presents}} {{a survey of}} the practical application of protocol <b>verification</b> <b>techniques</b> to applications in e­commerce. We concentrate in particular on logic­ based approaches, and review {{the current state of the}} art as well as the prospects for realistic deployment of protocol <b>verification</b> <b>techniques</b> in the near future...|$|R
40|$|Using <b>verification</b> <b>techniques</b> {{to prove}} the {{correctness}} of systems {{is becoming more and}} more important. Especially in the domain of embedded and distributed systems, verifica-tion techniques are increasingly being used for quality assurance today. Model checking is a <b>verification</b> <b>technique</b> that allows the automatic verification of systems with a finite stat...|$|R
5000|$|Formal {{design and}} <b>verification</b> <b>techniques</b> {{including}} a formal top-level specification ...|$|R
40|$|Verification of {{object-oriented}} programs {{relies on}} object invariants to express consistency criteria of objects. The semantics of object invariants is subtle, {{mainly because of}} call-backs, multi-object invariants, and subclassing. Several <b>verification</b> <b>techniques</b> for object invariants have been proposed. These techniques are complex and differ in restrictions on programs (for instance, which fields can be updated), restrictions on invariants (what an invariant may refer to), use of advanced type systems (such as ownership types), meaning of invariants (in which execution states are invariants assumed to hold), and proof obligations (when should an invariant be proven). As a result, {{it is difficult to}} compare and understand whether/why these techniques are sound, or to develop better techniques. In this paper, we develop a unified framework to describe <b>verification</b> <b>techniques</b> for object invariants. We separate type system concerns from verification strategy concerns. We distil seven parameters that characterise a <b>verification</b> <b>technique,</b> and identify sufficient conditions on these parameters under which a <b>verification</b> <b>technique</b> is sound. To illustrate the generality of our framework, we instantiate it with six <b>verification</b> <b>techniques</b> from the literature. We show how our framework facilitates the assessment and comparison of the soundness and expressiveness of these techniques. 1...|$|R
5000|$|Establishing a Special Committee of the IAEA Board of Governors on <b>safeguards</b> and <b>verification</b> to {{strengthen}} compliance and enforcement; and ...|$|R
40|$|This {{thesis is}} about {{scalable}} formal <b>verification</b> <b>techniques</b> for software. A <b>verification</b> <b>technique</b> is scalable {{if it is}} able to scale to reasoning about real (rather than synthetic or toy) programs. Scalable <b>verification</b> <b>techniques</b> are essential for practical program verifiers. In this work, we consider three key characteristics of scalability: precision, performance and automation. We explore trade-offs between these factors by developing <b>verification</b> <b>techniques</b> in the context of data-parallel programs, as exemplified by graphics processing unit (GPU) programs (called kernels). This thesis makes three original contributions to the field of program verification: 1. An empirical study of candidate-based invariant generation that explores the trade-offs between precision and performance. An invariant is a property that captures program behaviours by expressing a fact that always holds at a particular program point. The generation of invariants is critical for automatic and precise verification. Over a benchmark suite comprising 356 GPU kernels, we find that candidate-based invariant generation allows precise reasoning for 256 (72...|$|R
50|$|Loop {{unrolling}} is {{also part}} of certain formal <b>verification</b> <b>techniques,</b> in particular bounded model checking.|$|R
40|$|Ensuring the {{functional}} correctness of hardware {{early in the}} design cycle is crucial for both economic and method-ological reasons. However, current <b>verification</b> <b>techniques</b> are inadequate for industrial designs. Formal <b>verification</b> <b>techniques</b> are exhaustive but do not scale; partial ver-ification techniques based on simulation scale well but are not exhaustive. This paper discusses promising ap-proaches for improving the scalability of formal verifica-tion and comprehensiveness of partial verification. ...|$|R
40|$|Device {{drivers are}} {{notoriously}} hard {{to develop and}} even harder to debug. They are typically prone to many serious issues such as data races. In this paper, we present static pair-wise lock set analysis, a novel sound <b>verification</b> <b>technique</b> for proving data race freedom in device drivers. Our approach not only avoids reasoning about thread interleavings, but also allows the reuse of existing successful sequential <b>verification</b> <b>techniques...</b>|$|R
40|$|In this article, {{we propose}} an {{utterance}} <b>verification</b> <b>technique</b> for keyword spotting. The keyword spotting system analyzes a given spoken content and searches every speech segment {{in which one}} of pre-defined keywords is uttered. To maintain a stable recognition performance in the system, we propose an utterance <b>verification</b> <b>technique</b> that verifies whether a found utterance, or a candidate keyword segment, can be categorized as...|$|R
40|$|Object invariants {{define the}} {{consistency}} of objects. They have subtle semantics, mainly because of call-backs, multi-object invariants, and subclassing. Several <b>verification</b> <b>techniques</b> for object invariants have been proposed. It is difficult to compare these techniques, and to ascertain their soundness, because of their differences in restrictions on programs and invariants, {{in the use of}} advanced type systems (e. g., ownership types), in the meaning of invariants, and in proof obligations. We develop a unified framework for such techniques. We distil seven parameters that characterise a <b>verification</b> <b>technique,</b> and identify sufficient conditions on these parameters which guarantee soundness. We instantiate our framework with three <b>verification</b> <b>techniques</b> from the literature, and use it to assess soundness and compare expressiveness. peer-reviewe...|$|R
40|$|Model {{checking}} {{has been}} traditionally concerned on verifying a (critical) system against its speciﬁcation, {{which is generally}} expressed in temporal logic. Despite this <b>veriﬁcation</b> <b>technique</b> is mature, it becomes useless when the speciﬁcation incorporates vagueness, especially for the temporal constraints. This {{is often the case}} when non-critical adaptive systems are considered. These systems may tolerate small violations or may {{need to be aware of}} the satisfaction degree of their speciﬁcation for re-conﬁguration purposes. We present FTL (Fuzzy-time Temporal Logic), an extension of LTL that relaxes the notion of time, and propose a <b>veriﬁcation</b> <b>technique</b> to evaluate the truth degree of such vague temporal properties. Our <b>veriﬁcation</b> <b>technique</b> has been implemented in a prototype and the experimental results are promising...|$|R
40|$|Abstract—In this paper, {{we present}} a {{light-weight}} position <b>verification</b> <b>technique</b> for VANETs. Our technique supplements the received signal strength (RSSI) technique with a laser rangefinder to reduce the inaccuracy incurred in the RSSI. We used our new position <b>verification</b> <b>technique</b> to tighten the security in CASCADE (Cluster-based Accurate Syntactic Compression of Aggregated Data in VANETs) data aggregation technique. The proposed technique can detect any malicious vehicle sending false position information in less than 30 seconds and detects the GPS equipment malfunction in less than one minute with very few false positives, even under a low penetration rate. The incurred overhead due to using the position <b>verification</b> <b>technique</b> with CASCADE {{has been shown to}} be negligible. I...|$|R
40|$|Abstract. Object invariants {{define the}} {{consistency}} of objects. They have subtle semantics because of call-backs, multi-object invariants and subclassing. Several visible-state <b>verification</b> <b>techniques</b> for object invariants have been proposed. It is difficult to compare these techniques and ascertain their soundness because of differences in restrictions on programs and invariants, {{in the use of}} advanced type systems (e. g., ownership types), in the meaning of invariants, and in proof obligations. We develop a unified framework for such techniques. We distil seven parameters that characterise a <b>verification</b> <b>technique,</b> and identify sufficient conditions on these parameters which guarantee soundness. We instantiate our framework with three <b>verification</b> <b>techniques</b> from the literature, and use it to assess soundness and compare expressiveness. ...|$|R
40|$|Protocol {{and system}} {{designers}} use <b>verification</b> <b>techniques</b> to analyze a system's correctness properties. Network operators need <b>verification</b> <b>techniques</b> {{to ensure the}} "correct" operation of BGP. BGP's distributed dependencies cause small configuration mistakes or oversights to spur complex errors, which sometimes have devastating effects on global connectivity. These errors are often difficult to debug because they are sometimes only exposed by a specific message arrival pattern or failure scenario...|$|R
40|$|Four {{building}} {{energy analysis}} codes are compared using two direct gain building models with Madison TMY weather data. Hourly temperature profiles and annual {{heating and cooling}} loads are compared and discussed. An analytic <b>verification</b> <b>technique</b> is described and used to investigate performance of the four codes. An anomaly is discovered {{in one of the}} codes, and the analytic <b>verification</b> <b>technique</b> is used to test a modified version of this code...|$|R
40|$|Developing safe multithreaded {{software}} {{systems is}} difficult {{due to the}} potential unwanted interference among concurrent threads. This paper presents a sound, modular, and simple <b>verification</b> <b>technique</b> for multithreaded object-oriented programs with object invariants. Based on a recent methodology for object invariants in single-threaded programs, this new <b>verification</b> <b>technique</b> allows the definition of leak-proof ownership domains. These domains guarantee that only one thread at a time can ever access a confined object...|$|R
40|$|<b>Verification</b> <b>techniques</b> {{are applied}} to policy based systems to ensure design {{correctness}} and {{to aid in the}} discovery of errors at an early stage of the development life cycle. A primary goal of policy verification is to evaluate the policy’s validity. Other analyses on policy based systems include the identification of conflicting policies and policy efficiency evalu- ation and improvement. In this work, we present a discussion and classification of recent research on <b>verification</b> <b>techniques</b> for policy based systems. We analyse several techniques and identify popular supporting verification tools. An evaluation of the benefits and drawbacks of the existing policy analyses is made. Some of the common identified problems were the significant need of computational power, the limitation of the techniques to particular policy model, which restrict their ex- tension to other policy models and the lack of efficient conflicts resolution methods. We use the evaluation results for discussing the further challenges and future research directions that will be faced by policy <b>verification</b> <b>techniques.</b> In particular, we discuss specific requirements concerning <b>verification</b> <b>techniques</b> for coalition policies systems and autonomous decision making...|$|R
40|$|Probabilistic model {{checking}} is {{a formal}} <b>verification</b> <b>technique</b> for systems that exhibit stochastic behaviour. It {{has been used}} to analyse a wide range of systems, including communication protocols, such as Bluetooth and FireWire, randomised security protocols, e. g. for anonymity and contract signing, and many others. Often, {{it is also important to}} consider real-time aspects of the behaviour of such systems. This talk will give an introduction to <b>verification</b> <b>techniques</b> for probabilistic real-time systems, which can be modelled as probabilistic timed automata (PTAs). The talk will outline some of the underlying theory, introduce a variety of practical <b>verification</b> <b>techniques</b> for PTAs, and illustrate these ideas with a selection of case studies of probabilistic real-time systems that have been analysed with the probabilistic model checker PRISM. Background Reading • For a survey/tutorial on verification of probabilistic timed automata, see [4]. • For tutorial papers on <b>verification</b> <b>techniques</b> for other classes of probabilistic models, see for example [2], which focuses on (discrete- and continuous-time) Markov chains, and [1], which focuses on Markov decision processes and probabilistic automata...|$|R
40|$|One {{weakness}} of Hoare-style <b>verification</b> <b>techniques</b> based on {{first-order predicate logic}} is that reasoning is backward from postconditions to preconditions. A natural, forward reasoning is possible by viewing a program as a mathematical function that maps one program state to another. This functional program <b>verification</b> <b>technique</b> requires a minimal mathematical background as it uses equational reasoning based on sets and functions. Thus, it can be easily taught and used in practice. In this paper, we formalize a functional program specification and <b>verification</b> <b>technique</b> and extend it for object-oriented programs. Our approach allows one to formally specify and verify the behavior of an object-oriented program {{in a way that}} is natural and closer to the way one reasons about it informally...|$|R
40|$|In [Corin, den Hartog in ICALP 2006] {{we build}} a formal <b>verification</b> <b>technique</b> for game based {{correctness}} proofs of cryptograhic algorithms {{based on a}} probabilistic Hoare style logic [den Hartog, de Vink in IJFCS 13 (3), 2002]. An important step towards enabling mechanized <b>verification</b> within this <b>technique</b> is an axiomatization of implication between predicates which is purely semantically defined in [den Hartog, de Vink in IJFCS 13 (3), 2002]. In this paper we provide an axiomatization and illustrate {{its place in the}} formal <b>verification</b> <b>technique</b> of [Corin, den Hartog in ICALP 2006]...|$|R
40|$|Nuclear {{power plant}} ⇒ Reliability is {{becoming}} the primary concern � Increase of Size/Complexity of Software ⇒ Manual debugging is infeasibleProgram <b>Verification</b> <b>Techniques</b> � Model checking (c. f. 2007 Turing award) – Applicable to first-order procedures (pushdown model checking), but not to higher-order programs � Type-based program analysis – Applicable to higher-order programs – Sound but imprecise � Dependent types/theorem proving – Requires human intervention Sound and precise <b>verification</b> <b>techniques</b> for higher-order programs (e. g. ML/Java programs) ? This Talk �New program <b>verification</b> <b>technique</b> for higher-order languages (e. g. ML) – Sound, complete, and automatic for • A large class of higher-order programs • A large class of verification problems – Built on recent/new advances in • Type theories • Automata/formal language theories (esp. higher-order recursion schemes) • Model checking �Applications to language-based security (part II) Relevance to Security? (for ASIAN audience) � Program verification is relevant to software security – Prevent security holes – <b>Verification</b> <b>techniques</b> have been used for: • information flow analysis • access control • protocol verification � Higher-order program verification brings new advantages – precise for higher-order programs – applicable to infinite-state systemsOutlin...|$|R
40|$|Probabilistic {{models are}} widely {{deployed}} in various systems. To ensure their correctness, <b>verification</b> <b>techniques</b> {{have been developed}} to analyze probabilistic systems. We propose the first sound and complete learning-based compositional <b>verification</b> <b>technique</b> for probabilistic safety properties on concurrent systems where each component is an Markov decision process. Different from previous works, weighted assumptions are introduced to attain completeness of our framework. Since weighted assumptions can be implicitly represented by multiterminal binary decision diagrams (MTBDDs),we give an L*-based learning algorithm for MTBDDs to infer weighted assumptions. Experimental results suggest promising outlooks for our compositional technique. Probabilistic models are widely deployed in various systems. To ensure their correctness, <b>verification</b> <b>techniques</b> {{have been developed to}} analyze probabilistic systems. We propose the first sound and complete learning-based compositional <b>verification</b> <b>technique</b> for probabilistic safety properties on concurrent systems where each component is an Markov decision process. Different from previous works, weighted assumptions are introduced to attain completeness of our framework. Since weighted assumptions can be implicitly represented by multiterminal binary decision diagrams (MTBDDs),we give an L*-based learning algorithm for MTBDDs to infer weighted assumptions. Experimental results suggest promising outlooks for our compositional technique...|$|R
40|$|Software <b>verification</b> <b>techniques</b> require {{properties}} {{that define the}} intended behavior of a system be specified. Generating such properties is often very difficult and serves as an impediment {{to the adoption of}} <b>verification</b> <b>techniques.</b> Techniques that leverage program executions to infer these properties are a promising avenue for automatically generating these properties. In this paper, we propose a property inference approach that leverages event traces derived from program executions to efficiently infer {{properties that}} are subtle variations of commonly occurring properties. We define inference templates that represent sets of these properties and describe our inference algorithm that refines these templates based on event traces. 1...|$|R
40|$|The {{knowledge}} retention {{problem in}} the nuclear field was acknowledged by the OECD in 2000. ESARDA reacted to that with a strategy to tackle the problem and created a Working Group on Training and Knowledge Management (ESARDA WG TKM). The final objective of the ESARDA WG TKM is the setup of course modules to an internationally recognised reference standard. This project {{is in line with}} the movement of establishing a European curriculum for Nuclear Engineering. Teaching in the Nuclear Safeguards field is indeed strongly influenced by national history so the objective of the course is to provide homogeneous material in safeguards and non proliferation matters at the European level. This paper reports on the feedback of the course that was held by some of the leading experts in the field of nuclear safeguards in Europe. Its content deals with the general background of safeguards legislation and Treaties, the nuclear fuel cycle, various <b>safeguards</b> <b>techniques,</b> <b>verification</b> technologies and the evolution of safeguards. The audience - 40 university students and 5 young professionals (STUK and JRC) – from 12 different European countries was highly interested and gave positive feedback. The course has been introduced in the course database of the European Nuclear Education Network on the website [URL] A recognition as academic course of 3 credits under the European Credit Transfer System has been requested to the Belgian Nuclear higher Education Network. In the future this course will be repeated on a regular basis and evaluated, aiming to achieve recognition by the European Nuclear Education Network (ENEN). With an ENEN-label it is included in the list of optional courses for a European Masters Degree in Nuclear Engineering. JRC. G. 8 -Nuclear safeguard...|$|R
5000|$|In formal methods, a {{high-level}} formal specification {{can be related}} to a low-level executable implementation (e.g., formally by mathematical proof using formal <b>verification</b> <b>techniques).</b>|$|R
40|$|This talk {{presents}} the general landscape of timing analysis {{as it is}} being used today {{in the design of}} automotive embedded systems, reviews the main timing <b>verification</b> <b>techniques</b> and discusses what we can expect from them and what their limitations are. We will then emphasize the need to question the models and their assumptions, and cross-validate their results. Finally, we will discuss the prerequisites for a safe use of timing-accurate simulation as <b>verification</b> <b>technique</b> and illustrate on case-studies from the automotive domains...|$|R
40|$|This book {{presents}} state-of-the-art {{approaches to}} formal <b>verification</b> <b>techniques</b> to seamlessly integrate different formal verification methods {{within a single}} logical foundation. It should benefit researchers and practitioners looking to get a broad overview of the spectrum of formal <b>verification</b> <b>techniques,</b> as well as approaches to combining such techniques within a single framework. Coverage includes a range of case studies showing how such combination is fruitful in developing a scalable verification methodology for industrial designs. This book outlines both theoretical and practical issu...|$|R
40|$|For today's multi-million {{transistor}} designs, existing design <b>verification</b> <b>techniques</b> cannot {{guarantee that}} first silicon is designed error free. Therefore, techniques {{are necessary to}} efficiently debug first-silicon. In this article we show how scan-based debug {{can be used in}} a multiple clock domain system-on-a-chip. Both the necessary hardware measures, referred to as design for debug (DfD), and the required (debugger) software are considered. Special attention is paid to clock controller requirements. Keywords [...] - Debug, Test, Validation. I. Introduction Modern process technologies and design tools allow the realization of very large and complex systems on a single die. Because of the increased system complexity, improvements in integrated circuit (IC) <b>verification</b> <b>techniques</b> are necessary. For today's multimillion transistor designs, existing design <b>verification</b> <b>techniques</b> such as simulation, formal verification, static timing analysis, and emulation cannot guarantee that first s [...] ...|$|R
40|$|The {{effectiveness}} of hardware <b>verification</b> <b>techniques</b> has increased markedly {{in the past}} decade. As hardware <b>verification</b> <b>techniques</b> become increasingly powerful the idea of transitioning verification technology to industry can be taken seriously. Nevertheless, powerful decision procedures that can completely automate the verification of certain types of hardware, whether they are BDD based model-checkers [10] or automatic microprocessor verification tools [4], cannot be adequate on their own for industrial hardware verification. However, a high-level, general-purpose theorem prover with specific capabilities can provide an overall framework in which these tools can be embedded and {{in which they can}} then be effectively used for industrial hardware verification. 1 Introduction The {{effectiveness of}} hardware <b>verification</b> <b>techniques</b> has increased markedly in the past decade. These techniques span a spectrum from automatic techniques to interactive theorem proving techniques. At one end o [...] ...|$|R
40|$|Verification {{is one of}} the {{important}} sections of producing a software system. Several factors can influence on verification result. In this research, we analyze important factors on verification results and then we explain some <b>verification</b> <b>techniques</b> and software systems briefly. As verification result is sensitive highly in multilayer systems, we present a solution. By this solution, we can guarantee correctness and accuracy of verification results in multilayer systems by using static and dynamic <b>verification</b> <b>techniques</b> and reduce probability of errors in verification results of multilayer systems widely...|$|R
