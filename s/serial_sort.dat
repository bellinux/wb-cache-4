3|14|Public
25|$|Computational {{complexity}} (worst, {{average and}} best behavior) {{in terms of}} the size of the list (n). For typical serial sorting algorithms good behavior is O(nlogn), with parallel sort in O(log2n), and bad behavior is O(n2). (See Big O notation.) Ideal behavior for a <b>serial</b> <b>sort</b> is O(n), but this is not possible in the average case. Optimal parallel sorting is O(logn). Comparison-based sorting algorithms need at least Ω(nlogn) comparisons for most inputs.|$|E
5000|$|Computational {{complexity}} (worst, {{average and}} best behavior) {{in terms of}} the size of the list (n). For typical serial sorting algorithms good behavior is O(n log n), with parallel sort in O(log2 n), and bad behavior is O(n2). (See Big O notation.) Ideal behavior for a <b>serial</b> <b>sort</b> is O(n), but this is not possible in the average case. Optimal parallel sorting is O(log n). Comparison-based sorting algorithms need at least O(n log n) comparisons for most inputs.|$|E
40|$|FastSort is an {{external}} sort that uses parallel processing, large main memories and parallel disc accesses to obtain high performance. FastSort can sort a file {{as quickly as}} it can read the input and it can produce the result {{as quickly as it}} can write the target file [...] that is it sorts in linear time rather than the traditional Nlog(N) time of <b>serial</b> <b>sort</b> systems. This paper describes the design and implementation of FastSort. It presents performance measurements of FastSort on various Tandem Nonstop processors, with particular emphasis on the speedup obtained by using parallelism to sort large files...|$|E
40|$|A {{parallel}} sorting {{algorithm is}} presented for general purpose internal sorting on MIMD machines. The algorithm initially sorts the elements within each node using a <b>serial</b> <b>sorting</b> algorithm, then proceeds with a two phase parallel merge. The algorithm is comparison-based and requires additional storage of order the square {{root of the}} number of elements in each node. Performance of the algorithm is examined on two MIMD machines, the Fujitsu AP 1000 and the Thinking Machines CM 5. Table of Contents 1 THE PARALLEL SORTING TASK 1 1. 1 Introduction 1 1. 2 Nomenclature 1 1. 3 Aims of the Algorithm 1 1. 4 Hardware 2 2 OVERVIEW OF THE ALGORITHM 3 2. 1 Pre-Balancing 3 2. 2 <b>Serial</b> <b>Sorting</b> 3 2. 3 Primary Merging 4 2. 4 Cleanup 4 2. 5 Merge-Exchange 4 3 IMPLEMENTATION DETAILS 5 3. 1 Infinity Padding 5 3. 2 Balancing 6 3. 3 <b>Serial</b> <b>Sorting</b> 7 3. 4 Primary Merge 8 3. 5 Merge-Exchange Operation 9 3. 5. 1 Find-Exact Algorithm 10 3. 5. 2 Transferring Elements 11 3. 5. 3 Unbalanced Merging 11 3. 5. 4 Blockwise Merging 12 3 [...] ...|$|R
40|$|Abstract: A {{parallel}} sorting {{algorithm is}} presented for general purpose internal sorting on MIMD machines. The algorithm initially sorts the elements within each node using a <b>serial</b> <b>sorting</b> algorithm, then proceeds with a two phase parallel merge. The algorithm is comparison-based and requires additional storage of order the square {{root of the}} number of elements in each node. Performance of the algorithm is examined on two MIM...|$|R
40|$|A {{parallel}} sorting {{algorithm is}} presented for storage-efficient internal sorting on MIMD machines. The algorithm first sorts the elements within each node using a <b>serial</b> <b>sorting</b> algorithm, then uses a two-phase parallel merge. The algorithm is comparisonbased and requires additional storage of order the square {{root of the}} number of elements in each node. Performance of the algorithm on two general-purpose MIMD machines, the Fujitsu AP 1000 and the Thinking Machines CM 5, is examined. The algorithm is suitable for implementation on special-purpose parallel machines, e. g. parallel database machines...|$|R
3000|$|Situation 3 : When i a <  0 and N [...] sa <  0, the {{capacitor}} voltages of {{the positive}} and negative UFBSMs are sorted together, and the UFBSMs with the lowest capacitor voltages whose <b>sorted</b> <b>serial</b> numbers are 1, 2, 3,…, N [...] sa are negatively inserted for charging, and the other UFBSMs whose <b>sorted</b> <b>serial</b> numbers are N [...] sa +  1, N [...] sa +  2,…, N [...] s [...] are bypassed.|$|R
3000|$|Situation 2 : When i a >  0 and N [...] sa <  0, the {{negative}} UFBSMs are bypassed, {{and only the}} capacitor voltages of the positive UFBSMs are sorted. The positive UFBSMs with the lowest capacitor voltages whose <b>sorted</b> <b>serial</b> numbers are 1, 2,…, N [...] s  − N [...] sa are bypassed, and the other positive UFBSMs whose <b>sorted</b> <b>serial</b> numbers are N [...] s  − N [...] sa +  1, N [...] s  − N [...] sa +  2, …, N [...] s [...] are negatively inserted for discharging.|$|R
40|$|Cell sorting is broadly {{utilized}} {{in the field}} of biological and clinical research. Scientists frequently apply the technique to investigate the biology of stem cells or to develop therapies against neurodegenerative diseases [1]. Currently flow cytometry is {{the state of the art}} procedure to cope with cell separation tasks. In comparison to these commonly used systems, which rely on a <b>serial</b> <b>sorting</b> concept, the microchip based cell sorting device promises an increasing sorting velocity due to a parallel cell throughput, a more gentle cell treatment and an improved protection against biohazardous materials by encapsulating the sorting process in a microfluidic channel. The planned sorting device should be capable to sort droplets, which contain fluorescent cells by using the electrowetting effect. We demonstrate all relevant fluidic operations, as well as a characterisation of the electrowetting module by doing velocimetry and investigations on particle distributions within liquid droplets...|$|R
40|$|A {{parallel}} sorting {{algorithm is}} presented for general purpose internal sorting on MIMD machines. The algorithm initially sorts the elements within each node using a <b>serial</b> <b>sorting</b> algorithm, them proceeds with a two-phase parallel merge. The algorithm is comparison-based and requires additional storage of order the square {{root of the}} number of elements in each node. Performance of the algorithm is examined on two MIMD machines, the Fujitsu AP 1000 and the Thinking Machines CM 5. Keywords: Batcher's merge-exchange sort, distributed memory, Fujitsu AP 1000, parallel sorting, sorting, Sparc, Thinking Machines CM 5. 1. The Parallel Sorting Task. Many papers have discussed the task of sorting on parallel computers. See, for example, [1, 2, 9]. Most of these papers have dealt with the problem from a theoretical point of view, neglecting many issues which are important in a practical implementation of a parallel sorting algorithm [3, 8]. This report introduces a practical parallel sorting algor [...] ...|$|R
40|$|A {{parallel}} sorting {{algorithm is}} presented for storage-efficient internal sorting on MIMD machines. The algorithm first sorts the elements within each node using a <b>serial</b> <b>sorting</b> algorithm, then uses a two-phase parallel merge. The algorithm is comparisonbased and requires additional storage of order the square {{root of the}} number of elements in each node. Performance of the algorithm on two general-purpose MIMD machines, the Fujitsu AP 1000 and the Thinking Machines CM 5, is examined. The algorithm is suitable for implementation on special-purpose parallel machines, e. g. parallel database machines. Key words and phrases. Batcher's merge-exchange sort, distributed memory, Fujitsu AP 1000, parallel sorting, sorting, Sparc, Thinking Machines CM 5. 1 : Introduction and Aims There is a large literature on parallel sorting [...] see, for example, [1, 2, 9] and the references given there. Many of these papers have dealt with the problem from a theoretical point of view, neglecting issues which are [...] ...|$|R
40|$|It is {{commonly}} accepted that efficient <b>serial</b> <b>sorting</b> algorithms run in O(n×log(n)) time[3]. However, practical systems {{show that the}} running time of an algorithm can {{be affected by the}} hardware resources as well as the complexity of the algorithm. This paper is a case study of a hybrid sorting algorithm implemented on a parallel system. On the surface, it is an odd-even transposition sort. However, the oddeven transposition sort requires sorted sub-arrays for large data sets. We found that sorting the array segments using a hybrid of merge sort and quicksort results in better performance than simply using quicksort. Instead of allowing quicksort to partition the array, the hybrid algorithm splits the array evenly until the sub-arrays reach a specified size. At that point, quicksort is allowed to take over. The results are then merged together using a standard merge sort. Simple tests demonstrate that, using the hybrid sort, the parallel odd-even transposition sort performs much faster than when it uses quicksort to sort the array segments. Since qucksort and merge sort have the same complexity, we hypothesized that the performance difference was related to cache swapping. This paper discusses the results of exploring this hypothesis. ...|$|R
40|$|Abstract: An {{algorithm}} is described that allows log (n) processors to sort n records {{in just over}} 2 n write cycles, together with suitable hardware to support the algorithm. The {{algorithm is}} a parallel version of the straight merge sort. The passes of the merge sort are run overlapped, with each pass supported by a separate processor. The intermediate files of a <b>serial</b> merge <b>sort</b> are replaced by first-in firstout aueues. The processors and Queues may be implemented in conventional solid logic technology or in bubble technology. A hybrid technology is alsb appropriate. ...|$|R
40|$|Sorting {{is common}} process in {{computational}} world. Its utilization are on many fields from research to industry. There are many sorting algorithm in nowadays. One {{of the simplest}} yet powerful is bubble sort. In this study, bubble sort is implemented on FPGA. The implementation was taken on serial and parallel approach. Serial and parallel bubble sort then compared by means of its memory, execution time, and utility which comprises slices and LUTs. The experiments show that <b>serial</b> bubble <b>sort</b> required smaller memory as well as utility compared to parallel bubble sort. Meanwhile, parallel bubble sort performed faster than serial bubble sor...|$|R
40|$|Putative {{dendritic}} cells (DC) {{and their}} precursors {{have been obtained}} from human bone marrow but their origin and relationship to other myeloid cells remains obscure. A minor bone marrow mononuclear cell (BMMC) population, which contains the most potent allostimulatory cells and lacks mature cell lineage markers (CD 3, CD 11 b, CD 14, CD 15, CD 16, CD 19, CD 57 and glycophorin A; lineage-negative) was enriched by immunoselection. These preparations, which contain cells with similar characteristics to freshly isolated human blood DC, were further subdivided by <b>serial</b> fluorescent-activated cell <b>sorting</b> (FACS). Potent allostimulatory cells were detected in the CD 34, CD 33 and CD 4 positive and negative subpopulations. Cells with putative DC morphology were present in both the CD 33 and CD 4 positive and negative fractions. No significant CD 13 or Thy- 1 staining {{was seen in the}} lineage-negative population. In vitro culture of lineage-negative BMMC for 7 days in conditioned medium resulted in a up to fivefold expansion of cells and generated many lineage-positive progeny. This lineage-positive population was as allostimulatory as the negative progeny. Likewise, the CD 14 -positive and the CD 14 -negative cell progeny were equally allostimulatory. In contrast, the freshly isolated lineage-positive BMMC (containing CD 14 -positive monocytes) remained poor stimulators of the mixed lymphocyte reaction (MLR), even after culture in the presence of cytokines. These data suggest that {{there are at least two}} phenotypically diverse forms of potent allostimulatory cells in the lineage-negative fraction of human BM, at least some of which express the early haemopoietic precursor antigens CD 34 or CD 33. Some of these precursors generate CD 14 -positive allostimulatory cells upon in vitro culture, suggesting an intimate link between DC ontogeny and myeloid differentiation...|$|R

