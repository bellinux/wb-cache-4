58|260|Public
50|$|A {{replacement}} online option {{has been}} developed by Revora. The <b>software,</b> <b>instructions</b> and support {{can be found on}} CnC Online.|$|E
50|$|The {{advocates of}} XP {{argue that the}} only truly {{important}} product of the system development process is code - <b>software</b> <b>instructions</b> that a computer can interpret. Without code, there is no working product.|$|E
50|$|A {{completely}} {{different approach to}} function generation is to use <b>software</b> <b>instructions</b> to generate a waveform, with provision for output. For example, a general-purpose digital computer {{can be used to}} generate the waveform; if frequency range and amplitude are acceptable, the sound card fitted to most computers can be used to output the generated wave.|$|E
50|$|The CBL {{framework}} {{has been}} extended into new areas including strategic planning, workplace training (O'Mahony, et. al., 2012), and mobile <b>software</b> <b>instruction</b> and development (Santos, et. al., 2015).|$|R
40|$|Knowledge from game design {{appears to}} offer new methods for <b>software</b> <b>instruction</b> {{and use that}} would {{traditionally}} require long, expensive, and not always effective training. In this paper, we explore the possibility of applying such knowledge {{to the field of}} intelligence analysis. KEYWORDS serious games; intelligence analysis; intelligence analysts 1...|$|R
50|$|The law {{applies to}} “any written, printed or copied file, document, book, journal, brochure, etude, letter, <b>software,</b> <b>instruction,</b> sketch, plan, film, photograph, tape and video cassette, {{map of the}} {{institutions}} and the information, news and other data that are recorded and saved in electronic format that are {{within the scope of}} (the) law”.|$|R
5000|$|Numecent is a Irvine, California-based {{software}} company. The company {{develops a}} technology platform which delivers native software applications from cloud computing servers using virtualization technology. The patented technology, {{that the company}} refers to as [...] "cloudpaging", allows the delivery of pre-virtualized <b>software</b> <b>instructions</b> to a user's machine on-demand, where the instructions are executed {{as soon as they}} are received.|$|E
50|$|A {{program is}} a set of data that {{consists}} of a series of coded <b>software</b> <b>instructions</b> to control the operation of a computer or other machine. Physical computer memory elements consist of an address and a byte/word of data storage. Digital data are often stored in relational databases, like tables or SQL databases, and can generally be represented as abstract key/value pairs.|$|E
5000|$|Each {{group of}} {{multiple}} <b>software</b> <b>instructions</b> {{is called a}} bundle. Each of the bundles has a stop bit indicating if this set of operations is depended upon by the subsequent bundle. With this capability, future implementations can be built to issue multiple bundles in parallel. The dependency information is calculated by the compiler, so the hardware {{does not have to}} perform operand dependency checking.|$|E
50|$|Arguably {{a machine}} that has no ILP, which is not superscalar, which executes one {{instruction}} {{at a time in}} a non-pipelined manner, but which performs hardware prefetching (not <b>software</b> <b>instruction</b> level prefetching) exhibits MLP (due to multiple prefetches outstanding) but not ILP. This is because there are multiple memory operations outstanding, but not instructions. Instructions are often conflated with operations.|$|R
40|$|As {{microprocessor}} complexities {{and costs}} skyrocket, designers {{are looking for}} ways to simplify their designs to reduce costs, improve energy efficiency, or squeeze more computational elements on each chip. This is particularly true for the embedded domain where cost and energy consumption are paramount. <b>Software</b> <b>instruction</b> caches have the potential to provide the required performance while using simpler, more efficient hardware. A software cache consists of a simple array memory (such as a scratchpad) and a software system that is capable of automatically managing that memory as a cache. Software caches have several advantages over traditional hardware caches. Without complex cache-management logic, the processor hardware is cheaper and easier to design, verify and manufacture. The reduced access energy of simple memories can result in a net energy savings if management overhead is kept low. Software caches can also be customized to each individual program's needs, improving performance or eliminating unpredictable timing for real-time embedded applications. The greatest challenge for a software cache is providing good performance using general-purpose instructions for cache management rather than specially-designed hardware. This thesis designs and implements a working system (Flexicache) on an actual embedded processor and uses it to investigate the strengths and weaknesses of <b>software</b> <b>instruction</b> caches. Although both data and instruction caches can be implemented in software, very different techniques are used to optimize performance; this work focuses exclusively on <b>software</b> <b>instruction</b> caches. The Flexicache system consists of two software components: a static off-line preprocessor to add caching to an application and a dynamic runtime system to manage memory during execution. Key interfaces and optimizations are identified and characterized. The system is evaluated in detail from the standpoints of both performance and energy consumption. The results indicate that <b>software</b> <b>instruction</b> caches can perform comparably to hardware caches in embedded processors. On most benchmarks, the overhead relative to a hardware cache is less than 12 % and can be as low as 2. 4 %. At the same time, the software cache uses up to 6 % less energy. This is achieved using a simple, directly-addressed memory and without requiring any complex, specialized hardware structures. by Jason Eric Miller. Thesis (Ph. D.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2007. This electronic version was submitted by the student author. The certified thesis is available in the Institute Archives and Special Collections. Includes bibliographical references (p. 185 - 193) ...|$|R
40|$|Many {{systems have}} {{implemented}} replay of parallel or sequential processes, but none {{have provided a}} robust set of debugger tools that {{take advantage of this}} power. This paper develops new ideas about how <b>software</b> <b>instruction</b> counters can be used by programmers to facilitate debugging applications under replay. This paper is the discussion of the author's project for Honors in the degree of Bachelor of Science under the direction of Professor Robert H. B. Netzer. ...|$|R
50|$|VisualSim Architect is an {{electronic}} system-level software for {{modeling and simulation}} of electronic systems, embedded software and semiconductors. VisualSim Architect is a commercial version of the Ptolemy II research project at University of California Berkeley. The product was first released in 2003. VisualSim is a graphical tool {{that can be used}} for performance trade-off analyses using such metrics as bandwidth utilization, application response time and buffer requirements. It can be used for architectural analysis of algorithms, components, <b>software</b> <b>instructions</b> and hardware/ software partitioning.|$|E
50|$|The story {{starts with}} France selling to the USSR a {{meteorological}} Cray-1 {{system and the}} related software. At the occasion of an inspection for export control, NSA agents implement a secret software bomb. The system later breaks down on the exact day of an official visit of the Russian authorities, but mysteriously works again the day after without any repair. Ioulia and her assistant discover that some additional <b>software</b> <b>instructions</b> set the computer out of order when it processes some specific meteorological data related to the Saint-Thomas Island in the US Virgin Islands.|$|E
50|$|In all computers, <b>software</b> <b>instructions</b> {{control the}} {{physical}} hardware (screen, disk, keyboard, etc.) {{from the moment}} the power is switched on. In a PC, the BIOS, pre-loaded in ROM on the main board, takes control immediately after the processor is reset, including during power-up or when a hardware reset button is pressed. The BIOS initializes the hardware, finds, loads and runs the boot program (usually, but not necessarily, an OS loader), and provides basic hardware control to the operating system running on the machine, which is usually an operating system but may be a directly booting single software application.|$|E
40|$|We present Worldsens, a {{complete}} environment for fast prototyping of wireless sensor protocols and applications. Our environment proposes a full simulation platform with both embedded <b>software</b> <b>instruction</b> and radio packet accuracy. We propose a demonstration including a full software design, simulation, performance estimation and deployment {{on a set}} of nodes within the same design environment. Through these first experimentations, we show that accurate sensor network simulation is feasible and that complex application design and deployment is affordable...|$|R
50|$|READ 180 {{is based}} on a blended {{instructional}} model that includes whole-group instruction and three small-group rotations, adaptive <b>software,</b> differentiated <b>instruction,</b> and independent reading.|$|R
40|$|The {{purpose of}} this study is to make clear the {{proficiency}} of application software (word-processing, spreadsheet, database, browser, mailer, and presentation software) and to discuss the future of information education for social welfare students. The questionnaire was conducted to 286 social welfare students of Iwate Prefectural University. The results of analysis show significant achievement in information education. However, some efforts are still needed on improving the database software skill, making <b>software</b> <b>instruction</b> manual much more accessible, and enhancing the support function of helpdesk...|$|R
50|$|<b>Software</b> <b>instructions</b> to {{turn off}} the probe's {{attitude}} control, normally a fatal operation, were part of a routine used when testing the spacecraft on the ground. Normally this routine would be removed before launch. However, the software was coded in PROMs, and so removing the test code would have required removing and replacing the entire computer. Because of time pressure from the impending launch, engineers decided to leave the command sequence in, though it should never be used. However, a single-character error in constructing an upload sequence resulted in the command executing, with subsequent loss of the spacecraft.|$|E
50|$|Full {{backward}} compatibility {{is particularly important}} in computer instruction set architectures, {{one of the most}} successful being the x86 family of microprocessors. Their full {{backward compatibility}} spans back to the Intel 8080 processors produced in 1974 but not to its predecessor, the Intel 8008. The fully backward compatible processors can process the same binary executable <b>software</b> <b>instructions</b> as their predecessors, allowing the use of a newer processor without having to acquire new applications or operating systems. Similarly, the success of the Wi-Fi digital communication standard is attributed to its broad forward and backward compatibility; it became more popular than other standards that were not backward compatible.|$|E
5000|$|Explicitly {{parallel}} instruction computing (EPIC) {{is a term}} coined in 1997 by the HP-Intel {{alliance to}} describe a computing paradigm that researchers had been investigating since the early 1980s. This paradigm is also called Independence architectures. It {{was the basis for}} Intel and HP development of the Intel Itanium architecture, and HP later asserted that [...] "EPIC" [...] was merely an old term for the Itanium architecture. EPIC permits microprocessors to execute <b>software</b> <b>instructions</b> in parallel by using the compiler, rather than complex on-die circuitry, to control parallel instruction execution. This was intended to allow simple performance scaling without resorting to higher clock frequencies.|$|E
5000|$|Fixtureless in-circuit test (FICT) is {{a method}} of [...] testing {{a printed circuit board}} assembly. A {{traditional}} [...] "bed of nails" [...] tester for testing a PCB requires a custom fixture to hold the PCBA and the Pogo pins which make contact with the PCBA. In contrast, FICT uses two to four flying probes, which may be moved based on <b>software</b> <b>instruction.</b> The flying probes also allow easy modification of the test fixture when the PCBA design changes. FICT may be used on both bare or assembled PCB's.|$|R
50|$|The Control Unit (CU) is digital {{circuitry}} {{contained within}} the processor that coordinates the sequence of data movements into, out of, and between a processor's many sub-units. The result of these routed data movements through various digital circuits (sub-units) within the processor produces the manipulated data expected by a <b>software</b> <b>instruction</b> (loaded earlier, likely from memory). It controls (conducts) data flow inside the processor and additionally provides several external control signals {{to the rest of}} the computer to further direct data and instructions to/from processor external destination's (i.e. memory).|$|R
50|$|The 7 accumulator-immediate {{instructions}} are renumbered {{relative to the}} 14-bit PICmicro, to fit into 3 opcode bits rather than 4, but they are all there, {{as well as an}} additional <b>software</b> interrupt <b>instruction.</b>|$|R
5000|$|In Allvoice Developments US, LLC v. Microsoft Corp., the Federal Circuit in a May 2015 nonprecedential opinion invalidated {{patent claims}} to a speech {{recognition}} [...] "interface" [...] without undertaking an Alice analysis. The so-called interface was entirely {{a set of}} <b>software</b> <b>instructions,</b> claimed in means-plus-function form. The court found it unnecessary {{to go through the}} two-step analysis because a set of instructions is not a machine or article of manufacture or composition of matter, and it did not purport to be a process. Accordingly, the claimed subject matter did not fit within any of the statutory categories of section 101, which defines patentable subject matter. Moreover, it was intangible, and in the Digitech case, the Federal Circuit had held that except for processes, “eligible subject matter must exist in some physical or tangible form.” ...|$|E
5000|$|While {{the first}} [...] "Vores øl" [...] recipe draw some {{technical}} criticism, the recipe was continuously updated and identified shortcomings got fixed. Originally, the homebrewing community complaint {{the quality of}} the process and ingredient description. Remarks were that it was not stated how much water to use in the mash, what type of yeast was to be used, the style of beer being produced (other than being dark and heavy), whether or not any hops were being added for aroma, fermentation temperature, or how the beer was supposed to taste. Making reference to the technical problems of when <b>software</b> <b>instructions</b> ("source code") cannot be made into a functioning program, it was mentioned that if this recipe were source code, it would not compile. Because of the underlying theme of the group's message, the correction and development of this recipe is actively encouraged (in software terminology [...] "bug fixing and patches").|$|E
5000|$|The {{eligibility}} of software, as such, for {{patent protection}} {{has been only}} scantily addressed in the courts or in legislation. In fact, in the recent Supreme Court decision in Alice v. CLS Bank, the Court painstakingly avoided the issue, and one Justice in the oral argument repeatedly insisted that it was unnecessary to reach the issue. [...] The expression [...] "software patent" [...] itself has not been clearly defined. The United States Patent and Trademark Office (USPTO) has permitted patents to be issued on {{nothing more than a}} series of software computer instructions, but the latest Federal Circuit decision on the subject invalidated such a patent. The court held that <b>software</b> <b>instructions</b> as such were too intangible to fit within any of the statutory categories such as machines or articles of manufacture. On June 19, 2014 the United States Supreme Court ruled in Alice Corp. v. CLS Bank International that [...] "merely requiring generic computer implementation fails to transform an abstract idea into a patent-eligible invention." ...|$|E
5000|$|Without {{hardware}} support (and in multitasking environments), debuggers have {{to implement}} breakpoints in <b>software.</b> For <b>instruction</b> breakpoints, {{this is a}} comparatively simple task of replacing the instruction {{at the location of}} the breakpoint by either: ...|$|R
40|$|Although {{several recent}} papers have {{proposed}} archi-tectural support for program debugging and profil-ing, most processors {{do not yet}} provide even basic facilities, such as an instruction counter. As a result, system developers {{have been forced to}} invent soft-ware solutions. This paper describes our implemen-tation of a <b>software</b> <b>instruction</b> counter for program debugging. We show that an instruction counter can be reasonably implemented in software, often with less than 10 % execution overhead. Our experience suggests that a hardware instruction counter is not necessary for a practical implementation of watch-points and reverse execution, however it will make program instrumentation much easier for the system developer. ...|$|R
5000|$|A <b>software</b> {{prefetch}} <b>instruction</b> {{is used as}} a type of data prefetch. This prefetch {{increases the}} chances for a cache hit for loads, and can indicate the degree of temporal locality needed in various levels of the cache.|$|R
50|$|More precisely, the Control Unit (CU) is {{generally}} a sizable collection of complex digital circuitry interconnecting and controlling the many execution units (i.e. ALU, data buffers, registers) contained within a CPU. The CU is normally the first CPU unit to accept from an externally stored computer program, a single instruction (based on the CPU's instruction set). The CU then decodes this individual instruction into several sequential steps (fetching addresses/data from registers/ memory, managing execution data {{sent to the}} ALU or I/O, and storing the resulting data back into registers/memory) that controls and coordinates the CPU's inner works to properly manipulate the data. The design of these sequential steps {{are based on the}} needs of each instruction and can range in number of steps, the order of execution, and which units are enabled. Thus by only using a program of set instructions in memory, the CU will configure all the CPU's data flows as needed to manipulate the data correctly between instructions. This results in a computer that could run a complete program and requiring no human intervention to make hardware changes between instructions (as had to be done when using only punch cards for computations before stored programmed computers with CUs where invented). These detailed steps from the CU dictate which of the CPU's interconnecting hardware control signals to enable/disable or which CPU units are selected/de-selected and the unit's proper order of execution as required by the instruction's operation to produce the desired manipulated data. Additionally, the CU's orderly hardware coordination properly sequences these control signals then configures the many hardware units comprising the CPU, directing how data should also be moved, changed, and stored outside the CPU (i.e. memory) according to the instruction's objective. Depending on the type of instruction entering the CU, the order and number of sequential steps produced by the CU could vary the selection and configuration of which parts of the CPU's hardware are utilized to achieve the instruction's objective (mainly moving, storing, and modifying data within the CPU). This one feature, that efficiently uses just <b>software</b> <b>instructions</b> to control/select/configure a computer's CPU hardware (via the CU) and eventually manipulates a program's data, is a significant reason most modern computers are flexible and universal when running various programs. As compared to some 1930s or 1940s computers without a proper CU, they often required rewiring their hardware when changing programs. This CU instruction decode process is then repeated when the Program Counter is incremented to the next stored program address and the new instruction enters the CU from that address, and so on till the programs end.|$|E
30|$|Note {{that current}} {{generation}} sensor nodes may be broadly classified into two types: some being endowed {{with a high}} hardware processing capabilities and a rich set of <b>software</b> <b>instructions</b> allowing them to compute complex functions such as {{those involved in the}} constraints used in this paper while other have poor hardware processing capabilities with only a set of <b>software</b> <b>instructions</b> allowing to compute only an elementary set of functions. While our implementation model fits well for the former, the set of steps proposed above may be used in a more elementary processing context assuming some approximations to the functions used in the constraints.|$|E
30|$|Compute Resource: The core {{processing}} capabilities {{that are used}} to execute <b>software</b> <b>instructions.</b> We define this as comprising of a CPU, typically in multicore configuration, CPU cache and primary storage memory. Data centres typically house many thousands of servers containing these compute resources.|$|E
5000|$|... #Caption: A more {{elaborate}} example of fraction slash usage: plain text “4 221⁄225” rendered in Apple Chancery. This font supplies the text layout <b>software</b> with <b>instructions</b> to synthesize the fraction {{according to the}} Unicode rule described in this section.|$|R
50|$|A {{technical}} file includes drawings, specifications, reports, review records, meeting minutes, <b>instructions,</b> <b>software</b> source code, etc.|$|R
40|$|Abstract. In this paper, {{we take a}} MIPS-based {{open-source}} uniproces-sor soft core, Plasma, {{and extend}} it to obtain the Beefarm infrastruc-ture for FPGA-based multiprocessor emulation, a popular research topic {{of the last few}} years both in the FPGA and the computer architecture communities. We discuss various design tradeoffs and we demonstrate su-perior scalability through experimental results compared to traditional <b>software</b> <b>instruction</b> set simulators. Based on our experience of designing and building a complete FPGA-based multiprocessor emulation system that supports run-time and compiler infrastructure and on the actual executions of our experiments running Software Transactional Memory (STM) benchmarks, we comment on the pros, cons and future trends of using hardware-based emulation for research. ...|$|R
