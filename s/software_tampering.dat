5|27|Public
50|$|If implemented, trusted {{computing}} {{would make}} <b>software</b> <b>tampering</b> of protected programs {{at least as}} difficult as hardware tampering, as the user would have to hack the trust chip to give false certifications in order to bypass remote attestation and sealed storage. However, the current specification {{makes it clear that}} the chip is not expected to be tamper-proof against any reasonably sophisticated physical attack; that is, it is not intended to be as secure as a tamper-resistant device.|$|E
40|$|One {{approach}} to protect distributed systems implemented with mobile code is through program obfuscation. Disguising program intent {{is a form}} of information hiding that facilitates tamper proofing. By hiding program intent, adversaries are reduced to non-semantics attacks such as blind disruption or operating system level attacks (e. g. buffer overflows). In this paper, we amplify the Barak result to observe that the Virtual Black Box (VBB) program obfuscation model is fundamentally flawed for useful analysis. We provide an alternative framework for establishing and evaluating program intent protection mechanisms to impede <b>software</b> <b>tampering.</b> Our model reflects more modest goals than VBB. Rather than considering a comprehensive obfuscation view, we detail broad threat classes and propose mechanisms to counter those threats. We then illustrate our model with a protection proof and outline extensions to our results...|$|E
40|$|We {{specify a}} {{hardware}} architecture that supports tamper-resistant software by identifying an "idealized" model, {{which gives the}} abstracted actions available to a single user program. This idealized model is compared to a concrete "actual" model that includes actions of an adversarial operating system. The architecture is verified by using a finite-state enumeration tool (a model checker) to compare executions of the idealized and actual models. In this approach, <b>software</b> <b>tampering</b> occurs if the system can enter a state where one model is inconsistent with the other. In performing the verification, we detected an replay attack scenario {{and were able to}} verify the security of our solution to the problem. Our methods were also able to verify that all actions in the architecture are required, as well as come up with a set of constraints on the operating system to guarantee liveness for users...|$|E
40|$|We {{provide a}} {{selective}} survey on software protection, including approaches to <b>software</b> <b>tamper</b> resistance, obfuscation, <b>software</b> diversity, and white-box cryptography. We review the early {{literature in the}} area plus recent activities related to trusted platforms, and discuss challenges and future directions...|$|R
40|$|A major {{challenge}} in software protection {{is the problem}} of tampering where an adversary modifies a program and uses {{it in a way that}} was not intended or desired. Several ad hoc techniques for <b>software</b> <b>tamper</b> resistance have been proposed, some of which provide a significant level of resilience against tampering. However, the literature lacks a formal definition of tampering that takes into account a model of the attacker’s goals. One effect of this lack is the inability of easily comparing the actual efficacy of proposed tamper resistance mechanisms and evaluating the practical limits of tamper resistance. This paper is a step towards addressing this shortcoming. We consider the two players: the defender who wishes to protect the program, and an adversary who wishes to modify the program as well as the assets embedded within the program to his advantage. We propose a way of expressing the intent of the defender and the attacker based on predicates defined over program traces. Based on these expressions, we present formal definitions for <b>software</b> <b>tamper</b> resistance, and <b>software</b> <b>tamper</b> verification. With a practical tamper verification scheme, we show how this formal model can be used in a reactive protection setting. ...|$|R
40|$|Abstract. We {{provide a}} {{selective}} survey on software protection, including approaches to <b>software</b> <b>tamper</b> resistance, obfuscation, <b>software</b> diversity, and white-box cryptography. We review the early {{literature in the}} area plus recent activities related to trusted platforms, and discuss challenges and future directions. ...|$|R
40|$|We {{describe}} the architecture for a single-chip aegis processor {{which can be}} used to build computing systems secure against both physical and software attacks. Our architecture assumes that all components external to the processor, such as memory, are untrusted. We show two different implementations. In the first case, the core functionality of the operating system is trusted and implemented in a security kernel. We also describe a variant implementation assuming an untrusted operating system. aegis provides users with tamper-evident, authenticated environments in which any physical or <b>software</b> <b>tampering</b> by an adversary is guaranteed to be detected, and private and authenticated tamperresistant environments where additionally the adversary is unable to obtain any information about software or data by tampering with, or otherwise observing, system operation. aegis enables many applications, such as commercial grid computing, secure mobile agents, software licensing, and digital rights management. Preliminary simulation results indicate that the overhead of security mechanisms in aegis is reasonable. ...|$|E
40|$|We {{describe}} {{the architecture of}} the aegis processor which can be used to build computing systems secure against both physical and software attacks. aegis assumes that the operating system and all components external to it, such as memory, are untrusted. aegis provides tamper-evident, authenticated environments in which any physical or <b>software</b> <b>tampering</b> by the adversary is guaranteed to be detected, and private and authenticated, tamper-resistant environments where additionally the adversary is unable to obtain any information about software or data by tampering with, or otherwise observing, system operation. aegis enables many applications, such as commercial grid computing, software licensing, and digital rights management. We present a new encryption/decryption method that successfully hides a significant portion of encryption/decryption latency, in comparison to a conventional direct encryption scheme. Efficient memory encryption and integrity verification enable the implementation of a secure computing system with the only trusted component being a single-chip aegis CPU. Detailed simulation results indicate that the performance overhead of security mechanisms in aegis is reasonable. ...|$|E
40|$|International audienceThe {{increase}} use of <b>software</b> <b>tamper</b> resistance {{techniques to}} protect software against undesired attacks comes an increased {{need to understand}} more about the strength of these tamper resistance techniques. Currently the understanding is rather general. In this {{paper we propose a}} new <b>software</b> <b>tamper</b> resistance evaluation technique. Our main contribution is to identify a set of issues that a tamper resistant system must deal with and show why these issues must be dealt with in order to secure a software system. Using the identified issues as criteria, we can measure the actual protection capability of a TRS system implementation and provide guidance on potential improvements on the implementation. We can also enable developers to compare the protection strength between differently implemented tamper resistance systems. While the set of criteria we identified in this paper is by no means complete, our framework allows easy extension of adding new criteria in future...|$|R
40|$|Abstract. We {{describe}} a novel software verification primitive called Oblivious Hashing. Unlike previous techniques that mainly verify the static shape of code, this primitive allows implicit computation of a hash {{value based on}} the actual execution (i. e., space-time history of computation) of the code. We also describe its applications in local <b>software</b> <b>tamper</b> resistance and remote code authentication. 1...|$|R
40|$|Self-checking <b>software</b> <b>tamper</b> {{resistance}} mechanisms employing checksums, including ad-vanced {{systems as}} recently proposed by Chang and Atallah (2002) and Horne et al. (2002), have been promoted {{as an alternative}} to other software integrity verification techniques. Ap-pealing aspects include the promise of being able to verify the integrity of software independent of the external support environment, as well as the ability to automatically integrate check-summing code during program compilation or linking. In this paper, we show that the rich functionality of many modern processors, including UltraSparc and x 86 -compatible processors, facilitates automated attacks which defeat such checksumming by self-checking programs. ...|$|R
40|$|Abstract. Software {{protection}} {{is an area}} of active research in which a variety of techniques have been developed to address the issue. Examples of such techniques include code obfuscation, <b>software</b> watermarking, and <b>tamper</b> detection. In this paper we propose a tamper resistance technique which provides both on and offline tamper detection. In our offline approach, the <b>software</b> dynamically detects <b>tampering</b> and causes the program to fail, protecting itself from malicious attacks. Additionally, during program execution an event log is maintained which is transmitted to a clearing house when the program is back online...|$|R
40|$|Self-hashing {{has been}} {{proposed}} as a technique for verifying software integrity. Appealing aspects of this approach to <b>software</b> <b>tamper</b> resistance include the promise {{of being able to}} verify the integrity of software independent of the external support environment, as well as the ability to integrate code protection mechanisms automatically. In this paper, we show that the rich functionality of most modern general-purpose processors (including UltraSparc, x 86, PowerPC, AMD 64, Alpha, and ARM) facilitate an automated, generic attack which defeats such self-hashing. We present a general description of the attack strategy and multiple attack implementations that exploit different processor features. Each of these implementations is generic in that it can defeat self-hashing employed by any user-space program on a single platform. Together, these implementations defeat self-hashing on most modern general-purpose processors. The generality and efficiency of our attack suggests that self-hashing is not a viable strategy for high-security tamper resistance on modern computer systems...|$|R
40|$|Abstract. We {{introduce}} {{software integrity}} checking expressions (Soft-ICEs), which are program predicates {{that can be}} used in <b>software</b> <b>tamper</b> detection. We present two candidates, probabilistic verification conditions (PVCs) and Fourier-learning approximations (FLAs), which can be computed for certain classes of programs,. We show that these predicates hold for any valid execution of the program, and fail with some probability for any invalid execution (e. g., when the output value of one of the variables is tampered). PVCs work with straight-line integer programs that have operations { ∗, +, −}. We also sketch how we can extend this class to include branches and loops. FLAs can work over programs with arbitrary operations, but have some limitations in terms of efficiency, code size, and ability to handle various classes of functions. We describe a few applications of this technique, such as program integrity checking, program or client identification, and tamper detection. As a generalization of oblivious hashing (OH), our approach resolves several troublesome issues that complicate practical application of OH towards tamper-resistance. ...|$|R
40|$|Abstract – General {{elections}} {{are the foundation}} of power for democratic governments. Recently electronic voting has been adopted by several governments for use in these wide scale elections. As with most large scale electronic systems, electronic voting may vulnerable to malicious <b>software</b> and <b>tampering.</b> For an electronic voting system to be useful it must allow {{for all of the}} benefits of information technology while operating under the legalities of standard election regulations. These election regulations are common for any democratic process and must be upheld by the technologies and protocols involved...|$|R
40|$|We {{present a}} graph theoretic {{approach}} for watermarking software in a robust fashion. While watermarking software that are small in size (e. g. a few kilobytes) may be infeasible through this approach, {{it seems to}} be a viable scheme for large applications. Our approach works with control/data flow graphs and uses abstractions,approximate k-partitions,and a random walk method to embed the watermark,with the goal of minimizing and controlling the additions to be made for embedding,while keeping the estimated effort to undo the watermark (WM) as high as possible. The watermarks are so embedded that small changes to the software or flow graph are unlikely to disable detection by a probabilistic algorithm that has a secret. This is done by using some relatively robust graph properties and error correcting codes. Under some natural assumptions about the code added to embed the WM,locating the WM by an attacker is related to some graph approximation problems. Since little theoretical foundation exists for hardness of typical instances of graph approximation problems,we present heuristics to generate such hard instances and,in a limited case,present a heuristic analysis of how hard it is to separate the WM in an information theoretic model. We describe some related experimental work. The approach and methods described here also suitable for solving the problem of <b>software</b> <b>tamper</b> resistance...|$|R
40|$|In {{software}} protection we typically {{have to deal}} with the white-box attack model. In this model an attacker is assumed to have full access to the software and full control over its execution. The goal of white-box cryptography is to implement cryptographic algorithms in software such that it is hard for an attacker to extract the key by a white-box attack. Chow et al. [8, 7] present white-box implementations for AES and DES. Based on their ideas, white-box implementations can be derived for other block ciphers as well. In the white-box implementations the key of the underlying block cipher is expanded from several bytes to a collection of lookup tables with a total size in the order of hundreds of kilobytes. In this paper we present a technique that uses a white-box implementation to make <b>software</b> <b>tamper</b> resistant. The technique interprets the binary of software code as lookup tables, which are next incorporated into the collection of lookup tables of a white-box implementation. This makes the code tamper resistant as the dual interpretation implies that a change in the code results in an unintentional change in the white-box implementation. We also indicate in the paper that it is difficult for an attacker to make modifications to the white-box implementation such that its original operation is restored...|$|R
5000|$|DRM {{mechanisms}} {{also use}} certificates and asymmetric key cryptography in many cases. In all such cases, tamper resistance means not allowing the device user {{access to the}} valid device certificates or public-private keys of the device. The process of making <b>software</b> robust against <b>tampering</b> attacks {{is referred to as}} [...] "software anti-tamper".|$|R
50|$|In {{addition}} to requiring companies to improve cybersecurity, Congress is also considering bills that criminalize cyber-attacks. The Securely Protect Yourself Against Cyber Trespass Act (SPY ACT) was {{a bill of}} this type. This bill, which focused on phishing and spyware bill was passed on May 23, 2005 in the United States House of Representatives, but died in the Senate. This bill “makes unlawful the unauthorized usage of a computer {{to take control of}} it, modify its setting, collect or induce the owner to disclose personally identifiable information, install unsolicited <b>software,</b> and <b>tamper</b> with security, anti-spyware, or anti-virus software”.|$|R
40|$|The usage of  {{computing}} resources which are distributed {{as a service}} over a network is a cloud computing. There {{are a number of}} well-known profitable and individual cloud computing services to date. The choice of reactive information mutual in the cloud stress the cloud data sharing service to be held responsible for  protected and enforcement of data contented access among users.  The clients data are as usual practiced indistinctly, the same as in unidentified machinery users do not function is the most important characteristic of the cloud services. Extremely scalable services are without difficulty consumed over the Internet which are enabled by cloud computing. The client can be fear of supervising the information and can {{turn out to be a}} significant obstacle to the wide approval of cloud services. To examine the practice of user’s data in the cloud, it is necessary to make available an effectual method for them. For the tracking of the actual usage of the users’ data in the cloud, a new exceedingly decentralized information accountability structure is projected.  By means of user’s data and policies an object-centered method which facilitates enclosing our logging method collectively is proposed. Based on the concept of information accountability a new approach namely Cloud Information Accountability framework is projected. To confirm the reliability of the Java Running Environment and the confirmation of Java Archive files improvement approach is planned. The examination is aimed at providing <b>software</b> <b>tamper</b> resistance for java applications. </p...|$|R
50|$|Remote {{attestation}} allows {{changes to}} the user's computer to be detected by authorized parties. For example, software companies can identify unauthorized changes to <b>software,</b> including users <b>tampering</b> with their <b>software</b> to circumvent technological protection measures. It works by having the hardware generate a certificate stating what software is currently running. The computer can then present this certificate to a remote party to show that unaltered software is currently executing.|$|R
40|$|Abstract. The {{problem of}} {{defending}} <b>software</b> against <b>tampering</b> by a malicious host {{is not expected}} to be solved soon. Rather than trying to defend against the first attack, randomization tries to minimize the impact of a successful attack. Unfortunately, widespread adoption of this technique is hampered by its incompatibility with the current software distribution model, which requires identical physical copies. The ideas presented in this paper are a compromise between distributing identical copies and unique executions by diversifying at run time, based upon additional chaff input and variable program state. This makes it harder to zoom in on a point of interest and may fool an attacker into believing that he has succeeded, while the attack will work only {{for a short period of}} time, a small number of computers, or a subset of the input space. ...|$|R
40|$|Nowadays, {{considering}} {{the availability of}} relatively cheap devices and powerful editing <b>software,</b> video <b>tampering</b> is a relatively easy task. Video sequences can be tampered with by performing, e. g., temporal splicing. However, if the sequences spliced together do not share the same frame rate, {{they have to be}} temporally interpolated beforehand. This operation is often made using motion compensated interpolators, which allow to minimize visual artifacts. In this paper we propose a detector of this kind of interpolation. Moreover, the detector is capable of identifying the interpolation factor used, allowing an analyst to uncover the original frame rate of a sequence. This method relies on the analysis of the correlation introduced by the filter adopted by the interpolator. Results show that detection is successful, provided that the number of observed interpolated frames is large enough. Moreover, tests on compressed sequences obtained from television broadcasts validate the method in a real world scenario...|$|R
40|$|Abstract — Despite current {{software}} protection techniques, applications are still analysed, tampered with, and abused {{on a large}} scale. Crackers 1 compensate for each new protection technique by adapting their analysis and tampering tools. This paper presents a low-cost mechanism to effectively protect <b>software</b> against global <b>tampering</b> attacks. By introducing diversity per programme instance, we illustrate how to defeat various patching methods using inlined code snippets. We propose an efficient technique for creating the snippets based on genetic programming ideas, and illustrate how our approach might trigger a small-scale arms race between defending and attacking parties, each forced to evolve in order to “stay in the game”. I...|$|R
40|$|This study mainly {{based on}} Radix-K dynamic graph {{software}} watermark. Aiming to the weak robustness against attacks {{showing in the}} existing Radix-K dynamic graph, we propose a software watermark scheme of the tamper resistant radix dynamic graph coding. Considering of the coding efficiency, we introduce constant coding in the program and make the constant coding depend on software watermark coding structure. When attacks <b>tamper</b> <b>software</b> watermark structure, the extracted constants are not correct value and lead the program to fail, then we can effectively protect the software watermark information what is embedded into program. At last, the new dynamic graph watermark scheme is on SandMark system and selects different encoding methods to embed into watermark graph, we analysis of its coding efficiency, robustness, program overload and so on...|$|R
30|$|With {{digital imaging}} {{equipment}} and processing <b>software</b> springing up, <b>tampering</b> of digital image {{has become so}} easy and convenient. A frequent and fundamental type of image tampering is splicing which pastes image fragments from the same or different images into the host image by crop-and-paste operation. Though {{there might be some}} more professional artifices such as scaling, rotation, brightening, blurring, and smoothing after splicing, a careful and skillful splicing image can avoid any obvious trace of manipulation even without any of those above post-operations. Just as what the dissymmetry of information security reveals, though digital image tampering is quite a simple thing with modern techniques, its detection is actually a tough mission. Consequently, when photos as a record of what have happened cannot be trusted, it is a great threat to our society security especially in aspects like news media, military, and legal arguments.|$|R
40|$|For {{enhancing}} the protection level of dynamic graph software watermarks {{and for the}} purpose of conducting the analysis which evaluates the effect of integrating two software protection techniques such as <b>software</b> watermarking and <b>tamper</b> proofing, constant encoding technique along with the enhancement through the idea of constant splitting is proposed. In this paper Thomborson technique has been implemented with the scheme of breaking constants which enables to encode all constants without having any consideration about their values with respect to the value of watermark tree. Experimental analysis which have been conducted and provided in this paper concludes that the constant encoding process significantly increases the code size, heap space usage, and execution time, while making the tamper proofed code resilient to variety of semantic preserving program transformation attacks. Comment: 7 pages IEEE format, International Journal of Computer Science and Information Security, IJCSIS December 2009, ISSN 1947 5500, [URL]...|$|R
40|$|The {{insecurity}} of modern-day software {{has created}} the need for security monitoring applications. Two serious deficiencies are commonly found in these applications. First, the absence of isolation from the system being monitored allows malicious <b>software</b> to <b>tamper</b> with them. Second, the lack of secure and reliable monitoring primitives in the operating system makes them easy to be evaded. A technique known as Virtual Machine Introspection attempts to solve these problems by leveraging the isolation and mediation properties of full-system virtualization. A problem known as semantic gap, however, {{occurs as a result}} of the low-level separation enforced by the hypervisor. This thesis proposes and investigates novel techniques to overcome the semantic gap, advancing the state-of-the-art on the syntactic and semantic view re-creation for applications that conduct passive and active monitoring of virtual machines. First, we propose a new technique for reconstructing a syntactic view of the guest OS kernel's heap state by applying a combination of static code and dynamic memory analysis. Our key contribution is the accuracy and completeness of our analysis. We also propose a new technique that allows out-of-VM applications to invoke and securely execute API functions inside the monitored guest's kernel, eliminating the need for the application to know details of the guest's internals. Our key contribution is the ability to overcome the semantic gap in a robust and secure manner. Finally, we propose a new virtualization-based event monitoring technique based on the interception of kernel data modifications. Our key contribution is the ability to monitor operating system events in a general and secure fashion. PhDCommittee Chair: Lee, Wenke; Committee Member: Ahamad, Mustaque; Committee Member: Cui, Weidong; Committee Member: Giffin, Jonathon; Committee Member: Schwan, Karste...|$|R
40|$|The digital {{protection}} of electrical power apparatus {{has been an}} active area of research for the past twenty years. These research results are being utilized {{in some of the}} digital relay designs. The digital {{protection of}} power transformers requires complex calculations and logic, hence the use of a digital processor seems to be natural and attractive. [...] A stand-alone prototype digital protective relay for power transformer protection has been designed, implemented and tested successfully. The prototype digital relay integrates up to three different relaying functions in a single relay. Any changes to the relay operating characteristic can be carried out simply in the <b>software</b> without <b>tampering</b> with the hardware. The relay hardware is designed in two different boards namely, the data acquisition and the digital processing boards. The data acquisition board consists of seven identical circuits each having a scaling circuit, a sixth order Chebyshev anti-aliasing filter and a sample-and-hold circuit. All the seven signals are then multiplexed and connected to an A/D converter. The digital processing board consists of a TMS 320 E 15 digital signal processor. [...] The relay software program is developed for the complete three phase percentage differential relay with second harmonic restraint for inrush and fifth harmonic restraint for overexcitation. The primary and secondary ground fault protection is also provided. The software is written in modular form such that any relay algorithm can be used by simply changing only one subroutine. The present relay design utilizes the Discrete Fourier Transform (DFT) to extract the current harmonics. [...] The prototype digital relay was tested extensively in the laboratory for a duration of three months. The results of these tests show that the relay always cleared all the faults that were applied on the transformer and the relay never maloperated...|$|R
50|$|Anti-tamper {{protection}} can {{be applied}} as either internally or externally to the application being protected. External anti-tampering is normally accomplished by monitoring the <b>software</b> to detect <b>tampering.</b> This type of defense is commonly expressed as malware scanners and anti-virus applications. Internal anti-tampering is used to turn an application into its own security system and is generally done with specific code within the software that will detect tampering as it happens. This type of tamper proofing defense may {{take the form of}} runtime integrity checks such as cyclic redundancy checksums, anti-debugging measures, encryption or obfuscation. Execution inside a virtual machine has become a common anti-tamper method used in recent years for commercial software; it is used for example in StarForce and SecuROM. Some anti-tamper software uses white-box cryptography, so cryptographic keys are not revealed even when cryptographic computations are being observed in complete detail in a debugger. A more recent research trend is tamper-tolerant software, which aims to correct the effects of tampering and allow the program to continue as if unmodified. A simple (and easily defeated) scheme of this kind was used in the Diablo II video game, which stored its critical player data in two copies at different memory locations and if one was modified externally, the game used the lower value.|$|R
40|$|Software {{protection}} {{is one of}} the most important problems in the area of computing as it affects a multitude of players like software vendors, digital content providers, users, and government agencies. There are multiple dimensions to this broad problem of software protection. The most important ones are: (1) protecting software from reverse engineering. (2) protecting <b>software</b> from <b>tamper</b> (or modification). (3) preventing software piracy. (4) verification of integrity of the software;In this thesis we focus on these areas of software protection. The basic requirement to achieve these goals is to provide a secure execution environment, which ensures that the programs behave in the same way as it was designed, and the execution platforms respect certain types of wishes specified by the program;We take the approach of providing secure execution environment through architecture support. We exploit the power of reconfigurable components in achieving this. The first problem we consider is to provide architecture support for obfuscation. This also achieves the goals of tamper resistance, copy protection, and IP protection indirectly. Our approach is based on the intuition that the software is a sequence of instructions (and data) and if the sequence as well the contents are obfuscated then all the required goals can be achieved;The second problem we solve is integrity verification of the software particularly in embedded devices. Our solution is based on the intuition that an obfuscated (permuted) binary image without any dynamic traces reveals very little information about the IP of the program. Moreover, if this obfuscation function becomes a shared secret between the verifier and the embedded device then verification can be performed in a trustworthy manner;Cryptographic components form the underlying building blocks/primitives of any secure execution environment. Our use of reconfigurable components to provide software protection in both Arc 3 D and TIVA led us to an interesting observation about the power of reconfigurable components. Reconfigurable components provide the ability to use the secret (or key) in a much stronger way than the conventional cryptographic designs. This opened up an opportunity for us to explore the use of reconfigurable gates to build cryptographic functions...|$|R

