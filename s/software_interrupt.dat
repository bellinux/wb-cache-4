46|77|Public
2500|$|Flow of control: JMP (jump), JSR (jump to subroutine), BSR (relative address jump to subroutine), RTS (return from subroutine), RTE (return from exception, i.e. an interrupt), TRAP (trigger a {{software}} exception similar to <b>software</b> <b>interrupt),</b> CHK (a conditional software exception) ...|$|E
2500|$|Supervisor mode {{is used by}} the kernel for {{low level}} tasks that need {{unrestricted}} access to hardware, such as controlling how memory is accessed, and communicating with devices such as disk drives and video display devices. User mode, in contrast, is used for almost everything else. Application programs, such as word processors and database managers, operate within user mode, and can only access machine resources by turning control over to the kernel, a process which causes a switch to supervisor mode. [...] Typically, the transfer of control to the kernel is achieved by executing a <b>software</b> <b>interrupt</b> instruction, such as the Motorola 68000 TRAP instruction. [...] The <b>software</b> <b>interrupt</b> causes the microprocessor to switch from user mode to supervisor mode and begin executing code that allows the kernel to take control.|$|E
5000|$|... where [...] is the <b>software</b> <b>interrupt</b> {{that should}} be {{generated}} (0-255).|$|E
5000|$|<b>Software</b> interrupt: an <b>interrupt</b> {{generated}} {{within a}} processor by executing an instruction. <b>Software</b> <b>interrupts</b> {{are often used}} to implement system calls because they result in a subroutine call with a CPU ring level change.|$|R
5000|$|As {{previously}} noted, [...] and [...] are <b>software</b> <b>interrupts</b> and, as such, {{may be used}} in {{a variety}} of ways to implement system functions.|$|R
40|$|Abstractâ€”Hardware and <b>software</b> <b>interrupts</b> {{negatively}} affect system performance {{primarily because of}} pipeline flushing and pollution of TLB and caches. We propose a new architecture {{that focuses on the}} performace degradation caused by hardware and <b>software</b> <b>interrupts.</b> To reduce this performance degradation utilizing TLB, data and instruction caches effectively, our pro-posed architecture includes three proposals: clock interruption reduction with scheduler processor, a syscall thread of FlexSC [2] on scheduler processor, and non-busy waiting polling by non-blocking system calls on the syscall thread of FlexSC...|$|R
50|$|Implementing system calls {{requires}} a control transfer from user space to kernel space, which involves {{some sort of}} architecture-specific feature. A typical way to implement this {{is to use a}} <b>software</b> <b>interrupt</b> or trap. Interrupts transfer control to the operating system kernel so software simply needs to set up some register with the system call number needed, and execute the <b>software</b> <b>interrupt.</b>|$|E
5000|$|Depending on the context, compiler, or assembler, a <b>software</b> <b>interrupt</b> {{number is}} often given as a {{hexadecimal}} value, sometimes with a prefix 0x or the suffix h. For example, [...] will generate the <b>software</b> <b>interrupt</b> 0x21 (33 in decimal), causing the function pointed {{to by the}} 34th vector in the interrupt table to be executed, which is typically an MS-DOS API call.|$|E
5000|$|An {{advanced}} <b>software</b> <b>interrupt</b> {{facility that}} allowed user processes to operate asynchronously, using complex interrupt handling mechanisms.|$|E
50|$|Each {{interrupt}} {{has its own}} interrupt handler. The {{number of}} hardware interrupts {{is limited by the}} number of interrupt request (IRQ) lines to the processor, but there may be hundreds of different <b>software</b> <b>interrupts.</b> Interrupts are a commonly used technique for computer multitasking, especially in real-time computing. Such a system is said to be interrupt-driven.|$|R
50|$|MS-DOS {{compatibility}} {{was added}} {{late in the}} design, so hardware <b>interrupts</b> and MS-DOS <b>software</b> <b>interrupts</b> overlapped. One DEC documentation pack for developers included a listing of Microsoft assembly code to handle this. The theory was that hardware interrupts would <b>interrupt</b> again but <b>software</b> <b>interrupts</b> would only happen once. The Rainbow 100B fixed this overlap in hardware by changes to the board design that allowed the OS to move the hardware interrupts. This means that the MS-DOS 3.10b version for the Rainbow can only run on the Rainbow 100B.|$|R
50|$|One of {{the most}} useful DOS <b>software</b> <b>{{interrupt}}s</b> was interrupt 0x21. By calling it with different parameters in the registers (mostly ah and al) you could access various IO operations, string output and more.|$|R
5000|$|... {{executing}} a <b>software</b> <b>interrupt</b> {{when the}} CPL {{is greater than}} the DPL set for the interrupt gate ...|$|E
50|$|INT is an x86 {{instruction}} that triggers a <b>software</b> <b>interrupt,</b> and 13hex is the interrupt number (as a hexadecimal value) being called.|$|E
5000|$|<b>Software</b> <b>Interrupt</b> (Swi): {{structured}} {{to be similar}} to Hwis, but allow processing to be deferred until after a hardware interrupt has completed.|$|E
5000|$|CTSS used a {{modified}} IBM 7094 mainframe computer that had two 32,768 (32K) 36-bit-word banks of core memory {{instead of the}} normal one. [...] One bank was reserved for the time-sharing supervisory program, the other for user programs. CTSS had a protected-mode kernel, the supervisor's functions in the A-core (memory bank A) could only be called by <b>software</b> <b>interrupts,</b> like in the modern operating systems. Causing memory-protection interrupts were used for <b>software</b> <b>interrupts.</b> Processor allocation scheduling with a quantum time unit 200 ms, was controlled by a multilevel feedback queue. It also had some special memory-management hardware, a clock interrupt {{and the ability to}} trap certain instructions.|$|R
50|$|A more {{efficient}} approach consists in software debugger technique. Some {{parts of the}} code are executed natively on the real processor; on 'bad' instructions, there are <b>software</b> <b>interrupts</b> that break execution of the guest operating system code and that particular instruction is emulated.|$|R
5000|$|Use of the IDT is {{triggered}} by {{three types of}} events: hardware <b>interrupts,</b> <b>software</b> <b>interrupts,</b> and processor exceptions, which together {{are referred to as}} [...] "interrupts". The IDT consists of 256 interrupt vectors-the first 32 (0-31 or 00-1F) of which are reserved for processor exceptions.|$|R
50|$|INT is an {{assembly}} language instruction for x86 processors that generates a <b>software</b> <b>interrupt.</b> It takes the interrupt number formatted as a byte value.|$|E
5000|$|The 65xx {{family of}} microprocessors, {{consisting}} of the MOS Technology 6502 and its derivatives, the WDC 65C02, WDC 65C802 and WDC 65C816, and CSG 65CE02, all handle interrupts in a similar fashion. There are three hardware interrupt signals common to all 65xx processors and one <b>software</b> <b>interrupt,</b> the [...] instruction. The WDC 65C816 adds a fourth hardware interrupt - , useful for implementing virtual memory architectures - and the [...] <b>software</b> <b>interrupt</b> instruction (also present in the 65C802), intended {{for use in a}} system with a coprocessor of some type (e.g., a floating point processor).|$|E
50|$|The 7 accumulator-immediate {{instructions}} are renumbered {{relative to the}} 14-bit PICmicro, to fit into 3 opcode bits rather than 4, but they are all there, {{as well as an}} additional <b>software</b> <b>interrupt</b> instruction.|$|E
50|$|Most Unix {{systems and}} {{derivatives}} {{do not use}} <b>software</b> <b>interrupts,</b> {{with the exception of}} interrupt 0x80, used to make system calls. This is accomplished by entering a 32-bit value corresponding to a kernel function into the EAX register of the processor and then executing INT 0x80.|$|R
50|$|NetBSD uses a {{multilevel}} feedback queue with priorities {{ranging from}} 0-223. 0-63 {{are reserved for}} time-shared threads (default, SCHED_OTHER policy), 64-95 for user threads which entered kernel space, 96-128 for kernel threads, 128-191 for user real-time threads (SCHED_FIFO and SCHED_RR policies), and 192-223 for <b>software</b> <b>interrupts.</b>|$|R
5000|$|Access to {{computer}} systems {{for many years}} consisted of connecting a terminal to a mainframe system via a serial line and the RS-232 protocol. For this reason, when a system of <b>software</b> <b>interrupts,</b> called signals, were being developed, a signal was designated for use on [...] "Hangup".|$|R
5000|$|The {{interrupt}} table contains handlers for hardware interrupts, software interrupts, and exceptions. One {{example of}} a <b>software</b> <b>interrupt</b> handler (there are many others) is in table entry 0x2e. It points to the [...]|$|E
5000|$|Flow of control: JMP (jump), JSR (jump to subroutine), BSR (relative address jump to subroutine), RTS (return from subroutine), RTE (return from exception, i.e. an interrupt), TRAP (trigger a {{software}} exception similar to <b>software</b> <b>interrupt),</b> CHK (a conditional software exception) ...|$|E
5000|$|Some {{instruction}} set designers reserve {{one or more}} opcodes {{for some kind of}} system call or <b>software</b> <b>interrupt.</b> For example, MOS Technology 6502 uses 00H, Zilog Z80 uses the eight codes C7,CF,D7,DF,E7,EF,F7,FFH while Motorola 68000 use codes in the range A000..AFFFH.|$|E
50|$|The bit, {{which is}} bit 9 of the FLAGS register, may be set or cleared by {{programs}} with sufficient privileges, as usually {{determined by the}} Operating System. If the flag is set to 1, maskable hardware interrupts will be handled. If cleared (set to 0), such interrupts will be ignored. IF {{does not affect the}} handling of non-maskable <b>interrupts</b> or <b>software</b> <b>interrupts</b> generated by the INT instruction.|$|R
50|$|To manage {{problems}} with many TSR programs {{sharing the same}} interrupt, a method called Alternate Multiplex Interrupt Specification (AMIS) was proposed by Ralf Brown as an improvement over previously used services offered via INT 2Fh. AMIS provides ways to share <b>software</b> <b>interrupts</b> in a controlled manner. It is modeled after IBM's Interrupt Sharing Protocol, originally invented for sharing hardware interrupts of an x86 processor. AMIS services are available via Int 2Dh.|$|R
5000|$|As {{an example}} of one of the more {{elaborate}} IPL-handling systems ever deployed, the VAX computer and associated VMS operating system supports 32 priority levels, from 0 to 31. Priorities 16 and above are for requests from external hardware, while values below 16 are available for <b>software</b> <b>interrupts</b> (used internally by the operating system to schedule its own activities). Not all values are actually used, but {{here are some of the}} more important ones: ...|$|R
5000|$|Longene has {{two sets}} of system calls and their {{corresponding}} tables: a Windows syscall set and a Linux syscall set. Windows applications call the syscall table via <b>software</b> <b>interrupt</b> [...] "int 0x2e". Linux applications call the syscall table via [...] "int 0x80".|$|E
5000|$|Graphics BASIC also {{supports}} automatic sprite movement (change in place), animation (change in shape), and collision detection. This is {{implemented in the}} language core itself by adding hooks into the Commodore 64's <b>software</b> <b>interrupt</b> routines. (The language does not support adding your own interrupt hooks.) ...|$|E
5000|$|Operating {{systems and}} other {{software}} communicates with the BIOS software, {{in order to}} control the installed hardware, via software interrupts. A <b>software</b> <b>interrupt</b> is a specific variety of the general concept of an interrupt. An interrupt is a mechanism by which the CPU can bedirected to stop executing the main-line program and immediately execute a special program, called an Interrupt Service Routine (ISR), instead. Once the ISR finishes, the CPU continues with the main program. On x86 CPUs, the ISR to call when an interrupt occurs is found by looking it up in a table of their addresses (called [...] "interrupt vectors") in memory. An interrupt is invoked by its type number, from 0 to 255; the type number is used as an index into this table; the address found in the table is the address of the ISR that will be run in response to the interrupt. A <b>software</b> <b>interrupt</b> is simply an interrupt that is triggered by a software command; therefore, software interrupts function like subroutines, with the main difference that the program that makes a <b>software</b> <b>interrupt</b> call does not need to know the address of the ISR, only its interrupt number. This has advantages for modularity, compatibility, and flexibility in system configuration.|$|E
40|$|We {{present a}} new side-channel attack against soft {{keyboards}} that support gesture typing on Android smartphones. An application without any special permissions can observe {{the number and}} timing of the screen hardware <b>interrupts</b> and system-wide <b>software</b> <b>interrupts</b> generated during user input, and analyze this information to make inferences about the text being entered by the user. System-wide information is usually considered less sensitive than app-specific information, but we provide concrete evidence {{that this may be}} mistaken. Our attack applies to all Android versions, including Android M where the SELinux policy is tightened...|$|R
50|$|On Linux and Solaris platforms, if {{the native}} code {{registers}} {{itself as a}} signal handler, it could intercept signals intended for the JVM. A chain of responsibility {{can be used to}} allow native code to better inter-operate with the JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated <b>software</b> <b>interrupts</b> (such as NULL pointer access violations and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception.|$|R
50|$|GDI {{was present}} in the initial release of Windows. MS-DOS {{programs}} had hitherto manipulated the graphics hardware using <b>software</b> <b>interrupts</b> (sometimes via the Video BIOS) and by manipulating video memory directly. Code written in this way expects {{that it is the}} only user of the video memory, which was not tenable on a windowed system like Microsoft Windows, where multiple applications would want to write (to their own subwindows) concurrently. BYTE in December 1983 discussed Microsoft's plans for a system to output graphics to both printers and monitors with the same code in the forthcoming first release of Windows.|$|R
