2|47|Public
40|$|The {{performance}} of modern computer systems is increasingly often limited by long latencies of accesses {{to the memory}} subsystems. Instruction–level multithreading is an architectural approach to tolerating such long latencies by <b>switching</b> <b>instruction</b> threads rather than waiting for the completion of memory operations. The paper studies performance limitations in distributed–memory block multithreaded systems and determines conditions for such systems to be balanced. Event– driven simulation of a timed Petri net model of a simple distributed–memory system confirms the derived performance results. ...|$|E
40|$|Today {{with the}} latest {{technology}} the information beyond tool movement and <b>switching</b> <b>instruction</b> such as tooling, manufacturing features and process sequences are needed to support global adaptability for manufacturing with a specific focus on CNC-based manufacture This research focuses {{on the use of}} the new standard; ISO 14649 (STEP-NC), to address the process planning and machining of discrete turn/mill components and proposes a STEP Compliant NC structure for generation of ISO 14646 code which can be used for turned component manufacture. The novel application of this work is STEP-NC compliant process control where the research will utilise and extend the standard for in process measurement at the machine and also explore the application and integration of the STEP-NC standards. The major contribution of this research is the review of a computational environment for a STEPNC compliant system for turn/mill operations...|$|E
40|$|Voluntary control {{processes}} can {{be recruited}} to facilitate recollection {{in situations where}} a retrieval cue fails to automatically bring to mind a desired episodic memory. We investigated whether voluntary control processes can also stop recollection of unwanted memories that {{would otherwise have been}} automatically recollected. Participants were trained on cue–associate word-pairs, then repeatedly presented with the cue and asked to either recollect or avoid recollecting the associate, while having the event-related potential (ERP) correlate of conscious recollection measured. Halfway through the phase, some cues <b>switched</b> <b>instructions</b> so that participants had to start avoiding recall of associates they had previously repeatedly recalled, and vice versa. ERPs during recollection avoidance showed a significantly reduced positivity in the correlate of conscious recollection, and <b>switching</b> <b>instructions</b> reversed the ERP effect even for items that had been previously repeatedly recalled, suggesting that voluntary control processes can override highly practiced, automatic recollection. Avoiding recollection of particularly prepotent memories was associated with an additional, earlier ERP negativity that was separable from the later voluntary modulation of conscious recollection. The findings have implications for theories of memory retrieval by highlighting the involvement of voluntary attentional processes in controlling conscious recollectio...|$|R
40|$|Detailed {{clearing}} {{procedures and}} written <b>switching</b> <b>instructions,</b> {{together with a}} single line diagram, must be used in order to perform maintenance operations on a Working Zone (WZ). Previous papers of the authors have introduced a graphical representation, a color convention and a logic code to facilitate programming. This paper advances the above techniques through the "Parise Program", which is offered as a faster, easier way to establish lockout procedures. A software program using a PC, based on the model in this paper, has been developed...|$|R
50|$|Adoption of SIMD {{systems in}} {{personal}} computer software {{was at first}} slow, due {{to a number of}} problems. One was that many of the early SIMD instruction sets tended to slow overall performance of the system due to the re-use of existing floating point registers. Other systems, like MMX and 3DNow!, offered support for data types that were not interesting to a wide audience and had expensive context <b>switching</b> <b>instructions</b> to <b>switch</b> between using the FPU and MMX registers. Compilers also often lacked support, requiring programmers to resort to assembly language coding.|$|R
40|$|Abstract:- Dual width {{instruction}} set embedded processors such as ARM provide 16 -bit {{instruction set}} {{in addition to}} the 32 -bit instructions set for lower energy and memory cost. The combination of hardware multithreading technique with the 16 -bit code design can provide a tradeoff between performance and code size. In this paper, extension thread <b>switch</b> <b>instruction</b> (Ts) is added to the Thumb instruction set. With the decoder supporting, no extra cycles are needed to handle the Ts instructions. From analysis, our approach is a more flexible thread switch mechanism and provides better performance with little extra hardware cost...|$|R
5000|$|Only the Program Counter, Status Register, and Workspace Pointer {{registers}} {{are on the}} chip; {{all work}} registers are kept in RAM at an address indicated by the Workspace Pointer. 16 registers are available at any given time, and a context <b>switch</b> <b>instruction</b> which changed to another workspace automatically allows fast context switches compared to other processors which may have had to store and restore the registers. For CPU RAM, the machine has only 256 bytes of [...] "scratchpad" [...] memory to support the storage of workspaces. This memory is placed directly on the 16-bit bus with zero wait states, making it much faster than any other memory available to the system.|$|R
40|$|AbstractCurrent WAM-type compilers employ {{incremental}} compilation, {{in which}} each procedure is compiled in isolation from the program as a whole. This approach is ideal for {{the initial stages of}} program development, since procedures can be compiled and recompiled very quickly. We have developed global compilation techniques {{to be used in the}} final stages of program development. These techniques use data-flow and control-flow information to optimize the intermediate code. Specifically, the optimizations involve using inferred mode information to generate indexing code which intermixes unification instructions, primitive test <b>instructions,</b> and <b>switching</b> <b>instructions.</b> One of the primary goals of this research is to develop global compilation techniques which eliminate the need for the user to insert cuts in the program to improve performance. Empirical results show that these optimizationscan result in significant time and space savings...|$|R
50|$|A Change Address Mode (CAM) <b>instruction</b> <b>switched</b> between 2-, 3- and 4-character {{address mode}}s.The address mode {{specified}} {{the number of}} characters needed for each operand address in instructions.|$|R
50|$|ARM {{processors}} use ARM register {{banks for}} fast interrupt request. x86 processors use context switching and fast interrupt for <b>switching</b> between <b>instruction,</b> decoder, GPRs and register files, {{if there is}} more than one, before the instruction is issued, but this is only existing on processors that support superscalar. However, context switching is a totally different mechanism to ARM's register bank within the registers.|$|R
40|$|We {{present a}} {{compilation}} technique that targets realtime applications running on embedded processors with com-bined dynamic voltage scaling (DVS) and adaptive body biasing (ABB) capabilities. Considering the delay and en-ergy penalty of switching between operating modes of the processor, our compiler judiciously inserts mode <b>switch</b> <b>instructions</b> in selected {{locations of the}} code and generates executable binary that is guaranteed {{to meet the deadline}} constraint. More importantly, our algorithm runs very fast and comes reasonably close to the theoretical limit of energy optimization using DVS+ABB. At 65 nm technology, we improve the energy dissipation of the generated code by an average of 11 4 % under deadline constraints. While our technique’s improvement in energy dissipation over conven-tional DVS is marginal (3 %) at 130 nm, the average im-provement continues to grow to 4 7 %, 8 8 % and 15 4 % for 90 nm, 65 nm and 45 nm technology nodes, respectively. Compared to a recent ILP-based competitor, we improve the runtime by more than three orders of magnitude, while producing improved results...|$|R
5000|$|In {{a packet}} {{switched}} network, burst switching is a capability {{in which each}} network <b>switch</b> extracts routing <b>instructions</b> from an incoming packet header {{to establish and maintain}} the appropriate switch connection {{for the duration of the}} packet, following which the connection is automatically released.|$|R
40|$|Energy {{consumption}} {{has become}} a major constraint in providing increased functionality for devices with small form factors. Dynamic voltage and frequency scaling has been identified as an effective approach for reducing the energy consumption of embedded systems. Earlier works on dynamic voltage scaling focused mainly on performing voltage scaling when the CPU is waiting for memory subsystem or concentrated chiefly on loop nests and/or subroutine calls having sufficient number of dynamic instructions. This paper concentrates on coarser program regions {{and for the first time}} uses program phase behavior for performing dynamic voltage scaling. Program phases are annotated at compile time with mode <b>switch</b> <b>instructions.</b> Further, we relate the Dynamic Voltage Scaling Problem to the Multiple Choice Knapsack Problem, and use well known heuristics to solve it efficiently. Also, we develop a simple integer linear program formulation for this problem. Experimental evaluation on a set of media applications reveal that our heuristic method obtains a 38 % reduction in energy consumption on an average, with a performance degradation of 1 % and upto 45 % reduction in energy with a performance degradation of 5 %. Further, the energy consumed by the heuristic solution is within 1 % of the optimal solution obtained from the ILP approach...|$|R
40|$|Modern network {{processors}} {{such as the}} Intel IXP family {{hide the}} latency of slow instructions by supporting multiple threads of execution. Context switches in the IXP architecture {{are designed to be}} very fast. However, the low overhead is partly achieved by leaving register management to programs, with little support from the hardware. The complexity of the multi-engine, multi-threaded environment makes manual register management a daunting task, which is better left to the compiler. However, a purely static analysis {{may not be able to}} achieve full utilization of the register file due to conservative estimates of liveness. A register that is live across a context switch point must be considered live for the duration of all other threads, and so it must be assumed to be unavailable to other threads. In addition, aliasing further reduces the effectiveness of static analysis. The net effect is a large number of idle cycles that are still present after static optimization. We propose a dynamic solution that requires minimal software and hardware support. On the software side, we take a pre-allocated binary file and annotate the potential context <b>switch</b> <b>instructions</b> with information about the dead registers. On the hardware side, we try to rename all transfer registers and addresses to dead general purpose registers and update the vector of used registers. We then replace the long-latency memory instructions with fast move instructions in the architecture using the dynamic context. The results show up to 51 % reduction in idle cycles and up to 14 % increase in the throughput for hand coded applications...|$|R
40|$|Lockout" and "tagout" {{procedures}} {{to ensure safety}} is universally accepted. In order to perform operations of electrical maintenance on a zone, portion or components of the system, {{it is necessary to}} use more elaborate clearing procedures and written <b>switching</b> <b>instructions</b> for systems, together with a single-line diagram. Past practice has been largely empirical. This paper offers an analytical approach to the problem. Complex power distribution systems may have several operating bonds (interconnections), such as multiple sources and switching devices in each area or zone. They require several operating steps to isolate the safe working zone SWZ. Details of developing and applying lockout/tagout procedures can vary. This paper presents an analytical approach to the planning and control of lockout/tagout procedures. It reviews and enhances previous papers and investigates the basic concepts and definitions to give prominence to operating bonds and to provide alternative, independent lockout/tagout analysis. It proposes some simple rules and bond definitions to facilitate programming. It introduces a "new language", that is a graphical representation, a color convention and a logic code to write and show symbolically the instruction list of electrical status. Together, intuitive and mathematical approaches can heighten understanding. The Parise program allows memorizing visually the logic procedures, counting the necessary locks and executing an auto-check of the clearing procedure. Software programs using a PC, based on the model in this paper, have been developed for aided or interactive training on network samples and for planning new networks. They can facilitate a faster evaluation and an accurate analysis, reducing the risk of error...|$|R
40|$|This paper {{describes}} a processor, the Ultrascalar, {{based on such}} a structure. We have layed out the Ultrascalar's datapath in an H-tree layout using the Magic design tool. We built our own CMOS standard cells which we used in designing the register datapath. Figure 1 depicts this datapath for a 64 -station Ultrascalar. Each leaf-node of the H-tree represents a processing element, called an execution station, which executes one instruction. Execution stations are in turn connected by <b>switches.</b> <b>Instructions</b> are assigned to execution stations in a wrap-around sequence. The execution stations are connected to a memory subsystem via a butterfly network (not shown in Figure 1). The butterfly network can be layed out as a H-tree as well. The memory subsystem can consist of a conventional fetch unit and a data cache, or of more sophisticated components such as an instruction trace cache and an interleaved data cache. The layout is called an H-tree layout because it consists of recursive H-shaped structures. Note that a cluster of four stations forms the letter H; four clusters form another H and so on. The Ultrascalar processor when attached to a conventional memory subsystem exploits exactly the same instruction-level parallelism as that of today's superscalar processors. The Ultrascalar renames the registers of all outstanding instructions, reads all arguments, bypasses the results, issues instructions that meet the control and data dependencies, and reverts back from any mispredicted branches. The Ultrascalar achieves this with multiple instances of a single circuit structure - the cyclic, segmented parallel prefix tree. The prefix trees pass register values from producer instructions to consumer instructions within the wrap-around sequence, retire instructions in-order, and [...] ...|$|R
40|$|Compressing code {{is known}} {{to be one of the}} most {{effective}} methods of reducing the energy consumed in the interface between memory and processor. In this paper, we addressed the problem, which has not been tackled in the previous code compression techniques, of determining binary code of the instructions to be compressed. Our observation is that a careful assignment of binary code to the instructions to be compressed can lead to a considerable amount of power saving since the <b>switching</b> activity in <b>instruction</b> accesses varies significantly depending on the ways of assigning binary code to the instructions. To achieve the power saving, we analyze the problem and transform it into a graph optimization problem and solve it efficiently, but effectively by inventing an incremental node covering technique. From experiments using a set of benchmark programs, it is shown that the approach is quite effective, producing code with 17. 3 %- 27. 1 % less <b>switching</b> activity in <b>instruction</b> accesses over a greedy (gray-code based) low-power binary code assignment. I...|$|R
40|$|Everyone who {{interacts with}} an {{electrical}} power system knows that for all operating occurrences a complete control {{of the system is}} necessary. Safety when working in presence of electricity is a universal goal. Finding practical methods to achieve this safety, however, is not always easy or obvious. Maintenance personnel must take the necessary steps to assure that the system or portion of the system on which they plan to work is in an electrically safe working condition [11. The accepted, reliable way to provide safety is to de-energize the equipment first, then to connect the equipment to ground so that it cannot be reenergized. If there is no electrical power, there is no risk of electrical injury. Complexity of the electrical system normally determines the level of detail planning required for system clearing procedures. Complex power distribution systems that may have several sources into an area require several switching steps to isolate a portion of the system. It is necessary to use more elaborate clearing procedures and written <b>switching</b> <b>instructions</b> for systems together with a single-line diagram [l]. The instructions and/or procedures should include verifying that the power has been removed (by live line testing or other means,) followed by the placing of grounds and locking/tagging of isolating devices(l 1. The clearing procedures should be completely written, checked and understood by all persons involved before applying them to any portion of the power distribution system. This paper considers the subject from both European and American point of view. It investigates the basic concepts and definitions to give prominence to operating bonds and to help the procedure-project. It proposes some simple rules, a graphical representation and an algebraic model of electrical status to allow an auto-check of the clearing procedure...|$|R
40|$|Multithreaded {{architectures}} context <b>switch</b> between <b>instruction</b> streams to hide {{memory access}} latency. Although this improves processor utilization, it can increase cache interference and degrade overall performance. One technique {{to reduce the}} interconnect traffic is to co-locate threads that share data on the same processor. Multiple threads sharing in the cache should reduce compulsory and invalidation misses, thereby improving execution time. To test this hypothesis, we compared a variety of thread placement algorithms via trace-driven simulation of fourteen coarse- and medium-grain parallel applications on several multithreaded architectures. Our results contradict the hypothesis. Rather than decreasing, compulsory and invalidation misses remained nearly constant across all placement algorithms, for all processor configurations, even with an infinite cache. That is, sharing-based placement had no (positive) effect on execution time. Instead, load balancing was the critical factor t [...] ...|$|R
40|$|Memory for an {{interactive}} procedure acquired from written instructions is improved if the procedure {{can be carried}} out while the instructions are being read. The size of the read-act cycle was manipulated in Experiments 1 and 2 by comparing chunked instruction-following, in which 3 or 4 steps are read then performed with single-step conditions. In both experiments, enforced chunking improved subsequent unaided performance of the procedure. In Experiment 3, participants were allowed to manage the interleaving of reading and acting. The imposition of a small behavioral cost (a single mouse point-and-click operation) on the <b>switch</b> between <b>instructions</b> and device encouraged more chunking and better subsequent test performance. The authors concluded that the interleaving of reading and acting is an important practical concern in the design of interactive procedures and that more effective chunk-based strategies can quite readily be encouraged...|$|R
5000|$|Instructions: Machine {{instructions}} are normally {{the size of}} the architecture's word, such as in RISC architectures, or a multiple of the [...] "char" [...] size that is a fraction of it. This is a natural choice since instructions and data usually share the same memory subsystem. In Harvard architectures the word sizes of instructions and data need not be related, as instructions and data are stored in different memories; for example, the processor in the 1ESS electronic telephone <b>switch</b> had 37-bit <b>instructions</b> and 23-bit data words.|$|R
40|$|As mobile {{applications}} {{are required to}} handle more computing-intensive tasks, many mobile devices are designed using VLIW processors for high performance. In VLIW machines where a single instruction contains multiple operations, the power consumption during instruction fetches varies signi cantly {{depending on how the}} operations are arranged within the instruction. In this paper, we describe a post-pass optimal operation rearrangement method for low-power VLIW instruction fetch. The proposed method modi es operation placement orders within VLIW instructions so that the <b>switching</b> activitybetween successive <b>instruction</b> fetches is minimized. Our experiment shows that the switching activity can be reduced by 34 % on average for benchmark programs. I...|$|R
40|$|Decompiling {{is an area}} of {{interest}} for researchers in the field of software reverse engineering. When the source code from a high-level programming language is compiled, it loses a great deal of information, including code structure, syntax, and punctuation. The purpose of this research is to develop an algorithm that can efficiently decompile assembly language into pseudo C code. There are tools available that claim to extract high-level code from an executable file, but the results of these tools tend to be inaccurate and unreadable. Our proposed algorithm can decompile assembly code to recover many basic high-level programming structures, including if/else, loops, <b>switches,</b> and math <b>instructions.</b> The approac...|$|R
5|$|When Ohno {{was very}} young, his father meticulously {{researched}} childcare providers {{to care for}} his son during his long work hours. As he grew older, his father became concerned his son would become a latchkey kid, so he got his son involved with competitive swimming and quad-speed roller skating at age 6. He later <b>switched</b> from the <b>instruction</b> of Benton Redford, a National Champion, to a team in Federal Way, WA called Pattisons Team Extreme and became a national inline speedskating champion and record holder himself. His father used Inline Speedskating to fill his spare time. Ohno's days were spent with morning swimming practices, followed by schooling, and finally skating practices in the afternoon.|$|R
40|$|Abstract. Embedded systems {{demand to}} take high {{performance}} while executing on batteries. In such environment, the systems must be optimized with available technique to reduce energy consumption while not sacrificing performance. Especially, in mobile devices, power consumption {{is an important}} design constraint. Switching activity accounts for over 90 % of total power consumption in a digital circuit. In this paper, we describe an approach to design instruction format for low power instruction fetch. The proposed method reduces switching activity of the instruction fetch logic by using a heuristic that minimizes <b>switching</b> between adjacent <b>instructions.</b> To do this, the proposed approach encodes opcodes so that frequently executed instruction pairs have smaller bit changes...|$|R
50|$|When Ohno {{was very}} young, his father meticulously {{researched}} childcare providers {{to care for}} his son during his long work hours. As he grew older, his father became concerned his son would become a latchkey kid, so he got his son involved with competitive swimming and quad-speed roller skating at age 6. He later <b>switched</b> from the <b>instruction</b> of Benton Redford, a National Champion, to a team in Federal Way, WA called Pattisons Team Extreme and became a national inline speedskating champion and record holder himself. His father used Inline Speedskating to fill his spare time. Ohno's days were spent with morning swimming practices, followed by schooling, and finally skating practices in the afternoon.|$|R
50|$|The normal {{operating}} mode of the CPU is called Full Nucleus. All systems also support a limited {{mode of operation}} called Basic Test. In Basic Test mode, Nucleus is disabled, I/O is performed differently, and only a single program can run, restricted to the bottom 64KiB of store, but all other non-nucleus and non-PAS instructions operate normally. This mode is used very early during booting {{to set up the}} system tables required by Nucleus, before obeying a <b>Switch</b> Full Nucleus <b>instruction.</b> Once the system has switched to Full Nucleus, it cannot return to Basic Test mode without operator intervention at the front panel, in effect killing any operating system which was running. Basic Test mode is also used to run certain test software (hence the name).|$|R
5000|$|Interleaved multithreading: Interleaved {{issue of}} {{multiple}} instructions from different threads, {{also referred to}} as temporal multithreading. It can be further divided into fine-grained multithreading or coarse-grained multithreading depending on the frequency of interleaved issues. Fine-grained multithreading—such as in a barrel processor—issues instructions for different threads after every cycle, while coarse-grained multithreading only <b>switches</b> to issue <b>instructions</b> from another thread when the current executing thread causes some long latency events (like page fault etc.). Coarse-grain multithreading is more common for less context switch between threads. For example, Intel's Montecito processor uses coarse-grained multithreading, while Sun's UltraSPARC T1 uses fine-grained multithreading. For those processors that have only one pipeline per core, interleaved multithreading is the only possible way, because it can issue at most one instruction per cycle.|$|R
40|$|This paper {{presents}} Differential Multithreading (dMT) as {{an inexpensive}} {{way to achieve}} high throughput from a single-issue architecture. dMT <b>switches</b> among multiple <b>instruction</b> streams in response to pipeline stall conditions but saves in-flight instructions, thus squashing pipeline bubbles and ensuring maximal utilization of a single pipeline. dMT uses auxiliary pipeline registers to save the state of in-flight but stalled instructions. This squashes bubbles that would otherwise arise from data hazards, branch delays, and cache misses. This paper describes the pipeline organization necessary to support dMT, explains the advantage of shared-pipeline multithreading, and presents preliminary results which suggest that dMT can substantially increase processor utilization. 1 Introduction Microprocessors for embedded devices must typically use simple organizations, precluding the use of many techniques for exploiting instruction-level parallelism (ILP) like multiple issue, out-of- [...] ...|$|R
5000|$|In {{the second}} season, Professor McNutley <b>switches</b> from English <b>instruction</b> to dramas, the {{institution}} becomes Comstock University, {{and his own}} name is adjusted to [...] "McNulty". Lloyd Corrigan joins the cast as Dean Dodsworth. In the second-season premiere, McNulty is involved with a wealthy alumnus, played by Hans Conreid, later Uncle Tonoose of The Danny Thomas Show, {{who has written a}} play of low quality that McNulty must produce to obtain an endowment. In the episode, Milland uses the expression [...] "Dial B for Blackmail", parodying his role in the film then being released, Dial M for Murder, with co-star Grace Kelly. In the episode [...] "The Doll's House", McNulty directs the college production of the Henrik Ibsen play while his wife decides that she must own a fur coat.|$|R
40|$|This paper {{examines}} differential multithreading (dMT) as {{an attractive}} organization {{for coping with}} pipeline stalls in smallscale processors like those used in embedded environments. The paper proposes extensions to block multithreading to cope with data- and instruction-cache misses, and then explores some of the design tradeoffs that this enables. Results show that dMT boosts throughput substantially and can in fact replace dynamic branch prediction or data forwarding, or {{can be used to}} reduce the sizes of the instruction and data caches. Block multithreading, described by Farrens and Pleszkun, is a technique to achieve high throughput from a single-issue microarchitecture by <b>switching</b> among multiple <b>instruction</b> streams in response to pipeline stalls. Although single-issue organizations are no longer used in high-performance processors, they remain common even in newly-designed processors for small-scale, embedded devices. Like the original description of block multithreading, dMT u [...] ...|$|R
40|$|Many {{programs}} exhibit {{application level}} error resilience which allows certain subcomputations to execute in an imprecise, yet energy efficient manner, potentially yielding significant overall energy savings without sacrificing end-to-end quality. In this thesis we identify one fundamental problem {{that must be}} addressed to realize these energy benefits: even in applications with a large degree of error resilience, error resilient instructions are interleaved with instructions that must be executed precisely at a fine-grained level (about every seven instructions). This interleaving prohibits any energy savings due to the significant costs associated with switching between the modes, typically via voltage scaling, which may require hundreds to thousands of cycles to transition between levels. We propose a novel execution model for single-core architectures that reduces total switching by deferring execution of <b>instructions</b> requiring mode <b>switches,</b> thereby aggregating <b>instructions</b> of the same energy mode and reducing the number of mode switches. Deferre...|$|R
40|$|Low power {{embedded}} processors {{become more}} important for portable applications. For CMOS circuits, power is consumed during the charging and discharging of the capacitances. Reducing switching activities would significantly reduce power consumption of an embedded processor. In this paper, we {{address the problem of}} how to reduce switching activities at the control path of an embedded processor. We study the effects of using Gray code as the addressing scheme to reduce the switching activities. Gray codes have an advantage over the conventional binary code in that consecutive memory addresses have only one-bit different. Due to locality of program execution, Gray code addressing can significantly reduce the amount of <b>switching</b> on the <b>instruction</b> address bits. Also an instruction scheduling technique called cold scheduling, is developed to reorder the instruction sequence to reduce the switching activities. Reducing Power Consumption at the Control Path of High Performance Microprocessors [...] ...|$|R
50|$|The school's origins can {{be traced}} to the 1903 {{founding}} of the Civilian Girls' School. In 1915, this became a Hungarian-language community school, the Gymnasial Community School. In September 1919, following the area's union with Romania, the language of <b>instruction</b> <b>switched</b> to Romanian. In 1920, it became a state school, the Romanian Civilian State Middle School. In 1925, the institution was renamed the Girls' Gymnasium; it became the Girls' High School the following year. In 1927, it was named in honor of poet Iulia Hasdeu. Following the 1948 education reform under the nascent communist regime, the school had eleven grades. It was reduced to ten grades in 1954, when it was renamed Middle School nr. 15. It was refashioned into a high school in 1965. Following the Romanian Revolution, the Hasdeu name was restored in 1990. The distinction of national college was granted in 2004.|$|R
40|$|Abstract — Embedded {{processors}} {{are required}} to achieve high performance while running on batteries. Thus, they must exploit all the possible means available to reduce energy consumption while not sacrificing performance. In this work, one technique to reduce energy is explored to intelligently design the instruction-opcodes of a processor based on a target-workload. The optimization is done using a heuristic that not-only minimizes <b>switching</b> between adjacent <b>instructions,</b> but also simplifies the decoding to reduce latches to save dynamic energy. On average, an optimized opcode is able to be decoded using 40 - 60 % less latches in the decoder. In addition, it is shown that a decoder optimized for algorithms that had similar program structure, similar data-types or similar behavior exhibited consistent patterns of energy reduction. The techniques {{presented in this paper}} yield an average 10 % reduction in the total dynamic energy. It is also shown that this heuristic can be used to achieve similar results on different issue-width processors. I...|$|R
40|$|Power {{consumption}} can {{be greatly}} minimized {{by reducing the}} bus signal transition activity (also called switching activity) in the control and data path circuit. Switching activity occurs due to the <b>switching</b> between two <b>instructions</b> (of the embedded software) on successive clock cycles. Our belief is that the binary encoding of instructions (machine code) {{plays a significant role}} in determining the amount of switching in a circuit. Thus, our aim is to realise a machine encoding of instructions of an ASIP such that for a given data path, it will minimize the average switching activity in the control path circuit of the ASIP and hence the total switching activity in the ASIP. Given the application-domain of the ASIP, we have used information theoretic techniques to arrive at an encoding of the op-code that minimizes redundancy and also the switching activity. We have compared our encoding of instruction op-codes with those obtained by other encoding techniques using a switching activity estimator designed by us. 1...|$|R
