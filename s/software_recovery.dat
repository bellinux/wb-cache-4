26|184|Public
5000|$|Design Engineer quotes Aslihan Yener, Cambashi Consultant in Technical <b>software</b> <b>recovery</b> {{predicted}} in Cambashi report ...|$|E
50|$|Practically, the MVS <b>software</b> <b>recovery</b> made problem {{debugging}} both {{easier and}} more difficult. <b>Software</b> <b>recovery</b> requires that programs leave 'tracks' of {{where they are and}} what they are doing, thus facilitating debugging—but the fact that processing progresses despite an error can overwrite the tracks. Early date capture {{at the time of the}} error maximizes debugging, and facilities exist for the recovery routines (task and system mode, both) to do this.|$|E
50|$|The Microsoft Care {{division}} of Microsoft Mobile also has several other specialised {{versions of the}} Microsoft Software Updater. This includes the Nokia <b>Software</b> <b>Recovery</b> Tool which can recover lost software and unbrick phones {{in a similar manner}} to the Microsoft Software Updater. Its primary aim is to restore lost data after failed update installation attempts. The current version requires Windows 7 or later and is a re-released version of the older Symbian recovery tool. As part of Microsoft's new wave of rebranding it was renamed the Lumia <b>Software</b> <b>Recovery</b> Tool.|$|E
40|$|This paper covers {{current trends}} and issues in <b>software</b> {{architecture}} <b>recovery.</b> It {{consists of a}} summary of the presentations and discussions of the <b>Software</b> Architecture <b>Recovery</b> and Modelling discussion forum held during WCRE 2001, the Working Conference on Reverse Engineering, Stuttgart, Germany, October 2, 2001...|$|R
50|$|<b>Software</b> {{architecture}} <b>recovery</b> may {{be required}} as part of software retrofits.|$|R
40|$|Software {{architectures}} evolve {{over time}} due to requirement and technology changes. Hence, <b>software</b> architecture <b>recovery</b> is often necessary {{to capture and}} document existing systems to effectively support product evolution and maintenance. Architectures of existing systems can be recovered using reverse engineering techniques. Reverse engineering deals with deriving higher-level descriptions of a software system from existing software artifacts, primarily source code. Reverse engineering of source code, often, is a time consuming task. For reasons of limited resources or competition, software architectures could be recovered more efficiently by studying solutions from similar systems. This paper presents an approach for rapid and agile <b>software</b> architecture <b>recovery</b> in a mature domain, network applications. We demonstrate a case study for <b>software</b> architecture <b>recovery</b> by examining an existing architecture in the same domain. The existing architecture help derive a conceptual description for the target system. Meanwhile, some well-known design patterns in the similar domain are used to compare with the target system. The knowledge gained from design patterns provides more detailed information. The process is coupled with iterative reviews of the source code to refine the recovered software architecture. KEY WORDS <b>software</b> architecture <b>recovery,</b> reverse engineering, <b>software</b> evolution, design patterns, analogy 1...|$|R
5000|$|Automatic service restart after failure. Works in {{conjunction}} with the Solaris Fault Manager, allowing <b>software</b> <b>recovery</b> in the event of hardware faults (cpu, memory), admin error such as accidental kills, and software core dumps.|$|E
50|$|In 2015 Microsoft Mobile offers 4 {{distinct}} {{software update}} applications, the Microsoft Software Updater serves primarily to update their feature phones, while the Lumia <b>Software</b> <b>Recovery</b> Tool and Windows Phone Recovery Tools are applications used to update and recover Windows Phone devices, though the Lumia <b>Software</b> <b>Recovery</b> Tool also supports Symbian and other Nokia platforms, and the Nokia Care Suite enables users to install Microsoft Mobile firmware updates for Microsoft Lumia devices. Further Microsoft Mobile offers desktop synchronisation applications which also offer updates to device components {{such as the}} Nokia Suite and its predecessor the Nokia PC Suite for legacy Nokia telephones, though the Nokia Suite also supports content migration for Microsoft Lumia devices such as messages, contacts, and device software.|$|E
50|$|MVS took a {{major step}} forward in fault-tolerance, built on the earlier STAE facility, that IBM called <b>software</b> <b>recovery.</b> IBM decided to do this after years of {{practical}} real-world experience with MVT in the business world. System failures were now having major impacts on customer businesses, and IBM decided to take a major design jump, to assume that despite the very best software development and testing techniques, that 'problems WILL occur.' This profound assumption was pivotal in adding great percentages of fault-tolerance code to the system and likely contributed to the system's success in tolerating software and hardware failures. Statistical information is hard to come by to prove the value of these design features (how can you measure 'prevented' or 'recovered' problems?), but IBM has, in many dimensions, enhanced these fault-tolerant <b>software</b> <b>recovery</b> and rapid problem resolution features, over time.|$|E
50|$|In <b>software</b> testing, <b>recovery</b> {{testing is}} the {{activity}} of testing how well an application is able to recover from crashes, hardware failures and other similar problems.|$|R
40|$|The {{maintenance}} of a software system still represents the most costly part in its development lifecycle. To reduce cost while doing maintenance, developers {{must be able to}} understand the architecture of the existing code base. However, applying detailed <b>software</b> architecture <b>recovery</b> to a large software system is expensive and time consuming. It is instead usually advantageous to perform domain-specific <b>software</b> architecture <b>recovery</b> [...] - with a focus and a directed set of goals for a particular application domain, which encompasses the knowledge used to build a family of software systems...|$|R
50|$|There {{are still}} several {{techniques}} and some free and proprietary <b>software</b> for <b>recovery</b> of deleted or lost files using file system journal analysis; however, {{they do not}} guarantee any specific file recovery.|$|R
50|$|IBM {{included}} {{additional criteria}} for a major software problem that required IBM service. If a mainline component failed to initiate <b>software</b> <b>recovery,</b> that was considered a valid reportable failure. Also, if a recovery routine failed to collect significant diagnostic data such that the original problem was solvable by data collected by that recovery routine, IBM standards dictated that this fault was reportable and required repair. Thus, IBM standards, when rigorously applied, encouraged continuous improvement.|$|E
5000|$|This version {{provides}} a [...] "LightsOut Restore" [...] feature, which restores a system from an on-disk <b>software</b> <b>recovery</b> environment similar to Windows RE, thereby allowing recovery without a bootable CD. Upon system startup, a menu asks whether start {{the operating system}} or the LightsOut recovery environment. LightsOut restore would augment the ISO image, which comes with Ghost. The latter contains a recovery environment that can recover a system without a working operating system.|$|E
5000|$|The {{service can}} be used to restore the {{firmware}} on [...] "bricked" [...] phones which previously could only be done at local Microsoft Care customer service centres. Microsoft Care's range of software update and recovery programs also include a <b>software</b> <b>recovery</b> tool for Lumia-branded Windows Phones that don't start up or respond which may restore the latest firmware. The Recovery tool requires the telephone to have 70-80% battery charge and works only with Windows Phone 8 or higher devices.|$|E
40|$|<b>Software</b> Architecture <b>Recovery</b> {{is one of}} {{the finest}} parts of reverse engineering. Several {{different}} techniques have been adopted in vast literature to recover Software Architecture. One of the techniques is clustering, which extracts the similar components from the software. In general the component characteristics and its state are not clear. For that, Architecture recovered from ordinary clustering will not be appropriate in it. In this paper we used a fuzzy clustering technique to make the <b>Software</b> Architecture <b>recovery</b> to be more efficient and accurate. Our experimental results have shown that Architecture recovers from fuzzy clustering is better than ordinary clustering...|$|R
40|$|Abstract In {{the vast}} {{literature}} Software architecture has been recovered through graphs. During <b>Software</b> Architecture <b>recovery</b> generally matching will takes place between Source graph and Query graph. Graph matching {{is one of}} the phase in which we will find the same sub graph which is present in source graph and query graph. In most of the papers, it was stated that graph matching is complete. But in reality matching between the graphs is not appropriately complete. We call this an error in matching. In this paper we investigate the applicability of error correcting graph matching algorithm, Graph Isomorphism by Decision Tree to compensate the <b>Software</b> Architecture <b>Recovery.</b> 1...|$|R
5000|$|Symantec Backup Exec - {{on-premises}} backup and <b>recovery</b> <b>software</b> {{for small}} to medium enterprises ...|$|R
5000|$|Google's {{applications}} {{have been}} replaced by Nokia's and Microsoft's. When first released, the Google Play store is not included, with Nokia offering apps from their own Nokia Store. However, since the v2.1 update in September 2014 users are allowed to install Google Play and various other Google services through third party tools, but if users attempt to install Google services on their Nokia X devices it would usually get [...] "bricked" [...] and would require the Nokia <b>Software</b> <b>Recovery</b> Tool to restore the data.|$|E
40|$|As {{technology}} scales ever further, device unreliability {{is creating}} excessive complexity for hardware {{to maintain the}} illusion of perfect operation. In this paper, we consider whether exposing hardware fault information to software and allowing software to control fault recovery simplifies hardware design and helps technology scaling. The combination of emerging applications and emerging many-core architectures makes <b>software</b> <b>recovery</b> {{a viable alternative to}} hardware-based fault recovery. Emerging applications tend to have few I/O and memory side-effects, which limits the amount of information that needs checkpointing, and they allow discarding individual sub-computations with small qualitative impact. <b>Software</b> <b>recovery</b> can harness these properties in ways that hardware recovery cannot. We describe Relax, an architectural framework for <b>software</b> <b>recovery</b> of hardware faults. Relax includes three core components: (1) an ISA extension that allows software to mark regions of code for <b>software</b> <b>recovery,</b> (2) a hardware organization that simplifies reliability considerations and provides energy efficiency with hardware recovery support removed, and (3) software support for compilers and programmers to utilize the Relax ISA. Applying Relax to counter the effects of process variation, our results show a 20 % energy efficiency improvement for PARSEC applications with only minimal source code changes and simpler hardware...|$|E
40|$|As {{transistor}} technology scales ever further, hardware reliability {{is becoming}} harder to manage. The effects of soft errors, variability, wear-out, and yield are intensifying {{to the point}} where it becomes difficult to harness the benefits of deeper scaling without mechanisms for hardware fault detection and correction. We observe that the combination of emerging applications and emerging many-core architectures makes <b>software</b> <b>recovery</b> a viable and interesting alternative to traditional, hardware-based fault recovery. Emerging applications tend to have few I/O and memory side-effects, which limits the amount of information that needs checkpointing, and they allow discarding individual sub-computations with typically minimal qualitative impact. <b>Software</b> <b>recovery</b> can harness these properties in ways that hardware recovery cannot. Additionally, emerging many-core architectures comprised of many simple, in-order cores pay heavily in terms of power and area for hardware checkpointing resources. <b>Software</b> <b>recovery</b> can be more efficient while it simultaneously simplifies hardware design complexity. In this paper, we describe Relax, an architectural framework for <b>software</b> <b>recovery</b> of hardware faults. We describe Relax’s language, compiler, ISA, and hardware support, develop analytical models to project performance, and evaluate an implementation of the framework on the compute kernels of seven emerging applications. Applying Relax to counter the effects of process variation, we find that Relax can enable a 20 % energy efficiency improvement for more than 80 % of an application’s execution with only minimal source code changes. ...|$|E
5000|$|... 2013 SearchStorage.com Product of the Year: Data Backup & Disaster <b>Recovery</b> <b>Software</b> and Services ...|$|R
5000|$|June 2011, Nuance {{acquired}} Equitrac, {{the world}} leader in print management and cost <b>recovery</b> <b>software.</b>|$|R
5000|$|Finances and Banking {{solutions}} (Enterprise Management Support Systems, Sales Support <b>Software,</b> Debt <b>recovery</b> support solutions, Advanced integration services {{based on}} data buses (ESB) and process engines (BPM), Video-teleconferencing systems, B2B portal solutions, Data and document processing based on cloud solutions).|$|R
40|$|In modern safety-critical {{embedded}} systems reliability and performance are two important criteria. In many systems based on off-The-shelf processors software implemented error recovery {{is the only}} option to improve {{the reliability of the}} system. However, software methods typically introduce large performance overheads. Another important factor in error recovery schemes is the recovery time, especially in systems with real-Time requirements. A key observation that helps improve <b>software</b> <b>recovery</b> methods is that only a defined number of locations in the program are susceptible to errors. In this paper we propose a fast <b>software</b> <b>recovery</b> scheme that instruments the program only at locations vulnerable to control-flow errors. We use a systematic bit-flip analysis to identify the exact locations susceptible to control-flow errors in a given program. This helps us to instrument the code with minimal overheads, while maintaining high-level of correct-Ability and low recovery times. Our experiments show that using the result of our bit-flip analysis and limiting the code instrumentation to only the susceptible locations improves the efficiency by a factor of 80 when compared to the latest control-flow error recovery methods...|$|E
40|$|In this chapter, six {{hierarchical}} analytic {{models are}} developed {{to evaluate the}} performance and availability of mobile networks, especially {{for the next generation}} of networks based on the Third Generation Partnership Project IP Multimedia Subsystem. Three hierarchical analytic models are developed for the independent <b>software</b> <b>recovery</b> scheme, whereas the other three are proposed for the dependent <b>software</b> <b>recovery</b> scheme. The top level model (described by a reliability block diagram) captures the signaling system consisting of a series of servers in the core network. Each server in the network is modeled in the lower level with alternatives based on (binary) fault tree, multi-state fault tree, stochastic reward net and parallel multi-state systems, the last one solved by the universal generating function methodology. The steady-state system availability is computed to evaluate whether the required performance level is satisfied or not. The accuracy of these models is compared to cross-validate each other. Moreover, the models are compared with respect to the execution time and different input parameters. The influences of the performance demand and redundancy configuration on the system steady-state availability are also evaluated to provide the optimal redundancy configurations for signaling servers, while maintaining high system availability and minimizing the cos...|$|E
40|$|A {{fault-tolerant}} multiprocessor with a rollback {{recovery mechanism}} is discussed. The rollback mechanism {{is based on}} the hardware recovery block which is a hardware equivalent to the <b>software</b> <b>recovery</b> block. The hardware recovery block is constructed by consecutive state-save operations and several state-save units in every processor and memory module. When a fault is detected, the multiprocessor reconfigures itself to replace the faulty component and then the process originally assigned to the faulty component retreats to one of the previously saved states in order to resume fault-free execution. A mathematical model is proposed to calculate both the coverage of multi-step rollback recovery and the risk of restart. A performance evaluation in terms of task execution time is also presented...|$|E
50|$|In {{addition}} to the sysadmin tools, security and network related <b>software,</b> data <b>recovery</b> and forensic tools, editors, shells, and many text tools included with grml, the distribution focuses on accessibility by providing kernel support for speakup and software like brltty, emacspeak, and flite.|$|R
50|$|Backup and Disaster <b>Recovery</b> <b>software</b> is {{provided}} by its Bacula4 platform, based on the Open Source Bacula system.|$|R
40|$|<b>Software</b> Architecture <b>Recovery</b> {{includes}} {{the extraction of}} design patterns. Patterns may be found using many techniques such as fielder vectors, using clustering methods, query languages etc. In this chapter, for evaluating design patterns clustering methods and the general notion of fielder vector are used. </p...|$|R
40|$|Recovery in a {{fault-tolerant}} {{computer means}} {{the continuation of}} system operation with data integrity after an error occurs. This paper delineates two parallel concepts embodied in the hardware and software functions required for recovery; detection, diagnosis, and reconfiguration for hardware, data integrity, checkpointing, and restart for the software. The hardware relies on the recovery variable set, checking circuits, and diagnostics, and the software relies on the recovery information set, audit, and reconstruct routines, to characterize the system state and assist in recovery when required. Of particular utility is a handware unit, the recovery control unit, which serves as an interface between error detection and <b>software</b> <b>recovery</b> programs in the supervisor and provides dynamic interactive recovery...|$|E
40|$|Introduction. The {{analysis}} of the researched problem and features of the designed fault-tolerant hardware/software systems were carried out. The approach description to developing reliability models of the software/hardware system. This chapter outlines a reliability macromodel of a fault-tolerant multicore system with a <b>software</b> <b>recovery.</b> Model of the fault-tolerant multicore system. The model features include: two multicore systems (main and reserve), some processors for sliding redundancies, one control and diagnostics processor which controls the hardware and software features. Also this model includes the automatic software restart after hardware failure. The proposed model appication example. Weighed calculation of MTTF (mean time to failure) considering given probability of infallible performance of the suggested and existing models was performed. Conclusion. The proposed model is designed to estimate reliability of the hardware/software systems. ? ?????? ?????????? ???????????? ?????? ???????????????? ????????????????? ???????, ? ?????? ??????? ?????? ??? ????????????????? ??????? (???????? ? ?????????), ?????????? ?????? ??????????? ???????, ????????? ???????? ? ??????????? ??????? ? ?????????? ????? ? ??????????? ???????????. ? ?????? ????? ?????? ?????????????? ???????????? ???????????? ???????????, ????? ?????? ????????????????? ????????? ?????? ?????????? ??????? ???????. ???????????? ?????? ????????????? ??? ??????? ????? ????????????? ?????????????? ??????????-?????????? ??????...|$|E
40|$|Outer planet {{spacecraft}} have unique {{requirements that}} differentiate them from inner planet and Earth orbiter spacecraft. To meet these requirements, the Voyager and Galileo Power Management And Distribution (PMAD) architectures employed shunt regulation and {{carried on the}} Mariner tradition of AC power distribution {{to many of the}} user loads. Also, autonomous fault recovery was achieved by automatic responses in hardware and <b>software</b> <b>recovery</b> routines. Finally, power distribution switching was expanded to allow for removal of the most trivial load element as the nuclear source depleted itself. The design cycle has begun for a third generation spacecraft set named Comet Rendezvous Asteroid Flyby (CRAF) and Cassini (a saturn orbiter). In their power systems, AC power distribution, relay/fuse load switching, and fault protection will give way to the advantages of DC power and solid state load switches...|$|E
50|$|Clearing is {{the removal}} of {{sensitive}} data from storage devices {{in such a way}} that there is assurance that the data may not be reconstructed using normal system functions or <b>software</b> file/data <b>recovery</b> utilities. The data may still be recoverable, but not without special laboratory techniques.|$|R
5000|$|InterGuard - Employee monitoring, web content filtering, {{keystroke}} logging, {{data loss}} prevention and laptop theft <b>recovery</b> <b>software</b> {{as a service}} suite.|$|R
40|$|Software Engineering {{research}} and industry {{recognize the need}} for practical tools to support reverse engineering activities. Most of the well-known CASE-tools nowadays support reverse engineering in some way or other. Reverse engineering is first step towards <b>software</b> Architecture <b>recovery.</b> The most commonly used standard today is Unified Modeling Language to depict the architecture and design of an application. An UML class diagram describes the architecture of object oriented programs. Class diagram captures the essence of its design. Most of the existing systems do not have reliable software architecture and some legacy systems are designed without software architecture design phase. By using reverse engineering tools we can generate class diagram as part of <b>software</b> architecture <b>recovery.</b> In this paper we assess capabilities of software reverse engineering tools to generate class diagram from java source code...|$|R
