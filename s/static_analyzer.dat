208|236|Public
25|$|Even if the {{expression}} > always evaluates to true at run-time, most type checkers will reject {{the program as}} ill-typed, because it is difficult (if not impossible) for a <b>static</b> <b>analyzer</b> to determine that the else branch will not be taken. Conversely, a static type checker will quickly detect type errors in rarely used code paths. Without static type checking, even code coverage tests with 100% coverage {{may be unable to}} find such type errors. The tests may fail to detect such type errors, because the combination of all places where values are created and all places where a certain value is used must be taken into account.|$|E
5000|$|Sireum/Kiasan, a {{symbolic}} execution based <b>static</b> <b>analyzer</b> which supports JML as a contract language.|$|E
5000|$|Web <b>Static</b> <b>Analyzer</b> Tool (WebSAT) - checks {{web page}} HTML against typical {{usability}} guidelines ...|$|E
30|$|Mutation {{operators}} not {{detected by}} <b>static</b> <b>analyzers</b> are also {{source of information}} to improve the capability of <b>static</b> <b>analyzers</b> in detecting new kinds of faults. Such set of mutation operators were identified and can be further investigated.|$|R
40|$|Static {{analysis}} of Android applications can be hindered {{by the presence}} of the popular dynamic code update techniques: dynamic class loading and reflection. Recent Android malware samples do actually use these mechanisms to conceal their malicious behavior from <b>static</b> <b>analyzers.</b> These techniques defuse even the most recent <b>static</b> <b>analyzers</b> that usually operate under the "closed world" assumption (the targets of reflective calls can be resolved at analysis time; only classes reachable from the class path at analysis time are used at runtime). Our proposed solution allows existing <b>static</b> <b>analyzers</b> to remove this assumption. This is achieved by combining static and dynamic {{analysis of}} applications in order to reveal the hidden/updated behavior and extend static analysis results with this information. This paper presents design, implementation and preliminary evaluation results of our solution called StaDynA...|$|R
5000|$|Language processors, {{including}} compilers, <b>static</b> <b>analyzers,</b> and the like, often expand sugared constructs {{into more}} fundamental constructs before processing, a process sometimes called [...] "desugaring".|$|R
50|$|The Clang project {{includes}} the Clang front {{end and the}} Clang <b>static</b> <b>analyzer</b> and several code analysis tools.|$|E
5000|$|Flow, a <b>static</b> <b>analyzer</b> for JavaScript {{created at}} Facebook that infers and verifies static types for JavaScript programs.|$|E
5000|$|Infer, a <b>static</b> <b>analyzer</b> for Java, C, and Objective-C {{created at}} Facebook, {{which is used}} to detect bugs in iOS and Android apps.|$|E
30|$|Once each mutant is {{generated}} by a specific mutation operator we can identify classes of mutations which <b>static</b> <b>analyzers</b> are or are not adequate to detect.|$|R
40|$|Extensive {{research}} has shown that software metrics can be used to identify fault- and failure-prone components. These metrics can also give early indications of overall software quality. We seek to parallel the identification and prediction of fault- and failure-prone components in the reliability context with vulnerability- and attack-prone components in the security context. Our research will correlate the quantity and severity of alerts generated by source code <b>static</b> <b>analyzers</b> to vulnerabilities discovered by manual analyses and testing. A strong correlation may indicate that automated <b>static</b> <b>analyzers</b> (ASA), a potentially early technique for vulnerability identification in the development phase, can identif...|$|R
40|$|We {{demonstrate}} {{the benefits of}} DroidRA, a tool for taming reflection in Android apps. DroidRA first statically extracts reflection-related object values from a given Android app. Then, it leverages the extracted values to boost the app {{in a way that}} reflective calls are no longer a challenge for existing <b>static</b> <b>analyzers.</b> This is achieved through a bytecode instrumentation approach, where reflective calls are supplemented with explicit traditional Java method calls which can be followed by state-of-the-art analyzers which do not handle reflection. Instrumented apps can thus be completely analyzed by existing <b>static</b> <b>analyzers,</b> which are no longer required to be modified to support reflection-aware analysis. The video demo of DroidRA can be found at [URL]...|$|R
50|$|Some {{parts of}} Grok were {{publicly}} released even before Google Kythe was announced. In 2010, Google released a Python <b>static</b> <b>analyzer</b> {{which has been}} developed as part of Grok.|$|E
50|$|Astrée is a <b>static</b> <b>analyzer</b> {{based on}} {{abstract}} interpretation. It analyzes programs {{written in the}} C programming language and outputs an exhaustive list of possible runtime errors and assertion violations.|$|E
50|$|Frama-C {{stands for}} Framework for Modular Analysis of C programs. Frama-C {{is a set}} of {{interoperable}} program analyzers for C programs. Frama-C has been developed by Commissariat à l'Énergie Atomique et aux Énergies Alternatives (CEA-List) and Inria. Frama-C, as a <b>static</b> <b>analyzer,</b> inspects programs without executing them.|$|E
40|$|Set of Software Quality <b>Static</b> <b>Analyzers</b> (SSQSA) {{is a set}} of {{software}} tools for static analysis that is incorporated in the framework developed to target the common aim – consistent software quality analysis. The main characteristic of all integrated tools is the independency of the input computer language. Language independency is achieved by enriched Concrete Syntax Tree (eCST) that is used as an intermediate representation of the source code. This characteristic gives the tools more generality comparing to the other similar <b>static</b> <b>analyzers.</b> The aim {{of this paper is to}} describe an early idea for introducing support for static timing analysis and Worst Case Execution Time (WCET) calculation at code level in SSQSA framework...|$|R
50|$|Travis CI {{supports}} {{integration with}} external {{tools such as}} coverage <b>analyzers</b> or <b>static</b> <b>analyzers.</b> In the case of Coverity Scan, for instance, Travis CI can run the build stage under Coverity's cov-build tool, and submit the result for analysis if the build succeeds.|$|R
40|$|<b>Static</b> <b>analyzers</b> for {{critical}} embedded softwares often poorly abstract the phys-ical environment in which, in practice, the embedded systems are run. To take {{an extreme example}} (more reasonable examples abound in articles dedicated to hybrid systems [1, 12]), the static analysis of avionic codes should abstract th...|$|R
5000|$|...NET Reflector is a class browser, {{decompiler}} and <b>static</b> <b>analyzer</b> {{for software}} created with [...]NET Framework, originally written by Lutz Roeder. MSDN Magazine named {{it as one}} of the Ten Must-Have utilities for developers, and Scott Hanselman listed it as part of his [...] "Big Ten Life and Work-Changing Utilities".|$|E
5000|$|Up to Xcode 4.1, the Xcode suite {{included}} {{a modified version}} of the GNU Compiler Collection. In Xcode 3.1 up to Xcode 4.6.3, it included the LLVM-GCC compiler, with front ends from the GNU Compiler Collection and a code generator based on LLVM. In Xcode 3.2 and later, it included the Clang C/C++/Objective-C compiler, with newly-written front ends and a code generator based on LLVM, and the Clang <b>static</b> <b>analyzer.</b> [...] Starting with Xcode 4.2, the Clang compiler became the default compiler, Starting with Xcode 5.0, Clang was the only compiler provided.|$|E
40|$|The C++ SoftBench class editor adds {{automatic}} code generation {{capabilities to}} the class graph of the SoftBench <b>static</b> <b>analyzer.</b> Novice C++ programmers can concentrate on their software designs and have the computer handle C++’s esoteric syntax. Experienced C++ programmers benefit from smart batch editing functionality and by having the computer quickly generate the program skeleton. by Julie B. Wilson The C++ SoftBench class editor allows the programmer to edit the class constructs in a C++ program using the SoftBench static analyzer’s graphical interface. Using the class editor, the programmer can create and modify class hierarchies and edit class components. Since the class editor {{is part of the}} <b>static</b> <b>analyzer,</b> let’s look first at the functionality provided by the <b>static</b> <b>analyzer.</b> The <b>static</b> <b>analyzer</b> helps the programmer better understand the code. Through static queries, the programmer can understand a program’s structure, assess the impact of changes, and change the architecture of the code when necessary. The <b>static</b> <b>analyzer</b> presents a wide variety of information about the code, including information about variables, classes, functions, an...|$|E
30|$|Inspired by {{the work}} of Araújo Filho et al. (2010) and Couto et al. (2013), and trying to {{overcome}} the problem they faced of evaluating the direct correspondence between warnings and faults due to the small number of real faults, we revisited their work evaluating the correspondence between static warnings and mutations. We decided to use mutation testing due to the following reasons: 1) it is considered a good fault model for experimentation and has been successfully used for test set evaluations (Andrews et al. 2005); 2) mutants are generated by mutation operators which can be seen as fault categories so we can try to correlate warnings and specific types of faults; 3) it allows to increase fault concentration per Kilo Lines of Code (KLOC) by summing up the number of mutants derived from each source code line; and 4) it eases experimentation with a large number of software products. These reasons help overcoming limitations of previous works on these subjects. Moreover, from this study, we intend to define a strategy for static warnings prioritization based on their correspondence with mutations. The results can be used to evolve either <b>static</b> <b>analyzers</b> or mutation testing, or both. The former in the sense {{it will be possible to}} compare different <b>static</b> <b>analyzers</b> against the same fault model to decide which kind of mutations they are really adequate to detect. This information can be used to prioritize the warnings resolution starting from the ones more correlated with some mutation operator and also to guide the evolution of <b>static</b> <b>analyzers</b> by creating additional static verification rules to detect uncovered mutations. The later by avoiding the generation of mutants for that mutation operators which <b>static</b> <b>analyzers</b> are adequate to detect their faults statically.|$|R
50|$|AbsInt is a 1998 {{spin-off}} {{from the}} Department for Programming Languages and Compilers at the Saarland University, where its founders {{had developed a}} generic and generative framework for binary-level <b>static</b> program <b>analyzers</b> and optimizers. An important component of this framework is the Program Analyzer Generator PAG, which allows to automatically generate <b>static</b> <b>analyzers</b> from a mathematical specification of the abstract domains and transfer functions. The first version of PAG was released in 1995. With PAG/WWW, a free academic version of PAG is available which has been used worldwide in numerous teaching courses.|$|R
30|$|To {{the best}} of our {{knowledge}} we did not identify any research trying to combine mutation and <b>static</b> <b>analyzers</b> as proposed in this paper. Our work is complementary to the others described above in the sense it uses mutations to evaluate the capability of <b>static</b> <b>analyzers</b> in detecting such mutations. The results obtained so far indicate we can use the collected information to prioritize warning categories in an incremental strategy, allowing the reviewer to apply specific warning categories more adequate to detect mutations first by increasing the chance to analyze a true positive warning. On the other hand, it was also possible to identify warning categories which are not adequate to detect any kind of mutation suggesting these warning categories should be used only if there are time and resources available.|$|R
3000|$|... [...]) {{represent}} {{types of}} faults rarely detected by FindBugs, and may suggest new bug patterns {{that can be}} added to the <b>static</b> <b>analyzer</b> tool to improve its capability.|$|E
40|$|We {{describe}} our ongoing {{effort of}} moving a desktop <b>static</b> <b>analyzer,</b> Clousot, into a cloud-based one, Cloudot. A cloud-based <b>static</b> <b>analyzer</b> runs as a service. Clients issue analysis requests through the local network {{or over the}} internet. The analysis {{takes advantage of the}} large computation resources offered by the cloud: the underlying infrastructure ensures scaling and virtually unlimited storage. Cloud-based analyzers may relax performance-precision trade-offs usually associated with desktop-based analyzers. More cores enable more precise and responsive analyses. More storage enables full caching of the analysis results, shareable among different clients, and queryable off-line. To realize these advantages, cloud-based analyzers need to be architected differently than desktop ones...|$|E
40|$|Abstract. Adoption of the Model-Driven Architecture {{approach}} is increasing each day. As any other software development project, a MDA-based project is constantly evolving given that software requirements change along their lifecycle. Thus, changes in MDA transformations are also frequent. These changes are hard and error-prone tasks when manually accomplished. We propose a <b>static</b> <b>analyzer</b> for inspecting the source code of ATL transformations. It provides an API comprising methods to extract and handle diverse elements from ATL transformations. Therefore, the proposed <b>static</b> <b>analyzer</b> {{can be useful}} during several development tasks of MDA-based projects, such as maintenance and debugging, since it enables developers to save effort and development time by automatically identifying dependences and relations from transformation elements...|$|E
40|$|International audienceThis paper {{shows how}} to {{construct}} <b>static</b> <b>analyzers</b> using tree automata and rewriting techniques. Starting from a term rewriting system representing the operational semantics {{of the target}} programming language and given a program to analyze, we automatically construct an over-approximation of the set of reachable terms, i. e. of the program states that can be reached. The approach enables fast prototyping of <b>static</b> <b>analyzers</b> because modifying the analysis simply amounts to changing the set of rewrite rules defining the approximation. A salient feature {{of this approach is}} that the approximation is correct by construction and hence does not require an explicit correctness proof. To illustrate the framework proposed here on a realistic programming language we instantiate it with the Java Virtual Machine semantics and perform class analysis on Java bytecode programs...|$|R
40|$|This thesis aims at {{development}} of a tool support for comparing the output of static analysis applied to different versions of program source codes. The thesis also comprises a discussion of three opensource <b>static</b> <b>analyzers</b> of the C source code. Based on this discussion, one of these analyzers, Cppcheck, was chosen {{for the implementation of}} the designed tool. The <b>static</b> <b>analyzer's</b> outputs, obtained for various versions of a specific program, are compared {{on the basis of the}} context of the line at which an error was found. The patch utility is used for comparing the appropriate contexts. Detected errors are classified into three groups: new, old, and fixed errors. A web interface allowing an easier-to-follow presentation of the results is also provided. The designed tool set has been successfully tested on three opensource projects, including the Linux kernel, Coreutils and CPython...|$|R
30|$|We used {{mutation}} operators as a {{fault model}} {{to evaluate the}} direct correspondence between mutations and static warnings. The main advantage of using mutation operators is that they generate {{a large number of}} programs containing faults of different types, which can be used to decide the ones most probable to be detected by <b>static</b> <b>analyzers.</b>|$|R
40|$|The Astrée <b>static</b> <b>analyzer</b> is a {{specialized}} tool that can prove {{the absence of}} runtime errors, including arithmetic overflows, in large critical programs. Keeping analysis times reasonable for industrial use {{is one of the}} design objectives. In this paper, we discuss the parallel implementation of the analysis...|$|E
40|$|Workflow {{applications}} for large complex organizations often need to cross several security domains, each with di#erent management and specific security requirements. The resultant cross-dependency between the workflow specification {{and the security}} policy of each domain {{can be hard to}} manage without specific tools. This work presents a <b>static</b> <b>analyzer</b> that automatically verifies the consistency between workflow specifications written in WPDL (Workflow Process Definition Language) and organization security policies, written in a security language specially designed to simultaneously express several security policies. The <b>static</b> <b>analyzer</b> takes advantage of the constraint nature of both workflow and security specifications, to use constraint programming techniques. The result is a compact and flexible verification tool that can be adapted to several workflow and security specifications. 1 Introduction The security infrastructure of complex organizations is often comprised of several se [...] ...|$|E
30|$|The first {{approaches}} for detecting Android malware {{have been inspired}} by concepts from static program analysis. A <b>static</b> <b>analyzer</b> inspects an app by just disassembly, de-compilation without actually running it, hence does not infect the device. Since it analyzes an app’s whole source or recovered code, the analyzer can achieve high code coverage.|$|E
40|$|Abstract. We show two {{strategies}} {{which may}} be easily applied to stan-dard abstract interpretation-based <b>static</b> <b>analyzers.</b> They consist in 1) restricting the scope of widening, and 2) intertwining the computation of ascending and descending chains. Using these optimizations it is pos-sible to improve the precision of the analysis, without any change to the abstract domains. ...|$|R
40|$|Program {{verification}} tools (such as model checkers and <b>static</b> <b>analyzers)</b> {{can find}} many errors in programs. These tools need formal specifications of correct program behavior, but writing a correct specification is difficult, just as writing a correct program is difficult. Thus, {{just as we}} need methods for debugging programs, we need methods for debugging specifications...|$|R
40|$|Abstract — This paper {{presents}} {{a high level}} overview of a technology called CodeHawk whose purpose is to support verification of software properties. Today’s commercially available static analysis tools identify potential runtime and vulnerability problems based on properties described in the semantics of the programming language. While CodeHawk will detect those classes of problems, it is distinguished by the user’s ability to generate high performance <b>static</b> <b>analyzers</b> for the verification of application-specific properties. Today’s <b>static</b> <b>analyzers</b> may also trade off assurance and flexibility for speed in handling very large code sets. Our goal with CodeHawk is to handle industrial sized code sets with the highest speed in the industry among those offering 100 % verification assurance. CodeHawk’s customizability opens up additional uses of the core technology beyond detecting runtime or vulnerability exposures. In this paper we describe one such use, namely static analysis in support of optimized dynamic analysis. I...|$|R
