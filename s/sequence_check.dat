7|298|Public
50|$|<b>Sequence</b> <b>check</b> (Gap): Specifies {{whether the}} product {{supports}} can find (identify) gabs (in sequences) {{for a specific}} field. For example, finding a broken sequence in an invoice number sequence.|$|E
40|$|Abstract. In {{order to}} solve the {{existing}} high voltage switch gear when the voltage difference method using core phase, due to the different switch gear supporting capacitive sensor indicators are inconsistent, resulting in phase <b>sequence</b> <b>check</b> misjudgment and other issues, this paper uses the phase {{difference between the two}} high voltage switch gear method of phase <b>sequence</b> <b>check,</b> this method has the versatility to determine the exact characteristics such as the actual test to fully meet the requirements of high voltage switch gear core phase...|$|E
40|$|When {{computing}} {{the solution}} of a generalized symmetric eigenvalue problem of the form Ku = λMu, the Sturm <b>sequence</b> <b>check</b> {{is the most popular}} method for reporting the number of missed eigenvalues within a range [σL, σR]. This method requires the factorization of the matrices K − σLM and K − σRM. When the size of the problem is reasonable and the matrices K and M are assembled, these factorizations are possible. When the eigensolver is equipped with an iterative solver, which is nowadays the preferred choice for large-scale problems, the factorization of K − σM is not desired or feasible and therefore the Sturm <b>sequence</b> <b>check</b> cannot be performed. To this effect, {{the purpose of this paper}} is to present a factorization-free algorithm for detecting and identifying the eigenvalues that were missed by an eigensolver equipped with an iterative linear equation solver within an interval of interest [σL, σR]. This algorithm constructs a scalar, rational, transfer function whose poles are exactly the eigenvalues of the symmetric pencil (K,M), approximates it by a Pade ́ expansion, and computes the poles of this approximation to detect and identify the missed eigenvalues. The proposed algorithm is illustrated with an academic numerical example. Its potential for real engineering applications is also demonstrated with a large-scale structural vibrations problem. Copyright c © 2000 John Wiley &...|$|E
40|$|The MRO <b>Sequence</b> <b>Checking</b> Tool program, mro_check, automates {{significant}} {{portions of}} the MRO (Mars Reconnaissance Orbiter) <b>sequence</b> <b>checking</b> procedure. Though MRO has similar checks to the ODY s (Mars Odyssey) Mega Check tool, the checks needed for MRO are unique to the MRO spacecraft. The MRO <b>sequence</b> <b>checking</b> tool automates {{the majority of the}} sequence validation procedure and check lists that are used to validate the sequences generated by MRO MPST (mission planning and sequencing team). The tool performs more than 50 different <b>checks</b> on the <b>sequence.</b> The automation varies from summarizing data about the sequence needed for visual verification of the sequence, to performing automated <b>checks</b> on the <b>sequence</b> and providing a report for each step. To allow for the addition of new checks as needed, this tool is built in a modular fashion...|$|R
40|$|A general {{model for}} {{constructing}} minimal length <b>checking</b> <b>sequences</b> is proposed. The model {{is based on}} the characteristics of <b>checking</b> <b>sequences</b> and sets of state identification and verification sequences. Some existing methods are shown to be special cases of the proposed model. The minimality of the resulting <b>checking</b> <b>sequences</b> is discussed and heuristic algorithms for the construction of minimal length <b>checking</b> <b>sequences</b> given...|$|R
40|$|Lower bounds on {{the lengths}} of <b>checking</b> <b>sequences</b> {{constructed}} for testing from Finite State Machine-based specifications are established. These bounds {{consider the case}} where a distinguishing sequence is used in forming state recognition and transition verification subsequences and identify the effects of overlapping among such subsequences. Empirical {{results show that the}} existing methods for construction of <b>checking</b> <b>sequences</b> provide <b>checking</b> <b>sequences</b> with lengths that are within acceptable distance to these lower bounds...|$|R
40|$|An {{iterative}} system equivalent reduction expansion process (SEREP) {{is proposed}} for extraction of high frequency response from a reduced-order model (ROM) under frequency band-limited excitation. Various model order reduction methods are discussed. To alleviate the present drawback of the SEREP, which requires computation of full system modal matrix, an iterative method based on Sturm <b>sequence</b> <b>check</b> is proposed. The method uses eigenvalue separation properties on the excitation frequency band {{to identify the}} optimal number of the eigenpairs required to capture the accurate response. The basic steps for numerical implementation are given. Numerical results are presented to validate the predicted response. Comparison is also made to explain {{the reasons for the}} instability of the ROM based on dynamic condensation to capture the high frequency dynamics. Case studies are carried out to demonstrate the effect of the chosen frequency band for response extraction. Also, it is shown that accurate results are obtained while using the proposed method when the chosen frequency band encompass the excitation frequency band...|$|E
40|$|Abstract ⎯ Gossip {{protocols}} {{provide a}} means by which failures can be detected in large, distributed systems in an asynchronous manner without the limits associated with reliable multicasting for group communications. However, in order to be effective with application recovery and reconfiguration, these protocols require mechanisms by which failures can be detected with system-wide consensus in a scalable fashion. This paper presents three new gossipstyle protocols supported by a novel algorithm to achieve consensus in scalable, heterogeneous clusters. The roundrobin protocol improves on basic randomized gossiping by distributing gossip messages in a deterministic order that optimizes bandwidth consumption. Redundant gossiping is completely eliminated in the binary round-robin protocol, and the round-robin with <b>sequence</b> <b>check</b> protocol is a useful extension that yields efficient detection times without the need for system-specific optimization. The distributed consensus algorithm works with these gossip protocols to achieve agreement among the operable nodes in the cluster {{on the state of the}} system featuring either a flat or a layered design. The various protocols are simulated and evaluated in terms of consensus time and scalability using a high-fidelity, fault-injection model for distributed systems comprised of clusters of workstations connected by highperformance networks. Index Terms ⎯ Cluster computing, consensus, failure detection, fault tolerance, gossip protocol, Myrinet. ...|$|E
30|$|A {{graph-based}} method, RCI {{tries to}} reconstruct user-browser interactions [7]. RCI first builds the referral graph, and then prunes the graph {{by removing the}} automatically generated requests during rendering a page. Then nodes of the graph, which represent visited pages, are compared with DOM elements to find a triggering element for each request [7, 38]. ClickMiner [7] reconstruct user session from HTTP traces recorded by a passive proxy. Their proposed approach focuses on actions that change the URL of the application. However, in RIAs many actions do not alter the URL but rather update the DOM of the page [39]. In addition, although there is some level of support for JavaScript, ClickMiner is lacking the specific capabilities that are required to handle RIAs (e.g., handling user-inputs, client-side randomness, restoring the previous state, <b>sequence</b> <b>check).</b> Our previous work, ForenRIA [10], proposes a forensics tool to perform automated and complete reconstruction of a user session in RIAs. However, ForenRIA is less effective and scalable than D-ForenRIA since it is implemented as a single-threaded system where a single client (i.e., browser) is responsible for executing all the possible actions on a given page. ForenRIA also {{did not have the}} ability to support complex user input actions, timers, and actions that do not generate any traffic.|$|E
50|$|MTP2 {{provides}} flow control, {{error detection}} and <b>sequence</b> <b>checking,</b> and retransmits unacknowledged messages. MTP2 uses packets called signal units to transmit SS7 messages. There are {{three types of}} signal units: Fill-in Signal Unit (FISU), Link Status Signal Unit (LSSU), Message Signal Unit (MSU).|$|R
40|$|This study {{discusses}} {{the generation of}} the minimum length <b>checking</b> <b>sequences</b> for FSM-based protocol conformance testing. The discussion focuses on finding the minimal length of resulting <b>checking</b> <b>sequences</b> for an FSM under different conditions. Without interleaving state identification and transition verification sequences, four methods (D-method, W-method, Wp-method and UIOv-method) of generating minimum length test sequences for FSMs with reliable reset feature are reviewed and provided to construct <b>checking</b> <b>sequences.</b> These four methods are then improved to generate minimum length <b>checking</b> <b>sequences</b> for FSMs without reliable reset feature and provided to construct <b>checking</b> <b>sequences.</b> Moreover, the effects of interleaving the state identification and transition verification sequences {{on the length of}} the <b>checking</b> <b>sequences</b> are studied. An algorithm for interleaving the state identification and transition verification sequences generated by the above four methods with reliable reset feature is proposed. It is observed that the reduction in the length of <b>checking</b> <b>sequences</b> due to interleaving is significant. Finally, the two general models for constructing minimal length <b>checking</b> <b>sequences</b> using distinguishing sequences with interleaved state identification and transition verification sequences are proposed. The proof for the first model to find a minimum length <b>checking</b> <b>sequence</b> in polynomial time is provided. The sequences generated by using both models are proved to be <b>checking</b> <b>sequences.</b> Examples are provided as applications of all the proposed methods and models...|$|R
40|$|The {{problem of}} {{generating}} <b>checking</b> <b>sequences</b> for FSMs with distinguishing sequence has been attracting interest of researchers for several decades. In this paper, a solution is proposed for partial reduced FSMs with distinguishing sets, and either {{with or without}} reset feature. Sufficient conditions for a sequence to be a <b>checking</b> <b>sequence</b> for such FSMs are formulated. Based on these conditions, a method to generate <b>checking</b> <b>sequence</b> is elaborated. The results of an experimental comparison indicate that the proposed method produces shorter <b>checking</b> <b>sequences</b> than existing methods in most cases. The impact of using the reset feature {{on the length of}} <b>checking</b> <b>sequence</b> is also experimentally evaluated...|$|R
40|$|Life Insurance B is {{a company}} {{engaging}} in the services of people protection. Evaluation of accounting information system which relates with the customer claims payments made by the company has the objective to identify the weaknesses in the system of disbursement procedures and to provide the new recommendations. In doing the research, the author conducted literature research and field research. Fieldwork was conducted {{in order to obtain}} accurate and real data. Based on the research, writers found some weaknesses in the payment process customer claims, including the claim that the document is not to be numbered prints, the differences in the status of the policy and double claim status. There are weaknesses in the control applications such as <b>sequence</b> <b>check,</b> check and reasonable limits, total control check, which have not been applied to the company as well. In the company 2 ̆ 7 s report, there has been no report on the problems that occur in a given period. To overcome these weaknesses, writers suggest a new document in the form of proposals that have been accompanied by a serial number printed. Should the company implement a weekly batch system with a view to have the latest report from branches every week, not every month. And finally the employees should make report any problems that occur in the company, so that problems that occur can be easily monitored by the authorities...|$|E
40|$|Given {{a finite}} state machine M, a <b>checking</b> <b>{{sequence}}</b> is an input sequence that is guaranteed {{to lead to a}} failure if the implementation under test is faulty and has no more states than M. There has been much interest in the automated generation of a short <b>checking</b> <b>sequence</b> from a {{finite state machine}}. However, such sequences can contain reset transitions whose use can adversely affect both the cost of applying the <b>checking</b> <b>sequence</b> and the effectiveness of the <b>checking</b> <b>sequence.</b> Thus, we sometimes want a <b>checking</b> <b>sequence</b> with a minimum number of reset transitions rather than a shortest <b>checking</b> <b>sequence.</b> This paper describes a new algorithm for generating a <b>checking</b> <b>sequence,</b> based on a distinguishing sequence, that minimises the number of reset transitions used. This work {{was supported in part by}} Leverhulme Trust grant number F/ 00275 /D, Testing State Based Systems, Natural Sciences and Engineering Research Council (NSERC) of Canada grant number RGPIN 976, and Engineering and Physical Sciences Research Council grant number GR/R 43150, Formal Methods and Testing (FORTEST) ...|$|R
40|$|A {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} based testing is introduced. Unlike previous methods, {{which are based on}} state recognition using a single state identification sequence, our approach makes use of multiple state identification sequences. Using multiple state identification sequences provides an opportunity to construct shorter <b>checking</b> <b>sequences,</b> choosing greedily the state identification sequence that best suits our goal at different points during the construction of the <b>checking</b> <b>sequence.</b> We present the results of an experimental study showing that our approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods...|$|R
30|$|Packet is finished. All bytes {{have been}} received, and the MAC {{processor}} {{signals to the}} main CPU that a complete packet {{is available in the}} shared memory. When frame <b>check</b> <b>sequence</b> (FCS) <b>checking</b> is enabled, the signaling is only done if the FCS is correct.|$|R
40|$|Methods {{for testing}} from finite state machine-based {{specifications}} often require {{the existence of}} a preset distinguishing <b>sequence</b> for constructing <b>checking</b> <b>sequences.</b> It has been shown that an adaptive distinguishing sequence is sufficient for these methods. This result is significant because adaptive distinguishing sequences are strictly more common and up to exponentially shorter than preset ones. However, there has been no study on the actual effect of using adaptive distinguishing sequences on the length of <b>checking</b> <b>sequences.</b> This paper describes experiments that show that <b>checking</b> <b>sequences</b> constructed using adaptive distinguishing sequences are almost consistently shorter than those based on preset distinguishing sequences. This is investigated for three different <b>checking</b> <b>sequence</b> generation methods and the results obtained from an extensive experimental study are given...|$|R
40|$|Part 1 : Model Based TestingInternational audienceA {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} based testing is introduced. Unlike previous methods, {{which are based on}} state recognition using a single state identification sequence, our approach makes use of multiple state identification sequences. Using multiple state identification sequences provides an opportunity to construct shorter <b>checking</b> <b>sequences,</b> choosing greedily the state identification sequence that best suits our goal at different points during the construction of the <b>checking</b> <b>sequence.</b> We present the results of an experimental study showing that our approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods...|$|R
40|$|A {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} (FSM) based testing is introduced. It {{is based on a}} recently suggested method which uses quite a different approach than almost all the methods developed since the introduction of the <b>checking</b> <b>sequence</b> generation problem around half a century ago. Unlike its predecessor which aggressively tries to recognize the states by applying identification sequences, our approach relies on yet to be generated parts of the sequence for this. The method may terminate without producing a <b>checking</b> <b>sequence.</b> We also suggest a method to <b>check</b> if a <b>sequence</b> is a <b>checking</b> <b>sequence</b> for this purpose. If it turns out not be a <b>checking</b> a <b>sequence,</b> a post processing phase extends the sequence further. We present the results of an experimental study showing that our two phase approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods. This experimental study is performed on FSMs that are randomly generated by using a tool implemented within this work to support this and other FSM based testing studies...|$|R
40|$|Abstract. There are {{two main}} {{shortcomings}} in the existing models for generating <b>checking</b> <b>sequences</b> based on distinguishing sequences. First, these models require a priori selection of state recognition sequences (called α-sequences) {{which may not be}} the best selection for yielding substantial reduction in the length of <b>checking</b> <b>sequences.</b> Second, they do not take advantage of overlapping to further reduce the length of <b>checking</b> <b>sequences.</b> This paper proposes an optimization model that tackles these shortcomings to reduce the lengths of <b>checking</b> <b>sequences</b> beyond what is achieved by the existing models by replacing the state recognition sequences with a set of basic sequences called α-elements and by making use of overlapping. ...|$|R
50|$|Software, environmental, and {{hardware}} controls are required although they cannot prevent problems created from poor programming practice. Using limit and <b>sequence</b> <b>checks</b> to validate users’ input {{will improve the}} quality of data. Even though programmers may follow best practices, an application can still fail due to unpredictable conditions and therefore should handle unexpected failures successfully by first logging all the information it can capture in preparation for auditing. As security increases, so does the relative cost and administrative overhead.|$|R
40|$|Methods for {{software}} testing based on Finite State Machines (FSMs) have been researched {{since the early}} 60 ’s. Many of these methods are about generating a <b>checking</b> <b>sequence</b> from a given FSM which is an input sequence that determines whether an implementation of the FSM is faulty or correct. In this paper, we consider one of these methods, which constructs a <b>checking</b> <b>sequence</b> by reducing the problem of generating a <b>checking</b> <b>sequence</b> to finding a Chinese rural postman tour on a graph induced by the FSM; we re-formulate the constraints used in this method {{as a set of}} Boolean formulas; and use a SAT solver to generate a <b>checking</b> <b>sequence</b> of minimal length...|$|R
40|$|Based on a {{distinguishing}} sequence for a Finite State Machine (FSM), {{an efficient}} <b>checking</b> <b>sequence</b> may be produced {{from the elements}} of a set of –sequences and a set ET of T–sequences, that both recognize the states, and elements of EC which represents the transitions in the FSM. An optimization algorithm may then be used to produce a reduced length <b>checking</b> <b>sequence</b> by connecting the elements of, ET, and EC using transitions taken from an acyclic set E ′′. It is known that only a subset E′C of EC is sufficient to form a <b>checking</b> <b>sequence.</b> This paper improves this result by reducing the number of elements in E′C that must be included in the generated <b>checking</b> <b>sequence...</b>|$|R
40|$|Context: Given a Finite State Machine (FSM), a <b>checking</b> <b>{{sequence}}</b> is a {{test sequence}} that determines whether the system under test is correct as long as certain standard assumptions hold. Many <b>checking</b> <b>sequence</b> generation methods use an adaptive distinguishing sequence (ADS), which is an experiment that distinguishes {{the states of the}} specification machine. Furthermore, {{it has been shown that}} the use of shorter ADSs yields shorter <b>checking</b> <b>sequences.</b> It is also known, on the other hand, that constructing a minimum cost ADS is an NP-hard problem and it is NP-hard to approximate. This motivates studying and investigating effective ADS construction methods. Objective: The main objective of this paper is to suggest new methods that can compute compact ADSs to be used in the construction of <b>checking</b> <b>sequences.</b> Method: We briefly present the existing ADS construction algorithms. We then propose generalizations of these approaches with a set of heuristics. We also conduct experiments to compare the size of the resultant ADSs and the length of the <b>checking</b> <b>sequences</b> constructed using these ADSs. Results: The results indicate that when the ADSs are constructed with the proposed methods, the length of the <b>checking</b> <b>sequences</b> may reduce up to 54...|$|R
30|$|By using real video <b>sequences,</b> we <b>checked</b> the {{separation}} and integration processes of our method and confirmed {{the accuracy of}} our method by comparing existing methods.|$|R
40|$|A {{spacecraft}} can {{be modeled}} {{as a collection}} of states, with certain actions (commands) leading the spacecraft from one state to another. Here, we present the outline of a technique to generate models from the existing <b>sequence</b> <b>checking</b> code in a semi-automated way. To further speedup the simulation on the hypercube, a technique for Parallel Discrete Event Simulation (PDES) based upon the prediction techniques is also presented. The prediction technique is introduced with simulation results obtained on the Ncube and the performance of the proposed technique is compared to the Time Warp algorithm. ...|$|R
40|$|Interplanetary {{spacecraft}} {{are controlled}} with sets of onboard commands called 'sequences' {{that control the}} spacecraft for hours, days, or weeks depending upon the craft and its current activity phase. The sequence-checking problem, with some examples from practical experience, and the technical challenges of implementing <b>sequence</b> <b>checking</b> on a parallel computer are presented. Hypercube applications including computational-physics problems, 'optimistic' and 'conservative' categories are discussed. Finally, future development and prototype ways of balancing the checking network across the hypercube nodes, handling time dependencies among the checks, and minimizing communication are described...|$|R
30|$|Select a {{shipment}} <b>sequence</b> and <b>check</b> its feasibility {{with the help}} of condition (10). If the shipment sequence violates this condition, repeat Step 2.1 for evaluating the next sequence.|$|R
40|$|Part 6 : Short ContributionsInternational audienceIn this paper, we {{investigate}} how a <b>checking</b> <b>sequence</b> {{can be generated}} from a Finite State Machine, {{with respect to a}} user-defined set of faults, modeled as a nondeterministic FSM, called Mutation Machine (MM). We propose an algorithm for generating a <b>checking</b> <b>sequence</b> in this scenario and demonstrate its correctness...|$|R
40|$|With {{advances}} {{in computer technology}} and software engineering, systems are constantly becoming larger and more complex. Straightforward testing methods are insufficient {{to cope with the}} complexity and maintaining quality of service demands the use of more structured testing methods. <b>Checking</b> <b>sequences</b> are testing mechanisms based on finite state behavior models that can offer guarantees about a system under test, under certain assumptions. However, their complexities are high, and to make their imple-mentation feasible methods of their construction need to be refined. We have studied several methods of <b>checking</b> <b>sequence</b> construction in the presence of distinguishing sequences, developed fully formed algorithms from loose specifications, then implemented and compared their performances. We have also proposed several improvements that will allow generation of shorter <b>checking</b> <b>sequences.</b> We are confident that these developments will be instrumental in making the use of <b>checking</b> <b>sequences</b> feasible in a larger scope. i...|$|R
40|$|Due to the {{character}} of the original source materials and the nature of batch digitization, quality control issues may be present in this document. Please report any quality issues you encounter to digital@library. tamu. edu, referencing the URI of the item. Includes bibliographical references. Issued also on microfiche from Lange Micrographics. The motivation for this research has been its applicability in <b>sequence</b> <b>checking</b> in a spacecraft's control commands. Spacecrafts are controlled by sequences of time-tagged control commands which are essentially onboard computer programs. 'The sequence of control commands needs to be verified for correct execution before the commands are executed on the spacecraft to avoid the catastrophic effects of incorrect execution. The <b>sequence</b> <b>checking</b> employed (presently) is inherently sequential. The main objective of this work is to replace this existing sequential algorithm with a parallel implementation to gain performance. Parallel (distributed) discrete event simulation (PDES) refers to the execution of a single discrete event simulation program on a parallel computer. PDES mechanisms broadly fall into two categories : conservative mechanisms, like the Chandy-Misra approach and optimistic mechanisms, like the Time Warp mechanism. Conservative approaches strictly avoid the possibility of a causality error occurring whereas optimistic approaches use a detection and recovery approach wherein causality errors are detected and a rollback mechanism is invoked to recover. We present a technique for PDES that is based upon prediction techniques which performs very well for deterministic systems...|$|R
40|$|A <b>checking</b> <b>sequence,</b> {{generated}} from a finite state machine, {{is a test}} sequence that is guaranteed {{to lead to a}} failure if the system under test is faulty and has no more states than the specification. The problem of generating a <b>checking</b> <b>sequence</b> for a finite state machine M is simplified if M has a distinguishing sequence: an input sequence ¯D with the property that the output sequence produced by M in response to ¯ D is different for the different states of M. Previous work has shown that, where a distinguishing sequence is known, an efficient <b>checking</b> <b>sequence</b> can be produced from the elements of a set A of sequences that verify the distinguishing sequence used and the elements of a set Υ of subsequences that test the individual transitions by following each transition t by the distinguishing sequence that verifies the final state of t. In this previous work A is a predefined set and Υ is defined in terms of A. The <b>checking</b> <b>sequence</b> is produced by connecting the elements of Υ and A, to form a single sequence, using a predefined acyclic set Ec of transitions. An optimization algorithm is used in order to produce the shortest such <b>checking</b> <b>sequence</b> that can be generated {{on the basis of the}} given A and Ec. However, this previous work did not state how the sets A and Ec should be chosen. This paper investigates the problem of finding appropriate A and Ec to be used in <b>checking</b> <b>sequence</b> generation. We show how a set A may be chosen so that it minimizes the sum of the lengths of the sequences to be combined. Further, we show that the optimization step, in the <b>checking</b> <b>sequence</b> generation algorithm, may be adapted so that it generates the optimal Ec. Experiments are used to evaluate the proposed method...|$|R
5000|$|... {{too many}} frames with invalid frame <b>check</b> <b>sequence</b> (FCS) field have been {{received}} ...|$|R
5000|$|Protection against errors, {{generally}} {{by means}} of generating and <b>checking</b> frame <b>check</b> <b>sequences</b> ...|$|R
30|$|The basic solution: Any system {{aiming at}} reconstructing user-interactions for RIAs needs {{to at least}} {{be able to handle}} user-inputs recovery, {{client-side}} randomness, <b>sequence</b> <b>checks</b> and be able to restore a previous state; otherwise the reconstruction may not be possible. In our experiments, we call such a system the “basic solution”. It performs an exhaustive search for the elements of the DOM to find the next action and it does not use the proposed techniques in Section 3.3. To {{the best of our knowledge}} at the time of writing, no other published solution provides such a basic solution; thus there is no other solution that can reconstruct RIA sessions, even inefficiently.|$|R
30|$|All <b>sequences</b> were <b>checked</b> {{visually}} and {{aligned with}} Clustal W Multiple Alignment using Bioedit 7.1. 3 (Hall 1999). Genetic distances were calculated using the Kimura 2 -parameter model {{as suggested by}} MEGA 5.02 (Tamura et al. 2011).|$|R
