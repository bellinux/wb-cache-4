76|129|Public
2500|$|If an {{exception}} is thrown and not caught (operationally, {{an exception}} is thrown {{when there is}} no applicable handler specified), the uncaught exception is handled by the runtime; the routine that does this is called the [...] The most common default behavior is to terminate the program and print an error message to the console, usually including debug information such as a string representation of the exception and the <b>stack</b> <b>trace.</b> This is often avoided by having a top-level (application-level) handler (for example in an event loop) that catches exceptions before they reach the runtime.|$|E
2500|$|Visual Studio Debugger {{includes}} features targeting easier debugging of multi-threaded applications. In debugging mode, in the Threads window, which lists all the threads, {{hovering over}} a thread displays the <b>stack</b> <b>trace</b> of that thread in tooltips. The threads can directly be named and flagged for easier identification from that window itself. In addition, {{in the code}} window, along with indicating {{the location of the}} currently executing instruction in the current thread, the currently executing instructions in other threads are also pointed out. The Visual Studio debugger supports integrated debugging of the [...]NET 3.5 Framework Base Class Library (BCL) which can dynamically download the BCL source code and debug symbols and allow stepping into the BCL source during debugging. [...] a limited subset of the BCL source is available, with more library support planned for later.|$|E
2500|$|In {{contrast}} to Java, languages like C# do not enforce that exceptions {{have to be}} caught. According to Hanspeter Mössenböck, not distinguishing between to-be-called (checked) exceptions and not-to-be-called (unchecked) exceptions makes the written program more convenient, but less robust, as an uncaught exception results in an abort with a <b>stack</b> <b>trace.</b> Kiniry (2006) notes however that Java's JDK (version 1.4.1) throws {{a large number of}} unchecked exceptions: one for every 140 lines of code, whereas Eiffel uses them much more sparingly, with one thrown every 4,600 lines of code. Kiniry also writes that [...] "As any Java programmer knows, the volume of try catch code in a typical Java application is sometimes larger than the comparable code necessary for explicit formal parameter and return value checking in other languages that do not have checked exceptions. In fact, the general consensus among in-the-trenches Java programmers is that dealing with checked exceptions is nearly as unpleasant a task as writing documentation. Thus, many programmers report that they “resent” checked exceptions. This leads to an abundance of checked-but-ignored exceptions". Kiniry also notes that the developers of C# apparently were influenced by this kind of user experiences, with the following quote being attributed to them (via Eric Gunnerson): [...] According to Anders Hejlsberg there was fairly broad agreement in their design group to not have checked exceptions as a language feature in C#. Hejlsberg explained in an interview that ...|$|E
40|$|Abstract—A {{widely shared}} {{belief in the}} {{software}} engineering community is that <b>stack</b> <b>traces</b> are much sought after by developers to support them in debugging. But limited empirical evidence is available to confirm the value of <b>stack</b> <b>traces</b> to developers. In this paper, we seek to provide such evidence by conducting an empirical study on the usage of <b>stack</b> <b>traces</b> by developers from the ECLIPSE project. Our results provide strong evidence to this effect and also throws light {{on some of the}} patterns in bug fixing using <b>stack</b> <b>traces.</b> We expect the findings of our study to further emphasize the importance of adding <b>stack</b> <b>traces</b> to bug reports and that in the future, software vendors will provide more support in their products to help general users make such information available when filing bug reports. Keywords-debugging, <b>stack</b> <b>traces,</b> empirical study, bug tracking, collaboration I...|$|R
40|$|A {{widely shared}} {{belief in the}} {{software}} engineering community is that <b>stack</b> <b>traces</b> are much sought after by developers to support them in debugging. But limited empirical evidence is available to confirm the value of <b>stack</b> <b>traces</b> to developers. In this paper, we seek to provide such evidence by conducting an empirical study on the usage of <b>stack</b> <b>traces</b> by developers from the ECLIPSE project. Our results provide strong evidence to this effect and also throws light {{on some of the}} patterns in bug fixing using <b>stack</b> <b>traces.</b> We expect the findings of our study to further emphasize the importance of adding <b>stack</b> <b>traces</b> to bug reports and that in the future, software vendors will provide more support in their products to help general users make such information available when filing bug reports. © 2010 IEEE...|$|R
40|$|In {{software}} engineering, {{resources such}} as time, money and developers, are limited. Often when bugs {{are found in the}} software developed, bug triaging is used to prioritise bug reports and allocate resources to it. When the number of bugs is considerable, this will require a vast amount of time and effort. The goal of this research is to investigate the usefulness of <b>stack</b> <b>traces</b> in bug reports for the assessment of bug report properties, using existing metrics of bug reports and files, being severity, priority and time-to-fix. In order to investigate the usefulness of <b>stack</b> <b>traces,</b> a research framework and methodology are developed. Overall, we can conclude that <b>stack</b> <b>traces</b> can be used to link software artifacts. Also, <b>stack</b> <b>traces</b> can be a valuable input for prediction models, for example using metrics of related bugs and source files. Software EngineeringSoftware TechnologyElectrical Engineering, Mathematics and Computer Scienc...|$|R
50|$|A <b>stack</b> <b>trace</b> allows {{tracking}} {{the sequence of}} nested functions called - {{up to the point}} where the <b>stack</b> <b>trace</b> is generated. In a post-mortem scenario this extends up to the function where the failure occurred (but was not necessarily caused). Sibling calls do not appear in a <b>stack</b> <b>trace.</b>|$|E
5000|$|Memory {{checking}} includes memory leaks, dangling pointers, uninitialized variables, use of invalid memory references, mismatched memory, allocation and deallocation, stack memory checks, and <b>stack</b> <b>trace</b> with controllable <b>stack</b> <b>trace</b> depth ...|$|E
50|$|A rather subtle {{difference}} is the moment a <b>stack</b> <b>trace</b> is created when an exception is being thrown. In Java, the <b>stack</b> <b>trace</b> is created in the moment the exception is created.|$|E
5000|$|... jstack [...] - [...] utility that prints Java <b>stack</b> <b>traces</b> of Java threads (experimental) ...|$|R
40|$|Abstract—During {{software}} development, {{exceptions are}} by no means exceptional: Programmers repeatedly try and test their code to ensure that it works as expected. While doing so, runtime exceptions are raised, pointing out various issues, such as inappropriate usage of an API, convoluted code, as well as defects. Such failures result in <b>stack</b> <b>traces,</b> lists composed of the sequence of method invocations that led to the interruption of the program. <b>Stack</b> <b>traces</b> are useful to debug source code, and if shared also enhance the quality of bug reports. However, they are handled manually and individually, while we argue that they can be leveraged automatically and collectively to enable what we call crowdstacking, the automated collection of <b>stack</b> <b>traces</b> on the scale of a whole development community. We present our crowdstacking approach, supported by Shore-Line Reporter, a tool which seamlessly collects <b>stack</b> <b>traces</b> during program development and execution and stores them on a central repository. We illustrate how thousands of <b>stack</b> <b>traces</b> stemming from the IDEs of several developers can be leveraged to identify common hot spots in the code that are involved in failures, using this knowledge to retrieve relevant and related bug reports and to provide an effective, instant context of the problem to the developer. I...|$|R
5000|$|In {{properties}} {{of a process}} a user can view the process's threads and threads' <b>stack</b> <b>traces</b> ...|$|R
5000|$|In case of build failures, Bamboo {{provides}} {{an analysis of}} the failure, including a <b>stack</b> <b>trace</b> ...|$|E
5000|$|... is a {{base class}} and class-maker for derived {{exception}} classes. It provides a full structured <b>stack</b> <b>trace</b> in [...] and [...]|$|E
5000|$|... #Caption: The {{debugging}} interface of Eclipse with {{a program}} suspended at a breakpoint. Panels with <b>stack</b> <b>trace</b> (upper left) and watched variables (upper right) can be seen.|$|E
5000|$|View <b>stack</b> <b>traces</b> to {{see what}} is {{happening}} to the server at that moment in time ...|$|R
5000|$|Debugging {{facilities}} such as safe iterators, precondition and postcondition checking, and {{the ability}} to generate <b>stack</b> <b>traces</b> ...|$|R
30|$|Each CMP gather after NMO {{correction}} is summed {{together to}} yield a <b>stacked</b> <b>trace.</b> <b>Stacking</b> enhances the in-phase components and reduces the random noise. It yields zero offset section (in the absence of dipping layers in the subsurface) [5].|$|R
50|$|Programmers {{commonly}} use stack tracing during interactive and post-mortem debugging. End-users {{may see a}} <b>stack</b> <b>trace</b> displayed as part of {{an error}} message, which the user can then report to a programmer.|$|E
50|$|The source-level {{instrumentation}} {{allows it}} to not only identify that a leak occurred, but where it occurred. Some tools merely provide information about where the memory was allocated, Insure++ also gives a <b>stack</b> <b>trace</b> for when/where the actual leak occurred.|$|E
5000|$|Flash Player 11.5: {{released}} in November 2012, focused on performance improvement and stability. Some {{of the features}} in this release include the following: Shared ByteArray support for ActionScript workers. Debug <b>stack</b> <b>trace</b> in release builds of Flash Player. Various bug fixes ...|$|E
40|$|Modern {{programs}} {{depend on}} APIS {{to implement a}} significant part of their functionality. Apart from the way developers use APIS to build their software, the stability of these programs relies on the APIS design and implementation. In this work, we evaluate the reliability of APIS, by examining software telemetry data, in the form of <b>stack</b> <b>traces,</b> coming from Android application crashes. We got 4. 9 GB worth of crash data that thousands of applications send to a centralized crash report management service. We processed that data to extract approximately a million <b>stack</b> <b>traces,</b> stitching together parts of chained exceptions, and established heuristic rules to draw the border between applications and API calls. We examined 80 % of the <b>stack</b> <b>traces</b> to map the space of the most common application failure reasons. Our findings show that the top ones can be attributed to memory exhaustion, race conditions or deadlocks, and missing or corrupt resources. At the same time, a significant number of our <b>stack</b> <b>traces</b> (over 10 %) remains unclassified due to generic unchecked exceptions, which do not highlight the problems that lead to crashes. Finally, given the classes of crash causes we found, we argue that API design and implementation improvements, such as specific exceptions, non-blocking algorithms, and default resources, can eliminate common failures...|$|R
5000|$|Genshi {{templates}} {{are easier}} to debug, because it tracks template source file names and line numbers, and errors from Genshi's interpreter produce more comprehensible <b>stack</b> <b>traces</b> than from Kid's generated code.|$|R
3000|$|... {{observed}} temporal {{changes in}} the shallow crust after the Tohoku earthquake (Nakata and Snieder, 2011; Wu and Peng, 2011). Next, we measure the resonance frequency of the <b>stacked</b> <b>trace</b> in each period.|$|R
50|$|Graceful exits are {{not always}} desired. In many cases, an {{outright}} crash can give the software developer the opportunity to attach a debugger or collect important information, such as a core dump or <b>stack</b> <b>trace,</b> to diagnose {{the root cause of}} the error.|$|E
50|$|Error hiding: Catching {{an error}} message {{before it can}} be shown to the user and either showing nothing or showing a {{meaningless}} message. This anti-pattern is also named Diaper Pattern. Also can refer to erasing the <b>Stack</b> <b>trace</b> during exception handling, which can hamper debugging.|$|E
50|$|In {{the code}} above, the {{exception}} will contain the stack-trace {{of the first}} throw-line. When catching an exception, there are two options in case the exception should be rethrown: throw will just rethrow the original exception with the original stack, while throw e would have created a new <b>stack</b> <b>trace.</b>|$|E
40|$|IgProf is an {{application}} profiler that profiles mainly performance and memory usage. The profiler is extended and improved {{in three ways}} {{as part of this}} thesis: support for 64 -bit ARM is implemented, the execution time of <b>stack</b> <b>tracing</b> is reduced on both 64 -bit and 32 -bit ARM and a simple energy profiling module is added. The IgProf profiler was available on the Intel x 86 and x 86 - 64 architectures, as well as on 32 -bit ARM, but support for 64 -bit ARM was missing. The port of IgProf to 64 -bit ARM enables developers to evaluate how applications execute on the new architecture with regard to performance and memory usage. The port of IgProf is going to be used on 64 -bit ARM for examination and optimisation of the CMS software, which is related to the Compact Muon Solenoid (CMS) experiment at CERN. IgProf uses the libunwind library to perform <b>stack</b> <b>tracing</b> as part of the pro-filing. An optimised version of <b>stack</b> <b>tracing,</b> previously available only on the x 86 - 64 architecture, is ported to both 64 -bit and 32 -bit ARM. The optimise...|$|R
50|$|FusionReactor {{has been}} {{implemented}} as a Java agent, using point cut technology within the J2EE servlet container. The agent enables FusionReactor to instrument any information {{which is available}} within the Java container, including CPU, memory, thread information (<b>stack</b> <b>traces)</b> and JDBC calls.|$|R
5000|$|Python - Stock Python {{implementations}} do {{not perform}} tail-call optimization, though a third-party module {{is available to}} do this. Language inventor Guido van Rossum contends that <b>stack</b> <b>traces</b> are altered by tail call elimination making debugging harder, and prefers that programmers use explicit iteration instead ...|$|R
50|$|June 2002 Stylus Studio 2004 {{released}} a two way visual schema designer for XML Schema 1.0 {{and the first}} IDE to feature postmortem <b>stack</b> <b>trace</b> for XSLT with back mapping to the XSLT source. At {{that time it was}} the only XSLT debugger supporting cross-debugging between XSLT and Java extension functions.|$|E
50|$|Bug Buddy is {{the crash}} {{reporting}} tool {{used by the}} GNOME platform. When an application using the GNOME libraries crashes, Bug Buddy generates a <b>stack</b> <b>trace</b> using gdb and invites the user to submit the report to the GNOME bugzilla. The user can add comments and view {{the details of the}} crash report.|$|E
5000|$|Many {{programming}} languages, including Java and C#, have {{built-in support}} for retrieving the current <b>stack</b> <b>trace</b> via system calls. C++ has no built-in support for doing this, but C++ users can retrieve stack traces with (for example) the stacktrace library. In JavaScript exceptions hold a [...] property that contain the stack {{from the place}} where it was thrown.|$|E
40|$|Due to the {{character}} of the original source materials and the nature of batch digitization, quality control issues may be present in this document. Please report any quality issues you encounter to digital@library. tamu. edu, referencing the URI of the item. Includes bibliographical references. Conventional spiking deconvolution was applied to increase the high-f requency content of seismic data. The seismic data set was processed by CMP sorting, f ieldstatic corrections, velocity analysis, normal-moveout corrections, residual-static corrections besides corrections, residual-static corrections besides deconvolution. Before performing deconvolution, the effect of the design-window length, deconvolutionoperator length, and the location of the design window were investigated. From the analyses of the above parameters, it was shown that the location of window has the greatest effect on deconvolution. When the deconvolution operator was calculated, three methods of deconvolution were tested. They are I) the deconvolution operator was calculated for every trace in every CDP gather and the operator was applied to its trace and the <b>traces</b> are <b>stacked,</b> 2) deconvolution operators are calculated for each <b>stacked</b> <b>trace</b> and applied to the <b>stacked</b> <b>trace</b> from which it was calculated, and 3) the average is deconvolution operator obtained by averaging the operators from the second method and applied the <b>stacked</b> <b>traces.</b> From the observation of the stacked sections obtained using each method, it appears the third method generated the best results. This method requires one more step than second method but the result is much better. Synthetic seismograms were generated by two methods. one used the reflection-coefficients model and the other used the impulse-response model (including multiples). These results were convolved with a Ricker wavelet to generate synthetic seismograms. The results from both methods are similar each other and they are well correlated with <b>stacked</b> <b>trace...</b>|$|R
50|$|Crash Reporting creates {{detailed}} {{reports of}} the errors in the app. Errors are grouped into clusters of similar <b>stack</b> <b>traces</b> and triaged by the severity of impact on app users. In addition to automatic reports, developer can log custom events to help capture the steps leading up to a crash.|$|R
5000|$|... sustack <b>stack</b> {{adjacent}} <b>traces</b> {{having the}} same key header word ...|$|R
