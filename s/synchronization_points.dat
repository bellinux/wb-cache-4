172|119|Public
50|$|SLS {{can benefit}} from {{parallel}} computing architectures.For instance, existing algorithms to generate code from high-level modeling languages {{can be adapted to}} multi-core processors like GPUs. Parallel co-simulation is another approach to enable numerical integration speed-ups. In this approach, the global system is partitioned into sub-systems. The subsystems are integrated independently of each other and are synchronized at discrete <b>synchronization</b> <b>points.</b> Data exchange between subsystems occurs only at the <b>synchronization</b> <b>points.</b> This results in a loose coupling between the sub-systems.|$|E
50|$|Traditional DBR usually {{calls for}} buffers at several {{points in the}} system: the constraint, <b>synchronization</b> <b>points</b> and at {{shipping}}. S-DBR has a buffer at shipping and manages the flow of work across the drum through a load planning mechanism.|$|E
50|$|Critical Chain Project Management (CCPM) are {{utilized}} in this area. CCPM {{is based on}} the idea that all projects look like A-plants: all activities converge to a final deliverable. As such, to protect the project, there must be internal buffers to protect <b>synchronization</b> <b>points</b> and a final project buffer to protect the overall project.|$|E
5000|$|When SS2PL is {{effectively}} utilized in a distributed environment, then global deadlocks due to locking generate voting-deadlocks in 2PC, and are resolved automatically by 2PC (see Commitment ordering (CO), in Exact characterization of voting-deadlocks by global cycles; No reference except the CO articles {{is known to}} notice this). For the general case of 2PL, global deadlocks are similarly resolved automatically by the <b>synchronization</b> <b>point</b> protocol of phase-1 end in a distributed transaction (<b>synchronization</b> <b>point</b> is achieved by [...] "voting" [...] (notifying local phase-1 end), and being propagated to the participants in a distributed transaction {{the same way as}} a decision point in atomic commitment; in analogy to decision point in CO, a conflicting operation in 2PL cannot happen before phase-1 end <b>synchronization</b> <b>point,</b> with the same resulting voting-deadlock {{in the case of a}} global data-access deadlock; the voting-deadlock (which is also a locking based global deadlock) is automatically resolved by the protocol aborting some transaction involved, with a missing vote, typically using a timeout).|$|R
40|$|Stochastic dual dynamic {{programming}} (SDDP) {{has become a}} popular algorithm used in practical long-term scheduling of hydro power systems. The SDDP algorithm is significantly more computationally demanding than most heuristic-based scheduling methods, but can be designed {{to take advantage of}} parallel processing. This thesis presents a novel parallel scheme for the SDDP algorithm, where the stage-wise <b>synchronization</b> <b>point</b> traditionally used in the backward iteration of the SDDP algorithm is either partially or fully relaxed. The proposed scheme was tested on a realistic model of a Norwegian water course, proving that the partial <b>synchronization</b> <b>point</b> relaxation significantly improves parallel efficiency...|$|R
50|$|Meli-Šipak II, or {{alternatively}} Melišiḫu in contemporary inscriptions, was the 33rd {{king of the}} Kassite or 3rd Dynasty of Babylon ca. 1186-1172 BC (short chronology) and he ruled for 15 years. His reign marks the critical <b>synchronization</b> <b>point</b> in the chronology of the Near East.|$|R
50|$|By restricting {{services}} to only {{those that are}} absolutely necessary and by streamlining those that are provided, the overhead (sometimes called noise) of the lightweight operating system is minimized. This allows a significant and predictable amount of the processor cycles {{to be given to}} the parallel application. Since the application can make consistent progress on each processor, they will reach their <b>synchronization</b> <b>points</b> faster, ideally at the same time. Lost wait time is reduced.|$|E
50|$|An {{example of}} a session-layer {{protocol}} is the OSI protocol suite session-layer protocol, also known as X.225 or ISO 8327. In case of a connection loss this protocol may try to recover the connection. If a connection is not used for a long period, the session-layer protocol may close it and re-open it. It provides for either full duplex or half-duplex operation and provides <b>synchronization</b> <b>points</b> in the stream of exchanged messages.|$|E
5000|$|There {{were also}} {{challenge}} rooms {{present in the}} game, which required Ezio to clear a specific objective. The challenge rooms were played through in the Animus corridor, similar to the tutorial levels in the game. Cheats, dubbed [...] "Animus hacks", were present within the game, which could be unlocked by obtaining enough <b>synchronization</b> <b>points.</b> These cheats ranged from character skins to boosted gameplay movement and perks, which gave the player an advantage or allowed them to customize Ezio.|$|E
50|$|For 2PL in general, the {{automatic}} resolution by the (mandatory) end-of-phase-one <b>synchronization</b> <b>point</b> protocol (which has same voting mechanism as atomic commitment protocol, and same missing vote handling upon voting deadlock, resulting in global deadlock resolution) {{has not been}} mentioned until today (2009). Practically only the special case SS2PL is utilized, where no end-of-phase-one synchronization is needed in addition to atomic commit protocol.|$|R
50|$|MPI-2 defines three one-sided {{communications}} operations, , , and , being a {{write to}} remote memory, a read from remote memory, {{and a reduction}} operation on the same memory across a number of tasks, respectively. Also defined are three different methods to synchronize this communication (global, pairwise, and remote locks) as the specification does not guarantee that these operations have taken place until a <b>synchronization</b> <b>point.</b>|$|R
50|$|Local SS2PL {{together}} with atomic commitment implying global serializability {{can also be}} deduced directly: All transactions, including distributed, obey the 2PL (SS2PL) rules. The atomic commitment protocol mechanism is not needed here for consensus on commit, but rather {{for the end of}} phase-two <b>synchronization</b> <b>point.</b> Probably for this reason, without considering the atomic commitment voting mechanism, automatic global deadlock resolution has not been noticed before CO.|$|R
50|$|The High-Level Architecture (HLA IEEE 1516) is an IEEE and SISO {{standard}} for simulation interoperability. It defines {{a set of}} services, provided through an API in C++ or Java. The services offer publish/subscribe based information exchange, based on a modular Federation Object Model. There are also services for coordinated data exchange and time advance, based on logical simulation time, as well as <b>synchronization</b> <b>points.</b> Additional services provide transfer of ownership, data distribution optimizations and monitoring and management of participating Federates (systems).|$|E
50|$|Memories {{were played}} out in missions, similar to Assassin's Creed II, in that players were given <b>synchronization</b> <b>points</b> by {{clearing}} the mission, provided the required objectives were met in the mission's structure. These specific factors were the following: Time cleared, kills, damage taken, and notoriety. In order to achieve perfect synchronization with the requirements, the player had to complete the level as fast as possible, kill as many as they could, and take minimal damage respectively, though the required values varied from mission to mission.|$|E
5000|$|The parser uses {{recursive}} descent; LL(1) conflicts can {{be resolved}} by either a multi-symbol lookahead or by semantic checks. Thus the class of accepted grammars is LL(k) for an arbitrary k. Fuzzy parsing is supported by so-called ANY symbols that match complementary sets of tokens. Semantic actions are written in the same language as the generated scanner and parser. The parser's error handling can be tuned by specifying <b>synchronization</b> <b>points</b> and [...] "weak symbols" [...] in the grammar. Coco/R checks the grammar for completeness, consistency, non-redundancy {{as well as for}} LL(1) conflicts.|$|E
5000|$|A 2-pop is {{typically}} {{placed at the}} end of a visual countdown. Only the first frame of the [...] "2" [...] is shown, and the remainder of the 2 seconds prior to the program is black. This provides a unique point of reference where the frame-long image and frame-long sound should align, similar to the way a film clapperboard is used to generate a <b>synchronization</b> <b>point.</b>|$|R
40|$|Abstract. In {{behavioral}} programming, {{a program}} consists of separate modules called behavior threads, each representing {{a part of}} the system’s allowed, necessary or forbidden behavior. An execution of the program is a series of synchronizations between these threads, where at each <b>synchronization</b> <b>point</b> an event is selected to be carried out. As a result, the execution speed is dictated by the slowest thread. We propose an eager execution mechanism for such programs, which builds upon the realization that it is often possible to predict the outcome of a <b>synchronization</b> <b>point</b> even without waiting for slower threads to synchronize. This allows faster threads to continue running uninterrupted, whereas slower ones catch up at a later time. Consequently, eager execution brings about increased system performance, better support for the modular design of programs, and the ability to distribute programs across several machines. It also allows to apply behavioral programming to a variety of problems that were previously outside its scope. We illustrate the method by concrete examples, implemented in a behavioral programming framework in C++...|$|R
40|$|In {{distributed}} multimedia systems, the synchronization {{of multimedia}} information {{is one of}} the most important as well as difficult issues. In this paper, we propose three synchronization mechanisms and discuss how to implement these methods in our developed distributed hypermedia system Harmony. The proposed synchronization mechanisms are (1) <b>point</b> <b>synchronization,</b> (2) real-time synchronization, and (3) adaptive <b>synchronization.</b> <b>Point</b> <b>synchronization</b> realizes that the start/completion time of the presentation of multimedia information is synchronized with a certain specified point on the real time axis. Using this synchronization mechanism, the simultaneous start of presentation of multifarious information can be realized. In the case of real-time synchronization, if the presentation of a certain information medium lags behind the normal presentation rate because of an unexpected heavy load on the workstation, the process skips over certain presentation scenes and catches up to the cor [...] ...|$|R
50|$|In {{computer}} science, a trace {{is a set}} of strings, wherein certain {{letters in}} the string are allowed to commute, but others are not. It generalizes the concept of a string, by not forcing the letters to always be in a fixed order, but allowing certain reshufflings to take place. Traces were introduced by Cartier and Foata in 1969 to give a combinatorial proof of MacMahon's Master theorem. Traces are used in theories of concurrent computation, where commuting letters stand for portions of a job that can execute independently of one another, while non-commuting letters stand for locks, <b>synchronization</b> <b>points</b> or thread joins.|$|E
50|$|A data {{synchronization}} {{point is}} a point in time. It is {{used to assess the}} way in which data backups relate to each other. Data backups need to be related to each other correctly when considering the time of day they were made, or their relationship to computer system activity events. A data synchronization {{point is a}} point in time when a set of backups exist which if restored from can be synchronized to the same point in time. Often this point in time is some hours before the last backup is completed, i.e., some hours before the data synchronization point. Backups that have no <b>synchronization</b> <b>points</b> are generally useless.|$|E
50|$|On large {{computers}} {{barriers are}} expensive, {{and this is}} increasingly so on large scales. There is {{a large body of}} literature on removing <b>synchronization</b> <b>points</b> from existing algorithms, both in the context of BSP computing and beyond. For example, many algorithms allow for the local detection of the global end of a superstep simply by comparing local information to the number of messages already received. This drives the cost of a global synchronisation, compared to the minimally required latency of communication, to zero. Yet also this minimal latency is expected to increase further for future supercomputer architectures and network interconnects; the BSP model, along with other models for parallel computation, require adaptation to cope with this trend. Multi-BSP is one BSP-based solution.|$|E
50|$|Consider {{a system}} employs a {{software}} level shared memory abstraction {{rather than an}} actual hardware implementation. In this system, write propagation is executed at a page granularity, which makes it extremely expensive to propagate a whole page when only one block in this page is modified. Therefore, write propagation is delayed until a release <b>synchronization</b> <b>point</b> is reached and the entire page will be modified at this time and the whole page will be propagated.|$|R
40|$|JPEG {{images are}} almost always self-synchronized after an {{occurrence}} of an error in the JPEG file. In spite of the self-synchronization feature, after the <b>synchronization</b> <b>point</b> in the image, {{the rest of the}} image is not shown as {{it has been in the}} genuine image. Commonly, the blocks are shifted to right or left and usually the tinge is damaged as well. This paper suggests a way how to remedy the block shift and the tinge damage...|$|R
40|$|Barrier synchronizations {{can be very}} {{expensive}} on multiprogramming environment because no process can go past a barrier until all the processes have arrived. If a process participating at a barrier is swapped out by the operating system, the rest of participating processes end up waiting for the swapped-out process. This paper presents a compile-time/run-time system that uses a dependence-driven execution to overlap the execution of computations separated by barriers so that the processes do not {{spend most of the}} time idling at the <b>synchronization</b> <b>point...</b>|$|R
50|$|Kali Yuga (2000, {{pixilation}} {{and object}} animation) Directed, produced and animated by Joanna Priestley. Kali Yuga was a performance and animation collaboration with filmmaker Joanna Priestley, composer Joseph Waters and contemporary classical ensemble, Fear No Music. It included physical performances by the musicians (playing {{upside down in}} wooden contraptions, dropping a bowling ball {{from the top of}} a ladder into a vat of pennies) with projected animation. The pixillation of yogi Diane Wilson was shot over six months in the forests and parks near Portland, Oregon. The object animation was an experiment using household tools, bolts, screws and nails. Kali Yuga is a modern score in the style of classic 1940s cartoons. It placed virtuosic demands on the performers, with 150 <b>synchronization</b> <b>points.</b> Kali Yuga was performed at Reed College, Northwest Film Center, University of Oregon and the San Diego State University. Bob (2001, Directed and produced by Matt Smith). Music performed live by Fear no Music ensemble at Reed College and San Diego State University.|$|E
50|$|Processor consistency, while {{weaker than}} {{sequential}} consistency, {{is still in}} most cases a stronger consistency model than is needed. This {{is due to the}} number of <b>synchronization</b> <b>points</b> inherent to programs that run on multiprocessor systems. This means that no data races can occur (a data race being multiple simultaneous accesses to memory location where at least one access is a write). With this in mind, it is clear to see that a model could allow for reorganization of all memory operations, as long as no operation crosses a synchronization point and one does, called Weak Ordering. However, weak ordering does impose some of the same restrictions as processor consistency, namely that the system must remain coherent and thus all writes to the same memory location must be seen by all processors in the same order. Similar to weak ordering, the release consistency model allows reordering of all memory operations, but it gets even more specific and breaks down synchronization operations to allow more relaxation of reorders. It should be noted, however, that both of these models assume proper synchronization of code and in some cases hardware synchronization support, and so to that effect processor consistency is a safer model to adhere to if one is unsure about the reliability of the programs to be run using the model.|$|E
30|$|The single-hop TTS {{focuses on}} {{providing}} <b>synchronization</b> <b>points</b> (sync-points), {{which can be}} used to estimate the node clock phase and skew, instead of the approach to calculate the offsets directly.|$|E
40|$|Article dans revue scientifique avec comité de lecture. internationale. International audienceVirtual {{enterprises}} gather partners {{distributed in}} space, time and organizations, {{in order to}} achieve a common goal. Their business process realization needs the coordination of their distributed interactions. This paper presents the <b>Synchronization</b> <b>Point</b> model. It provides support for cooperative process management and coordination. It offers pertinent information about work progress while maintaining adequate privacy of information, and supports both long-time transactions and dynamic process definition. Then, its data repository and activity manager helps human interactions in cross-organizational applications...|$|R
40|$|This paper {{presents}} an analytic solution to progress graphs used for performance analysis. It derives the exact sequence of blocking and running times experienced by two processes sharing mutually exclusive, reusable resources. A novel application of Dijkstra's progress graphs yields the complex {{relationship between the}} waiting times at each <b>synchronization</b> <b>point.</b> The problem of solving progress graphs is formulated in terms of finding the minimum solution of each {{of a set of}} Diophantine equations. An algorithm is presented to find all steady state behaviors involving blocking that emerge from any initial condition...|$|R
40|$|The paper {{deals with}} the {{synchronization}} mechanism among the servers of a federation of distributed repositories for the constant updating of the didactic-scientific material, its properties and its locations. A shared metadata database is the <b>synchronization</b> <b>point</b> of reference and it allows to improve performance in terms of searching and downloading. The proposed federation is meant {{to deal with a}} large variety of different contents though the discussed prototype implementation is concerned with scientific and educational subjects in particular. Additional elements of evaluation are the capability of enhancing collaboration and fault tolerance...|$|R
40|$|Concurrency bugs usually {{manifest}} {{under very}} rare conditions, and reproducing such bugs {{can be a}} challenging task. To reproduce concurrency bugs with a given input, {{one would have to}} explore the vast interleaving space, searching for erroneous schedules. The challenges are compounded in a big data environment. This paper explores the topic of concurrency bug reproduction using runtime data. We approach the concurrency testing and bug reproduction problem differently from existing literature, by emphasizing on the preemptable <b>synchronization</b> <b>points.</b> In our approach, a light-weight profiler is implemented to monitor program runs, and collect <b>synchronization</b> <b>points</b> where thread scheduler could intervene and make scheduling decisions. Traces containing important synchronization API calls and shared memory accesses are recorded and analyzed. Based on the preemptable <b>synchronization</b> <b>points,</b> we build a reduced preemption set (RPS) to narrow down the search space for erroneous schedules. We implement an optimized preemption-bounded schedule search algorithm and an RPS directed search algorithm, in order to reproduce concurrency bugs more efficiently. Those schedule exploration algorithms are integrated into our prototype, Profile directed Event driven Dynamic AnaLysis (PEDAL). The runtime data consisting of <b>synchronization</b> <b>points</b> is used as a source of feedback for PEDAL. To demonstrate utility, we evaluate the performance of PEDAL against those of two systematic concurrency testing tools. The findings demonstrate that PEDAL can detect concurrency bugs more quickly with given inputs, and consuming less memory. To prove its scalability in a big data environment, we use PEDAL to analyze several real concurrency bugs in large scale multithread programs, namely: Apache, and MySQL. Concurrency bugs usually manifest under very rare conditions, and reproducing such bugs can be a challenging task. To reproduce concurrency bugs with a given input, one would have to explore the vast interleaving space, searching for erroneous schedules. The challenges are compounded in a big data environment. This paper explores the topic of concurrency bug reproduction using runtime data. We approach the concurrency testing and bug reproduction problem differently from existing literature, by emphasizing on the preemptable <b>synchronization</b> <b>points.</b> In our approach, a light-weight profiler is implemented to monitor program runs, and collect <b>synchronization</b> <b>points</b> where thread scheduler could intervene and make scheduling decisions. Traces containing important synchronization API calls and shared memory accesses are recorded and analyzed. Based on the preemptable <b>synchronization</b> <b>points,</b> we build a reduced preemption set (RPS) to narrow down the search space for erroneous schedules. We implement an optimized preemption-bounded schedule search algorithm and an RPS directed search algorithm, in order to reproduce concurrency bugs more efficiently. Those schedule exploration algorithms are integrated into our prototype, Profile directed Event driven Dynamic AnaLysis (PEDAL). The runtime data consisting of <b>synchronization</b> <b>points</b> is used as a source of feedback for PEDAL. To demonstrate utility, we evaluate the performance of PEDAL against those of two systematic concurrency testing tools. The findings demonstrate that PEDAL can detect concurrency bugs more quickly with given inputs, and consuming less memory. To prove its scalability in a big data environment, we use PEDAL to analyze several real concurrency bugs in large scale multithread programs, namely: Apache, and MySQL...|$|E
40|$|Abstract. This paper {{introduces}} new invariants for multiparameter dynamical systems. This is done {{by counting}} the number of points whose orbits intersect at time n under simultaneous iteration of finitely many endomorphisms. We call these points <b>synchronization</b> <b>points.</b> The resulting sequences of counts together with generating functions and growth rates are subsequently investigated for homeomorphisms of compact metric spaces, toral automorphisms and compact abelian group epimorphisms. <b>Synchronization</b> <b>points</b> are also used to generate invariant measures and the distribution properties of these are analysed for the algebraic systems considered. Furthermore, these systems reveal strong connections between the new invariants and problems of active interest in number theory, relating to heights and greatest common divisors. 1...|$|E
40|$|Colloque avec actes et comité de lecture. internationale. International audienceIn {{a virtual}} {{enterprise}} context, business process interoperability and cooperative process enactment {{are important in}} order to achieve a common objective despite the distribution in space, time and organizations. A contract is a facility that allows for deploying cross-organizational processes, monitoring and enforcing the composition and the enactment of these processes {{both inside and outside the}} organization's boundaries. This paper presents a contract model for describing clauses that address business interactions, for deploying cross-organizational activities (called <b>synchronization</b> <b>points)</b> and for enforcing and controling policies through the use of ECA rules. A contract is an XML document that allows for describing how process Web services cooperate and how <b>synchronization</b> <b>points</b> enforce contract clauses...|$|E
40|$|A {{concept of}} phase <b>synchronization</b> <b>point</b> is proposed, {{and then a}} model is built using this concept to explain {{secondary}} instabilities. This model {{has been used to}} determine the conditions of K- and H-type secondary instabilities, which are coincident with the conditions published in literatures. It also can be used to analyze other secondary instability phenomena. For example, the numerical results validate the analysis results in the case of 1 / 3 rd subharmonic mode secondary instability. Furthermore, the numerical results indicate that the spanwise wave number of 3 D disturbance has significant effect on the secondary instability...|$|R
3000|$|To join a Federation, a Federate {{must call}} the runFederate {{function}} from Virtual Bus API, described in Code 1. This function creates {{an instance of}} RTI Ambassador, requesting the RTI to create the Federation {{if it does not}} exist, and create the Federate Ambassador. The actual Federate joins the Federation and signals the RTI that it is ready to run as soon as all other Federates reach the <b>synchronization</b> <b>point</b> called READY_TO_RUN. Finally, when a Federate calls the method publishAndSubscribe (...) the time policy is set and all interesting objects to receive and send updates are registered.|$|R
40|$|Abstract:- The recent {{progress}} in the optical wireless communications systems with direct detection makes them appear as an important alternative to the conventional wireless (and wired) communication systems. An important application of such systems could be the called “last mile ” connection. Nevertheless, {{in order to take}} full advantage of the extremely huge wide bandwidth of the optical channels it will be necessary to use coherent detection instead of direct detection. In this paper, we describe several key issues needed to implement a practical coherent wireless communications system. Key-Words:- coherent detection, optical wireless systems, optical <b>synchronization,</b> <b>pointing,</b> tracking, acquisition. ...|$|R
