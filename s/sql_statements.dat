422|172|Public
25|$|Lastly, SQL {{injection}} exploits a vulnerability in {{the database}} layer of an application. When user input is incorrectly filtered, any <b>SQL</b> <b>statements</b> can be executed by the application.|$|E
25|$|The {{names and}} {{locations}} of {{documents in the}} system are exposed as a table with the column names System. ItemName and System. ItemURL respectively. A SQL query can directly reference these tables and index catalogues and use the MSIDXS provider to run queries against them. The search index {{can also be used}} via OLE DB, using the CollatorDSO provider. However, the OLE DB provider is read-only, supporting only SELECT and GROUP ON <b>SQL</b> <b>statements.</b>|$|E
25|$|The default catalog {{is called}} SystemIndex and it stores all the {{properties}} of indexed items with a predefined naming pattern. For example, the name and location of documents in the system is exposed as a table with the column names System. ItemName and System. ItemURL respectively. An SQL query can directly refer these tables and index catalogues and use the MSIDXS provider to run queries against them. The search index {{can also be used}} via OLE DB, using the CollatorDSO provider. However, OLE DB provider is read-only, supporting only SELECT and GROUP ON <b>SQL</b> <b>statements.</b>|$|E
50|$|Autocompletion in {{database}} query tools {{allows the}} user to autocomplete the table names in an <b>SQL</b> <b>statement</b> and column names of the tables referenced in the <b>SQL</b> <b>statement.</b> As text is typed into the editor, {{the context of the}} cursor within the <b>SQL</b> <b>statement</b> provides an indication of whether the user needs a table completion or a table column completion. The table completion provides a list of tables available in the database server the user is connected to. The column completion provides a list of columns for only tables referenced in the <b>SQL</b> <b>statement.</b> <b>SQL</b> Server Management Studio provides autocomplete in query tools.|$|R
40|$|A simple <b>sql</b> <b>statement</b> {{can be used}} {{to search}} {{learning}} or rule in relational database for data mining purposes particularly for classification rule. With just only one simple <b>sql</b> <b>statement,</b> characteristic and classification rule can be created simultaneously. Collaboration <b>sql</b> <b>statement</b> with any other application software will increase the ability for creating t-weight as measurement the typicality of each record in the characteristic rule and d-weight as measurement the discriminating behavior of the learned classification/discriminant rule, specifically for further generalization in characteristic rule. Handling concept hierarchy into tables based on concept tree will influence for the successful simple <b>sql</b> <b>statement</b> and by knowing the right standard knowledge to transform each of concept tree in concept hierarchy into one table as to transform concept hierarchy into table, the simple <b>sql</b> <b>statement</b> can be run properly. Comment: 6 page...|$|R
40|$|Searching {{learning}} or rules in relational database for data mining purposes with characteristic or classification/discriminant rule in attribute oriented induction technique can be quicker, easy, and simple with simple <b>SQL</b> <b>statement.</b> With just only one simple <b>SQL</b> <b>statement,</b> characteristic and classification rule {{can be created}} simultaneously. Collaboration <b>SQL</b> <b>statement</b> with any other application software will increase the ability for creating t-weight as measurement the typicality of each record in the characteristic rule and d-weight as measurement the discriminating behavior of the learned classification/discriminant rule, particularly for further generalization in characteristic rule. Handling concept hierarchy into tables based on concept tree will influence for the successful simple <b>SQL</b> <b>statement</b> and by knowing the right standard knowledge to transform each of concept tree in concept hierarchy into one table as transforming concept hierarchy into table, the simple <b>SQL</b> <b>statement</b> can be run properly. Comment: 17 pages, 20 tables, 4 figure...|$|R
500|$|Misunderstanding of how Null {{works is}} the cause of a great number of errors in SQL code, both in ISO {{standard}} <b>SQL</b> <b>statements</b> and in the specific SQL dialects supported by real-world database management systems. These mistakes are usually the result of confusion between Null and either 0 (zero) or an empty string (a string value with a length of zero, represented in SQL as [...] ). [...] Null is defined by the SQL standard as different from both an empty string and the numerical value 0, however. While Null indicates the absence of any value, the empty string and numerical zero both represent actual values.|$|E
2500|$|SQLCMD is {{a command}} line {{application}} {{that comes with}} Microsoft SQL Server, and exposes the management features of SQL Server. It allows SQL queries to be written and executed from the command prompt. It can also act as a scripting language to create and run a set of <b>SQL</b> <b>statements</b> as a script. Such scripts are stored as a [...]sql file, and are used either for management of databases or to create the database schema during the deployment of a database.|$|E
50|$|Embedded SQL is {{a method}} of {{combining}} the computing power of a programming language and the database manipulation capabilities of SQL. Embedded <b>SQL</b> <b>statements</b> are <b>SQL</b> <b>statements</b> written inline with the program source code of the host language. The embedded <b>SQL</b> <b>statements</b> are parsed by an embedded SQL preprocessor and replaced by host-language calls to a code library. The output from the preprocessor is then compiled by the host compiler. This allows programmers to embed <b>SQL</b> <b>statements</b> in programs written {{in any number of}} languages such as , COBOL and Fortran. This differs from SQL-derived programming languages that don't go through discrete preprocessors, such as PL/SQL and T-SQL.|$|E
50|$|The library cache stores shared SQL, caching the {{parse tree}} and the {{execution}} plan for every unique <b>SQL</b> <b>statement.</b> If multiple applications issue the same <b>SQL</b> <b>statement,</b> each application can access the shared SQL area. This reduces the amount of memory needed and reduces the processing-time used for parsing and execution planning.|$|R
50|$|In {{the context}} of data management, autocommit is a mode of {{operation}} of a database connection. Each individual database interaction (i.e., each <b>SQL</b> <b>statement)</b> submitted through the database connection in autocommit mode will be executed in its own transaction that is implicitly committed. A <b>SQL</b> <b>statement</b> executed in autocommit mode cannot be rolled back.|$|R
5000|$|The {{corresponding}} Oracle syntax <b>SQL</b> <b>statement</b> {{is assumed}} to be as follows: ...|$|R
50|$|SQL-data access - {{tells the}} {{database}} management system whether the function contains no <b>SQL</b> <b>statements</b> (NO SQL), contains <b>SQL</b> <b>statements</b> but does not access any tables or views (CONTAINS SQL), reads data from tables or views (READS SQL DATA), or actually modifies data in the database (MODIFIES SQL DATA).|$|E
5000|$|... {{placing the}} <b>SQL</b> <b>statements</b> in a file {{external}} to the source code; this separate file is converted to object code by the [...] "SQL Module Language" [...] compiler, and the source code then references these <b>SQL</b> <b>statements</b> and, after compilation, the two are joined by the OpenVMS linker.|$|E
50|$|NHibernate's {{configuration}} {{may affect}} when NHibernate executes <b>SQL</b> <b>statements.</b>|$|E
5000|$|Likewise, foreign keys can {{be defined}} as part of the [...] <b>SQL</b> <b>statement.</b>|$|R
30|$|A {{part of the}} {{generated}} <b>SQL</b> <b>statement</b> {{is presented}} in Annex I (of this paper).|$|R
5000|$|The other example {{shows the}} <b>SQL</b> <b>statement</b> of searching {{employee}} information {{by their first}} name order ...|$|R
5000|$|Intellisense for source, <b>SQL</b> <b>statements</b> and {{user defined}} objects.|$|E
5000|$|To {{work with}} cursors {{you must use}} the {{following}} <b>SQL</b> <b>statements</b> ...|$|E
50|$|The SQLite {{database}} engine translates <b>SQL</b> <b>statements</b> into {{a bespoke}} byte-code format.|$|E
5000|$|This <b>SQL</b> <b>statement</b> can {{be created}} using Empire-db's command API using object model {{references}} like this: ...|$|R
50|$|Populate the {{recordset}} {{by opening}} it and passing the desired table name or <b>SQL</b> <b>statement</b> as a parameter to open function.|$|R
5000|$|A full table scan example: The example {{shows the}} <b>SQL</b> <b>statement</b> of searching items with id {{is bigger than}} 10 from table1 ...|$|R
5000|$|Item 106. Prepare your <b>SQL</b> <b>statements</b> {{to reuse}} work and save time.|$|E
5000|$|As {{compared}} to executing <b>SQL</b> <b>statements</b> directly, prepared statements offer two main advantages: ...|$|E
5000|$|DBRM modules (compiled modules {{containing}} the <b>SQL</b> <b>statements</b> and variables used by programs) ...|$|E
5000|$|Interactive use {{can then}} start by {{entering}} a <b>SQL</b> <b>statement</b> (terminated by a semicolon), a PL/SQL block, or another command. For example: ...|$|R
50|$|Constructs are {{a direct}} {{substitution}} of a value, {{and help to}} build or modify a <b>SQL</b> <b>statement.</b> Examples include %Bind, %InsertSelect, and %List.|$|R
40|$|In this paper, {{we present}} a {{framework}} for rapid development of online transaction processing (OLTP) information systems. The framework assumes that a Web application will be developed {{on top of an}} available database. It includes a transformation that receives as an input a <b>SQL</b> <b>statement</b> and results in as an output a three-tier Web application. The transformation allows developers to generate an implementation specification, i. e. the source code of the presentation and logic tier of a Web application, from a <b>SQL</b> <b>statement.</b> It consists of a development method and three transformations. The transformation is to produce (i) a query form page, (ii) a query result page, and (iii) a Web services method that implement the <b>SQL</b> <b>statement.</b> To result in ready-to-deploy source code, developers must supply the transformations with additional information. Keywords: model-driven engineering; transformation; SQL statements; web applications; three-tier architecture...|$|R
5000|$|Support for {{additional}} character sets beyond the base requirement for representing <b>SQL</b> <b>statements.</b>|$|E
5000|$|... {{embedding}} <b>SQL</b> <b>statements</b> in {{the source}} file then running {{it through a}} precompiler ...|$|E
50|$|Meta-variables enable {{substitution}} of text within <b>SQL</b> <b>statements.</b> Examples include %AsOfDate, %Comma, and %JobInstance.|$|E
5000|$|Determinism - {{specifies}} {{whether the}} function is deterministic or not. The determinism characteristic has {{an influence on}} the query optimizer when compiling a <b>SQL</b> <b>statement.</b>|$|R
5000|$|A [...] {{clause in}} SQL {{specifies}} that a SQL Data Manipulation Language (DML) statement should only affect rows that meet specified criteria. The criteria {{are expressed in}} the form of predicates. [...] clauses are not mandatory clauses of <b>SQL</b> DML <b>statements,</b> but can be used {{to limit the number of}} rows affected by a <b>SQL</b> DML <b>statement</b> or returned by a query. In brief SQL WHERE clause is used to extract only those results from a <b>SQL</b> <b>statement,</b> such as: SELECT, INSERT, UPDATE, or DELETE statement.|$|R
50|$|In many cases, the <b>SQL</b> <b>statement</b> is fixed, {{and each}} {{parameter}} is a scalar, not a table. The user input is then assigned (bound) to a parameter.|$|R
