161|264|Public
2500|$|Debugging ranges in {{complexity}} from fixing simple errors to performing {{lengthy and}} tiresome tasks of data collection, analysis, and scheduling updates. [...] The debugging {{skill of the}} programmer can be {{a major factor in}} the ability to debug a problem, but the difficulty of <b>software</b> <b>debugging</b> varies greatly with the complexity of the system, and also depends, to some extent, on the programming language(s) used and the available tools, such as debuggers. Debuggers are software tools which enable the programmer to monitor the execution of a program, stop it, restart it, set breakpoints, and change values in memory. The term debugger can also refer to the person who is doing the debugging.|$|E
50|$|On some systems, a {{computer}} user can trigger an NMI through hardware and <b>software</b> <b>debugging</b> interfaces and system reset buttons.|$|E
50|$|Embedded systems present special {{problems}} for programmers because they usually lack keyboards, monitors, disk drives and other user interfaces that are present on computers. These shortcomings make in-circuit <b>software</b> <b>debugging</b> tools essential for many common development tasks.|$|E
50|$|The term debug {{is used as}} an {{inclusive}} way to encompass the various methods used to detect, triage, trace, and potentially eliminate mistakes, or bugs, in hardware and/or <b>software.</b> <b>Debug</b> includes control/configure methods, stop/step mode debugging, and various forms of trace.|$|R
50|$|Another {{addition}} to the boundary-scan family of standards has been IEEE 1149.7, which defines a reduced pin-count interface and provides for enhanced <b>software</b> <b>debug.</b> In addition, IEEE 1149.7 {{is expected to be}} used in the testing of complex chips with multiple die stacked in one package.|$|R
40|$|This semestral {{thesis is}} {{concerned}} on facilities of using DebugMonitor exception for <b>debugging</b> <b>software</b> which run on ARM Cortex-M 4. The comunnication between <b>debugged</b> <b>software</b> and <b>debugging</b> master is implemented via CAN bus. The result is support for debugging without special debugging equipment. For {{support of this}} type of debug this thesis implemented code library called SDebug. It's managing parts of Cortex-M 4 core, which are userd for debug...|$|R
50|$|The ARC EM Starter Kit is a low-cost, {{versatile}} solution enabling rapid software development, code porting, <b>software</b> <b>debugging,</b> {{and system}} analysis for ARC EM4 and EM6 Processors. The kit {{consists of a}} hardware platform of pre-installed FPGA images of two ARC EM4 and two ARC EM6 configurations with peripherals, and a software package that includes the MQX real-time operating system (RTOS) in binary format, peripheral drivers, and application code examples.|$|E
5000|$|The user {{had to be}} {{familiar}} with programming in Signetics 2650 assembly language and the unconventional ways and register architecture of the Signetics 2650 processor. For example, on many other processors an opcode 0 indicates [...] "no operation" [...] whereas on the 2650 it instructs the processor to Branch To Address In Immediate Register B. This was a source of many <b>software</b> <b>debugging</b> hassles for budding home programmers.|$|E
5000|$|By design, Bugzilla is {{programmed}} {{to return the}} string [...] "zarro boogs found" [...] instead of [...] "0 bugs found" [...] when a search for bugs returns no results. [...] "Zarro Boogs" [...] is a meta-statement {{about the nature of}} <b>software</b> <b>debugging.</b> Bug tracking systems like Bugzilla readily describe how many known bugs are outstanding. The response [...] "zarro boogs", is intended as a buggy statement itself (a misspelling of [...] "zero bugs"), implying that even when no bugs have been identified, software is still likely to contain bugs that have not yet been identified.|$|E
50|$|System <b>{{software}}</b> <b>debug</b> {{support is}} for many software developers {{the main reason}} {{to be interested in}} JTAG. Many silicon architectures such as PowerPC, MIPS, ARM, x86 built an entire <b>software</b> <b>debug,</b> instruction tracing, and data tracing infrastructure around the basic JTAG protocol. Frequently individual silicon vendors however only implement parts of these extensions. Some examples are ARM CoreSight and Nexus as well as Intel's BTS (Branch Trace Storage), LBR (Last Branch Record), and IPT (Intel Processor Trace) implementations. There are many other such silicon vendor-specific extensions that may not be documented except under NDA. The adoption of the JTAG standard helped move JTAG-centric debugging environments away from early processor-specific designs. Processors can normally be halted, single stepped, or let run freely. One can set code breakpoints, both for code in RAM (often using a special machine instruction) and in ROM/flash. Data breakpoints are often available, as is bulk data download to RAM. Most designs have “halt mode debugging”, but some allow debuggers to access registers and data buses without needing to halt the core being debugged. Some toolchains can use ARM Embedded Trace Macrocell (ETM) modules, or equivalent implementations in other architectures to trigger debugger (or tracing) activity on complex hardware events, like a logic analyzer programmed to ignore the first seven accesses to a register from one particular subroutine.|$|R
50|$|Some program <b>debugging</b> <b>software</b> {{will also}} detect {{violations}} during testing.|$|R
40|$|Since pre-silicon {{functional}} verification {{is insufficient to}} detect all design errors, re-spins are often needed due to malfunctions that escape into the silicon. This paper presents an automated software solution {{to analyze the data}} collected during silicon debug. The proposed methodology analyzes the test sequences to detect suspects in both the spatial and the temporal domain. A set of <b>software</b> <b>debug</b> techniques are proposed to analyze the acquired data from the hardware testing and provide suggestions for the setup of the test environment in the next debug session. A comprehensive set of experiments demonstrate its effectiveness in terms of run-time and resolution. 1...|$|R
50|$|Debugging ranges in {{complexity}} from fixing simple errors to performing {{lengthy and}} tiresome tasks of data collection, analysis, and scheduling updates. The debugging {{skill of the}} programmer can be {{a major factor in}} the ability to debug a problem, but the difficulty of <b>software</b> <b>debugging</b> varies greatly with the complexity of the system, and also depends, to some extent, on the programming language(s) used and the available tools, such as debuggers. Debuggers are software tools which enable the programmer to monitor the execution of a program, stop it, restart it, set breakpoints, and change values in memory. The term debugger can also refer to the person who is doing the debugging.|$|E
50|$|A {{software}} metric is {{a standard}} of measure of a {{degree to which a}} software system or process possesses some property. Even if a metric is not a measurement (metrics are functions, while measurements are the numbers obtained by the application of metrics), often the two terms are used as synonyms. Since quantitative measurements are essential in all sciences, there is a continuous effort by computer science practitioners and theoreticians to bring similar approaches to software development. The goal is obtaining objective, reproducible and quantifiable measurements, which may have numerous valuable applications in schedule and budget planning, cost estimation, quality assurance testing, <b>software</b> <b>debugging,</b> software performance optimization, and optimal personnel task assignments.|$|E
5000|$|Joseph [...] "Joe" [...] Lawrence Zachary is an American {{computer}} scientist {{and professor at}} the University of Utah. He {{is known for his}} work in computer science education as a charter member of the United States Department of Energy Undergraduate Computational Engineering and Science (UCES) Project, an education initiative to improve the undergraduate science and engineering curriculum through computation. He was influential in promoting a new approach to teaching scientific programming to beginning science and engineering students. He is also known for coining [...] "Judy's Law", a <b>software</b> <b>debugging</b> principle which states [...] "if something seems wrong but you dismiss it, it will come back to haunt you at the worst possible time".|$|E
50|$|In {{addition}} {{it offers}} <b>software</b> for design <b>debug,</b> failure analysis and yield acceleration.|$|R
50|$|LTP is {{designed}} to run directly over a data link layer (such as e.g. AOS), {{but it can also}} run on the User Datagram Protocol (UDP), e.g. if used in a sensor network, in a private network (where bandwidth contestation isn’t an issue), and for <b>software</b> <b>debug</b> purposes. Therefore, it does not address issues like routing or congestion control. It was originally designed to support “long-haul” transmission in an interplanetary network; its design is based on experiences with the CCSDS File Delivery Protocol (CFDP). LTP is commonly seen as the standard underlying convergence layer protocol for the Bundle Protocol (RFC 5050), supporting a wide selection of networks.|$|R
40|$|In {{software}} development, {{perhaps the}} most critical, yet least predicitible stage in the process is debugging. Of the many factors that come into play when <b>debugging</b> <b>software</b> applications, time is of utmost importance. The time required {{to set up and}} <b>debug</b> a <b>software</b> application can have major impacts on time-to-market, meeting customer expectations, and ultimately the financial impact of a well-developed product. This paper will explain the fundamentals of how the emulation logic and emulation tools work together with the TI digital signal processors. By understanding the fundamentals of emulation, {{you will be able to}} accelerate the process of setting up and performing <b>software</b> <b>debug,</b> as well as aid in troubleshooting potential problems in the debugging setup. A detailed explanation of the setup of the emulator hardware systems for single and multi-processor applications, along with a discussion of how the system components interact during debug will be discussed in the sections to follow. Also included is...|$|R
50|$|The DesignWare ARC AXS101 Software Development Platform is a complete, {{standalone}} platform enabling software development, code porting, <b>software</b> <b>debugging</b> {{and system}} analysis. It {{consists of an}} ARC AXC001 CPU Card mounted on an ARC Software Development Platform Mainboard. The CPU Card has an associated software package of pre-built operating systems,drivers and examples. Readily licensable DesignWare IP {{has been used to}} build the ARC Software Development Platform, giving the system a rich set of peripherals that can also be implemented in an SoC. The ARC Software Development Platform can easily be combined with the Synopsys HAPS FPGA-based Prototyping Solution to enable system prototyping and additional extension interfaces, such as five Digilent Pmod compatible connectors, support the integration of other custom and commercially available hardware extensions.|$|E
50|$|Randolph {{spent the}} dawn of the Internet age {{building}} direct-to-consumer marketing operations at software giant Borland International starting in 1988. He left Borland in 1995 for a series of short stints at Silicon Valley start-ups, including heading marketing at desktop scanner maker Visioneer, and then {{as a member of the}} founding team of Integrity QA, a developer of automated software testing products. In late 1996, <b>software</b> <b>debugging</b> company Pure Atria acquired the nine-person software startup. Pure Atria’s founder and CEO Reed Hastings retained Randolph as vice president of corporate marketing for the rapidly expanding Pure Atria. In late 1996, Pure Atria announced that Rational Software would acquire it in an $850 million stock swap in what was then the richest merger in Silicon Valley history. Hastings and Randolph commuted together between their homes in Santa Cruz, California into Silicon Valley for about four months while the Rational merger was finalized, and on these drives, the idea for Netflix was born.|$|E
40|$|Abstract- In this manuscript, we outline how to {{use test}} suites for <b>software</b> <b>debugging</b> of {{hardware}} description languages. We propose an algorithmic improvement for dealing with numerous failing test cases and show how to exploit passing test cases {{in terms of a}} technique called filtering. We report on results obtained on a well-known benchmark suite. The results clearly show that both passing and failing tests are capable of increasing the diagnoses accuracy in the field of <b>software</b> <b>debugging.</b> Model-based debugging; software debugging; debugging of hardware description languages; fault isolation. I...|$|E
40|$|Spectrum-based Fault Localization {{has emerged}} as a cost {{effective}} method to locate faulty code in <b>software</b> during the <b>debugging</b> process. Recent studies have shown that spectra (execution profiles) cloning for fail test cases can effectively improve the performance of certain spectrum-based Fault Localization ranking metrics. However, the amount of cloning required to optimize the performance varies from one program to another. This is because the structure and fault content of each program is unique. Furthermore, both insufficient cloning and excessive cloning may result in performance deterioration. In this paper, we propose an incremental spectra cloning algorithm that will clone the spectra of fail test cases up to an amount that optimizes the fault localization performance of the ranking metrics used for the <b>software</b> <b>debugged.</b> Experiments conducted on faulty versions of real life software have shown that the proposed algorithm could optimize the cost effectiveness of spectrum-based fault localization by reducing the number lines examined to locate the faulty code...|$|R
40|$|Abstract- The in-circuit {{emulator}} (ICE) is commonly adopted as a microprocessor debugging technique. In this paper, a parameterized embedded {{in-circuit emulator}} and its retargetable <b>debugging</b> <b>software</b> are proposed. The parameterized embedded in-circuit emulator {{can be integrated}} into different style processors such as microcontroller, microprocessor, and DSP processor. The GUI interface <b>debugging</b> <b>software</b> can help user to debug easily. As a result of it, the duration of microprocesso...|$|R
50|$|LURCH is a {{tool for}} <b>software</b> design <b>debugging</b> that uses a nondeterministic {{algorithm}} to quickly explore the reachable states of a software model. By performing a partial and random search, LURCH looks for faults in the model and reports the pathways leading to the faults.|$|R
40|$|This paper {{proposes a}} {{methodology}} {{for the study}} of program comprehension and debugging through the capture and analysis of rich process data. A <b>software</b> <b>debugging</b> environment with enhanced functionality is used to capture these data and a mixture of qualitative and quantitative approaches is employed to analyse them. The functionality added to the <b>software</b> <b>debugging</b> environment allows it to record the programmers ’ verbalisations, their focus of visual attention and their keyboard and mouse actions. These synchronous data are analysed to build a model that relates debugging expertise to strategy in terms of representation coordination and individual differences in representation use...|$|E
40|$|As an {{alternative}} to traditional software debuggers and hardware logic simulators, hardware/software coverification tools have been introduced in novel design processes for the embedded systems market. The main idea behind co-verification is to reduce design time by enabling an early integration of hardware and software development. However, with this approach, several new aspects on <b>software</b> <b>debugging</b> {{have been brought to}} surface. Especially when we look at verification of multithreaded applications, and multiprocessors in embedded real-time systems, the use of co-simulation has shown to be a promising method for reducing and/or eliminating the intrusiveness on run-time behaviour that is related to traditional <b>software</b> <b>debugging.</b> This paper presents the key concepts with co-simulation as adopted in two leading commercial tools. Furthermore, the use of co-simulation for verification of a real-time system is discussed. Ideas on applications that can benefit from co-simulation are also p [...] ...|$|E
40|$|This chapter {{provides}} {{a discussion of}} a fuzzy set approach {{which is used to}} extend the notion of <b>software</b> <b>debugging</b> from a 0 - 1 (perfect/imperfect) crisp approach to one which incorporates some fuzzy sets ideas. The main objective of this extension is to make current software reliability models more realistic. The theory underlying this approach, and hence its key modeling tool, is the theory of random point processes with fuzzy marks. The relevance of this theory to <b>software</b> <b>debugging</b> arises {{from the fact that it}} incorporates the randomness due to the locations of the software faults and the fuzziness bestowed by the imprecision of the debugging effort. Through several examples, we also demonstrates that this theory provides the natural vehicle for an investigation into the properties and efficacy of fuzzy debugging of software programs and is therefore a contribution to computational intelligence...|$|E
5000|$|EM250 SoC {{combines}} a radio transceiver with a 16-bit XAP2 microprocessor. It has embedded mesh networking <b>software,</b> on-chip <b>debugging,</b> 128kB of Flash and 5kB of RAM. It {{was designed for}} applications that require long battery life, low external component count, and a reliable networking solution.|$|R
5000|$|Process Hacker is a free, powerful, {{multi-purpose}} {{tool that}} helps you monitor system resources, <b>debug</b> <b>software</b> and detect malware ...|$|R
40|$|The Motor in {{a variety}} of {{electrical}} transmission and position servo system occupies an extremely important position. After the DSP technology being applied to the motor control, the unification of the hardware and the flexibility of the software can be combined. Take the brushless DC motor for example, studied the mathematical model and the structure of the motor control system, also obtained the design scheme of the DSP-based asynchronous motor control system. With TI's 32 bit fixed point DSPTMS 320 F 2812 as the core design of the hardware system, we wrote the system <b>software,</b> <b>debug</b> the motor control system and the results show that the system achieves the expected effect. The results of the research can be applied to brushless DC motor and other motor control, it will have a wide application prospects...|$|R
40|$|Program {{debugging}} is {{an extremely}} time-consuming process, and it takes up {{a large portion of}} software development time. In practice, debugging is still very much of an art, with the developer painstakingly going through volumes of execution traces to locate the actual cause of an observable error. In this work, we discuss recent advances in debugging which makes it systematic scientific activity in its own right. We explore the delicate connections between debugging and formal methods (such as model checking) in the overall task of validating software. Moreover, since any deployed software undergoes changes in its lifetime, we need debugging methods which can take the software evolution into account. We show how symbolic execution and Satisfiability Modulo Theories (SMT) solvers can be gainfully employed to greatly automate <b>software</b> <b>debugging</b> of evolving programs. Keywords: <b>Software</b> <b>Debugging,</b> Symbolic Execution...|$|E
40|$|Recent {{impressive}} performance {{improvements in}} computer architecture have not led to significant gains {{in ease of}} debugging. <b>Software</b> <b>debugging</b> often relies on inserting run-time software checks. In many cases, however, {{it is hard to}} find the root cause of a bug. Moreover, program execution typically slows down significantly, often by 10 - 100 times...|$|E
40|$|AbstractA {{considerable}} {{body of work}} on model-based <b>software</b> <b>debugging</b> (MBSD) {{has been}} published in the past decade. We summarise the underlying ideas and present the different approaches as abstractions of the concrete semantics of the programming language. We compare the model-based framework with other well-known Automated Debugging approaches and present open issues, challenges and potential future directions of MBSD...|$|E
5000|$|GDB {{integration}} — this is {{the main}} new feature of TiEmu 3. It allows calculator <b>software</b> programmers to <b>debug</b> their <b>software</b> with ease.|$|R
3000|$|... 9 This {{can make}} it hard for a {{programmer}} to debug algorithmic implementations, particularly if the programmer is unfamiliar with <b>debugging</b> <b>software</b> performing lazy evaluation.|$|R
40|$|Software Reliability {{is defined}} as the {{probability}} of free-failure operation for a specified period of time in a specified environment. Software Reliability Growth models (SRGM) have been developed to estimate software reliability measures such as number of remaining faults, software failure rate and <b>Software</b> Reliability. Imperfect <b>debugging</b> models are considered in these models. However, most SRGM assume that faults will eventually be removed. Fault removal efficiency in the existing models is limited. This paper aims to incorporate the fault removal efficiency in software reliability growth modeling. In this paper imperfect debugging is considered in the sense that new faults can be introduced into the <b>software</b> during <b>debugging</b> and the detected faults may not be removed completely...|$|R
