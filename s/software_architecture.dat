7958|2953|Public
25|$|A {{representation}} of a system, including a mapping of functionality onto hardware and software components, a mapping of the <b>software</b> <b>architecture</b> onto the hardware architecture, and human interaction with these components.|$|E
25|$|MRP {{had some}} notorious {{problems}} such as infinite capacity and fixed lead times, which influenced successive modifications of the original <b>software</b> <b>architecture</b> {{in the form of}} MRP II, enterprise resource planning (ERP) and advanced planning and scheduling (APS).|$|E
25|$|From {{this point}} on a curious {{development}} took place: while in the United States the possibility of applying the computer to business operations {{led to the development}} of management <b>software</b> <b>architecture</b> such as MRP and successive modifications, and ever more sophisticated optimization techniques and manufacturing simulation software, in post-war Japan a series of events at Toyota Motor {{led to the development of}} the Toyota Production System (TPS) and Lean Manufacturing.|$|E
3000|$|Description of SoS <b>software</b> <b>architectures</b> : Does the {{highlighted}} approach adopt some formalism {{to describe}} SoS <b>software</b> <b>architectures?</b> [...]...|$|R
40|$|Continuing {{growth and}} {{increasing}} complexity of distributed software systems make them be more flexible, adaptive and easily extensible. Dynamic evolution or reconfiguration of distributed software systems is one possible solution {{to meet these}} demands. However, there are some challenges for building dynamically evolving distributed software systems at runtime, where dynamic <b>software</b> <b>architectures</b> for them {{is one of the}} most crucial problems. In this paper, we proposed a formal method of describing and verifying dynamic <b>software</b> <b>architectures</b> for distributed systems using hypergraph grammars. We firstly gave out reconfiguration production rules and operations for <b>software</b> <b>architectures</b> based on hypergraph grammars, and then described dynamic reconfiguration of <b>software</b> <b>architectures</b> for distributed systems according to those rules. At last we verified the invariant property of dynamic <b>software</b> <b>architectures</b> for those systems using model checking, and gave out corresponding verification algorithms...|$|R
40|$|Abstract: The {{evaluation}} of <b>software</b> <b>architectures</b> {{is crucial to}} ensure that the de-sign of software systems meets the requirements. We present a generic methodical framework that enables the {{evaluation of}} component-based <b>software</b> <b>architectures.</b> It allows to determine system characteristics {{on the basis of the}} characteristics of its con-stituent components. Basic prerequisites are discussed and an overview of different architectural views is given, which can be utilised for the evaluation process. On this basis, we outline the general process of evaluating <b>software</b> <b>architectures</b> and provide a taxonomy of existing evaluation methods. To illustrate the evaluation of <b>software</b> <b>architectures</b> in practice, we present some of the methods in detail. ...|$|R
25|$|Efficiency: The {{source code}} and <b>software</b> <b>architecture</b> {{attributes}} are {{the elements that}} ensure high performance once the application is in run-time mode. Efficiency {{is especially important for}} applications in high execution speed environments such as algorithmic or transactional processing where performance and scalability are paramount. An analysis of source code efficiency and scalability provides a clear picture of the latent business risks and the harm they can cause to customer satisfaction due to response-time degradation.|$|E
25|$|The {{perceived}} {{complexity of}} programming routing functions in silicon {{led to formation}} of several startups determined {{to find new ways}} to process IP and MPLS packets entirely in hardware and blur boundaries between routing and switching. One of them, Juniper Networks, shipped their first product in 1999 and by 2000 chipped away about 30% from Cisco SP Market share. Cisco answered the challenge with homegrown ASICs and fast processing cards for GSR routers and Catalyst 6500 switches. In 2004, Cisco also started migration to new high-end hardware CRS-1 and <b>software</b> <b>architecture</b> IOS-XR.|$|E
25|$|Many {{aspects of}} {{structural}} quality can be evaluated only statically through {{the analysis of}} the software inner structure, its source code, at the unit level, the technology level and the system level, which is in effect how its architecture adheres to sound principles of <b>software</b> <b>architecture</b> outlined in a paper on the topic by OMG. But some structural qualities, such as usability, can be assessed only dynamically (users or others acting in their behalf interact with the software or, at least, some prototype or partial implementation; even the interaction with a mock version made in cardboard represents a dynamic test because such version can be considered a prototype). Other aspects, such as reliability, might involve not only the software but also the underlying hardware, therefore, it can be assessed both statically and dynamically (stress test).|$|E
40|$|International audienceThis paper {{presents}} {{a part of}} an approach for software processes reuse based on <b>software</b> <b>architectures.</b> This solution is proposed after the study of existing work on software process reuse field. Our study focuses on approaches for reusing based on <b>software</b> <b>architectures</b> and domain ontology. AoSP (<b>Architecture</b> oriented <b>Software</b> Process) approach exploits the progress of two research fields that promote reusing for the Software process reusing: Ontology and <b>software</b> <b>architectures.</b> This article details how the <b>software</b> process <b>architectures</b> are described and discusses the software process ontology conceptualization and instantiation...|$|R
40|$|Cloud-based {{software}} is often considered as providing a greener, more energy-efficient solution. At the same time, it introduces more complexity and demands for new investments in cloud services, technologies, and competencies for migration, maintenance, {{and evolution of}} the underlying <b>software</b> <b>architectures.</b> To understand better the implications of cloud <b>software</b> <b>architectures</b> on energy efficiency, {{in this paper we}} present the preliminary results of a systematic literature review that investigates what kind of <b>software</b> <b>architectures</b> for cloud service provisioning allow to achieve energy-efficient solution...|$|R
40|$|<b>Software</b> <b>architectures</b> {{that support}} dynamic coalitions of {{software}} services. New techniques for composing heterogeneous components, and certifying {{the properties of}} those compositions. <b>Software</b> <b>architectures</b> that adapting hemselves to their physical setting. Design principles for making architectural tradeoffs between correctness, resource consumption, and reliability. Self-monitoring systems...|$|R
500|$|The {{original}} design team had anticipated releasing the computer for US$3,000 in spring of 1987 {{to be ready}} for sale by summer of that year. The NeXT Computer received standing ovations when revealed at a lavish, invitation-only gala event, [...] "NeXT Introduction— the Introduction to the NeXT Generation of Computers for Education" [...] at the Louise M. Davies Symphony Hall, San Francisco, California on Wednesday October 12, 1988. The following day, selected educators and software developers were invited (for $100 registration fee) to attend the first public technical overview of the NeXT computer at an event called [...] "The NeXT Day" [...] held at the San Francisco Hilton. This event gave developers interested in developing NeXT software an insight into the <b>software</b> <b>architecture,</b> object-oriented programming and developing for the NeXT Computer. The luncheon speaker was Steve Jobs.|$|E
2500|$|PCI & PCI-X Hardware and <b>Software</b> <b>Architecture</b> & Design; 5th Ed; Ed Solari; 1140 pages; 2001; [...]|$|E
2500|$|Some of the {{research}} topics included {{on the web site}} are: Software Acquisition, <b>Software</b> <b>Architecture,</b> Agile Software Development,Software Best Practices, Collaborative Software Engineering, Configuration Management, ...|$|E
40|$|The {{needs of}} the new {{business}} models—in particular their demanding dynamicity and reliability requirements—have been fostering {{the creation of new}} open, service-oriented <b>software</b> <b>architectures.</b> Here the word “reliability ” includes security, privacy, and trust issues. Lack of trust in the new <b>software</b> <b>architectures</b> is perceived as a major risk...|$|R
50|$|TCS Innovation Lab, Delhi: <b>Software</b> <b>Architectures,</b> <b>Software</b> as a Service, natural {{language}} processing, text, data and process analytics, multimedia applications and graphics.|$|R
5000|$|WG2: Physics xTCA <b>Software</b> <b>Architectures</b> and Protocols Working Group ...|$|R
2500|$|While Cytoscape is most {{commonly}} used for biological research applications, it is agnostic in terms of usage. [...] Cytoscape {{can be used to}} visualize and analyze network graphs of any kind involving nodes and edges (e.g., social networks). A key aspect of the <b>software</b> <b>architecture</b> of Cytoscape is the use of plugins for specialized features. Plugins are developed by core developers and the greater user community.|$|E
2500|$|Prior to the ArcGIS suite, Esri {{had focused}} its {{software}} {{development on the}} command line Arc/INFO workstation program and several Graphical User Interface-based products such as the ArcView GIS 3.x desktop program. [...] Other Esri products included MapObjects, a programming library for developers, and ArcSDE as a relational database management system. [...] The various products had branched out into multiple source trees and did not integrate well with one another. [...] In January 1997, Esri decided to revamp its GIS software platform, creating a single integrated <b>software</b> <b>architecture.</b>|$|E
2500|$|Cytoscape is an {{open source}} {{bioinformatics}} software platform for visualizing molecular interaction networks and integrating with gene expression profiles and other state data. Additional features are available as plugins. Plugins are available for network and molecular profiling analyses, new layouts, additional file format support and connection with databases and searching in large networks. Plugins may be developed using the Cytoscape open Java <b>software</b> <b>architecture</b> by anyone and plugin [...] community development is encouraged. [...] Cytoscape also has a JavaScript-centric sister project named [...] {{that can be used}} to analyse and visualise graphs in JavaScript environments, like a browser.|$|E
40|$|It {{is widely}} {{accepted}} that <b>software</b> <b>architectures</b> represent non functional attributes of software systems. Yet {{we know of}} no Architectural Description Language that provides automated support for reasoning about such attributes. In this paper we discuss our ongoing research in representing and reasoning about non functional properties of <b>software</b> <b>architectures.</b> </p...|$|R
5000|$|AUTOSAR is a component-based {{reference}} <b>architecture</b> for automotive <b>software</b> <b>architectures.</b>|$|R
40|$|Architectural styles {{represent}} composition {{patterns and}} constraints at the software architectural level and are targeted at families of systems with shared characteristics. While both style-specific and style-neutral modeling environments for <b>software</b> <b>architectures</b> exist, creation of such environments is expensive and frequently involves reinventing the wheel. This paper describes the rapid {{design of a}} style-neutral architectural modeling environment, ViSAC. ViSAC is a domain-specific modeling environment obtained by configuring Vanderbilt University's Generic Modeling Environment (GME) for Alfa, a framework for constructing style-based <b>software</b> <b>architectures</b> from architectural primitives. Users can define their own styles in ViSAC and, in turn, use them to design <b>software</b> <b>architectures.</b> Moreover, ViSAC supports the hierarchical design of heterogeneous <b>software</b> <b>architectures,</b> i. e., using multiple styles. The rich user interface of GME and support for domain-specific semantics enable interactive design of well-formed styles and architectures...|$|R
2500|$|Dijkstra {{organized}} {{the design of}} the system in layers {{in order to reduce the}} overall complexity of the software. Though the term 'architecture' had not yet been used to describe software design, this was certainly considered the first glimpse of <b>software</b> <b>architecture.</b> It introduced a number of design principles which have become part of the working vocabulary of every professional programmer: levels of abstraction, programming in layers, the semaphore, and cooperating sequential processes. His original paper on the THE operating system was reprinted in the 25th Anniversary issue of Communications of the ACM, in January 1983. By way of introduction, the Editor-in-Chief says, [...] "This project initiated a long line of research in multilevel systems architecture — a line that continues to the present day because hierarchical modularity is a powerful approach to organizing large systems." ...|$|E
2500|$|In late 1999, Esri {{released}} ArcMap 8.0, {{which ran}} on the Microsoft Windows operating system. [...] ArcGIS combined the visual user-interface aspect of ArcView GIS 3.x interface {{with some of the}} power from the Arc/INFO version 7.2 workstation. This pairing resulted in a new software suite called ArcGIS including the command-line ArcInfo workstation (v8.0) and a new graphical user interface application called ArcMap (v8.0). This ArcMAP incorporating some of the functionality of ArcInfo with a more intuitive interface, as well as a file management application called ArcCatalog (v8.0). The release of the ArcMap constituted a major change in Esri's software offerings, aligning all their client and server products under one <b>software</b> <b>architecture</b> known as ArcGIS, developed using [...] Microsoft Windows COM standards. While the interface and names of ArcMap 8.0 are similar to later versions of ArcGIS Desktop, they are different products. ArcGIS 8.1 replaced ArcMap 8.0 in the product line but was not an update to it.|$|E
2500|$|Meanwhile, in the sixties, a {{different}} approach was developed by George W. Plossl and Oliver W. Wight, this approach was continued by Joseph Orlicky {{as a response to}} the TOYOTA Manufacturing Program which led to Material Requirements Planning (MRP) at IBM, latter gaining momentum in 1972 when the American Production and Inventory Control Society launched the [...] "MRP Crusade". One of the key insights of this management system was the distinction between dependent demand and independent demand. Independent demand is demand which originates outside of the production system, therefore not directly controllable, and dependent demand is demand for components of final products, therefore subject to being directly controllable by management through the bill of materials, via product design. Orlicky wrote [...] "Materials Requirement Planning" [...] in 1975, the first hard cover book on the subject. MRP II was developed by Gene Thomas at IBM, and expanded the original MRP software to include additional production functions. Enterprise resource planning (ERP) is the modern <b>software</b> <b>architecture,</b> which addresses, besides production operations, distribution, accounting, human resources and procurement.|$|E
50|$|Boehm's {{research}} interests include software development process modeling, software requirements engineering, <b>software</b> <b>architectures,</b> <b>software</b> metrics and cost models, software engineering environments, and knowledge-based software engineering.|$|R
40|$|Abstract—An {{important}} decision when developing a software agent is {{the design of}} its internal architecture. Several models of deliberative and reactive architectures have already been proposed. However, approaches of hybrid <b>software</b> <b>architectures</b> that combine deliberative and reactive components, with the advantages of both behaviors, are still an open research topic. This paper analyzes {{the state of the}} art of <b>software</b> agent <b>architectures</b> from the basic reactive and deliberative models to more advanced ones like hybrid and learning <b>software</b> <b>architectures.</b> A case study on the design of an ontology-driven hybrid and learning <b>software</b> agent <b>architecture</b> is also described...|$|R
40|$|Abstract- Enterprise {{architectures}} represent business {{objectives that}} can be extracted during requirements engineering. After gathering these objectives in form of requirements the resulting specifications must be translated into <b>software</b> <b>architectures</b> for later implementation. This transition {{has proven to be}} a non-trivial task. Even though requirements engineering and <b>software</b> <b>architectures</b> are well established areas in the software engineering domain we still lack fundamental guidelines and rules for the bridging between these two stages. This paper presents our research position by proposing a flexible and adaptive process framework to relate software requirements based on enterprise <b>architectures</b> and <b>software</b> <b>architectures...</b>|$|R
50|$|The IFIP WG 2.10 {{maintains}} the <b>software</b> <b>architecture</b> portal. The portal provides {{information about the}} working group, the <b>Software</b> <b>Architecture</b> Village wiki, and other resources on <b>software</b> <b>architecture.</b> The IFIP WG 2.10 is also active in organising the WICSA conference series.|$|E
50|$|COLA (<b>software</b> <b>architecture)</b> An {{attempt to}} produce a scalable, self-describing, self-hosting, {{extensible}} <b>software</b> <b>architecture</b> in the (conceptually) simplest way possible.|$|E
50|$|The {{purpose of}} WG 2.10 is {{to further the}} {{practice}} of <b>software</b> <b>architecture</b> by integrating <b>software</b> <b>architecture</b> research and practice.|$|E
40|$|Abstract. The paper {{presents}} {{the implementation of}} a railway control system, as a means of assessing the potential of coordination languages to be used for modelling <b>software</b> <b>architectures</b> for complex control systems using a components-based approach. Moreover, with this case study we assess and understand the issues of real time, fault tolerance, scalability, extensibility, distributed execution and adaptive behaviour, while modelling <b>software</b> <b>architectures.</b> We concentrate our study on the so-called control- or eventdriven coordination languages, and more to the point we use the language Manifold. In the process, we develop a methodology for modelling <b>software</b> <b>architectures</b> within the framework of control-oriented coordination languages...|$|R
30|$|The {{key issues}} in this paper relate to {{interoperability}} and <b>software</b> <b>architectures.</b>|$|R
40|$|Introduction — <b>Software</b> <b>architectures</b> model {{systems at}} high levels of abstraction. They capture {{information}} about a system’s components and how those components are interconnected. Some <b>software</b> <b>architectures</b> also capture information about the possible states of components and about the component behaviors that involve component interaction; behaviors and data manipulations internal to a component are typically not considered at thi...|$|R
