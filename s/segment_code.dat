3|966|Public
5000|$|... geoSmart geodemographic {{segments}} {{are produced}} from the Australian Census (Australian Bureau of Statistics) demographic measures and modeled characteristics, {{and the system}} is updated for recent household growth. The clustering creates a single <b>segment</b> <b>code</b> that is represented by a descriptive statement or a thumbnail sketch.|$|E
40|$|Code Hunt is {{a web-based}} serious gaming {{platform}} for players to solve coding duels, {{a type of}} puzzle based on programming and software engineering. In Code Hunt, a player iteratively modifies code to match the functional behavior of a secret code segment. The functional behavior is defined based on unit test cases shown as input-output pairs. To guide players to modify the code <b>segment,</b> <b>Code</b> Hunt provides feedback based on test generation through the Pex engine. In Code Hunt, the way of writing code {{is very different from}} the way in traditional software development since there are no known requirements (either informally/formally documented or existing in developers ’ mind); the game aspect in Code Hunt is es-sentially re-engineering from sample expected behaviors observed from generated test cases. Various types of context exist in Code Hunt including the duel and the test cases, as well as the player’s history and any hints that are given. In this position paper, we discuss how such context assists the players to solve coding duels while offering the players learning and fun experiences. 1. CODE HUNT Code Hun...|$|E
40|$|Within a decade, {{multicore}} processors {{emerged and}} revolutionised {{the world of}} computing. Nowadays, even a low-end computer comes with a multi-core processor and is capable running multiple threads simultaneously. It becomes impossible {{to make the best}} computation power out from a computer with a single-threaded program. Meanwhile, writing multi-threaded software is daunting to a lot of programmers as the threads share data and involve complicated synchronisation techniques such as locks and conditions. Software transactional memory is a promising alternative model that programmers simply need to understand transactional consistency and <b>segment</b> <b>code</b> into transactions. Programming becomes exciting again, without races, deadlocks and other issues that are common in lock-based paradigms. To pursue high throughput, performance-oriented computers have several multicore processors per each. A processor’s cache is not directly accessible by the cores in other processors, leading to non-uniform latency when the threads share data. These computers no longer behave like the classical symmetric multiprocessor computers. Although old programs continue to work, they do not necessary benefit from the added cores and caches. Most software transactional memory implementations fall into this category. They rely on a centralised and shared meta-variable (like logical clock) in order to provide the single-lock atomicity. On a computer with two or more multicore processors, the single and shared meta-variable gets regularly updated by different processors. This leads to a tremendous amount of cache contentions. Much time is spent on inter-processor cache invalidations rather than useful computations. Nevertheless, as computers with four processors or more are exponentially complex and expensive, people would desire solving sophisticated problems with several smaller computers whenever possible. Supporting software transactional consistency across multiple computers is a rarely explored research area. Although we have similar mature research topics such as distributed shared memory and distributed relational database, they have remarkably different characteristics so that most of the implementation techniques and tricks are not applicable to the new system. There are several existing distributed software transactional memory systems, but we feel there is much room for improvement. One crucial area is the conflict detection mechanism. Some of these systems make use of broadcast messages to commit transactions, which are certainly not scalable for large-scale clusters. Others use directories to direct messages to the relevant nodes only, but they also keep visible reader lists for invalidation per node. Updating a shared reader lists involves cache invalidations on processors. Reading shared data on such systems are more expensive compared to the conventional low-cost invisible reader validation systems. In this research, we aim to have a distributed software transactional memory system, with distributed clock validation for conflict detection purpose. As preparation, we first investigate some issues such as concurrency control and conflict detection in single-node systems. Finally, we combine the techniques with a tailor-made cache coherence protocol that is differentiated from typical distributed shared memory. published_or_final_versionComputer ScienceDoctoralDoctor of Philosoph...|$|E
40|$|Click on the DOI link below {{to access}} the article (may not be free). <b>Coding</b> <b>segments</b> are those subsegments of the {{chromosome}} that contribute positively to the fitness evaluation of the chromosome. Clique detection is a NP-complete problem {{in which we can}} detect such <b>coding</b> <b>segments.</b> We extract <b>coding</b> <b>segments</b> from chromosomes, and we investigate the duplication of <b>coding</b> <b>segments</b> inside the chromosome and the collection of <b>coding</b> <b>segments</b> outside of the chromosome. We find that duplication of <b>coding</b> <b>segments</b> inside the chromosomes provides a back-up mechanism for the search heuristics. We further find local search in a collective memory of <b>coding</b> <b>segments</b> outside of the chromosome, collective adaptation, enables the search heuristic to represent partial solutions that are larger than realistic chromosomes lengths and to express the solution outside of the chromosome. peer reviewe...|$|R
50|$|Object {{files are}} {{segmented}} into various memory segments types. Example <b>segments</b> include <b>code</b> <b>segments,</b> data segments, stack segments (.bss), or others.|$|R
30|$|Studies {{reveal that}} {{heritable}} variations do not reside in protein-coding DNA alone {{but also in}} the regulatory sequences. It is now increasingly clear that DNA <b>segments</b> <b>coding</b> for proteins account for only one aspect of heritable variations.|$|R
5000|$|Rotavirus is {{the most}} common cause of acute {{gastroenteritis}} in infants and young children worldwide. This virus contains a dsRNA genome and is a member of the Reoviridae family. The genome of rotavirus consists of eleven segments of dsRNA. Each genome <b>segment</b> <b>codes</b> for one protein with the exception of <b>segment</b> 11, which <b>codes</b> for two proteins. Among the twelve proteins, six are structural and six are non-structural proteins.It is a double-stranded RNA non-enveloped virus ...|$|R
40|$|We {{introduce}} an e#cient predictive binary shape coding {{method that}} consists of # 1 # global motion estimation, # 2 # local motion estimation, # 3 # matched <b>segment</b> <b>coding,</b> and # 4 # residual <b>segment</b> <b>coding.</b> Global and local motion estimation use contour pel matching and knowledge of previously reconstructed contours. After motion compensation, we code the one-dimensional reference contour indices of the matched contour positions. The #nal step codes the mismatched contour <b>segments</b> using residual <b>coding.</b> We use a maximum shape distortion tolerance parameter #dmax #, which is zero for lossless coding, for both motion estimation and residual coding. We apply the new shape coding method to MPEG- 4 binary mask test sequences in QCIF and SIF formats {{for a wide range}} of dmax values. The key contribution of our method is in lossy shape coding in which the average coding gain is more than 100 # over generalized di#erential chain coding. The proposed scheme can be applied to MPEG- 4 compliant shape coding and to e#cient shape representation for future MPEG- 7 applications...|$|R
50|$|The L and M segment are {{negative}} sense. For the Genera of Phlebovirus and Tospovirus, the S segment is ambisense. Ambisense means {{that some of}} the genes on the RNA strand {{are negative}} sense and others are positive sense. The S <b>segment</b> <b>codes</b> for the viral nucleoprotein (N) in the negative sense and a nonstructural (NSs) protein in ambisense.|$|R
50|$|Phleboviruses are viruses with a negative-sense RNA genome {{consisting}} of three segments. The small <b>segment</b> (S) <b>codes</b> for the viral N protein and a non structural protein, NSs via an ambisense coding strategy. The medium-sized <b>segment</b> (M) <b>codes</b> for a precursor of the viral glycoproteins and non-structural components. The {{product of the}} largest segment (L) is the viral RNA-dependent RNA polymerase.|$|R
50|$|The virus' 11.5 kb {{tripartite}} genome {{is composed}} of single-stranded RNA. As a Phlebovirus, it has an ambisense genome. Its L and M segments are negative-sense, but its S segment is ambisense. These three genome <b>segments</b> <b>code</b> for six major proteins: L protein (viral polymerase), the two glycoproteins G(N) and G(C), the nucleocapsid N protein, and the nonstructural NSs and NSm proteins.|$|R
40|$|Arenaviruses are	 feared	as	agents	 that	cause	viral	hemor-rhagic fevers. We	report	the	identification,	 isolation,	 and	ge-netic characterization	of	 2 	novel	arenaviruses	from	Namaqua rock mice	 in	Namibia. These	findings	extend	knowledge	of the distribution	and	diversity	of	arenaviruses	in	Africa. Arenaviruses {{are known}} to cause severe hemorrhagic fevers across the globe with case {{fatality}} rates up to 30 % (1). The viruses possess a bisegmented, single-strand-ed RNA genome with ambisense coding strategy consist-ing of a small <b>segment</b> <b>coding</b> for the nucleoprotein and glycoprotein and a large (L) <b>segment</b> <b>coding</b> for the RNA-dependent RNA polymerase and matrix protein. In Africa, Lassa virus (LASV) and Lujo virus are the only known {{members of the family}} Arenaviridae that cause human disease (2, 3); however, evidence for lymphocytic choriomeningitis virus, another Arenaviridae sp., was re-cently reported in Gabon (4). Several other arenaviruses of unknown pathogenic potential have also been found in Af-rica: Gbagroube, Kodoko, and Menekre viruses from west...|$|R
5000|$|... #Caption: Fig. 1 Memory {{segments}} in a program. Blue <b>segments</b> are <b>code,</b> green are data.|$|R
40|$|The S 1 genome {{segment of}} {{reovirus}} {{is linked to}} type specificity as determined by neutralization antibody. This gene <b>segment</b> <b>codes</b> for a minor outer capsid polypeptide (sigma 1). Therefore, sigma 1 is the peptide responsible for induction of neutralization antibody and confers type specificity. This biologic property of reovirus was defined using hybrid recombinants clones between reovirus types 1 and 3 and 2 and 3...|$|R
40|$|Methods and {{apparatuses}} {{are provided}} for automatically optimizing application program code for minimized access to privacy data. A privacy-oriented code optimizing module process and/or facilitate a processing {{one or more}} <b>code</b> <b>segments,</b> one or more execution logs associated with {{the one or more}} <b>code</b> <b>segments,</b> or a combination thereof to determine at least one privacy intrusion signature associated with the one or more <b>code</b> <b>segments.</b> Further, the privacy-oriented code optimizing module determines one or more recommendations for one or more alternate <b>code</b> <b>segments</b> based, at least in part, on the at least one privacy intrusion signature...|$|R
40|$|Biochemical mapping {{experiments}} of the simian rotavirus SA 11 genome {{were performed}} to determine which double-stranded RNA <b>segment</b> <b>coded</b> {{for each of the}} viral polypeptides. Viral RNA transcripts were synthesized in vitro by using the endogenous viral RNA polymerase and fractionated by electrophoresis in acid-urea agarose gels. The fractionated transcripts were translated in two cell-free systems: micrococcal nuclease-treated reticulocyte lysates and wheat germ extracts. The polypeptide products were identified by polyacrylamide gel electrophoresis and partial peptide analysis and compared with polypeptides synthesized in infected cells or found in purified virus. The RNA <b>segment</b> that <b>coded</b> for each transcript was determined by hybridization of the fractionated transcripts to the double-stranded RNA genome and analysis of the hybrids by electrophoresis in polyacrylamide gels. Primary gene products were assigned for 10 of the rotavirus transcripts and 10 of the double-stranded RNA <b>segments.</b> The <b>coding</b> assignments are as follows: the inner-capsid polypeptides, VP 1, VP 2, and VP 6, were assigned to segments 1, 2, and 6, respectively; the major outer-capsid polypeptides, VP 3 and VP 7, were assigned to segments 4 and 9, respectively; segments 5, 7, and 8 coded for nonstructural polypeptides with molecular weights of 53, 000, 34, 000, and 35, 000, respectively; <b>segment</b> 10 <b>coded</b> for the 20, 000 -molecular-weight precursor to the 29, 000 -molecular-weight glycosylated nonstructural polypeptide; and <b>segment</b> 11 <b>coded</b> for a 26, 000 -molecular-weight polypeptide that may be the precursor to the minor outer-capsid polypeptide VP 9. Several methods were used to determine the product of gene segment 3, and the problems associated with the identification of this gene product are discussed...|$|R
40|$|Improved {{fractionation}} of double-stranded RNA segments 7, 8, and 9 of simian rotavirus SA 11 has permitted their {{isolation and}} individual translation in vitro. <b>Segment</b> 7 <b>codes</b> for p 31 (NS 2), <b>segment</b> 8 <b>codes</b> for p 33 (NS 1), and the segment 9 gene product resembles the gp 34 precursor observed in SA 11 virus-infected cells. In vitro glycosylation of translation products of segments 5 and 10 was also observed...|$|R
40|$|The DNA coding for histone proteins, {{together}} with the intervening spacer DNA, has been isolated from the sea urchin, Psammechinus miliaris, by repeated centrifugation on CsCl-asctinomycin gradients. The biophysical data show that {{a major portion of}} the spacer is 37 % G+C and very divergent in sequence, while the DNA <b>segments</b> <b>coding</b> for histone proteins are high in G+C and have diverged to a lesser extent within the species...|$|R
40|$|During {{software}} development {{various forms of}} software documentation can be produced to make the software easier to understand and maintain after the software have been developed. One of these forms of software documentation is code comments, which {{is a form of}} software documentation that is produced to make source code easier to read and maintain. Although code comments make the code easier to read and maintain, code comments can become outdated and inconsistent with their corresponding code. Outdated and inconsistent code comments increase the probability for future bugs and when these comments are encountered, developers could lose the confidence for all other comments. In order {{to reduce the amount of}} outdated and inconsistent code comments, a program named the comment validator is presented in this study. The comment validator provides developers with the opportunity to manually validate <b>code</b> comments by <b>segmenting</b> <b>code</b> into three <b>segments</b> of <b>code</b> that needs to be manually validated: classes, methods and properties. The comment validator identifies when <b>code</b> <b>segments</b> have been modified after validation, therefore indicating that the <b>code</b> <b>segments</b> corresponding <b>code</b> comments could be outdated and inconsistent. The comment validator were evaluated through functional testing and through a field study in order to test that the comment validator could reduce the amount of outdated and inconsistent code comments. The evaluation showed that the comment validator did remove outdated and inconsistent code comments when it were used according to the description presented in this study, therefore providing a new way to reduce the amount of outdated and inconsistent code comments in {{software development}} projects...|$|R
2500|$|The entire Influenza A {{virus genome}} is 13,588 bases long and is {{contained}} on eight RNA <b>segments</b> that <b>code</b> for 11 proteins: ...|$|R
50|$|Viruses in Partitiviridae are non-enveloped, with {{icosahedral}} geometries, and T=1 symmetry. The diameter {{is around}} 35-40 nm. Partitiviruses have double stranded RNA genomes {{divided into two}} genomic segments {{and there may be}} additional subgenomic segments. The genome segments are packaged in the same virus particle, the larger <b>segment</b> <b>codes</b> for the RNA-dependent RNA polymerase and the smaller codes for the coat protein. Genomes are linear and around 1.4-3.0kb in length. The genome codes for 2 proteins.|$|R
40|$|Real time systems, used {{in most of}} {{the day-to-day}} applications, require time {{critical}} exection of tasks. Worst Case Execution Time Analysis (WCET) is performed to ensure the upper bound on the time they can take to execute. This work aims to perform a static analysis of the industry standard <b>code</b> <b>segments</b> to provide valuable information to aid in choosing the right apporach towards WCET analysis. Any <b>code</b> <b>segment</b> can be analyzed syntactically, to gain some insights to the effects that a particular coding syntax format may have. With focus on the functions and looping statements, vaulable information regarding the <b>code</b> <b>segments</b> inspected can be obtained. For this purpose, the <b>code</b> <b>segments</b> from CC systems, Vasteras, were inspected. Scope graphs generated by SWEET, the Swedish Execution Time tool were used extensively to aid this work. It was found that syntactical analysis could be performed effectively for the <b>code</b> <b>segments</b> that were analysed as a part of this task...|$|R
40|$|Efficient {{performance}} tuning of parallel programs is often hard. Optimization is often done {{when the program}} is written as a last effort to increase the performance. With sequential programs each (executed) <b>code</b> <b>segment</b> will affect the total execution time of the program. Thus, any <b>code</b> <b>segment</b> that is optimized in a sequential program will decrease the execution time. In {{the case of a}} parallel program executed on a multiprocessor this is not always true. This is due to dependencies between the different threads. As a result, certain <b>code</b> <b>segments</b> of the execution may not affect the total execution time of the program. Thus, optimization of such <b>code</b> <b>segments</b> will not increase the performance. In this paper we present a new approach to perform the optimization phase. Our approach finds the critical path of the multithreaded program and the optimization is only done on those specific <b>code</b> <b>segments</b> of the program. We have implemented the critical path analysis in a performance optimization tool. 1...|$|R
40|$|Research {{into the}} utility of non [...] <b>coding</b> <b>segments,</b> or introns, in genetic [...] based {{encodings}} has shown that they expedite the evolution of solutions in domains by protecting building blocks against destructive crossover. We consider a genetic programming system where non [...] <b>coding</b> <b>segments</b> can be removed, and the resultant chromosomes returned into the population. This parsimonious repair leads to premature convergence, since as we remove the naturally occurring non [...] <b>coding</b> <b>segments,</b> we strip away their protective backup feature. We then duplicate the <b>coding</b> <b>segments</b> in the repaired chromosomes, and place the modified chromosomes into the population. The duplication method significantly improves the learning rate in the domain we have considered. We also show that this method {{can be applied to}} other domains. 1 Introduction Researchers in both genetic algorithms (GA) and genetic programming (GP) have recently begun to examine {{the utility of}} non [...] <b>coding</b> <b>segments</b> 1 in chromosomes [2, 5, 10 [...] ...|$|R
40|$|This paper {{presents}} a systematic technique for generat-ing new instruction sets which are optimized {{for a given}} mi-croarchitecture and set of benchmark programs. This pro-cess consists of the following steps: generation of execution traces, formation of <b>code</b> <b>segments,</b> optimal recompilation of the <b>code</b> <b>segments</b> to produce candidate instructions, and covering of the instructions from the <b>code</b> <b>segments</b> to yield the final instruction set. To illustrate {{the use of the}} new technique, an instruction set is generated for the execution of compiled Prolog programs. ...|$|R
5000|$|Deletion of {{the long}} arm of {{chromosome}} 13 (del 13q) {{is the most common}} abnormality in CLL with roughly 50% of patients with cells containing this defect. These patients have the best prognosis and most live many years, even decades, without the need for therapy. The gene targeted by this deletion is a <b>segment</b> <b>coding</b> for microRNAs miR-15a and miR-16-1. Studies have found the miR-15a/16-1 microRNA cluster to function as a tumour suppressor, with the oncogene BCL2 as its target.|$|R
40|$|This article {{focus on}} the exist problem and status of current time <b>segment</b> <b>coding,</b> {{proposed}} {{a new set of}} approach about time segment coding: multi-scale time <b>segment</b> integer <b>coding</b> (MTSIC). This approach utilized the tree structure and the sort by size formed among integer, it reflected the relationship among the multi-scale time segments: order, include/contained, intersection, etc., and finally achieved an unity integer coding processing for multi-scale time. On this foundation, this research also studied the computing method for calculating the time relationships of MTSIC, to support an efficient calculation and query based on the time segment, and preliminary discussed the application method and prospect of MTSIC. The test indicated that, the implement of MTSIC is convenient and reliable, and the transformation between it and the traditional method is convenient, it has the very high efficiency in query and calculating...|$|R
40|$|This paper {{proposes a}} {{procedure}} for minimizing the code size of sequential programs for reactive systems. It identifies repeated <b>code</b> <b>segments</b> (a generalization of basic blocks to directed rooted trees) {{and finds a}} minimal covering of the input control flow graphs with <b>code</b> <b>segments.</b> The segments are disjunct, i. e. no two segments have the same code in common. The program is minimal {{in the sense that}} the number of <b>code</b> <b>segments</b> is minimum under the property of disjunction for the given control flow specification. The procedur...|$|R
5000|$|Heavy chain {{contains}} similar gene segments such as VH, JH and CH, {{but also}} has another gene segment called D (diversity). Unlike the light chain multigene family, VDJ gene <b>segments</b> <b>code</b> for the variable region of the heavy chain. The rearrangement and reorganization of gene segments in this multigene family is more complex [...] The rearranging and joining of segments produced different end products because these are carried out by different RNA processes. The same reason is why the IgM and IgG are generates at the time.|$|R
40|$|The {{purpose of}} {{software}} partitioning is to assign <b>code</b> <b>segments</b> {{of a given}} computer program {{to a range of}} execution locations such as general purpose processors or specialist hardware components. These execution locations differ in speed, communication characteristics, and in size. In particular, hardware components offering high speed tend to accommodate only few <b>code</b> <b>segments.</b> The goal of software partitioning is to find an assignment of <b>code</b> <b>segments</b> to execution locations that minimizes the overall program run time and respects the size constraints. In this paper we demonstrate that an additional speedup is obtained if we allow <b>code</b> <b>segments</b> to be instantiated on more than one location. We further show that the program run time not only depends on the execution frequency of the <b>code</b> <b>segments</b> but also on their execution order if there are multiply instantiated <b>code</b> <b>segments.</b> Unlike frequency information, however, sequence information is not available at the time when the software partition is selected. This motivates us to formulate the software partitioning problem as a robust optimization problem with decision-dependent uncertainty. We transform this problem to a mixed-integer linear program of moderate size and report on promising numerical results. Key words: robust optimization; software partitioning; decision-dependent uncertainty; multiple instance partitioning 1...|$|R
40|$|A mouse {{complementary}} {{deoxyribonucleic acid}} <b>segment</b> <b>coding</b> for the enzyme dihydrofolate reductase has been cloned in two general classes of vectors containing simian virus 40 deoxyribonucleic acid: (i) {{those that can}} be propagated as virions in permissive cells and (ii) those that can be introduced into and maintained stably in various mammalian cells. Both types of vectors express the mouse dihydrofolate reductase by using signals supplied by simian virus 40 deoxyribonucleic acid sequences. Moreover, plasmid vectors carrying the complementary deoxyribonucleic acid segment can complement Chinese hamster ovary cells lacking dihydrofolate reductase...|$|R
40|$|The {{regulatory}} {{region of}} the tetracycline resistance determinant from transposon TnlO {{has been used to}} construct plasmid vectors for gene expression regulated by tetracycline. Plasmids pRS tetBam- 8 and pRS tetBam- 16 include the tet regulatory region, the <b>segment</b> <b>coding</b> for the first four amino acids of the tetracycline resistance protein (tetA protein), and a linker region with SalI, HpaII, and BamHI restriction sites for gene fusions. Plasmid pTB- 1, a derivative of pRS tetBam- 8 and of the p-galactosidase gene-containing plasmid pMC 1403, constitutively ex-presses a tet...|$|R
50|$|The <b>code</b> <b>segment</b> {{in memory}} is {{typically}} read-only {{and has a}} fixed size, so on embedded systems it can usually be placed in read-only memory (ROM), {{without the need for}} loading. If the <b>code</b> <b>segment</b> is not read-only, then the particular architecture allows self-modifying code. Fixed-position or position independent code may be shared in memory by several processes in segmented or paged memory systems. As a memory region, the <b>code</b> <b>segment</b> may be placed below the heap or stack in order to prevent heap and stack overflows from overwriting it.|$|R
5000|$|Version 4.0 {{added support}} for 286 {{instructions}} and also shorthand mnemonics for <b>segment</b> descriptors (.<b>code,</b> [...]data, etc.). Version 5.0 supported 386 instructions, but could still only generate real mode executables.|$|R
5000|$|Snippets {{that allow}} {{developers}} to share <b>code</b> <b>segments</b> or files ...|$|R
5000|$|In X86-64, the <b>code</b> <b>segment</b> {{descriptor}} has {{the following}} form: ...|$|R
