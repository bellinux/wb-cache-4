67|147|Public
25|$|Writing data {{past the}} end of {{allocated}} memory can sometimes be detected by the operating system to generate a <b>segmentation</b> <b>fault</b> error that terminates the process.|$|E
25|$|The MMU {{may also}} {{generate}} illegal access error conditions or invalid page faults upon illegal or non-existing memory accesses, respectively, leading to <b>segmentation</b> <b>fault</b> or bus error conditions when {{handled by the}} operating system.|$|E
2500|$|Buffer {{overflow}} {{protection is}} used to detect the most common buffer overflows by checking that the stack has not been altered when a function returns. [...] If it has been altered, the program exits with a <b>segmentation</b> <b>fault.</b> Three such systems are Libsafe, and the StackGuard and ProPolice gcc patches.|$|E
50|$|Some Ryzen {{processors}} produce <b>segmentation</b> <b>faults</b> {{on certain}} workloads on Linux.|$|R
50|$|The {{improper}} use of dynamic memory allocation can frequently {{be a source}} of bugs. These can include security bugs or program crashes, most often due to <b>segmentation</b> <b>faults.</b>|$|R
50|$|Newer {{programming}} languages may employ mechanisms {{designed to}} avoid <b>segmentation</b> <b>faults</b> and improve memory safety. For example, the Rust programming language employs an 'Ownership' based model to ensure memory safety.|$|R
50|$|In {{systems such}} as Unix and Linux, the errors are {{reported}} separately (e.g. <b>segmentation</b> <b>fault</b> for memory errors).|$|E
50|$|On systems using {{hardware}} memory segmentation {{to provide}} virtual memory, a <b>segmentation</b> <b>fault</b> {{occurs when the}} hardware detects an attempt {{to refer to a}} non-existent segment, or to refer to a location outside the bounds of a segment, or to refer to a location in a fashion not allowed by the permissions granted for that segment. On systems using only paging, an invalid page fault generally leads to a <b>segmentation</b> <b>fault,</b> and segmentation faults and page faults are both faults raised by the virtual memory management system. Segmentation faults can also occur independently of page faults: illegal access to a valid page is a <b>segmentation</b> <b>fault,</b> but not an invalid page fault, and segmentation faults can occur {{in the middle of a}} page (hence no page fault), for example in a buffer overflow that stays within a page but illegally overwrites memory.|$|E
5000|$|Here, [...] may {{point to}} {{anywhere}} in memory, so performing the assignment [...] can corrupt an unknown area of memory or trigger a <b>segmentation</b> <b>fault.</b>|$|E
40|$|This release {{does the}} following: Address issue # 19 re: {{documentation}} Fix issue # 20, {{which was a}} minor bug {{that could lead to}} rare <b>segmentation</b> <b>faults.</b> Please that the fix means that simulation results will occasionally be different. Update the copying/license files to contain the full GPLv 2 text. fwdpp is still licensed as GPL >= v 2...|$|R
30|$|In this study, we {{show that}} gravity {{analysis}} enables {{the determination of the}} features, continuity, <b>segmentation,</b> <b>faulting</b> type and dipping direction of an active fault zone which occur as a result of large earthquakes. The gravity data used in this study were obtained prior to the Kumamoto earthquake. We emphasize that an effective use of gravity anomalies can enhance the understanding of active faults.|$|R
50|$|In computing, a {{bus error}} is a fault raised by hardware, notifying an {{operating}} system (OS) that a process {{is trying to}} access memory that the CPU cannot physically address: an invalid address for the address bus, hence the name. In modern use on most architectures these are much rarer than <b>segmentation</b> <b>faults,</b> which occur primarily due to memory access violations: problems in the logical address or permissions.|$|R
5000|$|... {{attempting}} {{to read or}} write memory that is not allocated for reading or writing by that application (<b>segmentation</b> <b>fault)</b> or x86 specific (general protection fault) ...|$|E
5000|$|The SIGSEGV {{signal is}} sent to a process when it makes an invalid virtual memory reference, or <b>segmentation</b> <b>fault,</b> i.e. when it {{performs}} a segmentation violation.|$|E
50|$|Dereferencing a {{null pointer}} in C {{produces}} undefined behavior, {{which could be}} catastrophic. However, most implementations simply halt execution {{of the program in}} question, usually with a <b>segmentation</b> <b>fault.</b>|$|E
5000|$|Due to its {{unconstrained}} expressiveness, {{low level}} C++ language features (e.g. unchecked array access, raw pointers, type punning) cannot be reliably checked at compile-time or without overhead at run-time. Related programming errors {{can lead to}} low-level buffer overflows and <b>segmentation</b> <b>faults.</b> The Standard Template Library provides higher-level RAII abstractions (like vector, list and map) to help avoid such errors. In Java, low level errors either cannot occur or are detected by the Java virtual machine (JVM) and reported to the application {{in the form of}} an exception.|$|R
50|$|<b>Segmentation</b> <b>faults</b> are {{a common}} class of error in {{programs}} written in languages like C that provide low-level memory access. They arise primarily due to errors in use of pointers for virtual memory addressing, particularly illegal access. Another type of memory access error is a bus error, which also has various causes, but is today much rarer; these occur primarily due to incorrect physical memory addressing, or due to misaligned memory access - these are memory references that the hardware cannot address, rather than references that a process {{is not allowed to}} address.|$|R
5000|$|Writing P/Invoke {{wrappers}} can {{be difficult}} and error prone. Using native DLLs means that the programmer can no longer benefit from type safety and garbage collection as is usually provided in the [...]NET environment. When they are used improperly this may cause problems such as <b>segmentation</b> <b>faults</b> or memory leaks. Getting the exact signatures of the legacy functions {{for use in the}} [...]NET environment can be hard, which can result in such problems. For this purpose tools and websites exist to obtain such signatures, helping to prevent signature problems. http://www.pinvoke.net/ ...|$|R
50|$|This {{sample code}} creates a null pointer, and then tries to access its value (read the value). Doing so causes a <b>segmentation</b> <b>fault</b> at runtime on many {{operating}} systems.|$|E
5000|$|A <b>segmentation</b> <b>fault</b> {{results when}} a program tries to access memory {{that it does}} not have {{permission}} to access. Generally a program doing so will be terminated by the operating system.|$|E
50|$|The MMU {{may also}} {{generate}} illegal access error conditions or invalid page faults upon illegal or non-existing memory accesses, respectively, leading to <b>segmentation</b> <b>fault</b> or bus error conditions when {{handled by the}} operating system.|$|E
40|$|Python {{interface}} to the Xenon middleware library. Xenon {{provides a}} simple programming interface to various pieces of software {{that can be}} used to access distributed compute and storage resources. It is primarily made to start jobs on clusters and supercomputers. Xenon is a Java library, so pyxenon uses JPype to interface with a Java Virtual Machine. Changes since version 0. 2. 2 : 	Wraps all java classes and package in a JavaClass and JavaPackage wrapper, to avoid <b>segmentation</b> <b>faults</b> and allow importing classes from Xenon directly. 	added __version__ attribute. 	Removed references to jpypes internal data structures. 	README to reStructuredText 	Switched to pytest testing with tox and added a. coveragerc file...|$|R
3000|$|... i, which {{corresponds}} to a geological boundary. The aftershock distribution and geodetic observations suggest that a spatial extent of the source fault is controlled by this boundary. Gravity analysis is a useful method to evaluate the continuity, <b>segmentation</b> and <b>faulting</b> type of active fault zones.|$|R
40|$|Algorithms in {{computational}} geometry are usually designed under the Real RAM model. In implementing these algorithms, however, fixed-precision arithmetic {{is used in}} place of exact arithmetic. This substitution introduces numerical errors in the computations {{that may lead to}} nonrobust behaviour in the implementation, such as infinite loops or <b>segmentation</b> <b>faults.</b> There are various approaches in the the literature addressing the problem of nonrobustness in geometric computations; see [1] for a survey. These approaches can be classified along two lines: the arithmetic approach and the geometric approach. The arithmetic approach tries to address nonrobustness in geometric algorithms by handling the numerical errors arising because of fixed-precision arithmetic; this can be done, for instance, by using multi-precision arithmetic [2], or by using rational arithmetic whenever possible. In general...|$|R
5000|$|The {{following}} code {{includes a}} null pointer dereference, but when compiled will often {{not result in}} a <b>segmentation</b> <b>fault,</b> as the value is unused and thus the dereference will often be optimized away by dead code elimination:int *ptr = NULL;*ptr; ...|$|E
5000|$|Protection against {{infinite}} recursion: Php has a documented {{behavior of}} yielding a <b>segmentation</b> <b>fault</b> error upon infinite recursion. Since {{this is a}} memory-safety issue, Suhosin will make the application gracefully exit once a maximum level of recursion has been met.|$|E
50|$|None, {{runs the}} code {{in the virtual}} machine without {{performing}} any analysis and thus has the smallest possible CPU and memory overhead of all tools. Since valgrind itself provides a trace back from a <b>segmentation</b> <b>fault,</b> the none tool provides this traceback at minimal overhead.|$|E
40|$|Intel’s Software Guard Extensions (SGX) {{provide a}} new {{hardware-based}} trusted execution environment on Intel CPUs using secure enclaves that are resilient to accesses by privileged code and physical attackers. Originally designed for securing small services, SGX bears promise to protect complex, possibly cloud-hosted, legacy applications. In this paper, {{we show that}} previously considered harmless synchronisation bugs can turn into severe security vulnerabilities when using SGX. By exploiting use-after-free and time-of-check-to-time-of-use (TOCTTOU) bugs in enclave code, an attacker can hijack its control flow or bypass access control. We present AsyncShock, a tool for exploiting synchronisation bugs of multithreaded code running under SGX. AsyncShock achieves this by only manipulating the scheduling of threads {{that are used to}} execute enclave code. It allows an attacker to interrupt threads by forcing <b>segmentation</b> <b>faults</b> on enclave pages. Our evaluation using two types of Intel Skylake CPUs shows that AsyncShock can reliably exploit use-after-free and TOCTTOU bugs...|$|R
5000|$|Beroza, G. C. (2003). <b>Fault</b> <b>segmentation</b> and {{possible}} pore fluid {{effects in the}} 1992 Landers, California aftershock sequence. Stanford, CA: Dept. of Geophysics, Stanford University. OCLC 57190036 ...|$|R
40|$|Verification of multi-threaded C++ {{programs}} poses {{three major}} challenges: {{the large number}} of states, states with huge sizes, and time intensive expansions of states. This paper presents our efforts in addressing these issues by combining an efficient use of hard disk with the distribution of the state space on several computing nodes. The approach is applicable to clusters and multi-core machines with single or multiple hard disks. We exploit the concept of a signature of a state that allows the full state vector to stay on secondary memory. For a distributed exploration of the state space, we report the lessons learned from using different partitioning schemes, including Holzmann and Bosnacki’s [21] depth-slicing method, and their effects on blind and directed search algorithms. Empirical evaluation is done on our experimental C++ verification tool StEAM, which is capable of detecting errors such as <b>segmentation</b> <b>faults,</b> deadlocks, access conflicts, etc. The distributed algorithms are realized through MPI on a cluster of workstations...|$|R
50|$|Writing to {{read-only}} memory raises a <b>segmentation</b> <b>fault.</b> At {{the level of}} code errors, this occurs when the program writes to part of its own code segment or the read-only portion of the data segment, as these are loaded by the OS into {{read-only memory}}.|$|E
50|$|Buffer {{overflow}} {{protection is}} used to detect the most common buffer overflows by checking that the stack has not been altered when a function returns. If it has been altered, the program exits with a <b>segmentation</b> <b>fault.</b> Three such systems are Libsafe, and the StackGuard and ProPolice gcc patches.|$|E
50|$|In both cases, Electric Fence {{causes the}} errant program to abort {{immediately}} via a <b>segmentation</b> <b>fault.</b> Normally, these two errors would cause heap corruption, which would manifest itself only much later, usually in unrelated ways. Thus, Electric Fence helps programmers find the precise location of memory programming errors.|$|E
40|$|This paper {{describes}} a new working {{implementation of the}} Python language; built {{on top of the}} Java language and run-time environment. This is in contrast to the existing implementation of Python, which has been built on top of the C language and run-time environment. Implementing Python in Java has a number of limitations when compared to the current implementation of Python in C. These include about 1. 7 X slower performance, portability limited by Java VM availability, and lack of compatibility with existing C extension modules. The advantages of Java over C as an implementation language include portability of binary executables, object -orientation in the implementation language to match object-orientation in Python, true garbage collection, run-time exceptions instead of <b>segmentation</b> <b>faults,</b> and the ability to automatically generate wrapper code for arbitrary Java libraries. 1. Why Java? The current implementation of Python in C is a fairly large and complicated software system. Do [...] ...|$|R
5000|$|How {{does the}} {{three-dimensional}} structure of mid-ocean ridges, and especially their <b>segmentation</b> by transform <b>faults</b> and similar features, {{relate to the}} physical properties and dynamics of the underlying Earth’s mantle? ...|$|R
3000|$|We {{implemented}} each module as a function, {{and each}} function has a specific soft deadline {{to be executed}} depending on its task. As {{a result of our}} monolithic programming model, all the functions are contained within a single main process. This process uses a sleep-and-run approach. At the beginning of each cycle, the main process checks for pending incoming packets, and puts them into the appropriate packet handler queues. Then, the main process passes the control to modules with due deadlines. As we cooperate with the NCTUns simulation engine, we need to relinquish the control to it periodically. This is accomplished by sleeping for a pre-defined amount of time after the execution of any pending module is completed. Initially, we used the sleep (...) function as it was encouraged in the documentation of the NCTUns simulation tool. Unfortunately, we experienced several problems such as <b>segmentation</b> <b>faults,</b> unexpected hang of application and/or simulation. Consequently to solve these problems, we needed to replace the sleep (...) function with the usleepAndReleaseCPU (...) function. Algorithm 4 show pseudo code the main process.|$|R
