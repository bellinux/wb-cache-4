10|245|Public
30|$|For the {{remainder}} of this article, we define by c a comment submitted to an online discussion. For the purposes of this work, we assume that each comment is composed only of its textual content and its timestamp, which is used as a <b>sorting</b> <b>key.</b> Thus, a comment sequence C is an ordered set of n comments c 1,c 2,…,cn taken from a common context, for example, all comments of a given YouTube video.|$|E
40|$|Abstract. Hypothesis {{tests have}} been used in the past as a tool in a cryptanalytic context. In this paper, we propose to use this {{paradigm}} and define a precise and sound statistical framework in order to optimally mix information on independent attacked subkey bits obtained from any kind of statistical cryptanalysis. In the context of linear cryptanalysis, we prove that the best mixing paradigm consists of <b>sorting</b> <b>key</b> candidates by decreasing weighted Euclidean norm of the bias vector. Keywords: Key ranking, statistical cryptanalysis, Neyman-Pearson lemma, linear cryptanalysis...|$|E
40|$|This paper {{analyzes}} {{the variation in}} expected monthly stock returns for a large cross-section of U. K. companies. Using company attributes as a <b>sorting</b> <b>key,</b> the authors we form portfolios and study their returns relative to the return on the market index. They find that book to market value, {{and to a lesser}} extent company size and liquidity, are the only company attributes that appear to contain information about variation in expected returns. The authors consider whether excess returns on their portfolios reflect risk premia or market inefficiency. Copyright 1996 by The London School of Economics and Political Science. ...|$|E
50|$|A new <b>sort</b> <b>key</b> can {{be created}} from two or more <b>sort</b> <b>keys</b> by {{lexicographical}} order. The first is then called the primary <b>sort</b> <b>key,</b> the second the secondary <b>sort</b> <b>key,</b> etc.|$|R
50|$|If the <b>sort</b> <b>key</b> {{values are}} totally ordered, the <b>sort</b> <b>key</b> defines a weak {{order of the}} items: items with the same <b>sort</b> <b>key</b> are {{equivalent}} with respect to sorting. See also stable sorting. If different items have different <b>sort</b> <b>key</b> values then this defines a unique order of the items.|$|R
50|$|For example, {{addresses}} {{could be}} sorted using {{the city as}} primary <b>sort</b> <b>key,</b> and the street as secondary <b>sort</b> <b>key.</b>|$|R
40|$|EVENT related {{potentials}} (ERP) {{were recorded}} from 29 electrode positions in 10 normal subjects while they performed a simplified {{version of the}} Wisconsin Card Sorting Test (WCST). The design focused on ERP differences between early and late trials within each WCST series. Topographic and dipole analyses confirmed the reliability of two ERP signs: one conspicuous mid-parietal P 3 b wave and one asymmetrical frontal-temporal component. A three-dipole model accounted for these ERP signs with> 90 % accuracy even in individual subjects, and suggests a sub-second activation of temporal-parietal and medial temporal association areas during card sorting. The WCST-related P 3 b wave is proposed to reflect working memory operations such as template matching and template formation during card <b>sorting.</b> <b>Key</b> word s: BESA; Event-related potentials; Frontal lobes; Wisconsin Card Sorting Test (WCST); Working memor...|$|E
40|$|Efficient sorting {{is a key}} {{requirement}} for many computer science algorithms. Acceleration of existing techniques as well as developing new sorting approaches is crucial for many realtime graphics scenarios, database systems, and numerical simulations {{to name just a}} few. It {{is one of the most}} fundamental operations to organize and filter the ever growing massive amounts of data gathered on a daily basis. While optimal sorting models for serial execution on a single processor exist, efficient parallel sorting remains a challenge. In this paper we present a hardware-optimized parallel implementation of the radix sort algorithm that results in a significant speed up over existing sorting implementations. We outperform all known GPU based sorting systems by about a factor of two and eliminate restrictions on the <b>sorting</b> <b>key</b> space. This makes our algorithm not only the fastest, but also the first general GPU sorting solution...|$|E
40|$|The {{exploitation}} of data locality in parallel computers is paramount {{to reduce the}} memory traffic and communication among processing nodes. We focus on the {{exploitation of}} locality by Parallel Radix sort. The original Parallel Radix sort has several communication steps in which one <b>sorting</b> <b>key</b> may have to visit several processing nodes. In response to this, we propose a reorganization of Radix sort {{that leads to a}} highly local version of the algorithm at a very low cost. As a key feature, our algorithm performs one only communication step, forcing keys to move at most once between processing nodes. Also, our algorithm reduces the amount of data communicated. Finally, the new algorithm achieves a good load balance which makes it insensitive to skewed data distributions. We call the new version of Parallel Radix sort that combines locality and load balance, Communication and Cache Conscious Radix sort (C 3 -Radix sort). Our results on 16 processors of the SGI O 2000 show that C 3 -R [...] ...|$|E
5000|$|... "Da#" [...] - Tale {{number as}} appears in Dasent's translation, usable as <b>sort</b> <b>key.</b>|$|R
50|$|In Unix-like {{operating}} systems, sort is {{a standard}} command line program that prints the lines of its input or concatenation of all files listed in its argument list in sorted order. Sorting is done based on one or more <b>sort</b> <b>keys</b> extracted from each line of input. By default, the entire input is taken as <b>sort</b> <b>key.</b> Blank space is the default field separator.|$|R
2500|$|Thorup's algorithm, a {{randomized}} algorithm for <b>sorting</b> <b>keys</b> from a domain of finite size, taking [...] time and O(n) space.|$|R
40|$|SUMMARY The {{generalized}} sorting {{problem is}} to find the first k largest elements among n input elements and to report them in a sorted order. In this paper, we propose a fast generalized sorting algorithm under the single hop wireless networks model with collision detection (WNCD). The algorithm is based on the maximum finding algorithm and the sorting algorithm. The key point of our algorithm is to use successful broadcasts to build broadcasting layers logically and then to distribute the data elements into those logic layers properly. Thus, the number of broadcast conflicts is reduced. We prove that the average time complexity required for our generalized sorting algorithm is Θ � k + log (n − k) �. Whenk = 1, our generalized sorting algorithm does the work of finding maximum, and when k = n, it does the work of sorting. Thus, the analysis of our algorithm builds a connection between the two extremely special cases which are maximum finding and <b>sorting.</b> <b>key</b> words: parallel algorithm, wireless, sorting, broadcast communication, conflict, generalized sorting 1...|$|E
40|$|The explotation of data {{locality}} {{in parallel}} computers is paramount {{to reduce the}} memory trac and communication among processing nodes. We focus on the exploitation of locality by Parallel Radix sort. The original Parallel Radix sort has several communication steps in which one <b>sorting</b> <b>key</b> may have to visit several processing nodes. In response to this, we propose a reorganization of Radix sort {{that leads to a}} highly local version of the algorithm at a very low cost. As a key feature, our algorithm performs one only communication step, forcing keys to move only once between processing nodes. Also, it reduces the amount of data communicated. Finally, the new algorithm achieves a good load and communication balance which makes it insensitive to skewed data distributions. We call the new version of Parallel Radix sort that combines locality and load balance, Communication and Cache Conscious Radix sort (C 3 -Radix sort). Our results on 16 processors of the SGI O 2000 show that C 3 -Radix sort reduces the execution time of the previous fastest version of Parallel Radix sort by 3 times for data sets larger than 8 M keys and by almost 2 times for smaller data sets. ...|$|E
40|$|Mutations in the mucolipin- 1 gene {{have been}} linked to {{mucolipidosis}} type IV, a lysosomal storage disorder characterized by severe neurological and ophthalmologic abnormalities. Mucolipin- 1 is a membrane protein containing six putative transmembrane domains with both its N- and C-termini localized facing the cytosol. To gain information on the sorting motifs that mediate the trafficking of this protein to lysosomes, we have generated chimeras in which the N- and C- terminal tail portions of mucolipin- 1 were fused to a reporter gene. In this article, we report the identification of two separate dileucine-type motifs that co-operate to regulate the transport of mucolipin- 1 to lysosomes. One di-leucine motif is positioned at the N-terminal cytosolic tail and mediates direct transport to lysosomes, whereas the other dileucine motif is found at the C-terminal tail and functions as an adaptor protein 2 -dependent internalization motif. We have also found that the C-terminal tail of mucolipin- 1 is palmitoylated and that this modification might regulate the efficiency of endocytosis. Finally, the mutagenesis of both di-leucine motifs abrogated lysosomal accumulation and resulted in cell-surface redistribution of mucolipin- 1. Taken together, these results reveal novel information regarding the motifs that regulate mucolipin- 1 trafficking and suggest a role for palmitoylation in protein <b>sorting.</b> <b>Key</b> words: sortin...|$|E
50|$|For example, {{the items}} are books, the <b>sort</b> <b>key</b> is the title, subject or author, {{and the order}} is alphabetical.|$|R
5000|$|Han's algorithm, a {{deterministic}} algorithm for <b>sorting</b> <b>keys</b> from {{a domain}} of finite size, taking O(n log log n) time and O(n) space.|$|R
50|$|When <b>sort</b> <b>keys</b> for a dataset are uniformly {{distributed}} numbers, {{linear interpolation}} is straightforward to implement and will find an index {{very near the}} sought value.|$|R
40|$|The aim of {{the paper}} is to {{introduce}} techniques in order to tune sequential in-core sorting algorithms in the frameworks of two applications. The first application is parallel sorting when the processor speeds are not identical in the parallel system. The second application is the Zeta-Data Project (Koskas, 2003) whose aim is to develop novel algorithms for databases issues. About 50 % of the work done in building indexes is devoted to sorting sets of integers. We develop and compare algorithms built to sort with equal keys. Algorithms are variations of the 3 way-Quicksort of Segdewick. In order to observe performances and to fully exploit functional units in processors and also in order to optimize {{the use of the}} memory system and the different functional units, we use hardware performance counters that are available on most modern microprocessors. We develop also analytical results for one of our algorithms and compare expected results with the measures. For the two applications, we show through fine experiments on an Athlon processor (a three-way superscalar x 86 processor), that L 1 data cache misses is not the central problem but a subtil proportion of independent retired instructions should be advised to get performance for in-core <b>sorting.</b> <b>Key</b> words: hardware performance counters, in-core sorting algorithms with equal keys, two levels memory hierarchy, optimizing memory accesses, parallelism at the chip level, data structures for databases, parallel sorting. Preprint submitted to Elsevier Science 2 June 2004...|$|E
5000|$|This list is sortable, and is {{initially}} sorted by year. Click on the [...] icon {{on the right}} side of the column header to change <b>sort</b> <b>key</b> and <b>sort</b> order.|$|R
50|$|Some sort {{utilities}} {{can sort}} on a reversed {{version of the}} <b>sort</b> <b>key,</b> {{making it easy to}} generate reverse dictionaries on the fly if the dictionary data is available in electronic form.|$|R
50|$|Union and Merge -Two or more streams can be {{combined}} by unioning or merging them. Unioning combines tuples in strict FIFO order. Merging is more deterministic, combining streams according to a <b>sort</b> <b>key.</b>|$|R
50|$|Sorting n-tuples (depending on context {{also called}} e.g. records {{consisting}} of fields) {{can be done}} based on {{one or more of}} its components. More generally objects can be sorted based on a property. Such a component or property is called a <b>sort</b> <b>key.</b>|$|R
2500|$|Self-Chord [...] decouples object {{keys from}} peer IDs and <b>sorts</b> <b>keys</b> along the ring with a {{statistical}} approach {{based on the}} swarm intelligence paradigm. Sorting ensures that similar keys are stored by neighbour nodes and that discovery procedures, including range queries, can be performed in logarithmic time.|$|R
5000|$|... # Every call to each {{returns the}} next key/value pair.# All values will be {{eventually}} returned, but their order# cannot be predicted.while (($name, $address) = each %addressbook) { print [...] "$name lives at $address\n";}# Similar to the above, but sorted alphabeticallyforeach my $next_name (<b>sort</b> <b>keys</b> %addressbook) { print [...] "$next_name lives at $addressbook{$next_name}\n";} ...|$|R
40|$|Describes the characte 1 ·istics, performance, and {{potential}} of SKED (Sort- Key Edit), a generalized computer program for creating <b>sort</b> <b>keys</b> for MARC II records at the users option. SKED and {{a modification of}} the IBM S/ 360 DOS tape sort/merge program {{form the basis for}} a comprehensive program for arranging catalog entries by computer...|$|R
5000|$|Here {{the first}} sort is done using column 2. [...] {{specifies}} <b>sorting</b> on the <b>key</b> starting {{and ending with}} column 2. If [...] is used instead, the <b>sort</b> <b>key</b> would begin at column 2 and extend {{to the end of}} the line, spanning all the fields in between. The [...] stands for 'numeric ordering'. [...] dictates breaking ties using the value in column 1, sorting alphabetically by default. Note that bob, an and chad have the same quota and are sorted alphabetically in the final output.|$|R
50|$|This will output {{the keys}} {{and values of the}} entire map, <b>sorted</b> by <b>keys.</b>|$|R
5000|$|<b>Sort</b> the <b>keys</b> using ProxmapSort, keeping theMapKey function, and the P and A2 arrays ...|$|R
5000|$|However, the {{simplest}} algorithms for BST item insertion may yield {{a tree with}} height n in rather common situations. For example, when the items are inserted in <b>sorted</b> <b>key</b> order, the tree degenerates into a linked list with n nodes. The difference in performance between the two situations may be enormous: for n = 1,000,000, for example, the minimum height is [...]|$|R
40|$|This article {{describes}} to a neuro-difusse <b>sort</b> <b>key</b> that marks {{a difference between}} four types of defects in wood known like bellboys. The visual inspection by humans of these defects has {{a high degree of}} complexity since within a same class variations in form, size and color exist. The characteristics used by the <b>sort</b> <b>key</b> were extracted of the wood images by means of Gabor filters 2 D. These filters very are used for images in where the texture is an important factor. The Method of Incorporation was used In order to reduce the dimensionality of the vector of characteristics. The neuro-difusse network was design from a network of Radial Base Functions, FBR, of two layers in where the entrances of the network are fuzified before initiating the training. The recognition that was reached was of the 97. 05 % being an acceptable result considering that a human inspector reaches recognition between 75 and 85 %...|$|R
5000|$|Locality-preserving hashing {{ensures that}} similar keys are {{assigned}} to similar objects. This can enable a more efficient execution of range queries.Self-Chord [...] decouples object keys from peer IDs and <b>sorts</b> <b>keys</b> along the ring with a statistical approach based on the swarm intelligence paradigm. Sorting ensures that similar keys are stored by neighbour nodes and that discovery procedures, including range queries, can be performed in logarithmic time.|$|R
40|$|Abstract. We {{study the}} problem of {{determining}} the complexity of optimal comparison-based in-place <b>sorting</b> when the <b>key</b> length, k, is not a constant. We present the first algorithm for lexicographically <b>sorting</b> n <b>keys</b> in O(nk+n log n) time using O(1) auxiliary data locations, which is simultaneously optimal in time and space. ...|$|R
40|$|The {{process of}} {{automatically}} making the indices for the abstract journal Mathematics is considered. The basis for {{creation of the}} indices is the database of the bibliography description sources and the text abstracts, which are typeset in the russi cation LaTeX 2. 09. An IBM PC is applied for working with a database and printing camera-ready copies. Em-TeX, MakeIndex and Perl scripts are used. Program DviSpell is applied for generating the <b>Sort</b> <b>Keys...</b>|$|R
50|$|In some applications, {{the strings}} by which items are {{collated}} {{may differ from}} the identifiers that are displayed. For example, The Shining might be sorted as Shining, The (see Alphabetical order above), but it may still be desired to display it as The Shining. In this case two sets of strings can be stored, one for display purposes, and another for collation purposes. Strings used for collation in this way are called <b>sort</b> <b>keys.</b>|$|R
50|$|Collation {{differs from}} {{classification}} in that classification {{is concerned with}} arranging information into logical categories, while collation {{is concerned with the}} ordering of items of information, usually based on the form of their identifiers. Formally speaking, a collation method typically defines a total order on a set of possible identifiers, called <b>sort</b> <b>keys,</b> which consequently produces a total preorder on the set of items of information (items with the same identifier are not placed in any defined order).|$|R
