18|1|Public
50|$|In Merkle-Hellman, {{the keys}} are two {{knapsack}}s. The public key is a 'hard' knapsack , {{and the private}} key is an 'easy', or <b>superincreasing,</b> knapsack , combined with two additional numbers, a multiplier and a modulus. The multiplier and modulus {{can be used to}} convert the <b>superincreasing</b> knapsack into the hard knapsack. These same numbers are used to transform the sum of the subset of the hard knapsack into the sum of the subset of the easy knapsack, which is a problem that is solvable in polynomial time.|$|E
5000|$|For example, [...] is a <b>superincreasing</b> sequence, but [...] is not. The {{following}} Python {{source code}} tests {{a sequence of}} numbers to determine if it is superincreasing: ...|$|E
5000|$|Sum: 0 Element: 1 Sum: 1 Element: 3 Sum: 4 Element: 6 Sum: 10 Element: 13 Sum: 23 Element: 27 Sum: 50 Element: 52 <b>Superincreasing</b> sequence? True ...|$|E
40|$|AbstractTwo public-key 0 – 1 {{knapsack}} cryptosystems are proposed, {{that have}} so high a density and use so weak a modular multiplication as a trapdoor, that known attacks can be avoided. Decryption is fairly slow and may produce {{more than one}} decipherment, but all alternative decipherments can be found. Disambiguating protocols are needed to determine the correct decipherment. It is suggested to use also redundancy for this purpose. In the first system, the initial knapsack is constructed from the powers of two, which are multiplied by a constant and reduced {{with respect to a}} modulus to a specific range, thus producing the “easy” knapsack. Then weak modular multiplication is used as a trapdoor transformation with respect to another modulus, which is typically smaller than {{some or all of the}} elements of the easy knapsack. The second knapsack is constructed iteratively from modularly injective or nearly injective components. Decryption of small components is based on look-up tables. The specific form of the proposal uses also one large non-injective component, which is generated and decrypted in a way that resembles <b>superincrease...</b>|$|R
50|$|First, a <b>superincreasing</b> {{sequence}} w {{is created}} w = {2, 7, 11, 21, 42, 89, 180, 354}This {{is the basis}} for a private key. From this, calculate the sum.|$|E
5000|$|In mathematics, a {{sequence}} of positive real numbers [...] is called <b>superincreasing</b> if every element of the sequence {{is greater than the}} sum of all previous elements in the sequence.|$|E
50|$|This {{problem is}} easy because w is a <b>superincreasing</b> sequence.Take the largest element in w, say wk. If wk > c' , then αk = 0, if wk≤c' , then αk = 1. Then, {{subtract}} wk×αk from c' , and repeat these steps {{until you have}} figured out α.|$|E
50|$|Decryption is {{possible}} because the multiplier and modulus used {{to transform the}} easy knapsack into the public key {{can also be used}} to transform the number representing the ciphertext into the sum of the corresponding elements of the <b>superincreasing</b> knapsack. Then, using a simple greedy algorithm, the easy knapsack can be solved using O(n) arithmetic operations, which decrypts the message.|$|E
5000|$|The Merkle-Hellman {{system is}} based on the subset sum problem (a special case of the {{knapsack}} problem). The problem is as follows: given a set of numbers [...] and a number b, find a subset of [...] which sums to b. In general, this problem is known to be NP-complete. However, if the set of numbers (called the knapsack) is <b>superincreasing,</b> meaning that each element of the set is greater than the sum of all the numbers in the set lesser than it, the problem is [...] "easy" [...] and solvable in polynomial time with a simple greedy algorithm.|$|E
40|$|We {{consider}} bounded integer knapsacks {{where the}} weights and variable upper bounds together form a <b>superincreasing</b> sequence. The {{elements of this}} <b>superincreasing</b> knapsack are exactly those vectors that are lexicographically smaller than the greedy solution to optimizing over this knapsack. We describe the convex hull of this n-dimensional set with O(n) facets. We also establish a distributive property by proving that the convex hull of -type <b>superincreasing</b> knapsacks {{can be obtained by}} intersecting the convex hulls of -sets taken individually. Our proofs generalize existing results for the binary case. Comment: 19 pages; under second review with journa...|$|E
40|$|Abstract- The Merkle-Hellman {{invented in}} 1978 {{is based on}} the <b>superincreasing</b> subset problem. Ralph Merkle and Martin Hellman used the subset problem to create a {{cryptosystem}} to encrypt data. A super-increasing knapsack vector s is created and the super-increasing property is hidden by creating a second vector M by modular multiplication and permutation. The vector M is the public key of the cryptosystem and s is used to decrypt the message. This paper demonstrates how to strengthen the encrypted message being sent by use of discrete logarithmics so that only the intended recipient of the message is able to decipher the message. Index Terms- Security; cryptography; cryptosystem; discrete logarithm; euler’s totient function; knapsack problem; <b>superincreasing</b> vector. T I...|$|E
40|$|AbstractIn the well-knownSubset Sum Problem, we {{are given}} {{positive}} integersa 1, [...] ., an andt and are to determine if some subset of theai sums tot. We investigate the boundary between easy and hard variations of this problem. In particular, we consider the cases where the sequencea 1, [...] ., an is an arithmetic progression, a chain or <b>superincreasing</b> and where theai may be replicated. We also consider related problems...|$|E
40|$|Cryptanalysis {{applied to}} a simple Merkle-Hellman (1978) public key {{cryptographic}} system (described within a standard-parameter knapsack problem) reveals the high vulnerability of the system. However, a cryptanalytic attack becomes ineffective when the knapsack problem with two or more iterations is used in order to obscure {{the structure of the}} <b>superincreasing</b> sequence. To enhance the security of a cryptographic system structured numbers can be used, while the multiple iterations of the modular multiplications technique can produce a safer Merkle-Hellman knapsack system...|$|E
40|$|The {{security}} {{offered by}} symmetric cryptosystems {{based on the}} arithmetic coding algorithm is examined. It is shown {{that this can be}} reduced naturally to the subset sum problem. The subset sum problem is NP-complete, however, the cases which arise in practical cryptosystems based on this problem tend to be solvable in polynomial time because the sums formed are either <b>superincreasing</b> or of low density. Our attack is therefore similar to attacks on public-key cryptosystems based on the subset sum problem (knapsack systems) ...|$|E
40|$|Recently, Hwang et al. {{introduced}} a knapsack type public-key cryptosystem. They proposed a new algorithm called permutation combination algorithm. By exploiting this algorithm, {{they attempt to}} increase the density of knapsack to avoid the low-density attack. We show that this cryptosystem is not secure, as it based on basic Merkel-Hellman knapsack cryptosystem {{and because of the}} <b>superincreasing</b> structure, we can use shamir's attack on the basic Merkel-Hellman knapsack to break this cryptosystem. Comment: International Conference on Applied Mathematics and Computer Sciences, Rio de Janeiro, Brazil, March 201...|$|E
40|$|AbstractThe {{iterated}} mod {{problem is}} this: given a, b 1, b 2, …, bn, all integers or all polynomials in Q[x], is ((… ((a mod b 1) mod b 2) …) mod bn) = 0 ? When the inputs are integers, we prove the problem P-complete {{with respect to}} log-space reductions, whereas in the polynomial case, we prove the problem is in NC. The significance of these results lies primarily in the similarity between the iterated mod problem and the Euclidean algorithm. We also show that the <b>superincreasing</b> knapsack problem is P-complete, using a very similar proof...|$|E
40|$|The basic goal of {{this study}} is to extend old and propose new ways to {{generate}} knapsack sets suitable for use in public key cryptography. The knapsack problem and its cryptographic use are reviewed in the introductory chapter. Terminology is based on common cryptographic vocabulary. For example, solving the knapsack problem (which is here a subset sum problem) is termed decipherment. Chapter 1 also reviews the most famous knapsack cryptosystem, the Merkle Hellman system. It is based on a <b>superincreasing</b> knapsack and uses modular multiplication as a trapdoor transformation. The insecurity caused by these two properties exemplifies the two general categories of attacks against knapsack systems. These categories provide the motivation for Chapters 2 and 4. Chapter 2 discusses the density of a knapsack and the dangers of having a low density. Chapter 3 interrupts for a while the more abstract treatment by showing examples of small injective knapsacks and extrapolating conjectures on some characteristics of knapsacks of larger size, especially their density and number. The most common trapdoor technique, modular multiplication, is likely to cause insecurity, but as argued in Chapter 4, it is difficult to find any other simple trapdoor techniques. This discussion also provides a basis for the introduction of various categories of non injectivity in Chapter 5. Besides general ideas of non injectivity of knapsack systems, Chapter 5 introduces and evaluates several ways to construct such systems, most notably the "exceptional blocks" in <b>superincreasing</b> knapsacks and the usage of "too small" a modulus in the modular multiplication as a trapdoor technique. The author believes that non injectivity is the most promising direction for development of knapsack cryptosystema. Chapter 6 modifies two well known knapsack schemes, the Merkle Hellman multiplicative trapdoor knapsack and the Graham Shamir knapsack. The main interest is in aspects other than non injectivity, although that is also exploited. In the end of the chapter, constructions proposed by Desmedt et. al. are presented to serve as a comparison for the developments of the subsequent three chapters. Chapter 7 provides a general framework for the iterative construction of injective knapsacks from smaller knapsacks, together with a simple example, the "three elements" system. In Chapters 8 and 9 the general framework is put into practice in two different ways. Modularly injective small knapsacks are used in Chapter 9 to construct a large knapsack, which is called the congruential knapsack. The addends of a subset sum can be found by decrementing the sum iteratively by using each of the small knapsacks and their moduli in turn. The construction is also generalized to the non injective case, which can lead to especially good results in the density, without complicating the deciphering process too much. Chapter 9 presents three related ways to realize the general framework of Chapter 7. The main idea is to join iteratively small knapsacks, each element of which would satisfy the <b>superincreasing</b> condition. As a whole, none of these systems need become <b>superincreasing,</b> though the development of density is not better than that. The new knapsack systems are injective but they can be deciphered with the same searching method as the non injective knapsacks with the "exceptional blocks" in Chapter 5. The final Chapter 10 first reviews the Chor Rivest knapsack system, which has withstood all cryptanalytic attacks. A couple of modifications to the use of this system are presented in order to further increase the security or make the construction easier. The latter goal is attempted by reducing the size of the Chor Rivest knapsack embedded in the modified system. ...|$|E
40|$|The {{knapsack}} problem {{is known to}} be used in numerous public key ciphersystems designs. These ciphersystems have been receiving increased attention from analytics, resulting in many being compromised. Therefore, modern systems incorporate new algorithms making them at least partially immune to known attacks. In this paper, three types of knapsack ciphersystems are introduced. The difference between types is how the keys are generated and used. Classical systems, being the first type, use <b>superincreasing</b> sequences and low-density knapsacks and are therefore vulnerable. Modern cryptosystems are based on high-density knapsacks. That makes them difficult to analyze. Hybrid cryptosystems incorporate several security mechanisms (not only trapdoor knapsacks) that makes analysis, as well as implementation, even more complicated...|$|E
40|$|This paper {{gives the}} {{definitions}} of an extra <b>superincreasing</b> sequence and an anomalous subset sum, and proposes a fast quantum-safe asymmetric cryptosystem called JUOAN 2. The new cryptosystem {{is based on an}} additive multivariate permutation problem (AMPP) and an anomalous subset sum problem (ASSP) which parallel a multivariate polynomial problem and a shortest vector problem respectively, and composed of a key generator, an encryption algorithm, and a decryption algorithm. The authors analyze the security of the new cryptosystem against the Shamir minima accumulation point attack and the LLL lattice basis reduction attack, and prove it to be semantically secure (namely IND-CPA) on the assumption that AMPP and ASSP have no subexponential time solutions. Particularly, the analysis shows that the new cryptosystem {{has the potential to be}} resistant to quantum computing attack, and is especially suitable to the secret communication between two mobile terminals in maneuvering field operations under any weather. At last, an example explaining the correctness of the new cryptosystem is given. Comment: 8 Pages. arXiv admin note: text overlap with arXiv: 1408. 622...|$|E

