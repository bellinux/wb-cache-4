25|84|Public
5000|$|The {{concept of}} {{successor}} {{can be used}} for keys as well. The <b>successor</b> <b>node</b> of a key [...] is the first node whose ID equals to [...] or follows [...] in the identifier circle, denoted by [...] Every key is assigned to (stored at) its <b>successor</b> <b>node,</b> so looking up a key [...] is to query [...]|$|E
5000|$|The third {{parameter}} next is {{the set of}} {{the formula}} using which <b>successor</b> <b>node</b> will be created.|$|E
5000|$|A parity game {{is played}} on a colored {{directed}} graph, where each node has been colored by a priority [...] - [...] one of (usually) finitely many natural numbers. Two players, 0 and 1, move a (single, shared) token {{along the edges of}} the graph. The owner of the node that the token falls on selects the <b>successor</b> <b>node,</b> resulting in a (possibly infinite) path, called the play.|$|E
5000|$|The data {{structure}} {{is similar to}} a decision tree. Each node has a rule, the format of this rule is IF cond1 AND cond2 AND ... AND condN THEN conclusion. Cond1 is a condition (boolean evaluation), for example A=1, isGreater(A,5) and average(A,">",average(B)). Each node has exactly two <b>successor</b> <b>nodes,</b> these <b>successor</b> <b>nodes</b> are connected to predecessor node by [...] "ELSE" [...] or [...] "EXCEPT".|$|R
30|$|A), {{that depend}} on A, will be {{immediately}} triggered (like it usually happens). Instead, <b>successor</b> <b>nodes</b> should be triggered as soon as A has finished its execution and has also performed a sufficient level {{of changes in the}} data store that comply with certain QoD requirements (which can cause a node being executed multiple times with the <b>successor</b> <b>nodes</b> being triggered only once). If such changes do not occur in a given time frame, <b>successor</b> <b>nodes</b> would eventually be triggered. Hence, the QoD requirements evaluate the volume of data input fed to an action that is worth its execution. This is the key difference and novelty of our approach that breaks through the SDF (synchronous data-flow) computing model.|$|R
5000|$|... {{restriction}} [...] of [...] on [...] is a bijection, with [...] {{the set of}} <b>successor</b> <b>nodes</b> of v.|$|R
5000|$|Deleting a node {{with two}} children: call the node to be deleted D. Do not delete D. Instead, choose either its in-order {{predecessor}} node or its in-order <b>successor</b> <b>node</b> as replacement node E (s. figure). Copy the user values of E to D. If E {{does not have}} a child simply remove E from its previous parent G. If E has a child, say F, it is a right child. Replace E with F at E parent.|$|E
50|$|At line 1, the if {{condition}} checks if curr contains any {{formula to}} be expanded.If the curr is empty then at line 2 the if condition checks if there already exists a state q' with {{same set of}} expanded formulas.If that is the case, then we do not add a redundant node, but we add parameter incoming in Incoming(q') at line 3.Otherwise, we add a new node q using the parameters at lines 5-9 and we start expanding a <b>successor</b> <b>node</b> of q using next(q) as its unexpanded set of formulas at line 10.|$|E
50|$|The DT {{contains}} the network {{view of the}} neighbors of a node. It contains a matrix where each element {{contains the}} distance and the penultimate node reported by a neighbor for a particular destination. The RT contains the up-to-date view of the network for all known destinations. It keeps the shortest distance, the predecessor node (penultimate node), the <b>successor</b> <b>node</b> (the next node to reach the destination), and a flag indicating {{the status of the}} path. The path status may be a simple path (correct), or a loop (error), or the destination node not marked (null). The LCT contains the cost (e.g., the number of hops to reach the destination) of relaying messages through each link. The cost of a broken link is infinity. It also contains the number of update periods (intervals between two successive periodic updates) passed since the last successful update was received from that link. This is done to detect links breaks. The MRL contains an entry for every update message that is to be retransmitted and maintains a counter for each entry. This counter is decremented after every retransmission of an update message. Each update message contains a list of updates. A node also marks each node in the RT that has to acknowledge the update message it transmitted. Once the counter reaches zero, the entries in the update message for which no acknowledgments have been received are to be retransmitted and the update message is deleted. Thus, a node detects a link break by the number of update periods missed since the last successful transmission. After receiving an update message, a node not only updates the distance for transmission neighbors but also checks the other neighbors’ distance, hence convergence is much faster than DSDV.|$|E
30|$|End node: a node {{that does}} not have any <b>successor.</b> <b>Nodes</b> CC 33, CC 14, CC 24, CC 34 are end nodes in Figure 3.|$|R
3000|$|Unlike {{the other}} typical models, our {{approach}} {{takes a step}} further: the end of execution of a node A {{does not mean that}} the <b>successor</b> <b>nodes</b> A’ (denoted A′≻ [...]...|$|R
50|$|The code of expand is {{labelled}} with line {{numbers for}} easy reference.Each call to expand aims {{to add a}} <b>node</b> and its <b>successors</b> <b>nodes</b> in the graph.The parameters of the call describes a potential new node.|$|R
30|$|Whenever a node in {{the network}} {{searches}} for the key k using a LOOKUP operation, the network address (physical address in the underlay network) associated with the <b>successor</b> <b>node</b> will be necessary. For this reason, the underlay network runs a routing protocol. In DCRP, the HWMP protocol is used.|$|E
40|$|Node {{mobility}} affects routing {{in terms}} of robustness and efficiency, as it may lead to frequent link breaks that are not always automatically detected at a protocolar level. In user-centric environments, nodes are characterized by dynamic mobility behavior because they are devices carried or controlled by humans. We propose routing metrics aimed at making routing more robust through consideration of node spatial correlation for <b>successor</b> <b>node.</b> We have validated our metrics in Ad hoc On-Demand Distance Vector (AODV) routing protocol using Network Simulator 2. Results obtained show that our metrics increase multi-hop routing robustness {{in terms of}} path re-computation reduction...|$|E
40|$|Abstract — We {{determine}} the exact symbol error probability of M-ary {{phase shift keying}} (M-PSK) for multihop communication systems with regenerative relays, where the source terminal transmits data to the destination terminal via a set of intermedi-ate relay stations, which perform hard decisions on the received symbols before forwarding them to their respective <b>successor</b> <b>node.</b> Both, time-invariant additive white Gaussian noise channels as well as frequency-flat fading channels are considered and we derive generic expressions, which might be easily evaluated numerically or even be given in closed-form for various cases. Index Terms — Multihop transmission, symbol error probabil-ity, M-PSK, relay channel, decode-and-forward, Nakagami-m fading, regenerative relays...|$|E
50|$|When a {{leaf node}} is reached, the {{algorithm}} generates all <b>successor</b> <b>nodes</b> and assigns intervals to them using the evaluation function. Then the intervals of all nodes {{have to be}} backed up using the backup operation.|$|R
5000|$|Postorder - This is {{a typical}} {{iteration}} order for backward data-flow problems. In postorder iteration, a node is visited after all its <b>successor</b> <b>nodes</b> have been visited. Typically, the postorder iteration is implemented with the depth-first strategy.|$|R
5000|$|Reverse {{postorder}} - This is {{a typical}} iteration order for forward data-flow problems. In reverse-postorder iteration, a node is visited before any of its <b>successor</b> <b>nodes</b> has been visited, except when the successor is reached by a back edge. (Note {{that this is not}} the same as preorder.) ...|$|R
30|$|A {{reinforcement}} learning {{approach has been}} described as providing a balance between pruning for generalization and growing deeper trees for accuracy [153]. A continuous U tree algorithm transfers traditional U tree algorithm to {{reinforcement learning}} and this U tree algorithm {{can be viewed as a}} Regression Tree algorithm for storing state values [154]. The regression clustering (CART) with splits satisfying a maximum gain measure as modelled by ginni coefficient describes a probabilistic measure modelling the fraction of points of the predecessor nodes that are present in the one or the other <b>successor</b> <b>node.</b> The above description summarizes the relevance of U tree algorithm and CART algorithm to our work.|$|E
40|$|In {{a dynamic}} social network, nodes {{can be removed}} from the network for some reasons, and {{consequently}} affect the behaviors of the network. In this paper, we tackle the challenge of finding a <b>successor</b> <b>node</b> for each removed seed node to maintain the influence spread in the network. Given a social network and a set of seed nodes for influence maximization, the problem is to effectively choose successors to inherit the jobs of initial influence propagation when some seeds are removed from the network. To tackle this problem, we present and discuss five neighborhoodbased selection heuristics, including degree, degree discount, overlapping, community bridge, and community degree. Experiments on DBLP co-authorship network show the effectiveness of devised heuristics...|$|E
40|$|This paper {{describes}} a fault-tolerant wormhole routing technique that incorporates {{a variation of}} distributed recovery block (DRB) approach. The section of a parallel system that spans between the source and destination nodes is dynamically partitioned into overlapping DRB groups. A DRB group consists of a current node, a primary and an alternate <b>successor</b> <b>node.</b> The message packets travel towards the destination from one DRB group to the next group. A prototype of the routing system is implemented for mesh and hypercube topologies; however, the method {{can be used for}} topologies with a minimum node connectivity of three. The simulation results indicate that the DRB approach based wormhole routing tolerates both node and link failures. ...|$|E
50|$|Let T = {0,1}* and Σ = {a,b}. We {{define a}} {{labeling}} function V as follows: the labeling for the root node is V(ε) = a and, for every other node t ∈ {0,1}*, the labellings for its <b>successor</b> <b>nodes</b> are V(t.0) = a and V(t.1) = b. It {{is clear from}} the picture that T forms a (fully) infinite binary tree.|$|R
30|$|The {{algorithm}} uses two {{estimates of}} {{the distance to the}} goal starting from a node s, called g(s) and rhs(s).The estimate rhs(s) is potentially more accurate than g(s), once {{it is based on the}} values of g(s) of the <b>successors</b> <b>nodes</b> of s. The basic principle of the algorithm is keeping the two values consistent for all nodes, which means that all estimates of distances are correct.|$|R
5000|$|Each <b>node</b> has a <b>successor</b> and a predecessor. The <b>successor</b> to a <b>node</b> is {{the next}} node in the {{identifier}} circle in a clockwise direction. The predecessor is counter-clockwise. If there is a node for each possible ID, the <b>successor</b> of <b>node</b> 0 is node 1, and the predecessor of node 0 is node however, normally there are [...] "holes" [...] in the sequence. For example, the <b>successor</b> of <b>node</b> 153 may be node 167 (and nodes from 154 to 166 do not exist); in this case, the predecessor of node 167 will be node 153.|$|R
40|$|Abstract—A MANET is a {{collection}} of mobile nodes communicating and cooperating with each other to route a packet from the source to their destinations. A MANET is used to support dynamic routing strategies in absence of wired infrastructure and centralized administration. In this paper, we propose a routing algorithm for the mobile ad hoc networks based on fuzzy logic to discover an optimal route for transmitting data packets to the destination. This protocol helps every node in MANET to choose next efficient <b>successor</b> <b>node</b> on the basis of channel parameters like environment noise and signal strength. The protocol improves the performance of a route by increasing network life time, reducing link failure and selecting best node for forwarding the data packet to next node...|$|E
40|$|AbstractWe {{define and}} analyse {{a new class}} of perfect {{information}} games. The nodes of a directed graph G are partitioned into n player sets. Starting at a fixed node of G an infinite path is created as follows: If the current node belongs to player k, then player k chooses any <b>successor</b> <b>node.</b> A local reward n-vector is assigned to every arc. The payoff corresponding to the infinite path is the long term average of the local reward vectors. Such games are called DGA games. Negative and positive results are obtained for the existence of Nash equilibria in certain types of pure strategies (e. g., stationary and automated strategies). Applications to duopoly pricing models and “surveillance games” on graphs are given...|$|E
40|$|Abstract: Central to {{the control}} of hybrid systems are the issues of safety, stability, and reachability. This paper {{addresses}} all these issues {{in the form of}} safe and stable reconfiguration of hybrid systems. Here, reconfiguration means the application of discrete control that changes the underlying dynamics of continuous states. We outline a methodology to perform rapid reconfiguration that will allow reaching a target equilibrium state staring from an initial equilibrium state in a safe and stable fashion using a sequence of discrete and continuous control steps. The key concept behind this methodology is the notion of a safe and stable reachability graph whose nodes are various equilibria of the system, and a directed edge between a pair of nodes is defined to imply the membership of the predecessor node in a certain region of stability of the <b>successor</b> <b>node...</b>|$|E
40|$|Search {{algorithms}} {{are often}} categorized by their node expansion strategy. One option is the depth-first strategy, a simple backtracking strategy that traverses the search {{space in the}} order in which <b>successor</b> <b>nodes</b> are generated. An alternative is the best-first strategy, which was designed to make it possible to use domain-specific heuristic information. By exploring promising parts of the search space first, best-first algorithms are usually more efficient than depth-first algorithms...|$|R
40|$|Abstract. An {{stochastic}} {{version of}} the classical shortest path problem whereby for each node of a graph, a probability distribution over the set of <b>successor</b> <b>nodes</b> must be chosen so as to reach a certain destination node with minimum expected cost. In this paper, we propose a new algorithm based on Particle Swarm Optimization (PSO) for solving Stochastic Shortest Path Problem (SSPP). The comparison of our algorithm with other algorithms indicates that its performance is suitable even by the less number of iterations...|$|R
5000|$|Each <b>node's</b> <b>successor</b> {{points to}} its {{immediate}} successor correctly.|$|R
40|$|The paper {{attempts}} to find numerical solutions of Diophantine equations, a challenging problem as there are no general methods to find solutions of such equations. It uses the metaphor of foraging habits of real ants. The ant colony optimization based procedure starts with randomly assigned locations to a fixed number of artificial ants. Depending upon the quality of these positions, ants deposit pheromone at the nodes. A <b>successor</b> <b>node</b> is selected from the topological neighborhood {{of each of the}} nodes based on this stochastic pheromone deposit. If an ant bumps into an already encountered node, the pheromone is updated correspondingly. A suitably defined pheromone evaporation strategy guarantees that premature convergence does not take place. The experimental results, which compares with those of other machine intelligence techniques, validate the effectiveness of the proposed method. Comment: 14 pages, 8 figure...|$|E
40|$|Mobile ad hoc {{network is}} a {{collection}} of mobile devices which can communicate through wireless links. The task of routing protocol is to send packets from source to destination. This is particularly hard in mobile ad hoc networks due to the mobility of the network elements and lack of centralized control, infrastructure, etc. In this paper, we propose a routing algorithm for the mobile ad hoc networks to discover an optimal route for transmitting data packets from source to destination. This protocol helps every node in MANET to choose next efficient <b>successor</b> <b>node</b> on the basis of channel parameters like noise, energy, bandwidth, number of hop, traffic load. The protocol improves the performance of a route by increasing network life time, reducing link failure and selecting best node for forwarding the data packet to next node. The protocol adapts quickly to routing changes when host movement is frequent, yet requires little or no overhead during periods in which hosts move less frequently...|$|E
30|$|The {{abolition}} of the aforementioned pure strategy includ- ed in Bodin [4], Keaton [10] and Fuegenschuh [9] might be a key to make European railroad systems more flexible and more efficient. Pure strategy is often used because of historical reasons. Work in the shunting yards used to be easier to coordinate when wagon routes could be derived from their destinations. This was an advantage in times when decisions were made by hand. But nowadays more and more work inside the yards is coordinated by software support systems. Thus, reduction of human mistakes by an easier planning system, i.e. pure strategy, is an outdated strategy. According to the last arguments, we advance the thesis that the pure strategy, which enforces a unique <b>successor</b> <b>node</b> for relations with common destinations, should be abolished in European railway planning processes. European railway operators should learn from North American production systems and customize existing ideas to their own needs. New concepts adapting ideas and knowledge from North American railroads are needed to prepare the European railroad systems for the future.|$|E
40|$|Subgraph {{isomorphism}} can {{be determined}} {{by means of a}} brute-force tree-search enumeration procedure. In this paper a new algorithm is introduced that attains efficiency by inferentially eliminating <b>successor</b> <b>nodes</b> in the tree search. To assess the time actually taken by the new algorithm, subgraph isomorphism, clique detection, graph isomorphism, and directed graph isomorphism experiments have been carried out with random and with various nonrandom graphs. A parallel asynchronous logic-in-memory implementation of {{a vital part of the}} algorithm is also described, although this hardware has not actually been bmlt The hardware implementation would allow very rapid determination of isomorphism...|$|R
40|$|The Network Generation Program (NETGEN), {{which creates}} logic {{networks}} from task chart data is presented. NETGEN {{is written in}} CDC FORTRAN IV (Extended) and runs in a batch mode on the CDC 6000 and CYBER 170 series computers. Data is input via a two-card format and contains information regarding the specific tasks in a project. From this data, NETGEN constructs a logic network of related activities with each activity having unique predecessor and <b>successor</b> <b>nodes,</b> activity duration, descriptions, etc. NETGEN then prepares this data on two files {{that can be used}} in the Project Planning Analysis and Reporting System Batch Network Scheduling program and the EZPERT graphics program...|$|R
5000|$|Threads are {{reference}} to the predecessors and <b>successors</b> of the <b>node</b> according to an inorder traversal.|$|R
