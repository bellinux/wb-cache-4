237|1213|Public
5000|$|The <b>state</b> <b>graph</b> of BRN {{represents}} {{the set of}} the states that a BRN can adopt with transitions among them deduced from the previous rules: ...|$|E
5000|$|In more detail, {{the source}} code listing {{represents}} a program graph.Executing the program graph (parsing and interpreting) {{results in a}} state graph.So each program graph induces a state graph.Conversion of the program graph to its associated <b>state</b> <b>graph</b> is called [...] "unfolding" [...] of the program graph.|$|E
50|$|Definition 5 (State graph): Let G = (V, A, b, s, t,K) be a BRN. The <b>state</b> <b>graph</b> of G is a {{directed}} graph G = (EG, T) with (μ, μ_) ∈ T if there exists v ∈ V such that:αv (μ) ≠ 0 and μ’ (v) = μ (v) + αv (μ) and μ (u) = μ’ (u), ∀u ∈ V \ {v}.|$|E
40|$|The {{form of a}} local Clifford (LC, {{also called}} local Gaussian (LG)) {{operation}} for the continuous-variable (CV) weighted <b>graph</b> <b>states</b> is presented in this paper, which is the counterpart of the LC operation of local complementation for qubit <b>graph</b> <b>states.</b> The novel property of the CV weighted <b>graph</b> <b>states</b> is shown, which can be expressed by the stabilizer formalism. It is distinctively different from the qubit weighted <b>graph</b> <b>states,</b> {{which can not be}} expressed by the stabilizer formalism. The corresponding <b>graph</b> rule, <b>stated</b> in purely <b>graph</b> theoretical terms, is described, which completely characterizes the evolution of CV weighted <b>graph</b> <b>states</b> under this LC operation. This LC operation may be applied repeatedly on a CV weighted <b>graph</b> <b>state,</b> which can generate the infinite LC equivalent <b>graph</b> <b>states</b> of this <b>graph</b> <b>state.</b> This work is an important step to characterize the LC equivalence class of CV weighted <b>graph</b> <b>states.</b> Comment: 5 pages, 6 figure...|$|R
40|$|This paper {{presents}} a tool which synthesizes timed circuits from reduced <b>state</b> <b>graphs.</b> Using timing information to reduce <b>state</b> <b>graphs</b> {{can lead to}} significantly smaller and faster circuits. The tool uses implicit techniques (binary decision diagrams) to represent these graphs. This allows us to synthesize larger, more complex systems which may be intractable with an explicit representation. We are also {{able to create a}} parameterized family of solutions, facilitating technology mapping. 1...|$|R
40|$|Absolutely maximally {{entangled}} (AME) {{states are}} multipartite entan-gled {{states that are}} maximally entangled for any possible bipartition. In this paper, we study the description of AME <b>states</b> within the <b>graph</b> <b>state</b> formalism. The graphical representation provides an intuitive framework to visualize the entanglement in <b>graph</b> <b>states,</b> which makes them a natural candidate to describe AME states. We show two different methods of de-termining bipartite entanglement in <b>graph</b> <b>states</b> {{and use them to}} define various AME <b>graph</b> <b>states.</b> We further show that AME <b>graph</b> <b>states</b> exist for all number of parties, and that any AME <b>graph</b> <b>states</b> shared between an even number of parties can be used to describe quantum secret shar-ing schemes with a threshold or ramp access structure directly within the <b>graph</b> <b>states</b> formalism. ...|$|R
5000|$|As {{theoretical}} analysis through Kinetic Logic is a {{time consuming}} process, a tool known as Genotech, for modeling and analysis of BRNs was developed {{on the basis of}} Kinetic Logic and has been used for a number of Kinetic Logic based studies. It analyzes behaviors like stable cycles, stable steady states and paths in the <b>state</b> <b>graph</b> (discrete model) of biological systems, accelerating the process of modeling. [...] GenoTech is extremely useful as it allows repeated experimentation by automating the whole process. This tool is available on request.|$|E
5000|$|In the {{previous}} case, {{the program would}} be in the same state, because the whole state is just the program counter, so if the program counter points to the same position (next command) it suffices to specify {{that we are in the}} same state.However, if the state comprises also of variables, then if those change value, we can be at the same program location with different variable values, meaning in a different state in the program's state space.The term [...] "unfolding" [...] originates from this multiplication of locations when producing the <b>state</b> <b>graph</b> from the program graph.|$|E
5000|$|Although this {{terminology}} {{is widespread}} in the model checking community, some textbooks on model checking do not define [...] "Kripke structure" [...] in this extended way (or at all in fact), but simply use {{the concept of a}} (labelled) transition system, which additionally has a set Act of actions, and the transition relation is defined as a subset of S × Act × S, which they additionally extend to include a set of atomic propositions and a labeling function for the states as well (L as defined above.) In this approach, the binary relation obtained by abstracting away the action labels is called a <b>state</b> <b>graph.</b>|$|E
40|$|In {{this paper}} methology of {{composing}} Markov preocess models of gap junction cells is introduced. This methology contains <b>state</b> <b>graphs</b> generation, computing of stationary probabilities and computing of the conductance {{of the gap}} junction dependence on a voltage. In this paper different gap junction models are presented. Every model has it‘s own connexin <b>state</b> <b>graphs,</b> on which the conductance of the gap junction dependence on a voltage simulation is based. Every connexin can have two different state scenarios: first scenario where two connexin model is based on two states „O“ – open or „C“ – closed and second scenario where three connexin model is based on three states „O“ – open, „C“ – closed and „D“ – deep closed. The computer programs based on these models where created, which allows user graphically see the models <b>state</b> <b>graphs,</b> simulate models and get the needed results. Also these programs are integrated into more difficult systems and into other libraries...|$|R
40|$|We {{formally}} extend various works {{dealing with}} Heuristic Search in <b>state</b> <b>graphs,</b> focusing on 1) {{the notion of}} path length, 2) {{the characteristics of the}} <b>state</b> <b>graphs,</b> 3) the procedures that control the choices of the states to be expanded, 4) the rules that govern the update operations, 5) the properties of the evaluation functions. We present new general theorems concerning the termination at a goal state, the admissibility and the sub-admissibility. 1 Introduction This paper is a part of a global study [3, 4] that aims to compare and to extend various works dealing with heuristically ordered search in <b>state</b> <b>graphs.</b> Below we recall the precise definitions of Nilsson's A and A* [11, 12], then we report under which exact conditions these algorithms terminate by discovering a solution possibly optimal. In Section 2 we propose a formal extension. In Section 3 we present general theorems about the termination discovering a path to a goal state. In Section 4 we present general theorems c [...] ...|$|R
40|$|Graphs (networks) {{are very}} common data {{structures}} which are handled in computers. Diagrams {{are widely used}} to represent the graph structures visually in many information systems. In order to automatically draw the diagrams which are, for example, <b>state</b> <b>graphs,</b> data-flow graphs, Petri nets, and entity-relationship diagrams, basic graph drawing algorithms are required...|$|R
5000|$|One {{important}} NL-complete {{problem is}} ST-connectivity (or [...] "Reachability") (Papadimitriou 1994 Thrm. 16.2), {{the problem of}} determining whether, given a directed graph G and two nodes s and t on that graph, there is a path from s to t. ST-connectivity {{can be seen to}} be in NL, because we start at the node s and nondeterministically walk to every other reachable node. ST-connectivity can be seen to be NL-hard by considering the computation <b>state</b> <b>graph</b> of any other NL algorithm, and considering that the other algorithm will accept if and only if there is a (nondetermistic) path from the starting state to an accepting state.|$|E
5000|$|ATNs {{build on}} the idea of using finite state {{machines}} (Markov model) to parse sentences. W. A. Woods in [...] "Transition Network Grammars for Natural Language Analysis" [...] claims that by adding a recursive mechanism to a finite state model, parsing can be achieved much more efficiently. Instead of building an automaton for a particular sentence, a collection of transition graphs are built. A grammatically correct sentence is parsed by reaching a final state in any <b>state</b> <b>graph.</b> Transitions between these graphs are simply subroutine calls from one state to any initial state on any graph in the network. A sentence is determined to be grammatically correct if a final state is reached by the last word in the sentence.|$|E
5000|$|DeadlocksConsider {{another example}} in which:X=yY=xThe state {{table for the}} system {{is shown in figure}} J. The states that are encircled are stable states, as they do not evolve towards any other state. The logical stable states are defined as those for which the vectors xy [...] [...]. and XY ... are equal. When we {{considered}} the time delays i.e. from ŌŌ the system will proceed to state 1 0 or to state 01, according to whether tx < ty or ty < tx, and from ĪĪ the system will proceed to state 10 or to state 0 1 according to whether ty < tx or tx < ty. The <b>state</b> <b>graph</b> representing delays is shown in figure K.The sequence of states a system depends on the relative values of the time delays. It is assumed that two delays (or sums of delays) are never exactly equal, therefore that two variables will not change their values at the same instant. But do not exclude the possibility because if this rule is applied rigidly, it could occasionally lead to the loss of interesting pathways.|$|E
40|$|A <b>graph</b> <b>state</b> and a <b>graph</b> code {{respectively}} {{are defined}} {{based on a}} mathematical simple graph. In this work, we examine a relation between a <b>graph</b> <b>state</b> and a <b>graph</b> code both obtained from the same graph, and show that a <b>graph</b> <b>state</b> is a superposition of logical qubits of the related graph code. By using the relation, we first discuss that a local complementation which {{has been used for}} a <b>graph</b> <b>state</b> can be useful for searching locally equivalent stabilizer codes, and second provide a method to find a stabilizer group of a graph code. Comment: accepted for publication in QI...|$|R
40|$|Abstract: It is {{important}} and difficult to identify the Hazard before a disaster happen because disaster often happens suddenly. This paper proposes a new method – <b>State</b> Transition <b>Graph,</b> which based on visual data space reconstruction, to identify hazard. The change process of the system state movement from one state to another in a certain period is described by some <b>state</b> transition <b>graphs.</b> The system <b>state,</b> which is safe or hazard, could be distinguished by its <b>state</b> transition <b>graphs.</b> This paper conducted experiments on single-dimension and multi-dimension benchmark data to prove the new method is effectiveness. Especially the result of stimulation experiments, based on the Yangtze River tunnel engineering data, showed that <b>state</b> transition <b>graph</b> identifies hazard easily and has better performances than other method. The <b>State</b> transition <b>graph</b> method is worth further researching...|$|R
40|$|We {{propose a}} new {{classification}} for the entanglement in <b>graph</b> <b>states</b> based on generalized con- currence. The numerical {{results indicate that}} the eight different three-qubit <b>graph</b> <b>states</b> in three categories, 64 four-qubit <b>graph</b> <b>states</b> in five categories and 1024 five-qubit <b>graph</b> <b>states</b> are in ten classes. We also compare this classification with equivalence classes of these <b>graph</b> <b>states</b> under local complementation (LC) operator, and the obtained result suggests that classification by generalized concurrence is not in contradiction with the LC-rule. Comment: 5 pages, 1 figur...|$|R
40|$|AbstractWe {{address the}} problem of {{generating}} a minimal <b>state</b> <b>graph</b> from a program, without building the whole <b>state</b> <b>graph.</b> Minimality is considered here with respect to bisimulation. A generation algorithm is derived and illustrated. Applications concern program verification and control synthesis in reactive program compilation...|$|E
40|$|We {{present a}} new {{approach}} for using a theorem-prover to verify the correctness of protocols and distributed algorithms. The method compares a <b>state</b> <b>graph</b> of the implementation with a specification which is a <b>state</b> <b>graph</b> representing the desired abstract behavior. The steps in the specification correspond to atomic transactions, which are not atomic in the implementation. The method relie...|$|E
40|$|Checking {{that a given}} finite state program {{satisfies}} {{a linear}} temporal logic property is suffering in many cases from a severe space and time explosion. One way {{to cope with this}} is to reduce the <b>state</b> <b>graph</b> used for model checking. We define an equivalence relation between infinite sequences, based on infinite traces such that for each equivalence class, either all or none of the sequences satisfy the checked formula. We present an algorithm for constructing a <b>state</b> <b>graph</b> that contains at least one representative sequence for each equivalence class. This allows applying existing model checking algorithms to the reduced <b>state</b> <b>graph</b> rather than on the larger full <b>state</b> <b>graph</b> of the program. It also allows model checking under fairness assumptions, and exploits these assumptions to obtain smaller state graphs. A formula rewriting technique is presented to allow coarser equivalence relation among sequences, such that less representatives are needed. ...|$|E
50|$|Graphs {{are often}} used in {{corporate}} annual reports {{as a form of}} impression management. In the United <b>States,</b> <b>graphs</b> {{do not have to be}} audited, as they fall under AU Section 550 Other Information in Documents Containing Audited Financial Statements.|$|R
40|$|We will {{formulate}} {{the problem}} of resolving spatial (space occupancy and support-stability) interactions in terms of tools developed in Operating Systems for the problems of deadlocks and synchronization. We show how to construct <b>state</b> <b>graphs</b> and to detect resource contentions and deadlocks from these <b>state</b> <b>graphs.</b> We describe an algorithm, called CONTAC, to deal with deadlocks where 'processes' represent the ordered motions of parts. The algorithm is a monitor-like process using preventative preemptive protocol to resolve higher-degree deadlocks. We develop the representation for knowledge about current allocations, pending requests, and synchronization constraints, to generate a contention-free sequence of actions. In this paper we focus on modeling deadlocks which are manifestations of spatial interactions...|$|R
40|$|Consistent {{and stable}} global states of clock {{synchronization}} {{are very important}} in distributed and parallel systems. This paper presents an innovative strategy and method to obtain stable global clock synchronization <b>state</b> <b>graphs</b> in asynchronous Internet environments. Our model will introduce the concept of clock precision difference {{as a means to}} evaluate running states of all clocks in this system and make this system  self-adaptive well. Finally, we introduce the concept of clock precision difference into global states analysis of clock synchronization and construct clock synchronization <b>state</b> <b>graphs</b> in order to evaluate distributed clock synchronization states. We also present detailed simulations of the strategy and mathematical analysis used on real Internet environments. <br /...|$|R
40|$|Abstract Checking {{that a given}} finite state program {{satisfies}} {{a linear}} temporal logic property is suffering in many cases from a severe space and time explosion. One way {{to cope with this}} is to reduce the <b>state</b> <b>graph</b> used for model checking. We define an equivalence relation between infinite sequences, based on infinite traces such that for each equivalence class, either all or none of the sequences satisfy the checked formula. We present an algorithm for constructing a <b>state</b> <b>graph</b> that contains at least one representative sequence for each equivalence class. This allows applying existing model checking algorithms to the reduced <b>state</b> <b>graph</b> rather than on the larger full <b>state</b> <b>graph</b> of the program. It also allows model checking under fairness assumptions, and exploits these assumptions to obtain smaller state graphs. A formula rewriting technique is presented to allow coarser equivalence relation among sequences, such that less representatives are needed. 1 Introduction When a program allows concurrent or independent activities, their executions are interleaved in many possible orders. It is often the case that a formula ' is insensitive to reordering some of the concurrent activities of the program, i. e., that any two sequences that are obtained from each other by such reordering, either both satisfy ' or both satisfy:'. This phenomenon allows reducing the <b>state</b> <b>graph</b> used for model checking by constructing a smaller <b>state</b> <b>graph</b> that represents only a subset of the interleaving sequences...|$|E
40|$|It needs much {{computation}} {{to develop}} a contact <b>state</b> <b>graph</b> and find an assembly sequence because polyhedral objects consist {{of a lot of}} vertices, edges, and faces. In this paper, we propose a new method to eliminate unnecessary contact states in the contact <b>state</b> <b>graph</b> corresponding to a robotic assembly task. In our method, the faces of polyhedral objects are triangulated, and the adjacency of each vertex, edge, and triangle between an initial contact state and a target contact state is defined. Then, this adjacency is used to create contact state graphs at different priorities. When a contact <b>state</b> <b>graph</b> is finished at a higher priority, a lot of unnecessary contact states can be eliminated because the contact <b>state</b> <b>graph</b> already includes at least one realizable assembly sequence. Our priority-based method is compared with a face-based method through statistically analyzing the contact state graphs obtained from different assembly tasks. Finally, our method results in a significant improvement in the final performance...|$|E
40|$|Abstract. In this article, {{we propose}} a global {{assignment}} theory for encoding <b>state</b> <b>graph</b> transformations. A constraint satisfaction framework is proposed that can guarantee necessary and sufficient {{conditions for a}} <b>state</b> <b>graph</b> assignment {{to result in a}} transformed <b>state</b> <b>graph</b> that is free of critical races. Performing transformations at the <b>state</b> <b>graph</b> level has the advantage that the requirements imposed on the initial STG are very weak. Unlike previous methods, the initial STG need not be a live, safe, nor a free choice net. The only requirement is that the corresponding initial <b>state</b> <b>graph</b> is finite, connected, and has a consistent state assignment. Hence, a very broad range of signal transition graphs can be synthesized. The transformations achievable using the proposed framework correspond to very complex transformations on signal transition graphs. Even transformations that convert a free choice net into a correct non-free choice net and a 1 -safe net into a correct 2 -safe net are feasible. Addition of transitions that do not follow the Petri net firing rule is also possible. Even though our method can search a large solution space, we will show {{that it is possible to}} solve the problem in an exact way in acceptable CPU times in many practical cases. 1...|$|E
40|$|A special {{configuration}} of <b>graph</b> <b>state</b> stabilizers, which contains only Pauli σ_X operators, is studied. The vertex sets ξ {{associated with such}} configurations are defined as what we call X-chains of <b>graph</b> <b>states.</b> The X-chains of a general <b>graph</b> <b>state</b> can be determined efficiently. They form a group structure such that one can obtain the explicit representation of <b>graph</b> <b>states</b> in the X-basis via the so-called X-chain factorization diagram. We show that <b>graph</b> <b>states</b> with different X-chain groups can have different probability distributions of X-measurement outcomes, which allows one to distinguish certain <b>graph</b> <b>states</b> with X-measurements. We provide an approach to find the Schmidt decomposition of <b>graph</b> <b>states</b> in the X-basis. The existence of X-chains in a subsystem facilitates error correction in the entanglement localization of <b>graph</b> <b>states.</b> In all of these applications, {{the difficulty of the}} task decreases with increasing number of X-chains. Furthermore, we show that the overlap of two <b>graph</b> <b>states</b> can be efficiently determined via X-chains, while its computational complexity with other known methods increases exponentially. Comment: This is the version after the publication of the paper in PRA. The title is changed according to PRA standard. Some typos are correcte...|$|R
40|$|We {{translate}} {{the action of}} local Clifford operations on <b>graph</b> <b>states</b> into transformations on their associated graphs - i. e. we provide transformation rules, <b>stated</b> in purely <b>graph</b> theoretical terms, which completely characterize the evolution of <b>graph</b> <b>states</b> under local Clifford operations. As we will show, there is essentially one basic rule, succesive application of which generates the orbit of any <b>graph</b> <b>state</b> under local unitary operations within the Clifford group...|$|R
40|$|In this paper, {{we define}} {{irregular}} bipolar fuzzy graphs and its various classifications. Size of regular bipolar fuzzy graphs is derived. The relation between highly and neighbourly irregular bipolar fuzzy graphs are established. Some basic theorems {{related to the}} <b>stated</b> <b>graphs</b> have also been presented...|$|R
40|$|Concurrent {{systems are}} {{commonly}} verified after computing a <b>state</b> <b>graph</b> describing all possible behaviors. Unfortunately, this <b>state</b> <b>graph</b> is often {{too large to}} be effectively built. Partial-order techniques {{have been developed to}} avoid combinatorial explosion while preserving the properties of interest. This paper investigates the combination of two such approaches, persistent sets and covering steps, and proposes partial enumeration algorithms that cumulate their respective benefits...|$|E
40|$|This paper {{presents}} how predicate abstraction can {{be applied}} to protocol verification. Predicate abstraction is a method for automatic construction of abstract <b>state</b> <b>graph.</b> Basic idea is to use n predicates 1, [...] ., n defined on concrete state space to generate abstract <b>state</b> <b>graph.</b> Model checking is a formal verification technique which has been successfully applied to protocol verification. But model checking can only be applied to finite state systems. Many interesting systems are innite state or number of states is so large that verification becomes infeasible. Predicate abstraction {{can be applied}} in verification of infinite state systems (or large finite state systems). Abstract <b>state</b> <b>graph</b> created by predicate abstraction can be used for verification of safety properties using a model checker. We provide simple examples of protocol verification using predicate abstraction...|$|E
40|$|In this paper, {{we present}} an {{approach}} for finding violations of safety properties of hybrid systems. Existing approaches search for com-plete system trajectories that begin from an initial state and reach some unsafe state. We present {{an approach that}} searches over seg-mented trajectories, consisting of a sequence of segments starting from any system state. Adjacent segments may have gaps, which our approach then seeks to narrow iteratively. We show that seg-mented trajectories are actually paths in the abstract <b>state</b> <b>graph</b> obtained by tiling the state space with cells. Instead of creating the prohibitively large abstract <b>state</b> <b>graph</b> explicitly, our approach implicitly performs a randomized search on it using a scatter-and-simulate technique. This involves repeated simulations, graph search to find likeliest abstract counterexamples, and iterative refinement of the abstract <b>state</b> <b>graph.</b> Finally, we demonstrate our technique {{on a number of}} case studies ranging from academic examples to models of industrial-scale control systems...|$|E
40|$|We {{investigate}} the entanglement properties of <b>graph</b> <b>states</b> which correspond to connected graphs by calculating the two-qubit and genuine three-qubit entanglement. Using the operational definition of <b>graph</b> <b>states,</b> we prove that in connected <b>graph</b> <b>states</b> of N qubits, if N> 2 {{there is no}} entanglement between any pair of qubits. Moreover, we show that if N> 3 there is no genuine three-qubit entanglement among every three qubits. Based on these results, we then propose the definition of maximally genuine multi-qubit entangled <b>states.</b> The connected <b>graph</b> <b>states</b> of four qubits is one but {{not the only one}} class of maximally genuine four-qubit entangled states...|$|R
40|$|We {{investigate}} {{the properties of}} different levels of entanglement in <b>graph</b> <b>states</b> which correspond to connected graphs. Combining the operational definition of <b>graph</b> <b>states</b> and the postulates of entanglement measures, we prove that in connected <b>graph</b> <b>states</b> of N qubits there is no genuine k-qubit entanglement, 2 ≤ k ≤ N − 1, among every k qubits. These results about connected <b>graph</b> <b>states</b> naturally lead {{to the definition of}} fully multi-qubit entangled states. We also find that the connected <b>graph</b> <b>states</b> of four qubits is one but not the only one class of fully four-qubit entangled states. 1...|$|R
40|$|Abstract. In this paper, {{we define}} {{irregular}} interval-valued fuzzy graphs and their various classifications. Size of regular interval-valued fuzzy graphs is derived. The relation between highly and neighbourly irregular interval-valued fuzzy graphs are established. Some basic theorems {{related to the}} <b>stated</b> <b>graphs</b> have also been presented...|$|R
