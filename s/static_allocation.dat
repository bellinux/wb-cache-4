245|351|Public
50|$|On FreeBSD, porters {{who need}} a UID for their package can pick a free one from the range 50 to 999 and then {{register}} the <b>static</b> <b>allocation.</b>|$|E
50|$|In {{an early}} work by Ruggieri and Murtagh, a region is created at the {{beginning}} of each function and deallocated at the end. They then use data flow analysis to determine a lifetime for each <b>static</b> <b>allocation</b> expression, and assign it to the youngest region that contains its entire lifetime.|$|E
5000|$|Where possible, {{automatic}} or <b>static</b> <b>allocation</b> {{is usually}} simplest because the storage is {{managed by the}} compiler, freeing the programmer of the potentially error-prone chore of manually allocating and releasing storage. However, many data structures can change in size at runtime, and since static allocations (and automatic allocations before C99) must have a fixed size at compile-time, there are many situations in which dynamic allocation is necessary. [...] Prior to the C99 standard, variable-sized arrays were a common example of this. (See the article on [...] {{for an example of}} dynamically allocated arrays.) Unlike automatic allocation, which can fail at run time with uncontrolled consequences, the dynamic allocation functions return an indication (in the form of a null pointer value) when the required storage cannot be allocated. (<b>Static</b> <b>allocation</b> that is too large is usually detected by the linker or loader, before the program can even begin execution.) ...|$|E
40|$|Current {{worst-case}} {{execution time}} (WCET) analyses {{do not support}} programs using dynamic memory allocation. This is mainly due to the unpredictability of cache performance introduced by standard memory allocators. To overcome this problem, algorithms have been proposed that precompute <b>static</b> <b>allocations</b> for dynamically allocating programs with known numeric bounds on the number and sizes of allocated memory blocks. In this paper, we present a novel algorithm for computing such <b>static</b> <b>allocations</b> that can cope with parametric bounds on the number and sizes of allocated blocks. To demonstrate the usefulness of our approach, we precompute <b>static</b> <b>allocations</b> {{for a set of}} existing real-time applications and academic examples. 1...|$|R
40|$|In this paper, {{we propose}} a <b>static</b> power <b>allocation</b> {{algorithm}} for a two-hop multi-input-multioutput (MIMO) amplify-and-forward (AF) relay {{system in which}} the interim channel state information over the first and the second hops is unavailable. Based on the path losses over the first and the second hops, this algorithm performs <b>static</b> power <b>allocation</b> between the source and relay nodes to maximize the equivalent received SNR of the system. We further investigate the optimal location of the relay node when the conventional fixed and the proposed optimal <b>static</b> power <b>allocation</b> schemes are applied. Our comparison between direct transmission and relaybased two-hop transmission indicates that whether the latter outperforms the former depends on a tradeoff between the received SNR gain and the multiplexing loss in the relay-based two-hop transmission scheme...|$|R
50|$|Rather than <b>static,</b> {{resource}} <b>allocation</b> is dynamic. This approach {{makes the}} company to change customers’ buying criteria or redefine the market itself in order to succeed within it.|$|R
50|$|In 1988, {{researchers}} began investigating {{how to use}} regions {{for safe}} memory allocation by introducing the concept of region inference, where the creation and deallocation of regions, {{as well as the}} assignment of individual <b>static</b> <b>allocation</b> expressions to particular regions, is inserted by the compiler at compile-time. The compiler is able to do this {{in such a way that}} it can guarantee dangling pointers and leaks do not occur.|$|E
5000|$|The term static {{efficiency}} belongs within neoclassical economics, which argues that explicit theoretical rationale of liberalisation {{is to achieve}} an efficient (<b>static)</b> <b>allocation</b> of resources. [...] In order to achieve this situation, there are three central assumptions within neoclassical economics that are indispensable for achieving an optimal allocation. These assumptions include that people are rational, both individuals and firms maximise utility, and everybody has full and relevant information, which they act upon independently.|$|E
5000|$|... program Example;type DimensionEnum = ( [...] deUnassigned, de2D, de3D, de4D [...] ); PointClass = class private Dimension: DimensionEnum; public X: Integer; Y: Integer; Z: Integer; T: Integer; public (* {{prototype}} of constructors *) constructor Create (...) constructor Create(AX, AY: Integer); constructor Create(AX, AY, AZ: Integer); constructor Create(AX, AY, AZ, ATime: Integer); constructor CreateCopy(APoint: PointClass); (* {{prototype of}} destructors *) destructor Destroy; end;constructor PointClass.Create (...)begin // {{implementation of a}} generic, non argument constructor Self.Dimension := deUnassigned;end;constructor PointClass.Create(AX, AY: Integer);begin // implementation of a, 2 argument constructor Self.X := AX; Y := AY; Self.Dimension := de2D;end;constructor PointClass.Create(AX, AY, AZ: Integer);begin // implementation of a, 3 argument constructor Self.X := AX; Y := AY; Self.X := AZ; Self.Dimension := de3D;end;constructor PointClass.Create(AX, AY, AZ, ATime: Integer);begin // implementation of a, 4 argument constructor Self.X := AX; Y := AY; Self.X := AZ; T := ATime; Self.Dimension := de4D;end;constructor PointClass.CreateCopy(APoint: PointClass);begin // implementation of a, [...] "copy" [...] constructor APoint.X := AX; APoint.Y := AY; APoint.X := AZ; APoint.T := ATime; Self.Dimension := de4D;end;destructor PointClass.PointClass.Destroy;begin // implementation of a generic, non argument destructor Self.Dimension := deUnAssigned;end;var (* variable for <b>static</b> <b>allocation</b> *) S: PointClass; (* variable for dynamic allocation *) D: ^PointClass;begin (* of program *) (* object lifeline with <b>static</b> <b>allocation</b> *) S.Create(5, 7); (* do something with [...] "S" [...] *) S.Destroy; [...] (* object lifeline with dynamic allocation *) D = new PointClass, Create(5, 7); (* do something with [...] "D" [...] *) dispose D, Destroy;end. (* of program *) ...|$|E
30|$|However actual {{spectrum}} occupancy measurements {{show that}} the frequency band scarcity is not {{a result of the}} heavy usage of the spectrum but is rather due to the inefficient <b>static</b> frequency <b>allocation</b> pursued by the regulators.|$|R
3000|$|Finally, when <b>static</b> bit <b>allocation</b> {{is adopted}} where {{an equal number}} of equal-width {{intervals}} is constructed in all D feature dimensions, the total distance deviation incurred by the continuous-to-discrete mapping can be upper bounded by [...]...|$|R
40|$|Abstract—Various <b>static</b> {{resource}} <b>allocation</b> algorithms {{have been}} used in WDM networks to allocate resources such as wavelength channels, transmitters, receivers, and wavelength converters to a given set of static lightpath demands. However, although optimized resource allocations can be obtained, it remains an open issue how to determine which resources are the bottlenecks in achieving better performance. Existing <b>static</b> resource <b>allocation</b> algorithms do not explicitly measure the impact of changes of network resources or lightpath demands on the design objective. We propose such a measurement based on the Lagrangian relaxation framework. We use the optimized values of Lagrange multipliers as a direct measurement of the criticality of resources...|$|R
30|$|Training: Determine the α% {{most dynamic}} tone. And set <b>static</b> <b>allocation</b> {{for the rest}} of tone (static tone).|$|E
40|$|Motivated by our {{interactions}} with a leading manufacturer of computers, {{in this paper}} we consider <b>static</b> <b>allocation</b> as applied to the problem of minimizing the costs of outsourcing warranty services to repair vendors. Under <b>static</b> <b>allocation,</b> a manufacturer assigns each item to one of several contracted repair vendors; every time a particular item fails, it is sent to its preassigned vendor for repair. In our model, the manufacturer incurs a repair cost each time an item needs repair and also incurs a goodwill cost while items are undergoing repair. We model each service vendor as a finite population multi-server queueing system and formulate the resulting outsourcing problem as an integer-variable resource allocation problem. After establishing convexity results regarding the queue lengths at the repair vendors, we show that marginal allocation is optimal. Through a detailed computational study we compare the optimal algorithm with five <b>static</b> <b>allocation</b> heuristics in terms of time and optimality gap. Our study indicates that the optimal algorithm takes less than a minute to solve industry size problems on average. Further, the commonly used heuristics are far away from the optimal on average, thus emphasizing the benefits of the optimal allocation algorithm. We also compare the optimal <b>static</b> <b>allocation</b> to two simple dynamic allocation heuristics. The results of this study further validate the use of <b>static</b> <b>allocation</b> as a justifiable and easy-to-implement policy. Among other computational insights we show that when the number of items to be allocated is large, a single-server approximation leads to optimal allocations in most of the cases...|$|E
30|$|When {{the static}} SCH {{allocation}} policy is enforced (curves labeled as <b>static</b> <b>allocation),</b> {{which allows the}} allocation of service channels {{in such a way}} to nullify the inter-BSS interference, worse performances are achieved as compared to the hybrid scenario as well.|$|E
40|$|Connection {{management}} {{based on}} Quality of Service (QoS) offers opportunities for better resource allocation in networks providing service classes. "Negotiation " describes {{the process of}} cooperatively configuring application and network resources for an application's use. Complex and long-running applications can reduce the inefficiencies of <b>static</b> <b>allocations</b> by splitting resource use into "eras " bounded by renegotiation of QoS parameters. Renegotiation can be driven by either the application or the network in order to best match application and network dynamics. A key element in this process is a translation between differing perspectives on QoS maintained by applications and network service provision. We model translation with an entity called a "broker". Comment...|$|R
40|$|Microwave {{backhaul}} {{networks are}} the dominant technology used to connect together access and core networks for their flexibility and cost-effectiveness in deployment. Unfortunately, microwave backhaul networks {{are susceptible to}} interference and are statically managed leading to poor Quality of Service (QoS) {{in the form of}} high delays and loss as well as being inefficient on energy. The use of Software Defined Networking (SDN) is proposed to address these problems by dynamically managing resources to work around the interference and remove <b>static</b> <b>allocations.</b> Two new algorithms, CUT and OptiCUT were designed to compute an optimal topology, to minimise loss and delay {{while at the same time}} reducing power consumption...|$|R
40|$|This paper {{presents}} a Per-Packet Dynamic Channel Allocation scheme for multiple channels MAC protocols in a infra-structured wireless network. The proposed MAC protocols implicitly assume a <b>static</b> channel <b>allocation</b> for each Access Point in the network. Our scheme assigns the requested channels to the APs in a dynamic mode. Furthermore resources allocation is performed in an original Per-Packet way, instead of classical per-call methods. Performances of this idea, {{in terms of}} packets dropping probability and average number of used channels for non dropped activity, are analyzed in a simulative way. The results show a higher system efficiency in the resource use of the proposed algorithm {{in comparison to the}} <b>static</b> channel <b>allocation</b> schemes...|$|R
40|$|Parallel {{computation}} {{is fundamental}} to satisfy the performance requirements of advanced safety-critical systems. OpenMP is a good candidate to exploit the performance opportunities of parallel platforms. However, safety-critical systems are often based on <b>static</b> <b>allocation</b> strategies, whereas current OpenMP implementations are based on dynamic schedulers. This paper proposes two OpenMP-compliant <b>static</b> <b>allocation</b> approaches: an optimal but costly approach based on an ILP formulation, and a sub-optimal but tractable approach that computes a worst-case makespan bound close to the optimal one. This work is funded by the EU projects P-SOCRATES (FP 7 -ICT- 2013 - 10) and HERCULES (H 2020 /ICT/ 2015 / 688860), and the Spanish Ministry of Science and Innovation under contract TIN 2015 - 65316 -P. Peer ReviewedPostprint (author's final draft...|$|E
40|$|We {{propose a}} model of computation, based on data flow, that unifies several {{disparate}} programming phenomena, including local and shared variables, synchronised and buffered communication, reliable and unreliable channels, dynamic and <b>static</b> <b>allocation,</b> explicit and garbage-collected disposal, fine-grained and coarse-grained concurrency, and weakly and strongly consistent memory...|$|E
40|$|We present design {{patterns}} used by software {{components in the}} TinyOS operating system. They differ significantly from traditional software {{design patterns}} due to TinyOS's focus on <b>static</b> <b>allocation</b> and whole-program composition. We describe how nesC has evolved to support design patterns by including a few simple language primitives...|$|E
40|$|The {{tremendous}} {{growth as}} well as diversity of explicit knowledge, increased users'demands,diminished budgets, and galloping prices for subscribing to periodicals in combination with technological advancement {{have resulted in the}} development of "shared subscription" or " consortis based subscription" to journals everywhere in the world. Ther is a growing trend towards joint purchasing, consortia-based subscription agreements, collaboration and partnerships. Libraries faced with diminishing or at the best <b>static</b> <b>allocations</b> have to consider new ways of consolidating global resources amongst themselves in order to maximize their limited financial resources. This article discusses the concepts and modalities for cooperation through library consortia in a networked information environment and future prospects for library consortiafrom an Indian perspective...|$|R
40|$|In this paper, the {{performance}} evaluation of two Asynchorous Transfer Mode (ATM) scheduler strategies, <b>static</b> bandwidth <b>allocation</b> {{with and without}} heuristic approach are presented. Several experiments were carried out by using the ON-OFF distribution source model based on the ATM Various Bit Rate (VBR) servic...|$|R
40|$|In {{the present}} paper, we {{consider}} the problem of joint bandwidth (subcarriers) and power allocation for the downlink of a multi-user multi-cell OFDM cellular network. This resource allocation problem is formulated as a power minimization problem, subject to meeting the target rates of all users in the network. We develop a distributed solution to find the globally optimal allocation which determines the subcarrier and power allocation dynamically. In addition, we investigate the impact of reducing the complexity by {{reducing the number of}} degrees of freedom available in the optimization. In particular, we consider a <b>static</b> bandwidth <b>allocation</b> scheme, and a <b>static</b> power <b>allocation</b> scheme. The numerical results show that the penalty on network performance due to the reduction in the available degrees of freedom is not significant...|$|R
40|$|Abstract. We {{propose a}} model of computation, based on data flow, that unifies several {{disparate}} programming phenomena, including local and shared variables, synchronised and buffered communication, reliable and unreliable channels, dynamic and <b>static</b> <b>allocation,</b> explicit and garbage-collected disposal, fine-grained and coarse-grained concurrency, and weakly and strongly consistent memory...|$|E
40|$|We study {{real-time}} demand fulfillment for networks {{consisting of}} multiple local warehouses, where spare parts of expensive technical systems are kept on stock for customers with di??erent service contracts. Each service contract specifies a maximum response time {{in case of}} a failure and hourly penalty costs for contract violations. Part requests can be fulfilled from multiple local warehouses via a regular delivery, or from an external source with ample capacity via an expensive emergency delivery. The objective is to minimize delivery cost and penalty cost by smartly allocating items from the available network stock to arriving part requests. We propose a dynamic allocation rule that belongs to the class of one-step lookahead policies. To approximate the optimal relative cost, we develop an iterative calculation scheme that estimates the expected total cost over an infinite time horizon, assuming that future demands are fulfilled according to a simple <b>static</b> <b>allocation</b> rule. In a series of numerical experiments, we compare our dynamic allocation rule with the optimal allocation rule, and a simple but widely used <b>static</b> <b>allocation</b> rule. We show that the dynamic allocation rule has a small optimality gap and that it achieves an average cost reduction of 7. 9 % compared to the <b>static</b> <b>allocation</b> rule on a large test bed containing problem instances of real-life size...|$|E
40|$|In {{this paper}} a {{heuristics}} approach for task allocation in a distributed computing {{system has been}} discussed. This performs <b>static</b> <b>allocation</b> and provide near optimal results. The suggested algorithm is coded in Mat Lab and implemented on a Dual Core machine and found {{the performance of the}} developed algorithm is satisfactory. 1...|$|E
40|$|Using {{multiple}} independent networks (also {{known as}} rails) is an emerging technique to overcome bandwidth limitations and enhance fault tolerance of current high-performance parallel computers. In this paper we present and analyze various algorithms to allocate multiple communication rails, including <b>static</b> and dynamic <b>allocation</b> schemes. An analytical lower bound {{on the number}} of rails required for <b>static</b> rail <b>allocation</b> is shown. We also present an extensive experimental comparison of the behavior of various algorithms in terms of bandwidth and latency. We show that striping messages over multiple rails can substantially reduce network latency, depending on average message size, network load, and allocation scheme...|$|R
5000|$|The {{promise of}} higher returns from {{rebalancing}} to a <b>static</b> asset <b>allocation</b> {{was introduced by}} William Bernstein in 1996. It has since been shown to only exist under certain situations that investors {{are not able to}} predict. At other times rebalancing can reduce returns. Most agree that: ...|$|R
40|$|Abstract — In {{the present}} paper, we {{consider}} the problem of joint bandwidth (subcarriers) and power allocation for the downlink of a multi-user multi-cell OFDM cellular network. This resource allocation problem is formulated as a power minimization problem, subject to meeting the target rates of all users in the network. We develop a distributed solution to find the globally optimal allocation which determines the subcarrier and power allocation dynamically. In addition, we investigate the impact of reducing the complexity by {{reducing the number of}} degrees of freedom available in the optimization. In particular, we consider a <b>static</b> bandwidth <b>allocation</b> scheme, and a <b>static</b> power <b>allocation</b> scheme. The numerical results show that the penalty on network performance due to the reduction in the available degrees of freedom is not significant. I...|$|R
40|$|The {{traditional}} {{approach to the}} parallelization of linear algebra algorithms such as matrix multiplication and LU factorization calls for <b>static</b> <b>allocation</b> of matrix blocks to processing elements (PEs). Such algorithms suffer from two drawbacks : they {{are very sensitive to}} load imbalances between PEs and they make it difficult to take advantage of pipelining opportunities...|$|E
30|$|Based on {{the above}} observation, we propose a partial-dynamic MW-PCC (PD-MW-PCC) {{resource}} allocation algorithm. In this algorithm, only {{a subset of}} the tones is dynamically allocated with crosstalk canceller taps, while the other tones have a <b>static</b> <b>allocation.</b> In this way the computational complexity of the resource allocation algorithm is reduced. First we define static tones, and dynamic tones.|$|E
40|$|Studies {{have shown}} that a {{majority}} of parallel jobs do not effectively use avail-able resources to the fullest [4] [15]. One of the main reasons for the underuti-lization of hardware is that jobs are given a <b>static</b> <b>allocation</b> of processors with which to run their job, while the job itself may require a varying amount o...|$|E
40|$|Using {{multiple}} independent networks (also {{known as}} rails) is an emerging technique to overcome bandwidth limitations and enhance fault-tolerance of current high-performance clusters. We present and analyze various venues for exploiting multiple rails. Different rail access policies are presented and compared, including <b>static</b> and dynamic <b>allocation</b> schemes. An analytical lower bound {{on the number}} of networks required for <b>static</b> rail <b>allocation</b> is shown. We also present an extensive experimental comparison of the behavior of various allocation schemes in terms of bandwidth and latency. Striping messages over multiple rails can substantially reduce network latency, depending on average message size, network load and allocation scheme. The methods compared include a <b>static</b> rail <b>allocation,</b> a round-robin rail allocation, a dynamic allocation based on local knowledge, and a rail allocation that reserves both end-points of a message before sending it. The latter is shown to perform better than other methods at higher loads: up to 49 % better than localknowledge allocation and 37 % better than the round-robin allocation. This allocation scheme also shows lower latency and it saturates on higher loads (for messages large enough). Most importantly, this proposed allocation scheme scales well with the number of rails and message sizes...|$|R
30|$|Additionally, a <b>static</b> SCH <b>allocation</b> {{policy is}} {{foreseen}} for the scenario with only RSUs acting as WAVE providers. In fact, {{since they are}} statically placed {{and they can be}} connected by a wired infrastructure, service channels can be pre-allocated to RSUs in order to avoid their BSSs to be channel-overlappingc.|$|R
40|$|In {{traditional}} wireless systems, spectrum or frequency is {{allocated to}} licensed users over a geographic area. Within these constraints, spectrum {{is considered a}} scarce resource due to <b>static</b> spectrum <b>allocation.</b> Recent empirical studies of radio spectrum usage have shown that licensed spectrum is typically highly underutilized (Broderson et al., 2004...|$|R
