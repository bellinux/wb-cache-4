223|10000|Public
500|$|In the Sierpiński triangle, for any integer , {{the rows}} {{numbered}} by multiples of [...] have nonzero cells spaced at least [...] units apart. Therefore, {{because of the}} additive property of Rule 90, if an initial configuration consists of a finite pattern [...] of nonzero cells with width less than , then in steps that are multiples of , the configuration will consist of copies of [...] spaced at least [...] units from start to start. This spacing is wide enough to prevent the copies from interfering with each other. The number of copies {{is the same as}} the number of nonzero cells in the corresponding row of the Sierpiński triangle. Thus, in this rule, every pattern is a replicator: it generates multiple copies of itself that spread out across the configuration, eventually filling the whole array. Other rules including the Von Neumann universal constructor, Codd's cellular automaton, and Langton's loops also have replicators that work by carrying and copying a <b>sequence</b> <b>of</b> <b>instructions</b> for building themselves. In contrast, the replication in Rule 90 is trivial and automatic.|$|E
2500|$|Cf. in {{particular}} the first chapter titled: Algorithms, Turing Machines, and Programs. His succinct informal definition: [...] "...any <b>sequence</b> <b>of</b> <b>instructions</b> that can be obeyed by a robot, is called an algorithm" [...] (p.4).|$|E
5000|$|... doTogether - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{simultaneously}} ...|$|E
5000|$|... direct {{creation}} <b>of</b> whole <b>instructions</b> or <b>sequences</b> <b>of</b> <b>instructions</b> {{in memory}} ...|$|R
50|$|Most {{assemblers}} provide macros {{to generate}} common <b>sequences</b> <b>of</b> <b>instructions.</b>|$|R
5000|$|In {{event-driven}} programming, the programmer may write <b>sequences</b> <b>of</b> <b>instructions</b> {{to respond}} to events without specifying an overall sequence for the program.|$|R
5000|$|More formally, a <b>sequence</b> <b>of</b> <b>instructions</b> forms a basic block if: ...|$|E
5000|$|... while - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} while a given condition holds ...|$|E
5000|$|... for - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} a given {{number of times}} ...|$|E
5000|$|... "In a {{multiprogramming}} or multiprocessing environment, {{one or more}} <b>sequences</b> <b>of</b> <b>instructions</b> {{treated by}} a control program as an element {{of work to be}} accomplished by a computer." ...|$|R
40|$|The <b>sequence</b> <b>of</b> <b>instruction</b> and {{appropriate}} tools for novice learners of object-oriented programming {{has been extensively}} debated. This paper analyzes the learning environment for OO programmers, and presents {{a series of studies}} aimed at finding the <b>sequence</b> <b>of</b> <b>instruction</b> and the corresponding tool that best supports the learning of object-oriented programming, starting with objects first. The studies indicate that starting out with a tool with visualization of object behavior and predefined classes in a toy domain is preferable. After having learnt the basic OO concepts, the learners can proceed to an environment that supports definition of classes for modeling a real world domain. 1...|$|R
40|$|Identifying common {{features}} in Forth programs {{is important for}} those designing Forth machines and optimisers. In this paper we measure the behaviour of six large Forth programs and four small ones. We look at the ratio of user to system code, basic block lengths, common <b>instructions,</b> and common <b>sequences</b> <b>of</b> <b>instructions.</b> Our most important finding is that for most large programs, many (38. 4 %– 47. 6 % statically and 21. 8 %– 40. 9 % dynamically) basic blocks consist of only a single instruction, which hinders optimisation. We also show static measures <b>of</b> frequent <b>instructions</b> and <b>sequences</b> <b>of</b> <b>instructions</b> are more consistent across programs, and {{may be a better}} predictor of the behaviour of other programs than dynamic measures. ...|$|R
5000|$|... forAllInOrder - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} iterating over the given collection ...|$|E
5000|$|... if - {{execute a}} <b>sequence</b> <b>of</b> <b>instructions</b> {{sequentially}} only under a given condition ...|$|E
50|$|The code may be source code, {{assembly}} code {{or some other}} <b>sequence</b> <b>of</b> <b>instructions.</b>|$|E
5000|$|Return-oriented {{programming}} requires these <b>sequences</b> <b>of</b> <b>instructions</b> called gadgets to {{end with}} a [...] instruction {{in this way the}} attacker can put a <b>sequence</b> <b>of</b> addresses where these gadgets resides and as soon as a [...] instruction is met the control flow will proceed to the next gadget of the list.|$|R
5000|$|... #Subtitle level 3: Atomizing Turing quintuples into a <b>sequence</b> <b>of</b> Post-Turing <b>instructions</b> ...|$|R
40|$|The study {{investigated}} the effectiveness of computer-based simulation versus laboratory experience, and the <b>sequencing</b> <b>of</b> <b>instruction,</b> in teaching logic circuits. The two independent variables in this study were: (1) method <b>of</b> <b>instruction,</b> a nominal variable with two categories (computer-based simulation and laboratory experience); and (2) <b>sequencing</b> <b>of</b> <b>instruction,</b> a nominal variable with two categories (reading following lab or simulation experience and reading prior to lab or simulation experience). The dependent variable was the posttest score;A 2 x 2 factorial design {{was used in this}} study. The data were analyzed using the analysis of variance procedure. It was found that the <b>sequence</b> <b>of</b> <b>instruction</b> was an importance factor in teaching logic circuits. It was significant at the 0. 001 alpha level. The students who did the activity (laboratory or computer simulation) first, followed by the reading assignment, scored significantly higher on the posttest as compared to those who received identical material in the opposite sequence. No significant difference was found between the two methods of instruction: laboratory or computer simulation. Also, there was no significant interaction between method <b>of</b> <b>instruction</b> and <b>sequence</b> <b>of</b> instruction;In order to gain greater insight into the students 2 ̆ 7 cognitive process, the posttest items were classified into two categories: (1) knowledge, and (2) transfer. It was found that only the 2 ̆ 7 transfer 2 ̆ 7 items contributed to {{the difference between the two}} sequential groups. The study concluded that exploratory type of experiential activity prior to formal instruction results in better conceptual learning and better transfer as compared to the reverse sequence...|$|R
50|$|Input: A <b>sequence</b> <b>of</b> <b>instructions</b> (mostly three-address code).Output: A list {{of basic}} blocks with each three-address {{statement}} in exactly one block.|$|E
50|$|The <b>sequence</b> <b>of</b> <b>instructions</b> {{listed above}} will allow two robots with labels 0 and 1 to meet after O(n2c) time steps.|$|E
5000|$|Conceptually [...] "wrap" [...] {{the full}} <b>sequence</b> <b>of</b> <b>{{instructions}}</b> around the loop, using FADD and FMUL instructions to drive calculations through the pipelines.|$|E
5000|$|Needs {{computing}} power {{to generate the}} display from a <b>sequence</b> <b>of</b> drawing <b>instructions</b> ...|$|R
30|$|A National Research Council study, America’s Lab Report (NRC, [2006]), {{provides}} {{a possible explanation}} for the results described in the aforementioned studies. The study found that the <b>sequence</b> <b>of</b> <b>instruction</b> and role <b>of</b> laboratory activities often are experienced as separate. The NRC report recommended greater use of integrated instructional units.|$|R
40|$|Presents {{a variant}} of Genetic Programming that evolves {{imperative}} computer programs as linear <b>sequences</b> <b>of</b> <b>instructions,</b> {{in contrast to the}} more traditional functional expressions or syntax trees. This book serves as a reference for researchers, but also contains sufficient introduction for students and those who are new to the fiel...|$|R
5000|$|... {{hardware}} compilers (also {{known as}} syntheses tools) are compilers whose output is {{a description of}} the hardware configuration instead of a <b>sequence</b> <b>of</b> <b>instructions.</b>|$|E
50|$|When {{writing a}} multi-threaded program, the {{programmer}} may write each thread as a <b>sequence</b> <b>of</b> <b>instructions</b> without specifying {{the timing of}} any instruction relative to instructions in other threads.|$|E
5000|$|This <b>sequence</b> <b>of</b> <b>instructions</b> generates position-independent code because [...] {{takes an}} instruction-pointer-relative {{immediate}} operand describing the offset in bytes {{of the target}} instruction from the next instruction (in this case 0).|$|E
40|$|The paper {{presents}} {{the argument for}} four years of arts education, grades two through five, and offers ArtsBridge founding director Keith Fowler's "step rationale" for the <b>sequencing</b> <b>of</b> <b>instruction</b> from Studio Art through Drama. It explains some of the diffuclties encountered and Fowler's solutions for setting up a four-year arts outreach program...|$|R
40|$|This paper {{presents}} {{a study of}} the performance limits of data value reuse. Two types of data value reuse are considered: instruction-level reuse and trace-level reuse. The former reuses instances <b>of</b> single <b>instructions</b> whereas the latter reuses <b>sequences</b> <b>of</b> <b>instructions</b> as an atomic unit. Two different scenarios are considered: an infinite resource machine and a machine with a limited instruction window. The results show that reuse is abundant in the SPEC applications. Instructionlevel reuse may provide a significant speedup but it drops dramatically when the reuse latency is considered. Trace-level reuse has in general less potential for the unlimited window scenario but it is much more effective for the limited window configuration. This is because trace-level reuse, in addition to reduce the execution latency, increases the effective instruction window size, by avoiding the fetch and execution <b>of</b> <b>sequences</b> <b>of</b> <b>instructions.</b> Overall, trace-level reuse is shown to be a promising approa [...] ...|$|R
5000|$|Oversight: provide {{accountability}} {{by conducting}} pre-and post-testing of language proficiency in schools at <b>sequenced</b> intervals <b>of</b> <b>instruction.</b>|$|R
50|$|A {{computer}} {{program is a}} <b>sequence</b> <b>of</b> <b>instructions</b> that are executed by a CPU. While simple processors execute instructions one after another, superscalar processors are capable of executing several instructions at once.|$|E
5000|$|... “an {{intuitive}} {{definition of}} an acceptable <b>sequence</b> <b>of</b> <b>instructions</b> {{is one in which}} each instruction is precisely defined so that the robot is guaranteed to be able to obey it” (p. 6) ...|$|E
5000|$|Lay out the {{shortest}} <b>sequence</b> <b>of</b> <b>instructions</b> for performing one {{instance of the}} desired calculation, allowing for two-cycle memory latency, and the driving of the floating-point modules with explicit FADD and FMUL instructions.|$|E
40|$|Abstract. We {{discuss a}} proof-producing {{compiler}} for {{a subset of}} higher order logic. The translation validation is automatic, {{and is based on}} Hoare rules derived from a compositional semantics for <b>sequences</b> <b>of</b> <b>instructions</b> for an ARM-like machine. Partial and total correctness are dealt with. The main focus is on issues in the intermediate level and back-end of the compiler. ...|$|R
50|$|Machine code optimization: These {{analyze the}} {{executable}} task {{image of the}} program after all of an executable machine code has been linked. Some of the techniques {{that can be applied}} in a more limited scope, such as macro compression (which saves space by collapsing common <b>sequences</b> <b>of</b> <b>instructions),</b> are more effective when the entire executable task image is available for analysis.|$|R
40|$|We {{present an}} {{implementation}} technique {{for a class}} of bottom-up logic procedures. The technique is based on code trees. It is intended to speed up most important and costly operations, such as subsumption and resolution. As a case study, we consider the forward subsumption problem which is the bottleneck of many systems implementing first order logic. In order to efficiently implement subsumption, we specialize subsumption algorithms at run time, using the abstract subsumption machine. The abstract subsumption machine makes subsumption-check using <b>sequences</b> <b>of</b> <b>instructions</b> {{that are similar to}} the WAM instructions [War 83]. It gives an efficient implementation of the "clause at a time" subsumption problem. To implement subsumption on the "set at a time" basis we combine <b>sequences</b> <b>of</b> <b>instructions</b> in code trees. We show that this technique yields a new way of indexing clauses. Some experimental results are given. The code trees technique may be used in various procedures, including binar [...] ...|$|R
