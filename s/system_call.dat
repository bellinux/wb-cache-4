1132|10000|Public
5|$|Most {{software}} {{that runs on}} Linux can run on FreeBSD using an optional built-in compatibility layer. Hence, most Linux binaries can be run on FreeBSD, including some proprietary applications distributed only in binary form. This compatibility layer is not an emulation; Linux's <b>system</b> <b>call</b> interface is implemented in the FreeBSD's kernel and hence, Linux executable images and shared libraries are treated the same as FreeBSD's native executable images and shared libraries. Additionally, FreeBSD provides compatibility layers for several other Unix-like operating systems, in addition to Linux, such as BSD/OS and SVR4, however, it is more common for users to compile those programs directly on FreeBSD.|$|E
25|$|Using {{a special}} <b>system</b> <b>call</b> instruction. This {{technique}} requires special hardware support, which common architectures (notably, x86) may lack. <b>System</b> <b>call</b> instructions {{have been added}} to recent models of x86 processors, however, and some operating systems for PCs make use of them when available.|$|E
25|$|MIPS I has two {{instructions}} for software to signal an exception: <b>System</b> <b>Call</b> and Breakpoint. <b>System</b> <b>Call</b> {{is used by}} user mode software to make kernel calls; and Breakpoint is used to transfer control to a debugger via the kernel's exception handler. Both instructions have a 20-bit Code field that can contain operating environment-specific information for the exception handler.|$|E
30|$|We obtain <b>system</b> <b>calls</b> of executables by {{monitoring}} their running behaviours in Cuckoo sandbox. As modern malicious executables {{always are}} equipped with sophisticated packers, the <b>system</b> <b>calls</b> we got contain not only the <b>system</b> <b>calls</b> of originals but also the <b>system</b> <b>calls</b> of packers which obfuscate the distribution of original <b>system</b> <b>calls.</b> It limits the detection accuracy. To retain detection accuracy, in this paper, we first reduce the obfuscation from packers by extracting sensitive <b>system</b> <b>calls.</b> At the beginning, we give a definition of our sensitive <b>system</b> <b>calls.</b>|$|R
5000|$|Version 7 of the Research UNIX System {{provided}} about 50 <b>system</b> <b>calls,</b> 4.4BSD provided about 110, and SVR4 had around 120. The {{exact number}} of <b>system</b> <b>calls</b> {{varies depending on}} the operating system version. More recent systems have seen incredible {{growth in the number}} of supported <b>system</b> <b>calls.</b> Linux 3.2.0 has 380 <b>system</b> <b>calls</b> and FreeBSD 8.0 has over 450.|$|R
5000|$|The Hubble Space Telescope uses a {{short-term}} <b>system</b> <b>called</b> SPSS and a long-term planning <b>system</b> <b>called</b> Spike.|$|R
25|$|Kang, D-K., Fuller, D., and Honavar, V. Learning Misuse and Anomaly Detectors from <b>System</b> <b>Call</b> Frequency Vector Representation. IEEE International Conference on Intelligence and Security Informatics. Springer-Verlag Lecture Notes in Computer Science, Springer-Verlag. Vol. 3495. pp.511–516, 2005.|$|E
25|$|OS/360 and successors {{include a}} <b>system</b> <b>call</b> XCTL (transfer control) that {{performs}} a similar function to exec. Except for type 4 SVC, this usage is rare. More common {{is the use}} of LINK or ATTACH to invoke a load module without terminating the current load module. In particular, TSO invokes commands with ATTACH, sharing memory.|$|E
25|$|Linux and Windows are two {{operating}} systems that use supervisor/user mode. To perform specialized functions, user mode code must perform a <b>system</b> <b>call</b> into supervisor mode {{or even to}} the kernel space where trusted code of the operating system will perform the needed task and return the execution back to the userspace.|$|E
40|$|This work {{describes}} {{different methods}} of fault injection, {{the principles of}} <b>system</b> <b>calls</b> in operating <b>system</b> Linux and the Systemtap tool. The main aim of thesis is design {{and implementation of the}} application that work on the principle of fault injection into the <b>system</b> <b>calls</b> using Systemtap tool. Implemented application automatically identifies the existing <b>system</b> <b>calls</b> with the error return values, which are then replaced the original <b>system</b> <b>calls</b> return value...|$|R
30|$|Since the <b>system</b> <b>calls</b> of malware {{variants}} {{which are}} in the same families share similar distributions, and there exist a significant difference of the distributions between malware and benign (Jang et al. 2015), some <b>system</b> <b>calls</b> are used more often in malware variants. We propose to extract a series of sensitive <b>system</b> <b>calls,</b> embed their frequencies into a vector and adopt deep learning method to solve these problems. Some recent researches also used deep learning for vulnerability or malware detection, which achieve better accuracy, such as (Li et al. 2018; Kolosnjaji et al. 2016), etc. We first extract a series of <b>system</b> <b>calls</b> which is more sensitive to malicious behaviours based information entropy theory. We <b>call</b> these <b>system</b> <b>calls</b> as sensitive <b>system</b> <b>calls</b> which reduce a degree of obfuscation. Then we embed the <b>system</b> <b>calls</b> to a vector by using occurrence frequency. The sensitive <b>system</b> <b>calls</b> will later be sent to a neural network for training or classification. Next we prefer to use multi-layers neural networks to train a model. Finally we use the model to detect and classify malware variants.|$|R
30|$|The {{sensitive}} <b>system</b> <b>calls</b> {{is a part}} of <b>system</b> <b>calls</b> which highly frequently act in unpacked malicious executables {{while not}} in unpacked legitimate ones.|$|R
25|$|The kernel's {{interface}} is {{a low-level}} abstraction layer. When a process makes requests of the kernel, {{it is called}} a <b>system</b> <b>call.</b> Kernel designs differ in how they manage these system calls and resources. A monolithic kernel runs all the operating system instructions in the same address space for speed. A microkernel runs most processes in user space, for modularity.|$|E
25|$|OpenBSD randomizes various {{behaviors}} of applications, making them less predictable {{and thus more}} difficult to attack. For example, PIDs are created and associated randomly to processes; the bind <b>system</b> <b>call</b> uses random port numbers; files are created with random inode numbers; and IP datagrams have random identifiers. This approach also helps expose bugs in the kernel and in user space programs.|$|E
25|$|Functions {{are also}} {{sometimes}} moved across rings {{in the other}} direction. The Linux kernel, for instance, injects a vDSO section in processes which contains functions that would normally require a <b>system</b> <b>call,</b> i.e. a ring transition. But instead of doing a syscall, these functions use static data provided by the kernel which prevents {{the need for a}} ring transition which is more lightweight than a syscall. The function gettimeofday can be provided this way.|$|E
40|$|Models {{based on}} <b>system</b> <b>calls</b> are a popular and common ap-proach to {{characterize}} the run-time behavior of programs. For example, <b>system</b> <b>calls</b> are used by intrusion detection systems to detect software exploits. As another example, policies based on <b>system</b> <b>calls</b> are used to sandbox appli-cations or to enforce access control. Given that malware represents a significant security threat for today’s comput-ing infrastructure, {{it is not surprising}} that <b>system</b> <b>calls</b> were also proposed to distinguish between benign processes and malicious code. Most proposed malware detectors that use <b>system</b> <b>calls</b> follow a program-centric analysis approach. That is, they build models based on specific behaviors of individual appli-cations. Unfortunately, it is not clear how well these mod...|$|R
5000|$|... 's10brand' {{provides}} a Solaris 10 environment on an OpenSolaris or Oracle Solaris 11 system, including translation from Solaris 10 <b>system</b> <b>calls</b> to OpenSolaris/Oracle Solaris 11 <b>system</b> <b>calls</b> ...|$|R
50|$|In most <b>systems,</b> <b>system</b> <b>calls</b> {{can only}} be made from userspace processes, while in some systems, OS/360 and successors for example, privileged system code also issues <b>system</b> <b>calls.</b>|$|R
25|$|In computing, a <b>system</b> <b>call</b> is how {{a process}} {{requests}} a service from an operating system's kernel {{that it does not}} normally have permission to run. System calls provide the interface between a process and the operating system. Most operations interacting with the system require permissions not available to a user level process, e.g. I/O performed with a device present on the system, or any form of communication with other processes requires the use of system calls.|$|E
25|$|Typical {{computer}} systems today use hardware-enforced rules about what programs {{are allowed to}} access what data. The processor monitors the execution and stops a program that violates a rule (e.g., a user process that is about to read or write to kernel memory, and so on). In systems that lack support for capabilities, processes are isolated from each other by using separate address spaces. Calls from user processes into the kernel are regulated by requiring them {{to use one of}} the above-described <b>system</b> <b>call</b> methods.|$|E
25|$|Linus Torvalds {{is married}} to Tove Torvalds (née Monni)—a six-time Finnish {{national}} karate champion—whom he first met {{in the autumn of}} 1993. Linus was running introductory computer laboratory exercises for students and instructed the course attendees to send him an e-mail as a test, to which Tove responded with an e-mail asking for a date. Tove and Linus were later married and have three daughters, Patricia Miranda (born 1996), Daniela Yolanda (born 1998), and Celeste Amanda (born 2000), two of whom were born in the United States. The Linux kernel's reboot <b>system</b> <b>call</b> accepts their dates of birth (written in hexadecimal) as magic values.|$|E
5000|$|... 'solaris8' {{provides}} a Solaris 8 environment on a Solaris 10 system, including translation from Solaris 8 <b>system</b> <b>calls</b> to Solaris 10 <b>system</b> <b>calls</b> (available only on SPARC systems) ...|$|R
50|$|As {{part of its}} {{internal}} IT infrastructure, BNR also created an email <b>system</b> <b>called</b> COCOS (COrporate COmmunication System), and a powerful relational database <b>system</b> <b>called</b> GERM (General Entity-Relationship Model).|$|R
30|$|This insight {{is based}} on an {{important}} observation that the average distribution of sensitive <b>system</b> <b>calls</b> of unpacked malicious executables is nearly the same as packed ones, which means that our sensitive <b>system</b> <b>calls</b> also low frequently act in packers, as a deduction of our approach. So based on this deduction, we use the sensitive <b>system</b> <b>calls</b> as representation of malicious executables.|$|R
25|$|A <b>system</b> <b>call</b> is a {{mechanism}} {{that is used}} by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from supervisor mode to protected mode. This is where the operating system performs actions like accessing hardware devices or the memory management unit. Generally the operating system provides a library that sits between the operating system and normal programs. Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to supervisor mode. System calls include close, open, read, wait and write.|$|E
25|$|A rootkit can modify data {{structures}} in the Windows kernel using a method known as direct kernel object manipulation (DKOM). This method {{can be used to}} hide processes. A kernel mode rootkit can also hook the System Service Descriptor Table (SSDT), or modify the gates between user mode and kernel mode, in order to cloak itself. Similarly for the Linux operating system, a rootkit can modify the <b>system</b> <b>call</b> table to subvert kernel functionality. It's common that a rootkit creates a hidden, encrypted filesystem in which it can hide other malware or original copies of files it has infected. Operating systems are evolving to counter the threat of kernel-mode rootkits. For example, 64-bit editions of Microsoft Windows now implement mandatory signing of all kernel-level drivers {{in order to make it}} more difficult for untrusted code to execute with the highest privileges in a system.|$|E
2500|$|... fork (<b>system</b> <b>call),</b> make a {{new process}} (but with the same executable) ...|$|E
5000|$|<b>System</b> <b>calls</b> {{that create}} a file, but fail if the file already exists. (<b>System</b> <b>calls</b> are {{available}} from languages such as C or C++, and shell scripts can make use of noclobber) ...|$|R
50|$|The System/3 (1969) ran a disk-based batch {{operating}} <b>system</b> <b>called</b> SCP (5702-SC1). IBM introduced for the S/3 {{an online}} program called CCP ("Communications Control Program.") which was {{started as a}} batch program. The IBM System/32 (1975) ran a disk-based operating <b>system</b> <b>called</b> SCP ("System Control Program.") The IBM System/38 (1978) ran an operating <b>system</b> <b>called</b> CPF ("Control Program Facility") that was much more advanced than SSP and not particularly similar.|$|R
500|$|Instead {{of having}} <b>system</b> <b>calls</b> {{specifically}} for process management, Plan 9 provides the [...] file system. Each process {{appears as a}} directory containing information and control files which can be manipulated by the ordinary file IO <b>system</b> <b>calls.</b>|$|R
2500|$|... man manual {{pages for}} each command, library component, <b>system</b> <b>call,</b> header file, etc.|$|E
2500|$|Standard {{names of}} such {{functions}} in C are execl, execle, execlp, execv, execve, and execvp (see below), but not [...] "exec" [...] itself. The Linux kernel has one corresponding <b>system</b> <b>call</b> named [...] "execve", whereas all aforementioned functions are user-space wrappers around it.|$|E
2500|$|In Unix-like {{operating}} systems, [...] is {{the command}} and <b>system</b> <b>call</b> which may change the access permissions to file system objects (files and directories). It may also alter special mode flags. The request is filtered by the umask. The name is an abbreviation of change mode.|$|E
50|$|A similar <b>system</b> <b>called</b> MobilePay {{has been}} {{operated}} by Danske Bank in Denmark since 2013. It has gained considerable popularity with about 1.6 million users by mid-2015. Another similar <b>system</b> <b>called</b> Vipps {{was introduced in}} Norway in 2015.|$|R
5000|$|Instead {{of having}} <b>system</b> <b>calls</b> {{specifically}} for process management, Plan 9 provides the [...] file system. Each process {{appears as a}} directory containing information and control files which can be manipulated by the ordinary file IO <b>system</b> <b>calls.</b>|$|R
40|$|For {{the past}} 30 + years, <b>system</b> <b>calls</b> {{have been the}} de facto {{interface}} used by applications to request services from the operating <b>system</b> kernel. <b>System</b> <b>calls</b> have almost universally been implemented as a synchronous mechanism, where a special processor instruction is used to yield userspace execution to the kernel. In {{the first part of}} this paper, we evaluate the performance impact of traditional synchronous <b>system</b> <b>calls</b> on <b>system</b> intensive workloads. We show that synchronous <b>system</b> <b>calls</b> negatively affect performance in a significant way, primarily because of pipeline flushing and pollution of key processor structures (e. g., TLB, data and instruction caches, etc.). We propose a new mechanism for applications to request services from the operating system kernel: exception-less <b>system</b> <b>calls.</b> They improve processor efficiency by enabling flexibility in the scheduling of operating system work, which in turn can lead to significantly increased temporal and spacial locality of execution in both user and kernel space, thus reducing pollution effects on processor structures. Exception-less <b>system</b> <b>calls</b> are particularly effective on multicore processors. They primarily target highly threaded server applications, such as Web servers and database servers. We present FlexSC, an implementation of exceptionless <b>system</b> <b>calls</b> in the Linux kernel, and an accompanying user-mode thread package (FlexSC-Threads), binary compatible with POSIX threads, that translates legacy synchronous <b>system</b> <b>calls</b> into exception-less ones transparently to applications. We show how FlexSC improves performance of Apache by up to 116 %, MySQL by up to 40 %, and BIND by up to 105 % while requiring no modifications to the applications. ...|$|R
