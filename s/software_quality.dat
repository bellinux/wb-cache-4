3819|1861|Public
25|$|Stephen H. Kan. Metrics and Models in <b>Software</b> <b>Quality</b> Engineering. Addison-Wesley, Boston, MA, second edition, 2002.|$|E
25|$|Historically, the structure, {{classification}} and terminology of {{attributes and}} metrics applicable to <b>software</b> <b>quality</b> management have been derived or {{extracted from the}} ISO 9126-3 and the subsequent ISO 25000:2005 quality model, also known as SQuaRE. Based on these models, the Consortium for IT <b>Software</b> <b>Quality</b> (CISQ) has defined five major desirable structural characteristics needed {{for a piece of}} software to provide business value: Reliability, Efficiency, Security, Maintainability and (adequate) Size.|$|E
25|$|However, the {{distinction}} between measuring and improving <b>software</b> <b>quality</b> in an embedded system (with emphasis on risk management) and <b>software</b> <b>quality</b> in business software (with emphasis on cost and maintainability management) is becoming somewhat irrelevant. Embedded systems now often include a user interface and their designers are as much concerned with issues affecting usability and user productivity as their counterparts who focus on business applications. The latter are in turn looking at ERP or CRM system as a corporate nervous system whose uptime and performance are vital {{to the well-being of}} the enterprise. This convergence is most visible in mobile computing: a user who accesses an ERP application on their smartphone is depending on the quality of software across all types of software layers.|$|E
40|$|The SPL {{paradigm}} promises high <b>quality</b> <b>software</b> through systematic assets reuseContext! The SPL paradigm promises high <b>quality</b> <b>software</b> through systematic assets reuseContext! The SPL paradigm promises high <b>quality</b> <b>software</b> through systematic assets reuse! Q: How {{to ensure}} such quality? Context! The SPL paradigm promises high <b>quality</b> <b>software</b> through systematic assets reuse! Q: How to ensure such quality? Context! The SPL paradigm promises high <b>quality</b> <b>software</b> through systematic assets reuse! Q: How to ensure such quality...|$|R
40|$|Existing {{proposals}} for <b>software</b> product <b>quality</b> {{have not been}} underpinned by the sort of empirical theory and supporting models that are found in most scientific endeavours. The present proposal provides a set of axioms and supporting <b>software</b> and <b>quality</b> models needed to construct a comprehensive model for <b>software</b> product <b>quality.</b> This model has been developed using a requirements-design-implementation strategy {{to ensure that it}} meets the needs of a number of different interest groups. A significant advantage of the proposed model is that it allows the problem of <b>software</b> product <b>quality</b> to be broken down into intellectually manageable chunks. Other important features of the model are that it has enough structure to characterize <b>software</b> product <b>quality</b> for large and complex systems and it will support practical specification and verification of quality requirements...|$|R
40|$|Software {{has become}} an {{integral}} part of telecommunication systems over the last 30 years. The relative cost for software in the systems has increased continuously over these years. This increase has meant that there has been a need to also focus on evaluation and prediction of different <b>software</b> <b>qualities</b> of the systems. This paper presents three studies evaluating <b>software</b> <b>qualities</b> in different ways. The firsts study focuses on performance and touches upon reliability. The reliability aspect is discussed in more detail in the second case study. Finally, the third study presents methods to estimate the fault content from software inspections. These studies are presented as representative examples of th...|$|R
25|$|The dual structural/functional {{dimension}} of <b>software</b> <b>quality</b> {{is consistent with}} the model proposed in Steve McConnell's Code Complete which divides software characteristics into two pieces: internal and external quality characteristics. External quality characteristics are those parts of a product that face its users, where internal quality characteristics are those that do not.|$|E
25|$|The structure, {{classification}} and terminology of {{attributes and}} metrics applicable to <b>software</b> <b>quality</b> management have been derived or {{extracted from the}} ISO 9126-3 and the subsequent ISO/IEC 25000:2005 quality model. The main focus is on internal structural quality. Subcategories have been created to handle specific areas like business application architecture and technical characteristics such as data access and manipulation or the notion of transactions.|$|E
25|$|One common {{limitation}} to the Function Point methodology {{is that it}} is {{a manual}} process and therefore it can be labor-intensive and costly in large scale initiatives such as application development or outsourcing engagements. This negative aspect of applying the methodology may be what motivated industry IT leaders to form the Consortium for IT <b>Software</b> <b>Quality</b> focused on introducing a computable metrics standard for automating the measuring of software size while the IFPUG keep promoting a manual approach as most of its activity rely on FP counters certifications.|$|E
40|$|Software Product Line (SPL) {{engineering}} is one approach for addressing customization and variability for products. However, current approaches and research, while often addressing feature modeling and component variability, insufficiently address difficulties and additional complexity {{with respect to}} entity model variability, which negatively impacts various <b>software</b> <b>qualities,</b> such as correctness, reusability, maintainability, testability, and evolvability. This paper presents a solution approach with an integrated mechanism providing a consistent view to capture data variability in entity models, while hiding and decoupling components from superfluous data elements via adapter generation. An eHealth SPL case study is presented supporting adapter generation with differential entity conversion. The results show that with this approach, entity model variability can be effectively addressed and desirable <b>software</b> <b>qualities</b> preserved. 1...|$|R
5000|$|... 1+1 Magazine awarded it {{with the}} <b>Software</b> Marketing <b>Quality</b> award.|$|R
40|$|Abstract. Unit test environments are today’s {{state of}} the art for many {{programming}} languages to keep the <b>software’s</b> <b>quality</b> above a certain level. However, the <b>software’s</b> syntactic <b>quality</b> necessary for the developers themselves is not covered by the aforementioned frameworks. This paper presents a tool realized using the DSL framework MontiCore for automatically validating easily extensible coding guidelines for any domain specific language or even general purpose languages like C++ and its application in an automotive R&D project where a German OEM and several suppliers were involved. Moreover, it was exemplary applied on UML/P-based sequence charts as well. ...|$|R
25|$|This view of <b>software</b> <b>quality</b> on {{a linear}} {{continuum}} {{has to be}} supplemented by the identification of discrete Critical Programming Errors. These vulnerabilities may not fail a test case, {{but they are the}} result of bad practices that under specific circumstances can lead to catastrophic outages, performance degradations, security breaches, corrupted data, and myriad other problems (Nygard, 2007) that make a given system de facto unsuitable for use regardless of its rating based on aggregated measurements. A well-known example of vulnerability is the Common Weakness Enumeration, a repository of vulnerabilities in the source code that make applications exposed to security breaches.|$|E
25|$|Cost Management: As in {{any other}} fields of engineering, an {{application}} with good structural <b>software</b> <b>quality</b> costs less to maintain and is easier to understand and change in response to pressing business needs. Industry data demonstrate that poor application structural quality in core business applications (such as enterprise resource planning (ERP), customer relationship management (CRM) or large transaction processing systems in financial services) results in cost and schedule overruns and creates waste {{in the form of}} rework (up to 45% of development time in some organizations). Moreover, poor structural quality is strongly correlated with high-impact business disruptions due to corrupted data, application outages, security breaches, and performance problems.|$|E
2500|$|To view, explore, analyze, and {{communicate}} <b>software</b> <b>quality</b> measurements, concepts and techniques of information visualization provide visual, interactive means useful, in particular, if several <b>software</b> <b>quality</b> measures {{have to be}} related to each other or to components of a software or system. For example, software maps represent a specialized approach that [...] "can express and combine information about software development, <b>software</b> <b>quality,</b> and system dynamics".|$|E
40|$|The {{problem of}} {{certifying}} <b>software's</b> <b>quality</b> is being attacked in three distinct ways: (1) accrediting personnel, (2) certifying the development organization, and (3) assessing {{the goodness of}} the software. Here, we will discuss these approaches and briefly discuss how hybrid approaches {{can be derived from}} them {{depending on the type of}} software that needs certification...|$|R
40|$|This paper {{considers}} {{the impact of}} consumer copying of computer software when there is asymmetric information about product quality. In particular, the paper: (1) examines how the presence of copying can enhance the feasibility of production of high <b>quality</b> <b>software</b> when <b>quality</b> is a priori unknown to consumers and (2) explores the novel possibility that a software producer can signal product quality via its copyright enforcement decision. Under certain conditions, when there is asymmetric information about product quality, providers of high <b>quality</b> <b>software</b> can be made strictly better off with less than full copyright enforcement; in some cases, they do not produce {{at all in the}} absence of copying. Piracy Copying Intellectual property <b>Software</b> Product <b>quality</b> Signaling Copyright...|$|R
40|$|Aspects are {{a natural}} {{evolution}} of the object-oriented paradigm. They provide a solution to some difficulties you may have encountered with modularizing your object-oriented code: sometimes functionality just doesn't fit! You've probably found yourself repeating the same lines of code in lots of different object-oriented classes because those classes each need that functionality, and so you can't easily wrap {{it up in a}} single place. Good examples of this kind of code are audit trails, transaction handling, concurrency management, and so on. You can now modularize such code with aspects. Aspect-Oriented Software Development (AOSD). Provides unique and advanced program structuring and modularization techniques. The implementation of software applications using AOSD techniques results in a better implementation structure which has an impact on many important <b>software</b> <b>qualities</b> such as enhanced reusability and reduced complexity. In turn, these <b>software</b> <b>qualities</b> lead to an improved software development lifecycle and, hence, to better software...|$|R
2500|$|Omar Alshathry, Helge Janicke, [...] "Optimizing <b>Software</b> <b>Quality</b> Assurance," [...] compsacw, pp.87–92, 2010 IEEE 34th Annual Computer Software and Applications Conference Workshops, 2010.|$|E
2500|$|... "A {{science is}} as mature as its {{measurement}} tools," [...] (Louis Pasteur in [...] ). Measuring <b>software</b> <b>quality</b> {{is motivated by}} at least two reasons: ...|$|E
2500|$|In {{the context}} of {{software}} engineering, <b>software</b> <b>quality</b> refers to two related but distinct notions that exist wherever quality is defined in a business context: ...|$|E
40|$|Abstract. Engineering multi-agent systems (MAS) {{is known}} to be a complex task. One of the reasons lays in the {{complexity}} to combine mul-tiple concerns that a MAS is expected to address, such as system func-tionality, coordination, robustness, etc. A well-recognized approach to manage system complexity is the use of self-adaptive (SA) mechanisms. Self-adaptation allows to adjust the system behavior in order to achieve certain <b>software</b> <b>qualities</b> (optimization, fault-tolerance, etc.). The key idea behind self-adaptation is complexity management through separa-tion of concerns. In this paper we introduce SA-MAS, an architectural approach that integrates the functionalities provided by a MAS with <b>software</b> <b>qualities</b> offered by a SA solution. The paper presents a ref-erence model for SA-MAS and applies it to a Mobile learning case, in which we deal with robustness properties. In addition, we apply formal verification techniques as an approach to guarantee the requirements of the SA-MAS application. ...|$|R
40|$|An {{integral}} part of test-driven software development is utilizing testcases to ensure the <b>software’s</b> <b>quality.</b> However, as testsuites grow larger, they tend to grow beyond control and are no longer easily comprehended. In this position paper, we propose to employ dynamic analysis and abstractions in reconstructing scenario diagrams from such testsuites. We discuss several challenges and suggest solutions to tackle these issues. 1...|$|R
40|$|Software Product Line (SPL) {{engineering}} is one approach for addressing customization and variability for software products. However, current state-of-the-art often focuses on feature modeling and component variability while insufficiently addressing data model variability difficulties and their associated complexity. Various <b>software</b> <b>qualities,</b> such as correctness, reusability, maintainability, testability, and evolvability, are negatively impacted. In this article the Approach for Data Model Variability (ADMV) is described {{which provides a}} unified and systematic methodology for providing a consistent view to capture data variability in data models. Adapter generation hides and decouples components from superfluous data elements and supports SPL data integration with the potentially multifarious external systems and devices that a SPL may need to consider. An eHealth SPL case study is presented supporting adapter generation with differential data conversion and data integration with medical devices. The results show that with this approach, data model variability and data integration can be effectively addressed and desirable <b>software</b> <b>qualities</b> preserved...|$|R
2500|$|Although the {{concepts}} {{presented in this}} section are applicable to both structural and functional <b>software</b> <b>quality,</b> measurement of the latter is essentially performed through testing [...]|$|E
2500|$|<b>Software</b> <b>quality</b> {{measurement}} quantifies to {{what extent}} a software program or system rates along each of these five dimensions. An aggregated measure of <b>software</b> <b>quality</b> can be computed through a qualitative or a quantitative scoring scheme or a mix of both and then a weighting system reflecting the priorities. This view of <b>software</b> <b>quality</b> being positioned on a linear continuum is supplemented by the analysis of [...] "critical programming errors" [...] that under specific circumstances can lead to catastrophic outages or performance degradations that make a given system unsuitable for use regardless of rating based on aggregated measurements. Such programming errors found at the system level represent up to 90% of production issues, whilst at the unit-level, even if far more numerous, programming errors account for less than 10% of production issues. As a consequence, code quality without {{the context of the}} whole system, as W. Edwards Deming described it, has limited value.|$|E
2500|$|One of the {{challenges}} in defining quality is that [...] "everyone feels they understand it" [...] and other definitions of <b>software</b> <b>quality</b> could be based on extending the various descriptions {{of the concept of}} quality used in business.|$|E
40|$|Engineering multi-agent systems (MAS) {{is known}} to be a complex task. One of the reasons lays in the {{complexity}} to combine multiple concerns that a MAS is expected to address, such as system functionality, coordination, robustness, etc. A well-recognized approach to manage system complexity is the use of self-adaptive (SA) mechanisms. Self-adaptation allows to adjust the system behavior in order to achieve certain <b>software</b> <b>qualities</b> (optimization, fault-tolerance, etc.). The key idea behind self-adaptation is complexity management through separation of concerns. In this paper we introduce SA-MAS, an architectural approach that integrates the functionalities provided by a MAS with <b>software</b> <b>qualities</b> oered by a SA solution. The paper presents a reference model for SA-MAS and applies it to a Mobile learning case, in which we deal with robustness properties. In addition, we apply formal verication techniques as an approach to guarantee the requirements of the SA-MAS application. On the conferens webpage with the title "Formal Verification of Robustness in a Self-Adaptive MAS: Mobile Learning Case Study" AMULET...|$|R
40|$|In the {{software}} engineering literature, {{there are numerous}} maturity models for assessing and evaluating a set of software processes. By contrast, there is no corresponding maturity model for assessing the <b>quality</b> of a <b>software</b> product. The design of such a model to assess the <b>quality</b> of a <b>software</b> product therefore represents a new research challenge in software engineering. Our main {{goal is to make}} available to industry (and consumers) a maturity model for assessing and improving the <b>quality</b> of the <b>software</b> product. This <b>Software</b> Product <b>Quality</b> Maturity Model (SPQMM) consists of three quality maturity submodels (viewpoints) that can be used not only once {{the software}} product has been delivered, but also throughout the life-cycle: • <b>Software</b> Product Internal <b>Quality</b> Maturity Model- SPIQMM, • <b>Software</b> Product External <b>Quality</b> Maturity Model - SPEQMM, and • Software Product Quality-in-Use Maturity Model- SPQiUMM In this thesis, we introduce the <b>Software</b> Product <b>Quality</b> Maturity Model (SPQMM), which could be used from three different viewpoints: the <b>software</b> product internal <b>quality,</b> the <b>software</b> product external <b>quality,</b> and the <b>software</b> product <b>quality</b> in-use. This quality maturity model is a quantitative model, and it based on the ISO 9126 (<b>software</b> product <b>quality</b> measures), ISO 15026 (software integrity levels), IEEE Std. 1012 (software verification and validation) and on six-sigma concepts. To build such a quality maturity model, we have combined the set of quality measures into a single number for each quality characteristic by assuming that all the measures for a single quality characteristic have an equal weight in the computation of a single value for that quality characteristic (they all make an equal contribution), yielding a quality level for that quality characteristic. The resulting quality level is then transformed based on the software integrity level into a sigma value positioned within a quality maturity level...|$|R
40|$|The {{software}} refactoring {{process is}} intended to en-hance the <b>quality</b> of a <b>software,</b> by improving its understandability, performance etc. We adopt the framework of [24]in order to model and analyze <b>software</b> <b>qualities,</b> to determine what software refac-toring transformations are most appropriate. In ad-dition, we use software metrics in order to evalu-ate the <b>qualities</b> of a <b>software</b> system quantitatively. Our framework adopts and extends work reported in [27]. ...|$|R
2500|$|<b>Software</b> <b>quality</b> {{measurement}} {{is about}} quantifying {{to what extent}} a system or software rates along these dimensions. The analysis can be performed using a qualitative or quantitative approach or a mix of both to provide an aggregate view [...]|$|E
2500|$|<b>Software</b> <b>quality</b> {{measurement}} {{is about}} quantifying {{to what extent}} a system or software possesses desirable characteristics. This can be performed through qualitative or quantitative means or a mix of both. In both cases, for each desirable characteristic, there are a set of measurable attributes the existence of which {{in a piece of}} software or system tend to be correlated and associated with this characteristic. For example, an attribute associated with portability is the number of target-dependent statements in a program. More precisely, using the Quality Function Deployment approach, these measurable attributes are the [...] "hows" [...] that need to be enforced to enable the [...] "whats" [...] in the <b>Software</b> <b>Quality</b> definition above.|$|E
2500|$|The {{dependence}} tree between <b>software</b> <b>quality</b> {{characteristics and}} their measurable attributes {{is represented in}} the diagram on the right, where each of the 5 characteristics that matter for the user (right) or owner of the business system depends on measurable attributes (left): ...|$|E
40|$|Unit test environments are today's {{state of}} the art for many {{programming}} languages to keep the <b>software's</b> <b>quality</b> above a certain level. However, the <b>software's</b> syntactic <b>quality</b> necessary for the developers themselves is not covered by the aforementioned frameworks. This paper presents a tool realized using the DSL framework MontiCore for automatically validating easily extensible coding guidelines for any domain specific language or even general purpose languages like C++ and its application in an automotive R&D project where a German OEM and several suppliers were involved. Moreover, it was exemplary applied on UML/P-based sequence charts as well. Comment: 13 pages, 7 figures. Symposium on Automotive/Avionics Systems Engineering 2009 (SAASE 09). San Diego, California, USA, October 200...|$|R
5000|$|Systematic reuse can enable {{significant}} <b>software</b> productivity, <b>quality,</b> {{and cost}} improvements. Reuse has two closely related facets: ...|$|R
5000|$|Source-code metrics {{are related}} with {{software}} developer activity to {{gain insight into}} developer-specific effects on <b>software</b> code <b>quality.</b>|$|R
