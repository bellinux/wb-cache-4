18|137|Public
50|$|A special-order <b>software</b> <b>item</b> {{is known}} as a Programming Request Price Quotation or PRPQ.|$|E
5000|$|Medical {{software}} is any <b>software</b> <b>item</b> or system used within a medical context, such as: ...|$|E
5000|$|The Institute of Electrical and Electronics Engineers {{defines the}} term feature in IEEE 829 as [...] "A {{distinguishing}} {{characteristic of a}} <b>software</b> <b>item</b> (e.g., performance, portability, or functionality)." ...|$|E
50|$|Among Equitrac's {{product lines}} are both {{hardware}} and <b>software</b> <b>items,</b> although Equitrac {{is known for}} its PageCounter line of document management consoles.|$|R
50|$|It {{was also}} {{possible}} to run some Radio-86RK, Microsha, Specialist <b>software</b> <b>items.</b> Also, a method of low-level adaptation of ZX Spectrum and MSX titles was developed and some <b>software</b> <b>items</b> were ported. In particular, Vector User magazine mentions a software package consisting of a disassembler, a processor that substitutes Z80-specific instructions that 8080 was lacking with macros {{and a set of}} macros. The package was used to port several ZX Spectrum titles, namely Chess Master, West Bank, Jumping Jack.|$|R
50|$|Fire-control system {{developers}} {{and most of}} the international (primarily NATO) ballistics communities are familiar with the mature NATO Armaments Ballistic Kernel (NABK) and other <b>software</b> component <b>items</b> that have emerged from the NABK development effort. The collection of these <b>software</b> <b>items</b> has been enhanced into the “suite” of NATO shareable fire control software.|$|R
50|$|The Defense Blood Standard System (DBSS) is a Food and Drug Administration (FDA)-regulated, Class II Medical Device {{designed}} to handle blood collection, processing and tracking procedures, and automation of standards and safeguards for the Military Health System (MHS) blood supply. DBSS is also identified by the FDA as a Blood Establishment <b>Software</b> <b>item.</b>|$|E
40|$|The {{objective}} of this document are: - uniquely identify the current official version of each <b>software</b> <b>item</b> - identify the versions of each <b>software</b> <b>item</b> which together constitute a specific version of a complete product - identify the build status of software products in development or delivered and installed - prevent simultaneous updating of multiple products {{in one or more}} locations - provide coordination for updating of multiple products in one or more locations - identify and track each change request from suggestion trough release. (AFNOR...|$|E
30|$|The {{nature of}} {{precipitates}} observed in plant tissues {{was determined by}} TEM (PHILIPS CM 12, FEI, Eindhoven, The Netherlands) equipped with an EDS-X-ray microanalysis system (EDAX, software EDAX Genesis, AMETEK, Mahwah, NJ, USA). The images were recorded by a Megaview G 2 CCD camera (<b>software</b> <b>iTEM</b> FEI, AnalySIS Image Processing, Olympus, Shinjuku-ku, Japan).|$|E
50|$|Registry Manager Allows user {{to modify}} {{many parts of}} the Windows Registry, such as to edit the Add/Remove <b>Software</b> <b>items,</b> shell {{extensions}} and registered file types.|$|R
50|$|All {{airborne}} {{and ground}} based flight control software is developed by TAI while payload hardware and <b>software</b> <b>items</b> are aimed {{to be developed}} by national sub-contractors, such as Aselsan and Milsoft.|$|R
50|$|Article 27 The {{contents}} of software registration announcement includes:1. Registration of <b>software</b> copyright;2. Registered <b>items</b> on <b>software</b> copyright contract;3. Information on invoke of <b>software</b> registration;4. Other <b>items.</b>|$|R
40|$|Debugging {{software}} {{often involves}} a removal process: {{the process of}} detection and removal of faults from a program. This paper gives an efficient procedure to detect all faults in a <b>software</b> <b>item</b> with high probability. The procedure is such that at any step the probability of leaving just one fault is equal to some specified value, a: the probability of leaving more than one fault is much smaller. It is found that, after eliminating the risk of early stopping, the probability of incomplete detection is then only slightly greater than a. The performance of the proposed procedure is demonstrated by simulation and by application to a real example...|$|E
40|$|Abstract. This paper {{addresses}} the visualization of the collaboration {{history in the}} development of software items using a simple interactive representation called Revision Tree. The visualization presents detailed information on a single <b>software</b> <b>item</b> with the intention of supporting the awareness of the project managers and developers about the item evolution and the collaboration taking place on its development. We considered that repositories of Software Configuration Management tools are the best information source to extract relevant information dealing with the relationships between the programmers and software items, as well as information regarding the creation of baselines, branches and revisions, and useful date and time details for the arrangement of the development timeline and collaboration representation...|$|E
40|$|Software {{testing is}} a process of {{evaluating}} a <b>software</b> <b>item</b> to detect the difference between given input and expected output. Software testing is one of the important step in software development lifecycle. Testing is a challenging task as it requires that user requirements be completely and properly understood before testing and also be able to test and deliver the product in less time. The {{purpose of this paper is}} to identify different ways in which testing time can be reduced thereby increasing accuracy. The paper focuses on automatically generating test cases which when generated manually requires more time and effort. The paper broadcasts various methods followed to generate test cases automatically and discusses the pros and cons of the methods used. Further the currently followed approach, the pros and cons of the approach is shown...|$|E
50|$|A {{software}} component is a functionally specialized unit of software—a collection of <b>software</b> <b>items</b> (functions, classes, etc.) grouped together to serve some distinct purpose. It {{serves as a}} constituent part of a whole software system or product. A product is one or more {{software component}}s that are assembled together and sold as a package. Components can be arranged in different combinations to form different products.|$|R
5000|$|Software Requirements Specification (SRS) - The {{requirements}} {{to be met}} by a Computer <b>Software</b> Configuration <b>Item</b> (CSCI) ...|$|R
40|$|The {{amount of}} {{software}} used on airborne platforms is increasing to unprecedented levels. With much larger amounts of software to design, control, and manage reasoning about overall systems performance becomes more difficult. This {{is a specific}} problem for Aerospace, {{as the use of}} newer technologies such as Integrated Modular Systems (IMS) and the need for high integrity systems further complicates the process and emphasizes the need to reason about system behaviour rather than specific <b>software</b> <b>items...</b>|$|R
40|$|The paper {{attempts}} {{to provide a}} comprehensive view of software testing. Software testing {{is the process of}} evaluation of a <b>software</b> <b>item</b> to detect differences between given input and expected output. Software testing provides a means to reduce errors, cut maintenance and overall software costs. It evaluates quality of a program and also for improving it, by identifying defects and problems. One of the major problems within software testing area is how to get a suitable set of cases to test a software system. This set should assure maximum effectiveness with the least possible number of test cases. There are now numerous testing techniques available for generating test cases. is the activity where the errors remaining from all the previous phases must be detected. Hence, testing perform a very critical role for software assurance quality...|$|E
40|$|We {{describe}} a modified Sag-Szekeres multidimensional quadrature algorithm and discuss its implementation as a general-purpose library procedure on serial and parallel architectures. Examples illustrate its effectiveness for both smooth and singular integrands. 1 Introduction In {{the practice of}} numerical quadrature, many different special-purpose algorithms are available and are efficient when used in the appropriate circumstances. We are interested in developing an algorithm for more general use as a <b>software</b> <b>item</b> in a software library. Specifically we seek a general purpose algorithm that accepts as wide a class of integrands and regions as possible, without grave compromise of efficiency. To this end, we have chosen one suitable for N-dimensional integration over a product region RN = R 1 1 Θ R 2 1 Θ ::::R N 1; where each R j 1 stands for one of [a; b]; [a; 1) (Γ 1; b] or (Γ 1; 1). The algorithm that we describe uses {{a modified version of}} the Sag-Szekeres ( [...] ...|$|E
40|$|The Computer Safety and Reliability Group at Lawrence Livermore National Laboratory (LLNL) is {{researching the}} {{evaluation}} of software used in safety-critical applications. This paper describes one, of {{the research and development}} efforts currently underway to model the software evaluation process and to develop a software evaluation tool. One of the primary techniques available for determining the safety of software proposed for use in safety-critical applications is to evaluate the software development process and the resulting products. This model of the evaluation process was influenced by several factors the underlying motivation was to identify, control and reduce the risk inherent in building safety-critical software systems. This prototype tool, the Software Evaluation Assistant (SEA), assists and guides evaluators as they analyze safety-critical software. SEA describes specific evaluation goals, provides a brief overview of the specific evaluation process, identifies potential, risks of not performing the evaluation, identifies the skills required to carry out {{the evaluation of}} a particular topic, identifies the material that should typically be available for the evaluation, and poses questions used to examine and rate the <b>software</b> <b>item...</b>|$|E
5000|$|Download Valley is {{a cluster}} of {{software}} companies in Israel, producing and delivering adware to be installed alongside downloads of other software. [...] The primary purpose is to monetize free software and downloads. These <b>software</b> <b>items</b> are commonly browser toolbars, adware, browser hijackers, spyware, and malware. Another group of products are download managers, possibly designed to induce or trick the user to install adware, when downloading a piece of desired software or mobile app from a certain source.|$|R
40|$|This talk {{began by}} {{presenting}} the Space Station Freedom Program (SSFP) {{definitions of software}} commonality and software reuse. Software commonality {{is the use of}} identical, interchangeable, functionally compatible, or similar <b>software</b> <b>items</b> to satisfy different sets of functionally similar requirements. The Software Support Environment (SSE) and the Data Management System (DMS) of onboard computing facilities are examples of SSFP common software. Software reuse is the use of identical, compatible, or similar <b>software</b> <b>items</b> in either modified or unmodified form to satisfy development activities at any point in the software life cycle; in other words, taking an existing item and applying it to another development activity. Software commonality has been mandated in several critical areas (such as the SSE and DMS) and a policy directive is under review. A software reuse study group was established in May 1988 to gather background information (see Level 2 Software Reuse Study that follows by Scott Herman). The SSFP Program Definition and Requirements Document contains requirements for SSE support in the area of software reuse. The SSE is a collection of tools and rules, and provides the common environment to be used for the life cycle management of all SSFP operational software...|$|R
40|$|The Starlink {{software}} collection currently runs {{on three}} different Unix platforms and contains around 100 separate <b>software</b> <b>items,</b> totaling 2. 5 million lines of code, {{in a mixture}} of languages. We have changed the build system from a hand-maintained collection of makefiles with hard-wired OS variants to a scheme involving feature-discovery via GNU Autoconf. As a result of this work, we have already ported the collection to MacOSX and Cygwin. This had some unexpected benefits and costs, and valuable lessons...|$|R
40|$|Predicting {{stability}} in object-oriented (OO) software, i. e., {{the ease with}} which a <b>software</b> <b>item</b> evolves while pre-serving its design, is a key feature for software maintenance. In fact, a well designed OO software must be able to evolve without violating the compatibility among versions, pro-vided that no major requirement reshuffling occurs. Sta-bility, like most quality factors, is a complex phenomenon and its prediction is a real challenge. In this paper, we present an approach which relies on the case-based reason-ing (CBR) paradigm and thus overcomes the handicap of in-sufficient theoretical knowledge on stability. The approach explores structural similarities between classes, expressed as software metrics, to guess their chances of becoming unstable. In addition, our stability model binds its value to the impact of changing requirements, i. e., the degree of class responsibilities increase between versions, quantified as the stress factor. As a result, the prediction mechanism favors the stability values for classes having strong struc-tural analogies with a given test class as well as a similar stress impact. Our predictive model is applied on a testbed made up of the classes from four major version of the Java API...|$|E
40|$|Software {{testing is}} the process of {{analyzing}} a <b>software</b> <b>item</b> to detect the differences between existing and required conditions (that is, bugs) and to evaluate the features of the software items. Software testing is an activity that should be done throughout the whole development process. Pairwise testing primarily targets faults caused by interactions between two parameters. However, some faults can be caused by interactions involving more than two parameters. Those faults cannot effectively be detected by pairwise testing. In this research work, we presented an algorithm to generate effective and less number of test cases using pairwise testing technique. The pairwise testing approach is basically {{based on the fact that}} the majority of possible errors/faults/bugs occur when two modules/parameters values interact. This proposed algorithm can be used efficiently in various realms of software products. In future we can plan to reduce the number of test cases by using the degree of coverage of three and four-wise in efficient way. Ultimately this will reduce the total number of test cases and provide only effective and efficient test case set and thus it will also save time for both software developers as well as for software testers...|$|E
40|$|This paper {{presents}} the tailoring of ECSS software product assurance requirements aiming at {{the development of}} scientific satellite payload embedded software by a Brazilian software supplier. The <b>software</b> <b>item,</b> named SWPDC, developed by DBA Engenharia de Sistemas LTDA within Software Factory context, {{is part of an}} ongoing research project, named Quality of Space Application Embedded Software - QSEE, developed by National Institute for Space Research INPE, with FINEP financial support. Among other aspects, QSEE project allowed to evaluate the adherence of a Software Factory processes to INPEs embedded software development process requirements. Although not familiar with space domain, the high maturity level of such supplier, CMMI- 3 formally evaluated, facilitates the Software Factory to comply with the requirements imposed by the custumer. Following the software verification and validation processes recommended by ECSS standards, an Independent Verification and Validation - IVV approach was used by INPE in order to delegate the software acceptance activities to a third party team. ECSS standard tailored form contributions along the execution of the project and the benefits provided to the supplier in terms of process improvements are also presented herein. Pages: 163 - 17...|$|E
40|$|This paper {{discusses}} a novel method called active browsing {{which increases}} the speed and accuracy with which a user may browse libraries for reusable software. Information inferred solely from the user’s normal actions is employed by the system to locate <b>software</b> <b>items</b> relevant to the user’s search goal. This paper describes our active browsing system and illustrates its operation with an example using typical browsing steps. An experiment, using an automated browsing agent, is described demonstrating that active browsing accelerates search. ...|$|R
5000|$|The {{benefits}} for software customers, SAM practitioners, IT support professionals and end users {{of a given}} <b>software</b> configuration <b>item</b> include, {{but are not limited}} to: ...|$|R
40|$|Quality {{assurance}} {{is one of}} {{the imperative}} non-functional programming requirements which numerous <b>software</b> <b>items</b> neglect to fulfill. Current software market is driven for the most part by earnestness and rivalry. This represents a major issue to software quality affirmation, consumer loyalty and reliability of the product items. One of the techniques to guarantee programming quality is a measurements based approach. Programming measurements have been utilized to quantitatively assess programming <b>items.</b> <b>Software</b> measurements proposed and utilized for procedural worldview have been discovered deficient for protest situated programming items mainly in light of the recognizing components of the question arranged worldview, for example, legacy and polymorphism. In this paper, we have analyzed various software metrics based on difefrent criteria. The result of analysis suggests user or developer that how the software should be change or improved to comply with standards...|$|R
40|$|The {{object-oriented}} (OO) paradigm has now reached maturity. OO software {{products are}} becoming more complex which makes their evolution effort and time consuming. In this respect, it has become important to develop tools that allow assessing the stability of OO software (i. e., {{the ease with which}} a <b>software</b> <b>item</b> can evolve while preserving its design). In general, predicting the quality of OO software is a complex task. Although many predictive models are proposed in the literature, we remain far from having reliable tools that can be applied to real industrial systems. The main obstacle for building reliable predictive tools for real industrial systems is the lackof representative samples. Unlike other domains where such samples can be drawn from available large repositories of data, in OO software the lack of such repositories makes it hard to generalize, to validate and to reuse existing models. Since universal models do not exist, selecting an appropriate quality model is a difficult, non-trivial decision for a company. In this paper, we propose two general approaches to solve this problem. They consist of combining/adapting a set of existing models. The process is driven by the context of the target company. These approaches are applied to OO software stability prediction. ...|$|E
40|$|One of {{the goals}} of {{software}} engineering is to provide what is necessary to write relevant, legible, useful descriptions of the systems to be developed, which will be the basis of successful developments. This goal was addressed both from informal approaches (providing in particular visual notations) and formal ones (providing a formal sound semantic basis). Informal approaches are often driven by a soft-ware development method, and, while formal approaches sometimes provide a user method, it is usually aimed at helping to use the proposed formalism when writing a specication. Our goal here is to provide a companion method that helps the user to understand the system to be developed, and to write the corresponding formal speci cations. We also aim at supporting visual presentations of formal specica-tions, so as to the best of both formal and informal worlds". We developed this method for the (logical-algebraic) specication languages Casl (Common Al-gebraic Specication Language, developed within the joint initiative CoFI) and for an extension for dynamic systems Casl-Ltl, and we believe it is general enough to be adapted to other paradigms. Another challenge is that a method that is too general does not encompass the dierent kinds of systems to be studied, while too many dierent specialized meth-ods result in partial views that may be dicult to integrate in a single global one. We deal with this issue by providing a limited number of instances of our method, tted for three dierent kinds of software items, while keeping a common "-structure and way of thinking. More precisely, we consider here that a <b>software</b> <b>item</b> may be a simple dynamic system, a structured dynamic system, or a data structure, and we show here how to support property-oriented (axiomatic) specications. We are thus providing support for the -bricks " tasks of specifying software artifacts that in our experience are needed for the development process. Our approach is illustrated with a lift case study...|$|E
40|$|Today {{surveillance}} {{systems are}} applied in many civil and defence areas and contain data fusion systems as embedded <b>software</b> <b>items.</b> Generally these systems are developed {{in accordance with}} different industry or governmental standards. Based on the experience the authors made within the development of several data fusion projects, this paper shows, how the software development standards can be tailored for a specific embedded data fusion process. It serves as a description of industry practice; identifies problems in applying software standards on the information fusion process, and demonstrates how existing standards need to be complemented/extended to include the area of information fusion...|$|R
40|$|This {{research}} {{addresses the}} problem of locating <b>software</b> <b>items</b> in extensive libraries. It aims {{to increase the speed}} and accuracy with which a user may browse software libraries for reusable code. The method proposed for this is called active browsing. The system monitors user actions, made within a normal browser, to infer an analogue representing the user's search goal. A relevancy measure is constructed from this analogue and used by the system to scan the library independently of the user and to evaluate potentially interesting components. The results affect the browser display to emphasize relevant components and thus aid search...|$|R
40|$|The NASA Ames-Dryden Flight Research Facility's Western Aeronautical Test Range will {{assign the}} flight test data display {{processing}} function to Mission Control Centers {{in order to}} allow research engineers to flexibly configure their own display-processing system to optimize performance during a flight research mission. This will leave the Telemetry Radar Acquisition and Processing System more time to acquire data. One of the processors chosen to handle the display-processing function is an IBM PC/AT-compatible, rack-mounted PC giving engineers a personalized set of analytic and display tools, developed on the basis of off-the-shelf PC/AT-compatible engineering hardware and <b>software</b> <b>items...</b>|$|R
40|$|Locating <b>software</b> <b>items</b> is di cult, {{even for}} {{knowledgeable}} software designers, when searching in large, complex and continuously growing libraries. This paper describes a technique, we term active browsing. An active browser suggests to the designer items it estimates {{to be close}} to the target of the search. The novel aspect of active browsing is that it is entirely unobtrusive: it infers its similarity measure from the designer's normal browsing actions, without any special input. Experiments are presented in which the active browsing system succeeds 40 % of the time in identifying the target before the designer has found it. An additional experiment indicates that this approach does, indeed, speed-up search. ...|$|R
