2103|1431|Public
25|$|From a {{collection}} of subtrees of a tree, one can define a <b>subtree</b> graph, which is an intersection graph that has one vertex per <b>subtree</b> and an edge connecting any two subtrees that overlap {{in one or more}} nodes of the tree. Gavril showed that the <b>subtree</b> graphs are exactly the chordal graphs.|$|E
25|$|Each {{internal}} node’s keys act as separation values which divide its subtrees. For example, if {{an internal}} node has 3 child nodes (or subtrees) {{then it must}} have 2 keys: a1 and a2. All values in the leftmost <b>subtree</b> will be less than a1, all values in the middle <b>subtree</b> will be between a1 and a2, and all values in the rightmost <b>subtree</b> will be greater than a2.|$|E
25|$|Choose a new {{separator}} (either {{the largest}} {{element in the}} left <b>subtree</b> or the smallest element in the right <b>subtree),</b> remove it from the leaf node it is in, and replace the element to be deleted with the new separator.|$|E
40|$|Over {{some types}} of trees with a given number of vertices, which trees {{minimize}} or maximize {{the total number of}} <b>subtrees</b> or leaf containing <b>subtrees</b> are studied. Here are some of the main results: (1) Sharp upper bound on the total number of <b>subtrees</b> (resp. leaf containing <b>subtrees)</b> among n-vertex trees with a given matching number is determined; as a consequence, the n-vertex tree with domination number γ maximizing the total number of <b>subtrees</b> (resp. leaf containing <b>subtrees)</b> is characterized. (2) Sharp lower bound on the total number of leaf containing <b>subtrees</b> among n-vertex trees with maximum degree at least Δ is determined; as a consequence the n-vertex tree with maximum degree at least Δ having a perfect matching minimizing the total number of <b>subtrees</b> (resp. leaf containing <b>subtrees)</b> is characterized. (3) Sharp upper (resp. lower) bound on the total number of leaf containing <b>subtrees</b> among the set of all n-vertex trees with k leaves (resp. the set of all n-vertex trees of diameter d) is determined. Comment: 17 pages, 9 figures. arXiv admin note: substantial text overlap with arXiv: 1204. 615...|$|R
50|$|Proof: Assume the contrary, i.e. that e {{belongs to}} an MST T1. Then {{deleting}} e will break T1 into two <b>subtrees</b> {{with the two}} ends of e in different <b>subtrees.</b> The remainder of C reconnects the <b>subtrees,</b> hence there is an edge f of C with ends in different <b>subtrees,</b> i.e., it reconnects the <b>subtrees</b> into a tree T2 with weight {{less than that of}} T1, because the weight of f is less than the weight of e.|$|R
50|$|A Binary Search Tree is a node-based data {{structure}} where each node contains a key and two <b>subtrees,</b> {{the left and}} right. For all nodes, the left <b>subtree's</b> key must be less than the node's key, and the right <b>subtree's</b> key must be greater than the node's key. These <b>subtrees</b> must all qualify as binary search trees.|$|R
25|$|Each {{internal}} node of a B-tree {{contains a}} number of keys. The keys act as separation values which divide its subtrees. For example, if an internal node has 3 child nodes (or subtrees) then it must have 2 keys: a1 and a2. All values in the leftmost <b>subtree</b> will be less than a1, all values in the middle <b>subtree</b> will be between a1 and a2, and all values in the rightmost <b>subtree</b> will be greater than a2.|$|E
25|$|<b>Subtree</b> {{isomorphism}} problem involves bipartite matching as sub-problem.|$|E
25|$|A <b>subtree</b> {{consisting}} of a single leaf node corresponds to an induced subgraph with a single vertex.|$|E
5000|$|... the <b>subtrees</b> in [...] and [...] are vertex-disjoint <b>subtrees</b> of [...] and , respectively.|$|R
40|$|Abstract. Tree mining has {{recently}} attracted {{a lot of}} interest in areas such as Bioinformatics, XML mining, Web mining, etc. We are mainly concerned with mining frequent induced and embedded <b>subtrees.</b> While more interesting patterns can be obtained when mining embedded <b>subtrees,</b> unfortunately mining such embedding relationships can be very costly. In this paper, we propose an efficient approach to tackle the complexity of mining embedded <b>subtrees</b> by utilizing a novel Embedding List representation, Tree Model Guided enumeration, and introducing the Level of Embedding constraint. Thus, when it is too costly to mine all frequent embedded <b>subtrees,</b> one can decrease the level of embedding constraint gradually up to 1, from which all the obtained frequent <b>subtrees</b> are induced <b>subtrees.</b> Our experiments with both synthetic and real datasets against two known algorithms for mining induced and embedded <b>subtrees,</b> FREQT and TreeMiner, demonstrate the effectiveness and the efficiency of the technique. ...|$|R
40|$|Tree {{structures}} are used extensively in domains such as computational biology, pattern recognition, XML databases, computer networks, and so on. One important problem in mining databases of trees {{is to find}} frequently occurring <b>subtrees.</b> However, because of the combinatorial explosion, the number of frequent <b>subtrees</b> usually grows exponentially {{with the size of}} the <b>subtrees.</b> In this paper, we present CMTreeMiner, a computationally e#cient algorithm that discovers all closed and maximal frequent <b>subtrees</b> in a database of rooted unordered trees. The algorithm mines both closed and maximal frequent <b>subtrees</b> by traversing an enumeration tree that systematically enumerates all <b>subtrees,</b> while using an enumeration DAG to prune the branches of the enumeration tree that do not correspond to closed or maximal frequent <b>subtrees.</b> The enumeration tree and the enumeration DAG are defined based on a canonical form for rooted unordered trees [...] the depth-first canonical form (DFCF) ...|$|R
25|$|A <b>subtree</b> rooted at a node labeled 0 {{corresponds}} to the union of the subgraphs defined by the children of that node.|$|E
25|$|Each <b>subtree</b> {{associates}} a graph vertex {{with a set}} of tree nodes. To define this formally, {{we represent}} each tree node as the set of vertices associated with it.|$|E
25|$|If ℓX(G) ≠ 0 {{then there}} exists a unique minimal G-invariant <b>subtree</b> XG of X. Moreover, XG {{is equal to the}} union of axes of {{hyperbolic}} elements of G.|$|E
40|$|AbstractA graph {{is called}} {{neighborhood}} chordal if {{the neighborhood of}} every vertex is chordal. A family of <b>subtrees</b> of a graph is called 2 -acyclic if the union of any two <b>subtrees</b> is acyclic. In the present paper we prove that every graph is an intersection graph of a Helly family of <b>subtrees</b> of a graph without triangles. In particular, we prove that a graph is an intersection graph of a Helly 2 -acyclic family of <b>subtrees</b> of a graph iff it is neighborhood chordal, in which case we present a simple greedy algorithm to construct the corresponding family of <b>subtrees.</b> In addition, we describe polynomial-time recognition algorithms for the intersection graphs and for the perfect intersection graphs of Helly families of <b>subtrees</b> in cacti graphs...|$|R
40|$|Tree {{structures}} are used extensively in domains such as computational biology, pattern recognition, XML databases, computer networks, and so on. One important problem in mining databases of trees {{is to find}} frequently occurring <b>subtrees.</b> Because of the combinatorial explosion, the number of frequent <b>subtrees</b> usually grows exponentially {{with the size of}} frequent <b>subtrees</b> and, therefore, mining all frequent <b>subtrees</b> becomes infeasible for large tree sizes. In this paper, we present CMTreeMiner, a computationally efficient algorithm that discovers only closed and maximal frequent <b>subtrees</b> in a database of labeled rooted trees, where the rooted trees can be either ordered or unordered. The algorithm mines both closed and maximal frequent <b>subtrees</b> by traversing an enumeration tree that systematically enumerates all frequent <b>subtrees.</b> Several techniques are proposed to prune the branches of the enumeration tree that do not correspond to closed or maximal frequent <b>subtrees.</b> Heuristic techniques are used to arrange the order of computation so that relatively expensive computation is avoided as much as possible. We study the performance of our algorithm through extensive experiments, using both synthetic data and data sets from real applications. The experimental results show that our algorithm is very efficient in reducing the search space and quickly discovers all closed and maximal frequent <b>subtrees...</b>|$|R
25|$|Intuitively, a tree {{decomposition}} {{represents the}} vertices {{of a given}} graph G as <b>subtrees</b> of a tree, {{in such a way}} that vertices in the given graph are adjacent only when the corresponding <b>subtrees</b> intersect. Thus, G forms a subgraph of the intersection graph of the <b>subtrees.</b> The full intersection graph is a chordal graph.|$|R
25|$|Every finite {{connected}} {{undirected graph}} {{has at least}} one Trémaux tree. One can construct such a tree by performing a depth-first search and connecting each vertex (other than the starting vertex of the search) to the earlier vertex from which it was discovered. The tree constructed in this way is known as a depth-first search tree. If uv is an arbitrary edge in the graph, and u is the earlier of the two vertices to be reached by the search, then v must belong to the <b>subtree</b> descending from u in the depth-first search tree, because the search will necessarily discover v while it is exploring this <b>subtree,</b> either from one of the other vertices in the <b>subtree</b> or, failing that, from u directly. Every finite Trémaux tree can be generated as a depth-first search tree: If T is a Trémaux tree of a finite graph, and a depth-first search explores the children in T of each vertex prior to exploring any other vertices, it will necessarily generate T as its depth-first search tree.|$|E
25|$|If X'i and X'j both {{contain a}} vertex v, then all nodes X'k of T in the (unique) path between X'i and X'j contain v as well. Equivalently, the tree nodes {{containing}} vertex v form a connected <b>subtree</b> of T.|$|E
25|$|The {{vertices}} {{in a bag}} can {{be thought}} of as the terminals of a subgraph of G, represented by the <b>subtree</b> of the tree decomposition descending from that bag. When G has bounded treewidth, it has a tree decomposition in which all bags have bounded size, and such a decomposition can be found in fixed-parameter tractable time. Moreover, it is possible to choose this tree decomposition so that it forms a binary tree, with only two child subtrees per bag. Therefore, it is possible to perform a bottom-up computation on this tree decomposition, computing an identifier for the equivalence class of the <b>subtree</b> rooted at each bag by combining the edges represented within the bag with the two identifiers for the equivalence classes of its two children.|$|E
40|$|Tree {{patterns}} are natural candidates for representing rules and hypotheses in many {{tasks such as}} information extraction and symbolic mathematics. A tree pattern is a tree with labeled nodes {{where some of the}} leaves may be labeled with variables, whereas a tree instance has no variables. A tree pattern matches an instance if there is a consistent substitution for the variables that allows a mapping of <b>subtrees</b> to matching <b>subtrees</b> of the instance. A finite union of tree patterns is called a forest. In this paper, we study the learnability of tree patterns from queries when the <b>subtrees</b> are unordered. The learnability is determined by the semantics of matching as defined by the types of mappings from the pattern <b>subtrees</b> to the instance <b>subtrees.</b> We first show that unordered tree patterns and forests are not exactly learnable from equivalence and subset queries when the mapping between <b>subtrees</b> is one-to-one onto, regardless of the computational power of the learner. Tree and forest pa [...] ...|$|R
40|$|The {{family tree}} of a Galton-Watson {{branching}} process may contain N-ary <b>subtrees,</b> i. e. <b>subtrees</b> whose vertices {{have at least}} N ≥ 1 children. For family trees without infinite N-ary <b>subtrees,</b> we study how fast N-ary <b>subtrees</b> of height t disappear as t → ∞. 1 Introduction and Statement of the Results The family tree associated with a Bieneimé-Galton-Watson process describes {{the evolution of a}} population in which each individual, independently of the others, creates k new individuals with probability pk (k = 0, 1, [...] .). We assume that at generation zero there is single ancestor...|$|R
5000|$|Name {{constraints}} are checked, to {{make sure}} the subject name is within the permitted <b>subtrees</b> list of all previous CA certificates and not within the excluded <b>subtrees</b> list of any previous CA certificate; ...|$|R
25|$|Tests of {{topology}} identify {{differences in}} tree topology {{taking into account}} the uncertainty in tree inference but they make no attempt at inferring how the differences came about. To infer the specifics of particular events, genome spectral or <b>subtree</b> pruning and regraft methods are required.|$|E
25|$|Searching {{is similar}} to searching a binary search tree. Starting at the root, the tree is recursively traversed from top to bottom. At each level, the search reduces its field of view to the child pointer (<b>subtree)</b> whose range {{includes}} the search value. A subtree's range {{is defined by the}} values, or keys, contained in its parent node. These limiting values are also known as separation values.|$|E
25|$|A <b>subtree</b> rooted at a node labeled 1 {{corresponds}} to the join of the subgraphs defined by the children of that node; that is, we form the union and add an edge between every two vertices corresponding to leaves in different subtrees. Alternatively, the join {{of a set of}} graphs can be viewed as formed by complementing each graph, forming the union of the complements, and then complementing the resulting union.|$|E
40|$|AbstractA chordal graph is the {{intersection}} graph {{of a family}} of <b>subtrees</b> of a tree, or, equivalently, it is the (edge-) intersection graph of leaf-generated <b>subtrees</b> of a full binary tree. In this paper, a generalization of chordal graphs from this viewpoint is studied: a graph G=(V,E) is representable if there is a family of <b>subtrees</b> {Sv}v∈V of a binary tree, such that uv∈E if and only if |Su∩Sv|⩾ 3...|$|R
40|$|Abstract. This paper {{addresses}} {{the following questions}} for a given tree T and integer d ≥ 2 : (1) What is the minimum number of degree-d <b>subtrees</b> that partition E(T) ? (2) What is the minimum number of degree-d <b>subtrees</b> that cover E(T) ? We answer the first question by providing an explicit formula for the minimum number of <b>subtrees,</b> and we describe a linear time algorithm that finds the corresponding partition. For the second question, we present a polynomial time algorithm that computes a minimum covering. We then establish a tight bound {{on the number of}} <b>subtrees</b> in coverings of trees with given maximum degree and pathwidth. Our results show that pathwidth is the right parameter to consider when studying coverings of trees by degree- 3 <b>subtrees.</b> We briefly consider coverings of general graphs by connected subgraphs of bounde...|$|R
40|$|In {{this paper}} we prove a &# 13; {{canonical}} partition theorem for weakly embedded <b>subtrees</b> {{of a given}} &# 13; regular tree. It was broght to my attention {{that there is a}} paper of &# 13; Milliken "Canonical partition theorem for strongly embedded <b>subtrees</b> of &# 13; regular trees" circulated in the 1980 's. This paper is still unpublished &# 13; and the results in my paper are discovered independently. Although it is &# 13; possible to conclude the result about weakly embedded <b>subtrees</b> from &# 13; Milliken's paper, we give a direct proof which works for both, weakly and &# 13; strongly embedded <b>subtrees...</b>|$|R
25|$|A tree {{decomposition}} {{of a given}} graph G consists of a tree and, for each tree node, {{a subset of the}} vertices of G called a bag. It must satisfy two properties: for each vertex v of G, the bags containing v must be associated with a contiguous <b>subtree</b> of the tree, and for each edge uv of G, there must be a bag containing both u and v.|$|E
25|$|The {{benefit of}} alpha–beta pruning {{lies in the}} fact that {{branches}} of the search tree can be eliminated. This way, the search time can be limited to the 'more promising' <b>subtree,</b> and a deeper search can be performed in the same time. Like its predecessor, it belongs to the branch and bound class of algorithms. The optimization reduces the effective depth to slightly more than half that of simple minimax if the nodes are evaluated in an optimal or near optimal order (best choice for side on move ordered first at each node).|$|E
25|$|The {{subsystem}} WKL0 {{consists of}} RCA0 plus a weak form of König's lemma, namely {{the statement that}} every infinite <b>subtree</b> of the full binary tree (the tree of all finite sequences of 0's and 1's) has an infinite path. This proposition, which is known as weak König's lemma, is easy to state {{in the language of}} second-order arithmetic. WKL0 can also be defined as the principle of Σ01 separation (given two Σ01 formulas of a free variable n which are exclusive, there is a class containing all n satisfying the one and no n satisfying the other).|$|E
50|$|Otter {{showed that}} any n-vertex tree has either a unique center vertex, whose removal splits the tree into <b>subtrees</b> {{of fewer than}} n/2 vertices, or a unique center edge, whose removal splits the tree into two <b>subtrees</b> of exactly n/2 vertices.|$|R
40|$|Due to the {{heterogeneous}} {{nature of}} XML data for internet applications exact matching of queries is often inadequate. The need arises to quickly identify <b>subtrees</b> of XML documents {{in a collection}} {{that are similar to}} a given pattern. In this paper we discuss di#erent similarity measures between a pattern and <b>subtrees</b> of documents in the collection. An e#cient algorithm for the identification of document <b>subtrees,</b> approximately conforming to the pattern, by indexing structures is then introduced...|$|R
40|$|We {{study that}} over {{some types of}} trees with a given number of vertices, which trees {{minimize}} or maximize {{the total number of}} <b>subtrees.</b> Trees minimizing (resp. maximizing) the total number of <b>subtrees</b> usually maximize (resp. minimize) the Wiener index, and vice versa. Here are some of our results: (1) Let T_n^k be the set of all n-vertex trees with k leaves, we determine the maximum (resp. minimum) value {{of the total number of}} <b>subtrees</b> of trees among T_n^k and characterize the extremal graphs. (2) Let P_n^p,q be the set of all n-vertex trees, each of which has a (p,q) -bipartition, we determine the maximum (resp. minimum) value of the total number of <b>subtrees</b> of trees among P_n^p,q and characterize the extremal graphs. (3) Let A_n^q be the set of all q-ary trees with n non-leaf vertices, we determine the minimum value of the total number of <b>subtrees</b> of trees among A_n^q and identify the extremal graph. Comment: 16 pages; 7 figure...|$|R
