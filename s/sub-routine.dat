115|100|Public
500|$|At {{multiple}} points {{within the}} game, Adam partakes {{in conversations with}} NPCs related to main and side quests. When talking, Adam is presented with three different conversation options that affect the outcome of conversations: choosing the right option can help with completing objectives while choosing the wrong option closes off that route and forces the player to find an alternate solution. A [...] "Social" [...] augmentation enables better reading of an NPC's expression and judging their psychological profile, improving chances of selecting the right dialogue option. While in the game's environments, Adam finds terminals and computers that can be accessed either with a password or through hacking. When hacking, the hacking screen is summoned, which shows the pathway through a device's security system to access the information: the pathway is accessed by opening [...] "directory" [...] nodes to reach the registry. Different nodes have different ratings, affecting how easily they can be accessed. Various devices have different grades of difficulty, which in turn dictate how many times hacking may be attempted. Each hacking attempt activates a Diagnostic <b>Sub-Routine</b> which works to stop the hack, activating a time limit once it is alerted. Adam can use additional skills and items to lengthen the time, such as software to stop or instantly capture nodes or fortify captured nodes to increase the time limit. Successful hacks yield experience points, Credits, and sometimes additional items.|$|E
2500|$|In {{computer}} science, {{a function}} is {{a portion of}} code within a larger program which performs a specific task and is relatively independent of the remaining code. [...] As used in database and spreadsheet applications these functions generally represent mathematical formulas widely used {{across a variety of}} fields. [...] While this code may be user-generated, it is also embedded as a pre-written <b>sub-routine</b> in applications. [...] These functions are typically identified by common nomenclature which corresponds to their underlying operations: e.g. IRR identifies the function which calculates Internal Rate of Return on a series of periodic cash flows.|$|E
50|$|At the <b>sub-routine</b> (or procedure) {{level the}} grain size is {{typically}} {{a few thousand}} instructions. Medium-grained parallelism is achieved at <b>sub-routine</b> level.|$|E
3000|$|The joint setup of the {{computational}} nodes {{is shown}} in Algorithm 1 which consists of the calculation of the priors and the synchronization of the pseudo-random generator. Subsequently, each individual PF is launched (Algorithm 2). Two important <b>sub-routines</b> are plotted in their own tableaus: [...]...|$|R
50|$|As Voyager resumes {{its journey}} home, Janeway reinstates Chakotay to Commander and strips the five {{surviving}} Equinox crew {{members of their}} ranks while integrating them {{with the rest of}} her crew. Seven promises to help the Doctor secure his ethical <b>sub-routines</b> from being deleted in the future.|$|R
50|$|Top-down is a {{programming}} style, {{the mainstay}} of traditional procedural languages, in which design begins by specifying complex pieces and then dividing them into successively smaller pieces. The technique for writing a program using top-down methods is to write a main procedure that names all the major functions it will need. Later, the programming team looks at the requirements of each of those functions and the process is repeated. These compartmentalized <b>sub-routines</b> eventually will perform actions so simple they can be easily and concisely coded. When all the various <b>sub-routines</b> have been coded the program is ready for testing. By defining how the application comes together at a high level, lower level work can be self-contained. By defining how the lower level abstractions are expected to integrate into higher level ones, interfaces become clearly defined.|$|R
5000|$|The program [...] starts by {{initializing}} its {{memory as}} well as registers to [...] Describing the procedures [...] and [...] is enough to complete the description of [...] The <b>sub-routine</b> [...] is given below. The inputs to the <b>sub-routine</b> are a memory location [...] and the value [...] to be stored at the location [...] It has three main phases, namely FETCH, PUT_BACK and FLUSH.|$|E
5000|$|The <b>sub-routine</b> [...] {{is similar}} to [...] For the [...] <b>sub-routine,</b> the input is just a memory {{location}} [...] and it is almost the same as [...] In the FETCH stage, {{if it does not}} find a triple corresponding to the location , it returns [...] as the value at location [...] In the PUT\_BACK phase, it will write back the same block that it read to the root, after associating it with a freshly sampled uniformly random leaf.|$|E
5000|$|...------------- {{interpreter}} --------------------------------------------* LM R14,R0,=A(4,CT1,N) Set R14=4, R15 --> table, and R0 =no. of {{entries in}} table (N) TRY CLC INPUT1,0(R15) ********* Found value in table entry ? BE ACTION * loop * YES, Load register pointer to <b>sub-routine</b> from table AR R15,R14 * * NO, Point to next entry in CT1 by adding R14 (=4) BCT R0,TRY ********* Back until count exhausted, then drop through [...] default action ... {{none of the}} values in table match, do something else LA R15,4(R15) point to default entry (beyond table end) ACTION L R15,0(R15) get pointer into R15,from where R15 points BALR R14,R15 Perform the <b>sub-routine</b> ("CALL" [...] and return) B END go terminate this program * ------------------ control table -----------------------------------------* * | this column of allowable EBCDIC or ASCII values is tested '=' against variable 'input1' * | | this column is the 3-byte address of the appropriate subroutine * v v CT1 DC C'A',AL3(ADD) START of Control Table (4 byte entry length) DC C'S',AL3(SUBTRACT) DC C'M',AL3(MULTIPLY) DC C'D',AL3(DIVIDE) N EQU (*-CT1)/4 number of valid entries in table (total length / entry length) DC C'?',AL3(DEFAULT) default entry - used on drop through to catch all INPUT1 DS C input variable is in this variable * ------------------ sub-routines ------------------------------------------* ADD CSECT <b>sub-routine</b> #1 (shown as separate CSECT here but might [...] alternatively be in-line code) [...] instruction(s) to add BR R14 return SUBTRACT CSECT <b>sub-routine</b> #2 [...] instruction(s) to subtract BR R14 return [...] etc..improving {{the performance of the}} interpreter in above example ...|$|E
50|$|Multics compilers {{generally}} optimised {{more for}} code density than CPU performance, for example using small <b>sub-routines</b> called operators for short standard code-sequences, making direct comparison of object code size with more modern systems less useful. High code density {{was a good}} optimisation choice for a multi-user system with expensive main memory, such as Multics.|$|R
40|$|Summary: Zerg is {{a library}} of <b>sub-routines</b> that parses the output from all NCBI BLAST {{programs}} (Blastn, Blastp, Blastx, Tblastn and Tblastx) and returns the attributes of aBLAST report to the user. It is optimized for speed, being especially useful for large-scale genomic analysis. Benchmark tests show that Zerg is over two orders of magnitude faster than some widely used BLAST parsers. Availability...|$|R
50|$|After {{learning}} the Doctor in their sickbay is from Voyager, and erasing his ethical <b>sub-routines</b> {{as they did}} with their EMH, they threaten to use him to probe Seven's mind to obtain the encrypted codes, despite the fact this may permanently incapacitate her. During his examination, he sings Clementine with the partially unconscious Seven, much dismaying Ransom as it seems to make his probing go more slowly.|$|R
5000|$|PC Gamer US {{nominated}} The People's General as {{the best}} wargame of 1998, although it lost to The Operational Art of War I: 1939-1955. They wrote, [...] "The People's Generals great graphics, slick-as-paint interface, and new aerial <b>sub-routine</b> all added up to jolly, bloody fun." ...|$|E
50|$|In {{computer}} science, {{a function}} is {{a portion of}} code within a larger program which performs a specific task and is relatively independent of the remaining code. As used in database and spreadsheet applications these functions generally represent mathematical formulas widely used {{across a variety of}} fields. While this code may be user-generated, it is also embedded as a pre-written <b>sub-routine</b> in applications. These functions are typically identified by common nomenclature which corresponds to their underlying operations: e.g. IRR identifies the function which calculates Internal Rate of Return on a series of periodic cash flows.|$|E
50|$|The {{programming}} interfaces of the Microsoft Windows {{family of}} OSes consist largely of dynamic-link libraries (DLLs). These contain {{a huge number}} of wrapper sub-routines for the system calls of the kernel, the NTOS kernel-mode program (ntoskrnl.exe). Only programmers at Microsoft write to the system-call layer, as documentation is not publicly available. The published user-mode interfaces all belong to operating system personalities that are implemented using subsystems that run on top of the NTOS layers. As a result, a programmer never knows the cost of <b>sub-routine.</b> But Windows also includes a number of programming interfaces which are implemented as services that run as separate processes. Applications communicate with user-mode services through RPCs.|$|E
5000|$|The term [...] "Pythagorean Method of Memorization" [...] {{was coined}} in 2013 and officially copyrighted in October 2014 by a Canadian company named You Learn Educational Solutions & Linguistics Inc. PYMOM takes the {{movement}} cycle from TMC and remedied {{the challenge of}} teaching the movement cycle itself to students by providing a software-based solution to handling cycles by means of <b>sub-routines</b> prompted by the user’s input.|$|R
40|$|Abstract Background Parallel {{computing}} {{is frequently}} used {{to speed up}} computationally expensive tasks in Bioinformatics. Results Herein, a parallel version of the multi-alignment program DIALIGN is introduced. We propose two ways of dividing the program into independent <b>sub-routines</b> that can be run on different processors: (a) pair-wise sequence alignments that are used {{as a first step}} to multiple alignment account for most of the CPU time in DIALIGN. Since alignments of different sequence pairs are completely independent of each other, they can be distributed to multiple processors without any effect on the resulting output alignments. (b) For alignments of large genomic sequences, we use a heuristics by splitting up sequences into sub-sequences based on a previously introduced anchored alignment procedure. For our test sequences, this combined approach reduces the program running time of DIALIGN by up to 97 %. Conclusions By distributing <b>sub-routines</b> to multiple processors, the running time of DIALIGN can be crucially improved. With these improvements, it is possible to apply the program in large-scale genomics and proteomics projects that were previously beyond its scope. </p...|$|R
25|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the bootstrap loader, Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on <b>sub-routines</b> in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|R
5000|$|Mildred Koss, {{an early}} UNIVAC programmer, explains: [...] "Writing machine code {{involved}} several tedious steps—breaking down a process into discrete instructions, assigning specific memory locations {{to all the}} commands, and managing the I/O buffers. After following these steps to implement mathematical routines, a <b>sub-routine</b> library, and sorting programs, our task was {{to look at the}} larger programming process. We needed to understand how we might reuse tested code and have the machine help in programming. As we programmed, we examined the process and tried to think of ways to abstract these steps to incorporate them into higher-level language. This {{led to the development of}} interpreters, assemblers, compilers, and generators—programs designed to operate on or produce other programs, that is, automatic programming." ...|$|E
5000|$|As {{well as the}} two index {{registers}} {{already mentioned}} (referred to as 1 and 2, or binary 01 and 10) there were other registers."Reg 4" [...] (0100) was the instruction address register (IAR) which pointed at the current instruction."Reg 8" [...] (1000) was the address recall register (ARR), set by certain instructions. Among these was the conditional branch (mnemonic BC) which used it {{to point to the}} byte immediately following the branch operation. For IBM mainframe folks this means that the S/3 branch could be likened to a conditional BALR (branch and link register). Very useful when branching to a <b>sub-routine,</b> and returning after it had processed.Finally, [...] "Reg 16" [...] (00010000) was the program status register (PSR), holding such things as the results of a compare instruction.Note that registers were used only for addressing and program status, not for arithmetic.|$|E
5000|$|The {{concept is}} similar in all languages: [...] is usually an {{immutable}} reference or pointer which refers to the current object; the current object often being the code that acts as 'parent' to the property, method, <b>sub-routine</b> or function that contains the [...] keyword. After an object is properly constructed, or instantiated, [...] is always a valid reference. Some languages require it explicitly; others use lexical scoping to use it implicitly to make symbols within their class visible. Or alternatively, the current object referred to by [...] may be an independent code object that has called the function or method containing the keyword [...] Such a thing happens, for example, when a Javascript event handler attached to an HTML tag in a web page calls a function containing the keyword [...] stored in the global space outside the document object; in that context, [...] will refer to the page element within the document object, not the enclosing window object.|$|E
40|$|A {{potentially}} operational snow mapping scheme {{applicable to}} areas of temporary snow cover (e. g. UK) using daily NOAA AVHRR imagery {{for the production}} of weekly composite snow area estimates is presented. This technique is based upon an unsupervised multispectral classification of AVHRR channels allowing snow/cloud and snow type discriminations together with the accurate location of snowpack margins. Supporting <b>sub-routines</b> have been developed also for the correction of forest masking and shadowing of the snow by cloud. Non peer reviewe...|$|R
40|$|The paper {{presents}} a nested and coupled modelling suite including meteorological, waves, currents and morphodynamics <b>sub-routines.</b> The sequence {{has been applied}} to two distinctiv e beaches along the Catalan coast in the Spanish Mediterranean. Models and observations from two intensive campaigns have been compared to establish the accuracy and reliability of morphodynamic simulations, with the aim to determine uncertainty intervals and to assess the suitability of using such a modelling tool for reducing storm induced risks in beach management. Peer ReviewedPostprint (published version...|$|R
5000|$|While {{many other}} vendors have {{continued}} to utilize a single-sector setup (logical sector 0 only) for the bootstrap loader, Microsoft's boot sector code has grown to span over logical sectors 0 and 2 since the introduction of FAT32, with logical sector 0 depending on <b>sub-routines</b> in logical sector 2. The Backup Boot Sector area consists of three logical sectors 6, 7, and 8 as well. In some cases, Microsoft also uses sector 12 of the reserved sectors area for an extended boot loader.|$|R
5000|$|At {{multiple}} points {{within the}} game, Adam partakes {{in conversations with}} NPCs related to main and side quests. When talking, Adam is presented with three different conversation options that affect the outcome of conversations: choosing the right option can help with completing objectives while choosing the wrong option closes off that route and forces the player to find an alternate solution. A [...] "Social" [...] augmentation enables better reading of an NPC's expression and judging their psychological profile, improving chances of selecting the right dialogue option. While in the game's environments, Adam finds terminals and computers that can be accessed either with a password or through hacking. When hacking, the hacking screen is summoned, which shows the pathway through a device's security system to access the information: the pathway is accessed by opening [...] "directory" [...] nodes to reach the registry. Different nodes have different ratings, affecting how easily they can be accessed. Various devices have different grades of difficulty, which in turn dictate how many times hacking may be attempted. Each hacking attempt activates a Diagnostic <b>Sub-Routine</b> which works to stop the hack, activating a time limit once it is alerted. Adam can use additional skills and items to lengthen the time, such as software to stop or instantly capture nodes or fortify captured nodes to increase the time limit. Successful hacks yield experience points, Credits, and sometimes additional items.|$|E
5000|$|...------------- {{interpreter}} --------------------------------------------* SR R14,R14 ********* Set R14=0 CALC IC R14,INPUT1 * calc * put EBCDIC byte into lo order bits (24-31) of R14 IC R14,CT1X(R14) * * use EBCDIC {{value as}} index on table 'CT1X' {{to get new}} index SLL R14,2 * * multiply index by 4 (additional instruction) FOUND L R15,CT1(R14) ********* get pointer to subroutine using index (0,4, 8 etc.) BALR R14,R15 Perform the <b>sub-routine</b> ("CALL" [...] and return or Default) B END go terminate this program * --------------- additional translate table (EBCDIC --> pointer table INDEX) 256 bytes----* CT1X DC 12AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) 12 identical sets of 16 bytes of x'00' * representing X'00 - x'BF' DC AL1(00,01,00,00,04,00,00,00,00,00,00,00,00,00,00,00) [...].x'C0' - X'CF' DC AL1(00,00,00,00,03,00,00,00,00,00,00,00,00,00,00,00) [...].x'D0' - X'DF' DC AL1(00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'E0' - X'EF' DC AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'F0' - X'FF' * the assembler {{can be used to}} automatically calculate the index values and make the values more user friendly * (for e.g. '01' could be replaced with the symbolic expression 'PADD-CT1X/4' in table CT1X above) * modified CT1 (index now based on 0,1,2,3,4 not 0,4,8,12,16 to allow all 256 variations) CT1 DC A(DEFAULT) index =00 START of Control Table (4 byte address constants) PADD DC A(ADD) =01 PSUB DC A(SUBTRACT) =02 PMUL DC A(MULTIPLY) =03 PDIV DC A(DIVIDE) =04 * the rest of the code remains the same as the 2nd example ...|$|E
5000|$|To handle 64 {{different}} input values, approximately 85 {{lines of}} source code (or less) are required (mainly single line table entries) whereas multiple 'compare and branch' would require around 128 lines (the {{size of the}} binary is also almost halved - despite the additional 256 byte table required to extract the 2nd index). * ------------------ interpreter --------------------------------------------* SR R14,R14 ********* Set R14=0 CALC IC R14,INPUT1 * calc * put EBCDIC byte into lo order bits (24-31) of R14 IC R14,CT1X(R14) * * use EBCDIC value as index on table 'CT1X' to get new index FOUND L R15,CT1(R14) ********* get pointer to subroutine using index (0,4, 8 etc.) BALR R14,R15 Perform the <b>sub-routine</b> ("CALL" [...] and return or Default) B END go terminate this program * --------------- additional translate table (EBCDIC --> pointer table INDEX) 256 bytes----* CT1X DC 12AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) 12 identical sets of 16 bytes of x'00 * representing X'00 - x'BF' DC AL1(00,04,00,00,16,00,00,00,00,00,00,00,00,00,00,00) [...].x'C0' - X'CF' DC AL1(00,00,00,00,12,00,00,00,00,00,00,00,00,00,00,00) [...].x'D0' - X'DF' DC AL1(00,00,08,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'E0' - X'EF' DC AL1(00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00) [...].x'F0' - X'FF' * the assembler {{can be used to}} automatically calculate the index values and make the values more user friendly * (for e.g. '04' could be replaced with the symbolic expression 'PADD-CT1' in table CT1X above) * modified CT1 (added a default action when index = 00, single dimension, full 31 bit address) CT1 DC A(DEFAULT) index =00 START of Control Table (4 byte address constants) PADD DC A(ADD) =04 PSUB DC A(SUBTRACT) =08 PMUL DC A(MULTIPLY) =12 PDIV DC A(DIVIDE) =16 * the rest of the code remains the same as first example ...|$|E
5000|$|The basic syntax {{remains very}} similar: conditions, loops, procedures, <b>sub-routines</b> are {{declared}} and {{written in the}} same manner (see Visual Basic). Mobility from prior Visual Basic iterations to Visual Basic [...]NET really are ports of existing code: programmers with experience in both worlds are required to effectively target the new platform with older logic. The Visual Basic [...]NET developer will have to learn the use of the basic [...]NET types rather than what they have been used to in Visual Basic.|$|R
50|$|Eventually {{the full}} {{brunt of the}} storm hits with its most {{destructive}} forces taking out many of the ship's systems. While some of the holodeck program Fair Haven survives, many of its finer points are lost. When approached by Tom and Harry about what {{can and should be}} saved, the captain returns to the holodeck. She does decide to save the character of Sullivan, and after more thought - tells the computer to deny her (Janeway herself) access to modifying any more of the program's <b>sub-routines.</b>|$|R
40|$|We {{describe}} a package for both R & S which allows expressions in that language to directly invoke Perl <b>sub-routines</b> and object methods directly. This provides {{a simple way}} of making network capabilities available to S, as well as fast regular expression matching, etc. The interface between R/S and Perl is achieved by running an embedded Perl interpreter within the R/S session. This gives us direct access to any existing Perl <b>sub-routines</b> and modules and avoids the use of expensive invocations of Perl as a sub-process that can only communicate with R/S via strings. The interface (will) allows for R and Perl computations to be mixed. This is intended to provide information for the user who is interested in not only knowing about the available functions in the R/S-Perl interface, but also how they might be used most effectively and what underlies them. A collection of annotated examples will provide a quicker way to get started. Perl is a wonderful complementary tool to use with R and S. There are certain tasks that are perfectly suited to the Perl language and others that one naturally considers expressing in the S-language because of its. Certain data structures (e. g. trees) are more naturally expressed and manipulated in a language that supports references such as Perl than in S. But S offers many advantages over Perl, but in different aspects...|$|R
30|$|<b>Sub-routine</b> 3 : (Victim identifier) Against each {{sensitive}} itemset, an item with maximum {{support is}} selected as a victim.|$|E
40|$|A two-year {{study of}} physical, biological, and {{chemical}} aspects of Minnesota wastewater treatment ponds was conducted. As {{a part of}} this study, the one-dimensional unsteady advection/diffusion lake model MINLAKE was adapted for simulation of pond processes. A special <b>sub-routine</b> to track the ponds ' Daphnia population was developed. Toxic effects of ammonia, low dissolved oxygen, and hydrogen sulfide were included in the model. The model and <b>sub-routine</b> were calibrated, and showed reasonable agreement with population data collected during the study. Development of the Daphnia <b>sub-routine</b> and its pelformance in the overall pond model are discussed herein. The University of Minnesota is committed to the policy that all persons shall have equal access to its programs, facilities, and employment without regard to race, religion, color, sex, national origin, handicap, age, or veteran status...|$|E
30|$|<b>Sub-routine</b> 4 : (Transaction sorting) Sensitive {{transactions}} are sorted {{depending on the}} given condition (e.g. Length of transaction, Degree of conflict etc.).|$|E
40|$|This {{research}} program presents an experimental {{study on the}} mechanical and thermal properties {{of different types of}} concretes at very early ages, (i. e., during hydration). These properties are investigated for temperature-matched curing, sealed curing and air-dried curing. Three types of concretes are studied including normal-strength (30 MPa), medium-strength (70 MPa) and high-strength (100 MPa) concretes. About 300 cylinders and 175 flexural beams were tested to determine the early-age mechanical properties including compressive stress-strain responses, gain of compressive strength, change in elastic modulus and variation of tensile strength. Creep frames and measuring devices were built to enable the experimental determination of early-age creep, with unloaded, companion specimens giving the corresponding shrinkage strains. A temperature-matched curing bath was developed to measure the heat of hydration and to subject 15 cylinders and 12 flexural beams to temperature-matched curing. The thermal properties investigated included the heat of hydration, the thermal conductivity, the specific heat and the coefficient of thermal expansion. Expressions are proposed to predict the development of compressive strength, elastic modulus and modulus of rupture {{as a function of the}} type of concrete and the type of curing. <b>Sub-routines</b> were developed for a finite element thermal analysis program "DETECT" to predict the variation of temperatures during hydration. Additional <b>sub-routines,</b> using the maturity concept, predicted the compressive strength, elastic modulus and tensile strength of each element, in the time domain. An experimental study was performed to observe the effect of different curing conditions and early-form stripping on the temperature and strain development in structural concrete members. Comparisons are made between the measured and predicted temperatures in large concrete columns and precast tee beams and slabs. <b>Sub-routines</b> were developed to enable incremental stress analysis in the time domain to account for the rapidly changing material properties and the influence of creep. Predictions of the risk of cracking were made and compared with observations from experiments on concrete elements during hydration. Parametric analyses were carried out to determine the influence of key thermal properties, time of formwork removal, creep, and concrete strength on the thermal gradients developed and the risk of thermal cracking...|$|R
40|$|Because {{of the new}} read program, {{a number}} of {{facilities}} are being added to the LISP system to permit manipulation of single characters and print names. Machine-language functions have been provided for breaking print names down into a list of their characters, for forming a list of characters into a print name, for creating a numerical object {{from a list of}} its characters, for reading in characters one by one from an input medium, and for testing characters to see whether they are letters, numbers, operation characters, etc. A number of auxiliary objects and <b>sub-routines</b> are also described in this memo...|$|R
40|$|We {{argue that}} {{probabilistic}} programming with undirected models, {{in order to}} scale up, needs to open up. That is, {{instead of focusing on}} minimal sets of generic building blocks such as universal quanti cation or logical connectives, languages should grow to include speci c building blocks for as many uses cases as necessary. This can not only lead to more concise models, but also to more e cient inference if we use methods that can exploit building-block speci c <b>sub-routines.</b> As embodiment of this paradigm we present Fast Froward, a platform for implementing probabilistic programming languages that grow...|$|R
