33|10000|Public
500|$|In November 1993, {{the subway}} system {{introduced}} a fare system called the MetroCard, which allows riders to use cards that <b>store</b> <b>the</b> <b>value</b> {{equal to the}} amount paid to a station booth clerk or vending machine. The MetroCard was enhanced in 1997 to allow passengers to make free transfers between subways and buses within two hours; several MetroCard-only transfers between subway stations were added in 2001. With the addition of unlimited-ride MetroCards in 1998 (for 7-day and 30-day periods, later 1-day [...] "Fun Pass" [...] and 14-day periods, {{both of which have}} been discontinued), the New York City Transit system was the last major transit system in the United States with the exception of BART in San Francisco to introduce passes for unlimited bus and rapid transit travel.|$|E
500|$|Uniform {{binary search}} stores, {{instead of the}} lower and upper bounds, the index of the middle element and {{the change in the}} middle element from the current {{iteration}} to the next iteration. Each step reduces the change by about half. For example, if the array to be searched was , the middle element would be [...] Uniform binary search works on the basis that the difference between the index of middle element of the array and the left and right subarrays is the same. In this case, the middle element of the left subarray (...) is [...] and the middle element of the right subarray (...) is [...] Uniform binary search would <b>store</b> <b>the</b> <b>value</b> of [...] as both indices differ from [...] by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the middle element. The main advantage of uniform binary search is that the procedure can store a table of the differences between indices for each iteration of the procedure, which may improve the algorithm's performance on some systems.|$|E
5000|$|In C++11, {{there is}} a type called [...] (null pointer type) that can only <b>store</b> <b>the</b> <b>value</b> [...]|$|E
25|$|The least {{significant}} 16-bit unit <b>stores</b> <b>the</b> <b>value</b> 0C0Dh, immediately {{followed by}} 0A0Bh.|$|R
5000|$|Initially, memory {{locations}} [...] and [...] both hold <b>the</b> <b>value</b> [...] <b>The</b> program {{running on}} processor #1 loops while <b>the</b> <b>value</b> of [...] is zero, then it prints <b>the</b> <b>value</b> of [...] <b>The</b> program running on processor #2 <b>stores</b> <b>the</b> <b>value</b> [...] into [...] and then <b>stores</b> <b>the</b> <b>value</b> [...] into [...] Pseudo-code {{for the two}} program fragments is shown below. The steps of the program correspond to individual processor instructions.|$|R
5000|$|<b>The</b> <b>Store</b> KeyPoOps <b>stores</b> <b>the</b> <b>value</b> in <b>the</b> Data Switches as {{specified}} by the Storage-Select Switch and the Address Switches.|$|R
5000|$|If the bit is [...] {{then read}} N bits, <b>store</b> <b>the</b> <b>value</b> {{as the new}} value of N, {{and go back to}} step 2.|$|E
50|$|Hash tables {{need to be}} able {{to handle}} collisions: when the hash {{function}} maps two different keys to the same bucket of the array. The two most widespread approaches to this problem are separate chaining and open addressing. In separate chaining, the array does not <b>store</b> <b>the</b> <b>value</b> itself but stores a pointer to another container, usually an association list, that stores all of the values matching the hash. On the other hand, in open addressing, if a hash collision is found, then the table seeks an empty spot in an array to <b>store</b> <b>the</b> <b>value</b> in a deterministic manner, usually by looking at the next immediate position in the array.|$|E
5000|$|CPU 1 {{issues a}} test-and-set {{instruction}} {{to write to}} [...] "memory location A". The DPRAM does not immediately <b>store</b> <b>the</b> <b>value</b> in memory location A, but instead simultaneously moves the current value to a special register, while setting the contents of memory location A to a special [...] "flag value". If at this point, CPU 2 issues a test-and-set to memory location A, the DPRAM detects the special flag value, and as in Variation 1, issues a BUSY interrupt.|$|E
5000|$|... : {{insert a}} new leaf node <b>storing</b> <b>the</b> <b>value</b> b as <b>the</b> ith leaf {{of the tree}} T.|$|R
50|$|Each {{parameter}} {{is stored}} {{as a pair}} of strings, one <b>storing</b> <b>the</b> name of the parameter (called the key), and <b>the</b> other <b>storing</b> <b>the</b> <b>value.</b>|$|R
5000|$|Now suppose we're <b>storing</b> <b>the</b> <b>values</b> with a {{scale factor}} of Z. If we simply {{multiply}} <b>the</b> <b>stored</b> representations we'll get the following: ...|$|R
50|$|With the {{earnings}} from his Chicago store, Young purchased a half interest in The Fair <b>Store.</b> <b>The</b> <b>value</b> {{of the store}} skyrocketed afterward and Young became wealthy. He maintained several interests in real estate, including the Heyworth Building, and {{served on the board}} of trustees of the First National Bank of Chicago. Young was also a philanthropist, and often donated to the Chicago Home for Incurables in memory of his son. Young's estate in Lake Geneva, Wisconsin is today recognized on the National Register of Historic Places.|$|E
5000|$|INP OUT // Initialize output [...] LOOP BRZ QUIT // If the {{accumulator}} {{value is}} 0, {{jump to the}} memory address labeled QUIT SUB ONE // Label this memory address as LOOP, The instruction will then subtract the value stored at address ONE from the accumulator OUT BRA LOOP // Jump (unconditionally) to the memory address labeled LOOP QUIT HLT // Label this memory address as QUIT ONE DAT 1 // <b>Store</b> <b>the</b> <b>value</b> 1 in this memory address, and label it ONE (variable declaration) ...|$|E
50|$|For example, to {{retrieve}} the contents of cell 123, we would load the value 123 (in binary) into the MAR and perform a fetch operation. When the operation is done, {{a copy of the}} contents of cell 123 would be in the MDR. To <b>store</b> <b>the</b> <b>value</b> 98 into cell 4, we load a 4 into the MAR and a 98 into the MDR and perform a store. When the operation is completed the contents of cell 4 will have been set to 98, by discarding whatever was there previously.|$|E
25|$|The least {{significant}} 16-bit unit <b>stores</b> <b>the</b> <b>value</b> 0C0Dh, immediately {{followed by}} 0A0Bh. Note that 0C0Dh and 0A0Bh represent integers, not bit layouts.|$|R
30|$|Storage <b>Store</b> <b>the</b> <b>values</b> of <b>the</b> weights, fitness, generations, MaxFunEvals {{and time}} taken for this run {{in case of}} all twelve hybrid schemes based on GA-SQP.|$|R
50|$|This {{problem can}} be solved {{by the use of}} {{conditional}} put. Suppose we change step 3 as follows: instead of unconditionally <b>storing</b> <b>the</b> new <b>value,</b> <b>the</b> program asks SimpleDB to <b>store</b> <b>the</b> new <b>value</b> only if <b>the</b> <b>value</b> that it currently holds is the same as <b>the</b> <b>value</b> that was retrieved in step 1. Then, we can be sure that <b>the</b> counter's <b>value</b> actually increases. This introduces some additional complexity; if SimpleDB was not able to <b>store</b> <b>the</b> new <b>value</b> because <b>the</b> current <b>value</b> was not as expected, the program must repeat steps 1-3 until the conditional put operation actually changes <b>the</b> <b>stored</b> <b>value.</b>|$|R
50|$|Counts {{how often}} an item is needed. Those {{that are used}} least often are {{discarded}} first. This works very similar to LRU except that instead of storing the value of how recently a block was accessed, we <b>store</b> <b>the</b> <b>value</b> of how many times it was accessed. So of course while running an access sequence we will replace a block which was used least number of times from our cache. E.g., if A was used (accessed) 5 times and B was used 3 times and others C and D were used 10 times each, we will replace B.|$|E
5000|$|STOD [...] - [...] Store {{destructive}} (if {{the target}} word has an odd tag throw a memory protect interrupt, [...] - [...] <b>store</b> <b>the</b> <b>value</b> in the B register {{at the memory}} addressed by the A register. [...] - [...] Delete the value off the stack.STON [...] - [...] Store non-destructive (Same as STOD but value is not deleted [...] - [...] handy for F := G := H := J expressions).OVRD [...] - [...] Overwrite destructive, STOD ignoring read-only bit (for use in MCP only)OVRN [...] - [...] Overwrite non-destructive, STON ignoring read-only bit (for use in MCP only) ...|$|E
5000|$|The {{operation}} of a CNC machine tool is typically controlled by a [...] "part program" [...] written a language known as G-code. [...] Canned cycles are similar in concept to functions in a traditional computer language, and can be compared also to G-code macros. The format for a canned cycle consists {{of a series of}} parameters specified with a letter and a numerical value. The letter is referred to as an [...] "address". (This use of the term [...] "address" [...] may be unfamiliar to programmers of conventional computers. It arises because in early and primitive machine controllers, the binary representation of the letter formed a physical address at which the controller would <b>store</b> <b>the</b> <b>value</b> following.) ...|$|E
30|$|Since {{the steps}} of a certain clock do no longer {{coincide}} with <b>the</b> instants, <b>the</b> <b>values</b> of variables have to be kept for the whole step. Therefore, <b>the</b> variable xprv <b>stores</b> <b>the</b> <b>value</b> of x from the previous instant.|$|R
5000|$|Otherwise <b>store</b> <b>the</b> {{previous}} <b>values,</b> , set , {{and update}} <b>the</b> <b>value</b> of [...]|$|R
50|$|On some {{computer}} architectures, it is {{more efficient}} to store a zero in a register by XOR-ing the register with itself (bits XOR-ed with themselves are always zero) instead of loading and <b>storing</b> <b>the</b> <b>value</b> zero.|$|R
5000|$|In November 1993, {{the subway}} system {{introduced}} a fare system called the MetroCard, which allows riders to use cards that <b>store</b> <b>the</b> <b>value</b> {{equal to the}} amount paid to a station booth clerk or vending machine. The MetroCard was enhanced in 1997 to allow passengers to make free transfers between subways and buses within two hours; several MetroCard-only transfers between subway stations were added in 2001. With the addition of unlimited-ride MetroCards in 1998 (for 7-day and 30-day periods, later 1-day [...] "Fun Pass" [...] and 14-day periods, {{both of which have}} been discontinued), the New York City Transit system was the last major transit system in the United States with the exception of BART in San Francisco to introduce passes for unlimited bus and rapid transit travel. In April 2016, MTA solicited proposals for a contactless [...] "New Fare Payment System" [...] to replace the MetroCard by 2022.|$|E
5000|$|Compilers {{prior to}} 5.0 {{would not accept}} the last line. [...] are {{reference}} objects, on the surface no different from , , and so forth. To convert from an [...] to an , one had to [...] "manually" [...] instantiate the Integer object. As of J2SE 5.0, the compiler will accept the last line, and automatically transform it so that an Integer object is created to <b>store</b> <b>the</b> <b>value</b> [...] This means that, from J2SE 5.0 on, something like , where [...] and [...] are [...] themselves, will compile now - a and b are unboxed, the integer values summed up, {{and the result is}} autoboxed into a new , which is finally stored inside variable [...] Note that the equality operators cannot be used this way, since the equality operators are already defined for reference types, for equality of the references; to test for equality of the value in a boxed type, one must still manually unbox them and compare the primitives, or use the [...] method.|$|E
5000|$|In simple cases this is {{identical}} to usual function calls; for example, addition [...] is generally equivalent to a function call [...] and less-than comparison [...] to , meaning that the arguments are evaluated in their usual way, then some function is evaluated {{and the result is}} returned as a value. However, the semantics can be significantly different. For example, in assignment [...] the target [...] is not evaluated, but instead its location (address) is used to <b>store</b> <b>the</b> <b>value</b> of [...] - corresponding to call-by-reference semantics. Further, an assignment may be a statement (no value), or may be an expression (value), with the value itself either an r-value (just a value) or an l-value (able to be assigned to). As another example, the scope resolution operator :: and the element access operator [...] (as in [...] or [...] ) operate not on values, but on names, essentially call-by-name semantics, and their value is a name.|$|E
5000|$|As {{mentioned}} earlier, using [...] and [...] we are {{now able}} to determine which of <b>the</b> two <b>values</b> of [...] ( [...] or [...] ) works. This gives <b>the</b> <b>value</b> of [...] Schoof's algorithm <b>stores</b> <b>the</b> <b>values</b> of [...] in a variable [...] for each prime [...] considered.|$|R
30|$|At design time, the {{developer}} specifies the buffer table {{that uses a}} tiny storage in the memory. In the buffer table, the columns represent the list of variables and the rows represent the slots. <b>The</b> first row <b>stores</b> <b>the</b> start <b>values.</b> Every subsequent row <b>stores</b> <b>the</b> <b>values</b> of variables for the slots over time. The number of rows is bounded {{by the number of}} slots in each communication cycle. The developer can specify initial values; otherwise, the variable is initialized with ϕ.|$|R
5000|$|<b>Store</b> <b>the</b> new <b>value</b> in <b>the</b> {{same place}} as <b>the</b> old <b>value</b> in SimpleDB.|$|R
5000|$|A {{number of}} {{optimizations}} reduce message complexity and size. These optimizations are summarized below::: [...] "We can save messages {{at the cost}} of an extra message delay by having a single distinguished learner that informs the other learners when it finds out that a value has been chosen. Acceptors then send Accepted messages only to the distinguished learner. In most applications, the roles of leader and distinguished learner are performed by the same processor.:: [...] "A leader can send its Prepare and Accept! messages just to a quorum of acceptors. As long as all acceptors in that quorum are working and can communicate with the leader and the learners, {{there is no need for}} acceptors not in the quorum to do anything.:: [...] "Acceptors do not care what value is chosen. They simply respond to Prepare and Accept! messages to ensure that, despite failures, only a single value can be chosen. However, if an acceptor does learn what value has been chosen, it can <b>store</b> <b>the</b> <b>value</b> in stable storage and erase any other information it has saved there. If the acceptor later receives a Prepare or Accept! message, instead of performing its Phase1b or Phase2b action, it can simply inform the leader of the chosen value.:: [...] "Instead of sending the value v, the leader can send a hash of v to some acceptors in its Accept! messages. A learner will learn that v is chosen if it receives Accepted messages for either v or its hash from a quorum of acceptors, and at least one of those messages contains v rather than its hash. However, a leader could receive Promise messages that tell it the hash of a value v that it must use in its Phase2a action without telling it the actual value of v. If that happens, the leader cannot execute its Phase2a action until it communicates with some process that knows v.":: [...] "A proposer can send its proposal only to the leader rather than to all coordinators. However, this requires that the result of the leader-selection algorithm be broadcast to the proposers, which might be expensive. So, it might be better to let the proposer send its proposal to all coordinators. (In that case, only the coordinators themselves need to know who the leader is.):: [...] "Instead of each acceptor sending Accepted messages to each learner, acceptors can send their Accepted messages to the leader and the leader can inform the learners when a value has been chosen. However, this adds an extra message delay.:: [...] "Finally, observe that phase 1 is unnecessary for round 1 [...]. The leader of round 1 can begin the round by sending an Accept! message with any proposed value." ...|$|E
3000|$|Finally, this module {{makes use}} of the {{services}} published by [...] "UPnP protocol stack" [...] module to implement a generic UPnP server. This UPnP device publishes a set of generic services which maps all the commands offered by the IEEE 1451.0 protocol. Furthermore, this device {{is characterized by a}} set of state variables that <b>store</b> <b>the</b> <b>value</b> of each sensor at any time and publish UPnP events when this value changes. In this way, all the iteration with non-UPnP devices is done using this module, which virtualizes the UPnP behavior.|$|E
40|$|We study {{parameterized}} verification {{problems for}} networks of interacting register automata. The network is represented through a graph, and processes may exchange broadcast messages containing data with their neighbours. Upon reception a process can either ignore a sent value, test for equality with a value {{stored in a}} register, or simply <b>store</b> <b>the</b> <b>value</b> in a register. We consider safety properties {{expressed in terms of}} reachability, from arbitrarily large initial configurations, of a configuration exposing some given control states and patterns. We investigate, in this context, the impact on decidability and complexity of the number of local registers, the number of values carried by a single message, and dynamic reconfigurations of the underlying network...|$|E
30|$|Contrary to {{the first}} component, we do not <b>store</b> <b>the</b> <b>values</b> of <b>the</b> ambient noise, and we act {{dynamically}} on the speaker’s volume. The sound level is modified gradually to avoid any impact on the user satisfaction, {{on the base of}} the change blindness [2].|$|R
3000|$|... [...]). However, for {{computing}} {{the shared}} key, both the nodes need <b>the</b> <b>values</b> of u and w. So, the two nodes must exchange <b>the</b> <b>values</b> of u[*]and w which will incur an additional communication cost of O(1). To avoid this, every node can <b>store</b> <b>the</b> <b>values</b> of P O S(∗,∗) for other nodes. For example node n [...]...|$|R
30|$|The {{extension}} {{shall be}} encoded; <b>the</b> authentication <b>value</b> field shall {{be used to}} <b>store</b> <b>the</b> signature <b>value.</b>|$|R
