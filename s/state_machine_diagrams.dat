52|8553|Public
5000|$|Events can, {{but do not}} necessarily, cause state {{transitions}} from one state to another in state machines represented by <b>state</b> <b>machine</b> <b>diagrams.</b>|$|E
5000|$|Dynamic (or behavioral) view: {{emphasizes}} the dynamic {{behavior of the}} system by showing collaborations among objects and changes to the internal states of objects. This view includes sequence diagrams, activity diagrams and <b>state</b> <b>machine</b> <b>diagrams.</b>|$|E
50|$|Concerning {{the rest}} of the {{automotive}} system, enhanced activity diagrams and <b>state</b> <b>machine</b> <b>diagrams</b> can be used to specify the embedded software control logic and information flows for the on-board automotive computers. Other SysML structural and behavioral diagrams can be used to model factories that build the automobiles, as well as the interfaces between the organizations that work in the factories.|$|E
50|$|The {{following}} <b>state</b> <b>machine</b> <b>diagram</b> describes different <b>states</b> of a task {{over its}} life cycle. This diagram is referenced from IBM.|$|R
40|$|Abstract — Automatic {{test data}} {{generation}} helps testers to validate software against user requirements more easily. Test {{data can be}} generated from many sources; for example, experience of testers, source program, or software specification. Selecting a proper test data set is a decision making task. Testers {{have to decide what}} test data that they should use, and a heuristic technique is needed to solve this problem automatically. In this paper, we propose a framework for generating test data from software specifications. The selected specification is Unified Modeling Language (UML) <b>state</b> <b>machine</b> <b>diagram.</b> UML <b>state</b> <b>machine</b> <b>diagram</b> describes a system in term of state which can be changed when there is an action occurring in the system. The generated test data is a sequence of these actions. These sequences of action help testers to know how they should test the system. The quality of generated test data is measured by the number of transitions which is fired using the test data. The more transitions test data can fire, the better quality of test data is. The number of coverage transitions is also used as a feedback for a heuristic search for a better test set. Genetic algorithms (GAs) are selected for searching the best test data. In this paper, we use a set of test data to test <b>state</b> <b>machine</b> <b>diagram.</b> A set of test data is comprised of test data which can cover most transition in each possible path. The possible path is a path which covers in <b>state</b> <b>machine</b> <b>diagram.</b> The transition coverage result from our current work is improved comparing to result when using only one test data. Keywords- Test data generation, UML <b>state</b> <b>machine</b> <b>diagram,</b> Genetic algorithm I...|$|R
30|$|And we {{specified}} {{user requirements}} by MBSE. MBSE was effective {{to describe the}} user requirements and models because the user requirements and the models could be defined by various diagrams in MBSE, such as the requirement <b>diagram</b> and the <b>state</b> <b>machine</b> <b>diagram.</b>|$|R
50|$|In addition, other {{behavioral}} UML diagrams such as activity diagrams, sequence diagrams, communication diagrams and <b>state</b> <b>machine</b> <b>diagrams</b> {{can also}} be used to visualize use cases accordingly. Specifically, a System Sequence Diagram (SSD) is a sequence diagram often used to show the interactions between the external actors and the system under design (SuD), usually for visualizing a particular scenario of a use case.|$|E
30|$|According to the COSMIC-FFP {{definitions}} {{given in}} ISO/IEC 19761 (2003) and Abran et al. (2009) and the sequence diagrams {{that derive from}} it, <b>state</b> <b>machine</b> <b>diagrams</b> {{can be obtained by}} applying these sequence diagrams. COSMIC-FFP measurements can be mapped to UML 2.0 state diagrams applying the technique proposed in Vasilache and Tanaka (2004), applied in Ormandjieva et al. (2008) (Abu Talib 2007; Abu Talib et al. 2012) and demonstrated by <b>state</b> <b>machine</b> <b>diagrams</b> from multiple interrelated scenarios (or sequence diagrams).|$|E
30|$|<b>State</b> <b>machine</b> <b>diagrams</b> {{can result}} from the {{multiple}} interrelated sequence diagrams drawn using the COSMIC-FFP measurement method. This is shown in “Sequence diagrams from COSMIC-FFP” and “State machine diagrams from COSMIC-FFP” sections.|$|E
30|$|We {{chose this}} class of Petri nets because of the {{similarity}} with the UML <b>state</b> <b>machines.</b> However, in order to translate our <b>state</b> <b>machines</b> <b>diagrams</b> to Petri nets, we added some elements to the previous definition. In deed, the Petri net used in our study is defined in the following Petri net Meta-model.|$|R
30|$|Petri nets are a {{promising}} tool for describing {{systems that are}} characterized as being concurrent, asynchronous, distributed, parallel, non deterministic, and/or stochastic. As a graphic tool, it is used like {{as a means of}} communication and it is similar to the <b>state</b> <b>machine</b> <b>diagram.</b>|$|R
40|$|In this paper, Serial Peripheral Interface (SPI) {{protocol}} {{is implemented}} in Field Programmable Gate Array (FPGA). Both the components SPI Master and SPI Slave are implemented using <b>state</b> <b>machine</b> <b>diagram.</b> The coding {{is done in}} Very high speed integrated circuits Hardware Descriptive Language (VHDL). The simulated data is shown and Received data is analyzed by receiving an acknowledgment...|$|R
40|$|This paper {{deals with}} a method which enables to {{describe}} a system using both UML <b>State</b> <b>Machine</b> <b>Diagrams</b> and Fuzzy-DEVS (to describe uncertain data) then to perform its simulation using DEVS formalism. The goal of the paper is to simplify the modeling of DEVS models, and also {{to take into account}} possible uncertainties on the transitions between states, by using a language based on UML <b>State</b> <b>Machine</b> <b>Diagrams.</b> This language is a part of a larger approach which final purpose is to create a high level intuitive language to enable non-computer scientists to describe DEVS models. ...|$|E
3000|$|Adjust {{the final}} state {{machines}} and approve the compatibility between scenarios and state machines {{to ensure that}} the behavior of the final <b>state</b> <b>machine</b> <b>diagrams</b> reproduce the information contained in the scenarios (Figs.  5, 6) [...]...|$|E
40|$|Abstract. The aim of {{this paper}} is to {{describe}} a systematic way to construct tests from a formal software specifica-tion for validating a system implementation. In order to achieve this goal, the specification could be extended to create UML states that directly address those aspects of the system we wish to test. The presented technique generates test cases from UML communication and <b>state</b> <b>machine</b> <b>diagrams</b> which allow testing a correct class integration of object-oriented software. UML <b>state</b> <b>machine</b> <b>diagrams</b> provide a good way for test generation in a form that can be easily manipulated. The concept of the technique and an example model are presented...|$|E
5000|$|NAT traversal, through TCP hole punching, is {{a method}} for {{establishing}} bidirectional TCP connections between Internet hosts in private networks using NAT. It does not work with all types of NATs, as their behavior is not standardized.When two hosts are connecting {{to each other in}} TCP, both via outbound connections, they are in the [...] "simultaneous TCP open" [...] case of the TCP <b>state</b> <b>machine</b> <b>diagram.</b>|$|R
40|$|This paper {{proposes a}} novel {{approach}} to the formal definition of UML semantics. We distinguish descriptive semantics from functional seman-tics of modelling languages. The former defines which system is an instance of a model while the later defines the basic concepts underlying the models. In this paper, the descriptive semantics of class diagram, interaction <b>diagram</b> and <b>state</b> <b>machine</b> <b>diagram</b> are defined by first order logic formulas. A translation tool is implemented and integrated with the theorem prover SPASS to enable auto-mated reasoning about models. The formalisation and reasoning of models is then applied to model consistency checking...|$|R
30|$|As the 2 nd step of MBD/UM as HCD cycle, {{the user}} {{requirements}} {{have to be}} determined {{on the basis of}} the specified context of use. Before clarifying the user requirements, a model of the stakeholder has to be specified by drawing the diagrams in MBSE for understanding and defining the activities of stakeholder {{on the basis of the}} context of use. Then, using the model of stakeholder, the user requirements for the product can be determined by using the requirement diagram in MBSE. And, on the basis of the user requirements, a model of product can be defined by using the <b>state</b> <b>machine</b> <b>diagram</b> in MBSE.|$|R
40|$|This {{technical}} report presents {{detail of the}} evaluation methodology used for researching the use of 3 D for UML <b>state</b> <b>machine</b> <b>diagrams.</b> The methodology is derived from a user centred design approach called “Sequential Evaluation”, which has been applied {{in the past to}} immersive virtual reality environments. This {{technical report}} first provides background into 3 D for UML, then background into 3 D for UML <b>state</b> <b>machine</b> <b>diagrams</b> and then how “Sequential Evaluation ” can be applied to evaluating 3 D UML <b>state</b> <b>machine</b> <b>diagrams.</b> This technical report does not contain results of user studies but uses information available with the UML toolset under test to demonstrate application of the evaluation methodology. The results shown are only “indicative ” i. e. they indicate the types of results that can be produced through the “Sequential Evaluation”. Actual user study based results of the application of this methodology are to be published in MODELS’ 08. This report builds on previous research, coined X 3 D-UML, where UML (Unified Modelling Language) is extended through X 3 D (eXtensible 3 D) to create a standards based approach to 3 D software visualisation...|$|E
40|$|Abstract. We outline a {{research}} proposal which {{goal is to}} contribute to methods of new Domain-Specific Languages (DSLs) definition and implementation. We propose the automata based method for DSLs definition that allows specifying new languages with various notations {{in such a way}} that the language definition can be treated as a ready-to-use language implementation already. The automata based method allows defining language by three components: language metamodel (which includes an abstract syntax), concrete syntax and operational semantics. We use Unified Modeling Language (UML) as description formalism for all three components. Namely, language metamodel is defined using class diagrams. Concrete syntax is defined as parser using <b>state</b> <b>machine</b> <b>diagrams.</b> Semantics is defined as metamodel interpreter using <b>state</b> <b>machine</b> <b>diagrams</b> as well...|$|E
40|$|For safety {{relevant}} and critical systems {{a crucial part}} of the development is a concise and complete safety requirement definition. We show how requirements can be modeled with graphical, semiformal means using the systems modeling language SysML. However, aiming at an unambiguous and formal requirement definition and verification, we do not focus on diagrams that are typically used for requirement definitions, e. g. the SysML requirement, parametric and use case diagrams. We rather use the state machine diagram to define safe and unsafe states as well as sequences of states that are expected within the overall system and within subsystems. We show how generic types of safety requirements are represented using extended versions of <b>state</b> <b>machine</b> <b>diagrams.</b> To this end we model expressions that are similar in semantics to linear temporal logic expressions using the SysML <b>state</b> <b>machine</b> <b>diagrams.</b> In particular, we can distinguish, whether a strict sequence of states is requir ed or some kind of intermediate states are allowed within the sequence, e. g. from an unintended initial unsafe state to a final safe state in case of an active safety function. Finally, we will indicate how this approach can be used in future to verify that overall <b>state</b> <b>machine</b> <b>diagrams</b> of systems or subsystems fulfill these formalized requirements...|$|E
30|$|One goal of {{participatory}} {{teaching methods}} is to engage students as active learners. McGuffee (2004) reports how he uses student led drama to teach three different reliable data transfer protocols in his computer networks course. These are namely the Alternating Bit, the Go-back-N and the Selective Repeat protocols. Traditional aids, when teaching networking protocols, are graphs, finite <b>state</b> <b>machines</b> and simulations. Classroom experience shows that confronting an average {{student with a}} finite <b>state</b> <b>machine</b> <b>diagram</b> may end up a tragedy! So, {{in order to give}} his students the opportunity to actively explore the challenges involved in reliable data transfer, McGuffy had them present the three different protocols in theatrical format. His novelty is that he leaves his students completely free to devise a way to dramatically present their assigned protocol.|$|R
40|$|In the paper, {{using of}} UML {{behavioural}} diagrams such as use cases, <b>state</b> <b>machines,</b> activity <b>diagrams</b> and interactions during Information system development is analyzed. The methodology of using these diagrams for creation of class diagrams and other specifications needed for generating code is proposed. The importance of <b>state</b> <b>machines</b> is highlighted in this methodology. MagicDraw UML tool {{is used for}} modeling and code generation...|$|R
40|$|We {{describe}} {{an approach to}} modelling a Byzantine tolerant distributed algorithm as a family of related finite <b>state</b> <b>machines,</b> generated from a single meta-model. Various artefacts are generated from each <b>state</b> <b>machine,</b> including <b>diagrams</b> and source-level protocol implementations. The approach allows a <b>state</b> <b>machine</b> formulation {{to be applied to}} problems for which it would not otherwise be suitable, increasing confidence in correctness. Comment: DSN 2007 Workshop on Architecting Dependable Systems, Edinburgh, Scotland. pp. 178 - 18...|$|R
40|$|Abstract. This paper {{proposes a}} genetic algorithm-based method to {{generate}} test cases. This method provides information for test case generation using <b>state</b> <b>machine</b> <b>diagrams.</b> Its feature is realizing automation through fewer generated test cases. In terms of automatic generation of test data based on path coverage, {{the goal is}} to build a function that can excellently assess the generated test data and guide the genetic algorithms to find the targeting parameter values...|$|E
40|$|This paper {{discusses}} {{the implementation of}} a suitable algorithm for code generation from UML <b>state</b> <b>machine</b> <b>diagrams.</b> The work includes analysis of state machines described in UML, followed by a description of the input fi le format of the proposed design of the generator and the generator itself. The generator was fully implemented in the work along with other functional requirements. At the end of this thesis is a description of the resulting implementation...|$|E
40|$|The {{basic idea}} of {{modeling}} law, as {{presented in this}} paper, is capturing domain knowledge of legislation and specifying it in a generic way by using commonly agreed and understandable modeling concepts of the Unified Modeling Language (UML). <b>State</b> <b>machine</b> <b>diagrams</b> provide a graphical notation for describing the dynamic (time-dependent) behavior of a system. Business oriented behavioral models of legislation enable to understand the system better, support the detection of anomalies and help {{to improve the quality}} of legislation by validation and verification. Different types of anomalies in legislation are classified and described in the article. More specific, this paper presents a static analysis approach to the checking of correctness and consistency of the UML <b>state</b> <b>machine</b> <b>diagrams</b> specifications of legislation. The presented framework includes semantic and syntactic anomalies. Other motivation for modeling legislation is a desire to build court case management systems. The prerequisite of building such models is the transformation of legislation and regulations into system models that focus on different aspects of the computer system, such as programs that automates the business process and business rules, database, user interface, system procedures etc. Based on empirical research, assessment of proposed method is made...|$|E
40|$|Achieving {{intelligent}} {{behavior on}} a mobile robot requires {{a mix of}} sensory processing, navigation, object manipulation, and human-robot interaction. Behavioral routines are often programmed {{as a collection of}} finite <b>state</b> <b>machines,</b> with <b>states</b> corresponding to actions, and state transitions triggered by asynchronous sensory events or timer expirations. Debugging these complex realtime behaviors or making them intelligible to a human observer can be challenging. Development of GUI tools can help programmers simplify this process. In this project, we develop a graphical &quot;storyboard &quot; representation for visualizing a robot's behavior over time. Such a representation has uses beyond debugging. It {{can be used to make}} a robot's behavior comprehensible to its users. And it can provide a visual record of the robot's &quot;performance &quot; on a task, suitable for publication or display. The tool allows user to manipulate <b>state</b> <b>machine</b> <b>diagram</b> and automatically generate a storyboard view, based on layout of the <b>state</b> <b>machine,</b> from robot's execution traces. The tool is implemented in Java on a PC, and communicates with a Sony AIBO robot dog running the Tekkotsu application development framework developed at Carnegie Mellon. ...|$|R
40|$|UML is a {{standard}} modeling language with an open notation and several concepts to be widely used in software modeling. However UML suffers {{from a lack of}} formal semantics. So, their models still need to be formally checked against incoherencies or inconsistencies. To reach this goal we propose in this paper, a framework and a tool based on graph transformation allowing an automatic translation of some UML diagrams to equivalent Maude formal specifications. To realize this automatic mapping we use UML Class diagram formalism to define three meta-models. The first one for Class Diagram, the second for <b>State</b> <b>Machine</b> <b>Diagram</b> and the third for the Communication Diagram. Then, we propose a graph grammar to generate Maude specifications of the UML diagrams based on theses meta-models. The meta-modeling tool AToM 3 is used to produce our visual modeling tool according to the proposed UML meta-models. An example is presented to illustrate our approach...|$|R
50|$|It {{seems that}} the {{additional}} diagrams were helpful in answering {{some of the questions}} more than the others. Only one question of eight in each of the cases scored lower when the combined diagrams specification was used. The SysML diagram that seems to have the biggest added value is the Block Definition Diagram (BDD), which specifies system hierarchy and features of blocks like attributes and operations. The relatively high helpfulness of the BDD is evident from both the students'assessment of the contribution of this diagram type and from analysis of the scores in the individual questions in both systems. According to the results of the experiment, the Use Case diagram seems to have the least effect on system comprehension, and this is also in agreement with the students' assessment of the Use Case diagram type contribution. In between are the Activity <b>diagram</b> and the <b>State</b> <b>Machine</b> <b>diagram,</b> which appear to have a positive effect, albeit not as high as the effect of the BDD.|$|R
3000|$|Create {{the state}} {{machines}} diagrams following {{the previous two}} steps. The sequence diagram in Fig.  3, part 1 has the following set of tuples = {(Evidence_Item, FTK_Imager, add_Evidence_Item), (Evidence_Item, Evidence_Item, add), (FTK_Imager, Image, click_Create_Image), (Image, Image, create)} while the sequence diagram in Fig.  3, part 2 has the following set of tuples = {(Evidence_Item, Evidence_Item, update), (Evidence Item, FTK_Imager, finish), (FTK_Imager, Image, generate hash), (Image, Image, store)}. Since three objects are involved in each scenario, three <b>state</b> <b>machine</b> <b>diagrams</b> can be derived as shown Fig.  4 [...]...|$|E
40|$|AbstractRefactoring is an {{important}} software development process involving the restructuring of a model to improve its internal qualities without changing its external behavior. In this paper, we propose a new approach of model refactoring based on the combined use of UML, B and CSP. UML models are described by class diagrams, OCL constraints, and <b>state</b> <b>machine</b> <b>diagrams.</b> We detail a refactoring pattern that allows for the introduction of an association relationship between two existing classes. We illustrate our proposal by giving a case study involving the SAAT (Software Architecture Analysis Tool) system...|$|E
40|$|AbstractIn this paper, a {{protection}} service model is proposed for an antivirus system. The proposed {{model has been}} focused on maintaining in secure state of the system. According to the proposed antivirus model, the required behavior has been specified as extended <b>state</b> <b>machine</b> <b>diagrams</b> and translated to temporal logic properties by using Computing Tree Logic language. Also the proposed model has been converted to aKripke Structure by using formal verification techniques. For proving the correctness and the reachability of proposed model, some properties of the proposed model are verified by using NuSMV model checker...|$|E
30|$|The ERTMS {{system is}} {{composed}} of two parts, on-track and on-board equipment. It is necessary to consider two system points of view {{in order to identify}} external actors. In the first point of view, the considered system is the on-board one, so actors are defined as driver, RBC, and GSM-R. In the second point of view, the considered system is the trackside one, so actors are defined as trains (EVCs), traffic manager, and interlocking. This allows defining system use cases which are a sequence of actions carried out by the system and producing an observable result for a particular actor. The first point of view was chosen in order to comply with the research aim and to check the EVC component. Therefore, a complete use case must be modelled in order to use it for verification and validation. The table of requirements used to model this procedure is available in [33]. This procedure is a use case for the on-board system and needs to be detailed in a <b>State</b> <b>machine</b> <b>diagram</b> {{in order to understand the}} dynamic behaviour of the EVC.|$|R
40|$|UML {{is by far}} {{the most}} widely used {{modelling}} language used nowadays in software engineering, due to its large scope and its wide tool support. This software standard of-fers many diagrams that cover all typical perspectives for describing and modelling the software systems under consideration. Among those diagrams, UML includes dia-grams (activity <b>diagram,</b> <b>state</b> <b>machine</b> <b>diagram,</b> use case diagrams, and the interaction diagrams) for describing the behaviour (or functionality) of a software system. Petri nets constitute a well-proven formal modelling language, suitable for describing the be-haviour of systems with characteristics like concurrency, distribution, resource sharing, and synchronisation. Thus, one may question why not combining some UML diagrams with Petri nets for effectively supporting the activities of the software engineer. The usage of Petri nets for/in Software Engineering was addressed by several well-known researchers, like, for example, Reisig [6], Pezze ̀ [1], Machado [5], and Kindler [4]. In this invited paper, we discuss some alternatives to introduce Petri nets into a UML-based software development process. In particular, we describe how Coloure...|$|R
40|$|International audienceThe Model Based Testing (MBT) is an {{original}} approach where test cases are automatically {{generated from the}} specifications of the system under tests. These specifications {{take the form of}} a behavioral model allowing the test generator to determine, on the one hand, the possible and relevant execution contexts. On the other hand, to predict the effects of these executions on the system. This paper proposes new methodology to generate vulnerability test cases based on SysML model of Europay-Mastercard and Visa (EMV) specifications. Our main aim is to ensure that not only the features described by the EMV specifications are met, but also that there is no vulnerability in the system. To meet these two objectives, we automatically generated concrete tests basing on SysML models. Indeed, this paper highlights the importance of modeling EMV specifications. We opted for the choice of SysML modeling language due to its ability to model Embedded Systems through several types of diagrams. In our work we used <b>state</b> <b>machine</b> <b>diagram</b> to generate vulnerability test cases for a secure and robust system...|$|R
