22|43|Public
40|$|Abstract. Security of a {{cryptographic}} {{protocol for}} a bounded number of sessions is usually {{expressed as a}} <b>symbolic</b> <b>trace</b> reachability problem. We show that <b>symbolic</b> <b>trace</b> reachability for well-defined protocols is decidable in presence of the exclusive or theory {{in combination with the}} homomorphism axiom. These theories allow us to model basic properties of important cryptographic operators. This trace reachability problem can be expressed as a system of symbolic deducibility constraints for a certain inference system describing the capabilities of the attacker. One main step of our proof consists in reducing deducibility constraints to constraints for deducibility in one step of the inference system. This constraint system, in turn, can be expressed as a system of quadratic equations of a particular form over Z/ 2 Z[h], the ring of polynomials in one indeterminate over the finite field Z/ 2 Z. We show that satisfiability of such systems is decidable. ...|$|E
40|$|We {{demonstrate}} that for any well-defined cryptographic protocol, the <b>symbolic</b> <b>trace</b> reachability {{problem in the}} presence of an Abelian group operator (e. g., multiplication) can be reduced to solvability of a decidable system of quadratic Diophantine equations. This result enables complete, fully automated formal analysis of protocols that employ primitives such as Diffie-Hellman exponentiation, multiplication, and xor, with a bounded number of role instances, but without imposing any bounds on the size of terms created by the attacker. ...|$|E
40|$|We present STA (<b>Symbolic</b> <b>Trace</b> Analyzer), a {{tool for}} the {{analysis}} of security protocols. STA relies on symbolic techniques that avoid explicit construction of the whole, possibly infinite, state-space of protocols. This results in accurate protocol modeling, increased efficiency and more direct formalization, when compared to finitestate techniques. We illustrate the use of STA by analyzing two well-known protocols, asymmetric Needham Schroeder and Kerberos. We discuss the results of this analysis, and contrast them with previous work based on finite-state model checking. 1...|$|E
40|$|Abstract. A {{notion of}} open bisimulation is {{formulated}} for the spi calculus, {{an extension of}} the πcalculus with cryptographic primitives. In this formulation, open bisimulation is indexed by pairs of <b>symbolic</b> <b>traces,</b> which represent the history of interactions between the environment with the pairs of processes being checked for bisimilarity. The use of <b>symbolic</b> <b>traces</b> allows for a symbolic treatment of bound input in bisimulation checking which avoids quantification over input values. Open bisimilarity is shown to be sound with respect to testing equivalence, and futher, it is shown to be an equivalence relation on processes and a congruence on finite processes. ...|$|R
40|$|A {{notion of}} open bisimulation is {{formulated}} for the spi calculus, {{an extension of}} the pi-calculus with cryptographic primitives. In this formulation, open bisimulation is indexed by pairs of <b>symbolic</b> <b>traces,</b> which represent the history of interactions between the environment with the pairs of processes being checked for bisimilarity. The use of <b>symbolic</b> <b>traces</b> allows for a symbolic treatment of bound input in bisimulation checking which avoids quantification over input values. Open bisimilarity is shown to be sound with respect to testing equivalence, and futher, it is shown to be an equivalence relation on processes and a congruence relation on finite processes. As far as we know, this is the first formulation of open bisimulation for the spi calculus for which the congruence result is proved. Comment: This is a revised and extended version of a conference paper presented at APLAS 200...|$|R
40|$|We {{present an}} {{analysis}} technique for structured sequential programs based upon abstract reasoning over <b>symbolic</b> <b>traces.</b> The novelty {{is that the}} technique performs abstraction on demand, as opposed to systematically, {{in the pursuit of}} a safety proof. The idea is to maintain precision to enhance the likelihood of proof, performing abstraction only when efficiency is at stake. The technique is automatic in the sense that no user input is required. The main technical result is analysis of bounded programs, those whose <b>symbolic</b> <b>traces</b> are bounded in length, where the analysis is exact. For example, loop-free programs fall into this class. While the problem is exponential-time in general, we introduce a notion of dynamic summarizations which can enable substantial pruning of the search space of traces. Summarizations also allow our analysis to be compositional, key to extending the boundedprogram analysis technique to the general case. Finally, the technique is tunable, primarily for two reasons. First, the technique is compositional. Second, the technique at its core is a function which generalizes a set of constraints, and custom functions may be directly used. 1...|$|R
40|$|Abstract. We {{consider}} security {{properties of}} cryptographic protocols, {{that are either}} trace properties (such as confidentiality or authenticity) or equivalence properties (such as anonymity or strong secrecy). Infinite sets of possible traces are symbolically represented using deducibility constraints. We give a new algorithm that decides the trace equivalence for the traces that are represented using such constraints, {{in the case of}} signatures, symmetric and asymmetric encryptions. Our algorithm is implemented and performs well on typical benchmarks. This is the first implemented algorithm, deciding <b>symbolic</b> <b>trace</b> equivalence. ...|$|E
40|$|Abstract. The {{symbolic}} {{verification of}} the security property of a cryptographic protocol for a bounded number of sessions is usually expressed as a <b>symbolic</b> <b>trace</b> reachability problem. Such a problem can be expressed as a constraint system for deducibility constraints for a certain inference system describing the possible actions of an attacker. We show that <b>symbolic</b> <b>trace</b> reachability for well-defined protocols is decidable in presence of both the exclusive or operator and a homomorphism over this operator. The exclusive or operator is often used in security protocols as a symmetric encryption operation. The homomorphism may model a hash function, or {{may be used to}} model a special situation in asymmetric encryption where an intruder may encrypt a message but can never learn about the corresponding decryption key. One main step of our proof consists in reducing the constraint system for deducibility into a constraint system for deducibility in one step and using one particular rule of the constraint system. This constraint system, in turn, can be expressed as a system of quadratic equations of a particular form over the ring of polynomials in one indeterminate over the finite field Z/ 2 Z[h]. We show that satisfiability of these systems of equations is decidable. ...|$|E
40|$|Abstract. We {{demonstrate}} that the <b>symbolic</b> <b>trace</b> reachability problem for cryptographic protocols is decidable {{in the presence of}} an Abelian group operator and modular exponentiation from arbitrary bases. We represent the problem as a sequence of symbolic inference constraints and reduce it to a system of linear Diophantine equations. For a finite number of protocol sessions, this result enables fully automated, sound and complete analysis of protocols that employ primitives such as DiffieHellman exponentiation and modular multiplication without imposing any bounds on the size of terms created by the attacker, but taking into account the relevant algebraic properties...|$|E
40|$|In {{this paper}} we propose an {{approach}} to efficient automating test technology for industrial software projects, that uses a formal model of the system, automatically performs a symbolic verification, generation and concretization of the <b>symbolic</b> <b>traces,</b> the generation of test suites for concretized traces, and also includes tools for analysis of the testing results, allowing users to automate the full cycle of testing. Particular {{emphasis is placed on}} the presentation of the algorithm concretization and setting of test scenarios. </p...|$|R
40|$|International audienceCircus is a state-rich process algebra {{based on}} Z and CSP {{that can be}} used for testing. In this paper, we {{consider}} data-flow coverage. In adapting the classical results on coverage of programs to Circus models, we define a notion of specification traces, consider models with data-flow anomalies, and cater for the internal nature of state. Our results are a framework for data-flow coverage of such abstract models, a novel data-flow criterion suited to state-rich process models, and the conversion of specification <b>traces</b> into <b>symbolic</b> <b>traces...</b>|$|R
40|$|Given two MIPS programs, {{when are}} they equivalent? At first glance, this is tricky to define, {{because of the}} {{unstructured}} nature of assembly code. We propose the use of alternating concolic execution to detect whether two programs are disequivalent. We have implemented our approach in a tool called Tamarin, which includes a MIPS emulator instrumented to record <b>symbolic</b> <b>traces,</b> {{as well as a}} concolic execution engine that integrates with the Z 3 solver. We show that Tamarin is able to reason about program disequivalence in a number of scenarios, without any a-priori knowledge about the MIPS programs under consideration. Comment: Technical Repor...|$|R
40|$|To {{evaluate}} {{the performance of}} a memory system, computer architects must determine the miss rate m of a cache C when running program P. Typically, the measured miss rate depends on the specific address mapping M of P set arbitrarily by the compiler and linker. In this paper, we remove the effect of the address-mapping on the miss rate by analyzing a <b>symbolic</b> <b>trace</b> T of basic blocks. By assuming each basic block has an equal probability of ending up anywhere in the address map, we determine the expected miss rate averaged over all possible address mappings...|$|E
40|$|Abstract — Analog and Mixed Signal (AMS) {{designs are}} im-portant {{integrated}} systems that link digital circuits to the analog world. Following {{the success of}} PSL verification methodolo-gies, recent research suggested extending PSL to support AMS systems. However, PSL has been defined initially to formalize properties about logical signals using models such as automata. In fact, the presence of continuous signals in AMS systems and the continuous notion of time are the main obstacles in adopting PSL. In this paper, we propose an approach to verify PSL properties for a class of AMS systems. Our approach is based on modeling the AMS design {{in terms of a}} System of Recurrence Equations (SRE). Then, we define an Assertion Based Verification method using the <b>symbolic</b> <b>trace</b> of SRE. I...|$|E
40|$|We {{demonstrate}} that for any well-defined cryptographic protocol, the <b>symbolic</b> <b>trace</b> reachability {{problem in the}} presence of an Abelian group operator (e. g., multiplica-tion) can be reduced to solvability of a particular system of quadratic Diophantine equations. This result enables for-mal analysis of protocols that employ primitives such as Diffie-Hellman exponentiation, products, and xor, with a bounded number of role instances, but without imposing any bounds on the size of terms created by the attacker. In the case of xor, the resulting system of Diophantine equa-tions is decidable. In the case of a general Abelian group, decidability remains an open question, but our reduction demonstrates that standard mathematical techniques for solving systems of Diophantine equations are sufficient for the discovery of protocol insecurities. 1...|$|E
40|$|International audienceThe {{synchronous}} language Lustre and its descendants {{have long}} been used to program and model discrete controllers. Recent work shows how to mix discrete and continuous elements in a Lustre-like language called Zélus. The resulting hybrid programs are deterministic and can be simulated with a numerical solver. In this article, we focus on a subset of hybrid programs where continuous behaviors are expressed using timers, nondeterministic guards, and invariants, as in Timed Safety Automata. We propose a source-to-source compilation pass to generate discrete code that, coupled with standard operations on Difference-Bound Matrices, produces <b>symbolic</b> <b>traces</b> that each represent a set of concrete traces...|$|R
40|$|We propose PS-LTL, a pure-past {{security}} linear {{temporal logic}} {{that allows the}} specification {{of a variety of}} authentication, secrecy and data freshness properties. Furthermore, we present a sound and complete decision procedure to establish the validity of security properties for <b>symbolic</b> execution <b>traces,</b> and show the integration with constraintbased analysis techniques. ...|$|R
40|$|This paper {{addresses}} {{the problem of}} efficient and accurate performance analysis to drive the exploration and design of bus-based System-on-Chip (SOC) communication architectures. Our technique fills a gap in existing techniques for system-level performance analysis, which are either too slow to use in an iterative communication architecture design framework (e. g., simulation of the complete system), or are not accurate enough to drive {{the design of the}} communication architecture (e. g., techniques that perform a "static" analysis of the system performance). The proposed system-level performance analysis technique consists of (i) initial co-simulation performed after HW/SW partitioning and mapping, with the communication between components modeled in an abstract manner (e. g., as events or data transfers), (ii) extraction of abstracted <b>symbolic</b> <b>traces,</b> represented as a Bus and Synchronization Event (BSE) Graph, that captures the activity of the various system components and their communic [...] ...|$|R
40|$|International audienceTESL {{addresses}} the specification {{of the temporal}} aspects of an architectural composition language that allows the composition of timed subsystems. TESL specifies the synchronization points between events and time scales. Methodologically, subsystems having potentially different models of execution are abstracted to their interfaces {{expressed in terms of}} timed events. In this paper, we present an operational semantics of TESL for constructing symbolic traces {{that can be used in}} an online-test scenario: the <b>symbolic</b> <b>trace</b> containing a set of constraints over time-stamps and occurrences of events is matched against concrete runs of the system. We present the operational rules for building symbolic traces and illustrate them with examples. Finally, we show a prototype implementation that generates symbolic traces, and its use for testing...|$|E
40|$|It {{is shown}} that black-box derandomization of {{polynomial}} identity testing (PIT) is essentially equivalent to derandomization of Noether’s Normalization Lemma for explicit algebraic varieties, {{the problem that}} {{lies at the heart of}} the foundational classification problem of algebraic geometry. Specifically: (1) It is shown that in characteristic zero black-box derandomization of the <b>symbolic</b> <b>trace</b> identity testing (STIT) brings the problem of derandomizing Noether’s Normalization Lemma for the ring of invariants of the adjoint action of the general linear group on a tuple of matrices from EXPSPACE (where it is currently) to P. Next it is shown that assuming the Generalized Riemann Hypothesis (GRH), instead of the blackbox derandomization hypothesis, brings the problem from EXPSPACE to quasi-PH, instead of P. Thus black-box derandomizatio...|$|E
40|$|Abstract We {{demonstrate}} that for any well-defined cryptographicprotocol, the <b>symbolic</b> <b>trace</b> reachability {{problem in the}} presence of an Abelian group operator (e. g., multiplica-tion) can be reduced to solvability of a particular system of quadratic Diophantine equations. This result enables for-mal analysis of protocols that employ primitives such as Diffie-Hellman exponentiation, products, and xor, with abounded number of role instances, but without imposing any bounds on the size of terms created by the attacker. Inthe case of xor, the resulting system of Diophantine equa-tions is decidable. In the case of a general Abelian group, decidability remains an open question, but our reductiondemonstrates that standard mathematical techniques for solving systems of Diophantine equations are sufficient forthe discovery of protocol insecurities. 1...|$|E
5000|$|In {{reference}} to the work, Zurob stated, [...] "Through the use of oil and acrylic paint and other mediums, I {{try to create a}} world which is composed of three worlds: exile where the artist lives (the father), and who appears in the paintings as the sole living human being by the depiction of the son who is portrayed in a relatively small scale in contrast to his surroundings. The second world concerns Qoudsi himself, as he visually appears and in his manner of showing his feelings through the use of his toys and his interactions with them. The third world is one of space, where we come from, which is depicted through walls, and multilayered backgrounds, as <b>symbolic</b> <b>traces</b> of the complex life that does not enable Qoudsi and me to meet. Yet, it is in my construction of a virtual world where a space for such a meeting occurs." ...|$|R
40|$|We {{consider}} a formalisation of {{a notion of}} observer (or intruder) theories, commonly used in symbolic analysis of security protocols. An observer theory describes the knowledge and capabilities of an observer, and can be given a formal account using deductive systems, such as those used in various “environment-sensitive ” bisimulation for process calculi, e. g., the spi-calculus. Two notions are critical to the correctness of such formalisations and the effectiveness of symbolic techniques based on them: decidability of message deduction by the observer and consistency of a given observer theory. We {{consider a}} formalisation, in Isabelle/HOL, of both notions based on an encoding of observer theories as pairs of <b>symbolic</b> <b>traces.</b> This encoding has recently been used in a theory of open bisimulation for the spi-calculus. We machine-checked some important properties, including decidability of observer deduction and consistency, and some key steps which are crucial to the automation of open bisimulation checking for the spi-calculus, and highlight some novelty in our Isabelle/HOL formalisations of decidability proofs...|$|R
40|$|Several formal {{approaches}} {{have been proposed}} to analyse security protocols, e. g. [2, 7, 11, 1, 6, 12]. Recently, a great interest has been growing {{on the use of}} constraint solving approach. Initially proposed by Millen and Shmatikov [9], this approach allows analysis of a finite number of protocol sessions. Yet, the representation of protocol runs by <b>symbolic</b> <b>traces</b> (as opposed to concrete traces) captures the possibility of having unbounded message space, allowing analysis over an infinite state space. A constraint is defined as a pair consisting of a message M and a set of messages K that represents the intruder¿s knowledge. Millen and Shmatikov present a procedure to solve a set of constraints, i. e. that in each constraint, M can be built from K. When a set of constraints is solved, then a concrete trace representing an attack over the protocol can be extracted. Corin and Etalle [4] has improved the work of Millen and Shmatikov by presenting a more efficient procedure. However, none of these constraint-based systems provide enough flexibility and expresiveness in specifying security properties. For example, to check secrecy an artificial protocol role is added to simulate whether a secret can be learned by an intruder. Authentication cannot also be checked directly. Moreover, only a built-in notion of authentication is implemented by Millen and Shmatikov in his Prolog implementation [10]. This problem motivates our current work. A logical formalism is considered to be an appropriate solution to improve the flexibility and expresiveness in specifying security properties. A preliminary attempt to use logic for specifying local security properties in a constraint-based setting has been carried out [3]. Inspired by this work and the successful NPATRL [11, 8], we currently explores a variant of linear temporal logic (LTL) over finite traces, -LTL, standing for pure-past security LTL [5]. In contrast to standard LTL, this logic deals only with past events in a trace. In our current work, a protocol is modelled as in previous works [9, 4, 3], viz. by protocol roles. A protocol role is a sequence of send and receive events, together with status events to indicate, e. g. that a protocol role has completed her protocol run. A scenario is then used to deal with the number of sessions and protocol roles considered in the analysis. Integrating -LTL into our constraint solving approach presents a challenge, since we need to develop a sound and complete decision procedure against <b>symbolic</b> <b>traces,</b> instead of concrete traces. Our idea to address this problem is by concretizing <b>symbolic</b> <b>traces</b> incrementally while deciding a formula. Basically, the decision procedure consists of two steps: transform and decide. The former step transforms a -LTL formula with respect to the current trace into a so-called elementary formula that is built from constraints and equalities using logical connectives and quantifiers. The decision is then performed by the latter step through solving the constraints and checking the equalities. Although we define a decision procedure for a fragment of -LTL, this fragment is expressive enough to specify several security properties, like various notions of secrecy and authentication, and also data freshness. We provide a Prolog implementation and have analysed several security protocols. There are many directions for improvement. From the implementation point of view, the efficiency of the decision procedure can still be improved. I would also like to investigate the expressiveness of the logic for speficying other security properties. This may result in an extension of the decision procedure for a larger fragment of the logic. Another direction is to characterize the expressivity power of -LTL compared to other security requirement languages...|$|R
40|$|Abstract. In Eurocrypt 2010, Miccinacio {{initiated}} {{an investigation}} of cryptographically sound, symbolic security analysis with respect to coinductive adversarial knowledge, and demonstrated that under an adversarially passive model, certain security criteria (e. g. indistinguishability) may be given a computationally sound symbolic characterization, without the assumption of key acyclicity. Left open in his work was the fundamental question of “the viability of extending the coinductive approach to prove computational soundness results {{in the presence of}} active adversaries. ” In this paper we make some initial steps toward answering this question in the affirmative with respect to an extension of a trace-based security model (proposed by Micciancio and Warinschi in TCC 2004) including asymmetric and symmetric encryption; in particular we prove that a random computational trace can be soundly abstracted by a coinductive <b>symbolic</b> <b>trace</b> with overwhelming probability, provided that both the underlying encryption schemes provide IND-CCA 2 security (plus ciphertext integrity for the symmetric scheme), and that the diameter of the underlying coinductively-hidden subgraph is constant in every <b>symbolic</b> <b>trace.</b> This result holds even if the protocol allows arbitrarily nested applications of symmetric/asymmetric encryption, unrestricted transmission of symmetric keys, and adversaries who adaptively corrupt users, along with other forms of active attack. As part of our proof, we formulate a game-based definition of encryption security allowing adaptive corruptions of keys and certain forms of adaptive key-dependent plaintext attack, along with other common forms of CCA 2 attack. We prove that (with assumptions similar to above,) security under this game is implied by IND-CCA 2 security. This also characterizes a provably benign form of cyclic encryption which can be achieved under standard notions of encryption security, which may be of independent interest...|$|E
40|$|It {{is shown}} that black-box derandomization of {{polynomial}} identity testing (PIT) is essentially equivalent to derandomization of Noether’s Normalization Lemma for explicit algebraic varieties, {{the problem that}} {{lies at the heart of}} the foundational classification problem of algebraic geometry. Specifically: (1) It is shown that in characteristic zero black-box derandomization of the <b>symbolic</b> <b>trace</b> or determinant identity testing (STIT or equivalently SDIT) brings the problem of derandomizing Noether’s Normalization Lemma for the ring of invariants of the adjoint action of the general linear group on a tuple of matrices from EXPSPACE (where it is currently) to P. NextitisshownthatassumingtheGeneralizedRiemannHypothesis(GRH),insteadofthe black-box derandomization hypothesis, brings the problem from EXPSPACE to quasi-PH, instead of P. Thus black-box derandomization of STIT takes us farther than GRH. Variants of the main implication are also shown assuming, instead of the black-box derandomization hypothesis in characteristic zero, Boolean lower bounds for constant-depth threshold circuits or uniform Boolean conjectures, in conjunction with GRH. These and related results ma...|$|E
40|$|We {{introduce}} the symbolic simulation function implemented in our model-checker/simulator RED 4. 0 for dense-time concurrent systems. By representing and manipulating state-spaces as logic predicates, {{the technique of}} symbolic simulation can lead to high performance by encoding even a dense amount of traces in traditional simulation into one <b>symbolic</b> <b>trace.</b> Symbolic simulation adds the dimension of width to a trace of state-spaces. By controlling the width of traces, we {{have a much better}} chance to find bugs using fewer traces. Our main contribution is the design of symbolic simulation function in RED 4. 0 for dense-time concurrent systems. In our tool, users can strongly control the width of traces and the generation of traces. We discuss how to generate traces using various policies, how to manipulate the state-predicate, and how to manage the trace trees. Moreover, we design a C-like language whose programs can be mechanically translated into the optimized communicating timed automata(CTA). Engineers can also put down comment-line assertions as specifications in their verification tasks. Finally, experiments using our simulator to verify the Bluetooth baseband protocol justify the usefulness of our tool...|$|E
40|$|Abstract. Several formal {{approaches}} {{have been proposed}} to analyse security protocols, e. g. [2, 7, 11, 1, 6, 12]. Recently, a great interest has been growing {{on the use of}} constraint solving approach. Initially proposed by Millen and Shmatikov [9], this approach allows analysis of a finite number of protocol sessions. Yet, the representation of protocol runs by <b>symbolic</b> <b>traces</b> (as opposed to concrete traces) captures the possibility of having unbounded message space, allowing analysis over an infinite state space. A constraint is defined as a pair consisting of a message M and a set of messages K that represents the intruder’s knowledge. Millen and Shmatikov present a procedure to solve a set of constraints, i. e. that in each constraint, M can be built from K. When a set of constraints is solved, then a concrete trace representing an attack over the protocol can be extracted. Corin and Etalle [4] has improved the work of Millen and Shmatikov by presenting a more efficient procedure. However, none of thes...|$|R
40|$|We {{consider}} {{the problem of}} determining tight conservative estimations of the worst case execution time. This problem is in general difficult even {{in the presence of}} simplifying assumptions, hence most methods rely on an interplay between various methods of abstraction and user provided (but not validated) annotations to achieve efficient and precise estimations. We present an algorithm which enumerates <b>symbolic</b> <b>traces</b> of a program. A key feature is the use of dynamic summarizations to capture abstract, yet context-dependent, input-output relationships that can be subsequently reused. This allows, in general, a {{reduction in the number of}} traces that need be considered. The algorithm is designed for userprovided input in the form of symbolic constraints. The important point here is that this information is eventually validated, finally resulting in a guaranteed resource estimate. Finally, the algorithm considers programs that are hierarchically structured. Besides leading to a compositional approach, this facilitates the specification of user assertions and guides the processes of summarization, re-use, and assertion validation, and allows the user to explore trade-offs between efficiency and precision. ...|$|R
50|$|Currently, runtime {{verification}} {{techniques are}} often presented with various alternative names, such as runtime monitoring, runtime checking, runtime reflection, runtime analysis, dynamic analysis, runtime/dynamic <b>symbolic</b> analysis, <b>trace</b> analysis, log file analysis, etc., all referring to instances {{of the same}} high-level concept applied either to different areas or by scholars from different communities. Runtime verification is intimately related to other well-established areas, such as testing (particularly model-based testing) when used before deployment and fault-tolerant systems when used during deployment.|$|R
40|$|Mobile {{agents have}} been {{implemented}} in e-commerce to search and filter information of interest from electronic markets. When the in format ion is very sensitive and critical, {{it is important to}} develop a novel security protocol that can efficiently protect the information from malicious tampering as well as unauthorized disclosure or at least detect any malicious act of intruders. In this chapter, we describe robust security techniques that ensure a sound security of information gathered throughout agent 2 ̆ 7 s itinerary against various security attacks, as well as truncation attacks. A sound security protocol is described, which implements the various security techniques that would jointly prevent or at least detect any malicious act of intruders. We reason about the soundness of the protocol using <b>Symbolic</b> <b>Trace</b> Analyzer (STA), a formal verification tool that is based on symbolic techniques. We analyze the protocol in key configurations and show that it is free of flaws. We also show that the protocol fulfils the various security requirements of exchanged information in MAS, including data-integrity, data-confidentiality, data authenticity, origin confidentiality and data non-repudiability. <br /...|$|E
40|$|In {{this paper}} we give a brief status {{report on the}} new LOTOS {{simulator}} that is being developed in the ESPRIT LOTOSPHERE project. We discuss its functionality, first experiments with its use, and some discussion of the tool architecture and tool technology related to it. It {{should be noted that}} this tool is preliminary and not yet distributed. 1 Introduction The symbolic simulator SMILE is a tool for the exploration of the behaviour of full LOTOS IS 8807 specifications. It has a number of features to distinguish itself from its predecessor HIPPO[vE 89]. It is fully symbolic, it does better condition solving and it runs faster (4 - 8 times) in less space. 2 Basic Model SMILE is fully symbolic, which means that the behaviour that follows a certain event can be studied without instantiating the variables of the event. This makes it possible to study a <b>symbolic</b> <b>trace,</b> and observe e. g. that an event with a certain value is eventually followed by another event with that value, regardless of th [...] ...|$|E
40|$|It {{is shown}} {{that the problem of}} derandomizing Noether’s Normalization Lemma (NNL) in a strong form for the ring of invariants of the adjoint action of the general linear group on a tuple of {{matrices}} can be brought down from EXPSPACE (where it was earlier) to PSPACE unconditionally, to PH assuming the Generalized Riemann Hypothesis (GRH), and to P assuming the black-box derandomization hypothesis for <b>symbolic</b> <b>trace</b> identity testing (STIT) or equivalently symbolic determinant identity testing (SDIT). This derandomization problem {{lies at the heart of}} the wild problem of classifying tuples of matrices to which the problem of classifying representations of any (finite dimensional) algebra or quiver can be reduced. By the result here, black-box derandomization of STIT implies an explicit solution to a coarser version of this classification problem, namely, the problem of explicitly parametrizing and decomposing the semi-simple tuples (i. e. tuples with closed orbits), where the phrase explicit has a precise complexity theoretic meaning. Variants of the result are also shown assuming, instead of the black-box derandomization hypothesis, arithmetic lower bounds for constant depth circuits, or Boolean lower bounds for constant-depth threshol...|$|E
40|$|The paper {{describes}} {{a system which}} is able, given execution traces of formal program specifications, to surmise relevant program properties. The system is embedded {{in an environment of}} software development by levels of abstractions. A surmising algorithm is given which is based on generalization, instantiation by symbolic execution and <b>symbolic</b> execution <b>trace</b> analysis. Examples are given which illustrate the behaviour and the capabilities of the system. Finally, conditions are given on program specification schemata which guarantee that the surmised properties actually hold...|$|R
40|$|This paper {{addresses}} {{the problem of}} efficient and accurate performance analysis to drive the exploration and design of bus-based System-on-Chip (SOC) communication architectures. Our technique fills a gap in existing techniques for system-level performance analysis, which are either too slow to use in an iterative communication architecture design framework (e. g., simulation of the complete system), or are not accurate enough to drive {{the design of the}} communication architecture (e. g., techniques that perform a “static ” analysis of the system performance). The proposed system-level performance analysis technique consists of (i) initial co-simulation performed after HW/SW partitioning and mapping, manner (e. g., as events or data transfers), (ii) extraction of abstracted <b>symbolic</b> <b>traces,</b> represented as a Bus and Synchronization Event (BSE) Graph, that captures the activity of the various system components and their communication over time, and (iii) manipulation of the BSE Graph using the bus parameters, to derive the behavior of the system accounting for effects of the bus architecture. We present experimental results on several example systems, including a TCP/IP network interface card sub-system. The results indicate that our performance estimation technique is over two orders of magnitude faster than performing a complete system simulation, while being very accurate (within 2 : 2 % of performance estimates derived from accurate HW/SW co-simulation). I...|$|R
30|$|We {{previously}} {{analyzed the}} patients undergoing the depicted interventions {{by means of}} their HRV, BPV, and BRS in pairwise settings, i.e., AVR vs MVR and AVR vs TAVI [12, 13]. The present contribution pooled together and widened the mentioned studies in terms of implicated patients, applied methods, and finally drew conclusions. That is to say, we review major findings related to HRV and BRS {{in the face of}} a more complete patient collective and complement such considerations by the analysis of cardiovascular coupling between the heart rate (HR) and blood pressure (BP) by means of <b>symbolic</b> coupling <b>traces</b> (SCT) [14] which are applied for the first time in the presented setting.|$|R
