1320|867|Public
5|$|Culik {{begins with}} the {{observation}} that a cellular automaton has an injective transition function {{if and only if}} the transition function is injective on the subsets of configurations that are periodic (repeating the same <b>substring</b> infinitely often in both directions). He defines a nondeterministic finite-state transducer that performs the transition rule of the automaton on periodic strings. This transducer works by remembering the neighborhood of the automaton {{at the start of the}} string and entering an accepting state when that neighborhood concatenated to the end of the input would cause its nondeterministically chosen transitions to be correct. Culik then swaps the input and output of the transducer. The transducer resulting from this swap simulates the inverse dynamics of the given automaton. Finally, Culik applies previously known algorithms to test whether the resulting swapped transducer maps each input to a single output.|$|E
25|$|A {{sequence}} is normal if {{and only if}} every block of equal length appears with equal frequency. (A block of length k is a <b>substring</b> of length k appearing at a position in the sequence that is a multiple of k: e.g. the first length-k block in S is S, the second length-k block is S, etc.) This was implicit in the work of Ziv and Lempel (1978) and made explicit in the work of Bourke, Hitchcock, and Vinodchandran (2005).|$|E
25|$|The Visual Studio 2010 code editor now {{highlights}} references; {{whenever a}} symbol is selected, all other usages of the symbol are highlighted. It {{also offers a}} Quick Search feature to incrementally search across all symbols in C++, C# and VB.NET projects. Quick Search supports <b>substring</b> matches and camelCase searches. The Call Hierarchy feature allows the developer {{to see all the}} methods that are called from a current method as well as the methods that call the current one. IntelliSense in Visual Studio supports a consume-first mode which developers can opt into. In this mode, IntelliSense does not auto-complete identifiers; this allows the developer to use undefined identifiers (like variable or method names) and define those later. Visual Studio 2010 can also help in this by automatically defining them, if it can infer their types from usage. Current versions of Visual Studio have a known bug which makes IntelliSense unusable for projects using pure C (not C++).|$|E
40|$|This paper {{provides}} {{experimental results}} showing {{that we can}} use maximal <b>substrings</b> as elementary building blocks of documents in place of the words extracted by a current state-of-the-art supervised word extraction. Maximal <b>substrings</b> are defined as the <b>substrings</b> each giving a smaller number of occurrences even by appending only one character to its head or tail. The main feature of maximal <b>substrings</b> is that they can be extracted quite efficiently in an unsupervised manner. We extract maximal <b>substrings</b> from a document set and represent each document as a bag of maximal <b>substrings.</b> We also obtain a bag of words representation by using a state-of-the-art supervised word extraction over the same document set. We then apply the same document clustering method to both representations and obtain two clustering results for a comparison of their quality. We adopt a Bayesian document clustering based on Dirichlet compound multinomials for avoiding overfitting. Our experiment shows that the clustering quality achieved with maximal <b>substrings</b> is acceptable enough to use them in place of the words extracted by a supervised word extraction...|$|R
40|$|In {{this note}} we define {{circular}} k-successions in permutations in one-line notation and count permutations that avoid <b>substrings</b> j(j+k) and j(j+k) (mod n). We also count circular permutations that avoid such <b>substrings,</b> {{and show that}} for <b>substrings</b> j(j+k) (mod n), the number of permutations depends on whether n is prime, and more generally, on whether n and k are relatively prime...|$|R
5000|$|The maximal {{of these}} longest common suffixes of {{possible}} prefixes {{must be the}} longest common <b>substrings</b> of S and T. These are shown on diagonals, in red, in the table. For this example, the longest common <b>substrings</b> are [...] "BAB" [...] and [...] "ABA".|$|R
2500|$|Many string {{algorithms}} including longest common subsequence, longest increasing subsequence, longest common <b>substring,</b> Levenshtein distance (edit distance) ...|$|E
2500|$|... where { ... }S {{indicates}} a <b>substring</b> recognized {{as belonging to}} S. This hierarchy {{can also be seen}} as a tree: ...|$|E
2500|$|... {{denotes the}} i-th {{character}} of , where [...] [...] denotes a <b>substring</b> of size , ranging from i-th to the j-th character of [...] [...] is the reversed version of [...]|$|E
40|$|In this paper, {{we propose}} {{a new type}} of Dictionary-based Entity Recognition Problem, named Approximate Membership Localization (AML). The popular Approximate Membership Extraction (AME) {{provides}} a full coverage to the true matched <b>substrings</b> from a given document, but many redundancies cause a low efficiency of the AME process and deteriorate the performance of real-world applications using the extracted <b>substrings.</b> The AML problem targets at locating nonoverlapped <b>substrings</b> which is a better approximation to the true matched <b>substrings</b> without generating overlapped redundancies. In order to perform AML efficiently, we propose the optimized algorithm P-Prune that prunes a large part of overlapped redundant matched <b>substrings</b> before generating them. Our study using several real-word data sets demonstrates the efficiency of P-Prune over a baseline method. We also study the AML in application to a proposed web-based join framework scenario which is a search-based approach joining two tables using dictionary-based entity recognition from web documents. The results not only prove the advantage of AML over AME, but also demonstrate the effectiveness of our search-based approach...|$|R
5000|$|... #Subtitle level 2: Shifting <b>substrings</b> {{search and}} {{competing}} algorithms ...|$|R
50|$|We assume all the <b>substrings</b> have a {{fixed length}} m.|$|R
2500|$|The free {{group with}} two {{generators}} a and b consists of all finite strings {{that can be}} formed from the four symbols a, aminus&1, b and bminus&1 such that no a appears directly next to an aminus&1 and no b appears directly next to a bminus&1. Two such strings can be concatenated and converted into a string of this type by repeatedly replacing the [...] "forbidden" [...] substrings with the empty string. For instance: ababminus&1aminus&1 concatenated with ababminus&1a yields ababminus&1aminus&1ababminus&1a, which contains the <b>substring</b> aminus&1a, and so gets reduced to ababminus&1babminus&1a, which contains the <b>substring</b> bminus&1b, which gets reduced to abaabminus&1a. One can check that the set of those strings with this operation forms a group with identity element the empty string e. This group may be called F2.|$|E
2500|$|... {{for each}} a. [...] Now let w be any finite string in Σ and let NS(w, n) {{to be the}} number of times the string w appears as a <b>substring</b> in the first n digits of the {{sequence}} S. (For instance, if S = 01010101..., then NS(010, 8) = 3.) S is normal if, for all finite strings w ∈ Σ, ...|$|E
2500|$|Using reduced words one may define three partial orders on the Coxeter group, the (right) weak order, the {{absolute}} {{order and the}} Bruhat order (named for François Bruhat). An element v exceeds an element u in the Bruhat order if some (or equivalently, any) reduced word for v contains a reduced word for u as a <b>substring,</b> where some letters (in any position) are dropped. In the weak order, v ≥ u if some reduced word for v contains a reduced word for u as an initial segment. Indeed, the word length makes this into a graded poset. The Hasse diagrams corresponding to these orders are objects of study, and {{are related to the}} Cayley graph determined by the generators. [...] The absolute order is defined analogously to the weak order, but with generating set/alphabet consisting of all conjugates of the Coxeter generators.|$|E
40|$|A {{system for}} {{aligning}} nucleotide or amino acid biosequences is described. The system, called Neweyes, employs a novel string matching algorithm, Running Karp-Rabin Greedy String T’ding (RKR [...] GST), which involves tiling one string with matching <b>substrings</b> {{of a second}} string. In practice, RKR-GST has a computational complexity that appears close to linear. With RKR-GST, Neweyes is able to detect transposed <b>substrings</b> or <b>substrings</b> of one biosequence that appears rearranged in a second sequence. Repeated <b>substrings</b> can also be detected. Neweyes also supports a form of matching-by-group that gives the effect of different amino acid mutation matrices. Neweyes {{can be used in}} a macro mode (searching database for a list of biosequences that are similar to a given biosequence) or in a micro mode, where two biosequences are compared and more detailed output formats are available...|$|R
500|$|... which tallies or replaces {{instances}} of specified <b>substrings</b> within a string.|$|R
40|$|This paper studies several {{combinatorial}} problems {{arising from}} finding the conserved genes of two genomes (i. e., the entire DNA of two species). The input {{is a collection}} of n maximal common <b>substrings</b> of the two genomes. The problem is to find, based on different criteria, a subset of such common <b>substrings</b> with maximum total length. The most basic criterion requires that the common <b>substrings</b> selected have the same ordering in the two genomes and they do not overlap among themselves in either genome. To capture mutations (transpositions and reversals) between the genomes, we do not insist the <b>substrings</b> selected to have the same ordering. Conceptually, we allow one ordering to go through some mutations to become the other ordering. If arbitrary mutations are allowed, the problem of finding a maximum-length, non-overlapping subset of <b>substrings</b> is found to be NP-hard. However, arbitrary mutations probably overmodel the problem and are likely to find more noise than conserved genes. We consider two criteria that attempt to model sparse and non-overlapping mutations. We show that both can be solved in polynomial time using dynamic programming. © 2008 Springer-Verlag. link_to_subscribed_fulltex...|$|R
2500|$|Hypocoristics with {{modified}} stems {{are derived}} by adding -chan to a stem consisting of an integral number, usually one but occasionally two, of feet, where a foot {{consists of two}} moras. A mora [...] is the unit of which a light syllable contains one and a heavy syllable two. For example, the stems that may be derived from Tarō are /taro/, consisting of two light syllables, and /taa/, consisting of a single syllable with a long vowel, resulting in Taro-chan and Tā-chan. The stems that may be derived from Hanako are /hana/, with two light syllables, /han/, with one syllable closed by a consonant, and /haa/, with one syllable with a long vowel, resulting in Hanachan, Hanchan, and Hāchan. The segmental content is usually a left <b>substring</b> of that of the given name. However, {{in some cases it}} is obtained by other means, including the use of another reading of the kanji used to write the name. For example, a girl named Megumi may be called Keichan or just Kei, because the character used to write the Megumi, , can also be read Kei.|$|E
5000|$|The {{subsequence}} {{should not}} be confused with <b>substring</b> [...] which can be derived from the above string [...] by deleting <b>substring</b> [...] The <b>substring</b> is a refinement of the subsequence.|$|E
5000|$|... (Note {{that here}} a <b>substring</b> is not {{necessarily}} a consecutive <b>substring.)</b> ...|$|E
5000|$|Executables {{of several}} antivirus/firewall {{products}} by ignoring files that contain certain <b>substrings</b> ...|$|R
5000|$|Find {{the most}} {{frequently}} occurring <b>substrings</b> of a minimum length in [...] time.|$|R
40|$|We {{introduce}} {{a new way of}} determining the difference between full genomes, based upon the occurrence of small <b>substrings</b> in both genomes. Basically we count the number of occurrences of all <b>substrings</b> of a certain length and use that to determine to what extent two genomes are alike. Based on these numbers several difference measures can be defined, e. g., a Euclidean distance in the vector space that has the same dimension as the number of possible <b>substrings</b> of a certain length, a multiset distance, or other measures. Each of these measures can be applied for phylogenetic tree generation. We also pay attention to some visualizations and several statistics. ...|$|R
5000|$|In {{computer}} science, {{the longest}} palindromic <b>substring</b> or longest symmetric factor {{problem is the}} problem of finding a maximum-length contiguous <b>substring</b> of a given string that is also a palindrome. For example, the longest palindromic <b>substring</b> of [...] "bananas" [...] is [...] "anana". The longest palindromic <b>substring</b> is not guaranteed to be unique; for example, in the string [...] "abracadabra", there is no palindromic <b>substring</b> with length greater than three, but there are two palindromic substrings with length three, namely, [...] "aca" [...] and [...] "ada". In some applications {{it may be necessary to}} return all maximal palindromic substrings (that is, all substrings that are themselves palindromes and cannot be extended to larger palindromic substrings) rather than returning only one <b>substring</b> or returning the maximum length of a palindromic <b>substring.</b>|$|E
5000|$|A <b>substring</b> of {{a string}} [...] is another string [...] that occurs [...] "in" [...] For example, [...] "the best of" [...] is a <b>substring</b> of [...] "It {{was the best of}} times". This is not to be {{confused}} with subsequence, which is a generalization of <b>substring.</b> For example, [...] "Itwastimes" [...] is a subsequence of [...] "It was the best of times", but not a <b>substring.</b>|$|E
5000|$|A <b>substring</b> (or factor) of {{a string}} [...] is a string , where [...] and [...] A <b>substring</b> {{of a string}} is a prefix of a suffix of the string, and {{equivalently}} a suffix of a prefix. If [...] is a <b>substring</b> of , {{it is also a}} subsequence, which is a more general concept. Given a pattern , you can find its occurrences in a string [...] with a string searching algorithm. Finding the longest string which is equal to a <b>substring</b> of two or more strings is known as the longest common <b>substring</b> problem.|$|E
40|$|Finding {{the longest}} common {{subsequence}} in $k$-length <b>substrings</b> (LCS$k$) is a recently proposed problem motivated by computational biology. This is a generalization of the well-known LCS problem in which matching symbols from two sequences $A$ and $B$ are replaced with matching non-overlapping <b>substrings</b> of length $k$ from $A$ and $B$. We propose several algorithms for LCS$k$, being non-trivial incarnations {{of the major}} concepts known from LCS research (dynamic programming, sparse dynamic programming, tabulation). Our algorithms make use of a linear-time and linear-space preprocessing finding the occurrences of all the <b>substrings</b> of length $k$ from one sequence in the other sequence. Comment: Submitted to a journa...|$|R
40|$|Various {{approaches}} to alignment-free sequence comparison {{are based on}} the length of exact or inexact word matches between two input sequences. Haubold et al. (2009) showed how the average number of substitutions between two DNA sequences can be estimated based on the average length of exact common <b>substrings.</b> In this paper, we study the length distribution of k-mismatch common <b>substrings</b> between two sequences. We show that the number of substitutions per position that have occurred since two sequences have evolved from their last common ancestor, can be estimated from the position of a local maximum in the length distribution of their k-mismatch common <b>substrings...</b>|$|R
40|$|This paper {{describes}} {{our approach}} to English-Korean transliteration in NEWS 2011 Shared Task on Machine Transliteration. We adopt the substring-based transliteration approach which group the characters of named entity in both source and target languages into <b>substrings</b> and then formulate the transliteration as a sequential tagging problem to tag the <b>substrings</b> in the source language with the <b>substrings</b> in the target language. The CRF algorithm are used {{to deal with this}} tagging problem. We also construct a rulebased transliteration method for comparison. Our standard and non-standard runs achieves 0. 43 and 0. 332 in top- 1 accuracy which were ranked as the best for the English-Korean pair. 1...|$|R
5000|$|Prefix and suffix {{are special}} cases of <b>substring.</b> A prefix {{of a string}} [...] is a <b>substring</b> of [...] that occurs at the {{beginning}} of [...] A suffix of a string [...] is a <b>substring</b> that occurs at the end of [...]|$|E
5000|$|... if {{and only}} if every string in R is a <b>substring</b> of , and no string in Q is a <b>substring</b> of ...|$|E
5000|$|Text {{statistics}} functions: Text statistics; extract words; Words lengths; UNITAZ quantity sorting; UNITAZ sorting alphabet; Count the <b>substring</b> {{and count}} the <b>substring</b> (regexp) ...|$|E
5000|$|Find {{the longest}} common <b>substrings</b> of the string [...] and [...] in [...] time.|$|R
5000|$|... n-gram, all the {{possible}} <b>substrings</b> of length n that are contained in a string ...|$|R
40|$|In {{the first}} step of the bisection {{algorithm}} for lossless compression of a data string of length a power of two, one recursively performs bisections of <b>substrings</b> of the data string obtained from previous bisections, starting with the bisection of the entire data string into two <b>substrings.</b> We consider a compression method which is a modification of the bisection algorithm, applicable to data strings of general length. Define an approximate bisection of a string to consist of the partitioning of the string into two <b>substrings</b> whose lengths differ by at most one. Then, {{the first step}} of the modified compression method consists of recursive "approximate bisection" of <b>substrings</b> of the data string, starting with the approximate bisection of the entire data string. The modified compression method requires that one specify in advance which of the at most two ways in which every approximate bisection must take place; this is called guided approximate bisection. It is shown that the modified [...] ...|$|R
