1557|421|Public
25|$|The {{algorithm}} was independently {{discovered and}} described in Algorithms for Approximate <b>String</b> <b>Matching,</b> by Esko Ukkonen.|$|E
2500|$|Linear time is {{the best}} {{possible}} time complexity in situations where the algorithm has to sequentially read its entire input. Therefore, much research has been invested into discovering algorithms exhibiting linear time or, at least, nearly linear time. This research includes both software and hardware methods. [...] There are several hardware technologies which exploit parallelism to provide this. An example is content-addressable memory. This concept of linear time is used in <b>string</b> <b>matching</b> algorithms such as the Boyer-Moore Algorithm and Ukkonen's Algorithm.|$|E
5000|$|Repeat-related problems: {{that deal}} with {{operations}} on single sequences and can be based on exact <b>string</b> <b>matching</b> or approximate <b>string</b> <b>matching</b> methods for finding dispersed fixed length and maximal length repeats, finding tandem repeats, and finding unique subsequences and missing (un-spelled) subsequences.|$|E
30|$|The actual {{comparison}} between System and Reference sentence pairs {{was carried out}} by using four standard string metrics (which are expected to correlate): Accuracy or <b>string</b> <b>match</b> (exact word <b>string</b> <b>match</b> equals 1, or 0 otherwise); Edit-distance (i.e., the number of insert, delete and replace operations required to make both strings identical); and the Machine Translation (MT) metrics BLEU [35] and NIST [36], 18 both of which measure n-gram overlap between Reference and System (BLEU scores range from 0 to 1, and NIST scores have no upper limit 19).|$|R
5000|$|Informally, the {{algorithm}} constructs a {{finite state machine}} that resembles a trie with additional links between the various internal nodes. These extra internal links allow fast transitions between failed <b>string</b> <b>matches</b> (e.g. a search for [...] in a trie that does not contain , but contains , and thus would fail at the node prefixed by [...] ), to other branches of the trie that share a common prefix (e.g., in the previous case, a branch for [...] {{might be the best}} lateral transition). This allows the automaton to transition between <b>string</b> <b>matches</b> without the need for backtracking.|$|R
30|$|Syntactic {{variation}} including capitalization, spacing, spellings, writing syntax, {{can affect}} the usability of open text answers to challenge questions. The answers were lexicographically correct, nevertheless, the <b>string</b> to <b>string</b> <b>match</b> failed using the equality algorithm.|$|R
5000|$|Aho-Corasick <b>string</b> <b>matching</b> {{algorithm}} (extension of Knuth-Morris-Pratt) ...|$|E
50|$|Suffix automata have {{applications}} in approximate <b>string</b> <b>matching.</b>|$|E
50|$|GNU grep {{implements}} a <b>string</b> <b>matching</b> algorithm {{very similar}} to Commentz-Walter.|$|E
500|$|Computational {{linguist}} Richard Sproat {{could not}} replicate the parallels Fischer claimed between the Santiago Staff {{and the other}} texts. He automated the search for <b>string</b> <b>matches</b> between the texts {{and found that the}} staff stood alone: ...|$|R
5000|$|The recipient's {{computer}} checks {{whether the}} e-mail address in the hash <b>string</b> <b>matches</b> any of the valid e-mail addresses registered by the recipient, or matches any of the mailing lists to which the recipient is subscribed. If a match is not found, the hash string is invalid.|$|R
40|$|An {{algorithm}} for locating all {{occurrences of}} {{a finite number}} of keywords in an arbitrary string, also known as multiple <b>strings</b> <b>matching,</b> is commonly required in information retrieval (such as sequence analysis, evolutionary biological studies, gene/protein identification and network intrusion detection) and text editing applications. Although Aho-Corasick was one of the commonly used exact multiple <b>strings</b> <b>matching</b> algorithm, Commentz-Walter has been introduced as a better alternative in the recent past. Comments-Walter algorithm combines ideas from both Aho-Corasick and Boyer Moore. Large scale rapid and accurate peptide identification is critical in computational proteomics. In this paper, we have critically analyzed the time complexity of Aho-Corasick and Commentz-Walter for their suitability in large scale peptide identification. According to the results we obtained for our dataset, we conclude that Aho-Corasick is performing better than Commentz-Walter as opposed to the common beliefs...|$|R
50|$|In {{computer}} science, approximate <b>string</b> <b>matching</b> (often colloquially {{referred to}} as fuzzy string searching) is the technique of finding strings that match a pattern approximately (rather than exactly). The problem of approximate <b>string</b> <b>matching</b> is typically divided into two sub-problems: finding approximate substring matches inside a given string and finding dictionary strings that match the pattern approximately.|$|E
50|$|The Aho-Corasick <b>string</b> <b>matching</b> {{algorithm}} {{formed the}} basis of the original Unix command fgrep.|$|E
50|$|This method {{utilizes}} the Wu-Manber approximate <b>string</b> <b>matching</b> algorithm {{to generate}} multiple sequence alignments.|$|E
50|$|At {{a deeper}} level, CRM114 {{is also a}} <b>string</b> pattern <b>matching</b> language, similar to grep or even Perl; {{although}} it is Turing complete it is highly tuned for matching text, and even a simple (recursive) definition of the factorial takes almost ten lines. Part of {{this is because the}} crm114 language syntax is not positional, but declensional. As a programming language, it may be used for many other applications aside from detecting spam. CRM114 uses the TRE approximate-match regex engine, so it is possible to write programs that do not depend on absolutely identical <b>strings</b> <b>matching</b> to function correctly.|$|R
40|$|The paper {{begins with}} {{definitions}} of regular expressions, and how <b>strings</b> are <b>matched</b> to them; this also gives our first Haskell treatment also. After describing the {{abstract data type}} of sets we define non-deterministic finite automata, and their implementation in Haskell. We then show how to build an NFA corresponding to each regular expression, and how such a machine can be optimised, first by transforming it into a deterministic machine, and then by minimising the state space of the DFA. We conclude {{with a discussion of}} regular definitions, and show how recognisers for <b>strings</b> <b>matching</b> regular definitions can be built...|$|R
5000|$|The rewrite {{semantics}} for RCGs {{is rather}} simple, {{identical to the}} corresponding semantics of LMGs. Given a predicate string , where the symbols [...] are terminal strings, {{if there is a}} rule [...] in the grammar that the predicate <b>string</b> <b>matches,</b> the predicate <b>string</b> is replaced by , substituting for the matched variables in each [...]|$|R
50|$|He found {{important}} Limit Theorems for Approximate <b>String</b> <b>Matching</b> {{for data}} compression and practical sub optimal results.|$|E
5000|$|A <b>string</b> <b>matching</b> {{algorithm}} {{wants to}} find the starting index [...] in string [...] that matches the search word [...]|$|E
5000|$|He {{proposed}} a new universal coding scheme (“Sadeh Algorithm”) based on approximate <b>string</b> <b>matching,</b> Wiener Ziv Algorithm and Ornstein-Shields block-coding algorithm (1992).|$|E
30|$|For non-sensitive keystrokes, {{whether the}} display latency is user-perceptible {{depends on how}} the prefix of non-sensitive typed <b>string</b> <b>matches</b> the prefix of {{user-defined}} sensitive data set (i.e., phone numbers in our case). If there is no long common prefix between non-sensitive string and items of sensitive data set, the display latency is non-perceptible. Otherwise, it is perceptible.|$|R
40|$|TR-COSC 01 / 93 This paper {{describes}} two searching {{methods for}} locating longest <b>string</b> <b>matches</b> in source texts of low entropy. A modi cation of the Boyer-Moore scanning algorithm and a statistical method, which searches for less likely symbols, are presented. Both algorithms {{have been implemented}} {{as part of the}} searching strategy for an LZ 77 type encoder. Experimental results are included...|$|R
40|$|In {{this paper}} we present an {{approach}} to terminology recognition whereby a sublanguage term (e. g. an aircraft engine component term extracted from a maintenance log) is matched to its corresponding term from a pre-defined list (such as a taxonomy representing the official break-down of the engine). Terminology recognition is addressed as a classification task whereby the extracted term is associated {{to one or more}} potential terms in the official description list via the application of string similarity metrics. The solution described in the paper uses dynamically computed similarity cut-off thresholds calculated on the basis of modeling a noise curve. Dissimilar <b>string</b> <b>matches</b> form a Gaussian distributed noise curve that can be identified and extracted leaving only mostly similar <b>string</b> <b>matches.</b> Dynamically calculated thresholds are preferable over fixed similarity thresholds as fixed thresholds are inherently imprecise, that is, there is no similarity boundary beyond which any two strings always describe the same concept. 1...|$|R
5000|$|Convert a <b>string</b> <b>matching</b> the {{symbolic}} {{name of a}} class or function into a reference to or invocation of that class or function.|$|E
50|$|In {{such cases}} the {{mechanism}} implements some fuzzy <b>string</b> <b>matching</b> algorithm and possibly some algorithm for finding {{the similarity between}} text fragment and pattern.|$|E
50|$|RMQs {{are used}} {{as a tool for}} many tasks in exact and {{approximate}} <b>string</b> <b>matching.</b> Several applications can be found in Fischer and Heun (2007).|$|E
5000|$|... evaluates to true if {{and only}} if the <b>string</b> [...] <b>matches</b> the regular {{expression}} [...]|$|R
50|$|For {{their own}} Reissue of the Triumph bass {{they have their}} own <b>strings</b> to <b>match</b> it.|$|R
40|$|Some {{computer}} {{anomaly detection}} systems {{inspired by the}} immune system rely on the r-contiguous bits matching rule, whereby two strings of length l are said to match if they have at least r contiguous bits in common. In this paper, we derive a recurrence relation and its closed form solution for computing the number of <b>strings</b> <b>matched</b> by a single such string called a detector. ...|$|R
5000|$|G. Myers. [...] "A fast bit-vector {{algorithm}} for approximate <b>string</b> <b>matching</b> {{based on}} dynamic programming." [...] Journal of the ACM 46 (3), May 1999, 395 - 415.|$|E
5000|$|Approximate <b>string</b> <b>matching</b> can be {{formulated}} {{in terms of}} edit distance. Ukkonen's 1985 algorithm takes a string , called the pattern, and a constant it then builds a deterministic finite state automaton that finds, in an arbitrary string , a substring whose edit distance to [...] is at most [...] (cf. the Aho-Corasick algorithm, which similarly constructs an automaton to search for any {{of a number of}} patterns, but without allowing edit operations). A similar algorithm for approximate <b>string</b> <b>matching</b> is the bitap algorithm, also defined in terms of edit distance.|$|E
5000|$|In {{mathematics}} and computer science, a string metric (also {{known as a}} string similarity metric or string distance function) is a metric that measures distance ("inverse similarity") between two text strings for approximate <b>string</b> <b>matching</b> or comparison and in fuzzy string searching. A necessary requirement for a string metric (e.g. in contrast to <b>string</b> <b>matching)</b> is fulfillment of the triangle inequality. For example, the strings [...] "Sam" [...] and [...] "Samuel" [...] can {{be considered to be}} close. A string metric provides a number indicating an algorithm-specific indication of distance.|$|E
40|$|Abstract: Background: Orphanet aims {{to provide}} rare disease {{information}} to healthcare professionals, patients, and their relatives. Objective: The {{objective of this}} work is to evaluate two methodologies (UMLS and manual Orphanet-ICD- 10 link-based mapping & <b>String</b> Based <b>matching)</b> used to map Orphanet thesaurus to the MeSH thesaurus. Results: On a corpus of 375 mappings, the <b>string</b> based <b>matching</b> provides significantly better results than the UMLS and manual Orphanet-ICD- 10 link-based mapping. Conclusion: <b>String</b> based <b>matching</b> {{could be applied to}} any biomedical terminology in French not yet included into UMLS. manuscrit_corrected_ 26012010 Click here to download Manuscrit: Tayeb_Merabti_IRBM July 2009 _revision. doc Mapping biomedical terminologies using natural language processing tools and UMLS: mapping the Orphanet thesaurus to the MeS...|$|R
5000|$|PCRE Perl Compatible Regular Expressions, {{a common}} modern {{implementation}} of <b>string</b> pattern <b>matching</b> ported to many languages ...|$|R
60|$|Besides the two knives {{there were}} <b>strings,</b> nails, <b>matches,</b> {{a piece of}} putty, fish-hooks, and two very dirty handkerchiefs.|$|R
