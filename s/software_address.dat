15|1016|Public
50|$|Other {{optional}} {{application software}} available on ROM included various terminal emulators such as Satellite Computing's ICL7561 emulator, plus their Action Diary and Presentation <b>Software,</b> <b>address</b> book, and inter-OPD communications utilities.|$|E
50|$|It {{acts as a}} {{scheduler}} for tasks {{running on}} the system, providing pre-emptive multitasking with prioritized round-robin scheduling. Exec also provides access to other libraries and high-level inter-process communication via message passing. Other comparable microkernels have had performance problems {{because of the need}} to copy messages between address spaces. Since the Amiga has only one address space, Exec message passing is quite efficient. The only fixed memory address in the Amiga <b>software</b> (<b>address</b> 4) is a pointer to , which can then be used to access other libraries. Exec was designed and implemented by Carl Sassenrath.|$|E
40|$|This paper {{introduces}} a new method, software virtual memory, (section 4) that combines hardware virtual memory's efficiency with <b>software</b> <b>address</b> computation's flexibility. We have implemented the new scheme for MIT Alewife, a globally cache-coherent distributedmemory multiprocessor, using the partitioning scheme in [1]. 2 <b>Software</b> <b>Address</b> Computatio...|$|E
5000|$|There {{are four}} basic types of <b>software</b> <b>addressing</b> AML {{business}} requirements: ...|$|R
5000|$|... #Subtitle level 2: Types of {{information}} and related processes this <b>software</b> <b>addresses</b> ...|$|R
40|$|International Telemetering Conference Proceedings / September 28 - 30, 1982 / Sheraton Harbor Island Hotel and Convention Center, San Diego, CaliforniaTo simplify {{telemetry}} software development, {{a design}} that elminates the use of <b>software</b> instructions to <b>address</b> telemetry channels is being implemented in our telemetry systems. By using the DMA function of the RCA 1802 microprocessor, once initialized, addressing of telemetry channels is automatic, requiring no software. In this report, the automatic addressing scheme is compared with an earlier technique that uses <b>software</b> to <b>address</b> telemetry channels. In comparison, the automatic addressing scheme effectively increases the software capability of the microprocessor, simplifies telemetry dataset encoding, eases data set changes, and may decrease the electronic hardware count. The <b>software</b> <b>addressing</b> technique uses at least three instructions to address each channel. The automatic addressing technique requires no <b>software</b> instructions. Instead, <b>addressing</b> is performed using a direct memory access cycle stealing technique. Application of {{an early version of}} this addressing scheme opened up the capability to execute 400 more microprocessor instructions than could be executed using the <b>software</b> <b>addressing</b> scheme. The present version of the automatic addressing scheme uses a section of PROM reserved for telemetry channel addresses. Encoding for a dataset is accomplished by programming the PROM with channel addresses in the order they are to be monitored. Software for one of our telemetry units was written using the <b>software</b> <b>addressing</b> scheme, then rewritten using the automatic addressing scheme. While 1000 bytes of memory were required by the <b>software</b> <b>addressing</b> scheme, the automatic addressing scheme required only 396 bytes. A number of prototypes using AATC have been built and tested in a telemetry lab unit. All have worked successfully...|$|R
40|$|Address trace {{compression}} represents {{that the}} address data, which were generated from instruction fetch stage of microprocessor, can be retrieved for later observation and analysis. In h s paper, we present how {{to design and}} implement this real-time address trace compressor (RTATC), whch {{can be used to}} collect the address trace information of FPGA Prototyping system based on embedded microprocessors. Address trace compressor is able to monitor address bus of microprocessor, and to get operation workload under the analysis of profiling <b>software.</b> <b>Address</b> trace compressor is also allowed to perform accurate, successive trace collection in an unlimited length and can be used in different embedded microprocessors. At last, by the help of FPGA, this silicon intelligent property can own the abundant reconfigurable parameters, the removable modules and the reusable ability...|$|E
40|$|Software {{vendors are}} {{continuously}} introducing different tools claiming that their products are the complete and ultimate solutions to Knowledge Management (KM) problems. This research investigates the vendors ’ claims, identifies the weaknesses in existing KM software, and explores {{the requirements for}} better KM software for construction organizations. The literature on KM software is first reviewed. Major vendors and users of KM software are then interrogated for a closer investigation of what current KM software can offer. It is found that existing <b>software</b> <b>address</b> only some elements of the KM sub-processes. In addition, they do not address {{the majority of the}} requirements of construction organizations. The research concludes that construction organizations need KM software to be more oriented towards the industry by addressing its specific needs. Some of these needs are discussed, in brief, {{at the end of the}} paper...|$|E
40|$|Persistent {{programming}} {{systems are}} generally supported by an object store, a conceptually infinite object repository. Objects {{in such a}} repository cannot be directly accessed by user programs; to be manipulated they must be fetched from the object store into virtual memory. Thus in these systems, two different kinds of object addresses may exist: those in the object store and those in virtual memory. The action of changing object store addresses into virtual memory addresses {{has become known as}} pointer swizzling and {{is the subject of this}} paper. The paper investigates three approaches to pointer swizzling: a typical <b>software</b> <b>address</b> translation scheme, a technique for performing swizzling at page fault time and finally a new hybrid scheme which performs swizzling in two phases. The hybrid scheme supports arbitrarily large pointers and object repositories using conventional hardware. The paper concludes with a comparison of these approaches. ...|$|E
40|$|Abstract. PARIP Explorer {{is a rich}} {{graphical}} client interface to a Web Service {{that allows}} querying and updating of a FOAF database of drama research. The <b>software</b> <b>addresses</b> problems arising from an evolving research field, a geographically distributed community and multiple views of the research terrain...|$|R
5000|$|Content access {{software}} is used primarily to access content without editing, but may include software {{that allows for}} content editing. Such <b>software</b> <b>addresses</b> the needs of individuals and groups to consume digital entertainment and published digital content. (Examples include media players, web browsers, and help browsers.) ...|$|R
5000|$|... eFront {{develops}} software {{products for}} general partners; limited partners, including family offices, {{pension funds and}} sovereign wealth funds; fund administrators; fund of funds and hedge funds. The <b>software</b> <b>addresses</b> several Alternative Investment asset classes, including private equity (both direct and indirect), real estate (both direct and indirect), infrastructure and fund of hedge funds.|$|R
40|$|This paper {{emerges from}} our {{collective}} interest {{and experience in}} the use of multimedia in the science and mathematics classroom. We each approach this topic from a different direction. The first author, Martin, during his years as a classroom teacher, began to see the possibility of utilising multimedia to create a student centred learning environment in which a self paced curriculum would be delivered by the computer. Martin was aware, however, that there were many questions regarding the pedagogical value of using multimedia in the mathematics classroom that needed to be answered. Specifically, could the <b>software</b> <b>address</b> the vital issues of problem solving and higher-level thinking? The second author, Dorit, was involved in research in this area over the last 10 years. In her research she investigated the potential of computerised learning environments and constructivist teaching epistemology in promoting higher-level thinking skills in the science classroom...|$|E
40|$|Product line {{engineering}} and safety engineering for <b>software</b> <b>address</b> current {{challenges in the}} development of software-intensive, safety-critical embedded systems. The two engineering diciplines have different goals and the approaches for achieving these goals have been created independently from each other. For this reason traditional safety engineering methods do not fit to traditional methods for software product {{line engineering}}. The research project "Safe ReSA (Safe Reusable Safety Artifacts) " between the Fraunhofer IESE and Siemens AG has the goal to extend traditional safety engineering methods so that safety engineering {{can be applied to the}} reusable artifacts that are created in product line engineering. Sequentially, we present how we extended methods for analyzing cause-effect relation between failures, for developing a safety concept and a safety case. Additionally, we present lessons learned from industry projects and our tool for applying the extended methods to complex real world systems...|$|E
40|$|This thesis {{presents}} the first-ever compile-time method for allocating {{a portion of}} a program’s dynamic data to scratch-pad memory. A scratch-pad is a fast directly addressed compiler-managed SRAM memory that replaces the hardware-managed cache. It is motivated by its better real-time guarantees vs cache and by its signifi-cantly lower overheads in access time, energy consumption, area and overall runtime. Dynamic data refers to all objects allocated at run-time in a program, as opposed to static data objects which are allocated at compile-time. Existing compiler methods for allocating data to scratch-pad are able to place only code, global and stack data (static data) in scratch-pad memory; heap and recursive-function objects(dynamic data) are allocated entirely in DRAM, resulting in poor performance for these dy-namic data types. Runtime methods based on software caching can place data in scratch-pad, but because of their high overheads from <b>software</b> <b>address</b> translation, they have not been successful, especially for dynamic data. In this thesis we present a dynamic yet compiler-directed allocation method for dynamic data that for the first time, (i) is able to place a portion of the dynami...|$|E
50|$|<b>Software</b> {{maintenance}} <b>address</b> {{bug fixes}} and minor enhancements and software evolution focus on adaptation and migration.|$|R
5000|$|Enterprise <b>software</b> <b>addresses</b> {{the needs}} of an entire organization's {{processes}} and data flows, across several departments, often in a large distributed environment. Examples include enterprise resource planning systems, customer relationship management (CRM) systems and supply chain management software. Departmental Software is a sub-type of enterprise software {{with a focus on}} smaller organizations or groups within a large organization. (Examples include travel expense management and IT Helpdesk.) ...|$|R
5000|$|Most {{self-service}} <b>software</b> <b>addresses</b> [...] "closed-loop" [...] inquiries {{whereby the}} author emulates {{a variety of}} known (finite) questions and related (known) responses on hand or required steps {{that must be addressed}} to derive and deliver a final answer or directive. Often the author using such software codifies such known processes and steps and then generates (publishes) end-user facing applications which can encompass a variety of code bases and platforms.|$|R
40|$|Although {{there exists}} a number of {{optimization}} frameworks only commercial and closed source <b>software</b> <b>address,</b> to an extent, real-world optimization problems and arguably these software packages are not very easy to use. In this work we introduce an open source integrated optimization environment {{which is designed to}} be extensible and have a smooth learning curve {{so that it can be}} used by the non-expert in industry. We call this environment, Liger. Liger is an application that is built about a visual programming language, by which optimization work-flows can be created. Additionally, Liger provides a communication layer with external tools, whose functionality can be directly integrated and used with native components. This fosters code reuse and further reduces the required effort on behalf of the practitioner in order to obtain a solution to the optimization problem. Furthermore, {{there exists a}} number of available algorithms which are fully configurable, however should the need arise new algorithms can also be created just as easily by reusing what we call operator nodes. Operator nodes perform specific tasks on a set, or a single solution. Lastly as visual exploration of the obtained solutions is essential for decision makers, we also provide state-of-the art visualization capabilities...|$|E
40|$|Abstract — This paper {{presents}} the first-ever compiletime method for allocating {{a portion of}} the heap data to scratch-pad memory. A scratch-pad is a fast directly addressed compiler-managed SRAM memory that replaces the hardware-managed cache. It is motivated by its better real-time guarantees vs cache and by its significantly lower overheads in access time, energy consumption, area and overall runtime. Existing compiler methods for allocating data to scratch-pad are able to place only global and stack data in scratch-pad memory; heap data is allocated entirely in DRAM, resulting in poor performance. Runtime methods based on software caching can place heap data in scratchpad, but because of their high overheads from <b>software</b> <b>address</b> translation, they have not been successful, especially for heap data. In this paper we present a dynamic yet compiler-directed allocation method for heap data that for the first time, (i) is able to place {{a portion of the}} heap data in scratch-pad; (ii) has no software-caching tags; (iii) requires no run-time per-access extra address translation; and (iv) is able to move heap data back and forth between scratch-pad and DRAM to better track the program’s locality characteristics. With our method, global, stack and heap variables can share the same scratch-pad. When compared to placing all heap variables in DRAM and only global and stack data in scratch-pad, our results show that our method reduces the average runtime of our benchmarks by 34. 6 %, and the average power consumption by 39. 9 %, for the same size of scratch-pad fixed at 5 % of total data size. Index Terms — heap allocation, scratch pad, SRAM, tightly coupled memory, TCM, dynamic allocation. I...|$|E
40|$|In 2003, McGill University, {{a member}} of the Canadian “G 10 ” {{research}} universities, undertook a limited trial of plagiarism detection software in specific undergraduate courses. While it is estimated that 28 Canadian universities and colleges currently use text-matching software, the McGill trial received considerable attention from student, national and international media after a student refused to submit his work to the service and successfully challenged the university’s policy requiring the use of Turnitin™. While student and faculty reactions to the software have been mixed, debate about the use of text-matching software has served to promote awareness of the importance of academic integrity and the use of alternative methods of deterring plagiarism. No final decision has yet been reached regarding the use of plagiarism detection software but the University is currently drafting policy for its general implementation in courses and specific use in cases of suspected plagiarism. At the same time, it is working to develop collaborative initiatives involving key campus stakeholders, including the University administration, Teaching and Learning Services, librarians and student advocacy groups, to promote academic integrity at McGill. In this study, we seek to determine how leading Canadian universities using text-matching <b>software</b> <b>address</b> issues of academic integrity. Particular attention will paid to the role of librarians in promoting academic integrity and in educating students and faculty about information literacy. Having identified seven of the G 10 currently using Turnitin™, we intend to survey key stakeholders from each institution via electronic questionnaire for information on four areas relating to academic integrity: promotion, policy, education, and library involvement. We expect to report a summary of our findings, paying special attention to the current situation at McGill...|$|E
5000|$|IBM {{at first}} asked {{developers}} to avoid writing <b>software</b> that <b>addressed</b> the computer's hardware directly, and to instead make standard calls to BIOS functions that carried out hardware-dependent operations. This software would run on any machine using MS-DOS or PC-DOS. <b>Software</b> that directly <b>addressed</b> the hardware {{instead of making}} standard calls was faster, however; this was particularly relevant to games. <b>Software</b> <b>addressing</b> IBM PC hardware in this way would not run on MS-DOS machines with different hardware. The IBM PC was sold in high enough volumes to justify writing software specifically for it, and this encouraged other manufacturers to produce machines which could use the same programs, expansion cards, and peripherals as the PC. The 808x computer marketplace rapidly excluded all machines which were not hardware- and software-compatible with the PC. The 640 KB barrier on [...] "conventional" [...] system memory available to MS-DOS is a legacy of that period; other non-clone machines, while subject to a limit, could exceed 640 kB.|$|R
50|$|Kiosk system <b>software</b> <b>addresses</b> {{security}} by deterring users from maliciously attacking or hacking into the kiosk. Kiosk software {{must be able}} to prevent misuse of the provided features. Of equal importance is the ability of the software to limit non malicious users to specific, predetermined activities so the device can be used for a specific task, communication, action or function. Kiosk software is a critical component to protecting public facing devices from hackers, inadvertent misuse, and unauthorized access.|$|R
5000|$|The product shipped with a Windows driver application, called DexPlorer, on two 3.5" [...] floppy disks. Updated <b>software,</b> which <b>addressed</b> {{many of the}} {{problematic}} issues in the pack-in software, was available for several years on the InterAct corporate website. Unofficial software has also been written by various authors. In some cases, competitors supported the DexDrive in order to claim de facto compatibility. In other cases, DexDrive users wrote their own <b>software</b> to <b>address</b> the shortcomings of DexPlorer.|$|R
40|$|Software {{applications}} for design and creation typically contain {{hundreds or thousands}} of commands, which collectively give users enormous expressive power. Unfortunately, rich feature sets also take a toll on usability. Current interfaces to feature-rich <b>software</b> <b>address</b> this dilemma by adopting menus, toolbars, and other hierarchical schemes to organize functionality—approaches that enable efficient navigation to specific commands and features, but do little to reveal how to perform unfamiliar tasks. We present an alternative task-centric user interface design that explicitly supports users in performing unfamiliar tasks. A task-centric interface is able to quickly adapt itself to the user’s intended goal, presenting relevant functionality and required procedures in task-specific customized interfaces. To achieve this, task-centric interfaces (1) represent tasks as first-class objects in the interface; (2) allow the user to declare their intended goal (or infer it from the user’s actions); (3) restructure the interface to provide step-by-step scaffolding for the current goal; and (4) provide additional knowledge and guidance within the application’s interface. Our inspiration for task-centric interfaces comes from a study we conducted, which revealed that a valid use case for feature-rich software is to perform short, targeted tasks that use {{a small fraction of the}} application’s full functionality. Task-centric interfaces provide explicit support for this use. We developed and tested our task-centric interface approach by creating AdaptableGIMP, a modified version of the GIMP image editor, and Workflows, an iteration on AdaptableGIMP’s design based on insights from a semi-structured interview study and a think-aloud study. Based on a two-session study of Workflows, we show that task-centric interfaces can successfully support a guided-and-constrained problem solving strategy for performing unfamiliar tasks, which enables faster task completion and reduced cognitive load as compared to current practices. We also provide evidence that task-centric interfaces can enable a higher-level form of application learning, in which the user associates tasks with relevant keywords, as opposed to low-level commands and procedures. This keyword learning has potential benefits for memorability, because the keywords themselves are descriptive of the task being learned, and scalability, because a few keywords can map to an arbitrarily complex set of commands and procedures. Finally, our findings suggest a range of different ways that the idea of task-centric interfaces could be further developed...|$|E
40|$|This thesis {{presents}} the first-ever compile-time method for allocating {{a portion of}} a program's dynamic data to scratch-pad memory. A scratch-pad is a fast directly addressed compiler-managed SRAM memory that replaces the hardware-managed cache. It is motivated by its better real-time guarantees vs cache and by its significantly lower overheads in access time, energy consumption, area and overall runtime. Dynamic data refers to all objects allocated at run-time in a program, as opposed to static data objects which are allocated at compile-time. Existing compiler methods for allocating data to scratch-pad are able to place only code, global and stack data (static data) in scratch-pad memory; heap and recursive-function objects(dynamic data) are allocated entirely in DRAM, resulting in poor performance for these dynamic data types. Runtime methods based on software caching can place data in scratch-pad, but because of their high overheads from <b>software</b> <b>address</b> translation, they have not been successful, especially for dynamic data. In this thesis we present a dynamic yet compiler-directed allocation method for dynamic data that for the first time, (i) is able to place a portion of the dynamic data in scratch-pad; (ii) has no software-caching tags; (iii) requires no run-time per-access extra address translation; and (iv) is able to move dynamic data back and forth between scratch-pad and DRAM to better track the program's locality characteristics. With our method, code, global, stack and heap variables can share the same scratch-pad. When compared to placing all dynamic data variables in DRAM and only static data in scratch-pad, our results show that our method reduces the average runtime of our benchmarks by 22. 3 %, and the average power consumption by 26. 7 %, for the same size of scratch-pad fixed at 5 % of total data size. Significant savings in runtime and energy across a large number of benchmarks were also observed when compared against cache memory organizations, showing our method's success under constrained SRAM sizes when dealing with dynamic data. Lastly, our method is able to minimize the profile dependence issues which plague all similar allocation methods through careful analysis of static and dynamic profile information...|$|E
40|$|To {{adequately}} explore {{high priority}} landing sites, scientists require rovers with greater mobility. Therefore, future Mars missions will involve rovers capable of traversing tens of kilometers (vs. tens of meters traversed by Mars Pathfinder's Sojourner). However, the current {{process by which}} scientists interact with a rover does not scale to such distances. A single science objective is achieved through many iterations of a basic command cycle: (1) all data must be transmitted to Earth and analyzed; (2) from this data, new targets are selected and the necessary information from the appropriate instruments are requested; (3) new commands are then uplinked and executed by the spacecraft and (4) the resulting data are returned to Earth, starting the process again. Experience with rover tests on Earth shows that this time intensive process cannot be substantially shortened given the limited data downlink bandwidth and command cycle opportunities of real missions. Sending complete multicolor panoramas at several waypoints, for example, {{is out of the}} question for a single downlink opportunity. As a result, long traverses requiring many science command cycles would likely require many weeks, months or even years, perhaps exceeding rover design life or other constraints. Autonomous onboard science analyses can address these problems in two ways. First, it will allow the rover to transmit only "interesting" images, defined as those likely to have higher science content. Second, the rover will be able to anticipate future commands, for example acquiring and returning spectra of "interesting" rocks along with the images in which they were detected. Such approaches, coupled with appropriate navigational <b>software,</b> <b>address</b> both the data volume and command cycle bottlenecks that limit both rover mobility and science yield. We are developing algorithms to enable such intelligent decision making by autonomous spacecraft. Reflecting the ultimate level of ability we aim for, this program has been dubbed the "Grad Student on Mars Project". We envision, for example, an appropriately intelligent Athena-like rover at the Pathfinder landing site might be able to traverse over the ridge towards "Twin Peaks" to obtain better information on the stratigraphy of these "streamlined islands" or of the size, composition and morphology of boulders located on them. Along the traverse, the intelligent rover would collect and analyze images and obtain spectra of geologically interesting features or regions. The intelligent rover might also traverse further up Arcs Vallis, and find additional paleoflood stage indicators such as slackwater deposits. Recognizing additional regions where boulders are imbricated, noting changes in their size, distribution, morphology, composition and the associated changes in channel geometry would yield important information on the outflow channel's paleoflood history, Representative images and associated supporting data from these locations could be downlinked to Earth along with the data requested by scientists from the previous uplink opportunity. Our initial work has focused on recognizing geologically interesting portions of images. Here we summarize some of the algorithms to date...|$|E
40|$|Abstract- Dynamic <b>software</b> {{adaptation}} <b>addresses</b> <b>software</b> {{systems that}} need to change their behavior at run-time. A software adaptation pattern models how the components {{that make up an}} architecture pattern cooperate to change the software configuration at run-time. This paper describes a model-based run-time adaptation pattern for distributed hierarchical service coordination in service-oriented applications, in which multiple service coordinators are organized in a distributed hierarchical configuration...|$|R
50|$|Knowledge {{discovery}} in software {{is related to}} a concept of reverse engineering. <b>Software</b> mining <b>addresses</b> structure, behavior {{as well as the}} data processed by the software system.|$|R
40|$|Zebu is an {{educational}} groupware technology which facilitates {{the use of}} standard WWW software to support collaborative project-based learning. This paper discusses the promise of Zebu in helping teachers and students overcome some technical and practical, educational problems inherent in WWW-based technologies, allowing them to more fully realise the potentials of the WWW as a technology for collaboration in education. Illustrations of the software are included to provide further detail of how the <b>software</b> <b>addresses</b> these problems. Keywords—educational groupware, collaborative learning strategies, design and interface issues, tools to support teaching in collaborative settings, WW...|$|R
50|$|Founded in 1998, Continuous Computing is {{a privately}} held {{company based in}} San Diego that {{provides}} telecom systems made up of telecom platforms and Trillium software, including protocol software stacks for femtocells and 4G wireless / Long Term Evolution (LTE). The company also sells standalone Trillium software products and ATCA hardware components, as well as professional services. Continuous Computing’s Trillium <b>software</b> <b>addresses</b> LTE Femtocells (Home eNodeB) and pico / macro eNodeBs, {{as well as the}} Evolved Packet Core (EPC), Mobility Management Entity (MME), Serving Gateway (SWG) and Evolved Packet Data Gateway (ePDG).|$|R
40|$|CODYBA is a <b>software</b> <b>addressed</b> to designers, {{teachers}} and research organisms. This software determines the energetic fluxes {{of a building}} zone. The basic data are the zones geometry and constitution. The main parameters are the climatic conditions, the internal loads and the {{heating and air conditioning}} powers, as well as their regulation mode. The graphical interface introduces concepts that are identical to those manipulated in the everyday practice by the building professionals and that are reproduced on screen by a classic "icono-graphical " representation in the "Windows" environment...|$|R
40|$|Run-time {{errors are}} {{typically}} seen as unacceptable within {{safety and security}} critical software. The SPARK approach {{to the development of}} high integrity <b>software</b> <b>addresses</b> the problem of run-time errors through the use of formal verification. Proofs are constructed to show that each run-time check will never raise an error, thus proving freedom from run-time exceptions. Here we build upon the success of the SPARK approach by increasing the level of automation that can be achieved in proving freedom from exceptions. Our approach is based upon proof planning and a form of abstract interpretation...|$|R
50|$|In June, 2011, Anthony Blake's son Thomas Nigel Blake {{took over}} as CEO of Cambridge Imaging Systems to lead the company from a project {{approach}} to one of developing clearly defined software products. The Imagen product was launched in February 2012 and has undergone continual development since. The product became available as an SaaS offering in March 2013 under the trademark ImagenCloud. Imagen is a Digital Media Asset Management <b>software</b> <b>addressing</b> multiple market sectors: enterprise DAM, media broadcasters and production studios, education, museums and libraries, defence and security.|$|R
5000|$|Version 2.1 of the <b>software</b> <b>addressed</b> some criticisms by {{improving}} firewall support for live video chat and video messaging, and [...] "video adaptation", and version 2.2 (August 2002) improved frame rates and audio, support for AIM, MSN, and Yahoo!, improved firewall support, and added new chat rooms. In its August 2002 review, USA Today gave the program 3 out of 4 stars, noting that its {{video and audio}} quality was [...] "snappier and sonically cleaner than the competition until Yahoo upgraded its product last week", but, without high-speed Internet connection, video was [...] "virtually unwatchable." ...|$|R
40|$|We {{present an}} {{educational}} <b>software</b> <b>addressed</b> {{to the students}} of optical communication courses, for a simple visualization of the basic dynamic processes of semiconductor lasers. The graphic interface allows the user to choose the laser and the modulation parameters and it plots the laser power output and instantaneous frequency versus time. Additionally, the optical frequency variations are numerically shifted into the audible frequency range {{in order to produce}} a sound wave from the computer loudspeakers. Using the proposed software, the student can simultaneously see and hear how the laser intensity and frequency change, depending on the modulation and device parameters...|$|R
