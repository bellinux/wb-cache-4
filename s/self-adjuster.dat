0|802|Public
40|$|Much {{has been}} said in praise of [...] . this paper, we compare the {{performance}} of three different techniques for <b>self-adjusting</b> trees with that of AVL and random binary search trees. Comparisons are made for various tree sizes, levels of key-access-frequency skewness and ratios of insertions and deletions to searches. The results show that, {{because of the high}} cost of maintaining <b>self-adjusting</b> trees, in almost all cases the AVL tree outperforms all the <b>self-adjusting</b> trees and in many cases even a random binary search tree has better performance, in terms of CPU time, than any of the <b>self-adjusting</b> trees. <b>Self-adjusting</b> trees seem to perform best in a highly dynamic environment, contrary to intuition...|$|R
40|$|<b>Self-adjusting</b> {{programs}} respond automatically {{and efficiently}} to input changes by tracking the dynamic data dependences of the computation and incrementally updating the output as needed. In {{order to identify}} data dependences, previously proposed ap-proaches require the user {{to make use of}} a set of monadic primi-tives. Rewriting an ordinary program into a <b>self-adjusting</b> program with these primitives, however, can be difficult and error-prone due to various monadic and proper-usage restrictions, some of which cannot be enforced statically. Previous work therefore suggests that <b>self-adjusting</b> computation would benefit from direct language and compiler support. In this paper, we propose a language-based technique for writ-ing and compiling <b>self-adjusting</b> programs from ordinary pro-grams. To compile <b>self-adjusting</b> programs, we use a continuation...|$|R
40|$|<b>Self-adjusting</b> {{computation}} {{offers a}} language-centric approach to writing programs that can automatically respond to modifications to their data (e. g., inputs). Except for several domain-specific implementations, however, all previous implementations of <b>self-adjusting</b> computation assume mostly functional, higher-order languages such as Standard ML. Prior to this work, {{it was not}} known if <b>self-adjusting</b> computation {{can be made to}} work with low-level, imperative languages such as C without placing undue burden on the programmer. We describe the design and implementation of CEAL: a C-based language for <b>self-adjusting</b> computation. The language is fully general and extends C with a small number of primitives to enable writing <b>self-adjusting</b> programs in a style similar to conventional C programs. We present efficient compilation techniques for translating CEAL programs into C that can be compiled with existing C compilers using primitives supplied by a run-time library for <b>self-adjusting</b> computation. We implement the proposed compiler and evaluate its effectiveness. Our experiments show that CEAL is effective in practice: compiled <b>self-adjusting</b> programs respond to small modifications to their data by orders of magnitude faster than recomputing from scratch while slowing down a from-scratch run by a moderate constant factor. Compared to previous work, w...|$|R
40|$|We {{present an}} {{overview}} of our ongoing work on parallelizing self-adjusting-computation techniques. In <b>self-adjusting</b> computation, programs can respond to changes to their data (e. g., inputs, outcomes of comparisons) automatically by running a change-propagation algorithm. This ability is important in applications where inputs change slowly over time. All previously proposed <b>self-adjusting</b> computation techniques assume a sequential execution model. We describe techniques for writing parallel <b>self-adjusting</b> programs and a change propagation algorithm that can update computations in parallel. We describe a prototype implementation and present preliminary experimental results...|$|R
5000|$|... #Caption: {{symmetric}} roller grip, self-closing and <b>self-adjusting</b> ...|$|R
40|$|Abstract. In <b>self-adjusting</b> computation, {{programs}} respond automatically {{and efficiently}} to modifications to their data by tracking the dynamic data dependences of the computation and incrementally updating the output as needed. In this tutorial, {{we describe the}} self-adjustingcomputation model and present the language ∆ML (Delta ML) for writing <b>self-adjusting</b> programs. ...|$|R
25|$|<b>Self-Adjusting</b> Clutch (SAC) {{introduced}} on the straight-six petrol engines.|$|R
50|$|In an {{adaptive}} system, a parameter changes slowly {{and has no}} preferred value. In a <b>self-adjusting</b> system though, the parameter value “depends {{on the history of}} the system dynamics”. One of the most important qualities of <b>self-adjusting</b> systems is its “adaptation to the edge of chaos” or ability to avoid chaos. Practically speaking, by heading to the edge of chaos without going further, a leader may act spontaneously yet without disaster. A March/April 2009 Complexity article further explains the <b>self-adjusting</b> systems used and the realistic implications. Physicists have shown that adaptation to the edge of chaos occurs in almost all systems with feedback.|$|R
5000|$|Front {{disc brakes}} with <b>self-adjusting</b> rear drums on CF2/230 to CF2/280; ...|$|R
40|$|<b>Self-adjusting</b> {{computation}} is {{an evaluation}} {{model in which}} programs can respond efficiently to small changes to their input data by using a change-propagation mechanism that updates computation by re-building only the parts affected by changes. Previous work has proposed language techniques for <b>self-adjusting</b> computation and showed the approach {{to be effective in}} a number of application areas. However, due to the complex semantics of change propagation and the indirect nature of previously proposed language techniques, it remains difficult to reason about the efficiency of <b>self-adjusting</b> programs and change propagation. In this paper, we propose a cost semantics for <b>self-adjusting</b> computation that enables reasoning about its effectiveness. As our source language, we consider a direct-style λ-calculus with first-class mutable references and develop a notion of trace distance for source programs. To facilitate asymptotic analysis, we propose techniques for composing and generalizing concrete distances via trace contexts (traces with holes). We then show how to translate the source language into a <b>self-adjusting</b> target language such that the translation (1) preserves the extensional semantics of the source programs and the cost of from-scratch runs, and (2) ensures that change propagation between two evaluations takes time bounded by their relativ...|$|R
40|$|International audienceCombining type theory, {{language}} design, {{and empirical}} work, we present techniques for computing with large and dynamically changing datasets. Based on lambda calculus, our techniques {{are suitable for}} expressing a diverse set of algorithms on large datasets and, via <b>self-adjusting</b> computation, enable computations to respond automatically to changes in their data. To improve the scalability of <b>self-adjusting</b> computation, we present a type system for precise dependency tracking that minimizes the time and space for storing dependency metadata. The type system eliminates an important assumption of prior work {{that can lead to}} recording spurious dependencies. We present a type-directed translation algorithm that generates correct <b>self-adjusting</b> programs without relying on this assumption. We then show a probabilistic-chunking technique to further decrease space usage by controlling the fundamental space-time tradeoff in <b>self-adjusting</b> computation. We implement and evaluate these techniques, showing promising results on challenging benchmarks involving large graphs...|$|R
40|$|International audienceComputational {{problems}} that involve dynamic data, such as physics simulations and program development environments, {{have been an}} important subject of study in programming languages. Building on this work, recent advances in <b>self-adjusting</b> computation have developed techniques that enable programs to respond automatically and efficiently to dynamic changes in their inputs. <b>Self-adjusting</b> programs {{have been shown to}} be efficient for a reasonably broad range of problems but the approach still requires an explicit programming style, where the programmer must use specific monadic types and primitives to identify, create and operate on data that can change over time. We describe techniques for automatically translating purely functional programs into <b>self-adjusting</b> programs. In this implicit approach, the programmer need only annotate the (top-level) input types of the programs to be translated. Type inference finds all other types, and a type-directed translation rewrites the source program into an explicitly <b>self-adjusting</b> target program. The type system is related to information-flow type systems and enjoys decidable type inference via constraint solving. We prove that the translation outputs well-typed <b>self-adjusting</b> programs and preserves the source program's input-output behavior, guaranteeing that translated programs respond correctly to all changes to their data. Using a cost semantics, we also prove that the translation preserves the asymptotic complexity of the source program...|$|R
50|$|A {{patent for}} a <b>self-adjusting</b> bracket {{for use with}} cap lamps was awarded in 1985.|$|R
5000|$|... 2/12/1996. Michael Athans, {{founder of}} the <b>self-adjusting</b> control {{in the field of}} automation, Professor at M.I.T.|$|R
50|$|Fins with <b>self-adjusting</b> camber {{offer the}} {{improved}} qualities in both port side and starboard side sailing directions.|$|R
6000|$|STURGIS, J. MORTIMER. [...] Two dozen Silver King Golf-balls and one patent Sturgis [...] Aluminium <b>Self-Adjusting,</b> Self-Compensating Putting-Cleek.|$|R
50|$|Adaptation plays a {{vital role}} for all living organisms and systems. All of them are {{constantly}} changing their inner properties to better fit in the current environment. The most important instruments for the adaptation are the <b>self-adjusting</b> parameters inherent for many natural systems. The prominent feature of systems with <b>self-adjusting</b> parameters is an ability to avoid chaos.The name for this phenomenon is “Adaptation {{to the edge of}} chaos”.|$|R
40|$|Combining type theory, {{language}} design, {{and empirical}} work, we present techniques for computing with large and dynamically changing datasets. Based on lambda calculus, our techniques {{are suitable for}} expressing a diverse set of algorithms on large datasets and, via <b>self-adjusting</b> computation, enable computations to respond automatically to changes in their data. Compared to prior work, this work overcomes the main challenge of reducing the space usage of <b>self-adjusting</b> computation without disproportionately decreasing performance. To this end, we present a type system for precise dependency tracking that minimizes the time and space for storing dependency metadata. The type system eliminates an important assumption of prior work {{that can lead to}} recording of spurious dependencies. We give a new type-directed translation algorithm that generates correct <b>self-adjusting</b> programs without relying on this assumption. We then show a probabilistic chunking technique to further decrease space usage by controlling the fundamental space-time tradeoff in <b>self-adjusting</b> computation. We implement and evaluate these techniques, showing very promising results on challenging benchmarks and large graphs. 1...|$|R
50|$|Tenebrescent {{behavior}} is exploited in synthetic {{materials for the}} manufacture of <b>self-adjusting</b> sunglasses, which darken on exposure to sunlight.|$|R
6000|$|... § 2. Distinction between Variations in the Exchanges {{which are}} <b>self-adjusting</b> and those {{which can only}} be {{rectified}} through Prices.|$|R
50|$|Revolo also {{consists}} of an in-built device that recognizes driving patterns and <b>self-adjusts</b> to provide optimum efficiency in stop-and-go traffic situations.|$|R
5000|$|<b>Self-adjusting</b> wedges on all {{driving and}} coupled axleboxes to {{eliminate}} axlebox-frame gaps, to prevent pounding and vibration associated with axlebox wear; ...|$|R
40|$|In {{reliable}} multicast protocols, each {{data packet}} being sent must be acknowledged. Collecting the acknowledgments centrally at the sources can cause ACK-implosion and {{can result in}} poor scalability. To overcome this, clustering algorithms which use virtual structures to gather acknowledgments were proposed. In this work, we analyze the complexities of three such clustering algorithms: Lorax, k-degree, and <b>Self-adjust.</b> We compare {{the quality of the}} virtual structures produced by these algorithms, focusing on the number of clusters, cluster size, cluster radius, and the optimal positioning of cluster leaders. Our simulation showed that the virtual structure produced by <b>Self-adjust</b> is better in terms of cluster radius and the location of cluster leaders. However, due to the <b>self-adjusting</b> nature of the algorithm, it might take longer time to compute than the other two algorithms. I...|$|R
40|$|<b>Self-adjusting</b> {{computation}} {{offers a}} language-based approach to writing programs that automatically respond to dynamically changing data. Recent work made {{significant progress in}} developing sound semantics and associated implementations of <b>self-adjusting</b> computation for high-level, functional languages. These techniques, however, do not address issues that arise for low-level languages, i. e., stack-based imperative languages that lack strong type systems and automatic memory management. In this paper, we describe techniques for <b>self-adjusting</b> computation which are suitable for low-level languages. Necessarily, we take a different approach than previous work: instead of starting with a high-level language with additional primitives to support <b>self-adjusting</b> computation, we start with a low-level intermediate language, whose semantics is given by a stack-based abstract machine. We prove that this semantics is sound: it always updates computations {{in a way that}} is consistent with full reevaluation. We give a compiler and runtime system for the intermediate language used by our abstract machine. We present an empirical evaluation that shows that our approach is efficient in practice, and performs favorably compared to prior proposals. Comment: Full version of our OOPLSA 2011 paper. Contains a couple of additional sections as well as an appendix with our proof...|$|R
5000|$|P. Melby, J. Kaidel, N. Weber, A. Hübler, (2000), [...] "Adaptation to {{the edge}} of chaos in the <b>self-adjusting</b> {{logistic}} map", Phys.Rev.Lett. 84: 5991-5993.|$|R
40|$|A {{real time}} <b>self-adjusting</b> neuro control scheme for optical fiber drawing is {{presented}} in this paper. The fiber presents high and low frequency variations in the obtained diameter, being these last ones caused by variations in the preform diameter {{and the distribution of}} the molecular weight which affects the rheologic behavior during the drawing process of the material. In order to control these variations an algorithm of <b>self-adjusting</b> control based on a three layers perceptron type neural network is proposed...|$|R
5000|$|There {{are three}} main types of oil skimmer: weir (manual or <b>self-adjusting)</b> and {{oleophilic}} and non-oleophilic (disc, drum, belt, tube, brush,mop, grooved disc, grooved drum): ...|$|R
50|$|Brake {{failure is}} also caused by brake drum thermal {{expansion}} in which brake shoe clearance becomes excessive from wear. This was largely remedied in the 1950s by <b>self-adjusting</b> brakes. Maladjustment with wear {{is still a}} factor in trucks with drum air brakes. A Canadian survey of randomly stopped heavy trucks found over 10% of trucks using <b>self-adjusting</b> brakes {{had at least one}} brake out of adjustment, due either to failure of the <b>self-adjust</b> mechanism or wear beyond the capacity of the self adjuster. Newer brake pistons ("cans") extend stroke from about 65 mm to about 75 mm; since about 30 mm of stroke is used just putting the pads in contact with the drum, the added 10 mm of stroke is over 25% increase in useful stroke. Longer stroke reduces especially wear-related fade, but drum brakes are still fundamentally prone to fade when hot.|$|R
40|$|The {{performance}} of distributed shared memory {{depends on the}} memory coherence algorithms and the access characteristics of shared data. In this paper, we propose an efficient coherence scheme using multiple coherence algorithms with <b>self-adjusting</b> feature. Our method can dynamically choose a more adaptive coherence algorithm for each variable class and the incorrect classification of shared variables will not affect the performance. We show that for each fixed classification, application programs suffer 5. 1 %, 4. 6 %, and 48. 9 % increases in the average execution time, when compared against the {{performance of}} a <b>self-adjusting</b> scheme. Experiments have shown our approach achieving good performance. Keywords. Distributed shared memory; memory coherence; multiple coherence algorithms; <b>self-adjusting</b> coherence scheme. This research work was partially supported by National Science Council of Republic of China under grant No. NSC 81 - 0408 -E 009 - 18. y Hsiao-Hsi Wang is with Institute of Computer [...] ...|$|R
50|$|The top end also {{featured}} adjustable tappets using the bucket and shim arrangement, and required checking every 25000 mi, although later (1990-) models had <b>self-adjusting</b> hydraulic tappets.|$|R
5000|$|This <b>self-adjusting</b> nature {{makes the}} {{selection}} of the maximum venturi diameter (colloquially, but inaccurately, referred to as [...] "choke size") much less critical than with a fixed-venturi carburettor.|$|R
40|$|AbstractBased on the min-max principle, the {{standard}} centering equation {{in the interior}} point method is replaced by the optimality condition of a new proximity measure function. Thus, a <b>self-adjusting</b> mechanism is constructed in the new perturbed system. The Newton direction can be adjusted self-adaptively according to the information of last iterates. A <b>self-adjusting</b> interior point method is given based on the new perturbed system. Numerical comparison is made between this algorithm and a primal-dual interior point algorithm using “standard” perturbed system. Results demonstrate the efficiency and some advantages of the proposed algorithm...|$|R
40|$|In (Hui and Martel, 1993), we {{designed}} and analyzed efficient <b>self-adjusting</b> linear list algorithms. Our analysis proves that a <b>self-adjusting</b> linear list algorithm, MP, is competitive {{to a large}} class of offline adversaries, where the operations are successful searches, unsuccessful searches, and insertions. Analysis of deletions is listed as an open question. This paper presents an improved version of MP which is also able to handle deletions efficiently, and proves that the new MP algorithm is 6 -competitive to offline adversaries when considering successful searches, unsuccessful searches, insertions, and deletions. link_to_subscribed_fulltex...|$|R
40|$|Developed is a wind-wheel design {{equipped}} with the <b>self-adjusting</b> blade. The blade is positioned eccentrically to the balance wheel and can freely rotate around its axis. Elaborated is the method of calculating the energy characteristics for a wind-wheel with the <b>self-adjusting</b> blade, considering not only the wind force but the force of air counter flow resistance to the blade’s rotation. Initially, the blade being located at an angle α = 45 to the wheel rotation plane, the air flow rotates the wheel with the maximum force. Thus, the speed of rotation increases that involves the increase in air counter flow resistance and results in blade turning with respective angle α reduction. This, consequently, reduces the torque. When the torsional force and the resistance enter into equilibrium, the blade takes a certain angle α, and the wheel speed becomes constant. This wind-wheel design including a <b>self-adjusting</b> blade allows increasing the air flow load ratio {{when compared to the}} wind-wheel {{equipped with}} a jammed blade...|$|R
50|$|Bucky spent {{significant}} {{portions of}} his career in both Germany and the United States. He was close friends with Albert Einstein and shared a patent with him for a <b>self-adjusting</b> camera.|$|R
50|$|As {{the shoes}} in drum brakes wear, brakes {{required}} regular manual adjustment until {{the introduction of}} <b>self-adjusting</b> drum brakes in the 1950s. Drums are prone to brake fading with repeated use.|$|R
