11|124|Public
2500|$|HyperCard {{contains}} an object oriented scripting language called HyperTalk. Objects {{exist in a}} message path hierarchy and respond to messages generated by either the user or the <b>system</b> (<b>timers</b> for instance). Objects inherit properties and attributes from those above them in the hierarchy. [...] HyperTalk object classes are predetermined by the HyperCard environment, although others can be added {{by the use of}} externals (see below). HyperTalk is verbose, hence its ease of use and readability. HyperTalk code segments are referred to as [...] "scripts", a term that was considered less daunting to beginning programmers.|$|E
50|$|Typical uses of {{interrupts}} {{include the}} following: <b>system</b> <b>timers,</b> disk I/O, power-off signals, and traps. Other interrupts exist to transfer data bytes using UARTs or Ethernet; sense key-presses; control motors; {{or anything else}} the equipment must do.|$|E
50|$|All Amiga {{computers}} (except the CD32, {{where these}} functions are {{performed by the}} Akiko chip) use two 8520 CIA (Complex Interface Adapter) for peripheral interfacing and the <b>system</b> <b>timers.</b> These chips were also used in some other Commodore devices.|$|E
5000|$|Sprinkler <b>system</b> <b>timer,</b> an {{electrical}} device? that can control water timers ...|$|R
3000|$|We added tracepoints to the kernel {{through a}} loadable module for flexibility, so no {{modification}} to kernel code {{would be required}} to perform trace synchronization. Upon loading, this module registers a probe to the <b>system</b> <b>timer’s</b> interrupt. In other words, every time the <b>system</b> <b>timer</b> issues an interrupt to the CPU, our synchronization routine will be invoked. The synchronization routine can be summed up as follows: [...]...|$|R
40|$|The basic <b>system</b> <b>timer</b> {{facilities}} used by applications and OS kernels for scheduling timeouts and periodic activities have remained largely unchanged for decades, while hardware architectures and application loads have changed radically. This raises concerns with CPU overhead, power management and application responsiveness. In this paper we study how kernel timers {{are used in}} the Linux and Vista kernels, and the instrumentation challenges and tradeoffs inherent in conducting such a study. We show how the same timer facilities serve at least five distinct purposes, and examine their performance characteristics under a selection of application workloads. We show that many timer parameters supplied by application and kernel programmers are somewhat arbitrary, and examine the potential benefit of adaptive timeouts. We also discuss the further implications of our results, both for enhancements to the <b>system</b> <b>timer</b> functionality in existing kernels, and for the clean-slate design of a <b>system</b> <b>timer</b> subsystem for new OS kernels, including the extent to which applications might require such an interface at all...|$|R
50|$|Akiko is the CD32's {{all-purpose}} 'glue' {{chip and}} forms {{part of the}} AGA chipset used in that system. Akiko is responsible for implementing system glue logic that in previous Amiga models {{were found in the}} discrete chips Budgie, Gayle and the two CIAs. In detail, it includes control logic for the CD32's CD-ROM controller, <b>system</b> <b>timers,</b> the two game ports and the serial ('AUX') port and the chip memory soldered onto the motherboard. It controls a one kilobyte EEPROM for saving data such as highscores etc.|$|E
5000|$|HyperCard {{contains}} an object oriented scripting language called HyperTalk. Objects {{exist in a}} message path hierarchy and respond to messages generated by either the user or the <b>system</b> (<b>timers</b> for instance). Objects inherit properties and attributes from those above them in the hierarchy. HyperTalk object classes are predetermined by the HyperCard environment, although others can be added {{by the use of}} externals (see below). HyperTalk is verbose, hence its ease of use and readability. HyperTalk code segments are referred to as [...] "scripts", a term that was considered less daunting to beginning programmers.|$|E
50|$|The CPU core (defined in APM as the CPU clock, cache, {{system bus}} and <b>system</b> <b>timers)</b> is treated {{specially}} in APM, {{as it is}} the last device to be powered down, and the first device to be powered back up. The CPU core is always controlled through the APM BIOS (there is no option to control it through a driver). Drivers can use APM function calls to notify the BIOS about CPU usage, but {{it is up to the}} BIOS to act on this information; a driver cannot directly tell the CPU to go into a power saving state.|$|E
50|$|In computing, a jiffy was {{originally}} {{the time between}} two ticks of the <b>system</b> <b>timer</b> interrupt. It is not an absolute time interval unit, since its duration depends on the clock interrupt frequency of the particular hardware platform.|$|R
5000|$|The Intel 8253 PIT was the {{original}} timing device used on IBM PC compatibles. It used a 1.193182 MHz clock signal (one third of the color burst frequency used by NTSC, one twelfth of the system clock crystal oscillator [...] ) and contains three timers. Timer 0 is used by Microsoft Windows (uniprocessor) and Linux as a <b>system</b> <b>timer,</b> timer 1 was historically used for {{dynamic random access memory}} refreshes and timer 2 for the PC speaker.|$|R
5000|$|SysTick timer: A 24-bit <b>system</b> <b>timer</b> {{that extends}} the {{functionality}} {{of both the}} processor and the Nested Vectored Interrupt Controller (NVIC). When present, it also provides an additional configurable priority SysTick interrupt. Though the SysTick timer is optional, it is very rare to find a Cortex-M microcontroller without it.|$|R
5000|$|At boot time, all BIOS {{services}} are available, {{and the memory}} below address [...] contains the interrupt vector table. BIOS POST has initialized the <b>system</b> <b>timers</b> 8253 or 8254 IC), interrupt controller(s), DMA controller(s), and other motherboard/chipset hardware as necessary to bring all BIOS services to ready status. DRAM refresh for all system DRAM in conventional memory and extended memory, but not necessarily expanded memory, {{has been set up}} and is running. The interrupt vectors corresponding to the BIOS interrupts have been set to point at the appropriate entry points in the BIOS, hardware interrupt vectors for devices initialized by the BIOS have been set to point to the BIOS-provided ISRs, and some other interrupts, including ones that BIOS generates for programs to hook, have been set to a default dummy ISR that immediately returns. The BIOS maintains a reserved block of system RAM at addresses [...] with various parameters initialized during the POST. All memory at and above address [...] can be used by the boot program; it may even overwrite itself.|$|E
40|$|This paper {{examines}} {{the dissemination of}} market timing information (signals on the overall performance of risky assets relative to the risk free rate). We consider two delivery systems. Under the newsletter delivery system market timing information is disseminated solely through newsletter. Under the fund delivery <b>system,</b> <b>timers</b> set up timing funds in which investors can invest. In the absence of market imperfections we find that both systems produce the same result. With restrictions on borrowing or with other nonlinearities we find the newsletter system to be superior. This is {{one possible explanation for}} the plethora of market timing newsletters and the paucity of market timing funds. ...|$|E
30|$|The MLME-START.request primitive, depends of the {{rescheduling}} {{technique to}} be used. If a Re-ordering technique {{is to be}} used, then the CH will used a DCS-RESTART-ROUTER.request, with the new offset information. This new interface is similar the standard NLME-RESTART-ROUTER.request, except no change is done to the other parameters of the stack. The objective is to simply turn the routing functionality on. If a Bandwidth reallocation is to be done, then the request will also change the Superframe Order parameter of the stack to reflect the bandwidth change. The <b>system</b> <b>timers</b> at the MAC layer, upon reception of this request are automatically updated with the new Superframe Order. Upon the reception of a Beacon from the parent, the ZigBee Router will automatically resynchronize and resume its work.|$|E
3000|$|... where T is a {{coarse-grained}} value updated on <b>system</b> <b>timer</b> interrupts. For a finer timekeeping, T {{needs to}} be adjusted using the TSC {{to account for the}} elapsed time since the last update (last timer interrupt). This is done using function f (...), which translates the TSC to an actual time value {{that can be used for}} fine-grained timekeeping.|$|R
50|$|The {{most widely}} {{supported}} kernel mode of oprofile uses a <b>system</b> <b>timer</b> (See: Gathering profiling events). However, this mode {{is unable to}} measure kernel functions where interrupts are disabled. Newer CPU models support a hardware performance counter mode which uses hardware logic to record events without any active code needed. In Linux 2.2/2.4 only 32-bit x86 and IA64 are supported; in Linux 2.6 there is wider support: x86 (32 and 64 bit), DEC Alpha, MIPS, ARM, sparc64, ppc64, AVR32.|$|R
5000|$|In 2012, ARM {{contributed a}} new [...] {{implementation}} allowing the <b>system</b> <b>timer</b> built into many ARMv7 CPUs {{to be used}} instead of a busy-wait loop. This implementation was released in Version 3.6 of the Linux kernel. Timer-based delays are more robust on systems that use frequency scaling to dynamically adjust the processor's speed at runtime, as [...] values may not necessarily scale linearly. Also, since the timer frequency is known in advance, no calibration is needed at boot time.|$|R
40|$|The Modechart {{specification}} {{language is a}} formalism for the specification of real-time systems. A toolset for specification, analysis and simulation for Modechart specifications exists for supporting the design and construction of real-time systems [CHLR 93]. This paper introduces a new tool in the the toolset: a compiler for a class of Modechart specifications, namely, that of deterministic system specifications, extended by a subclass of the non-deterministic system specifications. The object code that the compiler generates is in ESTEREL, {{a member of the}} synchronous family of programming languages for real-time systems. We discuss a broad approach to the implementation of timing specifications, providing a range of implementation options, from the basic time step unrolling of states in ESTEREL, to the use of <b>system</b> <b>timers.</b> The compiler presented herein allows the specifier to obtain a correct implementation of a modechart program, including timing constraints. 1 Introduction While d [...] ...|$|E
40|$|Virtual Real Time (VRT) is a {{computer}} program for testing embedded flight software by computational simulation in a workstation, in contradistinction to testing it in its target central processing unit (CPU). The disadvantages of testing in the target CPU include {{the need for an}} expensive test bed, the necessity for testers and programmers to take turns using the test bed, and the lack of software tools for debugging in a real-time environment. By virtue of its architecture, most of the flight software of the type in question is amenable to development and testing on workstations, for which there is an abundance of commercially available debugging and analysis software tools. Unfortunately, the timing of a workstation differs from that of a target CPU in a test bed. VRT, in conjunction with closed-loop simulation software, provides a capability for executing embedded flight software on a workstation in a close-to-real-time environment. A scale factor is used to convert between execution time in VRT on a workstation and execution on a target CPU. VRT includes high-resolution operating- <b>system</b> <b>timers</b> that enable the synchronization of flight software with simulation software and ground software, all running on different workstations...|$|E
40|$|This paper {{presents}} {{a tool for}} dynamic forecasting of Network-Enabled Servers performance. Fast (Fast Agent’s <b>System</b> <b>Timer)</b> is a software package allowing client applications to get an accurate forecast of rou-tines needs in terms of completion time, memory space and number of communication, {{as well as of}} current system availability. Fast relies on existing low level software packages, i. e., network and host monitoring tools, and some of our developments in computation routines modeling. The Fast internals and user inter-face are presented, as well as experimental results...|$|R
50|$|DOS {{is not a}} {{multitasking}} operating system. DOS did however {{provide a}} Terminate and Stay Resident (TSR) function which allowed programs to remain resident in memory. These programs could hook the <b>system</b> <b>timer</b> and/or keyboard interrupts to allow themselves to run tasks in the background or to be invoked at any time preempting the current running program effectively implementing a simple form of multitasking on a program-specific basis. The PRINT command did this to implement background print spooling. Borland Sidekick, a popup personal information manager (PIM), also used this technique.|$|R
50|$|MAPPER (not to be {{confused}} with the Unisys product of the same name) was a statistical performance analysis tool.It operated by allowing the program under test to run in Interrupt mode, but also used the <b>system</b> <b>timer</b> to periodically interrupt it. The addresses where the tested program was interrupted were recorded and later summarized and tabulated in the form of a map, showing the density of interrupts over the memory addresses. The result resembled nuclear scintigraphy images, showing the parts of the program most frequently used under the test conditions.|$|R
40|$|The clock offset {{between a}} GPS-based NTP time server and NTP time client software, {{installed}} in the MS Windows Operating System (OS) and the Linux OS on PCs, are measured and evaluated. The clock offset on MS Windows 98 OS shows a trend {{with a range of}} about 55 ms. The NTP time client software on MS Windows OS adjusts the internal clock with the Application Program Interface (API) timer function. The resolution of the API timer function depends on the hardware interrupt of the PC <b>system</b> <b>timer,</b> which is 54. 9 ms of IRQ 0 for MS Windows 98 OS. Thus, this range of the trend in the clock offset is considered to be caused by the resolution of API timer function. The clock offset on MS Windows XP OS shows time resolutions of 1 ms for the 1 ms API timer mode and 10 ms for the 10 ms API timer mode. The resolution of 1 ms is dependent on a hardware interrupt of IRQ 8 (976 μs) that is generated by a PC real-time clock. The resolution of the <b>system</b> <b>timer</b> on MS-windows XP depends on the hardware platform and shows 10 ms or 15 ms. The clock offset on Linux OS also has a trend as well as a periodic divergence. The trend interval of the drift is estimated to be about 35 minutes. The origin of this trend in interval is presumed to be the loop constant of the kernel Phase Lock Loop (PLL). The Standard Deviation of this clock offset for 24 hours is 0. 95 ms. Evidently, both MS Windows OS and Linux OS adopt different algorithms for keeping the internal clock. The accuracy of time synchronization by NTP is restricted by the algorithms. The limitation of the time synchronization accuracy on MS Windows OS is related to the resolution of API that depends on a hardware interrupt generated in the PC hardware <b>system</b> <b>timer</b> and real-time clock. On the other hand, the loop constant of the kernel clock algorithm restricts the time synchronization accuracy by NTP on Linux OS. I...|$|R
40|$|International audienceProgrammable logic {{controllers}} (PLCs) {{are widely}} used in embedded <b>systems.</b> <b>Timers</b> play {{a pivotal role in}} PLC real-time applications. The formalization of timers is of great importance. The study presents a formalization of PLC timers in the theorem proving system Coq, in which the behaviors of timers are characterized by a set of axioms at an abstract level. The authors discuss how to model timers at a proper and sound abstract level. PLC programs with timers are modeled. As a case study, a quiz machine problem with a timer is investigated. This work demonstrates the complexity of formal timer modelin...|$|R
40|$|This paper {{presents}} {{a tool for}} dynamic forecasting of Network-Enabled Servers performance. FAST (Fast Agent's <b>System</b> <b>Timer)</b> is a software package allowing client applications to get an accurate forecast of communication and computation times and memory use in a heterogeneous environment. It relies on low level software packages, i. e., network and host monitoring tools, {{and some of our}} developments in computation routines modeling. The FAST internals and user interface are presented and a comparison between the execution time predicted by FAST and the measured time of complex matrix multiplication executed on an heterogeneous platform is given...|$|R
50|$|Three Atlas Es were {{launched}} in 1964. The {{first of these}} was 48E on February 12. The guidance <b>system</b> <b>timer</b> failed due to liftoff-induced vibration, resulting in premature discreet cutoff signals being issued. The booster engines were shut down at T+96 seconds, the sustainer at T+240 seconds, and the verniers at T+300 seconds, causing an impact only 285 miles downrange. Missile 5E on February 25 was successful. Missile 57E on August 27 fell 60 miles short of its planned range when a malfunction of the guidance system accelerometer caused the sustainer and vernier cutoff signals to be issued early.|$|R
40|$|In {{this paper}} we {{presents}} {{a tool for}} the dynamic forecast of performance of linear algebra routine as well as com-munication between clusters. FAST (Fast Agent ’s <b>System</b> <b>Timer)</b> is a software package allowing client applications to obtain an accurate forecast of routine needs in terms of completion time, memory space, and number of commu-nication, as well as current system availability. FAST relies on existing low-level software packages, i. e. network and host monitoring tools, {{and some of our}} developments in sequential and parallel computational routines modeling. The FAST internals and user interface are presented, as well as experimental results and validation on different applications. Key words: Performance evaluation, parallel computing...|$|R
5000|$|... {-- [...] This program {{displays}} the current time on standard output every other second. -} module examples.CommandLineClock wheredata Date = native java.util.Date where native new :: (...) -> IO (MutableIO Date) -- new Date (...) native toString :: Mutable s Date -> ST s String -- d.toString (...) --- 'IO' action {{to give us}} the current time as 'String'current :: IO Stringcurrent = do d <- Date.new (...) -- reads <b>system</b> <b>timer,</b> hence IO d.toStringmain args = [...] forever do current >>= print -- print formatted date print [...] "\r" [...] -- followed by carriage return stdout.flush -- make sure it's shown Thread.sleep 999L -- wait 0.999 seconds ...|$|R
5000|$|... ttyskeepawake prevent idle system {{sleep when}} any tty (such as a remote login session) is active; a tty is {{inactive}} only when its idle time exceeds the <b>system</b> sleep <b>timer,</b> 1 to enable or 0 to disable ...|$|R
40|$|International audienceProgrammable logic {{controllers}} (PLCs) {{are widely}} used in computer-based industrial applications. Timers play {{a pivotal role in}} PLC real-time embedded system applications. The paper addresses the formal validation of PLC <b>systems</b> with <b>timers</b> in the theorem proving <b>system</b> Coq. The <b>timer</b> behavior is characterized formally. A reﬁnement validation methodology is presented in terms of an abstract model and a concrete model. The reﬁnement is calibrated by a mapping relation. The soundness of the methodology is shown in the proving system. An illustrative case study demonstrates the eectiveness of the approach...|$|R
40|$|Special {{issue on}} Clusters and Computational Grids for Scientific Computing (CCGSC' 02) In this paper we {{presents}} {{a tool for}} the dynamic forecast of performance of linear algebra routine as well as communication between clusters. FAST (Fast Agent's <b>System</b> <b>Timer)</b> is a software package allowing client applications to obtain an accurate forecast of routine needs in terms of completion time, memory space, and number of communication, as well as current system availability. FAST relies on existing low-level software packages, i. e. network and host monitoring tools, {{and some of our}} developments in sequential and parallel computational routines modeling. The FAST internals and user interface are presented, as well as experimental results and validation on different applications...|$|R
2500|$|On March 1, 2010 (UTC), {{many of the}} {{original}} [...] "fat" [...] PlayStation 3 models worldwide were experiencing errors related to their internal system clock. The error had many symptoms. Initially, the main problem {{seemed to be the}} inability to connect to the PlayStation Network. However, the root cause of the problem was unrelated to the PlayStation Network, since even users who had never been online also had problems playing installed offline games (which queried the <b>system</b> <b>timer</b> as part of startup) and using system themes. At the same time many users noted that the console's clock had gone back to December 31, 1999. The event was nicknamed the ApocalyPS3, a play on the word [...] and PS3, the abbreviation for the PlayStation 3 console.|$|R
40|$|This paper proposes {{the design}} and {{implementation}} of OpenMP program model based on embedded multicore platform, and also presents {{the evaluation of the}} parallel algorithms. We raise the solution by adopting the scheduler form embedded configurable system (eCos) and the runtime library of the Portable Operating System UNIX (POSIX) threads to found the cross compile environment of the OpenMP programs. The Cannon and FFT algorithm based on OpenMP programming model are analyzed specially for memory limited embedded multicore system. The execution of OpenMP programs is implemented on a FPGA platform and the execution time is measured by eCos <b>system</b> <b>timer.</b> The OpenMP parallel programs have got an average accelerating ratio of 3. 2 on 4 processor cores with a low memory requirement (< 4 MByte) ...|$|R
50|$|So {{a process}} switch {{proceeds}} {{something like this}} - a process requests a resource that is not immediately available, maybe a read of a record of a file from a block which is not currently in memory, or the <b>system</b> <b>timer</b> has triggered an interrupt. The operating system code is entered and run {{on top of the}} user stack. It turns off user process timers. The current process is placed in the appropriate queue for the resource being requested, or the ready queue waiting for the processor if this is a preemptive context switch. The operating system determines the first process in the ready queue and invokes the instruction move_stack, which makes the process {{at the head of the}} ready queue active.|$|R
5000|$|On March 1, 2010 (UTC), {{many of the}} {{original}} [...] "fat" [...] PlayStation 3 models worldwide were experiencing errors related to their internal system clock. The error had many symptoms. Initially, the main problem {{seemed to be the}} inability to connect to the PlayStation Network. However, the root cause of the problem was unrelated to the PlayStation Network, since even users who had never been online also had problems playing installed offline games (which queried the <b>system</b> <b>timer</b> as part of startup) and using system themes. At the same time many users noted that the console's clock had gone back to December 31, 1999. The event was nicknamed the ApocalyPS3, a play on the word [...] and PS3, the abbreviation for the PlayStation 3 console.|$|R
