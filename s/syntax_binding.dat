2|57|Public
40|$|Abstract. A novel {{argument}} {{binding mechanism}} {{that can be}} used with STL algorithm invocations is proposed. Without using any adaptors, bin-ding can be applied directly to pointers to nonmember functions, pointers to const and nonconst member functions and STL function objects. The types and number of arguments in the functions to be bound can be practically arbitrary; argument list lengths up to few dozens of elements can be supported. The unbound arguments are expressed as special placeholders in the argument list; they can appear for any argument position. Hence, binding sites preserve the resemblance to the function prototype of the underlying function, leading to simple and intuitive <b>syntax.</b> <b>Binding</b> can be applied recursively. This results in a versatile function composition mechanism. The binding mechanism is ecient {{in the sense that it}} induces very little or no runtime cost. ...|$|E
40|$|Abstract This {{thesis is}} the result of a study on the Italian {{reflexive}} morpheme auto-, especially in verbal environments. The restrictions on the prefixation of auto- raise a number of questions related the interferences between the structures of the verbs and the Reflexivization operation. When observed through the lens of the Reinhart (2000, 2002) 's Theta System, the (im) possibility of the prefixation of auto- “unveils” the structure of a verb. For the reasons that will be discussed and because of its properties of lexical operation, the auto-prefixation can be used a probe to observe Grooming verbs and Reciprocals. Abstract In section (1) I introduce informally verbs and Reflexivity; in section (2) I outline the notions of Anaphora and Binding, focusing on the distinction between Coreference and Binding. I explain Reinhart (2006) 's definition of logical <b>syntax</b> <b>binding</b> and subsequently the distinction between pronominal and anaphors, and the locality conditions on binding. Then I focus on the notion of Reflexivity as the case of co-argument binding. The problem posed by IDI is introduced as well as the solutions to it that languages have. In section (3) I present in detail Reinhart (2000, 2002) 's Theta System, the analysis of the verbs' argument structure and the operation that can apply to verbal entries. Reflexivity is one of these operations. The contrast between syntax and lexicon languages is introduced and the idea that reflexive morphemse are, in some cases, elements that take care of the residual case remained after Reflexivization applied. In the first part of section (4), the Intermezzo, I outline the traditional analysis of auto-; in the second part I discuss Italian reflexive nouns, which happen to be deverbal nominal auto-prefixed. The data is in support of the thesis presented in Hron (2009). Section (5) is dedicated to the distribution of auto-, first some observations on the productivity and, later on, on the restrictions. Following the Theta System analysis of the verbs, auto-verbs must have a [+c+m] argument in their structure. Since not all [+c+m] accept auto-prefixation, the exceptions are discussed. In the last section, (6), I discuss the concept of proxies as crucial to understand the semantics and pragmatics of auto-. The auto-prefixation, as a lexical operation, does not allow proxy-readings. But the concept of proxy may vary, as author/work proxies are allowed by auto-, as in the case of Translate-type verbs. In fact, when (non-statue) proxies are invoved, some [+c] verbs also allow auto-...|$|E
40|$|Abstract. Abstract <b>syntax</b> with {{variable}} <b>binding</b> {{is known}} to be characterised as an initial algebra in a presheaf category. This paper extends it to the case of poly-morphic typed abstract <b>syntax</b> with <b>binding.</b> We consider two variations, second-order and higher-order polymorphic syntax. The central idea is to apply Fiore’s initial algebra characterisation of typed abstract <b>syntax</b> with <b>binding</b> repeatedly, i. e. first to the type structure and secondly to the term structure of polymorphic system. In this process, we use the Grothendieck construction to combine differ-ently staged categories of polymorphic contexts. ...|$|R
50|$|The MPI {{interface}} {{is meant}} to provide essential virtual topology, synchronization, and communication functionality between a set of processes (that have been mapped to nodes/servers/computer instances) in a language-independent way, with language-specific <b>syntax</b> (<b>bindings),</b> plus a few language-specific features. MPI programs always work with processes, but programmers commonly refer to the processes as processors. Typically, for maximum performance, each CPU (or core in a multi-core machine) will be assigned just a single process. This assignment happens at runtime through the agent that starts the MPI program, normally called mpirun or mpiexec.|$|R
5000|$|Declarative Databindings. ZK has an {{optional}} <b>syntax</b> for <b>binding</b> user interface controls to your POJO Java Beans. ZK will automatically call your POJO setter/getter methods with zero programming {{in response to}} user input at the browser.|$|R
40|$|Abstract. This {{document}} describes part of {{an effort}} to achieve in Nuprl a practical reflection of its expression syntax. This reflection is done at the granularity of the operators; in particular, each operator of the syntax is denoted by another operator of the same syntax. Further, the <b>syntax</b> has <b>binding</b> operators, and we organize reflection not around the concrete <b>binding</b> <b>syntax,</b> but instead, around the abstract higher-order syntax. We formulate and prove the correctness of a core rule for inferring well-formedness of instances of operator-denoting operators. ...|$|R
40|$|FOOLPROOF is {{intended}} as a component toolkit for implementation of formal languages with binding structures. It provides a coherent collection of components for many common language processing tasks, in particular those related to binding structures. FOOLPROOF consists of: a meta-language for specifying signatures with variable bindings; a signature editor for constructing well-formed signatures; a small collection of interfaces for manipulating <b>syntax</b> trees and <b>binding</b> structures at various levels of detail; a set of generic components for processing <b>syntax</b> trees with <b>binding</b> structures, in particular for: copying, substitution, editing, matching, unification and rewriting; a generator which maps signature specifications to signature-specific classes. FOOLPROOF is being implemented in Object Pascal and will eventually {{take the form of}} a component library for the Delphi environment. Key words: abstract <b>syntax,</b> variable <b>bindings,</b> signatures, structure editors, API generators, component library, Delphi...|$|R
40|$|We {{provide a}} {{semantic}} framework for (first order) message-passing process calculi by combining categorical theories of abstract <b>syntax</b> with <b>binding</b> and operational semantics. In particular, we obtain abstract rule formats for name and value passing with both late and early interpretations. These formats induce an initial-algebra/finalcoalgebra semantics that is compositional, respects substitution, and is fully abstract for late and early congruence. We exemplify the theory with the #-calculus and valuepassing CCS...|$|R
40|$|Abstract. We {{define a}} notion of module over a monad {{and use it to}} propose a new {{definition}} (or semantics) for abstract <b>syntax</b> (with <b>binding</b> constructions). Using our notion of module, we build a category of exponential monads, which can be understood as the category of lambda-calculi, and prove that it has an initial object (the pure untyped lambda-calculus). Our definitions and results are formalized in the proof assistant Coq. 1...|$|R
40|$|We {{propose a}} new {{definition}} for abstract <b>syntax</b> (with <b>binding</b> constructions), and, accordingly, for initial semantics and algebraicity. Our definition {{is based on}} the notion of module over a monad and its companion notion of linearity. In our setting, we give a one-line definition of an untyped lambda-calculus. Among untyped lambda-calculi, the initial one, the pure untyped lambda-calculus, appears as defined by two algebraic constructions (abs and the unary application app 1), together with two algebraic equations which are essentially the β and η rules...|$|R
40|$|We {{extend our}} {{approach}} to abstract <b>syntax</b> (with <b>binding</b> constructions) through modules and linearity. First we give a new general definition of arity, yielding the companion notion of signature. Then we obtain a modularity result as requested by [GU 03]: in our setting, merging two extensions of syntax corresponds to building an amalgamated sum. Finally we define a natural notion of equation concerning a signature and prove {{the existence of an}} initial semantics for a so-called representable signature equipped with a set of equations...|$|R
30|$|Several {{techniques}} {{can be used}} {{in order to deal with}} the problem of free variable capture on substitution, such as de Bruijn indexes [7], locally nameless representation [8] and high-order abstract syntax [14]. More about the formalisation of programming languages <b>syntax</b> with variable <b>binding</b> can be found at [1].|$|R
40|$|Inspired {{from the}} recent {{developments}} in theories of non-wellfounded syntax (coinductively defined languages) and of <b>syntax</b> with <b>binding</b> operators, the structure of algebras of wellfounded and non-wellfounded terms is studied for a very general notion of signature permitting both simple variable binding operators as well as operators of explicit substitution. This is done in an extensional mathematical setting of initial algebras and final coalgebras of endofunctors on a functor category. In the non-wellfounded case, the fundamental operation of substitution is more beneficially {{defined in terms of}} primitive corecursion than coiteration...|$|R
40|$|We {{present the}} {{formalization}} {{of a theory}} of <b>syntax</b> with <b>bindings</b> that has been developed and refined {{over the last decade}} to support several large formalization efforts. Terms are defined for an arbitrary number of constructors of varying numbers of inputs, quotiented to alpha-equivalence and sorted according to a binding signature. The theory includes a rich collection of properties of the standard operators on terms, such as substitution and freshness. It also includes induction and recursion principles and support for semantic interpretation, all tailored for smooth interaction with the bindings and the standard operators. Comment: Extended version of paper published in ITP 201...|$|R
40|$|This memo defines an Experimental Protocol for the Internet community. It {{does not}} specify an Internet {{standard}} of any kind. Discussion {{and suggestions for}} improvement are requested. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (1999). All Rights Reserved. This memo describes a syntax for embedding S-HTTP negotiation parameters in HTML documents. S-HTTP, as described by RFC 2660, contains the concept of negotiation headers which reflect the potential receiver of a message’s preferences as to which cryptographic enhancements should {{be applied to the}} message. This document describes a <b>syntax</b> for <b>binding</b> these negotiation parameters to HTML anchors. 1...|$|R
50|$|Variable binding relates three things: a {{variable}} v, a location a for that variable in an expression and a non-leaf node n {{of the form}} Q(v, P). Note: we define a location in an expression as a leaf node in the <b>syntax</b> tree. Variable <b>binding</b> occurs when that location is below the node n.|$|R
40|$|We {{develop some}} Higher-Order Abstract Syntax (HOAS) {{concepts}} and proof principles {{as a collection}} of definitions and propositions on top of the original <b>syntax</b> with <b>bindings.</b> Our approach brings together hassle-free (i. e., binding- and substitution-free) manipulation of the objects on the one hand, and inductive reasoning about the same objects on the other. We present our approach by providing adequate representations of the untyped lambda-calculus, its beta-reduction and its Curry-style System F typing. The HOAS induction and recursion principles extracted from the encoding are illustrated by employing them in tandem to naturally (re) discover a proof of strong normalization for typable terms in System F. unpublishe...|$|R
40|$|We {{develop a}} theory of {{abstract}} <b>syntax</b> with variable <b>binding.</b> To every binding signature we associate a category of models consisting of variable sets endowed with compatible algebra and substitution structures. The syntax generated by the signature is the initial model. This gives a notion of initial algebra semantics encompassing the traditional one; besides compositionality, it automatically veri- fies the semantic substitution lemma...|$|R
40|$|We {{develop a}} theory of <b>syntax</b> with <b>bindings,</b> {{focusing}} on: - methodological issues concerning the convenient representation of syntax; - techniques for recursive definitions and inductive reasoning. Our approach consists {{of a combination of}} FOAS (First-Order Abstract Syntax) and HOAS (Higher-Order Abstract Syntax) and tries {{to take advantage of the}} best of both worlds. The connection between FOAS and HOAS follows some general patterns and is presented as a (formally certified) statement of adequacy. We also develop a general technique for proving bisimilarity in process algebra. Our technique, presented as a formal proof system, is applicable to a wide range of process algebras. The proof system is incremental, in that it allows building incrementally an a priori unknown bisimulation, and pattern-based, in that it works on equalities of process patterns (i. e., universally quantified equations of process terms containing process variables), thus taking advantage of equational reasoning in a "circular" manner, inside coinductive proof loops. All the work presented here has been formalized in the Isabelle theorem prover. The formalization is performed in a general setting: arbitrary many-sorted <b>syntax</b> with <b>bindings</b> and arbitrary SOS-specified process algebra in de Simone format. The usefulness of our techniques is illustrated by several formalized case studies: - a development of call-by-name and call-by-value lambda-calculus with constants, including Church-Rosser theorems, connection with de Bruijn representation, connection with other Isabelle formalizations, HOAS representation, and contituation-passing-style (CPS) transformation; - a proof in HOAS of strong normalization for the polymorphic second-order lambda-calculus (a. k. a. System F). We also indicate the outline and some details of the formal development...|$|R
40|$|Nominal {{terms are}} an {{extended}} first-order language for specifying and verifying properties of <b>syntax</b> with <b>binding.</b> Founded upon the semantics of nominal sets, {{the success of}} nominal terms with regard to systems of equational reasoning is already well established. This work first extends the untyped language of nominal terms with a notion of non-capturing atom substitution for object-level names and then proposes a dependent type system for this extended language. Both these contributions are intended {{to serve as a}} prelude to a future nominal logical framework based upon nominal equational reasoning and thus an extended example is given to demonstrate that this system is capable of encoding various other formal systems of interest...|$|R
40|$|Abstract We {{develop a}} theory of {{abstract}} <b>syntax</b> with variable <b>binding.</b> To every binding signature we associate a category of models consisting of variable sets endowed with both a (binding) algebra and a substitution structure compatible with each other. The syntax generated by the signature is the initial model. This gives a notion of initial algebra semantics encompassing the traditional one; besides compositionality, it automatically verifies the semantic substitution lemma...|$|R
40|$|Metadata is {{now widely}} {{deployed}} {{to assist the}} management of digital content and to support {{a wide range of}} service domains. Its adoption by a wide range of communities managing Web-content is the good news. However, a survey of sample current implementations reveals that much of this deployed metadata comes {{in a wide variety of}} <b>syntaxes</b> and <b>bindings,</b> reflecting a diversity of approaches to managing information. This presents a major challenge for information sharing. This plenary presentation explores a range of current issues including the concept of interoperability, the use of application profiles and value-added metadata services, demands for maintenance and sustainability of infrastructure, together with some exploration of the next generation metadata infrastructure challenges with particular reference to the needs of learning communities. 1...|$|R
40|$|AbstractFragments of {{mainstream}} programming languages are formalised {{in order to}} show desirable properties of their static semantics. We ask if said formalisms could also be used to define a test suite for the mainstream programming language in question, and what the utility of such a suite would be. In this work, we present our findings from testing Java with Featherweight Java (FJ). We take the <b>syntax</b> and <b>binding</b> structure of FJ to define an instance space of non-isomorphic test programs and implementations of FJ type checkers to provide oracles for our tests, to ensure the mainstream implementation conforms with the expectations of FJ. Using these, we evaluate (using code coverage techniques) how much of the Sun OpenJDK javac can be tested by FJ...|$|R
40|$|Fragments of {{mainstream}} programming languages are formalised {{in order to}} show desirable properties of their static semantics. We ask if said formalisms could also be used to define a test suite for the mainstream programming language in question, and what the utility of such a suite would be. In this work, we present our findings from testing Java with Featherweight Java (FJ). We take the <b>syntax</b> and <b>binding</b> structure of FJ to define an instance space of non-isomorphic test programs and implementations of FJ type checkers to provide oracles for our tests, to ensure the mainstream implementation conforms with the expectations of FJ. Using these, we evaluate (using code coverage techniques) how much of the Sun OpenJDK javac can be tested by FJ. © 2009 Elsevier B. V. All rights reserved...|$|R
40|$|There are two {{well-known}} {{approaches to}} programming with names, binding, and equivalence up to consistent renaming: representing names and bindings as concrete identifiers in a first-order language (such as Prolog), or encoding names and bindings as variables and abstractions in a higher-order language (such as Lambda-Prolog). However, both approaches have drawbacks: the former often involves stateful name-generation and requires manual definitions for alpha-equivalence and capture-avoiding substitution, {{and the latter}} is semantically very complicated, so reasoning about programs written using either approach can be very di#cult. Gabbay and Pitts have developed {{a new approach to}} encoding abstract <b>syntax</b> with <b>binding</b> based on primitive operations of name-swapping and freshness. This paper presents Alpha-Prolog, a logic programming language that uses this approach, along with several illustrative example programs and an operational semantics...|$|R
40|$|Nominal {{techniques}} {{are based on}} the idea of sets with a finitelysupported atoms-permutation action. In this paper we consider the idea of sets with a finitely-supported atoms-renaming action (renamings can identify atoms; permutations cannot). We show that these exhibit many of the useful qualities found in traditional nominal techniques; an elementary sets-based presentation, inductive datatypes of <b>syntax</b> up to <b>binding,</b> cartesian closure, and being a topos. Unlike in nominal techniques, the notion of names-abstraction coincides with functional abstraction. 1...|$|R
40|$|We {{describe}} motivation, design, use, {{and implementation}} of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or <b>syntax</b> incorporates name <b>binding</b> information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higherorder abstract syntax, a supporting matching and unification algorithm, and some clients in Commo...|$|R
40|$|AbstractThe {{theory of}} nominal sets {{is a rich}} {{mathematical}} framework for studying <b>syntax</b> and variable <b>binding.</b> Within it, we can describe several binding disciplines and derive convenient reasoning principles that respect α-equivalence. In this article, we introduce the notion of binding operator, a novel construction on nominal sets that unifies and generalizes many forms of binding proposed in the literature. We present general results about these operators, including sufficient conditions for validly using them in inductive definitions of nominal sets...|$|R
40|$|Abstract. Recently {{there has}} {{been a great deal of}} {{interest}} in higher-order syntax which seeks to extend standard initial algebra semantics to cover languages with variable binding. The canonical example studied in the literature is that of the untyped λ-calculus which is handled as an instance of the general theory of binding algebras, cf. Fiore, Plotkin, Turi [13]. Another important syntactic construction is that of explicit substitutions which are used to model local definitions and to implement reduction in the λ-calculus. The syntax of a language with explicit substitutions does not form a binding algebra as an explicit substitution may bind an arbitrary number of variables. Thus explicit substitutions are a natural test case for the further development of the theory and applications of <b>syntax</b> with variable <b>binding.</b> This paper shows that a language containing explicit substitutions and a firstorder signature Σ is naturally modelled as the initial algebra of the Id + FΣ ◦ + ◦ endofunctor. We derive a similar formula for adding explicit substitutions to the untyped λ-calculus and then show these initial algebras provide useful datatypes for manipulating abstract syntax by implementing two reduction machines. We also comment on the apparent lack of modularity in <b>syntax</b> with variable <b>binding</b> as compared to first-order languages...|$|R
40|$|This paper {{focuses on}} wh-in-situ {{phenomena}} under phase-based approach and discusses the asymmetry between wh-arguments and wh-adjuncts in Mandarin Chinese. Wh-adjuncts, contrary to wh-arguments, {{are considered to}} be operators and must undergo movement so that the wh-island effects in this case can be explained. This paper attributes the subjacency effect to the locality requirement of wh-adjuncts and suggests that the asymmetry results from different licensing processes on wh-words, movement in the narrow <b>syntax,</b> or <b>binding</b> after narrow <b>syntax.</b> 1. Wh-in-situ and Subjacency Effect It is well known that wh-words in Chinese and Japanese stay in situ, whereas wh-words in English must move to the initial position. The data are shown in (1). (1) a. What did John think [that Bill bought e]? (wh movement) b. Zhangsan renwei [Lisi mai-le sheme]? (wh in-situ) Zhangsan think Lisi buy-Asp what c. Taro-ga [Hanako-ga nani-o katta] to omotteiru-no? (wh in-situ...|$|R
40|$|Initial Semantics aims at {{characterizing the}} syntax {{associated}} to a signature as the initial object of some category. We present an initial semantics result for typed <b>syntax</b> with variable <b>binding</b> together with its formalization in the Coq proof as-sistant. The main theorem was first proved on {{paper in the}} second author’s PhD thesis in 2010, and verified formally shortly afterwards. To a simply–typed binding signature S over a fixed set T of object types we associate a category called the category of representations of S. We show that thi...|$|R
40|$|Abstract. Nominal {{techniques}} {{are based on}} the idea of sets with a finitelysupported atoms-permutation action. We consider the idea of nominal renaming sets, which are sets with a finitelysupported atoms-renaming action; renamings can identify atoms, permutations cannot. We show that nominal renaming sets exhibit many of the useful qualities found in (permutative) nominal sets; an elementary sets-based presentation, inductive datatypes of <b>syntax</b> up to <b>binding,</b> cartesian closure, and being a topos. Unlike is the case for nominal sets, the notion of names-abstraction coincides with functional abstraction. Thus we obtain a concrete presentation of sheaves o...|$|R
40|$|Constraint Handling Rules provide {{descriptions}} for constraint solvers. However, {{they fall}} short when those constraints specify some binding structure, like higher-rank types in a constraint-based type inference algorithm. In this paper, the term syntax of constraints {{is replaced by}} λ-tree <b>syntax,</b> in which <b>binding</b> is explicit; and a new ∇ generic quantifier is introduced, {{which is used to}} create new fresh constants. Comment: Paper presented at the 33 nd International Conference on Logic Programming (ICLP 2017), Melbourne, Australia, August 28 to September 1, 2017 16 pages, LaTeX, no PDF figure...|$|R
40|$|These notes {{form the}} basis of four lectures given at the Summer School on Generic Programming, Oxford, UK, which took place during August 2002. The aims of the notes are to provide an {{introduction}} to very elementary category theory, and to show how such category theory can be used to provide both abstract and concrete mathematical models of syntax. Much of the material is now standard, but some of the ideas which are used in the modeling of <b>syntax</b> involving variable <b>binding</b> are quite new. It is assumed that readers [...] ...|$|R
40|$|AbstractThis paper formalises within first-order logic {{some common}} {{practices}} {{in computer science}} to do with representing and reasoning about syntactical structures involving lexically scoped binding constructs. It introduces Nominal Logic, a version of first-order many-sorted logic with equality containing primitives for renaming via name-swapping, for freshness of names, and for name-binding. Its axioms express properties of these constructs satisfied by the FM-sets model of <b>syntax</b> involving <b>binding,</b> which was recently introduced by the author and M. J. Gabbay and makes use of the Fraenkel–Mostowski permutation model of set theory. Nominal Logic serves {{as a vehicle for}} making two general points. First, name-swapping has much nicer logical properties than more general, non-bijective forms of renaming {{while at the same time}} providing a sufficient foundation for a theory of structural induction/recursion for syntax modulo α-equivalence. Secondly, it is useful for the practice of operational semantics to make explicit the equivariance property of assertions about syntax – namely that their validity is invariant under name-swapping...|$|R
40|$|In this paper, we {{show how}} to {{manipulate}} <b>syntax</b> with <b>binding</b> using a mixed representation of names for free variables (with {{respect to the}} task in hand) and de Bruijn indices [5] for bound variables. By doing so, we retain the advantages of both representations: naming supports easy, arithmetic-free manipulation of terms; de Bruijn indices {{eliminate the need for}} α-conversion. Further, we have ensured that not only the user but also the implementation need never deal with de Bruijn indices, except within key basic operations. Moreover, we give a hierarchical representation for names which naturally reflects the structure of the operations we implement. Name choice is safe and straightforward. Our technology combines easily with an approach to syntax manipulation inspired by Huet’s ‘zippers’[10]. Without the ideas in this paper, we would have struggled to implement EPIGRAM [19]. Our example—constructing inductive elimination operators for datatype families—is but one of many where it proves invaluable...|$|R
