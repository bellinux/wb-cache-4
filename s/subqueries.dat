262|66|Public
500|$|The intuition {{for what}} happens above is that the Codd tables {{representing}} the projections in the <b>subqueries</b> lose track {{of the fact that}} [...] the Nulls in the columns F12.F2 and F23.F2 are actually copies of the originals in the table J. This observation suggests that a relatively simple improvement of Codd tables (which works correctly for this example) would be to use Skolem constants (meaning Skolem functions which are also constant functions), say ω12 and ω22 instead of a single NULL symbol. Such an approach, called v-tables or Naive tables, is computationally less expensive that the c-tables discussed above. However it is still not a complete solution for incomplete information in the sense that v-tables are only a weak representation for queries not using any negations in selection (and not using any set difference either). The first example considered in this section is using a negative selection clause, WHERE Age <> 22, so it is also an example where v-tables queries would not report sure information.|$|E
50|$|The {{effect of}} {{correlated}} <b>subqueries</b> can {{in some cases}} be obtained using joins. For example, the queries above (which use inefficient correlated <b>subqueries)</b> may be rewritten as follows.|$|E
5000|$|Since 1999 the SQL {{standard}} allows [...] clauses for <b>subqueries,</b> i.e. named <b>subqueries,</b> {{usually called}} common table expressions (also called subquery factoring). CTEs {{can also be}} recursive by referring to themselves; the resulting mechanism allows tree or graph traversals (when represented as relations), and more generally fixpoint computations.|$|E
50|$|In a SQL {{database}} query, a correlated <b>subquery</b> (also {{known as}} a synchronized <b>subquery)</b> is a <b>subquery</b> (a query nested inside another query) that uses values from the outer query. Because the <b>subquery</b> may be evaluated once for each row processed by the outer query, it can be inefficient.|$|R
50|$|A <b>subquery</b> can use {{values from}} the outer query, in which case it {{is known as a}} {{correlated}} <b>subquery.</b>|$|R
30|$|According to Listing 1, {{the outer}} query accesses the view {{generated}} by the <b>subquery,</b> whereas the <b>subquery</b> projects email fields, provided that the access control policies specified for those fields are satisfied. As shown in Listing 1, any field of emails is explicitly referred to by name in the <b>subquery.</b>|$|R
5000|$|Composability, which removes {{restrictions}} on where <b>subqueries</b> can be used.|$|E
50|$|Through data abstraction, federated {{database}} {{systems can}} provide a uniform user interface, enabling users and clients to store and retrieve data from multiple noncontiguous databases with a single query—even if the constituent databases are heterogeneous. To this end, a federated database system {{must be able to}} decompose the query into <b>subqueries</b> for submission to the relevant constituent DBMSs, after which the system must composite the result sets of the <b>subqueries.</b> Because various database management systems employ different query languages, federated database systems can apply wrappers to the <b>subqueries</b> to translate them into the appropriate query languages.|$|E
50|$|Cassandra cannot do joins or <b>subqueries.</b> Rather, Cassandra {{emphasizes}} denormalization through {{features like}} collections.|$|E
5000|$|A derived {{table is}} the use of {{referencing}} an SQL <b>subquery</b> in a FROM clause. Essentially, the derived table is a <b>subquery</b> that can be selected from or joined to. The derived table functionality allows the user to reference the <b>subquery</b> as a table. The inline view is also referred to as an inline view [...] or a subselect.|$|R
5000|$|An {{example of}} a {{recursive}} query computing the factorial of numbers from 0 to 9 is the following:WITH RECURSIVE temp (n, fact) AS (SELECT 0, 1 -- Initial <b>Subquery</b> UNION ALL [...] SELECT n+1, (n+1)*fact FROM temp -- Recursive <b>Subquery</b> [...] WHERE n < 9)SELECT * FROM temp; ...|$|R
5000|$|... where a <b>subquery</b> is an {{arbitrarily}} {{long list}} of tags, concatenated as directories: ...|$|R
5000|$|Version 4.1: beta from June 2004, {{production}} release October 2004 (R-trees and B-trees, <b>subqueries,</b> prepared statements).|$|E
50|$|Correlated <b>subqueries</b> {{may appear}} {{elsewhere}} besides the WHERE clause; for example, this query uses a correlated subquery in the SELECT clause to print the entire list of employees alongside {{the average salary}} for each employee's department. Again, because the subquery is correlated with a column of the outer query, it must be re-executed for each row of the result.|$|E
50|$|Transbase {{supports}} {{all important}} {{functions of the}} SQL standard: extensive transaction concept, complex queries with included <b>subqueries,</b> referential integrity (primary keys, foreign keys, check constraints and others),set operations, updatable views, trigger, interface for C, C++, Java/JDBC, PHP, ODBC export and import of data as well as database schema. The database is extensible via additional functions and custom data types.|$|E
40|$|Abstract — When a query jointly {{addresses}} {{very large}} and very small collections it may happen that an iteration caused by a query operator is driven by a large collection and in each cycle it evaluates a <b>subquery</b> that depends on an element of a small collection. For each such element the result returned by the <b>subquery</b> is the same. In effect, such a <b>subquery</b> is unnecessarily evaluated many times. The optimization rewrites such a query to reverse the situation: the loop is to be performed on a small collection and inside each its cycle a <b>subquery</b> addressing a large collection is evaluated. We illustrate the method on comprehensive examples and then present the general rewriting rule. The research follows the Stack-Based Approach to query languages having roots in the semantics of programming languages. The optimization method consists in analyzing of scoping and binding rules for names occurring in queries. I I...|$|R
50|$|CTEs can {{be thought}} of as {{alternatives}} to derived tables (<b>subquery),</b> views, and inline user-defined functions.|$|R
50|$|Embedded queries {{supported}} include <b>subquery</b> expressions, expr IN (subselect), quantified comparisons, and the EXISTS (subselect) predicate.|$|R
5000|$|Queries can be nested so {{that the}} results of one query can be used in another query via a {{relational}} operator or aggregation function. A nested query is also known as a subquery. While joins and other table operations provide computationally superior (i.e. faster) alternatives in many cases, the use of <b>subqueries</b> introduces a hierarchy in execution that can be useful or necessary. In the following example, the aggregation function [...] receives as input the result of a subquery: ...|$|E
5000|$|Pre-release builds later {{included}} <b>subqueries</b> that aggregated {{content from}} a main Library Search Folder. Microsoft's stated aim {{with this approach}} was {{to move beyond the}} traditional physical folder concept, but the company received a considerable amount of feedback from users who found that the new Search Folder-based approach was too confusing. In particular, the Search Folders being located on the Start menu led to the belief that there existed multiple physical folders with similar names and content.|$|E
5000|$|Conjunctive queries also {{correspond}} to select-project-join queries in relational algebra (i.e.,relational algebra queries {{that do not}} use the operations union or difference) and to select-from-where queries in SQL in which the where-condition uses exclusively conjunctions of atomic equality conditions, i.e. conditions constructed from column names and constants using no comparison operators other than [...] "=", combined using [...] "and". Notably, this excludes the use of aggregation and <b>subqueries.</b> For example, the above query can be written as an SQL query of the conjunctive query fragment as ...|$|E
5000|$|In ANSI SQL the [...] keyword {{can be used}} to {{transform}} a <b>subquery</b> into a collection expression: ...|$|R
5000|$|... is {{a general}} select {{that can be used}} as <b>subquery</b> {{expression}} of another more general query, while ...|$|R
3000|$|..., the <b>subquery</b> {{selection}} {{is achieved by}} an exhaustive evaluation of {{all parts of the}} cascade of filters [...]...|$|R
50|$|Lucene {{has been}} around for a while now. Many {{bioinformatics}} centres have been experimenting with its use with biological data and databases. A pioneering development in this field is headed by Dr. Don Gilbert at Indiana University, called LuceGene, a part of the GMOD (Generic Software Components for Model Organisms Databases) initiative. Another example is the search engine in the UniProt web site which is also based on Lucene and adds features such as sorting large data sets, <b>subqueries</b> across data sets and group-by queries. Lucene is also used in QuALM a question answering system for Wikipedia.|$|E
5000|$|When sent a command, early {{versions}} of Apple's DAL interpreter broke down the statement and re-built it into <b>subqueries</b> for the underlying data sources. This translation {{took place on}} the server-side, just like PL/SQL and Transact-SQL, but required a fairly expensive [...] "adaptor" [...] program of often dubious performance. This adaptor made DAL considerably less appealing than later systems like ODBC, where the translation normally takes place on the client side and is typically included for free with the database engine. The downside to the ODBC approach is that, theoretically at least, more network bandwidth is used up to pull the [...] "raw data" [...] to the client machine for processing back into a standard format.|$|E
50|$|The intuition {{for what}} happens above is that the Codd tables {{representing}} the projections in the <b>subqueries</b> lose track {{of the fact that}} the Nulls in the columns F12.F2 and F23.F2 are actually copies of the originals in the table J. This observation suggests that a relatively simple improvement of Codd tables (which works correctly for this example) would be to use Skolem constants (meaning Skolem functions which are also constant functions), say ω12 and ω22 instead of a single NULL symbol. Such an approach, called v-tables or Naive tables, is computationally less expensive that the c-tables discussed above. However it is still not a complete solution for incomplete information in the sense that v-tables are only a weak representation for queries not using any negations in selection (and not using any set difference either). The first example considered in this section is using a negative selection clause, WHERE Age <> 22, so it is also an example where v-tables queries would not report sure information.|$|E
5000|$|The EXISTS {{condition}} {{uses the}} SQL standard keyword [...] {{to determine whether}} rows exist in a <b>subquery</b> result.|$|R
40|$|We discuss query {{optimization}} in {{a secure}} distributed database system, called the Secret Sharing Distributed DataBase System (SSDDBS). We {{have to consider}} not only <b>subquery</b> allocations to distributed servers and data transfer on the network but also decoding distributed shared data. At first, we formulated the <b>subquery</b> allocation problem as a constraints satisfaction problem. Since the <b>subquery</b> allocation problem is NP-complete in general, {{it is not easy}} to obtain the optimal solution in practical time. Secondly, we proposed a heuristic evaluation function for the best-first search. We constructed an optimization model on an available optimization software, and evaluated the proposed method. The results showed that feasible solutions could be obtained by using the proposed method in practical time, and that quality of the obtained solutions was good...|$|R
5000|$|Delete rows from mytable using a <b>subquery</b> in the where condition:DELETE FROM mytable WHERE id IN ( [...] SELECT id FROM mytable2 [...] ); ...|$|R
40|$|One of {{the most}} {{powerful}} features of SQL is the use of nested queries. Most research work on the optimization of nested queries focuses on aggregate <b>subqueries.</b> However, the solutions proposed for non-aggregate <b>subqueries</b> are still limited, especially for queries having multiple <b>subqueries</b> and null values. In this paper, we show that existing approaches to queries containing non-aggregate <b>subqueries</b> proposed in the literature (including rewrites) are not adequate. We then propose a new efficient approach, the nested relational approach, based on the nested relational algebra. Our approach directly unnests non-aggregate <b>subqueries</b> using hash joins, and treats all <b>subqueries</b> in a uniform manner, being able to deal with nested queries of any type and any level. We report on experimental work that confirms that existing approaches have difficulties dealing with non-aggregate <b>subqueries,</b> and that our approach offers better performance. We also discuss some possibilities for algebraic optimization and the issue of integrating our approach in a relational database system. 1...|$|E
40|$|The {{issue of}} <b>subqueries</b> in SPARQL has {{appeared}} in different papers as an extension point to the original SPARQL query language. Particularly, nested CONSTRUCT in FROM clauses are a feature that has been discussed as a potential input for SPARQL 1. 1 which was resolved {{to be left out}} in favour of select <b>subqueries</b> under the - unproven - conjecture that such <b>subqueries</b> can express nested construct queries. In this paper, we show that it is indeed possible to unfold nested SPARQL construct queries into <b>subqueries</b> in SPARQL 1. 1; our transformation, however, requires an exponential blowup in the nesting depth. This suggests that nested construct queries are indeed a useful syntactic feature in SPARQL that cannot compactly be replaced by <b>subqueries...</b>|$|E
40|$|Abstract. The <b>Subqueries</b> {{functionality}} is {{a powerful}} feature which allows to enforce reuse, composition, rewriting and optimization in a query language. In this paper we perform a comprehensive study of the incorporation of <b>subqueries</b> into SPARQL. We consider several possible choices {{as suggested by the}} experience of similar languages, as well as features that developers are incorporating and/or experimenting with. Based on this study, we present an extension of SPARQL, with syntax and formal semantics, which incorporates all known types of <b>subqueries</b> in a modular fashion and preserves the original semantics. ...|$|E
5000|$|... {{transforms}} the <b>subquery</b> into a collection expression {{that can be}} used in another query, or in assignment to a column of appropriate collection type.|$|R
50|$|Here is {{an example}} for a typical {{correlated}} <b>subquery.</b> In this example, {{the objective is to}} find all employees whose salary is above average for their department.|$|R
40|$|Can you {{actually}} get something for nothing? With PROC SQL‟s <b>subquery</b> and remerging features, yes, you can. When working with categorical variables, often {{there is a}} need to add group descriptive statistics such as group counts, minimum and maximum values for further by-group processing. Instead of first creating the group count, minimum or maximum values and then merging the summarized dataset to the original dataset, why not take advantage of PROC SQL to complete two steps in one? With PROC SQL‟s <b>subquery</b> and summary functions by the group variable, you can easily remerge the new group descriptive statistics back to the original dataset...|$|R
