15|137|Public
50|$|The {{prepared}} statement execution {{consists of}} two stages: prepare and execute. At the prepare stage a statement template {{is sent to the}} database server. The server performs a <b>syntax</b> <b>check</b> and initializes server internal resources for later use.|$|E
50|$|Programming editors, {{also known}} as source code editors, are text editors that are {{specifically}} designed for programmers or developers for writing the source code of an application or a program. Most of these editors include features useful for programmers, which may include color syntax highlighting, auto indentation, auto-complete, bracket matching, <b>syntax</b> <b>check,</b> and allows plug-ins. These features aid the users during coding, debugging and testing.|$|E
5000|$|OCL {{is often}} {{referred}} to as an object analog for SQL since OCL provides a means to make queries in terms of objects. ECO uses its own OCL editor with <b>syntax</b> <b>check</b> and expression assistant in order to simplify writing type safe OCL expressions. The ECO OCL editor validates OCL expressions also against the actual model context. The following OCL expression selects company employee objects representing employees older than 30 years. If persisted object instances are not present in memory when the OCL expression is evaluated, they will be automatically loaded into memory by the ECO framework: ...|$|E
40|$|AEJCL {{provides}} a listing and JCL <b>syntax</b> <b>checking</b> facility on a PDP/ 9 L computer system. The <b>syntax</b> <b>checking</b> system {{is controlled by}} a directed graph structure which is initially written in a machine independent language and then translated to PDP/ 9 L code automatically. The input and output sections of the system are handled asynchronously by a multitasking master control program...|$|R
2500|$|... visudo is a {{command-line}} utility {{that allows}} editing the configuration file in a fail-safe manner. It prevents multiple simultaneous edits with locks and performs sanity and <b>syntax</b> <b>checks.</b>|$|R
5000|$|The ACE's dialect of FORTH {{introduced}} several innovations. First As FORTH programming environment, {{it added}} <b>syntax</b> <b>checking</b> to control structures and definer constructions (a.k.a. [...] "Safe Compiling") {{as well as}} decompiling capabilities.|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedA universal syntax checker was constructed to be utilized with a text editor in a time-sharing environment. This syntax checker is a top-down left-right slow-back parser that will provide, when supplied the syntax of any {{language in the}} Backus-normal form, a <b>syntax</b> <b>check</b> for any string written in a language described. The procedure is capable of handling left, right, and self-embedded recursive definitions. [URL] United States Nav...|$|E
40|$|In {{this work}} we {{investigate}} {{the performance of}} watermarking as an error detection method for H. 264 /AVC encoded videos. The efficiency of a previously proposed forced even watermarking is evaluated in a more realistic error-prone transmission scenario. A less invasive watermarking scheme, the force odd watermarking, is proposed as alternative. In order to handle possible decoding desynchronization at the receiver, we implement a <b>syntax</b> <b>check</b> error detection mechanism together with watermarking and evaluate its performance. 1...|$|E
40|$|The <b>syntax</b> <b>check</b> options {{direct the}} SAS ® system, when a syntax error occurs while {{compiling}} source code, {{to enter a}} special mode to scan {{the remainder of the}} job for syntax errors after the point where the first error occurred. In this mode, only the header portion of some data sets are created, permanent data sets are not replaced, but global commands are executed (also a very few PROCs). The options controlling the mode are explained and illustrated using simple test jobs. The effects of setting and resetting the option within a job are explored, and there are some surprises along the way. The risks of running with the options enabled vs. disabled are discussed...|$|E
5000|$|SpecBox: from Adelard {{provides}} <b>syntax</b> <b>checking,</b> {{some simple}} semantic checking, and generation of a LaTeX file enabling specifications to be printed in mathematical notation. This tool is freely available {{but it is}} not being further maintained.|$|R
50|$|The {{latest version}} of Lisa is V3.2. Lisa {{includes}} an integrated editor with <b>syntax</b> <b>checking.</b> Lisa can assemble up to 30,000 lines of code in a minute on a 1 MHz computer, a speed achieved due to the editor's pre-parsing of the source code.|$|R
50|$|PceEmacs is a SWI-Prolog builtin editor. PceEmacs is an Emacs clone {{implemented}} in Prolog (and XPCE). It supports proper indentation, syntax highlighting, full <b>syntax</b> <b>checking</b> {{by calling the}} SWI-Prolog parser, warning for singleton variables and finding predicate definitions based on the source-information from the Prolog database.|$|R
40|$|Abstract. According to the {{requirements}} of IEC 61131 - 3 standard, the system of Programmable Logic Controller(PLC) using Sequential Function Chart (SFC) as the main programming language is build. Aiming at {{the requirements}} of the SFC programming system, the framework of SFC is established, on this basis, a suit of data structure based on Object-Oriented thinking is designed. It describes the data structure of SFC mainly, and in this way, the functions of SFC, including edit, modify and compile, etc, are realized. The <b>syntax</b> <b>check</b> and logic check of SFC are achieved by traveling recursively and iterating the layers of the nested data structure of SFC. After making SFC into intermediate code, eventually the intermediate code is translated into the corresponding object code...|$|E
40|$|Abstract. Automated {{modeling}} of appropriate and valid document descriptions {{is a central}} issue for the benefit and success of an ontologybased personal document management system. One of the more practical problems is the deduction of knowledge from partly large but varying, ambiguous, or domain specific information sources (metadata, attributes, features, etc.). The generation process, which requires transformation and reasoning techniques, primarily depends on the application context and should be customized accordingly. Furthermore, automatically generated and deduced information needs appropriate cleaning and consolidation to maintain {{a certain level of}} data quality. Therefore, this paper presents a stepwise knowledge modeling approach based on consecutive stages and separated, configurable rule sets. Following the principle of divide-and-conquer, the suggested approach separately addresses the problems of general translation of diverse information sources, <b>syntax</b> <b>check,</b> normalization, and duplication and conflict handling. ...|$|E
40|$|Introduction For {{practically}} applied {{natural language}} processing systems, grammars with extensive coverage are required. The writing of broad-coverage grammars is so complex a task that it cannot be done on paper alone, but must be supported by powerful tools for testing the grammar with respect to consistency, coverage, overgeneration and accuracy. Grammar writing is similar to programming in that grammars and programs must be tested and debugged until their input/output behaviour meets the given specifications and they run efficiently. Unlike programming, which can be approached by techniques like top-down refinement, modularization and so on, grammar writing is an incremental process, which consists of a cycle of writing or modifying of the grammar, testing of the grammar, debugging the grammar. Grammar engineering tools must support this work cycle. All existing grammar engineering tools include an editor for modification of the grammar, possibly enhanced by <b>syntax</b> <b>check...</b>|$|E
50|$|The program {{features}} syntax highlighting and auto-completion for SQL, PHP, HTML, CSS, JavaScript, and XML, {{as well as}} automatic <b>syntax</b> <b>checking.</b> There is a HTML and CSS inspector like Firebug. It {{also includes}} Drupal support. All plugins are paid, but they offer trial periods of varying length.|$|R
5000|$|Atari Microsoft BASIC, unlike Atari BASIC, didn't allow {{abbreviations}} for keywords; keywords {{had to be}} fully spelled out. <b>Syntax</b> <b>checking</b> occurred after running a program, not immediately after entering the line. Also, arithmetic operations with integers resulted in an integer result.Atari Microsoft BASIC came in two packages: ...|$|R
50|$|SPE runs on Linux, Mac OS X and Microsoft Windows and has syntax highlighting, auto completion, auto indentation, call tips, {{multiple}} tabs, <b>syntax</b> <b>checking</b> and {{an integrated}} GUI designer (wxGlade) and debugger (winpdb). It {{is based on}} wxPython. Available under the GNU General Public License, SPE is free software.|$|R
40|$|Abstract—Incorrectly {{received}} packets in low-rate video sequences {{result in}} the loss of considerably large picture areas that have to be concealed. The performance of error concealment decreases with the size of the interpolated picture area. The incorrectly received packets may still contain some correct information that can be exploited at the decoder. In this work we propose the utilization of information from the link layer of UMTS (Universal Mobile Telecommunications System) at the application layer for better pre-localization of errors in the bitstream domain. <b>Syntax</b> <b>check</b> together with the detection of impairments in the pixel domain decide which part of the incorrectly received packets will be concealed. We evaluate the results using error traces from the live UMTS network and H. 264 /AVC (Advanced Video Coding) encoded video stream. Apart from reduced complexity facilitated by the cross-layer approach, the proposed method gains 1. 09 dBs of Y-PSNR compared to a slice rejection mechanism. Index Terms—Video streaming, UMTS, H. 264 /AVC, error resilience, error detection, cross-layer...|$|E
40|$|The XTCE GOVSAT {{software}} suite contains three tools: validation, search, and reporting. The Extensible Markup Language (XML) Telemetric and Command Exchange (XTCE) GOVSAT Tool Suite {{is written in}} Java for manipulating XTCE XML files. XTCE is a Consultative Committee for Space Data Systems (CCSDS) and Object Management Group (OMG) specification for describing the format and information in telemetry and command packet streams. These descriptions are files {{that are used to}} configure real-time telemetry and command systems for mission operations. XTCE s purpose is to exchange database information between different systems. XTCE GOVSAT consists of rules for narrowing the use of XTCE for missions. The Validation Tool is used to <b>syntax</b> <b>check</b> GOVSAT XML files. The Search Tool is used to search (i. e. command and telemetry mnemonics) the GOVSAT XML files and view the results. Finally, the Reporting Tool is used to create command and telemetry reports. These reports can be displayed or printed for use by the operations team...|$|E
30|$|CB {{priority}}. A small {{source of}} false negatives {{results from the}} priority issue in processing CB. For instance, the sentence “Allow Ad to create a calendar event?” describes a “Setting” manner, but S 3 identifies it as insensitive. S 3 correctly parses its syntax as an action “Allow” followed by a noun phrase “Ad” and an action “create” followed by a noun phrase “a calendar event”. S 3 first identifies the sensitive candidate noun phrase “a calendar event” because it has three neighbors in category “Calendar” while noun phrase “Ad” has no neighbors in any categories. Then S 3 identifies the noun phrase “a calendar event” is dominated by an action “create”. This action also has neighbors in concept space of actions in category “Calendar”. Then the noun phrase “a calendar event” and its dominant action “create” make up a CBANP. Since the noun phrase “Ad” is insensitive but its dominant action “Allow” has neighbors in category “Setting”, the action “Allow” makes up a CBA. Because the CBANP has higher priority than CBA, S 3 identifies the sensitiveness of the text based on the CBANP “create a calendar event”. However the <b>syntax</b> <b>check</b> fails because the CBANP is dominated by another action “Allow” (the ancestor node is a verb phrase). Such issue can be addressed by processing the CB sequentially until it reaches a sensitive category rather than only processing the top priority CB.|$|E
50|$|ABAP Objects {{is fully}} {{compatible}} with the existing language, so one can use existing statements and modularization units in programs that use ABAP Objects, and can also use ABAP Objects in existing ABAP programs. <b>Syntax</b> <b>checking</b> is stronger in ABAP Objects programs, and some syntactical forms (usually older ones) of certain statements are not permitted.|$|R
40|$|This thesis {{describes}} {{techniques for}} defining independent tasks in Java programs forparallelization. Existing Java parallelization APIs like JOMP, Parallel Java,Deterministic Parallel Java, JConqurr and JaMP are discussed. We {{have seen that}} JaMPis an implementation of OpenMP for Java, {{and it has a}} set of OpenMP directives andruntime library functions. We have discussed that JaMP has source to byte codecompiler, and it does not help in debugging the parallel source codes. There is no designtime <b>syntax</b> <b>checking</b> support of JaMP directives, and we know about mistakes onlywhen we compile the source code with JaMP compiler. So we have decided tocontribute JaMP with adding an option in the compiler to get parallel source code. Wehave created an eclipse plug-in to support design time <b>syntax</b> <b>checking</b> of JaMPdirectives too. It also helps the programmers to get quickly parallel source code withjust one click instead of using shell commands with JaMP compiler...|$|R
40|$|In {{this paper}} we will explain {{how to build}} fast {{scanners}} for regular languages in TEX. The resulting scanners can be composed with different parsers if they are written as self parsers. This parsing technique allows us to choose the syntactic rigour: from loose parsers with almost no <b>syntax</b> <b>checks,</b> good for pretty-printers, to the strict parser needed to write a compiler...|$|R
40|$|This study {{presents}} {{detection of}} SQL injection queries by a multi level architecture which uses multiple agents. The SQL injection attacks {{are one of}} the biggest security threats in databases. SQL Injection {{is one of the many}} web attack mechanisms used by hackers to steal data from organizations. The proposed architecture is based on a hierarchical and distributed strategy where the functionalities are structured on layers. SQL-injection attacks, one of the most dangerous attacks to online databases, are the focus of this research. The agents in each one of the layers are specialized in specific tasks, such as <b>syntax</b> <b>check</b> of queries, data classification, and visualization. The study uses multiple agents in a multi layer architecture, where each agent functions differently and assigns functions to other agent to detect and block SQL injection queries. This study describes two important agents under hybrid architecture: an agent which classifies SQL queries using a Case-Based Reasoning engine based on Legal/illegal/Suspicious. Later if query is still suspicious the query is passed to the human expert by control agents, from where query can be finally classified. The chance of the query reaching to the human expert agent in this system is very low. Thus this study is very effective and efficient to detect and block hazardous SQL injection query fired by an attacker. The system acts as a firewall between an application and database. The use of multi agents helps the cause effectively...|$|E
40|$|During {{the design}} and {{construction}} phases of building projects, domain experts iteratively exchange building information models. One of their goals {{is to ensure that}} the requirements and objectives of a proposed project are satisfied. In addition, most building information modeling software currently implements heterogeneous mapping processes in their IFC interfaces that bind their native models to the IFC format. However, such exchanges frequently do not realize intended geometric transformations, project requirements, and required syntactic and semantic conditions in building model data, exacerbating the problem of model integrity and resulting in expensive changes during the construction and operation phases. These problematic issues have been addressed by the development of solid frameworks for validating a building design. This paper surveys six currently available applications for validating building design data and identifies their strengths and weaknesses: The Express Engine&# 39;s EXPRESSO, the JDSAI (TM), the EXPRESS Data Manager (TM), the IFC server ActiveX Component, the IfcDoc, and the Solibri Model Checker (R). We also structured the validation processes into three types of tasks: I) a <b>syntax</b> <b>check</b> of the assurance of compliance with the IFC schema defined by the EXPRESS language, 2) semantic and syntactic assessment in terms of conformity to model view definitions, which consist of concept modularizations, and 3) the validation of design programming requirements that evaluates regulations, project criteria, owner requirements, and functional performance. The purpose of this survey, based on available software that supports the validation of building model data for these three types of interoperability issues, is to integrate diverse checking approaches, as a basis for improving what are now widely distributed efforts. (C) 2015 Elsevier B. V. All rights reserved...|$|E
40|$|The 3 rd {{generation}} of mobile systems is mainly focused on enabling multimedia {{services such as}} video streaming, video call and conferencing. In order to achieve this, the Universal Mobile Telecommunications System (UMTS), is the standard that has been developed by the 3 rd Generation Partnership ect (3 GPP) in Europe, including the baseline profile of H. 264 /AVC in the specification. With the union of both technologies a great improvement on video transmission over mobile networks, and even modification of the user habits towards {{the use of the}} mobile phone is expected. Nevertheless, video transmission has always been related to wired networks and unfortunately the migration to wireless networks is not as easy as it seems. In real time applications the delay is a critical constraint. Usually, transmission protocols without delivery warranties, like the User Network Protocol (UDP) for IP based networks, are used. This works under the assumption that in real time applications dropped packets are preferable to delayed packets. Moreover, in UMTS the network needs to be treated in a different way, thus the wireless channel is a prone error channel due to its high time variance. Typically, when transmitting video, the receiver checks whether the information packet is corrupted (by means of a checksum) or if its temporal mark exceeds the specified delay. This approach is suboptimal, {{due to the fact that}} perhaps the video information is not damaged and could still be used. Instead, residual redundancy on the video stream can be used to locate the errors in the corrupted packet, increasing the granularity of the typical upper-layer checksum error detection. Based on this, the amount of information previous to the error detection can be decoded as usually. The aim of this thesis is to combine some of the more effective methods concretely, <b>Syntax</b> <b>check,</b> Watermarking and Checksum schemes have been reformulated, combined and simulated...|$|E
40|$|In 1995, the Space Telescope Science Institute (STScI) {{introduced}} RPS 2 (Remote Proposal Submission 2). RPS 2 {{is used by}} Hubble Space Telescope (HST) proposers {{to prepare}} their detailed observation descriptions. It is a client/server system implemented using Tcl/Tk. The client can transparently access servers on the user's machine, at STScI, or on any other machine on the Internet. The servers combine <b>syntax</b> <b>checking,</b> feasibility analysis and orbit packing, and constraint and schedulability analysis of user-specified proposals as they will be performed aboard HST. Prior {{to the release of}} RPS 2, observers used a system which provided only <b>syntax</b> <b>checking.</b> RPS 2 now provides the observers with some of the more complicated pieces of software that had been used by STScI staff to prepare observations since 1990. The RPS 2 system consists of four independent subsystems, controlled by the client/server mechanism. A problem with a system of this size and complexity is that the software components, [...] ...|$|R
40|$|This report {{presents}} the finite state machines for the BGP decision process, and uses these finite state machines to BGP protocol <b>syntax</b> <b>checking.</b> The routing protocol syntax defines the legitimate sequence of messages {{and is used}} to reject invalid messages. If the protocol syntax is well defined, <b>syntax</b> <b>checking</b> can be very effective at detecting hardware faults, implementation bugs, and so forth. To better capture the protocol syntax, from the finite state machines we derive protocol assertions the rules that must hold true when the BGP protocol is functioning properly. This approach formalizes the protocol specification and only legitimate sequence of routing update messages are allowed by the corresponding state machine. Illegitimate message sequences resulting from implementation bugs, hardware faults can be detected by violations of the finite state machine transitions. We demonstrate that some pathological updates(false withdrawals) in the early Internet [2] would’ve been detected should one of our assertion checking had been deployed. I...|$|R
5000|$|Notepad++ is {{a source}} code editor. It {{features}} syntax highlighting, code folding and limited autocompletion for programming, scripting, and markup languages, but not intelligent code completion or <b>syntax</b> <b>checking.</b> As such it may properly highlight code written in a supported schema but whether that code is a working masterpiece or pure junk is not verifiable. As of version 4.7.2, Notepad++ can highlight the syntactic elements of: ...|$|R
40|$|Abstract. The iStarTool {{supports}} the graphical modeling of i * Framework. With {{a view to}} decrease the learning curve of i * models {{as well as to}} improve their quality, we provided the <b>syntax</b> <b>checking</b> feature. The tool allows the construction of valid models according to constraints and good practices guidelines. It is been developed using the open-source Eclipse platform and model-driven technologies, such as the Graphical Modeling Framework (GMF) ...|$|R
50|$|Support for {{alternative}} languages is often provided by plugins, {{allowing them to}} be installed on the same IDE at the same time. For example, Flycheck is a modern on-the-fly <b>syntax</b> <b>checking</b> extension for GNU Emacs 24 with support for 39 languages. Eclipse, and Netbeans have plugins for C/C++, Ada, GNAT (for example AdaGIDE), Perl, Python, Ruby, and PHP, which are selected between automatically based on file extension, environment or project settings.|$|R
500|$|David Babsky {{described}} the ZX81 as [...] "a wonderfully brainy little micro which won't let you {{waste your time}} and {{make a fool of}} yourself". In a comparison between the ZX81 and IBM PC published in Which Micro?, he commended the ZX81's user-friendliness and its on-the-fly <b>syntax</b> <b>checking</b> of BASIC programs, which he described as [...] "the feature that I, as a newcomer to computing, want to see incorporated into every micro." ...|$|R
40|$|Abstract. We propose {{extensions}} and corrections of the syntax and semantics of OMDoc {{that are}} necessary to define a formal semantics of OMDoc theory graphs. Since OMDoc theories are also OpenMath content dictionaries, this provides a module system and rudimentary <b>syntax</b> <b>checking</b> for OpenMath. Our proposal includes a new constructor for OpenMath objects that is needed {{in the context of this}} module system. Together with related work, this contribution provides a formal semantics and full type checking for OMDoc theory graphs. ...|$|R
40|$|Event Driven Process Chains (EPC) are {{commonly}} used for the modelling of business processes. As modelling is decentralised to personnel {{not familiar with the}} formal aspects of this method, <b>syntax</b> <b>checks</b> are needed to avoid invalid models. This paper presents the concept of implicit element and arc types. It can be used both to support modellers in the process of building models and to check entire models. It is especially helpful to avoid closure calculation for connector type consistency constraints...|$|R
40|$|A very {{substantial}} {{fraction of the}} time and efforts required to develop a program is devoted to the removal of errors. In order to simplify this task, a model to automatize the correction of syntax errors is developed. It is the first model which is both formal and fairly realistic to appear in the literature. The notion of error is defined and studied formally. Then, using this definition, a systematic error-correction process is modelled. This process makes local corrections over clusters of errors, using the context around the errors to determine the corrections and to insure that the different local corrections performed on the string do not interfere with one another. The error-correction process can be naturally embedded in many left-to-right <b>syntax</b> <b>checking</b> processes. It uses the recognizer both to detect errors and to find possible corrections. The process has two modes: a ``standard mode'' used for <b>syntax</b> <b>checking</b> and an ``error-correction mode'' used for determining the context of a cluster of errors and for finding all possible corrections of these errors. In the ``standard mode'', the <b>syntax</b> is <b>checked</b> at the same speed as if no error-correction mechanism is implemented. Thus, for programs which contain no errors, no price is paid for the presence of this mechanism. The ``error-correction mode'' consist of two phases: the backward move which locates the left context of the cluster, and the forward move which construct possible corrections and locates the right context of the cluster. This process seems the most natural way to perform left-to-right <b>syntax</b> <b>checking</b> and error correction. Some techniques for efficiently finding the range of the backward move are developed. The formal model is not practical when using the conventional context-free description of programming languages. In order to make it more practical, the notion of bracketed context-free language is introduced and proposed {{as a model for the}} syntax fo programming languages. Then, heuristic restrictions on the type of errors corrected are discussed. They may lead to a simpler process. In particular, assuming that brackets are corrected only when no other correction is possible, and that errors in deep levels of nesting (with respect to the point where the errors are detected) are neglected, it is shown how the process can be used to correct syntax errors in programming languages...|$|R
