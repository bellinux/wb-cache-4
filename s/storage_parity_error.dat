0|136|Public
40|$|Parity {{checking}} comprises a low-redundancy {{method for}} the design of reliable digital systems. While quite effective for detecting single-bit transmission or <b>storage</b> <b>errors,</b> <b>parity</b> encoding has not been widely used for checking the correctness of arithmetic results because parity is not preserved during arithmetic operations and parity prediction requires fairly complex circuits in most cases. We propose a general strategy for designing parity-checked arithmetic circuits that takes advantage of redundant intermediate representations. Because redundancy is often used for high performance anyway, the incremental cost of our proposed method is quite small. Unlike conventional binary numbers, redundant representations can be encoded and manipulated {{in such a way that}} parity is preserved in each step. Additionally, lack of carry propagation ensures that the effect of a fault is localized rather than catastrophic. After establishing the framework for our parity-preserving transformations in computer arithmetic, we illustrate some applications of the proposed strategy to the design of parity-checked adder/subtractors, multipliers, and other arithmetic structures used in signal processing...|$|R
5000|$|Channel data checkPoOps {{indicates}} a <b>parity</b> <b>error</b> during a data transfer.|$|R
5000|$|Memory {{consist of}} 64 Kbit 150 ns memory modules. <b>Parity</b> <b>error</b> {{protected}} setup.|$|R
5000|$|... 32 KiB {{instruction}} + 32 KiB data L1 cache per core, L1 cache includes <b>parity</b> <b>error</b> detection ...|$|R
50|$|Some {{methods are}} {{designed}} to avoid the <b>parity</b> <b>errors</b> described above. For instance, solving the corners and edges first and the centers last would avoid such <b>parity</b> <b>errors.</b> Once {{the rest of the}} cube is solved, any permutation of the center pieces can be solved. Note {{that it is possible to}} apparently exchange a pair of face centers by cycling 3 face centers, two of which are visually identical.|$|R
50|$|The PCI bus detects <b>parity</b> <b>errors,</b> {{but does}} not attempt to correct them by {{retrying}} operations; it is purely a failure indication. Due to this, {{there is no need}} to detect the <b>parity</b> <b>error</b> before it has happened, and the PCI bus actually detects it a few cycles later. During a data phase, whichever device is driving the AD31:0 lines computes even parity over them and the C/BE3:0# lines, and sends that out the PAR line one cycle later. All access rules and turnaround cycles for the AD bus apply to the PAR line, just one cycle later. The device listening on the AD bus checks the received parity and asserts the PERR# (<b>parity</b> <b>error)</b> line one cycle after that. This generally generates a processor interrupt, and the processor can search the PCI bus for the device which detected the error.|$|R
50|$|The status {{register}} indicates {{the status of}} the IRQ, DSR and DCD lines, transmitter and receiver data Registers, and overrun, framing and <b>parity</b> <b>error</b> conditions.|$|R
2500|$|The PCI bus detects <b>parity</b> <b>errors,</b> {{but does}} not attempt to correct them by {{retrying}} operations; it is purely a failure indication. [...] Due to this, {{there is no need}} to detect the <b>parity</b> <b>error</b> before it has happened, and the PCI bus actually detects it a few cycles later. [...] During a data phase, whichever device is driving the AD lines computes even parity over them and the C/BE# lines, and sends that out the PAR line one cycle later. [...] All access rules and turnaround cycles for the AD bus apply to the PAR line, just one cycle later. [...] The device listening on the AD bus checks the received parity and asserts the PERR# (<b>parity</b> <b>error)</b> line one cycle after that. [...] This generally generates a processor interrupt, and the processor can search the PCI bus for the device which detected the error.|$|R
50|$|Another similar {{approach}} to solving this cube is to first pair the edges, {{and then the}} centers. This, too, is vulnerable to the <b>parity</b> <b>errors</b> described above.|$|R
50|$|Similarly, {{the data}} bus is often {{designed}} to suit specific needs such as serial or parallel data access, {{and the memory}} may be designed to provide for <b>parity</b> <b>error</b> detection or even error correction in expensive business systems.|$|R
50|$|A <b>Parity</b> <b>Error</b> {{occurs when}} the parity {{of the number of}} 1 bits disagrees with that {{specified}} by the parity bit. Use of a parity bit is optional, so this error will only occur if parity-checking has been enabled.|$|R
2500|$|The PERR# line is {{only used}} during data phases, once a target has been selected. [...] If a <b>parity</b> <b>error</b> is {{detected}} during an address phase (or the data {{phase of a}} Special Cycle), the devices which observe it assert the SERR# (System error) line.|$|R
50|$|Intel's Pentium 4, Intel Xeon, P6 family {{processors}} {{as well as}} the Itanium architecture {{implement a}} machine check architecture that provides a mechanism for detecting and reporting hardware (machine) errors, such as: system bus <b>errors,</b> ECC <b>errors,</b> <b>parity</b> <b>errors,</b> cache errors, and translation lookaside buffer errors. It consists of a set of model-specific registers (MSRs) that are used to set up machine checking and additional banks of MSRs used for recording errors that are detected.|$|R
5000|$|System Reset sends a reset signal {{on every}} I/O channel and clears the {{processor}} state; all pending interruptions are cancelled. System Reset is not guaranteed to correct <b>parity</b> <b>errors</b> in general registers, floating point registers or storage. System Reset does not reset {{the state of}} shared I/O devices.|$|R
40|$|Large-scale {{integrated}} circuit generates and checks parity of four eight-bit registers. In addition, circuit will indicate by output signal whether <b>parity</b> <b>error</b> exists. Circuit can also generate or check parity of words up to 32 bits. This {{is done by}} making appropriate internal wiring connections on the large-scale integrated chip...|$|R
5000|$|The DS-3 M-frame uses P bits {{to check}} the line parity. The M-subframe uses C bits in a format called C-bit parity, which copies {{the result of the}} P bits at the source and checks the result at the destination. An ATM {{interface}} reports detected C-bit <b>parity</b> <b>errors</b> back to the source via a far-end block error (FEBE). ( [...] Cisco.com all rights reserved) ...|$|R
50|$|Electromechanical {{teleprinters}} {{were arranged}} to print a special character when received data contained a <b>parity</b> <b>error,</b> to allow detection of messages damaged by line noise. A single parity bit {{does not allow}} implementation of error correction on each character, and communication protocols working over serial data links will have higher-level mechanisms to ensure data validity and request retransmission of data that has been incorrectly received.|$|R
50|$|One {{strategy}} involves grouping similar edge pieces into solid strips, and centers into one-colored blocks. This {{allows the}} cube to be quickly solved {{with the same}} methods one would use for a 3×3×3 cube. Because the permutations of the corners, central edges and fixed centers have the same parity restrictions as the 3×3×3 cube, the <b>parity</b> <b>errors</b> seen on the 4×4×4 and 6×6×6 cannot occur on the 7×7×7 unless the cube has been tampered with.|$|R
50|$|A Machine Check interruptionPoOps {{occurs to}} report unusual {{conditions}} {{associated with the}} channel or CPU that cannot be reported by another class of interruption. The most important class of conditions causing a Machine Check is a hardware error such as a <b>parity</b> <b>error</b> found in registers or storage, but some models may use it to report less serious conditions. Both the interruption code and the data stored in the scanout area at '80'x (128 decimal) are model dependent.|$|R
40|$|A remote {{maintenance}} monitoring system retrofits {{to a given}} hardware device with a sensor implant which gathers and captures failure data from the hardware device, without interfering with its operation. Failure data is continuously obtained from predetermined critical points within the hardware device, and is analyzed with a diagnostic expert system, which isolates failure origin to a particular component within the hardware device. For example, monitoring of a computer-based device may include monitoring of <b>parity</b> <b>error</b> data therefrom, as well as monitoring power supply fluctuations therein, so that <b>parity</b> <b>error</b> and power supply anomaly data {{may be used to}} trace the failure origin to a particular plane or power supply within the computer-based device. A plurality of sensor implants may be rerofit to corresponding plural devices comprising a distributed large-scale system. Transparent interface of the sensors to the devices precludes operative interference with the distributed network. Retrofit capability of the sensors permits monitoring of even older devices having no built-in testing technology. Continuous real time monitoring of a distributed network of such devices, coupled with diagnostic expert system analysis thereof, permits capture and analysis of even intermittent failures, thereby facilitating maintenance of the monitored large-scale system...|$|R
50|$|The AMD K8 has a {{combined}} bimodal and global predictor, where the combining choice is another bimodal predictor. This processor caches {{the base and}} choice bimodal predictor counters in bits of the L2 cache otherwise used for ECC. As a result, it has effectively very large base and choice predictor tables, and parity rather than ECC on instructions in the L2 cache. Parity is just fine, since any instruction suffering a <b>parity</b> <b>error</b> can be invalidated and refetched from memory.|$|R
40|$|Abstract — Low voltage {{electrical}} wiring in homes {{has largely been}} dismissed as too noisy and unpredictable to support high speed communication signals. Power Line Communication (PLC) is a communication method where signals are carried across already existing power lines, rather than through other mediums such as optical fibers or radio waves. PLC {{has been a very}} important inter-discipline topic for power, communications, industrial and automation engineers and researchers since 1980 s. Designing and planning optimized or standard PLC systems require information and data regarding signal attenuations, load variations and communication performance for various locations of the world which have different power networks. In this paper, we highlight our own proprietary designed real-time communication (RTC) routing protocol based on flood transmission for the application of home automation via power line. The designed protocol also has features such as multitasking, Amplitude Shift Keying (ASK) modulation and even <b>parity</b> <b>error</b> detection. Multipoint of receiver units can be controlled (On / Off) by the main controller unit sending command data using power line as transmission medium to the corresponding devices. Analysis on protocol performance and reliability test in terms of packet drop, delay-jitter and number of loads along the line had been carried out. Keywords- Routing protocol, flood transmission, even <b>parity</b> <b>error</b> detection, Amplitude Shift Keying I...|$|R
40|$|Abstract: In {{this article}} we {{describe}} one suitable approach that enables the designer to insert a boundary-scan and built-in-self-test concepts, as typical designfor-testability techniques in system-on-chip and multichip module embedded system design, for fault-effects detection. For transient error detection implementation of <b>parity</b> <b>error</b> detection into a 36 -bit bus transceiver circuit (32 -bit data & four parity bits) is given. The bus transceiver can be implemented as custom or semi-custom integrated circuit in submicron technology and low cost FPGA or CPLD circuit, core within a system-on-a-chip, or glue logic (bridge) within the multichip module...|$|R
50|$|The SPARCstation 2 can be {{configured}} {{with up to}} 128 MB {{of memory}} in total: 64 MB on the motherboard, and an additional 64 MB using a special 32 MB SBus memory card with another 32 MB piggy-backed daughterboard. The 16 RAM slots on the motherboard can be populated with either 1 MB SIMMs {{for a total of}} 16 MB, or with 4 MB SIMMs for a total of 64 MB. Standard 30 pin SIMMs can be used as long as they use <b>parity</b> <b>error</b> detection and are rated 80 ns or faster.|$|R
50|$|People able {{to rapidly}} solve puzzles like this usually favour the {{reduction}} method of grouping similar edge pieces into solid strips, and centers into one-colored blocks. This allows the cube to be quickly solved {{with the same}} methods one would use for a 3×3×3 cube. As illustrated to the right, the fixed centers, middle edges and corners can be treated as equivalent to a 3×3×3 cube. As a result, the <b>parity</b> <b>errors</b> sometimes seen on the 4×4×4 cannot occur on the 5×5×5 unless the cube has been tampered with.|$|R
50|$|SCSI is an intelligent, peripheral, buffered, {{peer-to-peer}} interface, {{hiding the}} complexity of the physical format. Every device attaches to the SCSI bus in a similar manner. Up to 8 or 16 devices can be attached to a single bus. There can be any number of hosts and peripheral devices but there should be at least one host. SCSI uses handshake signals between devices, SCSI-1, SCSI-2 have the option of <b>parity</b> <b>error</b> checking. Starting with SCSI-U160 (part of SCSI-3) all commands and data are error checked by a CRC32 checksum.|$|R
40|$|In {{parallel}} communication {{the cost}} {{as well as}} complexity of the system increases due to simultaneous transmission of data bits on multiple wires. Serial communication alleviates this drawback and emerges as effective candidate in many applications for long distance communication as it reduces the signal distortion because of its simple structure. This paper focuses on the VHDL implementation of UART with status register which supports asynchronous serial communication. The paper presents the architecture of UART which indicates, during reception of data, <b>parity</b> <b>error,</b> framing error, overrun error and break error using status register. The whole design is functionally verified using Xilinx ISE Simulator...|$|R
50|$|In the {{original}} IBM PC, an NMI was triggered if a <b>parity</b> <b>error</b> was detected in system memory, or reported by an external device. In either case, the PC would display an error message and halt. Some later PC clones used an NMI {{to conceal the}} hardware differences {{from that of a}} standard PC. On such computers, an NMI would be generated when a program attempted to access incompatible hardware. A BIOS interrupt handler would then translate the program's request to match the hardware that was actually present. The SMM in the 386SL is a better way to do this.|$|R
50|$|The {{diagnostic}} microcomputer (based {{around the}} Zilog Z80) was embedded within the CPU. Its functions included running a system confidence check when power is first applied, bootstrapping the CPU, and taking control should an unrecoverable control store <b>parity</b> <b>error</b> be detected. It {{could also be}} used to load new microcode dynamically whilst the machine was running. An RS-232C interface was provided to which a terminal could be attached. Extensive diagnostics could then be run in conjunction with special microcode to perform fault analysis {{in the event of a}} system failure. Problems could usually be isolated to one or two integrated circuits.|$|R
40|$|Energy-parity {{objectives}} combine ω-regular with quantitative {{objectives of}} reward MDPs. The controller needs to avoid {{to run out}} of energy while satisfying a parity objective. We refute the common belief that, if an energy-parity objective holds almost-surely, then this can be realised by some finite memory strategy. We provide a surprisingly simple counterexample that only uses coBüchi conditions. We introduce the new class of bounded (energy) storage objectives that, when combined with parity objectives, preserve the finite memory property. Based on these, we show that almost-sure and limit-sure energy-parity objectives, as well as almost-sure and limit-sure <b>storage</b> <b>parity</b> objectives, are in NP∩coNP and can be solved in pseudo-polynomial time for energy-parity MDPs...|$|R
25|$|One {{major feature}} that distinguishes ZFS from other file systems {{is that it}} is {{designed}} with a focus on data integrity by protecting the user's data on disk against silent data corruption caused by data degradation, current spikes, bugs in disk firmware, phantom writes (the previous write did not make it to disk), misdirected reads/writes (the disk accesses the wrong block), DMA <b>parity</b> <b>errors</b> between the array and server memory or from the driver (since the checksum validates data inside the array), driver errors (data winds up in the wrong buffer inside the kernel), accidental overwrites (such as swapping to a live file system), etc.|$|R
40|$|An early {{experience}} of camp laparoscopic sterilization in Gujarat State, India, resulted in 22 deaths among 106, 500 women undergoing the operation during 1979 and 1980. Increased {{risk of death}} was seen when larger numbers of procedures were performed by year or month of year. The least experienced surgeons had the highest case-fatality rate. Improvised settings (i. e., school buildings) exacerbated the risk of death, as did advanced age, and, to a lesser extent, high <b>parity.</b> <b>Errors</b> in clinical judgment were identified in some fatal procedures. A system of health audit of large sterilization programs is needed. Key words: sterilization deaths, laparoscopic sterilization, camp sterilizatio...|$|R
50|$|One {{major feature}} that distinguishes ZFS from other file systems {{is that it}} is {{designed}} with a focus on data integrity by protecting the user's data on disk against silent data corruption caused by data degradation, current spikes, bugs in disk firmware, phantom writes (the previous write did not make it to disk), misdirected reads/writes (the disk accesses the wrong block), DMA <b>parity</b> <b>errors</b> between the array and server memory or from the driver (since the checksum validates data inside the array), driver errors (data winds up in the wrong buffer inside the kernel), accidental overwrites (such as swapping to a live file system), etc.|$|R
50|$|If an {{odd number}} of bits (including the parity bit) are {{transmitted}} incorrectly, the parity bit will be incorrect, thus indicating that a <b>parity</b> <b>error</b> occurred in the transmission. The parity bit is only suitable for detecting errors; it cannot correct any errors, {{as there is no}} way to determine which particular bit is corrupted. The data must be discarded entirely, and re-transmitted from scratch. On a noisy transmission medium, successful transmission can therefore take a long time, or even never occur. However, parity has the advantage that it uses only a single bit and requires only a number of XOR gates to generate. See Hamming code for an example of an error-correcting code.|$|R
50|$|Simple go/no go parity {{checking}} {{requires that the}} memory have extra, redundant bits beyond those needed to store the data; but if extra bits are available, {{they can be used}} to correct, as well as detect, errors. Earlier memory as used in, for example, the IBM PC/AT (FPM and EDO memory) were available in versions that supported either no checking or {{parity checking}} (in earlier computers that used individual RAM chips rather than DIMM or SIMM modules, extra chips were used to store parity bits); if the computer detected a <b>parity</b> <b>error</b> it would display a message to that effect and stop. The SDRAM and DDR modules that replaced the earlier types are usually available either without error-checking or with ECC (full correction, not just parity).|$|R
50|$|There are {{a number}} of methods {{that can be used to}} solve a V-Cube 6. One method is to first group the center pieces of common colors together, then to match up edges that show the same two colors. Once this is done, turning only the outer layers of the cube allows it to be solved like a 3×3×3 cube. However, certain {{positions}} that cannot be solved on a standard 3×3×3 cube may be reached. For instance, a single quartet of edges may be inverted, or the cube may appear to have an odd permutation (that is, two pieces must be swapped, which is not possible on the 3×3×3 cube). These situations are known as <b>parity</b> <b>errors,</b> and require special algorithms to be solved.|$|R
