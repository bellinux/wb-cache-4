84|16|Public
5000|$|... // disable {{color and}} depth buffers glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE); glDepthMask(GL_FALSE); glStencilFunc(GL_NEVER, 1, 0xFF); // never pass stencil test glStencilOp(GL_REPLACE, GL_KEEP, GL_KEEP); // replace <b>stencil</b> <b>buffer</b> values to ref=1 glStencilMask(0xFF); // <b>stencil</b> <b>buffer</b> free to write glClear(GL_STENCIL_BUFFER_BIT); // first clear <b>stencil</b> <b>buffer</b> by writing default stencil value (0) {{to all of}} <b>stencil</b> <b>buffer.</b> draw_stencil_shape (...) // at stencil shape pixel {{locations}} in <b>stencil</b> <b>buffer</b> replace <b>stencil</b> <b>buffer</b> values to ref = 1 ...|$|E
50|$|In the {{simplest}} case, the <b>stencil</b> <b>buffer</b> {{is used to}} limit the area of rendering (stenciling). More advanced usage of the <b>stencil</b> <b>buffer</b> makes use of the strong connection between the depth buffer and the <b>stencil</b> <b>buffer</b> in the rendering pipeline. For example, stencil values can be automatically increased/decreased for every pixel that fails or passes the depth test.|$|E
50|$|Typically <b>Stencil</b> <b>buffer</b> is {{initialized}} {{by setting}} depth buffer and color buffer masks to false. and then setting appropriate ref value to <b>stencil</b> <b>buffer</b> by failing the stencil test every time.|$|E
50|$|The depth fail {{method has}} the same {{considerations}} regarding the <b>stencil</b> <b>buffer's</b> precision as the depth pass method. Also, similar to depth pass, it is {{sometimes referred to as}} the z-fail method.|$|R
5000|$|On November 16, 2011, Carmack {{announced}} on Twitter that he's writing new code for Doom 3's open source release, because [...] "lawyers are still skittish about the patent issue around 'Carmack's reverse'". This {{refers to an}} implementation of <b>stencil</b> <b>buffered</b> shadow volume algorithms.|$|R
5000|$|In DRI2, {{instead of}} a single shared (back) buffer, every DRI client gets its own private back buffer [...] - along with their {{associated}} depth and <b>stencil</b> <b>buffers</b> - [...] to render its window content using the hardware acceleration. The DRI client then swaps it with a false [...] "front buffer", which {{is used by the}} compositing window manager as one of the sources to compose (build) the final screen back buffer to be swapped at the VBLANK interval with the real front buffer.|$|R
5000|$|<b>Stencil</b> <b>buffer</b> {{typically}} {{share the}} same memory space with a depth buffer ( [...] Eng. Depth Buffer, the Z-buffer), and typically the ratio is 24 bits in depth + 8 bits for <b>stencil</b> <b>buffer</b> or, heretofore often used, 15 bits for the depth + 1 bit for <b>stencil</b> <b>buffer.</b> Is also present in variant 4 + 24, where 28 of the 32 bits is used, and 4 ignored. Stencil and depth buffers {{are part of the}} frame buffer ( [...] Eng. Frame Buffer), coupled to the buffer for the color (Color Buffer). The first chip available to a wider market, which supported one bit <b>stencil</b> <b>buffer,</b> was 3Dlab's Permedia II.|$|E
5000|$|Line and edge anti-aliasing, bump mapping, 8-bit <b>stencil</b> <b>buffer</b> ...|$|E
5000|$|Depth buffer, <b>Stencil</b> <b>buffer,</b> for {{different}} parts of image information ...|$|E
40|$|In {{this paper}} we {{describe}} a real-time shadow generation with volume shadow algorithm in virtual {{environment that is}} illuminated by light sources with possibility to move separately. This algorithm uses the combination of stencil and Z-buffers to generate shadow volume. It is simple to understand and implement. We have significantly improved and implemented recent techniques {{that are used in}} shadow volume algorithms using <b>stencil</b> <b>buffers</b> especially in order to recognize silhouette, reduce the number of shadow polygons and also redundant length of each triangles that makes the volume shadow. This work may be applied in commercial games or other virtual reality systems...|$|R
50|$|DirectX 6.0 (released in August, 1998) {{introduced}} numerous {{features to}} cover contemporary hardware (such as multitexture and <b>stencil</b> <b>buffers)</b> {{as well as}} optimized geometry pipelines for x87, SSE and 3DNow! and optional texture management to simplify programming. Direct3D 6.0 also included support for features that had been licensed by Microsoft from specific hardware vendors {{for inclusion in the}} API, in exchange for the time-to-market advantage to the licensing vendor. S3 texture compression support was one such feature, renamed as DXTC for purposes of inclusion in the API. Another was TriTech's proprietary bump mapping technique. Microsoft included these features in DirectX, then added them to the requirements needed for drivers to get a Windows logo to encourage broad adoption of the features in other vendors' hardware.|$|R
50|$|Configuration {{of these}} {{surfaces}} is done through a pixel format selection process where different compatible layers of rendering information are combined {{to form a}} framebuffer. Examples of such layers are color buffers, transparency <b>buffers</b> (alpha), <b>stencil</b> <b>buffers,</b> and depth buffers. The CGL function CGLChoosePixelFormat is used to perform this buffer compatibility check. CGLChoosePixelFormat will, based on input parameters and their scoring policy, choose a pixel format that represents a compatible buffer configuration that {{is supported by the}} underlying renderer that will be used to process graphics commands. Renderers may be either hardware based, such that they correspond to graphics cards installed in the system or they may be software based, where the main CPU of the system handles all of the graphics command processing and final rasterization work.|$|R
5000|$|... #Caption: In {{this program}} the <b>stencil</b> <b>buffer</b> {{is filled with}} 1s {{wherever}} a white stripe is drawn and 0s elsewhere. Two versions of each oval, square, or triangle are then drawn. A black colored shape is drawn where the <b>stencil</b> <b>buffer</b> is 1, and a white shape is drawn where the buffer is 0.|$|E
50|$|You {{can also}} use <b>stencil</b> <b>buffer</b> like with the shadow volume technique.|$|E
50|$|A {{solution}} that includes <b>stencil</b> <b>buffer</b> {{is based on}} the knowledge that a polygon to be in front of which it stands. After this, the silhouette of the front polygons drawn into the <b>stencil</b> <b>buffer.</b> After that, the last polygon line only where the silhouette is not charted, {{and the rest of the}} scene can be deleted normally.|$|E
40|$|We {{propose a}} hardware-assisted {{visibility}} ordering algorithm. From a given viewpoint, a (back-to-front) visibility ordering {{of a set}} of objects is a partial order on the objects such that if object obstructs object, then precedes in the ordering. Such orderings are useful because they are the building blocks of other rendering algorithms such as direct volume rendering of unstructured grids. The traditional way to compute the visibility order is to build a set of visibility relations (e. g.,), and then run a topological sort on the set of relations to actually get the partial ordering. Our technique instead works by assigning a layer number to each primitive, which directly determines the visibility ordering. Objects that have the same layer number are independent, and can be placed anywhere with respect to each other. We use a simple technique which exploits a combination of the z- and <b>stencil</b> <b>buffers</b> to compute the layer number of each primitive [...] ...|$|R
40|$|This paper {{describes}} a real-time shadow generation algorithm for polygonal environments illuminated by movable point light sources. The main {{goal is to}} quickly {{reduce the number of}} hidden shadow volumes, by using a technique of volumetric shadow rendering using <b>stencil</b> <b>buffers</b> with a modified BSP tree, i. e. a simplified version of a SVBSP (Shadow Volume BSP) tree. It also provides new easy-to-implement approaches to improvement techniques used in shadow volume algorithms, such as silhouette detection {{to reduce the number of}} redundant shadow polygons and the computation of capping polygons to handle cases where the shadow volumes are clipped by the eye-view near clipping plane. Such hybrid approach solves important limitations on the original shadow rendering algorithm, as well as achieves real-time frame rates when using modest size scenes (about 500 shadow polygons), according to measurements performed on personal computers using current graphics hardware. Per-phase timing results from the implementation are provided along the text and compared with those of the standard algorithm...|$|R
50|$|Dwight D. Eisenhower had a {{non-standard}} red {{background to}} the nameplate c. 1958. During its time allocated to Grantham motive power depot, {{the name of}} the depot was <b>stencilled</b> on the <b>buffer</b> beam.|$|R
50|$|A <b>stencil</b> <b>buffer</b> is {{an extra}} buffer, in {{addition}} to the color buffer and depth buffer (z-buffering) found on modern graphics hardware. The buffer is per pixel, and works on integer values, usually with a depth of one byte per pixel. The depth buffer and <b>stencil</b> <b>buffer</b> often share the same area in the RAM of the graphics hardware.|$|E
5000|$|... glEnable(GL_STENCIL_TEST); // {{by default}} not enabledglStencilMask(stencilMask); // allow writing to <b>stencil</b> <b>buffer,</b> by default (0xFF) no mask.glClearStencil(clearStencilValue); // clear stencil value, by default = 0glStencilFunc(func, ref, mask); // by default GL_ALWAYS, 0, 0xFF, always pass stencil testglStencilOp(fail,zfail,zpass); // by default GL_KEEP, GL_KEEP, GL_KEEP, {{do not change}} stencil bufferglClear(GL_STENCIL_BUFFER_BIT); // clear <b>stencil</b> <b>buffer,</b> fill with (clearStencilValue & stencilMask) ...|$|E
5000|$|Each {{of these}} {{passages}} implies that a clean <b>stencil</b> <b>buffer</b> can be used.|$|E
40|$|Various {{techniques}} {{can be used}} to improve real-time 3 D graphics. Two general parts are present, visual appeal and performance. Different techniques are used to improve these two elements of computer graphics, some of which are discussed in-depth in this thesis. Shadow volumes with <b>stencil</b> <b>buffers</b> {{is one of the leading}} techniques used today when it comes to realistic shadows for real-time 3 D applications. This approach to shadowing is one of the primary topics of this thesis. The second topic focused upon is octrees using portals, which is an approach to improve performance in real-time 3 D rendering. Bump mapping is also discussed. Some other 3 D concepts are also touched upon, mainly to highlight the advantages of the previously mentioned techniques and also to illustrate why they were chosen instead of other available options. The goal of this thesis is to improve upon a 3 D graphics engine to create a more visually pleasing world. Both visual appeal and performance enhancing elements are used to create a dynamically lit environment. Validerat; 20101217 (root...|$|R
40|$|Abstract. We {{propose a}} hardware-assisted {{visibility}} ordering algorithm. From a given viewpoint, a (back-to-front) visibility ordering {{of a set}} of objects is a partial order on the objects such that if object ¢ obstructs object £, then £ precedes ¢ in the ordering. Such orderings are useful because they are the building blocks of other rendering algorithms such as direct volume rendering of unstructured grids. The traditional way to compute the visibility order is to build a set of visibility relations (e. g., £¥¤§¦¨ ¢), and then run a topological sort on the set of relations to actually get the partial ordering. Our technique instead works by assigning a layer number to each primitive, which directly determines the visibility ordering. Objects that have the same layer number are independent, and have no obstruction between each other. We use a simple technique which exploits a combination of the z- and <b>stencil</b> <b>buffers</b> to compute the layer number of each primitive. One application of our technique is to obtain a fast unstructured volume rendering algorithm. In this paper, we present our technique and its implementation in OpenGL. We also discuss its performance and some optimizations on some recent graphics hardware architectures. ...|$|R
40|$|Digital Equipment Corporation High-performance 3 D {{graphics}} accelerators traditionally re-quire multiple {{chips on}} multiple boards, including geometry, rasterizing, pixel processing, and texture mapping chips. These designs are often scalable: they can increase performance by using more chips. Scalability has obvious costs: a minimal configura-tion needs several chips, and some configurations must replicate texture maps. A less obvious cost is the almost irresistible temp-tation to replicate chips to increase performance, {{rather than to}} design individual chips for higher performance in the first place. In contrast, Neon is a single chip that performs like a multi-chip design. Neon accelerates OpenGL [191 3 D rendering, as well as Xl 1 1201 and Windows/NT 2 D rendering. Since our pin budget limited peak memory bandwidth, we designed Neon from the memory system upward {{in order to reduce}} bandwidth re-quirements. Neon has no special-purpose memories; its eight independent 32 -bit memory controllers can access color buffers, 1. depth <b>buffers,</b> <b>stencil</b> <b>buffers,</b> and texture data. To fit our gate budget, we shared logic among different operations with similar implementation requirements, and left floating point calculations to Digital’s Alpha CPUs. Neon’s performance is between HP’s Visualize fx 4 and fx 6, and is well above SGI’s MXE for most operations. Neon-based boards cost much less than these com-petitors, due to a small part count and use of commodit...|$|R
5000|$|Is more {{flexible}} {{because all of}} depth buffer, <b>stencil</b> <b>buffer,</b> etc. can be acquired.|$|E
5000|$|Reflection of a {{scene is}} drawn as her {{reflection}} {{in relation to a}} given plane , which determines the slope at which reflection should reflect on. Part of the problem concerning the <b>stencil</b> <b>buffer</b> restrict the display of the reflected scene only on the ground that. achieve the illusion that the scene only a reflection on it reflects. <b>Stencil</b> <b>buffer</b> that provides as follows: 1. The scene draws no areas that are mirror. For each mirror: 1. Locks the depth buffer and color buffer 2. The <b>stencil</b> <b>buffer</b> is plotted visible part of the mirror 3. Depth test is set up so that each pixel is passed to enter the maximum value and always passes 4. Renders the surface of a mirror 5. Depth test is set so that it passes only if the distance of a pixel is less than the current (default behavior) 6. The matrix transformation be changed to reflect the scene to the plane mirror 7. Unlock the depth buffer and color buffer 8. The scene is drawn, but also to draw only part of it that lies behind the plane of the mirror and is visible in the mirror. For the first constraint is added to a limiting plane ( [...] Eng. Clip plane), and other limitations used <b>stencil</b> <b>buffer</b> content 9. Again locks color buffer, depth test is set so that it always passes, and the pixels mirrors are deleted from the <b>stencil</b> <b>buffer</b> so that it is again traced. After this, the <b>stencil</b> <b>buffer</b> again clean and ready for the next mirror.|$|E
5000|$|Although {{the range}} of <b>stencil</b> <b>buffer</b> {{applications}} is rather wide, we can mention several well-known applications.|$|E
50|$|Other {{architectural}} changes include {{improvements to}} anti-aliasing functionality. Previous GeForce chips could perform only super-sampled anti-aliasing (SSAA), a demanding process that renders the image {{at a large}} size internally and then scales {{it down to the}} end output resolution. GeForce 3 adds multi-sampling anti-aliasing (MSAA) and Quincunx anti-aliasing methods, both of which perform significantly better than super-sampling anti-aliasing at the expense of quality. With multi-sampling, the render output units super-sample only the Z <b>buffers</b> and <b>stencil</b> <b>buffers,</b> and using that information get greater geometry detail needed to determine if a pixel covers more than one polygonal object. This saves the pixel/fragment shader from having to render multiple fragments for pixels where the same object covers all of the same sub-pixels in a pixel. This method fails with texture maps which have varying transparency (e.g. a texture map that represents a chain link fence). Quincunx anti-aliasing is a blur filter that shifts the rendered image a half-pixel up and a half-pixel left in order to create sub-pixels which are then averaged together in a diagonal cross pattern, destroying both jagged edges but also some overall image detail. Finally, the GeForce 3's texture sampling units were upgraded to support 8-tap anisotropic filtering, compared to the previous limit of 2-tap with GeForce 2. With 8-tap anisotropic filtering enabled, distant textures can be noticeably sharper.|$|R
40|$|Silicon Graphics, and Conix Enterprises for the {{hardware}} and software support that enabled me to write my OpenGL textbook. Page 14 CONCLUSION With over 200 functions in the API, we have only scratched the surface {{of what we can}} do with OpenGL. The major omission in these two articles is how we can define various types of curves and surfaces. Nevertheless, you should have a fair idea of the range of functionality supported by the OpenGL architecture. In the future, the CAD and animation communities will not only use OpenGL as their standard API but also start making use of features particular to OpenGL, such as the accumulation and <b>stencil</b> <b>buffers.</b> The advantages of OpenGL are many. It is close to {{the hardware}} but still easy to use to write application programs. It is portable and supports a wide variety of features. It is the only graphics API that I have seen in my 15 years in the field that is used by animators, game developers, CAD engineers and researchers on supercomputers. Personally, I routinely use OpenGL on a PowerMac 6100, a PowerBook, an SGI Infinite Reality Engine and a variety of PCs, rarely having to change my code moving among these systems. There is not much more that can I ask of an API. SOURCES AND URLS OpenGL is administered through an Architectural Review Board. The two major sources for on-line information on OpenGL are the OpenGL organization (www. opengl. org) and Silicon Graphics Inc (www. sgi. com/Technology/OpenGL). You can find pointers to code, FAQ, standards documents and literature at these sites. I keep the sample code from my book a...|$|R
40|$|In {{this article}} authors provide outline and formal {{description}} of visual techniques that support analysis and extraction of patterns from information encoded in spatial graphs. Both known methods (such as transparency, magnification, etc.) are being presented and {{offered by the}} authors for the enhanced analysis (such as projective shadows, illumination distance, gradient stenciling, etc.). The goal {{of this research is}} to assist in graph data visualization and mining tasks by providing a set of supplementary techniques for effective information comprehension and analysis. Components of computer graphics framework required for each type of technique (for example – support of shaders, presence of <b>stencil</b> and depth <b>buffers,</b> etc.) are being listed. The result of this analysis is presented in tabular form, comparing fitness of identified techniques against different three-dimensional graph layout algorithms, semantic data domains and desired analysis processes. This allows to identify main requirements for computer graphics framework being used for data visualization as a part of particular graph visualization software system technical specification. Conclusion about achieved results is made. Information about potential future researches in this field is presented...|$|R
50|$|The <b>stencil</b> <b>buffer</b> and its {{modifiers}} can {{be accessed}} in computer graphics APIs like OpenGL and Direct3D.|$|E
5000|$|Now use the {{initialized}} <b>stencil</b> <b>buffer</b> and stencil test {{to write}} {{only in the}} locations where stencil value is 1 ...|$|E
5000|$|Frank Crow {{published}} a paper describing {{the theory of}} shadow volumes in 1977. [...] This technique uses the <b>stencil</b> <b>buffer</b> to specify areas of the screen that correspond to surfaces that lie in a [...] "shadow volume", or a shape representing a volume of space eclipsed from a light source by some object. These shadowed areas are typically shaded after the scene is rendered to buffers by storing shadowed areas with the <b>stencil</b> <b>buffer.</b>|$|E
5000|$|The eighty Image Engines have {{multiple}} functions. Firstly, each Image Engine controls {{a portion of}} the raster memory, which {{in the case of the}} InfiniteReality, is a 1 MB SGRAM organized as 262,144 by 32-bit words. Secondly, the following OpenGL per-fragment operations are performed by the Image Engines: pixel ownership test, <b>stencil</b> test, depth <b>buffer</b> test, blending, dithering and logical operation. Lastly, the Image Engines perform anti-aliasing and accumulation buffer operations. To deliver pixel data for display, each Image Engine has a 2-bit serial bus to the Display Generator board. If one Raster Manager board is present in the pipeline, the Image Engine uses the entire width of the bus, whereas if two or more Raster Manager boards are present, the Image Engine uses half the bus. Each serial bus is actually a part of the Video Bus, which has a bandwidth of 1.2 GB/s. Four Image Engine [...] "cores" [...] are contained on an Image Engine ASIC, which contains nearly 488,000 logic gates, comprising 1.95 million transistors, on a 42 mm2 (6.5 by 6.5 mm) die that was fabricated in a 0.35 micrometre process by VLSI Technology.|$|R
5000|$|Using {{the depth}} {{information}} from that scene, construct a mask in the <b>stencil</b> <b>buffer</b> that has holes only where the visible surface {{is not in}} shadow.|$|E
5000|$|Render {{the scene}} again {{as if it}} were {{completely}} lit, using the <b>stencil</b> <b>buffer</b> to mask the shadowed areas. Use additive blending to add this render to the scene.|$|E
