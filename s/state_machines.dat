3735|4877|Public
25|$|The Unified Modeling Language has a {{notation}} {{for describing}} <b>state</b> <b>machines.</b> UML <b>state</b> <b>machines</b> overcome {{the limitations of}} traditional finite <b>state</b> <b>machines</b> while retaining their main benefits. UML <b>state</b> <b>machines</b> introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML <b>state</b> <b>machines</b> have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both {{the state of the}} system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.|$|E
25|$|In {{addition}} to their use in modeling reactive systems presented here, finite <b>state</b> <b>machines</b> are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, and logic. Finite <b>state</b> <b>machines</b> are a class of automata studied in automata theory and the theory of computation.|$|E
25|$|Additional {{circuits}} called fractional-n {{phase lock}} loops (frac-N PLLs) multiply the resonator’s mechanical frequencies to the oscillator’s output frequencies. These highly specialized PLLs set the output frequencies under control of digital <b>state</b> <b>machines.</b> The <b>state</b> <b>machines</b> {{are controlled by}} calibration and program data stored in non-volatile memory and adjust the PLL configurations to compensate for temperature variations.|$|E
50|$|Because the {{internal}} {{structure of a}} composite state can be arbitrarily complex, any hierarchical <b>state</b> <b>machine</b> {{can be viewed as}} an internal structure of some (higher-level) composite state. It is conceptually convenient to define one composite state as the ultimate root of <b>state</b> <b>machine</b> hierarchy. In the UML specification, every <b>state</b> <b>machine</b> has a top state (the abstract root of every <b>state</b> <b>machine</b> hierarchy), which contains all the other elements of the entire <b>state</b> <b>machine.</b> The graphical rendering of this all-enclosing top state is optional.|$|R
2500|$|A {{deterministic}} finite <b>state</b> <b>machine</b> or acceptor deterministic finite <b>state</b> <b>machine</b> is a quintuple , where: ...|$|R
40|$|In {{this paper}} we {{introduced}} {{the concept of}} interval neutrosophic finite <b>state</b> <b>machine,</b> interval neutrosophic finite switchboard <b>state</b> <b>machine</b> using the notion of interval neutrosophic set. We also introduced the concept of homomorphism and strong homomorphism of interval neutrosophic finite <b>state</b> <b>machine...</b>|$|R
25|$|Finite <b>state</b> <b>machines</b> can be {{subdivided}} into transducers, acceptors, classifiers and sequencers.|$|E
25|$|Through state {{encoding}} for {{low power}} <b>state</b> <b>machines</b> may be optimized to minimize power consumption.|$|E
25|$|In {{computer}} science, directed graphs {{are used}} to represent knowledge (e.g., conceptual graph), finite <b>state</b> <b>machines,</b> and many other discrete structures.|$|E
50|$|The <b>state</b> <b>machine</b> {{actually}} {{controls the}} behavior of the organism. Since it is a feed forward <b>state</b> <b>machine,</b> the machine responds to future events predicted from past data.|$|R
5000|$|As the RASP <b>machine's</b> <b>state</b> <b>machine</b> {{interprets the}} program in the registers, what exactly will the <b>state</b> <b>machine</b> be doing? The column {{containing}} the exclamation mark ! will list in time sequence the <b>state</b> <b>machine's</b> actions as it [...] "interprets" [...] converts to action [...] the program: ...|$|R
50|$|Using a one-hot {{implementation}} typically {{allows a}} <b>state</b> <b>machine</b> {{to run at}} a faster clock rate than any other encoding of that <b>state</b> <b>machine.</b>|$|R
25|$|The <b>state</b> <b>machines</b> {{can also}} be built to provide {{additional}} user functions, for instance spread-spectrum clocking and voltage controlled frequency trimming.|$|E
25|$|Finite automata {{are often}} used in the {{frontend}} of programming language compilers. Such a frontend may comprise several finite <b>state</b> <b>machines</b> that implement a lexical analyzer and a parser.|$|E
25|$|In {{computer}} science, finite <b>state</b> <b>machines</b> {{are widely}} used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, {{and the study of}} computation and languages.|$|E
40|$|Aspects are {{separate}} code modules {{that can be}} bound (“woven”) to a base program at joinpoints to provide an augmented program. A novel approach is defined to verify that an aspect <b>state</b> <b>machine</b> will provide desired properties whenever it is woven over a base <b>state</b> <b>machine</b> that satisfies the assumptions of the aspect. A single <b>state</b> <b>machine</b> is constructed using the tableau of the linear temporal logic (LTL) description of the assumptions, {{a description of the}} joinpoints, and the <b>state</b> <b>machine</b> of the aspect code. A theorem is shown that if the constructed machine satisfies the desired properties, so will an augmented <b>state</b> <b>machine</b> using any base machine that satisfies the assumptions. The theorem is stated and shown for assumptions and properties given in LTL, for a somewhat restricted form of joinpoint description, and for aspect code that ends in states already reachable in the base <b>state</b> <b>machine.</b> A language-based description of aspects, as in AspectJ, can be converted to a <b>state</b> <b>machine</b> version using existing tools, thus providing generic modular verification of code-level aspects...|$|R
50|$|One-hot {{encoding}} {{is often}} used for indicating the state of a <b>state</b> <b>machine.</b> When using binary or Gray code, a decoder {{is needed to determine}} the state. A one-hot <b>state</b> <b>machine,</b> however, does not need a decoder as the <b>state</b> <b>machine</b> is in the nth state if and only if the nth bit is high.|$|R
30|$|The railway {{characteristics}} {{indicate that}} a cell’s status is related to neighboring cells, and the finite <b>state</b> <b>machine</b> model is a powerful method for dealing with cell status transitions. The mealy-type <b>state</b> <b>machine</b> [23], a type of Finite <b>state</b> <b>machine,</b> {{is based on the}} present <b>state</b> of the <b>machine,</b> and the input conditions, and can effectively lead to a {{reduction in the number of}} states.|$|R
25|$|As {{a general}} rule, data-path {{sections}} benefit most from floorplanning, whereas random logic, <b>state</b> <b>machines,</b> and other non-structured logic can safely {{be left to}} the placer section of the place and route software.|$|E
25|$|The {{behavior}} of <b>state</b> <b>machines</b> {{can be observed}} in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.|$|E
25|$|Upon {{agreement}} {{of a system}} design, RTL designers then implement the functional models in a hardware description language like Verilog, SystemVerilog, or VHDL. Using digital design components like adders, shifters, and <b>state</b> <b>machines</b> as well as computer architecture concepts like pipelining, superscalar execution, and branch prediction, RTL designers will break a functional description into hardware models of components on the chip working together. Each of the simple statements described in the system design can easily turn into thousands of lines of RTL code, {{which is why it}} is extremely difficult to verify that the RTL will do the right thing in all the possible cases that the user may throw at it.|$|E
5000|$|The term <b>state</b> <b>machine</b> {{replication}} {{was first}} suggested by Leslie Lamport [...] and was widely adopted after {{publication of a}} survey paper written by Fred B. Schneider. The model covers any system in which some deterministic object (a <b>state</b> <b>machine)</b> is replicated {{in such a way}} that a series of commands can be applied to the replicas fault-tolerantly. A reconfigurable <b>state</b> <b>machine</b> is one that can vary its membership, adding new members or removing old ones. [...] Some <b>state</b> <b>machine</b> protocols can also ride out the temporary unavailability of a subset of the current members without requiring reconfiguration when such situations arise, including Gbcast and also Paxos, Lamport’s widely cited protocol for <b>state</b> <b>machine</b> replication.|$|R
50|$|Clocking {{changes on}} TMS steps through a {{standardized}} JTAG <b>state</b> <b>machine.</b> The JTAG <b>state</b> <b>machine</b> can reset, access an instruction register, or access data {{selected by the}} instruction register.|$|R
5000|$|<b>State</b> <b>Machine</b> Safety: if {{a server}} has applied a {{particular}} log entry to its <b>state</b> <b>machine,</b> then no other server may apply a different command {{for the same}} log.|$|R
25|$|Monoids are {{studied in}} semigroup theory, {{because they are}} semigroups with identity. Monoids occur in several {{branches}} of mathematics; for instance, they {{can be regarded as}} categories with a single object. Thus, they capture the idea of function composition within a set. In fact, all functions from a set into itself form naturally a monoid with respect to function composition. Monoids are also commonly used in computer science, both in its foundational aspects and in practical programming. The set of strings built from a given set of characters is a free monoid. The transition monoid and syntactic monoid are used in describing finite <b>state</b> <b>machines,</b> whereas trace monoids and history monoids provide a foundation for process calculi and concurrent computing. Some of the more important results in the study of monoids are the Krohn–Rhodes theorem and the star height problem. The history of monoids, as well as a discussion of additional general properties, are found in the article on semigroups.|$|E
2500|$|There {{are other}} sets of {{semantics}} available to represent <b>state</b> <b>machines.</b> [...] For example, there are tools for modeling and designing logic for embedded controllers. They combine hierarchical <b>state</b> <b>machines</b> (which usually {{have more than}} one current state), flow graphs, and truth tables into one language, resulting in a different formalism and set of semantics. [...] These charts, like Harel's original <b>state</b> <b>machines,</b> support hierarchically nested states, orthogonal regions, state actions, and transition actions.|$|E
2500|$|State diagrams, {{graphical}} {{representations of}} finite <b>state</b> <b>machines</b> ...|$|E
5000|$|These {{messages}} {{control a}} <b>state</b> <b>machine</b> {{related to each}} session (for example, this <b>state</b> <b>machine</b> forbids any MIDI data exchange until a session reaches the [...] "opened" [...] state) ...|$|R
40|$|Abstract. A {{parallel}} checking {{method is}} {{proposed in the}} paper, {{in order to improve}} the speed of sequential circuit checking. The graph form of sequential circuits is isomorphic to finite state machine; a parallel sequential circuit equivalence checking method is designed using parallel minimization method of finite <b>state</b> <b>machine.</b> At last, the effectiveness and feasibility of the method is proved with an instance. The definition of sequential equivalence Sequential circuit is a sort of finite <b>state</b> <b>machine</b> [1, 2]. Finite <b>state</b> <b>machine</b> is a nonobjective model, which can be used to describe operation characteristic about system’s input and output. Finite <b>state</b> <b>machine</b> has two forms of Mealy and Moore, describing sequential circuit with Mealy <b>state</b> <b>machine.</b> Mealy <b>state</b> <b>machine</b> is described as follow: M = (S, r, Y,δ, S 0) S: finite non empty set of state S 0, S 1,, S n⋯ r: finite non empty set of input symbol. Y: output alphabet...|$|R
5000|$|The {{transcoder}} {{equipment that}} supports TFO runs a well defined <b>state</b> <b>machine.</b> Based on {{the sequence of}} events, the <b>state</b> <b>machine</b> table defines a sequence of actions to be performed.|$|R
2500|$|... {{comparing}} theoretical {{aspects of}} Mealy, Moore, Harel & UML <b>state</b> <b>machines.</b>|$|E
2500|$|Askemos [...] is a concurrent, garbage-collected, {{persistent}} programming platform atop of replicated <b>state</b> <b>machines</b> which tolerates Byzantine faults. It prototypes {{an execution}} environment facilitating Smart contracts.|$|E
2500|$|Tendermint {{is general}} purpose {{software}} for BFT state machine replication. Using a socket protocol, it enables <b>state</b> <b>machines</b> to be written in any programming language, and provides ...|$|E
50|$|The CIP-model is {{basically}} a finite <b>state</b> <b>machine,</b> or more precisely, an extended finite <b>state</b> <b>machine</b> (processes can store and modify variables and can use these to enable or disable transitions).|$|R
5000|$|According to the W3C State Chart XML (SCXML): <b>State</b> <b>Machine</b> Notation for Control Abstraction specification, SCXML is a {{general-purpose}} event-based <b>state</b> <b>machine</b> {{language that}} can be used in many ways, including: ...|$|R
30|$|The product <b>machine</b> of the <b>state</b> <b>machine</b> objects {{pertaining}} to the same component results in an extended <b>state</b> <b>machine</b> outlining {{the behavior of the}} component. “Markov model applications” section illustrates this process.|$|R
