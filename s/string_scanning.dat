4|29|Public
5000|$|One of the {{powerful}} features of Icon is <b>string</b> <b>scanning.</b> The scan string operator, [...] saves the current <b>string</b> <b>scanning</b> environment and creates a new <b>string</b> <b>scanning</b> environment. The <b>string</b> <b>scanning</b> environment consists of two keyword variables, [...] and [...] Where &subject is the string being scanned, and &pos is the cursor or current position within the subject string.|$|E
50|$|A {{more complex}} example {{demonstrates}} {{the integration of}} generators and <b>string</b> <b>scanning</b> within the language.|$|E
50|$|As {{you would}} expect from the {{description}} of the run-time data structures used in these systems, they also have an interesting instruction set. Programs are made up of 8-bit syllables, which may be Name Call, be Value Call or form an operator, which may be from one to twelve syllables in length. There are less than 200 operators, all of which fit into 8-bit syllables. Many of these operators are polymorphic depending on the kind of data being acted on as given by the tag. If we ignore the powerful <b>string</b> <b>scanning,</b> transfer, and edit operators, the basic set is only about 120 operators. If we remove the operators reserved for the operating system such as MVST and HALT, the set of operators commonly used by user-level programs is less than 100. The Name Call and Value Call syllables contain address couples; the Operator syllables either use no addresses or use control words and descriptors on the stack.|$|E
50|$|An {{example of}} a format string isThe above format <b>string</b> <b>scans</b> the first seven {{characters}} as a decimal integer, then reads the remaining as a string until a space, new line or tab is found, then scans the first non-whitespace character following and a double-precision floating-point number afterwards.|$|R
5000|$|...left or *l - left <b>string</b> from <b>scan</b> or split command {{execution}} ...|$|R
5000|$|...middle or *m - middle <b>string</b> from <b>scan</b> or split command {{execution}} ...|$|R
40|$|This paper {{presents}} a software tool sa 2 px to translate regular expressions (regexps) in SpamAssassin (SA) rules into the POSIX format. The translated regexps {{can be implemented}} on different platforms, so that one could better separate the composition process of spam filtering rules from the on-line operations. Sa 2 px is consisted of three layers of functions. The first layer is responsible for translating plugins and special formats to their equivalent basic SA formats. The second layer uses a syntax conversion approach to translate basic SA rules to the POSIX format. The third layer uses a backward grouping algorithm to group multiple regexps together {{so that they can}} be packed into a DFA table using Flex or similar tools. Overall, sa 2 px can translate regexps in the whole rule set (uri, body, header, rawbody and ReplaceTags plugin), and the translation rate of 1115 SA regexp rules is 84. 5 %. In comparison, sa-compile can translate 296 rules of 453 body rules. The translated rules are then clustered into several main groups, except for some cases in which the regexp structures led to explosive state growth. Finally, DFA tables and (action number, rule name) pairs are generated. Experimental results show that the DFA table based implementation of these translated regexps cut down 66 % of the execution time of the Perl (with sa-compile activated) based <b>string</b> <b>scanning</b> under process-level parallelization environment. 1...|$|E
5000|$|...right or *r - right <b>string</b> from <b>scan</b> or split command {{execution}} ...|$|R
5000|$|... : <b>Scan</b> a {{character}} <b>string.</b> The <b>scan</b> terminates at whitespace. A null character is stored {{at the end}} of the string, which means that the buffer supplied must be at least one character longer than the specified input length.|$|R
5000|$|Built-in and {{user-defined}} functions {{can be used}} to {{move around}} within the <b>string</b> being <b>scanned.</b> Many of the built-in functions will default to &subject and &pos (for example the find function). The following, for example, will write all blank delimited [...] "words" [...] in a string.|$|R
50|$|Uniform Resource Locator (URL) filtering: URL <b>strings</b> are <b>scanned</b> {{for target}} {{keywords}} {{regardless of the}} domain name specified in the URL. This affects the HTTP protocol. Typical circumvention methods are to use escaped characters in the URL, or to use encrypted protocols such as VPN and TLS/SSL.|$|R
50|$|These {{were used}} for <b>scanning</b> <b>strings</b> useful in writing compilers.All these {{operators}} are protected from buffer overflows by being limited by the bounds in the descriptors.|$|R
40|$|This thesis {{develops}} an algorithm for approximate {{string matching}} and applies {{it to the}} problem of partially occluded object recognition. The algorithm measures the similarity of differing <b>strings</b> by <b>scanning</b> for matching substrings between strings. The length and number of matching substrings determines the amount of similarity. A classification algorithm is developed using the approximate string matching algorithm for the identification and classification of objects. A previously developed method of shape description is used for object representation...|$|R
40|$|AbstractmFive {{experiments}} {{explored the}} utility of subvocal rehearsal, and of an inner-ear/innervoice partnership, in tasks of auditory imagery. In three tasks (reinterpreting ambiguous auditory images, parsing meaningful letter <b>strings,</b> <b>scanning</b> familiar melodies) subjects relied on a partnership between the inner ear and inner voice, one similar to the phonological loop system described in the short-term memory literature. Apparently subjects subvoeally rehearsed the imagery material, which placed the material in a phonological store that allowed the imagery judgement. In a fourth task (distinguishing voiced and unvoiced consonants in imagery), subjects still subvoeally rehearsed, but seemed to need no additional phonological store to respond correctly. In this ease they may have consulted articulatory or kinesthetic cues instead. In a fifth experiment (making homophone judgements), subjects hardly even needed to subvoeally rehearse, a result suggesting that homophone judgements rely on some direct route from print to phonology. We consider {{the breadth of the}} partnership between the inner ear and inner voice, the level that subvoeal rehearsal occupies in the cognitive system, and the functional neuroanatomy of the phonological loop system. Key Words: imagery; auditory imagery; subvocalization; inner speech...|$|R
40|$|A regular {{language}} is generally accepted {{by a single}} finite automaton. But when to increase the efficiency, we use Dual Finite Automata, An input <b>string</b> is <b>scanned</b> by two deterministic finite automata (DFA's) : reading from the string's head and tail respectively. One of them accepts the regular language itself; the other accepts the language's reversal. Whether a string is accepted depends on the states of both automata, when their reading heads meet. Dual finite automata can be applied in compiler generation and parallel computing...|$|R
50|$|TEX {{provided}} several internal read-only registers called star functions or star variables which changed {{state when}} certain TEX string parsing operations were executed. Star functions provided {{a means to}} get the current date and time, resultant strings from a split or <b>scan</b> <b>string</b> parsing operations, TEX internal call level and TSS session information.|$|R
30|$|As the {{temporal}} {{length of the}} pulse is less than 1  ms, {{it is assumed that}} a scanning system is not applicable unless each point is scanned within a different <b>string.</b> This <b>scanning</b> configuration requires several minutes for the complete the detection process. The accuracy of the time measurements must be better than 0.5  ns (0.1  ns recommended) to enable accurate mapping of the room layout when measuring the time delay between the reception of the original pulse and its back-reflected versions (Fang, 1990; Lee, 1989). The delay for a depth of 15  cm is less than 1  ns for complete two-way travel.|$|R
50|$|Notable {{extensions}} {{to standard}} Pascal include separately compilable Units and a String type. Both of these extensions influenced {{the design of}} the Ada language.Some intrinsics were provided to accelerate <b>string</b> processing (e.g. <b>scanning</b> in an array for a particular search pattern); other language extensions were provided to allow the UCSD p-System to be self-compiling and self-hosted.|$|R
40|$|Abstract—The {{one-dimensional}} (1 -D) Boolean {{model is}} used to calculate features for the description of binary textures. Each two-dimensional (2 -D) texture is converted into several 1 -D <b>strings</b> by <b>scanning</b> it according to raster vertical, horizontal or Hilbert sequences. Several different probability distributions for the segment lengths created this way are used to model their distribution. Therefore, each texture is described by a set of Boolean models. Classification is performed by calculating the overlapping probability between corresponding models. The method is evaluated with the help of 32 different binary textures, and {{the pros and cons of}} the approach are discussed. Index Terms—Feature extraction, statistical models, texture analysis. I...|$|R
40|$|IV Escuela: Curso 1 Curso 2 Curso 3 Dualidad y D-branas. César Gómez López 7 Bosonic String 7. 1 Classical Theory 7. 2 Closed Bosonic String 7. 3 Open Bosonic String 7. 4 Background Fields 8 Toroidal Compactifications 8. 1 T-Duality 8. 1. 1 Closed Bosonic String Compactifications 8. 2 Discrete Light Cone: Compactification of Light 8. 3 Open Bosonic String Compactifications: D-Branes 8. 3. 1 D-Brane Dynamics 8. 4 Orientifolds 9 6 -Model Geometry 9. 1 K 3 Geometry. A First Look at Quantum Cohomology 9. 2 Mirror Symmetry 9. 3 Elliptic Fibrations 9. 3. 1 Singularities of Type D 4 : Z 2 Orbifolds 9. 3. 2 Singularities of Type An_ 19. 3. 3 Singularities of Type Dn+ 49. 4 Kodaira's Classification 9. 5 Elliptically Fibered K 310 Superstring Theories 10. 1 Worldsheet Supersymmetry 10. 2 Green-Schwarz Superstring: <b>String</b> <b>Scan</b> 10. 3 The SO(32) Type I Superstring 10. 4 Toroidal Compactification of Type IIA and Type IIB Theories. U-duality 10. 5 Heterotic String and K 3 Surfaces 10. 6 Heterotic Compactifications to Four Dimensions. 10. 7 Heterotic-Type I Duality 10. 8 The Quantum Fate of Moduli Singularities 10. 8. 1 Small Instantons for Heterotic String on K 310. 8. 2 Conifold Singularities for Type II Strings 10. 9 Point Particle Limit 11 Dirichlet-Branes 11. 1 Supersymmetric D-Branes 11. 2 D-Brane Scattering 11. 2. 1 Field Theory Effective Potentials 11. 2. 2 Brane-Antibrane Scattering 11. 3 Elliptic Fibrations and D- 7 branes 11. 4 D-Brane Classical Supergravity Solutions 11. 5 D-Branes and Black HolesBibliografíaIV Escuela:Curso 1 Curso 2 Curso 3 Nivel analític...|$|R
40|$|Network Intrusion Detection and Prevention Systems (IDPS) use <b>string</b> {{matching}} to <b>scan</b> Internet packets for ma-licious content. Bloom filters offer {{a mechanism}} {{to search for a}} large number of strings efficiently and concurrently when implemented with Field Programmable Gate Array (FPGA) technology. A string matching circuit has been im-plemented within the FPX platform using Bloom filters. Us-ing 155 block RAMs on a single Xilinx VirtexE 2000 FPGA, the circuit scans for 35, 475 unique signatures. ...|$|R
40|$|Abstract—All Text {{processing}} systems allow their users to search {{a pattern of}} string from a given text. String matching is fundamental to database and text processing applications. Every text editor must contain a mechanism to search the current document for arbitrary <b>strings.</b> Spelling checkers <b>scan</b> an input text for words in the dictionary and reject any strings that do not match. We store our information in data bases so that later on we can retrieve the same and this retrieval {{can be done by}} using various string matching algorithms. This paper is describing a new string matching algorithm for various applications. A new algorithm has been designed with the help of Rabin Karp Matcher, to improve string matching process...|$|R
40|$|Designers {{of visual}} {{communication}} material want their material {{to attract and}} retain attention. In marketing research, heat maps, dwell time, and time to AOI first hit are often used as evaluation parameters. Here we present two additional measures 1) scan path entropy to quantify gaze guidance and 2) the arrow plot to visualize the average scan path. Both are based on <b>string</b> representations of <b>scan</b> paths. The latter also incorporates transition matrices and time required for 50 % of the observers to first hit AOIs (T 50). The new measures were tested in an eye tracking study (48 observers, 39 advertisements). Scan path entropy is a sensible measure for gaze guidance and the new visualization method reveals aspects of the average scan path and gives a better indication in what order global scanning takes place...|$|R
40|$|Automata act as {{classical}} {{models for}} recognition devices. From the previous researches, the classical models of automata {{have been used}} to <b>scan</b> <b>strings</b> and to determine the types of languages a string belongs to. In the study of automata and group theory, it has been found that the properties of a group can be recognized by the automata using the automata diagrams. There are two types of automata used to study the properties of a group, namely modified finite automata and modified Watson-Crick finite automata. Thus, in this paper, automata diagrams are constructed to recognize permutation groups using the data given by the Cayley table. Thus, the properties of permutation group are analyzed using the automaton diagram that has been constructed. Moreover, some theorems for the properties of permutation group in term of automata are also given in this paper...|$|R
40|$|The {{tremendous}} {{growth in}} digital imagery {{is driving the}} need for more sophisticated methods for automatic image analysis, cataloging, and searching. We present a method for classifying and querying images based on the spatial orderings of regions or objects using composite region templates (CRTs). The CRTs capture the spatial information statistically and provide a robust way to measure similarity in the presence of region insertions, deletions, substitutions, replications and relocations. The CRTs can be used for classifying and annotating images by assigning symbols to the regions or objects and by extracting symbol <b>strings</b> from spatial <b>scans</b> of the images. The symbol strings can be decoded using a library of annotated CRTs to automatically label and classify the images. The CRTs can also be used for searching bysketch or example by measuring image similarity based on relative counts of the CRTs...|$|R
40|$|Abstract — Metamorphic viruses engage {{different}} mutation {{techniques to}} escape from <b>string</b> signature based <b>scanning.</b> They try to change their code in new offspring so that the variants appear non-similar and have no common sequences of string as signature. However, all versions of a metamorphic virus have similar task and performance. This obfuscation process helps to keep them safe from the string based signature detection. In this study, we make use of instructions statistical features to compare the similarity of two hosted files probably occupied by two mutated forms of a specific metamorphic virus. The introduced solution in this paper is relied on static analysis and employs the frequency histogram of machine opcodes in different instances of obfuscated viruses. We use Minkowski-form histogram distance measurements in order to check the likeness of portable executables (PE). The purpose {{of this research is}} to present an idea that for a number of special obfuscation approaches the presented solution can be used to identif...|$|R
40|$|Metamorphic viruses  engage {{different}} mutation {{techniques to}} escape from <b>string</b> signature based <b>scanning.</b> They try to change their code in new offspring so that the variants appear non-similar and have no common sequences of string as signature. However, all versions of a metamorphic virus have similar task and performance. This obfuscation process helps to keep them safe from the string based signature detection. In this study, we make use of instructions statistical features to compare the similarity of two hosted files probably occupied by two mutated forms of a specific metamorphic virus. The introduced solution in this paper is relied on static analysis and employs the frequency histogram of machine opcodes in different instances of obfuscated viruses. We use Minkowski-form histogram distance measurements in order to check the likeness of portable executables (PE). The purpose {{of this research is}} to  present an idea that for  a number of special  obfuscation approaches the presented solution can be  used to identify morphed copies of a file. Thus, it can be applied by antivirus scanner to recognize different versions of a metamorphic virus...|$|R
40|$|Contents 1 Grammars and Parsing 3 2 Grammars 4 2. 1 Grammar {{notation}} 4 2. 2 Derivation 4 3 Parsing theory 6 3. 1 Parsing: {{reconstruction of}} a derivation tree 6 3. 2 A more machine-oriented view of parsing 8 3. 3 Left factorization 9 3. 4 Left recursive nonterminals 10 3. 5 First-sets, follow-sets and selection sets 11 3. 6 Summary of parsing theory 15 4 Parser construction in Java 16 4. 1 Java {{representation of the}} input 16 4. 2 Constructing parsing methods in Java 16 4. 3 Parsing methods follow the derivation tree 19 4. 4 Summary of parser construction 19 5 Scanners 20 5. 1 Scanning #oating-pointnumerals 22 5. 2 Scanning names 22 5. 3 Distinguishing names from keywords 23 5. 4 <b>Scanning</b> <b>string</b> constants 23 5. 5 Summary of scanning: token streams 23 6 Parsers with attributes 24 6. 1 Constructing attributed parsers 24 6. 2 Building representations of input 28 6. 3 Summary of parsers with attributes 30 7 A larger example: ari...|$|R
40|$|The {{complexity}} of anti-virus software has grown enormously {{over the last}} five years. The methods used to detect viruses have evolved from dumb-grunt scanning of the whole file from top to bottom for a specific search string to very intelligent methods based on a combination of heuristic and specific detection methods. This paper discusses this evolution in detail: from old-fashioned methods to the most complex contemporary ones. When speaking to the people not directly involved in the AV business I found it rather amusing that they are usually surprised to find that these days we do not use <b>scan</b> <b>strings</b> as such any more. In fact, we do, but not frequently, because for contemporary malware better methods can be used. What are they? The definitions and examples of various detection methods are given including: search string detection, checksumming or CRCing, X-raying elimination, static heuristic analysis, dynamic heuristic analysis, etc. The advantages and disadvantages of these individual methods and their combinations are presented. A theoretical battle is constantly going on. Which is better: specific, precise detection or generic ways of handling viruses...|$|R
50|$|The Warden client scans a {{small portion}} of the code segment of running {{processes}} in order to determine whether any third-party programs are running. The goal of this is to detect and address players who may be attempting to run unsigned code or third party programs in the game. This determination of third party programs is made by hashing the <b>scanned</b> <b>strings</b> and comparing the hashed value to a list of hashes assumed to correspond to banned third party programs. The Warden's reliability in correctly discerning legitimate versus illegitimate actions was called into question when a large scale incident happened. This incident banned many Linux users after an update to Warden caused it to incorrectly detect Cedega as a cheat program. Blizzard issued a statement claiming they had correctly identified and restored all accounts and credited them with 20 days play. Warden scans all processes running on a computer, not just the game, and could possibly run across what would be considered private information and other personally identifiable information. It is because of these peripheral scans that Warden has been accused of being spyware and has run afoul of controversy among privacy advocates.|$|R
40|$|Metamorphic viruses engage {{different}} mutation {{techniques to}} escape from <b>string</b> signature based <b>scanning.</b> They try to change their code in new offspring so that the variants appear non-similar and have no common sequences of string as signature. However, all versions of a metamorphic virus have similar task and performance. This obfuscation process helps to keep them safe from the string based signature detection. In this study, we make use of instructions statistical features to compare the similarity of two hosted files probably occupied by two mutated forms of a specific metamorphic virus. The introduced solution in this paper is relied on static analysis and employs the frequency histogram of machine opcodes in different instances of obfuscated viruses. We use Minkowski-form histogram distance measurements in order to check the likeness of portable executables (PE). The purpose {{of this research is}} to present an idea that for a number of special obfuscation approaches the presented solution can be used to identify morphed copies of a file. Thus, it can be applied by antivirus scanner to recognize different versions of a metamorphic virus. Comment: Proceeding of the International Conference on Advance Science, Engineering and Information Technology 2011, Hotel Equatorial Bangi-Putrajaya, Malaysia, 14 - 15 January 201...|$|R
40|$|LFC是以上下文无关语言上的递归函数（CFRF）理论为基础的形式规约语言，能较好地支持形式规约的获取和检验．同时LFC也是一种函数式语台，具有良好的数学基础、引用透明、无副作用、模式匹配等特点．本文工作主要是研究形式规约语言LFC的实现和应用，另外还包括一个上下文无关语言句子枚举算法．在理论方面，提出了一个上下文无关语言句子枚举算法．该枚举算法首先计算上下文无关语言的最小序句子和最大序句子，然后从最小序句子开始按照一定的顺序扫描字符串，直至扫描到最大序句子为止，对被扫描的字符串进行判断取舍，在扫描的过程中采用削减和前瞻策略，很大程度上减少了被扫描字符串的个数，可以取得较好的时空性能．在实现方面，提出了编译LFC的技术路线，设计一个目标抽象机，通过程序翻译的方法将源程序翻译为目标抽象机代码，然后再将抽象机代码转换为汇编代码，汇编装配连接执行．翻译过程中，将进行参数一致化、模式分量翻译、模式的编码、公共子表达式的提取、模式匹配树的构造及优化工作．由于LFC是一个有类型的语言，为其设计了一个类型系统，支持参数化多态，给出了类型检查算法，还讨论了类型系统实现中需要解决的问题．为实现编译目的，设计了一个目标抽象机HSECD机，详细讨论了HSECD机的结构、指令、工作原理和指令优化方法．提出从HSECD机指令生成汇编指令的方法，包括如何组织存储结构和宏扩展．此外，为上下文无关语言句子的分析树设计了一种简单表示形式，这种表示形式可以提高空间效率，并且易于实现．根据CFRF的特点，提出了后缀形式的计算方法，减少在函数计算中存在的动态语法分析，避免了不必要的求值计算，使效率得到提高．在此基础上，实现了LFC的编译器．在应用方面，实现了一个用LFC编写的从XML DTD到XML Schema的转换工具，检验了LFC的能力．The {{implementation}} {{and application of}} formal specification language LFC are studied in this thesis. LFC is a formal specification language based on recursive functions defined on context free languages (CFRF) and supports the acquisition and validation of formal specification very well. LFC is yet another functional programming language which has many characteristics, such as good mathematics basis, reference transparency, no side effect, pattern matching, etc. In theory, an algorithm of enumerating sentences of CFG is presented. First, the minimal and maximal sentences of CFG are calculated. Then the character <b>strings</b> are <b>scanned</b> one by one from the minimal sentence in certain order till the maximal sentence. The <b>scanned</b> character <b>strings</b> are printed or skipped according to a rule. In the process, reducing and look-ahead strategies are adopted {{to reduce the number}} of the <b>scanned</b> character <b>strings.</b> So good time and space efficiency can be achieved. In implementation, the technique solution of compiling LFC is presented. The solution is that we design a target machine, and translate the source codes into the target machine codes by program translation, then generate the assembly codes from the target machine codes, assemble and link the assembly codes into exe file, at last execute the exe file to get the result of program. Renaming parameters, translating pattern, generating code of pattern, extracting common sub expression, constructing and optimizing pattern-matching tree, are finished during program translation. For compilation, we design a target abstract machine-HSECD machine and discuss the structure, instruction, principle and optimization of HSECD machine in detail. The method of generating assembly codes from HSECD instructions including arranging store structure and macro expansion is put forward. Moreover, we present an intermediate representation for parsing tree of CFL sentence that can be easily implemented and needs less space occupancy. According to the characteristic of CFRF, we develop the calculation method of postfix form that can reduce calling CFL sentence parsing and redundant evaluation to improve the efficiency. From these, a compiler is constructed. In application, we finish a converter of XML DTD to XML Schema in LFC that proves the application power of LFC...|$|R

