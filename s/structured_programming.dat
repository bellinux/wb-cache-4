640|6784|Public
5|$|COBOL {{has been}} criticized {{throughout}} its life, however, for its verbosity, design process and poor support for <b>structured</b> <b>programming,</b> which resulted in monolithic and incomprehensible programs.|$|E
5|$|Python is a multi-paradigm {{programming}} language: {{object-oriented programming}} and <b>structured</b> <b>programming</b> are fully supported, and many language features support functional programming and aspect-oriented programming (including by metaprogramming and metaobjects (magic methods)). Many other paradigms are supported via extensions, including design by contract and logic programming.|$|E
25|$|The {{rise of the}} <b>structured</b> <b>programming</b> {{movement}} led to {{many other}} structured approaches applied to software design. The techniques of structured analysis and structured design are outgrowths of <b>structured</b> <b>programming</b> concepts and techniques, and of the early ideas about modular design. Principles of modularity were strengthened by Larry Constantine's concepts of coupling (to be minimized between modules) and cohesion (to be maximized within modules), by David Parnas's techniques of information hiding, and by abstract data types. A number of tools and methods employing structured concepts were developed, such as Structured Design, Jackson's <b>Structured</b> <b>Programming,</b> Ross' Structured Analysis and Design Technique (SADT), Yourdon's Structured Method, Structured Systems Analysis and Design Method (SSADM), and James Martin's Information Engineering. The field of software metrics is often considered as a direct influence of the <b>structured</b> <b>programming</b> movement on software engineering in the 1970s.|$|E
40|$|To evolve <b>structured</b> <b>programs</b> we {{introduce}} H-PIPE, {{a hierarchical}} extension of Probabilistic Incremental Program Evolution (PIPE - Sa/lustowicz and Schmidhuber, 1997). Structure is induced by "hierarchical instructions" (HIs) limited to top-level, <b>structuring</b> <b>program</b> parts. "Skip nodes" (SNs) inspired by biology's introns (non-coding segments) allow for switching program parts on and off. In our experiments H-PIPE outperforms PIPE, and SNs facilitate synthesis of certain <b>structured</b> <b>programs</b> but not unstructured ones. We conclude that introns {{can be particularly}} useful {{in the presence of}} structural bias. Keywords: Probabilistic Incremental <b>Program</b> Evolution, <b>Structured</b> <b>Programs,</b> Hierarchical Programs, Introns, Non-Coding Segments. 1 Introduction and Previous Work Overview. Hierarchical Probabilistic Incremental Program Evolution (H-PIPE) is a novel method for synthesizing <b>structured</b> <b>programs.</b> It uses the PIPE paradigm (Sa/lustowicz and Schmidhuber, 1997) to iteratively generate succes [...] ...|$|R
40|$|To evolve <b>structured</b> <b>programs</b> we {{introduce}} H-PIPE, {{a hierarchical}} extension of Probabilistic Incremental <b>Program</b> Evolution (PIPE). <b>Structure</b> is induced by "hierarchical instructions" (HIs) limited to top-level, <b>structuring</b> <b>program</b> parts. "Skip nodes" (SNs) allow for switching program parts on and off. They facilitate synthesis of certain <b>structured</b> <b>programs.</b> In our experiments HPIPE outperforms PIPE: structural bias can speed up program synthesis. Keywords: Probabilistic Incremental <b>Program</b> Evolution, <b>Structured</b> <b>Programs,</b> Hierarchical Programs, Non-Coding Segments. 1 Introduction Overview. Automatic program synthesis {{is of interest}} because it addresses the problem of searching in general algorithm space as opposed to more limited search spaces like those of, say, feedforward neural networks. Hierarchical Probabilistic Incremental Program Evolution (H-PIPE) is a novel method for synthesizing <b>structured</b> <b>programs.</b> It uses the PIPE paradigm (Sa/lustowicz and Schmidhuber, 1997) to iterativ [...] ...|$|R
50|$|Pascal <b>structures</b> <b>programs</b> into {{procedures}} and functions.|$|R
25|$|In <b>structured</b> <b>programming,</b> the ordered {{sequencing}} of successive commands {{is considered one}} of the basic control structures, which is used as a building block for programs alongside iteration, recursion and choice.|$|E
25|$|Procedural {{programming}} {{is a type}} of imperative programming in which the program is built from one or more procedures (also termed subroutines or functions). The terms are often used as synonyms, but the use of procedures has a dramatic effect on how imperative programs appear and how they are constructed. Heavily-procedural programming, in which state changes are localized to procedures or restricted to explicit arguments and returns from procedures, is a form of <b>structured</b> <b>programming.</b> From the 1960s onwards, <b>structured</b> <b>programming</b> and modular programming in general have been promoted as techniques to improve the maintainability and overall quality of imperative programs. The concepts behind object-oriented programming attempt to extend this approach.|$|E
25|$|The Octave {{language}} is an interpreted programming language. It is a <b>structured</b> <b>programming</b> language (similar to C) and supports many common C standard library functions, and also certain UNIX system calls and functions. However, {{it does not}} support passing arguments by reference.|$|E
5000|$|... {{regional}} conferences {{or global}} summits featuring multi-day <b>structured</b> <b>programs</b> ...|$|R
50|$|He first {{described}} the general use of monads to <b>structure</b> <b>programs.</b>|$|R
50|$|The {{graduate}} school offers a <b>structured</b> <b>program</b> for CASED PhD students.|$|R
25|$|Dijkstra's {{ideas about}} {{programming}} methodology (especially the <b>structured</b> <b>programming</b> movement) helped lay {{the foundations for}} the birth {{and development of the}} professional discipline of software engineering (in particular the software design and development), enabling programmers to organize and manage increasingly complex software projects. In the late 1960s Dijkstra discussed the concept of program families. And in the mid 1970s David Parnas and others clarified the idea and showed how to apply it in software engineering principles.|$|E
25|$|JavaScript {{supports}} {{much of the}} <b>structured</b> <b>programming</b> syntax from C (e.g., if statements, while loops, switch statements, {{do while}} loops, etc.). One partial exception is scoping: JavaScript originally had only function scoping with var. ECMAScript 2015 added keywords let and const for block scoping, meaning JavaScript now has both function and block scoping. Like C, JavaScript makes a distinction between expressions and statements. One syntactic difference from C is automatic semicolon insertion, which allows the semicolons that would normally terminate statements to be omitted.|$|E
25|$|The {{notion of}} {{multi-level}} breaks is of {{some interest in}} theoretical computer science, because it gives rise to what is today called the Kosaraju hierarchy. In 1973 S. Rao Kosaraju refined the structured program theorem by proving that it's possible to avoid adding additional variables in <b>structured</b> <b>programming,</b> as long as arbitrary-depth, multi-level breaks from loops are allowed. Furthermore, Kosaraju proved that a strict hierarchy of programs exists: for every integer n, there exists a program containing a multi-level break of depth n that cannot be rewritten as a program with multi-level breaks of depth less than n without introducing added variables.|$|E
40|$|These notes {{discuss the}} {{simultaneous}} use of generalised fold operators and monads to <b>structure</b> functional <b>programs.</b> Generalised fold operators <b>structure</b> <b>programs</b> after the decomposition {{of the value}} they consume. Monads <b>structure</b> <b>programs</b> after the computation of the value they produce. Our programs abstract both from the recursive processing of their input {{as well as from}} the side-effects in computing their output. We show how generalised monadic folds aid in calculating an efficient graph reduction engine from an inefficient specification...|$|R
5000|$|Interface pattern: {{method for}} <b>structuring</b> <b>programs</b> so that they're simpler to {{understand}} ...|$|R
40|$|The {{use of a}} {{preprocessor}} of the LaRC {{computer center}} that converts RAFTOR source into FORTRAN source code is described. The purpose of RAFTOR is to make FORTRAN a better programming language for both writing and <b>structuring</b> <b>programs.</b> It is concluded that RAFTOR can generate a well <b>structured</b> <b>program</b> with a source code that is easy to follow...|$|R
25|$|Some {{assemblers}} {{have incorporated}} <b>structured</b> <b>programming</b> elements to encode execution flow. The earliest {{example of this}} approach was in the Concept-14 macro set, originally proposed by Dr. Harlan Mills (March 1970), and implemented by Marvin Kessler at IBM's Federal Systems Division, which extended the S/360 macro assembler with IF/ELSE/ENDIF and similar control flow blocks. This {{was a way to}} reduce or eliminate the use of GOTO operations in assembly code, one of the main factors causing spaghetti code in assembly language. This approach was widely accepted in the early '80s (the latter days of large-scale assembly language use).|$|E
25|$|Purely {{functional}} {{programs can}} use monads to structure procedures that include sequenced operations like {{those found in}} <b>structured</b> <b>programming.</b> Many common programming concepts {{can be described in}} terms of a monad structure without losing the beneficial property of referential transparency, including side effects such as input/output, variable assignment, exception handling, parsing, nondeterminism, concurrency, continuations, or domain-specific languages. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like Haskell provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.|$|E
500|$|In the 1970s, {{adoption}} of the <b>structured</b> <b>programming</b> paradigm was becoming increasingly widespread. Edsger Dijkstra, a preeminent computer scientist, {{wrote a letter to}} the editor of Communications of the ACM, published 1975 entitled [...] "How do we tell truths that might hurt?", in which he was critical of COBOL and several other contemporary languages; remarking that [...] "the use of COBOL cripples the mind".|$|E
50|$|The 2010 edition {{provided}} a <b>structured</b> <b>program</b> of workshops, lectures, classes, and concerts.|$|R
5000|$|Following the <b>structured</b> <b>program</b> theorem, all {{programs}} {{are seen as}} composed of control structures: ...|$|R
5000|$|Providing firmer 5-year force <b>structure</b> <b>program</b> package {{planning}} information concerning performance cost and schedules.|$|R
2500|$|Dijkstra, Edsger W. (1972). Notes on <b>Structured</b> <b>Programming,</b> in <b>Structured</b> <b>Programming,</b> by O.-J. Dahl, E. W. Dijkstra, and C. A. R. Hoare, New York: Academic Press ...|$|E
2500|$|Dijkstra's thesis {{was that}} departures from linear control flow were clearer if allowed only in disciplined higher-level {{structures}} such as the if-then-else statement and the while loop. This methodology was developed into <b>structured</b> <b>programming</b> movement, {{the title of his}} 1972 book, coauthored with C.A.R. Hoare and Ole-Johan Dahl. Considered by many as the first significant movement in history of computer programming, <b>structured</b> <b>programming</b> became the new programming orthodoxy during the 1970s. Bertrand Meyer remarked that, [...] "The revolution in views of programming started by Dijkstra's iconoclasm led to a movement known as <b>structured</b> <b>programming,</b> which advocated a systematic, rational approach to program construction. <b>Structured</b> <b>programming</b> is the basis for all that has been done since in programming methodology, including object-oriented programming." ...|$|E
2500|$|Compliance with Object-Oriented and <b>Structured</b> <b>Programming</b> best {{practices}} (as appropriate) ...|$|E
40|$|These notes {{discuss the}} {{simultaneous}} use of generalised fold operators and monads to <b>structure</b> functional <b>programs.</b> Generalised fold operators <b>structure</b> <b>programs</b> after the decomposition {{of the value}} they consume. Monads <b>structure</b> <b>programs</b> after the computation of the value they produce. Our programs abstract both from the recursive processing of their input {{as well as from}} the side-effects in computing their output. We show how generalised monadic folds aid in calculating an efficient graph reduction engine from an inefficient specification. 1 Introduction Should I <b>structure</b> my <b>program</b> after the decomposition of the value it consumes or after the computation of the value it produces? Some [Bir 89, Mee 86, Mal 90, Jeu 90, MFP 91] argue in favour of <b>structuring</b> <b>programs</b> after the decomposition of the value they consume. Such syntax directed programs are written using a limited set of recursion functionals. These functionals, called catamorphisms or generalised fold operators are naturally [...] ...|$|R
50|$|File formats {{and other}} {{internal}} data structures {{are described in}} the Data <b>Structures</b> <b>Programming</b> Reference Manual.|$|R
50|$|Currently, the {{conservatories}} train {{more than}} 1,200 students in <b>structured</b> <b>programs,</b> with 350 professors in nine departments.|$|R
2500|$|Compliance with Object-Oriented and <b>Structured</b> <b>Programming</b> best {{practices}} (when applicable) ...|$|E
2500|$|<b>Structured</b> <b>programming</b> {{is often}} {{regarded}} as [...] "goto-less programming". But as Bertrand Meyer notes, [...] "As {{the first book}} on the topic [...] shows, <b>structured</b> <b>programming</b> is about much more than control structures and the goto. Its principal message is that programming {{should be considered a}} scientific discipline based on mathematical rigor." [...] , <b>structured</b> <b>programming</b> – especially in the 1970s and 1980s – significantly influenced the birth of many modern programming languages such as Pascal, C, Modula-2, and Ada. The Fortran 77 version which incorporates the concepts of <b>structured</b> <b>programming,</b> was released in 1978. The C++ language was a considerably extended and enhanced version of the popular [...] C (see also: list of C-based programming languages). Since C++ was developed from a more traditional , it is a 'hybrid language', rather than a pure object-oriented programming language.|$|E
2500|$|Knuth {{discusses}} software patenting, <b>structured</b> <b>programming,</b> {{collaboration and}} his development of TeX.|$|E
5000|$|As state {{reform and}} {{development}} to a supportive living approach, involving new service <b>structures,</b> <b>program</b> development and financing.|$|R
5000|$|Eugenio Moggi and Philip Wadler {{introduced}} {{the use of}} monads for <b>structuring</b> <b>programs</b> written in functional programming languages.|$|R
40|$|Dynamic Interaction Simulation of Controls and <b>Structure</b> (DISCOS) <b>program</b> was {{developed}} for dynamic simulation and stability analysis of passive and actively controlled spacecraft. Program is written in FORTRAN IV for batch execution and requires access to finite-element <b>structures</b> <b>program</b> as NASTRAN for flexible-body input data...|$|R
