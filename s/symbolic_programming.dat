99|428|Public
2500|$|Colmerauer, with Philippe Roussel, {{used this}} dual {{interpretation}} of clauses {{as the basis}} of Prolog, which was implemented in the summer and autumn of 1972. The first Prolog program, also written in 1972 and implemented in Marseille, was a French question-answering system. The use of Prolog as a practical programming language was given great momentum by the development of a compiler by David Warren in Edinburgh in 1977. [...] Experiments demonstrated that Edinburgh Prolog could compete with the processing speed of other <b>symbolic</b> <b>programming</b> languages such as Lisp. [...] Edinburgh Prolog became the de facto standard and strongly influenced the definition of ISO standard Prolog.|$|E
50|$|Languages {{that support}} <b>symbolic</b> <b>programming</b> include Wolfram Language, LISP and Prolog.|$|E
5000|$|... <b>symbolic</b> <b>programming</b> {{which has}} a {{particular}} style of syntax and grammar.|$|E
40|$|In this paper, {{we present}} a new design-space {{exploration}} approach which we call the <b>symbolic</b> <b>program</b> approach. The <b>symbolic</b> <b>program</b> approach is based on both the trace driven approach and the control data ow graph approach. As expected, the trajectory of the <b>symbolic</b> <b>program</b> approach appears somewhere in-between the two extremes mentioned above. Thus, it leads to the shorter simulation time while it can still give fairly accurate performance numbers. Moreover, it produces results that can be readily taken as input for further design...|$|R
40|$|This paper {{shows how}} <b>symbolic</b> <b>programs</b> can be {{extracted}} from {{a special kind}} of recurrent neural networks, called neural programs. The technique is based on transforming between ordinary discrete data structures and " data structures representing probability distributions. The linear combinations of real values in ordinary neural networks are replaced with mixing of continuous data structures. Node activation functions, such as the sigmoid and tanh functions, are replaced with continuous equivalents of normal functions in <b>symbolic</b> <b>programs,</b> for example sorting a list. The resulting nets can use very many hidden layers since these new activation functions turn out to be smoother than for example the sigmoid. Keywords: <b>Program</b> synthesis, <b>symbolic</b> <b>programs,</b> recurrent neural nets, automatic dierentiation. ...|$|R
40|$|In {{this report}} {{we deal with}} an {{implementation}} of the architecture modelling technique. We describe architecture models, their features, {{and the way they}} should be used with the <b>symbolic</b> <b>program</b> exploration approach. We also show the reasons (motivation) why we choose this particular way of implementation for modelling different streaming multiprocessor architectures. Vladimir D. ˇZivković, LIACS- Leiden University architecture models, platforms, <b>symbolic</b> <b>programs,</b> SystemC, compiletime overlapping, run-time overlapping, operating system, inter-process communication, interrup...|$|R
50|$|Programming {{languages}} for the 1400 series included <b>Symbolic</b> <b>Programming</b> System (SPS, {{an assembly}} language), Autocoder (assembly language), COBOL, FORTRAN, Report Program Generator (RPG), and FARGO.|$|E
50|$|In {{computer}} programming, <b>symbolic</b> <b>programming</b> is a programming {{paradigm in}} which the program can manipulate its own formulas and program components {{as if they were}} plain data.|$|E
50|$|Mokotoff {{joined the}} IBM Applied Programming Department in 1959, working on {{developing}} systems {{software for the}} yet-to-be-announced IBM 1401. He {{is the author of}} SPS-1, SPS-2 IBM 1401 <b>Symbolic</b> <b>Programming</b> System, coauthor of 1401 Autocoder and participated in the 1401 Fortran II compiler project.|$|E
30|$|In this section, two {{examples}} {{are given to}} illustrate {{the applicability of the}} Fibonacci matrix method and all of them are performed on the computer by using MAPLE <b>symbolic</b> <b>program.</b>|$|R
40|$|Four <b>symbolic</b> <b>programs,</b> in Macsyma or Mathematica language, are presented. The rst program {{tests for}} the {{existence}} of solitons for nonlinear PDEs. It explicitly constructs solitons using Hirota's bilinear method. In the second program, the Painleve integrability test for ODEs and PDEs is implemented. The third program provides an algorithm to compute conserved densities for nonlinear evolution equations. The fourth software package aids in the computation of Lie symmetries of systems of dierential and dierence-dierential equations. Several examples illustrate the capabilities of the software. Key words: soliton theory, <b>symbolic</b> <b>programs,</b> Hirota method, Painleve test, Lie symmetries, conserved densities. 1 Introduction The search for special properties (such as integrability), exact solutions, Lie symmetries and conserved densities of nonlinear partial dierential equations (PDEs) becomes more and more attractive due to the availability of <b>symbolic</b> manipulation <b>programs</b> such as M [...] ...|$|R
40|$|The {{process of}} {{performing}} an automated stability analysis for an elastic-bladed helicopter rotor is discussed. A <b>symbolic</b> manipulation <b>program,</b> written in FORTRAN, {{is used to}} aid in the derivation of the governing equations of motion for the rotor. The blades undergo coupled bending and torsional deformations. Two-dimensional quasi-steady aerodynamics below stall are used. Although reversed flow effects are neglected, unsteady effects, modeled as dynamic inflow are included. Using a Lagrangian approach, the governing equations are derived in generalized coordinates using the <b>symbolic</b> <b>program.</b> The program generates the steady and perturbed equations and writes into subroutines to be called by numerical routines. The <b>symbolic</b> <b>program</b> can operate on both expressions and matrices. For the case of hovering flight, the blade and dynamic inflow equations are converted to equations in a multiblade coordinate system by rearranging the coefficients of the equations. For the case of forward flight, the multiblade equations are obtained through the <b>symbolic</b> <b>program.</b> The final multiblade equations are capable of accommodating any number of elastic blade modes. The computer implementation of this procedure consists of three stages: (1) the symbolic derivation of equations; (2) the coding of the equations into subroutines; and (3) the numerical study after identifying mass, damping, and stiffness coefficients. Damping results are presented in hover and in forward flight with and without dynamic inflow effects for various rotor blade models, including rigid blade lag-flap, elastic flap-lag, flap-lag-torsion, and quasi-static torsion. Results from dynamic inflow effects which are obtained from a lift deficiency function for a quasi-static inflow model in hover are also presented...|$|R
50|$|MXNet {{supports}} both imperative and <b>symbolic</b> <b>programming,</b> {{which makes}} it easier for developers that are used to imperative programming to get started with deep learning. It also makes it easier to track, debug, save checkpoints, modify hyperparameters, such as learning rate or perform early stopping.|$|E
50|$|In <b>symbolic</b> <b>programming</b> languages, {{it is easy}} to have {{patterns}} as {{arguments to}} functions or as elements of data structures. A consequence of this is the ability to use patterns to declaratively make statements about pieces of data and to flexibly instruct functions how to operate.|$|E
5000|$|The IBM 1401 <b>Symbolic</b> <b>Programming</b> System (SPS) was an {{assembler}} {{that was}} developed by Gary Mokotoff, IBM Applied Programming Department, for the IBM 1401 computer, {{the first of the}} IBM 1400 series. One source indicates that [...] "This programming system was announced by IBM with the machine." ...|$|E
40|$|A {{survey of}} <b>symbolic</b> <b>programs</b> for the {{determination}} of Lie symmetry groups of systems of differential equations is presented. The purpose, methods and algorithms of symmetry analysis are briey outlined. Examples illustrate {{the use of the}} software. Directions for further research and development are indicated...|$|R
5000|$|Wolfram Mathematica - {{mathematical}} <b>symbolic</b> computation <b>program.</b>|$|R
40|$|ABSTRACT: In {{this report}} {{we deal with}} a {{definition}} of the architecture modelling technique. We define representation, methods, and models related to the <b>symbolic</b> <b>program</b> exploration approach. We also show the reasons (motivation) why we choose this particular approach for exploration of different streaming multiprocessor architectures...|$|R
5000|$|Through <b>symbolic</b> <b>programming,</b> complex {{processes}} can {{be developed}} that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to [...] "learn", which makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.|$|E
5000|$|<b>Symbolic</b> <b>programming</b> is a {{paradigm}} that describes programs able to manipulate formulas and program components as data. [...] Programs can thus effectively modify themselves, {{and appear to}} [...] "learn", making them suited for applications such as artificial intelligence, expert systems, natural language processing and computer games. Languages that support this paradigm include Lisp and Prolog.|$|E
5000|$|When doing <b>symbolic</b> <b>programming</b> from {{a formal}} {{mathematical}} specification {{the use of}} indirection can be quite helpful. To start with a simple example the variables x, y and z in an equation such as [...] can refer to any number. One could imagine objects for various numbers and then x, y and z could point to the specific numbers being used for a particular problem. The simple example has its limitation as there are infinitely many real numbers. In various other parts of <b>symbolic</b> <b>programming</b> {{there are only so}} many symbols. So to move on to a more significant example, in logic the formula α can refer to any formula, so it could be β, γ, δ, ... or η→π, ς ∨ σ,.... When set-builder notation is employed the statement Δ={α} means the set of all formulae — so although the reference is to α there are two levels of indirection here, the first to the set of all α and then the second to a specific formula for each occurrence of α in the set Δ.|$|E
40|$|In {{this report}} we {{show how the}} <b>Symbolic</b> <b>Program</b> {{approach}} {{can be used to}} efficiently and accurately analyse the performance of a datadependent application executing on a multi-processor architecture. The candidate data-dependent application is the JPEG decoding network, and the candidate architecture is the space-Cake - Wasabi multiprocessor...|$|R
5000|$|For {{test and}} {{debugging}} purposes, the monitoring program can provide facilities to view and alter registers, memory, and restart location or obtain a mini core dump or print <b>symbolic</b> <b>program</b> names with current data values. It could permit new conditional [...] "pause" [...] locations, remove unwanted pauses and suchlike.|$|R
40|$|A <b>symbolic</b> <b>program</b> {{performing}} the Formal Reduction of Density Operators (FRODO) {{has been developed}} in the MuPAD computer algebra system {{with the purpose of}} evaluating the matrix elements of the electronic Hamiltonian between internally contracted functions in a complete active space (CAS) scheme. The program is illustrated making use of two meaningful examples...|$|R
5000|$|Hutch-Tech {{was one of}} the world's first {{high schools}} with a digital computer, {{acquiring}} an IBM 1620 (Level C) in 1961. [...] This computer, with 20,000 BCD words of memory, was quite advanced for the time, and classes were taught in assembly language, <b>symbolic</b> <b>programming,</b> Fortran, Cobol, and numerical analysis. Many Hutch-Tech graduates from the 1960s became pioneers in computing; perhaps the best known of these was astronomer and computer security expert Clifford Stoll.|$|E
50|$|Pure {{comes with}} an {{interpreter}} and debugger, provides automatic memory management, has powerful functional and <b>symbolic</b> <b>programming</b> abilities, and interfaces to libraries in C (e.g., for numerics, low-level protocols, and other such tasks). At the same time, Pure is a small language designed from scratch; its interpreter is not large, and the library modules are written in Pure. The syntax of Pure resembles that of Miranda and Haskell, {{but it is a}} free-format language and thus uses explicit delimiters (rather than off-side rule indents) to denote program structure.|$|E
50|$|POP-11 is an {{evolution}} of the language POP-2, developed in Edinburgh University and features an open stack model (like Forth, among others). It is mainly procedural, but supports declarative language constructs, including a pattern matcher and is mostly used for research and teaching in Artificial Intelligence, although it has features sufficient for many other classes of problems. It {{is often used to}} introduce <b>symbolic</b> <b>programming</b> techniques to programmers of more conventional languages like Pascal, who find POP syntax more familiar than that of Lisp. One of POP-11's features is that it supports first-class functions.|$|E
40|$|International audienceThe {{calculation}} of the oscillation condition {{is one of the}} main points of oscillator analysis. Its determination in finite term allows one to calculate the steady state amplitude and frequency of the oscillator. Symbolic solutions provide an additional insight into the behavior of the circuit. As an example the sensitivity of the oscillator to parameter change can be expressed in an exact form. Numerical solutions are not as helpful as symbolic solutions in the design stage. We present a technique, based on the gyrator transformation, to set up the nonlinear equation network in a form suitable to be solved with analytical methods. We develop a <b>symbolic</b> <b>program</b> based on this technique. As an example, the <b>symbolic</b> <b>program</b> is applied to compute the exact expression of the steady state frequency and amplitude of the Van der Pol oscillator and the Colpitts oscillator...|$|R
40|$|A <b>symbolic</b> dynamic <b>programming</b> {{approach}} for solving first-order Markov decision processes within the situation calculus is presented. As an alternative specification language for dynamic worlds the fluent calculus is chosen and the fluent calculus formalization of the <b>symbolic</b> dynamic <b>programming</b> approach is provided. The major constructs of Markov decision {{processes such as}} the optimal value function and the policy are logically represented. The technique produces a set of first-order formulae that minimally partitions the state space. Consequently, the <b>symbolic</b> dynamic <b>programming</b> algorithm presented here does not require neither state nor action space enumeration, thereby solving the drawback of classical dynamic programming methods...|$|R
40|$|International audienceWe {{propose a}} logic and a {{deductive}} system for stating and automatically proving the equivalence of programs in deterministic languages having a rewriting-based operational semantics. The deductive system is circular {{in nature and}} is proved sound and weakly complete; together, these results say that, when it terminates, our system correctly solves the program-equivalence problem as we state it. We show that our approach is suitable for proving the equivalence of both terminating and non-terminating programs, and also the equivalence of both concrete and <b>symbolic</b> <b>programs.</b> The latter are programs in which some statements or expressions are symbolic variables. By proving the equivalence between <b>symbolic</b> <b>programs,</b> one proves in one shot the equivalence of (possibly, infinitely) many concrete programs obtained by replacing the variables by concrete statements or expressions. We also report on a prototype implementation of the proposed deductive system in the K Framework...|$|R
5000|$|The {{idea behind}} FARGO was to {{facilitate}} ease of transition for IBM 407 Accounting Machine technicians {{to the new}} IBM 1400 series of computers. The 1400 series had two [...] assemblers; <b>Symbolic</b> <b>Programming</b> System (SPS) and Autocoder (a more advanced assembler which required more memory than SPS). These represented a significant paradigm shift and learning curve for the technicians who were accustomed to wiring a control panel to direct input, output, control and counter operations (add, subtract). Multiplication and division operations were possible but their practicality was limited.|$|E
50|$|Colmerauer, with Philippe Roussel, {{used this}} dual {{interpretation}} of clauses {{as the basis}} of Prolog, which was implemented in the summer and autumn of 1972. The first Prolog program, also written in 1972 and implemented in Marseille, was a French question-answering system. The use of Prolog as a practical programming language was given great momentum by the development of a compiler by David Warren in Edinburgh in 1977. Experiments demonstrated that Edinburgh Prolog could compete with the processing speed of other <b>symbolic</b> <b>programming</b> languages such as Lisp. Edinburgh Prolog became the de facto standard and strongly influenced the definition of ISO standard Prolog.|$|E
50|$|Term graphs are a {{prominent}} topic in programming language research since term graph rewriting rules {{are capable of}} formally expressing a compiler's operational semantics. Term graphs are also used as abstract machines capable of modelling chemical and biological computations as well as graphical calculi such as concurrency models. Term graphs can perform automated verification and logical programming since they are well-suited to representing quantified statements in first order logic. <b>Symbolic</b> <b>programming</b> software is another application for term graphs, which are capable of representing and performing computation with abstract algebraic structures such as groups, fields and rings.|$|E
40|$|Luddy Harrison October 15, 1991 Abstract A {{large body}} of {{literature}} has developed concerning the automatic parallelization of numerical programs, and a quite separate literature has developed concerning the parallelization of <b>symbolic</b> <b>programs.</b> Because many <b>symbolic</b> <b>programs</b> make heavy use of array data and iterative constructs, in addition to more "symbolic" language features like pointers and recursion, it is desirable to fuse these bodies of work so that results developed for numerical programs {{can be applied to}} symbolic ones, and generalized so that they apply to the variety of language constructs encountered in symbolic computations. In this paper is described a framework, called generalized iteration space, that allows one to unify dependence analysis of array computations with dependence analysis of pointer computations. It is shown that subscripted array accesses as well as pointer dereferences can be seen as linear functions of generalized iteration space. We are applying [...] ...|$|R
40|$|Abstract. We {{propose a}} logic and a {{deductive}} system for stating and automatically proving the equivalence of programs in deterministic languages having a rewriting-based operational semantics. The deductive system is circular {{in nature and}} is proved sound and weakly complete; together, these results say that, when it terminates, our system correctly solves the program-equivalence problem as we state it. We show that our approach is suitable for proving the equivalence of both terminating and non-terminating programs, and also the equivalence of both concrete and <b>symbolic</b> <b>programs.</b> The latter are programs in which some statements or expressions are symbolic variables. By proving the equivalence between <b>symbolic</b> <b>programs,</b> one proves in one shot the equivalence of (possibly, infinitely) many concrete programs obtained by replacing the variables by concrete statements or expressions. A prototype of the proof system for a particular language was implemented and can be tested on-line. ...|$|R
50|$|The Wolfram Language, {{a general}} multi-paradigm {{programming}} language developed by Wolfram Research, is the programming language of mathematical <b>symbolic</b> computation <b>program</b> Mathematica and the Wolfram Programming Cloud. It emphasizes <b>symbolic</b> computation, functional <b>programming,</b> and rule-based programming and can employ arbitrary structures and data.|$|R
