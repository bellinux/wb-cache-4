73|64|Public
50|$|For <b>sequential</b> <b>software,</b> {{examples}} of formal methods include the B-Method, the specification languages used in automated theorem proving, RAISE, and the Z notation.|$|E
50|$|The Structured Coordination Language (SCL) {{was one of}} the {{earliest}} skeleton programming languages. It provides a co-ordination language approach for skeleton programming over software components. SCL is considered a base language, and was designed to be integrated with a host language, for example Fortran or C, used for developing <b>sequential</b> <b>software</b> components. In SCL, skeletons are classified into three types: configuration, elementary and computation. Configuration skeletons abstract patterns for commonly used data structures such as distributed arrays (ParArray). Elementary skeletons correspond to data parallel skeletons such as map, scan, and fold. Computation skeletons which abstract the control flow and correspond mainly to task parallel skeletons such as farm, SPMD, and iterateUntil. The coordination language approach was used in conjunction with performance models for programming traditional parallel machines as well as parallel heterogeneous machines that have different multiple cores on each processing node.|$|E
40|$|Most {{software}} {{today is}} concurrent {{and are used}} in everything from cell- phones, washing machines, cars to aircraft control systems. The reliability of the concurrent software may {{be more or less}} critical, depending on which a. o. domain it is functioning in. Irrespective of domain, the concurrent software must be suﬃciently reliable. It is therefore interesting to study how adaptable test methods for <b>sequential</b> <b>software</b> are to test concurrent software. Novel test methods for concurrent software can be developed by adapting test methods for <b>sequential</b> <b>software.</b> In this dissertation, adaptability factors have been identiﬁed by conducting a literature survey over state-of-the-art test methods. Directions taken in the research of concurrent software testing is described by the survey. The survey also demonstrates diﬀerences and similarities between test methods. Three research contributions has been achieved by this dissertation. First, this dissertation presents a survey over state-of-the-art-test methods. The second contribution is the identiﬁed adaptability factors that should be added to a test method for <b>sequential</b> <b>software,</b> that will be adapted to test concurrent software. Finally, the third contribution to the ﬁeld of concurrent software testing is the identiﬁed future work in areas where test methods for concurrent software has not been researched much or at all. ...|$|E
50|$|Generally the {{simulation}} and emulation environment are two independent systems. Semulation is a symbiosis of both methods. In semulation {{one part of}} a hardware design is processed <b>sequential</b> in <b>software</b> (e.g. the testbench) while the other part is emulated.|$|R
40|$|The use of weakest-precondition {{predicate}} tranformers in the derivation of <b>sequential,</b> process-control <b>software</b> is discussed. Only one {{extension to}} Dijkstra's calculus for deriving ordinary sequential programs {{was found to}} be necessary: function-valued auxiliary variables. These auxiliary variables are needed for reasoning about states of a physical process that exist during program transitions...|$|R
50|$|A {{write buffer}} {{is a type}} of data buffer used in certain CPU cache {{architectures}} like Intel's x86 and AMD64. In multi-core systems, write buffers destroy <b>sequential</b> consistency. Some <b>software</b> disciplines, like C11's data-race-freedom, are sufficient to regain a sequentially consistent view of memory.|$|R
40|$|Synchronous {{programming}} {{languages are}} well-suited {{for the design}} of safety-critical real-time embedded systems. However, the compilers and synthesis procedures are challenged by the synchronous programming paradigm and have to solve additional problems like causality and schizophrenia problems. Algorithms to solve these basic compilation problems have already become mature, but code optimization still lacks behind. Often, code optimiza-tion is left to the back-end tools like compilers for <b>sequential</b> <b>software</b> or hardware synthesis tools. In this paper, we develop a static analysis procedure to introduce code optimization techniques to synchronous lan-guages. We develop specialized code optimization proce-dures that can be applied to all kinds of synchronous lan-guages. Similar to the code optimization techniques used for the compilation of <b>sequential</b> <b>software,</b> our procedures are also based on a static data-flow analysis that is adapted to the synchronous programing model. ...|$|E
40|$|This thesis {{concerns}} {{description of}} structure and explanation of data bus I 2 C and 1 -Wire communication, their connection to user´s PC through RS 232 connector and <b>sequential</b> <b>software</b> development among user´s PC and data buses in program language Visual Basic 6. 0. These {{will be added}} to this thesis on compact disk...|$|E
40|$|In {{the quest}} for {{additional}} computational power to provide higher software performance, industry have shifted to multi-core processing units. At the same time, many existing applications still contain sequential software; in these cases, multi-core processors would not deeply improve performances and in general would be under-utilized since software running {{on top of them}} are not conceived to exploit parallelization. In this thesis we aim at providing a way to increase the performance of existing <b>sequential</b> <b>software</b> through parallelization {{and at the same time}} minimizing the cost of the parallelization effort. The contribution of this thesis is a generic parallelization method for introducing parallelization into <b>sequential</b> <b>software</b> using multi-core CPUs and GPUs. As a proof-of-concept we ran an experiment in industrial settings by applying the proposed parallelization method to an existing industrial system running sequential code. Additionally, we compare the method we propose to existing methods for parallelization...|$|E
40|$|Improved {{approach}} to execution of finite-element codes on hypercube and similar concurrent data processors increases efficiency of computation for {{many different types}} of problems. Based on flexible general model of computation on, and communication among, large-node parallel processors. Hybrid combining direct methods within subdomains and preconditioned-conjugate-gradient (PCG) iteration on remaining boundary system to obtain method of solution both robust and efficient. Preserves general structure and function of conventional <b>sequential</b> finite-element-method <b>software.</b> Generalized to both distributed- and shared-memory multicomputers, eliminating degree of machine specificity restricting general usefulness...|$|R
40|$|International audienceWe {{present an}} {{extension}} of Astrée to concurrent C software. Astrée is a sound static analyzer for run-time errors previously limited to <b>sequential</b> C <b>software.</b> Our extension employs a scalable abstraction which covers all possible thread interleavings, and soundly reports all run-time errors and data races: when the analyzer does not report any alarm, the program is proven free from those classes of errors. We show how this extension is able to support a variety of operating systems (such as POSIX threads, ARINC 653, OSEK/AUTOSAR) and report on experimental results obtained on concurrent software from different domains, including large industrial software...|$|R
40|$|<b>Sequential</b> pattern {{analysis}} <b>software</b> for educational event data Many types of educational software {{are capable of}} writing event records to log files as learners interact with the software features. Such log files are potentially valuable to researchers investigating how learners access and manipulate information as they use the software. Educational researchers have explored severa...|$|R
40|$|For {{testing of}} <b>sequential</b> <b>software</b> {{it is usually}} {{sufficient}} to provide the same input (and program state) in order to reproduce the output. For real-time systems, on the other hand, we need also to control, or observe, the timing and order of the inputs. If the system additionally is multitasking, {{we also need to}} take timing and the concurrency of the executing tasks into account...|$|E
40|$|In {{this paper}} we present and discuss a real {{experience}} of reusing <b>sequential</b> <b>software</b> {{in a parallel}} and physically distributed computing environment. Specifically, we have combined the functionalities of two existing systems previously developed at our Department. One, Tracs, is a programming environment for networked, heterogeneous machines that, among other things, is able to generate process farms out of a pure sequential code. The other, SPACE, is a graphical tool that generates sequential Fortran programs for simulating digital transmission systems. We have implemented a tool that restructures SPACE-generated programs to let them match the input required by the Tracs process farm generator. The result is that users of SPACE can transparently take advantage of networked and heterogeneous workstations to run their simulations. We have tackled the problems arising from both parallelism and distribution. The techniques we have used can be easily applied to any problem that can be modelled according to the process farm paradigm. Moreover, our experience shows that the Tracs framework may constitute a sound basis for facilitating engineering efforts on the reuse of <b>sequential</b> <b>software</b> in distributed environments. ...|$|E
40|$|S-Net is a {{coordination}} {{language that}} aims at reconciling the legacy world of <b>sequential</b> <b>software</b> and programming techniques with the hardware {{reality in the}} many-core era. This is achieved through a near-complete separation of conventional application programming from concurrency-related concerns. Sequential legacy code {{as well as new}} code written in a conventional concurrency-agnostic style is made fit for efficient execution on modern many-core systems through a high-level coordination layer based on stream processing...|$|E
40|$|A PyMPI-based {{approach}} for parallel interactive molecular dynamics (MD) simulations is proposed, derived for the ADKS <b>sequential</b> MD <b>software.</b> The ADKS software allows the simulation and interactive visualization of complex phenomena as fractures and grain boundary behaviour in solids. The simulation engine was parallelized using the MPI (Message assing Interface) communication library. A finite automata model represents {{the interaction between}} the user interface and the simulation engine. The PyMPI extends the Python language for the MPI environment and it is used to integrate the user interface and the parallel simulation engine. Performance results are shown without/with visualization for execution in a distributed memory parallel machine...|$|R
40|$|We {{present the}} work {{performed}} {{in the context of}} a three month internship funded by IRIT-CNRS done at CERFACS-ENSEEIHT located in Toulouse (France). The first part of this work has consisted of in the integration of up-to-date <b>sequential</b> ordering <b>software</b> into MUMPS: SCOTCH from F. Pellegrini (LaBRI- Bordeaux), PORD from Y. Schulze (Padenborn University- Germany), MeTiS from G. Karypis and V. Kumar (University of Minesota) and Approximate Min. Fill (Toulouse). In the second part, the influence of the ordering software choice on the size of the factorized matrices and on the scalability has been studied on a Cray T 3 E from NERSC (Lawrence Berkele...|$|R
40|$|This paper {{presents}} a concept {{and implementation of}} an object-oriented software environment for the parallel nite element modeling on networks (clusters) of workstations. This environment {{is an extension of}} the <b>sequential</b> NuscaS <b>software,</b> previously developed in the Technical University of Czestochowa. The domain decomposition technique and iterative methods of solving large sparse linear systems are used to develop the parallel kernel of the environment. The application of the object-oriented approach allows mechanisms supporting parallelism to be transparent for developers of new application modules. The performance results obtained for the simulation of solidication of castings are promising, and indicate that a signicant reduction in runtime can be achieved for suciently large meshes. ...|$|R
30|$|Concurrent {{programming}} puts {{demands on}} software debugging and testing, as concurrent software may exhibit problems {{not present in}} <b>sequential</b> <b>software,</b> e.g., deadlocks and race conditions. In aiming to increase efficiency and effectiveness of debugging and bug-fixing for concurrent software, a deep understanding of concurrency bugs, their frequency and fixing-times would be helpful. Similarly, to design effective tools and techniques for testing and debugging concurrent software, understanding the differences between non-concurrency and concurrency bugs in real-word software would be useful.|$|E
40|$|Business {{demands for}} better {{computing}} power because {{the cost of}} hardware is declining day by day. Therefore, existing <b>sequential</b> <b>software</b> are either required to convert to a parallel equivalent and should be optimized, or a new software base must be written. The factors outlined in this paper are analyzed the current business demands and need of parallelism of existing sequential source code. To address these requirements, we reviewed the ongoing research in parallelization and we conclude some solution approaches...|$|E
40|$|The {{expensive}} reengineering of the <b>sequential</b> <b>software</b> and {{the difficult}} parallel programming {{are two of}} the many technical and economic obstacles to the wide use of HPC. We investigate the chance to improve in a rapid way the performance of a numerical serial code for the simulation of the transport of a charged carriers in a Double-Gate MOSFET. We introduce the Drift-Diffusion-Schrödinger-Poisson (DDSP) model and we study a rapid parallelization strategy of the numerical procedure on shared memory architectures...|$|E
40|$|The {{objective}} {{of this research is}} to produce an early reliability assessment of a <b>sequential</b> assembly of <b>software</b> components using limited component execution-related information and considering the expected assembly use. Accomplishing this objective provides quantitative means to support design decisions and to improve the component selection process. The execution-related information, called execution traces, is gathered during the component testing process...|$|R
50|$|The 120-cell is a 4-D {{geometric}} figure (4-polytope) {{composed of}} 120 dodecahedrons, {{which in turn}} is a 3-D figure composed of 12 pentagons. The 120-cell is the 4-D analogue of the dodecahedron {{in the same way that}} the tesseract (4-cube) is the 4-D analogue of the cube. The 4-D 120-cell <b>software</b> <b>sequential</b> move puzzle from Gravitation3d is therefore the 4-D analogue of the Megaminx dodecahedral 3-D puzzle.|$|R
40|$|Concurrency {{annotations}} are {{inserted into}} otherwise sequential object-oriented code, inducing a concurrent semantics {{that is very}} close to the original sequential semantics. This facilitates integrated engineering of <b>sequential</b> and concurrent <b>software,</b> in particular reuse of code across the boundary between concurrency and sequentiality. Concurrency annotations also blend well with inheritance, giving an additional boost to reusability. The annotations approach to reusable concurrent software is presented using Eiffel as the sequential base for a concurrent language called CEiffel. Thus: Eiffel + annotations =CEiffel...|$|R
40|$|The {{expensive}} reengineering of the <b>sequential</b> <b>software</b> and {{the difficult}} parallel programming {{are two of}} the many technical and economic obstacles to the wide use of HPC. We investigate the chance to improve, in a rapid way, the performance of a numerical serial code modelling semiconductor devices, exploiting the parallel features of shared memory architectures. OpenMP seems to be the good choice in order to guarantee the portability, {{that is one of the}} big issues in parallel computing...|$|E
30|$|Testing and {{debugging}} concurrent software {{are faced}} with a variety of challenges [1]. These challenges concern different aspects of software testing and debugging, such as parallel programming [2], performance testing, error detection [3] and more. Since concurrent software exhibit more non-deterministic behavior and non-deterministic bugs are generally viewed to be more challenging than other types of bugs [4 – 6], testing and debugging concurrent software are also considered to be more challenging compared to testing and debugging of <b>sequential</b> <b>software.</b>|$|E
40|$|Multicore {{architectures}} {{are becoming}} available in embedded systems. However, parallelizing <b>sequential</b> <b>software</b> is a challenging task. A structured approach {{is needed to}} exploit parallel opportunities. Therefore we propose a topdown approach based on a layered model of parallel design patterns. As a proof of concept this approach has been applied {{on a number of}} algorithms including the Fast Fourier Transformation. The FFT algorithm has been implemented parallel on a Linux based embedded system while others were implemented in a freestanding environment. status: publishe...|$|E
40|$|Abstract. We {{describe}} a domain decomposition (DD) algorithm {{for use in}} the parallel adaptive meshing paradigm of Bank and Holst [3, 4]. Our algorithm has low communication, makes extensive use of existing sequential solvers, and exploits in several important ways data generated as part of the adaptive meshing paradigm. Numerical examples illustrate the effectiveness of the procedure. Key words. Domain decomposition, Bank–Holst algorithm, parallel adaptive grid generation. AMS subject classifications. 65 N 50, 65 N 30 1. Introduction. In this work, we {{describe a}} domain decomposition (DD) algorithm {{for use in the}} parallel adaptive meshing paradigm described in [3, 4]. The Bank-Holst paradigm provides a general approach to parallel adaptive meshing in which communication costs are kept low, and where <b>sequential</b> adaptive <b>software</b> (such as the software package pltmg used in this work) can be employed withou...|$|R
40|$|We {{describe}} parallel software, PMIRKDC, {{for solving}} boundary value ordinary differential equations (BVODEs). This software {{is based on}} the package, MIRKDC, which employs monoimplicit Runge-Kutta schemes within a defect control algorithm. The primary computational costs involve the treatment of large, almost block diagonal (ABD) linear systems. The most significant feature of PMIRKDC is the replacement of <b>sequential</b> ABD <b>software,</b> COLROW, with new parallel ABD software, RSCALE, based on a parallel block eigenvalue rescaling algorithm. Other modifications involve parallelization of the setup of the ABD systems and solution interpolants, and defect estimation. Numerical results show almost linear speedups. Keywords: Parallel software, boundary value ordinary differential equations, almost block diagonal linear systems, Runge-Kutta methods. AMS Subject Classifications: 65 L 10, 65 Y 05 1 Introduction In this paper we consider the development of software for the efficient numerical s [...] ...|$|R
40|$|International audienceFormal methods, and in {{particular}} sound static analyses, have been recognized by Certification Authorities as reliable methods to certify embedded avionics <b>software.</b> For <b>sequential</b> C <b>software,</b> industrial static analyzers, such as Astrée, already exist and are deployed. This {{is not the case}} for concurrent C software. This article discusses the requirements for sound static analysis of concurrent embedded software at Airbus and presents AstréeA, an extension of Astrée with the potential to address these requirements: it is scalable and reports soundly all run-time errors with few false posi-tives. We illustrate this potential on a variety of case studies targeting different avionics software components, including large ARINC 653 and POSIX threads applications, and a small part of an operating system. While the experiments on some case studies were conducted in an academic setting, others were conducted in an industrial setting by engineers, hinting at the maturity of our approach...|$|R
40|$|Parallelization of {{existing}} <b>sequential</b> <b>software</b> {{is a complex}} task that typically requires intensive manual effort to achieve optimal performance. Researchers have sought to build parallelizing compilers that would completely automate the parallelization process. 1 - 3 These compilers typically struggle to exploit available parallelism {{because of the difficulty}} of proving parallel transforms ’ correctness and profitability. This difficulty is demonstrated in a comparison we performed between the output of Intel C++ Compiler (icc), a state-of-the-art, commercial parallelizing compiler, and manual parallelization efforts on the Rodinia benchmark suite. ...|$|E
40|$|We {{present a}} <b>sequential</b> <b>software</b> release {{procedure}} that certifies with some confidence level {{that the next}} error is not occurring within a certain time interval. Our procedure is defined {{in such a way}} that the release time is optimal for single stages and the global risk can be controlled. We assume that the failure detection process can be modeled as a General Order Statistics model where its unknown parameters are studied from a Bayesian point of view. We show how to implement our procedure and study its performance via simulation...|$|E
40|$|This Technical Report {{presents}} {{a series of}} case studies in the formal, mathematical verification of formal specifications of <b>sequential</b> <b>software</b> systems. Each of the five case studies is formally specified in Z and VDM, and various issues in formal specification are discussed. Analysis and verification techniques from the two methods are applied to the case studies, and issues {{in the use of}} such techniques are discussed. Finally, suggestions are made about ways to combine the individual strengths of Z and VDM to make the verification task stronger and simpler...|$|E
40|$|The {{process of}} {{eliciting}} client language toward change (change talk [CT]) is implicated as a causal mechanism in motivational interviewing (MI) and brief motivational interventions (BMI). We investigated {{the articulation of}} counselor behaviors and CT during BMI with young men. We coded 149 sessions using the Motivational Interviewing Skill Code and summarized these codes into three counselor categories (MI-consistent [MICO], MI-inconsistent [MIIN], other) and three client categories (CT, counter CT [CCT], follow/neutral [F/N]). We then computed immediate transition frequencies and odds ratios using <b>sequential</b> analysis <b>software.</b> CT was significantly more likely following MICO behaviors, whereas MIIN behaviors only led to CCT and F/N. This strongly supports the use of MI skills to elicit CT during BMI with young men, whose speech also predicted counselor behaviors (particularly CT to MICO and CCT to MIIN). Additional analyses showed that among MICO behaviors, reflective listening may be a particularly powerful technique to elicit CT...|$|R
40|$|Abstract: We {{present an}} {{operational}} semantics of the membrane systems, using an appropriate notion of configurations and sets of inference rules {{corresponding to the}} three stages of an evolution step in membrane systems: maximal parallel rewriting step, parallel communication of objects through membranes, and parallel membrane dissolving. We define various arithmetical operations over multisets {{in the framework of}} membrane systems, indicating their complexity and presenting the membrane systems which implement the arithmetic operations. Finally we discuss and compare various <b>sequential</b> and parallel <b>software</b> simulators of the membrane systems, emphasizing their specific features...|$|R
40|$|In {{this paper}} we {{describe}} a methodology for constructing efficient algorithms applied in an elementary course on Data Structures and Algorithms. This methodology attempts {{to show the}} essential steps in a <b>sequential</b> process in <b>software</b> development from an informally stated problem, via a formal problem specification, to a final efficient program. Students of the course {{are expected to have}} at least a year's experience in programming high level languages and elementary logic and calculus. We describe a prototype, AyDA, which assists in the construction of algorithms starting from the proposed methodology...|$|R
