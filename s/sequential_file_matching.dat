0|467|Public
40|$|INTRODUCTION 3 (2) - 1 THE INDEXED-SEQUENTIAL FILE The indexed-sequential file design {{attempts}} {{to overcome the}} access problem inherent in the <b>sequential</b> <b>file</b> organization without losing all the benefits and tradition associated with <b>sequential</b> <b>files.</b> Two features {{are added to the}} organization of the <b>sequential</b> <b>file</b> to arrive at this third file organization type. One additional feature is an index to the file to provide better random access; the other is an overflow area to provide a means to handle additions to the file. Figure 3 - 6 shows a particular example of an indexed-sequential file. We find in this figure the three important components: the <b>sequential</b> <b>file,</b> the index, and the overflow area. The sketch also has a number of details which will appear in later discussions. To be expanded to 200 pt for Figure space was Fig. 3 - 1 Figure 3 (2) - 1 Components of an Indexed <b>Sequential</b> <b>File</b> !!new?? Sec. 3 (2) - 1 The Indexed-Sequential Fi...|$|R
5000|$|A <b>sequential</b> <b>file</b> is a {{data file}} {{that can be}} linearly read from start to finish. [...] files are {{commonly}} used to store documents or text files created by a word processor or other such editor. A <b>sequential</b> <b>file</b> is analogous to a flat file in Linux or UNIX, in {{that it has no}} specialized internal structure. It is not possible to position to any arbitrary location in a <b>sequential</b> <b>file,</b> as there is no analog of the [...] kernel call found in UNIX-like operating systems.|$|R
50|$|<b>Sequential</b> <b>files</b> are {{somewhat}} more efficient {{in terms of}} space than line files and can be more efficient in terms of CPU time too when compared with large disorganized line files. But {{the main reason for}} the existence of SEQ files is that they supported long lines (up to 32767 characters) before line <b>files</b> did. <b>Sequential</b> <b>files</b> were less common once line files could support long lines. <b>Sequential</b> <b>files</b> are also used to force new lines to be appended {{to the end of the}} file without the need to give the line number range (LAST+1).|$|R
40|$|When <b>sequential</b> <b>file</b> {{structures}} must be {{used and}} binary searching is not feasible, jump searching becomes an appealing alternative. This paper explores variants of the classic jump searching scheme where the optimum jump size is the square root {{of the number of}} records. Multiple level and variable size jump strategies are explored, appropriate applications are discussed and performance is evaluated. Key Words and Phrases: jump searching, <b>sequential</b> <b>files,</b> file management, search strategies, databas...|$|R
5000|$|<b>Sequential</b> <b>files,</b> {{in which}} records {{are stored in}} {{consecutive}} slots.|$|R
50|$|<b>Sequential</b> <b>files</b> ($CREATE name TYPE=SEQ) are line-oriented files {{with the}} first line number being implicitly 1 and {{incremented}} by 1 for each line. Once written {{the length of a}} line (other than the last line of a file) can not be changed, although any line can be replaced by a line of the same length. <b>Sequential</b> <b>files</b> are generally only readable sequentially from start to end, or written by appending to the end. One can, however, request a reference for the current line of a <b>sequential</b> <b>file,</b> and use that reference to jump to that specific location again.|$|R
5000|$|... perform <b>sequential</b> <b>file</b> I/O (QSAM) {{operations}} from {{a script}} to a user-defined, external dataset; ...|$|R
5000|$|Data: By {{splitting}} {{a single}} <b>sequential</b> <b>file</b> into smaller data files to provide parallel access ...|$|R
50|$|This data is then {{periodically}} dumped to <b>sequential</b> <b>files</b> (for example, tape drives) {{using the}} IFASMFDP SMF Dump Utility (or IFASMFDL when using log streams). IFASMFDP {{can also be}} used to split existing SMF <b>sequential</b> <b>files</b> and copy them to other files. The two dump programs produce the same output, so it does not involve changes in the SMF records elaboration chain, other than changing the JCL with the call of the new dump utility.|$|R
5000|$|... {{to support}} only {{selected}} commands of a manager, {{such as the}} ability to load and unload records from a <b>sequential</b> <b>file.</b>|$|R
5000|$|... {{support for}} BIL (band {{interleaved}} by line files) and BSQ (band <b>sequential</b> in one <b>file)</b> {{added to the}} individual band <b>sequential</b> <b>files</b> supported by the earlier version; all formats can be 8-16 bits per pixel including swapped word order ...|$|R
5000|$|Insert+Cat - {{it allows}} {{creating}} a text file from a diskette directory, similarly, it allows {{to make a}} list of files on cassette. Additionally, it allows to convert <b>sequential</b> [...]Q <b>files</b> into text file (.Q <b>files</b> are <b>sequential</b> <b>files</b> used by diskette units Didaktik 40 and Didaktik 80).|$|R
50|$|SAFR {{can access}} {{multiple}} types of mainframe-based data, including DB2. For example, it can read <b>sequential</b> <b>files</b> {{based on the}} input format specified, then look up certain fields in a VSAM file or in another <b>sequential</b> <b>file.</b> SAFR can produce output in yet another format with some additional calculations, as required. The entire process is called a VIEW, {{and any number of}} VIEWs can be defined. SAFR also commonly processes data from other platforms that are fed into its engine.|$|R
50|$|Sequential With Line Number files ($CREATE name TYPE=SEQWL) {{are similar}} to <b>Sequential</b> <b>Files,</b> except that their line numbers were {{explicitly}} stored. They have all the restrictions of <b>Sequential</b> <b>Files,</b> except that the line number could be specifically supplied when writing to a file (as {{long as it is}} greater than the last line number written to the file). Unlike Line Files, the first read of an SEQWL file returns the first line of the file, even if it was negative.|$|R
5000|$|MTS {{supports}} {{three types}} of <b>file,</b> line <b>files,</b> <b>sequential</b> <b>files,</b> and <b>sequential</b> with line number files, but line files were {{by far the most}} common: ...|$|R
5000|$|An undocumented {{internally}} used file type {{similar in}} structure to a <b>sequential</b> <b>file.</b> Creation of this file type must {{be accomplished by}} direct manipulation of the disk directory.|$|R
40|$|The {{performance}} of batched search {{when applied to}} index <b>sequential</b> <b>files</b> is studied. Analysis provides exact formulae {{for the cost of}} searching when batching is applied {{as a function of the}} magnitude of the query and time. The analysis takes into account (a) accesses to the overflow area only, and (b) accesses to both primary and overflow area, as well as whether the records of the query are (a) distinct, or (b) nondistinct. Batched search is compared with the simple on-line search and a proposal is stated concerning the reorganization of index <b>sequential</b> <b>files...</b>|$|R
40|$|This paper {{investigates the}} most {{efficient}} way to read and write large <b>sequential</b> <b>files</b> using the Windows NT^TM 4. 0 File System. The study explores the performance of Intel Pentium Pro^TM based memory and IO subsystems, including the processor bus, the PCI bus, the SCSI bus, the disk controllers, and the disk media. We provide details of the overhead costs at various levels of the system and examine a variety of the available tuning knobs. The report shows that NTFS out-of-the box read and write performance is quite good, but overheads for small requests can be quite high. The best performance is achieved by using large requests, bypassing the file system cache, spreading the data across many disks and controllers, and using deep-asynchronous requests. Draft Sequential IO Paper 3 07 / 04 / 99 1. Introduction This paper discusses how to do high-speed <b>sequential</b> <b>file</b> access using the Windows NT^TM File System (NTFS). Highspeed <b>sequential</b> <b>file</b> access is important for bulk data operations [...] ...|$|R
40|$|The BNL Archive and Dissemination (BNLAD) System was {{designed}} to operate on a homogeneous distributed data base in a computer network. Its primary function is to present a uniform logical and physical view of already existing <b>sequential</b> <b>files</b> of data, so [...] . "BNL- 22612; AMD 757 R 1. ""March 1977. "Includes bibliographical references (p. 21) The BNL Archive and Dissemination (BNLAD) System {{was designed}} to operate on a homogeneous distributed data base in a computer network. Its primary function is to present a uniform logical and physical view of already existing <b>sequential</b> <b>files</b> of data, so [...] . Mode of access: Internet...|$|R
5000|$|The {{first step}} was to create a format. This command allowed the user to type a form {{directly}} onto the screen, using fixed text for headings, and indicating where variable data fields would get populated from the data file. The format could be associated with a data file created by an existing application, or used to create a new one by entering records interactively. v1.0 supported only <b>sequential</b> <b>files,</b> but search performance was predictably terrible, and multi-key indexed <b>sequential</b> <b>files</b> were quickly added in v2.0. Once the format was created and associated with a file, the user employed intuitive commands such as: ...|$|R
5000|$|In {{the example}} above, SYSIN control cards {{are coming from}} an in-stream file, but you can instead point to any <b>sequential</b> <b>file</b> or a PDS member {{containing}} control cards or a temporary data-set, if you wish.Example of using SYSIN files would be something like this: ...|$|R
40|$|Brief {{descriptions}} of the I/O requirements for four production oceanography programs running at Oregon State University are presented. The applications all rely exclusively on array-oriented, <b>sequential</b> <b>file</b> operations. Persistent files are used for checkpointing and movie making, while temporary files are used to store out-of-core data...|$|R
5000|$|Standard {{executable}} were scanned, or, {{one could}} use up to twenty <b>file</b> <b>matching</b> patterns ...|$|R
40|$|This {{retrieval}} system builds, updates, retrieves, and performs basic statistical analyses on blood, urine, and diet parameters for the M 071 and M 073 Skylab and Apollo experiments. This system permits data entry from cards {{to build an}} indexed <b>sequential</b> <b>file.</b> Programs are easily modified for specialized analyses...|$|R
5000|$|... is a Transact-SQL {{statement}} that implements a bulk data-loading process, inserting multiple rows into a table, reading data from an external <b>sequential</b> <b>file.</b> Use of [...] results in better performance than processes that issue individual [...] statements for each row to be added. Additional details {{are available in}} MSDN.|$|R
40|$|Primary file organization: – {{determines how}} {{the files of}} records are {{physically}} placed on the disk – heap <b>files,</b> <b>sequential</b> <b>files</b> (search key), hashed files (hash key) • Secondary organization: – allows efficient access to the records of a file based on alternate fields that those used for the primary file organizatio...|$|R
5000|$|A {{relative}} file is {{a variation of}} the <b>sequential</b> <b>file</b> type, in which an indexing mechanism referred to as side-sectors is present to permit record-oriented access. Records may be a maximum of 254 bytes in size and are addressed by a one-based cardinal number, permitting true random access to any part of the file.|$|R
5000|$|Files had various types, like text <b>files</b> {{and index}} <b>sequential</b> data <b>files.</b>|$|R
5000|$|Loading {{pointers}} into memory {{instead of}} the slow <b>sequential</b> text <b>file</b> methology ...|$|R
40|$|A new hidden-line {{algorithm}} is proposed for illustrating objects consisting of plane faces. The algorithm determines the degree of edge and classifies edges and faces into contoural and non-contoural. To reduce memory requirements, <b>sequential</b> <b>files</b> and sorting are used. The {{algorithm is}} particularly intended for illustrating complex objects, such as curved surfaces approximated by plane face...|$|R
5000|$|Partitioned {{datasets}} (PDS) were sequential datasets {{subdivided into}} [...] "members" [...] {{that could be}} processed as <b>sequential</b> <b>files</b> in their own right. The most important use of PDS was for program libraries - system administrators used the main PDS {{as a way to}} allocate disk space to a project and the project team then created and edited the members.|$|R
5000|$|They had {{to support}} {{a wide range of}} {{application}} requirements. For example, some applications only needed to read through <b>sequential</b> <b>files</b> from start to finish; others needed fast, direct access to specific records in very large files; and a few applications spent nearly all their time doing calculations, with very little reading or writing of files.|$|R
50|$|Wildcard {{completion}} is a {{generalization of}} path completion, where an expression matches {{any number of}} files, using any supported syntax for <b>file</b> <b>matching.</b>|$|R
40|$|A {{model for}} an index <b>sequential</b> <b>file</b> {{employing}} multiple overflow chains per bucket is developed. This model {{is used to}} analyse the effects of insertions and deletions {{on the cost of}} successful and unsuccessful search in terms of block accesses. Numerical results are obtained illustrating the performance. The performance is also compared with that of an ISAM file using only one overflow chain per bucket...|$|R
40|$|RESTRUCT is a {{software}} tool that reformats <b>sequential</b> <b>files.</b> It {{can operate as}} a stand alone process or function as a filter in a sequence of operations. Using RESTHUC'l', one can express simple file transformations in a simple way. 1 t is driven by a specification-based data description language that includes record description at three levels of detail. record redefinition and field conversion capabilities...|$|R
50|$|When the {{integrals}} are computed by the integrals program {{they are}} written {{out to a}} <b>sequential</b> <b>file</b> along with the p,q,r,s indices which define them. The order in which the integrals are computed {{is defined by the}} algorithm used in the integration program. The most efficient algorithms do not compute the integrals in order, that is such that the p,q,r and s indices are ordered.|$|R
