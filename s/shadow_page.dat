27|86|Public
2500|$|Tolkien, J. R. R. [...] The Return of the <b>Shadow,</b> <b>page</b> 240. [...] Ed. Christopher Tolkien. [...] Boston: Houghton Mifflin, 1988.|$|E
50|$|Starting in version 6.0, shadow paging {{was used}} instead of pre-imaging, {{and it is still}} used to this day. Instead of copying the page into a {{temporary}} file, the next spare physical location in the database file was found and the page was written to this location. This page is called a <b>shadow</b> <b>page</b> because it still has not had its location written to the file's PAT. Once the update to the <b>shadow</b> <b>page</b> completed, the PAT was updated and the entry recorded in the PAT of the next available and current physical page in the file. However, if a system failure occurred while doing the update to the <b>shadow</b> <b>page</b> the PAT would not be updated and so the change would be dropped because the current and next entry was not updated in the PAT.|$|E
5000|$|Shadow paging is a copy-on-write {{technique}} for avoiding in-place updates of pages. Instead, when a page {{is to be}} modified, a <b>shadow</b> <b>page</b> is allocated. Since the <b>shadow</b> <b>page</b> has no references (from other pages on disk), it can be modified liberally, without concern for consistency constraints, etc. When the page is ready to become [...] durable, all pages that referred to the original are updated {{to refer to the}} new replacement page instead. Because the page is [...] "activated" [...] only when it is ready, it is atomic.|$|E
40|$|In {{this paper}} we present several new ideas about {{concurrent}} <b>shadow</b> <b>paging</b> as a crash recovery method in databases. We show {{how to use}} <b>shadow</b> <b>paging</b> in a multi-user environment and describe several optimizations and ideas which significantly improve the performance and general usability of <b>shadow</b> <b>paging,</b> making it very competitive to other methods in crash recovery. <b>Shadow</b> <b>paging</b> with our optimizations appears to be much faster than log-based solutions, and {{it would seem to}} be very generally applicable. We also present some new, potentially very useful ideas which can be efficiently implemented with <b>shadow</b> <b>paging</b> but not with logging. 1 Introduction The idea of <b>shadow</b> <b>paging</b> is to never overwrite valid data. A page table is used to map logical page numbers to physical page numbers, and modified pages are always written to unused parts of the database. The page table is updated atomically at transaction commit to reflect the new state of the database. This allows arbitrary atomic transa [...] ...|$|R
40|$|<b>Shadow</b> <b>paging</b> is {{a method}} for {{implementing}} atomic transactions in databases. In previous studies {{it has been found}} to perform rather poorly. However, many of the reasons that originally hampered its performance have become obsolete due to technological development. Several ideas are presented in this paper which considerably improve the performance of <b>shadow</b> <b>paging.</b> The page table allows all writes to be done sequentially, resulting in very significant speedups, and variable-size pages offer a solution to clustering problems. A simple performance analysis indicates that in many common applications the performance achieved using these optimizations can be twice or more the performance of log-based approaches. 1 Introduction 1. 1 Background The original idea of <b>shadow</b> <b>paging</b> was presented by Lorie [7]. It was implemented in the System R database manager, which supported concurrent operation using a complicated multi-user <b>shadow</b> <b>paging</b> system with logs on directory pages [3]. The implem [...] ...|$|R
40|$|This paper {{describes}} in detail how to implement multiple concurrent transactions with fine-granularity locking in a database system using <b>shadow</b> <b>paging</b> for crash recovery. The basic {{idea is to}} store the updates separately until the transaction requests to commit, at which time the changes are patched to the global database. Commit batching is used to achieve reasonable performance; its gains are much higher with <b>shadow</b> <b>paging</b> than with log-based systems. Due to early releasing of locks, locking durations do not increase because of commit batching. 1 Introduction Traditionally, <b>shadow</b> <b>paging</b> has been considered to have poor performance and to be unsuitable for large multi-user systems [1, 3, 5, 6]. However, Kent [5, 6] has shown how to use <b>shadow</b> <b>paging</b> efficiently in a multiuser environment using page-level locking (but found it to have inferior performance compared to log-based approaches). Since then, main memory sizes have increased due to technological development, and the entire [...] ...|$|R
50|$|Second Level Address Translation (SLAT), {{also known}} as nested paging, is a hardware-assisted {{virtualization}} technology which {{makes it possible to}} avoid the overhead associated with software-managed <b>shadow</b> <b>page</b> tables.|$|E
50|$|A VMware {{research}} paper found that RVI offers up to 42% gains in performance compared with software-only (<b>shadow</b> <b>page</b> table) implementation. Tests conducted by Red Hat showed a doubling in performance for OLTP benchmarks.|$|E
50|$|Some of {{the above}} hypervisors {{actually}} require SLAT {{in order to work}} at all (not just faster) as they do not implement a software <b>shadow</b> <b>page</b> table; the list is not fully updated to reflect that.|$|E
50|$|<b>Shadow</b> <b>paging</b> is also {{similar to}} purely {{functional}} data structures, in that in-place updates are avoided.|$|R
40|$|Recently, a {{flash memory}} {{has become a major}} {{database}} storage in building portable information devices because of its non-volatile, shock-resistant, power-economic nature, and fast access time for read operations. We propose a new scheme called flash memory <b>shadow</b> <b>paging</b> (FMSP) scheme for efficient page management in {{a flash memory}} database environment. We improved traditional <b>shadow</b> <b>paging</b> schemes by reusing old data pages which are supposed to be disposed in the course of writing a new data page in the flash memory file systems. In order to reuse these data pages, we devised a deferred cleaning mechanism and an operation interface which is geared to existing flash file systems. FMSP contributes to overcome the two drawbacks of traditional <b>shadow</b> <b>paging</b> schemes, additional space overhead and slow access caused by page distribution. 1...|$|R
5000|$|In version 6.0 {{and later}} files, more {{physical}} pages can exist than are actually used. This is because with <b>shadow</b> <b>paging</b> some {{pages in the}} system may not have an entry in the PAT. These pages are marked as [...] "Extra" [...] pages, and are used up before space for new pages is allocated.|$|R
5000|$|Operating system {{virtualization}} is {{the process}} of simulating the operation of a computer within another computer. This technique is useful for someone who wants to run more than one type of operating system on his/her PC concurrently. <b>Shadow</b> <b>page</b> tables are often used in simulating more than one operating system on a single set of memory and processor. A page table is used by an operating system to map the virtual memory, the actual memory used by programs and the operating system to store information, to its location on the physical memory, the hardware-specific memory stored in bytes on the RAM (Random Access Memory). [...] A <b>shadow</b> <b>page</b> table is a pseudo-page table within a computer's main page table which allows a system to run more than one kind of operating system concurrently.|$|E
50|$|One of {{the main}} driving factors for the {{development}} of hardware assists for the System/370 was virtual memory itself. When the guest was an operating system that itself implemented virtual memory, even non-privileged instructions could experience longer execution times - a penalty imposed by the requirement to access translation tables not used in native execution (see <b>shadow</b> <b>page</b> tables).|$|E
50|$|Modern {{processors}} use {{the concepts}} of physical memory and virtual memory; running processes use virtual addresses and when an instruction requests access to memory, the processor translates the virtual address to a physical address using a page table or TLB. When running a virtual system, it has allocated virtual memory of the host system {{that serves as a}} physical memory for the guest system, and the same process of address translation goes on also within the guest system. This increases the cost of memory access since the address translation needs to be performed twice once inside the guest system (using software-emulated <b>shadow</b> <b>page</b> table), and once inside the host system (using hardware page table).|$|E
50|$|WAL allows updates of a {{database}} {{to be done}} in-place. Another way to implement atomic updates is with <b>shadow</b> <b>paging,</b> which is not in-place. The main advantage of doing updates in-place is that it reduces the need to modify indexes and block lists.|$|R
40|$|Abstract. With the {{development}} of flash technologies, flash disks have become an alternative to hard disk as external storage media. Because of the unique characteristics of flash disks such as fast random read ac-cess and out-place update, <b>shadow</b> <b>paging</b> technology can be adopted to support transaction recovery in flash-based DBMS. Inspired by <b>shadow</b> <b>paging</b> and logging, we propose a new transaction commit model named MixSL {{which can be used}} in databases built on MLC flash disks. Based on MixSL, we detail normal processing, garbage collection and recov-ery. For improving system performance and raising the utilization ratio of flash disks, we extend MixSL to support group commit. Our perfor-mance evaluation based on the TPC-C benchmark shows that MixSL outperforms the state-of-the-art recovery protocols...|$|R
5000|$|In {{computer}} science, <b>shadow</b> <b>paging</b> is {{a technique}} for providing atomicity and [...] durability (two of the ACID properties) in database systems. A page in this context refers to a unit of physical storage (probably on a hard disk), typically {{of the order of}} 1 to 64 KiB.|$|R
5000|$|Since the Haswell {{microarchitecture}} (announced in 2013), Intel {{started to}} include VMCS shadowing as {{a technology that}} accelerates nested virtualization of VMMs. The virtual machine control structure (VMCS) is a data structure in memory that exists exactly once per VM, while it is managed by the VMM. With every change of the execution context between different VMs, the VMCS is restored for the current VM, defining {{the state of the}} VM's virtual processor. [...] As soon as more than one VMM or nested VMMs are used, a problem appears in a way similar to what required <b>shadow</b> <b>page</b> table management to be invented, as described above. In such cases, VMCS needs to be shadowed multiple times (in case of nesting) and partially implemented in software in case there is no hardware support by the processor. To make shadow VMCS handling more efficient, Intel implemented hardware support for VMCS shadowing.|$|E
5000|$|A {{number of}} key data {{structures}} used by a processor need to be shadowed. Because most operating systems use paged virtual memory, and granting the guest OS {{direct access to the}} MMU would mean loss of control by the virtualization manager, some of the work of the x86 MMU needs to be duplicated in software for the guest OS using a technique known as <b>shadow</b> <b>page</b> tables. This involves denying the guest OS any access to the actual page table entries by trapping access attempts and emulating them instead in software. The x86 architecture uses hidden state to store segment descriptors in the processor, so once the segment descriptors have been loaded into the processor, the memory from which they have been loaded may be overwritten {{and there is no way}} to get the descriptors back from the processor. Shadow descriptor tables must therefore be used to track changes made to the descriptor tables by the guest OS.|$|E
30|$|The {{hypervisor}} uses <b>shadow</b> <b>page</b> {{tables to}} convert a guest VM physical address to an actual machine address. <b>Shadow</b> <b>page</b> tables are accessible from the hypervisor {{and can be}} manipulated easily. The introspection code can be secured from guest VM-based applications using shadow tables and Intel VT technology features. Intel's VT support and virtual memory protection {{can be used to}} secure the monitoring code.|$|E
40|$|This paper {{presents}} two algorithms {{for maintaining}} Btree index consistency in a DBMS {{which does not}} use write-ahead logging (WAL). One algorithm is similar to <b>shadow</b> <b>paging,</b> but improves performance by integrating shadow meta-data with index meta-data. The other algorithm uses a two-phase page reorganization scheme to reduce the space overhead caused by <b>shadow</b> <b>paging.</b> Although designed for the POSTGRES storage system, these algorithms would also be useful in a WAL-based storage system as support for logical logging. Measurements of a prototype implementation and estimates {{of the effect of}} the algorithms on large trees show that they will have little impact on data manager performance. 1. Introduction The POSTGRES storage system uses no-overwrite techniques to combine support for historical data with support for transaction management [13]. Instead of write-ahead log processing, POSTGRES recovers from failures by falling back to the latest version of its preserved historical data. Usin [...] ...|$|R
40|$|<b>Shadow</b> <b>paging</b> has {{a number}} of {{desirable}} properties, of which snapshots are discussed in this paper. It is possible to take a transactionconsistent snapshot of a database in a few microseconds. This can be used to execute arbitrary read-only transactions with full consistency without any locking and only minimal overhead. A related application is dumping the database; it is shown that the page table allows very efficient multi-level incremental dumping of the database without disturbing normal transaction processing. Algorithms are given to solve the associated problems. Modification of snapshots is also discussed; this may turn out to have some interesting applications. 1 Introduction Traditionally, <b>shadow</b> <b>paging</b> has been considered to have poor performance and to be unsuitable for large multi-user systems [3, 7, 11, 12]. However, memory sizes have increased due to technological development, and the entire page table of even a large database can now be kept in main memory. This has re [...] ...|$|R
5000|$|<b>Shadow</b> <b>paging</b> {{is similar}} to the old master - new master batch {{processing}} technique used in mainframe database systems. In these systems, the output of each batch run (possibly a day's work) was written to two separate [...] disks or other form of storage medium. One was kept for backup, and the other was used as the starting point for the next day's work.|$|R
30|$|Nested {{virtualization}} {{of memory}} {{can be divided}} into software-based and hardware-based. Software-based nested virtualization is by extending the <b>shadow</b> <b>page</b> table and adding another layer of memory translation, while hardware-based nested virtualization makes use of the hardware feature support, which is named as EPT by Intel and NPT by AMD (McDougall and Anderson 2010). As the nested <b>shadow</b> <b>page</b> is very inefficient, we are mainly concerned with hardware-based one.|$|E
40|$|With the {{advantage}} of the reusability property of the virtualization technology, users can reuse various types and versions of existing operating systems and drivers in a virtual machine, so as to customize their application environment. In order to prevent users’ virtualization environments being impacted by driver faults in virtual machine, Chariot examines the correctness of driver’s write operations by the method of combining a driver’s write operation capture and a driver’s private access control table. However, this method needs to keep the write permission of <b>shadow</b> <b>page</b> table as read-only, so as to capture isolated driver’s write operations through page faults, which adversely affect the performance of the driver. Based on delaying setting frequently used shadow pages’ write permissions to read-only, this paper proposes an algorithm using <b>shadow</b> <b>page</b> cache to improve the performance of isolated drivers and carefully study the relationship between the performance of drivers and the size of <b>shadow</b> <b>page</b> cache. Experimental results show that, through the <b>shadow</b> <b>page</b> cache, the performance of isolated drivers can be greatly improved without impacting Chariot’s reliability too much...|$|E
40|$|Memory-mapped I/O (MMIO) tracing {{provides}} {{an effective means}} for analyzing and debugging I/O related functions since {{it allows us to}} observe and track the interplay between processors and I/O devices [1]. However, existing MMIO tracing techniques have a serious drawback in multicore systems. Current MMIO techniques commonly use a memory protection mechanism to detect access to an MMIO address area under consideration. Unfortunately, this approach may miss some I/O events and even lead to a data race condition due to inappropriate management of concurrent accesses to the MMIO address area. In this paper, we describe a novel MMIO tracing approach introducing the notion of <b>shadow</b> <b>page</b> table. We use a <b>shadow</b> <b>page</b> table to allow only one processor to have access to a MMIO address area while forbidding other processors’ access to the same MMIO address area. We show how the <b>shadow</b> <b>page</b> table approach can be efficiently implemented on a multiprocessor platform with dual core ARM Cortex A 15 CPU. This work was supported partly by Seoul Creative Human Development Program (HM 120006), and partly by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MEST) (NRF- 2011 - 0015997), and partly the MSIP(Ministry of Science, ICT and Future Planning), Korea, under the C-ITRC(Convergence Information Technology Research Center) (IITP- 2015 - H 8601 - 15 - 1005) supervised by the IITP(Institute for Information & communications Technology Promotion) ...|$|E
40|$|Abstract. Techniques {{similar to}} <b>shadow</b> <b>pages</b> have been {{suggested}} for use in rollback and crash recovery for nested transactions. However, undo/redo log methods have not been presented, though undo/redo logs are widely used for transaction recovery, and perhaps preferable to shadow methods. We develop a scheme of logbased recovery for nested transactions. The resulting design is promising because it requires {{a relatively small number}} of extensions to a similar scheme of recovery for single-level transactions...|$|R
5000|$|If the {{referring}} pages {{must also}} be updated via <b>shadow</b> <b>paging,</b> this procedure may [...] recurse many times, becoming quite costly. One solution, employed by the WAFL file system (Write Anywhere File Layout) is to be lazy about making pages durable (i.e. write-behind caching). This increases performance significantly by avoiding many writes on hotspots {{high up in the}} referential hierarchy (e.g.: a file system superblock) at the cost of high commit latency.|$|R
50|$|Polyhedra IMDB {{achieves}} data persistence {{through the}} use of snapshots and journal logging; Polyhedra Flash DBMS uses <b>shadow</b> <b>paging,</b> with 2 levels of recursion. In addition, Polyhedra can be used in hot-standby configurations for improved availability. The transactional model used by all Polyhedra products ensures atomicity, consistency and isolation (as defined by the ACID properties); durability is enforced in Polyhedra Flash DBMS, while in Polyhedra IMDB clients can choose the durability model when they issue their transactions.|$|R
30|$|Other than this, for the {{execution}} of precopy method, Xen uses some data structure for effective transfer of virtual machine memory pages during virtual machine live migration. Guest page table are managed by guest itself and pointed by CR 3 register. Initially, Xen makes guest page tables read-only and when the guest tries to change or update its page table during migration, a page fault occurs. Xen employs <b>shadow</b> <b>page</b> table under the running virtual machine to log information of updated pages. It uses log of updated pages during migration. Xen also uses another bitmap named dirty log bitmap, which also contains the log of updated or dirty pages. When pages are updated during migration, the changes are propagated to both <b>shadow</b> <b>page</b> table and dirty log bitmap. Both are used to manage transferring of virtual machine pages {{at the time of}} migration and for each iteration bitmap is scanned to locate updated pages for transferring.|$|E
40|$|This thesis {{evaluates the}} {{feasibility}} of doing page sharing between virtual machines. To do this evaluation we proposed two different de-signs: One that is transparent to the guest op-erating system and a paravirtualized one. We implemented one of these based on Potemkin, which is a modification of the Xen virtual ma-chine monitor. In this we find pages eligi-ble for sharing by use of a technique called content-based page sharing. When identical pages are found, the actual sharing of pages is obtained using <b>shadow</b> <b>page</b> tables and Copy-on-Write. Finally the implementation was evaluated and we found no significant over-heads except {{for the use of}} <b>shadow</b> <b>page</b> ta-bles. The paravirtualized design should miti-gate this overhead. As for {{the feasibility of}} page sharing, we car-ried out a series of experiments. These ex-plored sharing under good and bad conditions as well as under synthetic workloads. We con-cluded that page sharing is feasible and that most workloads that have similar kernels and applications have something to share...|$|E
40|$|Abstract—Efficient {{virtualization}} {{of translation}} lookaside buffers (TLBs), a core component of modern hypervisors, {{is complicated by}} the concurrent, speculative walking of page tables in hardware. We give a formal model of an x 64 -like TLB, criteria for its correct virtualization, and outline the verification of a virtualization algorithm using <b>shadow</b> <b>page</b> tables. The verification is being carried out in VCC, a verifier for concurrent C code. I...|$|E
40|$|Contents (pages vii-viii) [...] Preface (page ix) [...] Acknowledgements (pages x-xi) [...] Chapter 1. Beginnings (pages 1 - 10) [...] Chapter 2. Ireland (pages 11 - 24) [...] Chapter 3. South African {{apprenticeship}} (pages 25 - 32) [...] Chapter 4. Trooper G. W., {{cross of}} the Albany Rangers (pages 33 - 43) [...] Chapter 5. Grahamstown: sunshine and <b>shadow</b> (<b>pages</b> 44 - 55) [...] Chapter 6. Bowden: the country schoolmaster (pages 56 - 67) [...] Chapter 7. Return to Grahamstown (pages 68 - 84) [...] Chapter 8. Gathering storm (pages 85 - 101) [...] Chapter 9. Whirlwind (pages 102 - 115) [...] Chapter 10. Interlude: book lover and literary critic (pages 116 - 130) [...] Chapter 11. Farewell to Grahamstown (pages 131 - 138) [...] Chapter 12. Pretoria: {{a time to}} build (pages 139 - 150) [...] Chapter 13. Pretoria: frustrations and achievements (pages 151 - 163) [...] Chapter 14. Durban: Valley of the <b>shadow</b> (<b>pages</b> 164 - 182) [...] Chapter 15. Bloemfontein: up-hill to the end (pages 183 - 192) [...] Chapter 16. Task accomplishes (pages 193 - 204) [...] Notes (pages 205 - 228) [...] Bibliography (pages 229 - 236) [...] Index (pages 237 - 253...|$|R
5000|$|Maud Ellmann: Elizabeth Bowen: The <b>Shadow</b> Across the <b>Page</b> (2003) ...|$|R
40|$|The {{design and}} {{implementation}} of some persistent object stores rely {{on the availability of}} memory mapped files. A significant difficulty faced by this approach is that the programmer has very little control over when I/O occurs. In this paper, a mechanism for exposing the I/O activity of a memory mapped file is presented. This involves implementing a special purpose NFS server that provides a <b>shadow</b> <b>paged</b> file which can be memory mapped by a persistent object store. Some initial performance figures are presented to indicate the relative performance of this approach compared to more traditional approaches. Fred Brow...|$|R
