185|10000|Public
5|$|In {{terms of}} the {{implication}} graph, two literals {{belong to the same}} <b>strongly</b> <b>connected</b> <b>component</b> whenever there exist chains of implications from one literal to the other and vice versa. Therefore, the two literals must have the same value in any satisfying assignment to the given 2-satisfiability instance. In particular, if a variable and its negation both belong to the same <b>strongly</b> <b>connected</b> <b>component,</b> the instance cannot be satisfied, because it is impossible to assign both of these literals the same value. As Aspvall et al. showed, this is a necessary and sufficient condition: a 2-CNF formula is satisfiable if and only if there is no variable that belongs to the same <b>strongly</b> <b>connected</b> <b>component</b> as its negation.|$|E
5|$|Check {{whether any}} <b>strongly</b> <b>connected</b> <b>component</b> {{contains}} both a variable and its negation. If so, {{report that the}} instance is not satisfiable and halt.|$|E
5|$|Important {{polynomial}} time computational problems on DAGs include topological sorting (finding a topological ordering), {{construction of the}} transitive closure and transitive reduction (the largest and smallest DAGs with the same reachability relation, respectively), and the closure problem, in which {{the goal is to}} find a minimum-weight subset of vertices with no edges connecting them {{to the rest of the}} graph. Transforming a directed graph with cycles into a DAG by deleting as few vertices or edges as possible (the feedback vertex set and feedback edge set problem, respectively) is NP-hard, but any directed graph can be made into a DAG (its condensation) by contracting each <b>strongly</b> <b>connected</b> <b>component</b> into a single supervertex. The problems of finding shortest paths and longest paths can be solved on DAGs in linear time, in contrast to arbitrary graphs for which shortest path algorithms are slower and longest path problems are NP-hard.|$|E
5000|$|Tarjan's <b>strongly</b> <b>connected</b> <b>components</b> {{algorithm}}, an algorithm {{that gives}} the topologically sorted list of <b>strongly</b> <b>connected</b> <b>components</b> in a graph ...|$|R
40|$|We present faster {{algorithms}} for computing the 2 -edge and 2 -vertex <b>strongly</b> <b>connected</b> <b>components</b> of a directed graph, {{which are}} straightforward generalizations of <b>strongly</b> <b>connected</b> <b>components.</b> While in undirected graphs the 2 -edge and 2 -vertex <b>connected</b> <b>components</b> {{can be found}} in linear time, in directed graphs only rather simple O(m n) -time algorithms were known. We use a hierarchical sparsification technique to obtain algorithms that run in time O(n^ 2). For 2 -edge <b>strongly</b> <b>connected</b> <b>components</b> our algorithm gives the first running time improvement in 20 years. Additionally we present an O(m^ 2 / n) -time algorithm for 2 -edge <b>strongly</b> <b>connected</b> <b>components,</b> and thus improve over the O(m n) running time also when m = O(n). Our approach extends to k-edge and k-vertex <b>strongly</b> <b>connected</b> <b>components</b> for any constant k with a running time of O(n^ 2 ^ 2 n) for edges and O(n^ 3) for vertices...|$|R
50|$|Find the <b>strongly</b> <b>connected</b> <b>components</b> of the {{resulting}} graph.|$|R
500|$|Construct the {{condensation}} of {{the implication}} graph, a smaller graph that has one vertex for each <b>strongly</b> <b>connected</b> <b>component,</b> and an edge from component [...] to component [...] whenever the implication graph contains an edge [...] such that [...] belongs to component [...] and [...] belongs to component [...] The condensation is automatically a {{directed acyclic graph}} and, like the implication graph from which it was formed, it is skew-symmetric.|$|E
2500|$|As [...] showed, a {{satisfying}} assignment to the 2-satisfiability instance {{is equivalent to}} a partition of this implication graph into two subsets of vertices, S and σ(S), such that no edge starts in S and ends in σ(S). If such a partition exists, {{a satisfying}} assignment may be formed by assigning a true value to every variable in S and a false value to every variable in σ(S). This may be done {{if and only if}} no <b>strongly</b> <b>connected</b> <b>component</b> of the graph contains both some vertex v and its complementary vertex σ(v). If two vertices belong to the same <b>strongly</b> <b>connected</b> <b>component,</b> the corresponding variables or negated variables are constrained to equal each other in any satisfying assignment of the 2-satisfiability instance. The total time for testing strong connectivity and finding a partition of the implication graph is linear {{in the size of the}} given 2-CNF expression.|$|E
50|$|If G is not {{strongly}} connected, we may {{perform a}} similar computation in each <b>strongly</b> <b>connected</b> <b>component</b> of G, ignoring the edges that pass from one <b>strongly</b> <b>connected</b> <b>component</b> to another.|$|E
50|$|Several {{algorithms}} compute <b>strongly</b> <b>connected</b> <b>components</b> in linear time.|$|R
5|$|Two {{vertices}} in a {{directed graph}} {{are said to}} be <b>strongly</b> <b>connected</b> to each other if there is a directed path {{from one to the other}} and vice versa. This is an equivalence relation, and the vertices of the graph may be partitioned into <b>strongly</b> <b>connected</b> <b>components,</b> subsets within which every two vertices are <b>strongly</b> <b>connected.</b> There are several efficient linear time algorithms for finding the <b>strongly</b> <b>connected</b> <b>components</b> of a graph, based on depth first search: Tarjan's <b>strongly</b> <b>connected</b> <b>components</b> algorithm and the path-based strong component algorithm each perform a single depth first search. Kosaraju's algorithm performs two depth first searches, but is very simple.|$|R
30|$|The two {{important}} results {{in this paper}} are the intractability of the decomposition into (open) <b>strongly</b> <b>connected</b> <b>components</b> in FSDNs {{and the construction of}} DMSTs over an already existing <b>strongly</b> <b>connected</b> <b>components.</b> Note also that the very concept of Open <b>Connected</b> <b>Components</b> is completely new, and somewhat surprising, arising because of the dynamics of the networks, and may find important applications.|$|R
5000|$|<b>Strongly</b> <b>connected</b> <b>component,</b> {{a related}} concept for {{directed}} graphs ...|$|E
50|$|Once a 2-SAT {{problem is}} reduced to a graph, then if a depth first search finds a <b>strongly</b> <b>connected</b> <b>component</b> with both phases of a variable, then the 2-SAT problem is not satisfiable. Likewise, if the depth first search does not find a <b>strongly</b> <b>connected</b> <b>component</b> with both phases of a variable, then the 2-SAT problem is satisfiable.|$|E
50|$|When each node {{finishes}} recursing, if its lowlink {{is still}} set to its index, {{then it is}} the root node of a <b>strongly</b> <b>connected</b> <b>component,</b> formed {{by all of the}} nodes above it on the stack. The algorithm pops the stack up to and including the current node, and presents all of these nodes as a <b>strongly</b> <b>connected</b> <b>component.</b>|$|E
50|$|In the {{mathematical}} theory of directed graphs, a graph {{is said to}} be <b>strongly</b> <b>connected</b> or diconnected if every vertex is reachable from every other vertex. The <b>strongly</b> <b>connected</b> <b>components</b> or diconnected components of an arbitrary directed graph form a partition into subgraphs that are themselves <b>strongly</b> <b>connected.</b> It is possible to test the strong connectivity of a graph, or to find its <b>strongly</b> <b>connected</b> <b>components,</b> in linear time.|$|R
40|$|Abstract. We {{establish}} linear-time {{reductions between}} the minimization of a deterministic finite automaton (DFA) and the conjunction of 3 subproblems: the minimization of a <b>strongly</b> <b>connected</b> DFA, the isomorphism {{problem for a}} set of <b>strongly</b> <b>connected</b> minimized DFAs, and the minimization of a connected DFA consisting in two <b>strongly</b> <b>connected</b> <b>components,</b> both of which are minimized. We apply this procedure to minimize, in linear time, automata whose nontrivial <b>strongly</b> <b>connected</b> <b>components</b> are cycles. 1...|$|R
5000|$|Consider the {{automaton}} as a {{directed graph}} and decompose it into <b>strongly</b> <b>connected</b> <b>components</b> (SCCs).|$|R
50|$|If each <b>strongly</b> <b>connected</b> <b>component</b> is {{contracted}} {{to a single}} vertex, the resulting graph is a directed acyclic graph, the condensation of G. A directed graph is acyclic {{if and only if}} it has no strongly connected subgraphs with more than one vertex, because a directed cycle is strongly connected and every nontrivial <b>strongly</b> <b>connected</b> <b>component</b> contains at least one directed cycle.|$|E
50|$|While {{there is}} nothing special about {{the order of the}} nodes within each <b>strongly</b> <b>connected</b> <b>component,</b> one useful {{property}} of the algorithm is that no <b>strongly</b> <b>connected</b> <b>component</b> will be identified before any of its successors. Therefore, the order in which the strongly connected components are identified constitutes a reverse topological sort of the DAG formed by the strongly connected components.|$|E
50|$|In {{terms of}} the {{implication}} graph, two literals {{belong to the same}} <b>strongly</b> <b>connected</b> <b>component</b> whenever there exist chains of implications from one literal to the other and vice versa. Therefore, the two literals must have the same value in any satisfying assignment to the given 2-satisfiability instance. In particular, if a variable and its negation both belong to the same <b>strongly</b> <b>connected</b> <b>component,</b> the instance cannot be satisfied, because it is impossible to assign both of these literals the same value. As Aspvall et al. showed, this is a necessary and sufficient condition: a 2-CNF formula is satisfiable if and only if there is no variable that belongs to the same <b>strongly</b> <b>connected</b> <b>component</b> as its negation.|$|E
5000|$|If G is not <b>strongly</b> <b>connected,</b> then r(G) {{is equal}} to the maximum cycle rank among all <b>strongly</b> <b>connected</b> <b>components</b> of G.|$|R
2500|$|S. Rao Kosaraju, {{developed}} Kosaraju's algorithm, which {{finds the}} <b>strongly</b> <b>connected</b> <b>components</b> of a directed graph ...|$|R
40|$|AbstractA bidirected graph is a graph each arc {{of which}} has either two {{positive}} end-vertices (tails), two negative end-vertices (heads), or one positive end-vertex (a tail) and one negative end-vertex (a head). We define the strong connectivity of a bidirected graph as a generalization of the strong connectivity of an ordinary directed graph. We show that a bidirected graph is decomposed into <b>strongly</b> <b>connected</b> <b>components</b> and that a signed poset structure is naturally defined {{on the set of}} the consistent <b>strongly</b> <b>connected</b> <b>components.</b> We also give a linear time algorithm for decomposing a bidirected graph into <b>strongly</b> <b>connected</b> <b>components.</b> Furthermore, we discuss the relationship between the decomposition of a bidirected graph and the minimization of a certain bisubmodular function...|$|R
5000|$|A {{directed}} cycle for each <b>strongly</b> <b>connected</b> <b>component</b> of G, connecting together the vertices in this component ...|$|E
50|$|A {{directed}} graph has an Eulerian cycle if {{and only if}} every vertex has equal in degree and out degree, and all of its vertices with nonzero degree belong to a single <b>strongly</b> <b>connected</b> <b>component.</b> Equivalently, a {{directed graph}} has an Eulerian cycle {{if and only if}} it can be decomposed into edge-disjoint directed cycles and all of its vertices with nonzero degree belong to a single <b>strongly</b> <b>connected</b> <b>component.</b>|$|E
50|$|The index {{variable}} is the depth-first search node number counter. S is the node stack, which starts out empty and stores {{the history of}} nodes explored but not yet committed to a <b>strongly</b> <b>connected</b> <b>component.</b> Note {{that this is not}} the normal depth-first search stack, as nodes are not popped as the search returns up the tree; they are only popped when an entire <b>strongly</b> <b>connected</b> <b>component</b> has been found.|$|E
3000|$|... {{transforming}} G in a directed graph. The <b>strongly</b> <b>connected</b> <b>components</b> of this digraph {{can now be}} computed.|$|R
40|$|Ideally, {{algorithms}} {{should be}} easy to understand and perform efficiently. However, these two requirements are often contradicting. In this thesis, by describing a semi-automatic derivation of an efficient algorithm for detecting <b>strongly</b> <b>connected</b> <b>components,</b> we argue that efficiency may be derivable, thereby satisfying both requirements. First, some basic graph theory will be reviewed. Then we will focus on some existing algorithms, among which Tarjan’s algorithm is the most well known. Some attention is given to parallel algorithms for detecting <b>strongly</b> <b>connected</b> <b>components.</b> Next, we start with a simple but inefficient algorithm for detecting <b>strongly</b> <b>connected</b> <b>components.</b> This algorithm will be transformed step-by-step into a more efficient algorithm. Finally, we will present some test results and compare {{the efficiency of the}} resulting algorithm to Tarjan’s algorithm...|$|R
50|$|The tree-depth of an {{undirected graph}} {{has a very}} similar definition, using undirected {{connectivity}} and <b>connected</b> <b>components</b> in place of strong connectivity and <b>strongly</b> <b>connected</b> <b>components.</b>|$|R
50|$|Check {{whether any}} <b>strongly</b> <b>connected</b> <b>component</b> {{contains}} both a variable and its negation. If so, {{report that the}} instance is not satisfiable and halt.|$|E
5000|$|... {{entanglement}} of G is 1 if {{and only}} if G is not acyclic, and in every <b>strongly</b> <b>connected</b> <b>component</b> of G there is a node whose removal makes the component acyclic.|$|E
5000|$|... #Caption: The yellow {{directed}} acyclic graph is the condensation of {{the blue}} directed graph. It is formed by contracting each <b>strongly</b> <b>connected</b> <b>component</b> of the blue graph into a single yellow vertex.|$|E
50|$|Using the graph, the optimizer {{can then}} cluster the <b>strongly</b> <b>connected</b> <b>components</b> (SCC) and {{separate}} vectorizable {{statements from the}} rest.|$|R
500|$|... found {{a simpler}} linear time {{procedure}} for solving 2-satisfiability instances, {{based on the}} notion of <b>strongly</b> <b>connected</b> <b>components</b> from graph theory.|$|R
5000|$|S. Rao Kosaraju, Computer Science (1959-1964), {{founder of}} the Kosaraju's algorithm, which finds the <b>strongly</b> <b>connected</b> <b>components</b> of a {{directed}} graph ...|$|R
