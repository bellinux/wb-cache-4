50|0|Public
25|$|A logical system {{satisfying}} Lindström's {{definition that}} has a <b>semidecidable</b> logical consequence relation and satisfies the Löwenheim–Skolem theorem must be equivalent to first-order logic.|$|E
25|$|There {{are many}} {{deductive}} systems for first-order logic which are both sound (all provable statements are true in all models) and complete (all statements which are true in all models are provable). Although the logical consequence relation is only <b>semidecidable,</b> much {{progress has been}} made in automated theorem proving in first-order logic. First-order logic also satisfies several metalogical theorems that make it amenable to analysis in proof theory, such as the Löwenheim–Skolem theorem and the compactness theorem.|$|E
25|$|Unlike propositional logic, first-order {{logic is}} {{undecidable}} (although <b>semidecidable),</b> {{provided that the}} language {{has at least one}} predicate of arity at least 2 (other than equality). This means that there is no decision procedure that determines whether arbitrary formulas are logically valid. This result was established independently by Alonzo Church and Alan Turing in 1936 and 1937, respectively, giving a negative answer to the Entscheidungsproblem posed by David Hilbert in 1928. Their proofs demonstrate a connection between the unsolvability of the decision problem for first-order logic and the unsolvability of the halting problem.|$|E
2500|$|A {{property}} {{of a theory}} or logical system weaker than decidability is semidecidability. [...] A theory is <b>semidecidable</b> {{if there is an}} effective method which, given an arbitrary formula, will always tell correctly when the formula is in the theory, but may give either a negative answer or no answer at all when the formula is not in the theory. A logical system is <b>semidecidable</b> if there is an effective method for generating theorems (and only theorems) such that every theorem will eventually be generated. This is different from decidability because in a <b>semidecidable</b> system there may be no effective procedure for checking that a formula is not a theorem.|$|E
2500|$|The {{inconsistency}} {{problem of}} dependence logic is <b>semidecidable,</b> {{and in fact}} equivalent to the inconsistency problem for first-order logic.|$|E
2500|$|Every decidable {{theory or}} logical system is <b>semidecidable,</b> {{but in general}} the {{converse}} is not true; a theory is decidable {{if and only if}} both it and its complement are semi-decidable. For example, the [...] set of logical validities V of first-order logic is semi-decidable, but not decidable. In this case, it is because there is no effective method for determining for an arbitrary formula A whether A is not in V. Similarly, the set of logical consequences of any recursively enumerable set of first-order axioms is <b>semidecidable.</b> Many of the examples of undecidable first-order theories given above are of this form.|$|E
2500|$|A {{language}} is computably enumerable (synonyms: recursively enumerable, <b>semidecidable)</b> {{if there is}} a computable function [...] such that [...] is defined if and only if the word [...] is in the language. [...] The term enumerable has the same etymology as in computably enumerable sets of natural numbers.|$|E
2500|$|A set {{of natural}} numbers is called computably {{enumerable}} (synonyms: recursively enumerable, <b>semidecidable)</b> {{if there is}} a computable function [...] such that for each number , [...] is defined if and only if [...] is in the set. [...] Thus a set is computably enumerable if and only if it is the domain of some computable function. [...] The word enumerable is used because the following are equivalent for a nonempty subset [...] of the natural numbers: ...|$|E
2500|$|Although the halting {{problem is}} not computable, it is {{possible}} to simulate program execution and produce an infinite list of the programs that do halt. Thus the halting problem {{is an example of a}} recursively enumerable set, which is a set that can be enumerated by a Turing machine (other terms for recursively enumerable include computably enumerable and <b>semidecidable).</b> Equivalently, a set is recursively enumerable if and only if it is the range of some computable function. [...] The recursively enumerable sets, although not decidable in general, have been studied in detail in recursion theory.|$|E
50|$|A {{property}} {{of a theory}} or logical system weaker than decidability is semidecidability. A theory is <b>semidecidable</b> {{if there is an}} effective method which, given an arbitrary formula, will always tell correctly when the formula is in the theory, but may give either a negative answer or no answer at all when the formula is not in the theory. A logical system is <b>semidecidable</b> if there is an effective method for generating theorems (and only theorems) such that every theorem will eventually be generated. This is different from decidability because in a <b>semidecidable</b> system there may be no effective procedure for checking that a formula is not a theorem.|$|E
5000|$|A logical system {{satisfying}} Lindström's {{definition that}} has a <b>semidecidable</b> logical consequence relation and satisfies the Löwenheim-Skolem theorem must be equivalent to first-order logic.|$|E
5000|$|In computability theory, {{traditionally}} called recursion theory, a set S {{of natural}} numbers is called recursively enumerable, computably enumerable, <b>semidecidable,</b> provable or Turing-recognizable if: ...|$|E
50|$|A {{formal system}} {{is said to}} be {{recursive}} (i.e. effective) or recursively enumerable if the set of axioms and the set of inference rules are decidable sets or <b>semidecidable</b> sets, respectively.|$|E
50|$|Every decidable {{theory or}} logical system is <b>semidecidable,</b> {{but in general}} the {{converse}} is not true; a theory is decidable {{if and only if}} both it and its complement are semi-decidable. For example, the set of logical validities V of first-order logic is semi-decidable, but not decidable. In this case, it is because there is no effective method for determining for an arbitrary formula A whether A is not in V. Similarly, the set of logical consequences of any recursively enumerable set of first-order axioms is <b>semidecidable.</b> Many of the examples of undecidable first-order theories given above are of this form.|$|E
50|$|The first {{condition}} suggests why {{the term}} <b>semidecidable</b> is sometimes used; the second suggests why computably enumerable is used. The abbreviations r.e. and c.e. are often used, even in print, {{instead of the}} full phrase.|$|E
50|$|Faced with an unprovable statement, a {{complete}} proof procedure may sometimes succeed in detecting and signalling its unprovability. In the general case, where provability is a <b>semidecidable</b> property, {{this is not}} possible, and instead the procedure will diverge (not terminate).|$|E
50|$|A {{decision}} problem A is called decidable or effectively solvable if A is a recursive set. A problem is called partially decidable, <b>semidecidable,</b> solvable, or provable if A is a recursively enumerable set. Problems {{that are not}} decidable are called undecidable.|$|E
5000|$|The {{inconsistency}} {{problem of}} dependence logic is <b>semidecidable,</b> {{and in fact}} equivalent to the inconsistency problem for first-order logic. However, the decision problem for dependence logic is non-arithmetical, and is in fact complete {{with respect to the}} [...] class of the Levy hierarchy.|$|E
5000|$|A {{language}} is computably enumerable (synonyms: recursively enumerable, <b>semidecidable)</b> {{if there is}} a computable function [...] such that [...] is defined if and only if the word [...] is in the language. The term enumerable has the same etymology as in computably enumerable sets of natural numbers.|$|E
50|$|A {{more general}} class of sets {{consists}} of the recursively enumerable sets, also called <b>semidecidable</b> sets. For these sets, it is only required {{that there is an}} algorithm that correctly decides when a number is in the set; the algorithm may give no answer (but not the wrong answer) for numbers not in the set.|$|E
50|$|In mathematics, {{logic and}} {{computer}} science, a formal language is called recursively enumerable (also recognizable, partially decidable, <b>semidecidable,</b> Turing-acceptable or Turing-recognizable) {{if it is}} a recursively enumerable subset in the set of all possible words over the alphabet of the language, i.e., if there exists a Turing machine which will enumerate all valid strings of the language.|$|E
5000|$|... A y {{such that}} R holds of the xi {{may be called}} a 'witness' to the {{relation}} S holding of the xi (provided we understand that when the witness is a number rather than a person, a witness only testifies to what is true)." [...] In this particular example, B-B-J have defined s to be (positively) recursively <b>semidecidable,</b> or simply semirecursive.|$|E
5000|$|A set {{of natural}} numbers is called computably {{enumerable}} (synonyms: recursively enumerable, <b>semidecidable)</b> {{if there is}} a computable function [...] such that for each number , [...] is defined if and only if [...] is in the set. Thus a set is computably enumerable if and only if it is the domain of some computable function. The word enumerable is used because the following are equivalent for a nonempty subset [...] of the natural numbers: ...|$|E
50|$|There {{are many}} {{deductive}} systems for first-order logic which are both sound (all provable statements are true in all models) and complete (all statements which are true in all models are provable). Although the logical consequence relation is only <b>semidecidable,</b> much {{progress has been}} made in automated theorem proving in first-order logic. First-order logic also satisfies several metalogical theorems that make it amenable to analysis in proof theory, such as the Löwenheim-Skolem theorem and the compactness theorem.|$|E
50|$|Although the halting {{problem is}} not computable, it is {{possible}} to simulate program execution and produce an infinite list of the programs that do halt. Thus the halting problem {{is an example of a}} recursively enumerable set, which is a set that can be enumerated by a Turing machine (other terms for recursively enumerable include computably enumerable and <b>semidecidable).</b> Equivalently, a set is recursively enumerable if and only if it is the range of some computable function. The recursively enumerable sets, although not decidable in general, have been studied in detail in recursion theory.|$|E
50|$|Unlike propositional logic, first-order {{logic is}} {{undecidable}} (although <b>semidecidable),</b> {{provided that the}} language {{has at least one}} predicate of arity at least 2 (other than equality). This means that there is no decision procedure that determines whether arbitrary formulas are logically valid. This result was established independently by Alonzo Church and Alan Turing in 1936 and 1937, respectively, giving a negative answer to the Entscheidungsproblem posed by David Hilbert in 1928. Their proofs demonstrate a connection between the unsolvability of the decision problem for first-order logic and the unsolvability of the halting problem.|$|E
50|$|Satisfiability is {{undecidable}} {{and indeed}} it isn't even a <b>semidecidable</b> property of formulae in first-order logic (FOL). This fact {{has to do}} with the undecidability of the validity problem for FOL. The question of the status of the validity problem was posed firstly by David Hilbert, as the so-called Entscheidungsproblem. The universal validity of a formula is a semi-decidable problem. If satisfiability were also a semi-decidable problem, then the problem of the existence of counter-models would be too (a formula has counter-models iff its negation is satisfiable). So the problem of logical validity would be decidable, which contradicts the Church-Turing theorem, a result stating the negative answer for the Entscheidungsproblem.|$|E
40|$|A δ-uniform BSS {{machine is}} a {{standard}} BSS machine which does not rely on exact equality tests. We prove that, for any archimedean field R, a set is δ-uniformly <b>semidecidable</b> iff it is open and semi-decidable by a BSS machine which is locally time bounded; we also prove that the local time bound is nontrivial. This entails a number of results about BSS machines, in particular the existence of decidable sets whose interior (closure) is not even semi-decidable without adding constants. Finally, we show that the sets <b>semidecidable</b> by Turing machines are the sets semi-decidable by δ-uniform machines with coefficients in Q or T, the field of Turing computable numbers...|$|E
40|$|What can {{be decided}} or semidecided about a {{primitive}} recursive function, given {{a definition of}} that function by primitive recursion? What about subrecursive classes other than primitive recursive functions? We provide a complete and explicit characterization of the decidable and <b>semidecidable</b> properties. This characterization uses a variant of Kolmogorov complexity where only programs in a subrecursive programming language are allowed. More precisely, we prove that all the decidable and <b>semidecidable</b> properties can be obtained as combinations of two classes of basic decidable properties: (i) the function takes some particular values on a finite set of inputs, and (ii) every finite part of the function can be compressed to some extent...|$|E
40|$|International audienceIn {{computability theory}} and computable analysis, finite {{programs}} can compute infinite objects. Presenting a computable object via any program for it, provides {{at least as}} much information as presenting the object itself, written on an infinite tape. What additional information do programs provide? We characterize this additional information to be any upper bound on the Kolmogorov complexity of the object. Hence we identify the exact relationship between Markov computability and Type- 2 computability. We then use this relationship to obtain several results characterizing the computational and topological structure of Markov <b>semidecidable</b> sets...|$|E
40|$|This paper {{addresses}} {{the problem of}} consistency {{of a set of}} integrity constraints itself, independent from any state. It is pointed out that database constraints have not only to be consistent, but in addition to be finitely satisfiable. This stronger property reflects that the constraints have to admit a finite set of (stored as well as derivable) facts. As opposed to consistency, being undecidable, finite satisfiability is <b>semidecidable.</b> For efficiency purposes we investigate methods that check both finite satisfiability as well as unsatisfiability. Two different methods are proposed which extend two alternative approaches to refutation. ...|$|E
40|$|It {{is shown}} that between one-turn pushdown automata (1 -turn PDAs) and {{deterministic}} finite automata (DFAs) {{there will be}} savings concerning the size of description not bounded by any recursive function, so-called non-recursive tradeoffs. Considering the number of turns of the stack height as a consumable resource of PDAs, we can show the existence of non-recursive trade-offs between PDAs performing k+ 1 turns and k turns for k >= 1. Furthermore, non-recursive trade-offs are shown between arbitrary PDAs and PDAs which perform only {{a finite number of}} turns. Finally, several decidability questions are shown to be undecidable and not <b>semidecidable...</b>|$|E
40|$|Abstract. In this paper, we analyze {{limits of}} {{approximation}} techniques for (non-linear) continuous image computation in model checking hybrid systems. In particular, {{we show that}} even a single step of continuous image computation is not <b>semidecidable</b> numerically even for a very restricted class of functions. Moreover, we show that symbolic insight about derivative bounds provides sufficient additional information for approximation refinement model checking. Finally, we prove that purely numerical algorithms can perform continuous image computation with arbitrarily high probability. Using these results, we analyze the prerequisites for a safe operation of the roundabout maneuver in air traffic collision avoidance...|$|E
40|$|When {{their reading}} heads {{are allowed to}} move {{completely}} asynchronously, finite-state automata with multiple tapes achieve a significant expressive power, but also lose useful closure properties [...] -closure under intersection, in particular. This paper investigates to what extent it is still feasible to use multi-tape automata as recognizer of polyadic predicates on words. On the negative side, determining whether the intersection of asynchronous multi-tape automata is expressible is not even <b>semidecidable.</b> On the positive side, we present an algorithm that computes under-approximations of the intersection; and discuss simple conditions under which it can construct complete intersections. A prototype implementation and a few non-trivial examples demonstrate the algorithm in practice...|$|E
40|$|We {{introduce}} {{a framework for}} managing as a whole {{the space of a}} narrowing computation. The aim of our framework is to find a finite representation of an infinite narrowing space. This, in turn, allows us to replace an infinite enumeration of computed answers with an equivalent finite representation. We provide a <b>semidecidable</b> condition for this result. Our framework is intended to be used by implementations of functional logic programming languages. Our approach borrows from the memoization technique used in the implementation of functional languages. Since narrowing adds non-determinism and unifiers to functional evaluation, we develop a new approach based on graphs to memoize the outcome of a goal...|$|E
40|$|AbstractThe {{intersection}} type discipline for the λ-calculus (ITD) is {{an extension}} of the classical functionality theory of Curry. In the ITD a term satisfying a given property has a principal type scheme in an extended meaning, i. e., there is a type scheme deducible for it from which all and only the type schemes deducible for it are reachable, by means of suitable operations. The problem of finding the principal type scheme for a term, if it exists, is <b>semidecidable.</b> In the paper a procedure is shown, building the principal type scheme of a term through the construction of the most general unifier for intersection type schemes...|$|E
