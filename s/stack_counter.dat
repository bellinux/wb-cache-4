0|44|Public
40|$|The {{downward}} closure {{of a language}} L of words is the set of all (not necessarily contiguous) subwords of members of L. It {{is well known that}} the {{downward closure}} of any language is regular. Although the downward closure seems to be a promising abstraction, there are only few language classes for which an automaton for the downward closure is known to be computable. It is shown here that for <b>stacked</b> <b>counter</b> automata, the downward closure is computable. <b>Stacked</b> <b>counter</b> automata are finite automata with a storage mechanism obtained by adding blind <b>counters</b> and building <b>stacks.</b> Hence, they generalize pushdown and blind counter automata. The class of languages accepted by these automata are precisely those in the hierarchy ob-tained from the context-free languages by alternating two closure operators: imposing semilinear constraints and taking the algebraic extension. The main tool for computing downward closures is the new concept of Parikh annotations. As a second application of Parikh annotations, it is shown that the hierarchy above is strict at every level. ...|$|R
40|$|Existing {{techniques}} for identifying working set sizes based on miss ratio curves (MRCs) have large memory overheads which make them impractical for storage work-loads. We present a novel data structure, the <b>counter</b> <b>stack,</b> which can produce approximate MRCs while us-ing sublinear space. We show how <b>counter</b> <b>stacks</b> can be checkpointed to produce workload representations that are many {{orders of magnitude}} smaller than full traces, and we describe {{techniques for}} estimating MRCs of arbitrary workload combinations over arbitrary windows in time. Finally, we show how online analysis using <b>counter</b> <b>stacks</b> can provide valuable insight into live workloads. ...|$|R
25|$|Uniform 16× 32-bit {{register}} file (including {{the program}} <b>counter,</b> <b>stack</b> pointer and the link register).|$|R
40|$|The {{tree shaker}} {{is a high}} {{throughput}} hydro-mechanical systems used in nut and fruit harvest. Many commercial tree shakers use <b>stacked</b> <b>counter</b> rotating eccentric mass energy-wheels to dislodge the crop from the tree by attaching and shaking the trunk. Tree shakers are known to cause tree trunk damage by approach impact, barking, and bruising of the tree trunk. Tree trunk damage, catastrophic or accumulative, could account for a 4 % lifetime production loss, 1408 kg/hectare.;The energy-wheels are commonly known to create planer pulse forces. The pulse is created by the rotation of eccentric mass about a fixed common shaft. The frequency and magnitude of the force {{is determined by the}} weight, angular velocity, and center of gravity location of each energy wheel. The industry has developed pads and slings to conform to the tree trunk and transmit the force while minimizing the potential for trunk damage. Lubrication of the slings reduces the coefficient of friction and allows unwanted force dissipation. Lubrication of the slings reduce the transfer of non-normal forces.;This research discloses the presence of moments and extends the planer equations to allow analysis of moment magnitudes and the introduction of planer losses in the y-axis. Moments and planer forces are always present in <b>stacked</b> <b>counter</b> rotating eccentric mass energy-wheel systems. Moments are non-normal forces and are dissipated in the slings, pads, shaker head suspension system. Moments and y-axis losses reduce the efficiency of the system and require additional hardware and systems to control adverse effects on the tree trunk.;Understanding the magnitude of moments will allow development of new systems to extend the application of mechanical shakers to other crops and applications...|$|R
50|$|The new library {{block is}} a double-storeyed {{building}} consisting of deposit-counter, issue-of-books <b>counter,</b> <b>stack</b> hall, reserve section, reading hall, teachers' reading room, magazine section, and administrative section.|$|R
40|$|In {{software}} verification {{it is often}} required to prove statements about heterogeneous domains containing elements of various sorts, such as <b>counters,</b> <b>stacks,</b> lists, trees and queues. Any domain with <b>counters,</b> <b>stacks,</b> lists, and trees (but not queues) can be easily seen a special case of the term algebra, and hence a decision procedure for term algebras {{can be applied to}} decide the first-order theory of such a domain. We prove that the first-order theory of term algebras extended with queues is decidable by presenting a quantifier-elimination procedure for this theory...|$|R
40|$|This work {{presents}} a formal {{description of a}} subset of a C-like language {{in the form of}} an operational semantics. We give semantics to the following statements (presented in alphabetical order) : assig-nation, break, composition, continue, goto, if, skip and while. The semantics is given by an abstract machine composed by an <b>stack,</b> two <b>counters</b> and three functions. We prove some expected properties of the semantics. ...|$|R
40|$|Abstract—This paper {{presents}} lower bounds on the time- and space-complexity of implementations {{that use}} k-compare-and-swap (k-CAS) synchronization primitives. We prove that using k-CAS primitives cannot improve neither the time- nor the space-complexity of implementations of widely-used concurrent objects, such as <b>counter,</b> <b>stack,</b> queue, and collect. Surprisingly, overly restrictive use of k-CAS may even increase the space complexity required by such implementations. We prove a lower bound of Ω(log 2 n) on the round complexity of implementations of a collect object using read, write and k-CAS, for any k, where n {{is the number}} of processes in the system. There is an implementation of collect with O(log 2 n) round complexity that uses only reads and writes. Thus, our lower bound establishes that k-CAS is no stronger than read and write for collect implementation round complexity. For k-CAS operations that return the values of all the objects they access, we prove that the total step complexity of implementing key objects such as <b>counters,</b> <b>stacks</b> and queues is Ω(n log k n). We also prove that k-CAS cannot improve the space complexity of implementing many objects (including <b>counter,</b> <b>stack,</b> queue, and single-writer snapshot). An implementation has to use at least n base objects even if k-CAS is allowed, and if all operations (other than read) swap exactly k base objects, then it must use at least k · n base objects. Index Terms—Compare-and-swap, CAS, k-compare-and-swap, k-CAS, conditional synchronization primitives, round complexity, collect, <b>counter,</b> <b>stack,</b> queue...|$|R
50|$|The POWER5 is {{a further}} {{development}} of the POWER4. The addition of two-way multithreading required the duplication of the return <b>stack,</b> program <b>counter,</b> instruction buffer, group completion unit and store queue so that each thread may have its own. Most resources, such as the register files and execution units, are shared, although each thread sees {{its own set of}} registers. The POWER5 implements simultaneous multithreading (SMT), where two threads are executed simultaneously. The POWER5 can disable SMT to optimize for the current workload.|$|R
40|$|Operations {{on basic}} data {{structures}} such as queues, priority queues, <b>stacks,</b> and <b>counters</b> can dominate the execution time of a parallel program due to both their frequency and their coordination and contention overheads. There are considerable performance payoffs in developing highly optimized, asynchronous, distributed, cache-conscious, parallel implementations of such data structures. Such implementations may employ a variety of tricks to reduce latencies and avoid serial bottlenecks, {{as long as the}} semantics of the data structure are preserved. The complexity of the implementation and the difficulty in reasoning about asynchronous systems increases concerns regarding possible bugs in the implementation. In this paper we consider postmortem, black-box procedures for testing whether a parallel data structure behaved correctly. We present the first systematic study of algorithms and hardness results for such testing procedures, focusing on queues, priority queues, <b>stacks,</b> and <b>counters,</b> under various important scenarios. Our results demonstrate the importance of selecting test data such that distinct values are inserted into the data structure (as appropriate). In such cases we present an O(n) time algorithm for testing linearizable queues, an O(n log n) time algorithm for testing linearizable priority queues, and an O(np 2) time algorithm for testing sequentially consistent queues, where n is the number of data structure operations and p is th...|$|R
50|$|The {{bank was}} in a two-story {{building}} that also held stores for groceries and hardware. On August 6, the clerks in the bank prepared the cash and coins for Robert's large withdrawal, scheduled to take place at 1:00 pm. The bank's president, John Dessart, had the money {{taken out of the}} vault and <b>stacked</b> on the <b>counter</b> in preparation.|$|R
5000|$|A {{register}} set is a fast memory containing {{the data of}} the central processing unit. It may include the program <b>counter,</b> <b>stack</b> pointer, and other numbers that are not easily accessible to the application programmer. Often the {{register set}} is a triple-ported register file; that is, two registers can be read, and a third written at the same time.|$|R
40|$|A {{man in a}} {{mechanics}} uniform {{leans on}} the counter. He is holding a cigarette. Boxes are <b>stacked</b> on the <b>counter</b> and rows of shelving line the room. A tire rests on the floor against the counter. A tall floor fan is in the background. Exhibited at the Swope Art Museum as part of "Hometown Terre Haute: Photography from the Martin Studios" (June 11 -July 25, 2004...|$|R
50|$|The ST7 has six registers: the accumulator, X and Y index registers, <b>stack</b> pointer, program <b>counter,</b> and {{condition}} code register. Also, double-indirect addressing allows the zero page of RAM {{to serve as}} additional registers. An unusual but useful feature is that an interrupt pushes four of these registers on the stack (A and X {{as well as the}} usual PC and CC), and interrupt return restores them.|$|R
40|$|Abstract. This paper {{presents}} lower bounds on the time- and spacecomplexity of implementations {{that use}} the k compare-and-swap (k-CAS) synchronization primitives. We prove {{that the use of}} k-CAS primitives cannot improve neither the time- nor the space-complexity of implementations of widely-used concurrent objects, such as <b>counter,</b> <b>stack,</b> queue, and collect. Surprisingly, the use of k-CAS may even increase the space complexity required by such implementations. We prove that the worst-case average number of steps performed by processes for any n-process implementation of a <b>counter,</b> <b>stack</b> or queue object is Ω(log k+ 1 n), even if the implementation can use j-CAS for j ≤ k. This bound holds even if a k-CAS operation is allowed to read the k values of the objects it accesses and return these values to the calling process. This bound is tight. We also consider more realistic non-reading k-CAS primitives. An operation of a non-reading k-CAS primitive is only allowed to return a success/failure indication. For implementations of the collect object that use such primitives, we prove that the worst-case average number of steps performed by processes is Ω(log 2 n), regardless of the value of k. This implies a round complexity lower bound of Ω(log 2 n) for such implementations. As there is an O(log 2 n) round complexity implementation of collect that uses only reads and writes, these results establish that non-reading k-CAS is no stronger than read and write for collect implementation round complexity. We also prove that k-CAS does not improve the space complexity of implementing many objects (including <b>counter,</b> <b>stack,</b> queue, and singlewriter snapshot). An implementation has to use at least n base objects even if k-CAS is allowed, and if all operations (other than read) swap exactly k base objects, then the space complexity must be at least k · n. ...|$|R
40|$|This paper {{presents}} lower bounds on the time- and space-complexity of implementations {{that use}} the k compare-and-swap (k-CAS) synchronization primitives. We prove {{that the use of}} k-CAS primitives cannot improve neither the time- nor the space-complexity of implementations of widely-used concurrent objects, such as <b>counter,</b> <b>stack,</b> queue, and collect. Surprisingly, the use of k-CAS may even increase the space complexity required by such implementations. We prove that the worst-case average number of steps performed by processes for every n-process implementation of a <b>counter,</b> <b>stack</b> or queue object is Ω(log k+ 1 n), even if the implementation can use j-CAS for j ≤ k. This bound holds even if a k-CAS operation is allowed to read the k values of the objects it accesses and return these values to the calling process. We also consider more realistic non-reading k-CAS primitives. An operation of a non-reading k-CAS primitive is only allowed to return a success/failure indication. For implementations of the collect object that use such primitives, we prove that the worst-case average number of steps performed by processes is Ω(log 2 n), regardless of the value of k. This implies a round complexity lower bound of Ω(log 2 n) for such implementations. As there is an O(log 2 n) round complexity implementation of collect that uses only reads and writes, these results establish that non-reading k-CAS is no stronger than read and write for collect implementation round complexity. We also prove that k-CAS does not improve the space complexity of implementing many objects (including <b>counter,</b> <b>stack,</b> queue, and single-writer snapshot). An implementation has to use at least n base objects even if k-CAS is allowed, and if all operations (other than read) swap exactly k base objects, then the space complexity must be at least k · n. ...|$|R
40|$|The MicroBooNE {{detector}} is {{a liquid}} argon time projection chamber at Fermilab designed to study short-baseline neutrino oscillations and neutrino-argon interaction cross-section. Due to its location near the surface, {{a good understanding}} of cosmic muons as a source of backgrounds is of fundamental importance for the experiment. We present a method of using an external 0. 5 m (L) x 0. 5 m (W) muon <b>counter</b> <b>stack,</b> installed above the main detector, to determine the cosmic-ray reconstruction efficiency in MicroBooNE. Data are acquired with this external muon <b>counter</b> <b>stack</b> placed in three different positions, corresponding to cosmic rays intersecting different parts of the detector. The data reconstruction efficiency of tracks in the detector is found to be ϵ_data=(97. 1 ± 0. 1 (stat) ± 1. 4 (sys)) %, in good agreement with the Monte Carlo reconstruction efficiency ϵ_MC = (97. 4 ± 0. 1) %. This analysis represents a small-scale demonstration of the method that can be used with future data coming from a recently installed cosmic-ray tagger system, which will be able to tag ≈ 80 % of the cosmic rays passing through the MicroBooNE detector. Comment: 19 pages, 12 figure...|$|R
40|$|We {{investigate}} {{the question of}} computational resources (such as <b>stacks</b> and <b>counters)</b> necessary to perform radix conversions. To this end it is shown that no PDA can compute the significand of the best $n$-digit floating point approximation of a power of an incommensurable radix. This extends the results of W. ~Clinger. We also prove that a two counter machine with input is capable of such conversions. On the other hand we note a curious asymmetry {{with respect to the}} order in which the digits are input by showing that a two counter machine can decode its input online if the digits are presented in the most-to-least significant order while no such machine can decode its input in this manner if the digits are presented in the least-to-most significant order. Some structural results about two counter machines (with input) are also established...|$|R
40|$|We present Ω(n) lower bounds on {{the worst}} case time to perform a single {{instance}} of an operation in any nonblocking implementation of a large class of concurrent data structures shared by n processes. Time {{is measured by the}} number of stalls a process incurs as a result of contention with other processes. For standard data structures such as <b>counters,</b> <b>stacks,</b> and queues, our bounds are tight. The implementations considered may apply any primitives to a base object. No upper bounds are assumed on either the number of base objects or their size...|$|R
40|$|International audienceVisibly pushdown automata {{are special}} pushdown automata whose stack {{behavior}} {{is driven by}} the input symbols according to a partition of the alphabet. We show that it is decidable for a given visibly pushdown automaton whether it is equivalent to a visibly counter automaton, i. e. an automaton that uses its <b>stack</b> only as <b>counter.</b> In particular, this allows to decide whether a given visibly pushdown language is a regular restriction of the set of well-matched words, meaning that the language can be accepted by a finite automaton if only well-matched words are considered as input...|$|R
40|$|Photograph of {{a butcher}} cutting up meant, ca. 1930. A {{man wearing a}} lightly colored apron stands over a slab of wood {{to the right of}} center. The man looks down while he uses his right hand to slice a piece of meat with a long knife. Three large chunks of meat lay on the slab in front of him while the handles of six knives can be seen {{sticking}} {{out of the side of}} the slab. To the left, a tray of meat sits on a table while butcher paper and holding containers are neatly <b>stacked</b> on a <b>counter</b> in the center...|$|R
40|$|Abstract. Visibly pushdown automata {{are special}} pushdown automata whose stack {{behavior}} {{is driven by}} the input symbols according to a partition of the alphabet. We show that it is decidable for a given visibly pushdown automaton whether it is equivalent to a visibly counter automaton, i. e. an automaton that uses its <b>stack</b> only as <b>counter.</b> In particular, this allows to decide whether a given visibly pushdown language is a regular restriction of the set of well-matched words, meaning that the language can be accepted by a finite automaton if only well-matched words are considered as input. ...|$|R
40|$|Abstract This paper proves Ω (n) lower bounds on {{the time}} to perform a single {{instance}} of an operationin any implementation of a large class of data structures shared by n processes. For standarddata structures such as <b>counters,</b> <b>stacks,</b> and queues, the bound is tight. The implementations considered may apply any deterministic primitives to a base object. No bounds are assumedon either the number of base objects or their size. Time is measured {{as the number of}} steps a process performs on base objects and the number of stalls it incurs as a result of contentionwith other processes. ...|$|R
40|$|Visibly pushdown automata {{are special}} pushdown automata whose stack {{behavior}} {{is driven by}} the input symbols according to a partition of the alphabet. We show that it is decidable for a given visibly pushdown automaton whether it is equivalent to a visibly counter automaton, i. e. an automaton that uses its <b>stack</b> only as <b>counter.</b> In particular, this allows to decide whether a given visibly pushdown language is a regular restriction of the set of well-matched words, meaning that the language can be accepted by a finite automaton if only well-matched words are considered as input...|$|R
40|$|AbstractThis paper {{presents}} a novel profiling approach, which is entirely based on program transformation techniques {{in order to}} enable exact profiling, preserving complete call <b>stacks,</b> method invocation <b>counters,</b> and bytecode instruction counters. We exploit the number of executed bytecode instructions as profiling metric, which has several advantages, such as making the instrumentation entirely portable and generating reproducible profiles. These ideas have been implemented as the JP tool. It provides a small and flexible API to write portable profiling agents in pure Java, which are periodically activated to process the collected profiling information. Performance measurements point out that JP causes significantly less overhead than a prevailing tool for the exact profiling of Java code...|$|R
40|$|Most multiprocessors are multiprogrammed {{in order}} to achieve {{acceptable}} response time and to increase their utilization. Unfortunately, inopportune preemption may significantly degrade the performance of synchronized parallel applications. To address this problem, researchers have developed two principal strategies for concurrent, atomic update of shared data structures: (1) preemption-safe locking and (2) non-blocking (lock-free) algorithms. Preemption-safe locking requires kernel support. Non-blocking algorithms generally require a universal atomic primitive such as compare-and-swap or load-linked/store-conditional, and are widely regarded as inefficient. We evaluate the performance of preemption-safe lock-based and non-blocking implementations of important data structures [...] -queues, <b>stacks,</b> heaps, and <b>counters</b> [...] -including non-blocking and lock-based queue algorithms of our own, in micro-benchmarks and real applications on a 12 -processor SGI Challenge multiprocessor. Our results indi [...] ...|$|R
40|$|Parallel {{distributed}} processing (PDP) architectures demonstrate a potentially radical {{alternative to the}} traditional theories of language processing {{that are based on}} serial computational models. However, learning complex structural relationships in temporal data presents a serious challenge to PDP systems. For example, automata theory dictates that processing strings from a context-free language (CFL) requires a <b>stack</b> or <b>counter</b> memory device. While some PDP models have been hand-crafted to emulate such a device, {{it is not clear how}} a neural network might develop such a device when learning a CFL. This research employs standard backpropagation training techniques for a recurrent neural network (RNN) in the task of learning to predict the next character in a simple deterministic CFL (DCFL). We show that an RNN can learn to recognize the structure of a simple DCFL. We use dynamical systems theory to identify how network states re ¯ ect that structure by building counters in phase space. The work is an empirical investigation which is complementary to theoretical analyses of network capabilities, yet original in its speci ® c con ® guration of dynamics involved. The application of dynamical systems theory helps us relate the simulation results to theoretical results, and the learning task enables us to highlight some issues for understanding dynamical systems that process language with counters...|$|R
40|$|Several user-level {{checkpointing}} libraries that checkpoint Unix processes {{have been}} developed. However, {{they do not}} support multithreaded programs. This paper describes a user-level checkpointing library to checkpoint multithreaded programs that use the POSIX threads library provided by Solaris 2. Experiments with programs from the SPLASH- 2 benchmark suite showed a 3 % to 10 % increase in execution time with checkpointing enabled, plus an additional overhead for saving the program's state. The checkpointing library described here is available at [URL] 1. Introduction A multithreaded program's state {{can be divided into}} private state and shared state. A thread's private state includes its program <b>counter,</b> <b>stack</b> pointer, and registers. Its shared state includes everything common to all threads in the process, such as the address space and open file state. A multithreaded checkpointing library must save and recover the program's shared state and each thread's priva [...] ...|$|R
40|$|International audienceDelegation is {{a thread}} {{synchronization}} technique where access to shared data is performed through a dedicated server thread. When a client thread requires shared data access, {{it makes a}} request to a server and waits for a response. This paper studies delegation implementation over cache-coherent shared memory, {{with the goal of}} optimizing it for high throughput. Whereas client-server communication naturally fits message-passing systems, efficient implementation over cache-coherent shared memory requires careful optimization. We demonstrate optimizations that significantly improve delegation performance on two modern x 86 processors (the Intel Xeon Westmere and the AMD Opteron Magny-Cours), enabling us to come up with <b>counter,</b> <b>stack</b> and queue implementations that out-perform the best known alternatives in a large number of cases. Our optimized delegation solution achieves 1. 4 x (resp. 2 x) higher throughput compared to the most efficient state-of-the-art delegation solution on the Intel Xeon (resp. AMD Opteron) ...|$|R
5000|$|Tucumcari {{had long}} advertised [...] "2000 motel rooms" [...] (later [...] "1200 motel rooms") on {{roadside}} signage {{for hundreds of}} miles along US 66 using the slogan [...] "Tucumcari tonite!" [...] At least one historically restored Tucumcari Boulevard motel, the 12-room neon-lit 1939 Blue Swallow Motel, is listed on the National Register of Historic Places. Another motel recently restored nearby is the Motel Safari. The Motel Safari was built in 1959 by Chester Dohrer and features a mid-century modern retro design with [...] "Doo Wop" [...] or [...] "Googie" [...] styled architecture. Boomerangs, holes in cinder blocks, <b>counter</b> <b>stacked</b> bricks protruding from the façade and whimsical metal cylinders that light up at night, along with its famous camel atop the neon sign, paying tribute to the U.S. Camel Corps that once came through {{the area in the}} 1800s on a surveying expedition for a future national road system.|$|R
40|$|Abstract. Visibly pushdown automata {{are special}} pushdown automata whose stack {{behavior}} {{is driven by}} the input symbols according to a partition of the alphabet. We show that it is decidable for a given visibly pushdown automaton whether it is equivalent to a visibly counter automaton, i. e. an automaton that uses its <b>stack</b> only as <b>counter.</b> In particular, this allows to decide whether a given visibly pushdown language is a regular restriction of the set of well-matched words, meaning that the language can be accepted by a finite automaton if only well-matched words are considered as input. 1 Introduction The class of context-free languages (Cfl) {{plays an important role in}} severalareas of computer science. Besides its definition using context-free grammars it has various other characterizations, the most prominent being the one vianondeterministic pushdown automata. It is well known that Cfl does not enjoygood closure properties, e. g. it is not closed under complement and intersection...|$|R
40|$|AbstractIn this paper, we {{investigate}} various decision problems concerning parameterized versions of some classes of machines. Let C(s,m,t) be {{the class of}} nondeterministic multitape Turing machine (TM) acceptors with a two-way read-only input, at most s states, at most m read–write worktapes, and at most t symbols in the worktape alphabet, where s,m,t are fixed positive integers. There is no restriction on the cardinality of the input alphabet. We are able to show the emptiness, disjointness, and universe (also called universality) problems to be decidable for C(s,m,t). For the class consisting of machines in C(s,m,t) that always halt or whose minimal-time accepting computations can be bounded by some recursive function f(n) (where n is the input length), the containment and equivalence problems are decidable. These results hold for other machines, e. g., when the worktapes are pushdown stacks (where on every step, each pushdown can only pop {{the top of the}} stack or replace the top of the stack by at most two symbols) or when <b>stacks</b> are <b>counters</b> (where on every step, a counter can be incremented by 1, decremented by 1, or remain unchanged, and can be tested for zero). Our results are the best possible in the sense that not parameterizing one of s,m,t (or, in the case of counter machines, allowing the counters to increment by arbitrary integers that may change from machines to machines) makes the universe problem undecidable. We also give a simple characterization of the languages defined by C(s,m,t). Finally, {{we investigate}} the applicability of our techniques to machines with multiple input heads or multiple input tapes...|$|R
40|$|Strong {{mobility}} enables {{migration of}} entire computations combining code, data, and execution state (such as <b>stack</b> and program <b>counter)</b> between sites of computation. This {{is in contrast}} to weak mobility were migration is confined to just code and data. Strong mobility is essential for many applications where reconstruction of execution states is either difficult or even impossible. Typical application areas are load balancing, reduction of network latency and traffic, and resource-related migration, just to name a few. This thesis presents a model, programming abstractions, an implementation, and an evaluation of thread-based strong mobility. The model extends a distributed programming model based on automatic synchronization via dataflow variables. The programming abstractions capture various migration scenarios. These scenarios differ in how migration source and destination relate to the site initiating migration. The implementation is based on replication of concurrent lightweight threads between sites controlled by migration managers. The model is implemented in the Mozart programming system. The first version is complete and a work concerning resource rebinding is still in progress. QC 2010113...|$|R
40|$|We {{present the}} TSW system (TestSystem Web), a web-based {{environment}} currently {{developed at the}} Rome 1 University, for the delivery of C programming exercises and their automatic correction. The core of the correction system automatically tests the student’s programs by applying unit-tests and/or by comparing the behaviour of the student’s code to a reference implementation. Care is taken to avoid error propagation from a function to other functionally depending procedures by redirecting the failing calls to the corresponding reference implementation. The system “instruments” the student’s code by using a code analyser and rewriter to handle instruction tracing and function calls redirection. The rewriter can be easily extended to develop other analysis instruments. As an example, we have developed: a code coverage tool that reports {{how much of the}} student’s code has been visited during the test, a cyclomatic complexity evaluator to compare the number of different logic paths in the code, a tracker for stack depth usage to check for proper implementation of recursive functions, a function/loop execution counter for the evaluation of the execution complexity. Additional care is taken to capture disruptive errors that would abort the program: “segmentation faults” caused by wrong pointer dereferentiation, and time-out caused by run-away processes. With these tools, the teacher can write rich unit tests that can either compare the behaviour of the function under analysis with a reference implementation (e. g. by generating random input and comparing the results), or by submitting well-crafted special inputs to elicit special cases or by comparing the complexity and/or <b>stack</b> depth <b>counters.</b> Each test applied will then explain to the student what was the problem found. TSW is the core component of a future larger social knowledge project, in which students will cooperatively/competitively participate to the definition and test of each-other’s programs, sharing ideas and learning from each other...|$|R
40|$|Three {{studies in}} the machine {{assisted}} proof of recursion implementation are described. The verification system used is Edinburgh LCF (Logic for Computable Functions). Proofs are generated, in LCF, in a goal-oriented fashion by the application of strategies reflecting informal proof plans. LCF is introduced in Chapter 1. We present three case studies in which proof strategies are developed and (except in the third) tested in LCF. Chapter 2 contains {{an account of the}} machine generated proofs of three program transformations (from recursive to iterative function schemata). Two of the examples are taken from Manna and Waldinger. In each case, the recursion is implemented by the introduction of a new data type, e. g., a <b>stack</b> or <b>counter.</b> Some progress is made towards the development of a general strategy for producing the equivalence proofs of recursive and iterative function schemata by machine. Chapter 3 is concerned with the machine generated proof of the correctness of a compiling algorithm. The formulation, borrowed from Russell, includes a simple imperative language with a while and conditional construct, and a low level language of labelled statements, including jumps. We have, in LCF, formalised his denotational descriptions of the two languages and performed a proof of the preservation of the semantics under compilation. In Chapter 4, we express and informally prove the correctness of a compiling algorithm for a language containing declarations and calls of recursive procedures. We present a low level language whose semantics model a standard activation stack implementation. Certain theoretical difficulties (connected with recursively defined relations) are discussed, and a proposed proof in LCF is outlined. The emphasis in this work is less on proving original theorems, or even automatically finding proofs of known theorems, than on (i) exhibiting and analysing the underlying structure of proofs, and of machine proof attempts, and (ii) investigating the nature of the interaction (between a user and a computer system) required to generate proofs mechanically; that is, the transition from informal proof plans to behaviours which cause formal proofs to be performed...|$|R
40|$|As part of {{designing}} and building the Amoeba distributed operating system, {{we have come}} up with a simple set of mechanisms for process management hat allows downloading, process migration, checkpointing, remote debugging and emulation of alien operating system interfaces. The basic process management facilities are realized by the Amoeba Kernel and can be augmented by user-space services: Debug Service, Load-Balancing Service, Unix-Emulation Service, Checkpoint Service, etc. The Amoeba Kernel can produce a representation of the state of a process which can be given to another Kernel where it is accepted for continued exe-cution. This state consists of the memory contents in the form of a collection of segments, and a Process Descriptor which contains the additional state, pro-gram <b>counters,</b> <b>stack</b> pointers, system call state, etc. Careful separation of mechanism and policy has resulted in a compact set of Kernel operations for process creation and management. A collection of user-space services provides process management policies and a simple inter-face for application programs. In this paper we shall describe the mechanisms as they are being imple-mented in the Amoeba Distributed System at the Centre for Mathematics and Computer Science in Amsterdam. We believe that the mechanisms described here can also apply to other distributed systems...|$|R
