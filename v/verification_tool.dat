1072|1551|Public
5000|$|Windows System Requirements <b>Verification</b> <b>Tool</b> from ManufacturerMacintosh System Requirements <b>Verification</b> <b>Tool</b> from Manufacturer ...|$|E
50|$|The current <b>verification</b> <b>tool</b> for ACSL is Frama-C.|$|E
5000|$|Valtrix Systems: Sting (a {{versatile}} design <b>verification</b> <b>tool</b> {{for complex}} SoC/CPU implementations) ...|$|E
40|$|Abstract—We {{present the}} PRISM {{benchmark}} suite: {{a collection of}} probabilistic models and property specifications, designed to facilitate testing, benchmarking and comparisons of probabilistic <b>verification</b> <b>tools</b> and implementations. Keywords-Benchmarks; Probabilistic models; Probabilistic model checking; Probabilistic <b>verification</b> <b>tools...</b>|$|R
40|$|This paper {{describes}} the Process Algebra Compiler (PAC), a front-end generator for processalgebra -based <b>verification</b> <b>tools.</b> Given descriptions {{of a process}} algebra's concrete and abstract syntax and semantics as structural operational rules, the PAC produces syntactic routines and functions for computing the semantics of programs in the algebra. Using this tool greatly simplifies the task of adapting <b>verification</b> <b>tools</b> {{to the analysis of}} systems described in different languages; it may therefore be used to achieve source-level compatibility between different <b>verification</b> <b>tools.</b> Although the initial <b>verification</b> <b>tools</b> targeted by the PAC are MAUTO and the Concurrency Workbench, the structure of the PAC caters for the support of other tools as well. 1 Introduction The past ten years have seen the development of a variety of automatic <b>verification</b> <b>tools</b> for finite-state systems expressed in process algebra; examples include MAUTO [6], the Concurrency Workbench [10], TAV [14], an [...] ...|$|R
40|$|Problem statement: Formal notations employ {{mathematical}} {{symbols and}} interpretation to illustrate system elements. The formality {{imposed by the}} notations allows the accuracy and consistency of a system model to be confirmed by <b>verification</b> <b>tools.</b> Formal notations {{on the other hand}} are difficult to understand and use by most users. As supporting instruments, <b>verification</b> <b>tools</b> are expected to be as usable as possible to overcome this limitation. Approach: This study presented a survey conducted on two instances of <b>verification</b> <b>tools</b> that support a formal method, namely B. The focus of the survey was to identify the important features that are necessary for <b>verification</b> <b>tools</b> to become usable to users. The survey assessed the tools usability based on the Cognitive Dimensions of Notations (CD) framework and several criteria suggested by the International Organization for Standardization (ISO). Sixty-three participants responded to the survey. The data was analyzed by using the grounded theory. Results: The analysis enabled the identification of abstract concepts and properties that formed a design guideline for usable <b>verification</b> <b>tools.</b> The guideline includes there main aspects; Interface, Utilities and Resources Management. Conclusion: The guideline acts as a roadmap for tool designers to design <b>verification</b> <b>tools</b> that promote the use of formal notations...|$|R
50|$|A <b>verification</b> <b>tool</b> for students' {{exemption}} from certain courses in English language programs (course waiver).|$|E
5000|$|Krakatoa, {{a static}} <b>{{verification}}</b> <b>tool</b> {{based on the}} Why verification platform and using the Coq proof assistant.|$|E
50|$|The {{verification}} layer {{consists of}} directives to a <b>verification</b> <b>tool</b> (for instance {{to assert that}} a given property is correct or to assume that a certain set of properties is correct when verifying another set of properties).|$|E
5000|$|Reduced time {{to market}} via {{standard}} development and <b>verification</b> <b>tools</b> ...|$|R
40|$|The paper {{begins by}} {{discussing}} various approaches to hardware specification and verification. The main {{emphasis is on}} using mechanical <b>verification</b> <b>tools</b> to assist the verification process. The case study is the verification of a seven-segment LED display decoder circuit design, in which two popular <b>verification</b> <b>tools,</b> HOL and PVS, are compared and evaluated...|$|R
40|$|Developers rely on {{automated}} testing and <b>verification</b> <b>tools</b> to gain {{confidence in their}} software. The input to such tools is often generated by compilers that {{have been designed to}} generate code that runs fast, not code that can be verified easily and quickly. This makes the <b>verification</b> <b>tool’s</b> task unnecessarily hard. We propose that compilers support a new kind of switch,-OVERIFY, that generates code optimized for the needs of <b>verification</b> <b>tools.</b> We implemented this idea for one class of verification (symbolic execution) and found that, when run on the Coreutils suite of UNIX utilities, it reduces verification time by up to 95 ×. ...|$|R
50|$|A {{software}} <b>verification</b> <b>tool</b> {{for identifying}} the AMD Opteron processors {{listed in the}} above table that may be affected under these specific conditions is available, only to AMD OEM partners. AMD will replace those processors at no charge.|$|E
50|$|The model {{integrity}} can be verified at any time, the Model <b>Verification</b> <b>tool</b> displays errors, warnings and hints. The verification can be customized {{to a degree}} by enabling/disabling verification rules. Models can be verified and list of errors, warnings and hints can be displayed {{as a result of}} model verification process.|$|E
50|$|A {{third party}} tool can be {{qualified}} as a <b>verification</b> <b>tool,</b> but development tools {{must have been}} developed following the DO-178 process. Companies providing these kind of tools as COTS are subject to audits from the certification authorities, to which they give complete access to source code, specifications and all certification artifacts.|$|E
40|$|This {{thesis is}} focused on tools which are used to {{analyzed}} security protocols. In {{the beginning of the}} thesis key goals of security protocols are mentioned and also basic attacks on them are illustrated. Subsequently basic verification techniques, specification languages and <b>verification</b> <b>tools</b> are described. Next part of thesis contains description of protocols in common syntax. Then the main standards used for evaluation of information security products are mentioned. In the end of thesis two well-known <b>verification</b> <b>tools</b> – AVISPA and Scyther - are described and compared to designed methodology of comparing <b>verification</b> <b>tools</b> and their outputs...|$|R
40|$|Program {{verification}} is unusable. But {{perhaps not}} useless. The quality of feedback produced by most <b>verification</b> <b>tools</b> makes it {{virtually impossible to}} use them without an extensive background in formal methods. This position paper proposes a research agenda that seeks to overcome these difficulties, aiming to enable well motivated users {{to take advantage of}} <b>verification</b> <b>tools...</b>|$|R
2500|$|The use of {{citizenship}} <b>verification</b> <b>tools</b> to determine eligibility for taxpayer-funded healthcare benefits ...|$|R
50|$|He {{attended}} the Technion - Israel Institute of Technology in Haifa while simultaneously working at IBM's research laboratory in the city. While at IBM, {{he was responsible}} for developing the Genesys system, a processor <b>verification</b> <b>tool</b> that is used widely within IBM and in other companies such as Advanced Micro Devices and SGS-Thomson.|$|E
50|$|KeYmaera http://symbolaris.com/info/KeYmaera.html (previously called HyKeY) is a {{deductive}} <b>verification</b> <b>tool</b> for {{hybrid systems}} {{based on a}} calculus for the differential dynamic logic dL http://symbolaris.com/logic/dL.html.It extends the KeY tool with computer algebra systems like Mathematica and corresponding algorithms and proof strategies such {{that it can be}} used for practical verification of hybrid systems.|$|E
50|$|A {{derivation}} of the TLP {{based on}} graph theory concepts {{has been given}} by Rafael Vargas-Bernal et al. in 2000. In this work, it is illustrated as a graphical representation {{can be used for}} the future development of a <b>verification</b> <b>tool</b> that plays an important and fundamental role in the structured design of translinear circuits.|$|E
5000|$|IC <b>Verification</b> <b>tools</b> such as Calibre nmDRC, Calibre nmLVS, Calibre xRC, Calibre xACT 3D ...|$|R
40|$|Automated <b>verification</b> <b>tools</b> {{are capable}} of {{detecting}} subtle errors in models of complex software systems. Unfortunately, {{it can be difficult}} to use these tools effectively. Input models must correctly represent essential system behavior. Models must also enable efficient verification in terms of their time and memory requirements. Satisfying these two requirements can be challenging even for experts. But, given a correct model, can a user be confident that the verification results are correct? One way to assess correctness of verification results is to provide translation tools from a modeling language to the input languages of diverse <b>verification</b> <b>tools.</b> Our experiments with automatic translators from the SCR modeling language to the input languages of various <b>verification</b> <b>tools</b> show that <b>verification</b> results produced from automatically translated models are not always consistent. In the tradition of fault identification and fault tolerance provided through diversity, we argue that various <b>verification</b> <b>tools</b> need to be used in concert. Our fault seeding experiments indicate that the results of different model <b>verification</b> <b>tools</b> can be compared, their discrepancies analyzed and modeling faults corrected. Our experiments further imply that “ensemble verification ” should be a viable paradigm for the assessment of high assurance systems in the future. 1...|$|R
40|$|Attempts {{to achieve}} {{widespread}} use of software <b>verification</b> <b>tools</b> have been notably unsuccessful. Even 'straightforward', classic, and potentially effective <b>verification</b> <b>tools</b> such as lint-like tools face limits on their acceptance. These limits are imposed by the expertise required applying the tools and interpreting the results, the high false positive rate of many <b>verification</b> <b>tools,</b> {{and the need to}} integrate the tools into development environments. The barriers are even greater for more complex advanced technologies such as model checking. Web-hosted services for advanced verification technologies may mitigate these problems by centralizing tool expertise. The possible benefits of this approach include eliminating the need for software developer expertise in tool application and results filtering, and improving integration with other development tools...|$|R
50|$|The same {{functionality}} {{which makes}} a debugger useful for eliminating bugs allows it {{to be used as}} a software cracking tool to evade copy protection, digital rights management, and other software protection features. It often also makes it useful as a general <b>verification</b> <b>tool,</b> fault coverage, and performance analyzer, especially if instruction path lengths are shown.|$|E
50|$|The Berkeley Lazy Abstraction Software <b>Verification</b> <b>Tool</b> (BLAST) is a {{software}} model checking tool for C programs. The task addressed by BLAST {{is the need}} to check whether software satisfies the behavioral requirements of its associated interfaces. BLAST employs counterexample-driven automatic abstraction refinement to construct an abstract model that is then model-checked for safety properties. The abstraction is constructed on the fly, and only to the requested precision.|$|E
5000|$|As of September 2015 msnbot {{was still}} active from the Microsoft and the Bing {{webmaster}} help & howto documentation still indicated that msnbot was active (but {{that it would}} retire soon). The <b>verification</b> <b>tool</b> for bingbot previously did not recognise msnbot IP addresses. A test executed on 2016-02-22 resulted in a yes: [...] "Verdict for IP address 157.55.39.150: Yes - this IP address is a verified Bingbot IP address. Name: msnbot-157-55-39-150.search.msn.com." ...|$|E
50|$|Various <b>verification</b> <b>tools,</b> {{such as a}} runtime {{assertion}} checker and the Extended Static Checker (ESC/Java) aid development.|$|R
40|$|The area {{of formal}} {{verification}} of protocols has gained substantial {{importance in the}} recent years. The research results and subsequent applications have amply demonstrated that the formal <b>verification</b> <b>tools</b> have indeed helped correct the protocols even after being standardized. However, the standard protocol <b>verification</b> <b>tools</b> and techniques do not verify the security properties of a cryptographic protocol. This {{has resulted in the}} emergence of the security protocol verifiers to fill the need. In this paper, taking the two popular security <b>verification</b> <b>tools</b> namely Scyther and ProVerif as the basis, we identify a few security protocols and implement them in both Scyther and ProVerif, to aptly evaluate the tools, in terms of the security properties of the selected protocols. In the process, we not only characteristically present a comparative evaluation of the two tools, but also reveal interesting security properties of the protocols selected, showing their strengths and weaknesses. To the best of our knowledge, this is a unique attempt to juxtapose and evaluate the two <b>verification</b> <b>tools</b> using the selected security protocols...|$|R
40|$|International audienceTool-assisted {{verification}} of critical software has great potential but {{is limited by}} two risks: unsoundness of the <b>verification</b> <b>tools,</b> and miscompilation when generating executable code from the sources that were verified. A radical solution to these two risks is the deductive {{verification of}} compilers and <b>verification</b> <b>tools</b> themselves. In this invited talk, I describe two ongoing projects along this line: CompCert, a verified C~compiler, and Verasco, a verified static analyzer based on abstract interpretation...|$|R
50|$|Bumble {{launched}} a photo <b>verification</b> <b>tool</b> in September 2016 {{to insure that}} users of the app were the same people in their profile pictures. To be verified, users are asked to submit a selfie of them performing a specific pose, the picture is reviewed by a real person who ensures the user is {{the person in the}} profile pictures. Bumble was the first dating app to include photo verification in the U.S.|$|E
50|$|This {{high-density}} real-time in situ turbulence {{data can}} be used to alter flight arrival and departure routes. It also can be assimilated into models to improve predictions of threatening turbulence conditions, as well as being used as a <b>verification</b> <b>tool</b> for longer-range numerical weather prediction (NWP)-based turbulence forecasts. As with the icing observations, potential utility of this data in air traffic control decision making for avoidance and mitigation of severe turbulence encounters can be significant.|$|E
50|$|Sometimes a shmoo plot has {{an unusual}} and {{surprising}} shape, {{and while it}} is difficult to determine the exact cause, it is sometimes due to some unusual defect (perhaps in only part of a circuit) coupled with otherwise normal operation. In other cases, it might be an artifact of the electrical testing setup or the test program used, in particular a race condition. As such, a shmoo plot can be a useful test setup <b>verification</b> <b>tool.</b>|$|E
40|$|Model-Based Design with {{automatic}} code generation {{is an important}} and established technology for developing aerospace embedded control systems. Early verification, validation, and test of models and generated code using software tools with accompanying workflows are increasingly used. In 2009, The MathWorks released tool qualification kits for <b>verification</b> <b>tools</b> based on the commercial aviation software standard DO- 178 B. The use of Model-Based Design for DO- 178 B applications using qualified <b>verification</b> <b>tools</b> is described herein. I...|$|R
40|$|International audienceSafety {{verification}} of hybrid dynamical systems relies crucially {{on the ability}} to reason about reachable sets of continuous systems whose evolution is governed by a system of ordinary differential equations (ODEs). <b>Verification</b> <b>tools</b> are often restricted to handling a particular class of continuous systems, such as e. g. differential equations with constant right-hand sides, or systems of affine ODEs. More recently, <b>verification</b> <b>tools</b> capable of working with non-linear differential equations have been developed. The behavior of non-linear systems is known to be in general extremely difficult to analyze because solutions are rarely available in closed-form. In order to assess the practical utility of the various <b>verification</b> <b>tools</b> working with non-linear ODEs it is very useful to maintain a set of verification problems. Similar efforts have been successful in other communities, such as automated theorem proving, SAT solving and numerical analysis, and have accelerated improvements in the tools and their underlying algorithms. We present a set of 65 safety verification problems featuring non-linear polynomial ODEs and for which we have proofs of safety. We discuss the various issues associated with benchmarking the currently available <b>verification</b> <b>tools</b> using these problems...|$|R
40|$|Abstract—Sequentialization {{translates}} concurrent programs into equivalent nondeterministic sequential programs so {{that the}} different concurrent schedules {{no longer need to}} be handled explicitly. It can thus be used as a concurrency preprocessing technique for automated sequential program <b>verification</b> <b>tools.</b> Our CSeq tool implements a novel sequentialization for C programs using pthreads, which extends the Lal/Reps sequentialization to support dynamic thread creation. CSeq now works with three different backend tools, CBMC, ESBMC, and LLBMC, and is competitive with state-of-the-art <b>verification</b> <b>tools</b> for concurrent programs. I...|$|R
