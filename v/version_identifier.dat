9|19|Public
50|$|The <b>version</b> <b>identifier</b> 13 was skipped, {{thought to}} be for reasons of superstition, while 14 was {{used to refer to}} a WebKit-based release of Opera for Android.|$|E
5000|$|A minimal {{well formed}} Stockholm files should contain the header which states the format and <b>version</b> <b>identifier,</b> {{currently}} '# STOCKHOLM 1.0'. Followed by the sequences and corresponding unique sequence names: ...|$|E
50|$|The ISO 15706-2 is the ISO standard, an {{extension}} {{to the existing}} 2002 published standard ISO 15706:2002. The ISO 15706-2 is the Information and documentation — International Standard Audiovisual Number — Part 2: <b>Version</b> <b>identifier.</b>|$|E
40|$|Finding changed {{identifiers}} {{in programs}} {{is important for}} program comparison and merging. Comparing two versions of a program is complicated if renaming has occurred. Textual merging is highly unreliable if, in one <b>version,</b> <b>identifiers</b> were renamed, while in the other version, code using the old identifiers was added or modified. A tool tha...|$|R
5000|$|Creator (PublicationYear): Title. <b>Version.</b> Publisher. ResourceType. <b>Identifier</b> ...|$|R
40|$|Software {{components}} can {{be found}} in both enterprise-wide and mobile/embedded solutions. Components are mutually linked and dependent, but encapsulated as black boxes and developed independently. They can be replac ed without affecting the rest of the application. This advantage requires careful and complex compatibility checks between both component versions though, otherwise the whole application can be broken down. In this paper we present and describe the implementation of the ENT metamodel and the ENT based component comparison algorithm. This algorithm is used in the practical case: OSGi Release 4 components are being compared. On the basis of the change, <b>version</b> <b>identifiers</b> of the newer component are assigned...|$|R
50|$|When IBM {{announced}} the new Power Systems line of servers on April 2, 2008, they renamed {{the operating system}} from i5/OS to IBM i and changed the <b>version</b> <b>identifier</b> format from VxRxMx (Version, Release, Modification, e.g. V6R1M0) to the more standard format (e.g. 6.1).|$|E
5000|$|ISO 15706-2:2007 {{establishes}} a voluntary {{system for the}} identification of versions of audiovisual works and other content derived from or closely related to an audiovisual work. It {{is based on the}} International Standard Audiovisual Number (ISAN) system defined in ISO 15706:2002. An ISAN combined with the version segment, as specified in ISO 15706-2:2007 constitutes an ISAN <b>version</b> <b>identifier,</b> is referred to as a V-ISAN. A V-ISAN is a registered, globally unique identifier for versions of an audiovisual work and related content.|$|E
40|$|The INL {{software}} developers use version control {{for both the}} formally released SAPHIRE versions, {{as well as for}} source code. For each formal release of the software, the developers perform an acceptance test: the software must pass a suite of automated tests prior to official release. Each official release of SAPHIRE is assigned a unique <b>version</b> <b>identifier.</b> The release is bundled into a standard installation package for easy and consistent set-up by individual users. Included in the release is a list of bug fixes and new features for the current release, as well as a history of those items for past releases. Each formal release of SAPHIRE will have passed an acceptance test. In addition to assignment of a unique <b>version</b> <b>identifier</b> for an official software release, each source code file is kept in a controlled library. Source code is a collection of all the computer instructions written by developers to create the finished product. The library is kept on a server, where back-ups are regularly made. This document describes the configuration management approach used as part of the SAPHIRE development...|$|E
40|$|This thesis {{presents}} TransLucid, a low-level, purely declarative, {{intensional programming}} language. Built {{on a simple}} algebra and with just {{a small number of}} primitives, TransLucid programs define arbitrary dimensional infinite data structures, which are then queried to produce results. The formal foundations of TransLucid come from the work in intensional logic by Montague and Scott. The background chapters give a history of intensional logic and its predecessors in the Western world, as well as a history of intensional programming and Lucid, the first intensional programming language. The semantics of TransLucid are fully specified in the form of operational semantics. Three levels of semantics are given, in increasing order of efficiency, with the sequential warehouse semantics, the most efficient, being presented together with a proof that any expression will be evaluated by only examining relevant dimensions in the current context. The language is then extended in three important ways, by adding <b>versioned</b> <b>identifiers,</b> (declarative) side-effects and timestamped equations and demands. Adding <b>versioned</b> <b>identifiers</b> to TransLucid enriches the expressiveness of the language and allows the encoding of a variety of programming paradigms, ranging from manipulating large data-cubes to pattern-matching. Adding side-effects supports {{one of the main reasons}} for TransLucid: namely, to provide a target language, together with a methodology, for translating the main programming paradigms, thus creating a uniform end platform that can be the focus for optimisation and program verification. A translation of imperative programs into TransLucid is given. Timestamped equations and demands enable TransLucid to become a language for synchronous programming in real-time systems, as well as allowing runtime updates to a program's equations. The language TransLucid represents a decisive advance in declarative programming. It has applications in many fields of computer science and opens up exciting new avenues of research...|$|R
40|$|For API users, {{backward}} compatibility of new releases is important, as it permits safe and fast upgrading {{when the new}} release becomes available. To signal safe upgrading, version naming schemes such as semantic versioning provide strict rules on major (breaking changes permitted) versus minor and patch (no breaking changes permitted) releases. In this paper, we analyze seven years of library release history in Maven Central, and contrast <b>version</b> <b>identifiers</b> with actual incompatibilities. We find that around one third of all releases introduce at least one breaking change, and that this figure {{is the same for}} minor and major releases. Furthermore, we find that deprecation tags that could signal breaking changes are hardly used. We explore the wider implications of our findings, concerning education, tool support, versioning principles, and repository mining research. Software TechnologyElectrical Engineering, Mathematics and Computer Scienc...|$|R
40|$|Finding changed {{identifiers}} {{in programs}} {{is important for}} program comparison and merging. Comparing two versions of a program is complicated if renaming has occurred. Textual merging is highly unreliable if, in one <b>version,</b> <b>identifiers</b> were renamed, while in the other version, code using the old identifiers was added or modified. A tool that automatically detects renamed identifiers between pairs of program modules is presented. The detector {{is part of a}} suite of intelligent differencing and merging programs that exploit the static semantics of programming languages. No special editor is needed for tracking changes. The core of the renaming detector is language independent. The detector works with multiple file pairs, taking into account renamings that affect multiple files. Renaming detectors for Java and Scheme have been implemented. A case study is presented that demonstrates proof of concept. With renaming detection, a higher quality of program comparison and merging is achievable [...] . ...|$|R
40|$|Abstract: This paper {{deals with}} class and {{interface}} name clashes in Java component systems that occur because of evolutionary changes during the lifecycle of a component application. We {{show that the}} standard facilities of the Java type system do not provide a satisfactory {{way to deal with}} the name clashes, and present a solution based on administering the names of classes and interfaces with a <b>version</b> <b>identifier</b> using a byte code manipulation tool. We provide a proof of concept implementation...|$|E
40|$|When {{developing}} {{software components}} in a distributed environment, certain issues regarding the component specifications must be handled: 1. specifications need to consistently reference concrete versions of other specifications, while easy transition {{to refer to}} the new versions in either a specification or an implementation is demanded; 2. a hierarchy of description languages exists; specifications declared in additional description languages need to reference specifications already declared in preceding languages; 3. specifications are expected to evolve (potentially in multiple lines of development) while being at the same time used on other, potentially disconnected nodes; 4. a successor relation among the versions is desired. In the common solutions available, these issues are usually addressed only by a simple unique <b>version</b> <b>identifier.</b> We address the issue using a concept of a repository holding the specifications, assuming existence of a federation of the repositories. Besides generic reasoning, we propose a concrete realization of the concept, the Type Information Repository (TIR), integrated into the SOFA component model. Meanwhile, we also derive general requirements for a version model to be used in such a repository and we also describe the concrete version model used in TIR; we show its integration with the SOFA Component Definition Language (CDL) and rules to be imposed on combining di#erent versions of related specifications in CDL declarations. The integration also includes rules for automatic selection of the appropriate version (profiles are used for this). The concept of a repository has been proven as realistic by implementing TIR and a CDL compiler storing compiled specifications in the repository. Furthermore, a graphica [...] ...|$|E
40|$|This report {{describes}} some of {{the challenges}} of software versioning in an SOA environment and provides guidance on how {{to meet these challenges}} by following industry guidelines and recommended practices. Managing change in software systems becomes more difficult as the software increases in size, complexity, and dependencies. Part of this task is software versioning, in which <b>version</b> <b>identifiers</b> are assigned to software artifacts for the purpose of managing their evolution. However, software versioning is not a self-contained task. Versioning decisions affect a wide range of processes that fall under the broad heading of change management. With the advent of service-oriented architecture (SOA) as a software-development paradigm, software versioning has become even more en¬twined with the software life cycle, mainly due to the highly distributed nature, multiproduct outcome, and multilayer implementation of service-oriented systems. The report describes typical items that a versioning policy for a service-oriented system should contain, including which artifacts to version, how to apply version control, and the impact of versioning on each phase of the life cycle within an SOA infrastructure...|$|R
40|$|GenBank R © (www. ncbi. nlm. nih. gov/genbank/) is a {{comprehensive}} database that contains publicly avail-able nucleotide sequences for over 340 000 formally described species. Recent developments include a new starting page for submitters, a shift toward using accession. <b>version</b> <b>identifiers</b> rather than GI numbers, a wizard for submitting 16 S rRNA sequences, and an Identical Protein Report to address growing issues of data redundancy. GenBank organizes the sequence data received from individual laboratories and large-scale sequencing projects into 18 divisions, and Gen-Bank staff assign unique accession. version iden-tifiers upon data receipt. Most submitters use the web-based BankIt or standalone Sequin programs. Daily data exchange with the European Nucleotide Archive (ENA) and the DNA Data Bank of Japan (DDBJ) ensures worldwide coverage. GenBank is ac-cessible through the nuccore, nucest, and nucgss databases of the Entrez retrieval system, which in-tegrates these records {{with a variety of}} other data including taxonomy nodes, genomes, protein struc-tures, and biomedical journal literature in PubMed. BLAST provides sequence similarity searches of GenBank and other sequence databases. Complete bimonthly releases and daily updates of the GenBank database are available by FTP...|$|R
30|$|Figure 4 {{presents}} the main abstractions related to requirements. Requirement is a property {{that must be}} exhibited by a product, some of its part (e.g., subsystem, module), or its development process. Requirement has description, <b>identifier,</b> <b>version,</b> type, state, owner, and stakeholders as its attributes.|$|R
50|$|Early {{versions}} of BASIC on microcomputers were infamous for one- or two-character variable names, {{which made the}} meanings of variables difficult to recall in complex programs. MBASIC <b>version</b> 5 allowed <b>identifiers</b> up to 40 characters long, which permitted programmers to give variables readable names.|$|R
50|$|There {{are many}} {{different}} schemes and formats for digital identifiers. The most widely used is Uniform Resource Identifier (URI) and its internationalized <b>version</b> Internationalized Resource <b>Identifier</b> (IRI)—the standard for identifiers on the World Wide Web. OpenID and Light-Weight Identity (LID) are two web authentication protocols that use standard HTTP URIs (often called URLs), for example.|$|R
40|$|Information flow is {{intensive}} {{during a}} design process, where delivering timely and appropriate information is required. Sonnenwald [2] identified 13 communication roles that emerged during four multidisciplinary design situations in the USA and Europe. She stated that participants from different disciplines, organisations and cultures {{come to the}} design situation with pre-existing patterns of working activities, and specialised work languages. Different methods to represent information flow activities are used, varying in different companies, different disciplines, and different teams, which may cause misunderstandings particularly among design teams composed of different organisations. In this sense, {{it is important to}} present information flow in a rigorous way. Eastman and Shirley [3] developed a model of design information flow. The model dealt with design information management, reflecting entities, constraints, design states, design document accessed modes, transactions, and <b>version</b> <b>identifiers.</b> But, the development of their model was not based upon a theoretical foundation. In this paper, we develop an alternative model to present information flow in design based on a foundation of situation theory. The model may serve to analysis design information system and provide a basis for investigating the situatedness of design information flow. To be able to represent information flow we should firstly study its phenomena. Based on Sim's formalism of design activities, the theory of Speech Acts, Computer Supported Cooperative Work (CSCW, and other works studying information flow, an example model for information flow in design is developed. A discussion of {{the strengths and weaknesses of}} this representation method is carried out...|$|R
40|$|The Semantic Web {{is built}} on top of Knowledge Organization Systems (KOS) (vocabularies, ontologies, concept schemes) that provide a structured, {{interoperable}} and distributed access to Linked Data on the Web. The maintenance of these KOS over time has produced a number of KOS version chains: subsequent unique <b>version</b> <b>identifiers</b> to unique states of a KOS. However, the release of new KOS versions pose challenges to both KOS publishers and users. For publishers, updating a KOS is a knowledge intensive task that {{requires a lot of}} manual effort, often implying deep deliberation on the set of changes to introduce. For users that link their datasets to these KOS, a new version compromises the validity of their links, often creating ramifications. In this paper we describe a method to automatically detect which parts of a Web KOS are likely to change in a next version, using supervised learning on past versions in the KOS version chain. We use a set of ontology change features to model and predict change in arbitrary Web KOS. We apply our method on 139 varied datasets systematically retrieved from the Semantic Web, obtaining robust results at correctly predicting change. To illustrate the accuracy, genericity and domain independence of the method, we study the relationship between its effectiveness and several characterizations of the evaluated datasets, finding that predictors like the number of versions in a chain and their release frequency have a fundamental impact in predictability of change in Web KOS. Consequently, we argue for adopting a release early, release often philosophy in Web KOS development cycles. Comment: 16 pages, 6 figures, ISWC 2015 conference pre-print The paper has been withdrawn due to significant overlap with a subsequent paper submitted to a conference for revie...|$|R
5000|$|The LAPA Boeing 737-200 plane, LAPA flight 3142, {{went into}} flames after {{crashing}} into a mound in midtown Buenos Aires, causing {{the death of}} 65 people, and severely injuring 17. The film's basic theme: the general corrosive deregulation, the greedy cost-cutting corporations, and the corrupt government officials, found in the Argentine airline industry. The film is named after the NATO phonetic alphabet <b>version</b> of the <b>identifier</b> of the accident aircraft, LV-WRZ (Lima Victor - Whisky Romeo Zulu) ...|$|R
40|$|INSPIRE is a EU-wide {{data and}} service {{infrastructure}} for the cross-border sharing of environmental data {{and for their}} use in support to policy making. This paper introduces the context, requirements and issues for registers and registries in INSPIRE, including persistent <b>identifiers,</b> <b>versioning,</b> multi-linguality, extensibility, linking and alignment with existing registers and cross-sector interoperability and re-use. In our presentation, besides highlighting open issues relevant {{not only in the}} scope of INSPIRE, we will report the results of an INSPIRE workshop on registers/registries taking place on 22 - 23 January 2014. JRC. H. 6 -Digital Earth and Reference Dat...|$|R
5000|$|In {{this version}} the phylogenetic trees {{represent}} speciation and gene duplication events. Identification of gene orthologs is possible. There are {{more support for}} alternative database identifiers for genes, proteins and microarray probes. PANTHER version 7 uses the SBGN standard to depict biological pathways. It includes 48 set of genomes. To define the new families and {{in collaboration with the}} European Bioinformatics Institute’s InterPro group, approximately 1000 families of non-animal genomes were added in this version. The sources of gene sets included model organism databases, Ensembl genome annotation and Entrez Gene. Since this <b>version,</b> a stable <b>identifier</b> to each node in the tree is used. This stable identifier is a nine-digit number with the prefix PTN (stand for PANTHER Tree Node). (2009) ...|$|R
40|$|Software {{versioning}} is {{an important}} part of the software development process. A ver-sion (of a software artifact) represents a state of an evolving artifact. Versioning of software artifacts is done by assigning unique identifiers to the artifacts that are being <b>versioned.</b> These <b>identifiers</b> are in a form that allows a temporal relation between differ-ent versions of an artifact, e. g. version 1. 0 is created before version 2. 0 etc. Versioning is used in conjunction with revision control. Revision control assumes the existence of a repository and enables efficient storage, manipulation, and retrieval of any version of an artifact in the repository. Software versioning together with revision control al-lows teams of developers to work on multiple versions of software at the same time, as well as for teams of developers to work on the same version at the same time, and to synchronize (merge) their work when needed. Data put under version control is usually contained in (text) files [1]. Hence, file is the unit of versioning (UOV) as described by Murta et al. [2]. Software versioning systems have several important features. One of the most important features is the way storage of different versions of a UOV is handled. This is done by storing only the dif...|$|R
30|$|For {{improvement}} of speed, the application {{depends on the}} network speed and number of items to be downloaded. It only occurs when threaded url connections are used {{to speed up the}} application, and it is provided by the asyncimageview class. The application contacts the server in two distinct stages. The first contains information about the device (name, model, localized model, system name, system <b>version,</b> and unique <b>identifier).</b> The second communication occurs when the application makes a request for data (news content feed), and at this point the information to server contains battery status and client type. These stages are important for the success of the ubiquitous system. Other requests are motivated by references of thumbnails and images included in the XML file. This request just happens if the user allows image loading on settings, and if the used network is 3 G or Wi-Fi.|$|R
40|$|The EMBL-European Bioinformatics Institute (EMBL-EBI) offers {{public access}} to patent {{sequence}} data, providing a valuable service to the intellectual property and scientific communities. The non-redundant (NR) patent sequence databases com-prise two-level nucleotide and protein sequence clusters (NRNL 1, NRNL 2, NRPL 1 and NRPL 2) based on sequence identity (level- 1) and patent family (level- 2). Annotation from the source entries in these databases is merged and enhanced with additional information from the patent literature and biological context. Corrections in patent publication numbers, kind-codes and patent equivalents significantly improve the data quality. Data are available through various user interfaces including web browser, downloads via FTP, SRS, Dbfetch and EBI-Search. Sequence similarity/homology searches against the databases are available using BLAST, FASTA and PSI-Search. In this article, we describe the data collection and annotation and also outline major changes and improvements introduced since 2009. Apart from data growth, these changes include additional annotation for singleton clusters, the <b>identifier</b> <b>versioning</b> for tracking entry change and the entry mapping...|$|R

