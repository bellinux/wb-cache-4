0|199|Public
5000|$|System V Application <b>Binary</b> <b>Interface</b> Edition 4.1 (1997-03-18) ...|$|R
5000|$|PowerPC Embedded Application <b>Binary</b> <b>Interface</b> 32-Bit Implementation (1995-10-01) ...|$|R
5000|$|... 64-bit PowerPC ELF Application <b>Binary</b> <b>Interface</b> Supplement Version 1.9 (2004) ...|$|R
5000|$|In 2014, {{the maximum}} size {{allowed for a}} {{notification}} payload sent through the <b>binary</b> <b>interface</b> was increased from 256 bytes to 2 kilobytes. In December 2015, a new HTTP/2 provider API was released by Apple, effectively replacing the now-legacy <b>binary</b> <b>interface.</b> The maximum notification payload size allowed using the HTTP/2 API is 4 kilobytes.|$|R
3000|$|Sandbox-based {{isolation}} (Instruction Set Architecture, Application <b>Binary</b> <b>Interface,</b> Access Control List); [...]...|$|R
5000|$|An {{application}} <b>binary</b> <b>interface</b> (ABI) {{based on}} Executable and Linkable Format (ELF).|$|R
50|$|By choice, the Linux kernel {{has never}} {{maintained}} a stable in-kernel Application <b>binary</b> <b>interface.</b>|$|R
5000|$|It {{eliminates}} the fragile <b>binary</b> <b>interface</b> problem; superclasses can change sizes without affecting binary compatibility.|$|R
500|$|... armel: Little-endian ARM {{architecture}} (ARMv4T instruction set) {{on various}} embedded systems (embedded application <b>binary</b> <b>interface</b> (EABI)) ...|$|R
50|$|Other {{compiler}} improvements included whole program optimization (WPO) and devirtualization and ARM embedded-application <b>binary</b> <b>interface</b> (EABI) support.|$|R
3000|$|... {{of the set}} of <b>virtual</b> {{detecting}} <b>binary</b> sensors. The {{time when}} the first pedestrian enters into the sensing region of the set of <b>virtual</b> detecting <b>binary</b> sensors [...]...|$|R
5000|$|Lack of {{centralized}} authoritative {{support for}} DLL application <b>binary</b> <b>interface</b> management and safeguards, allowing incompatible DLLs {{with the same}} file name and internal version numbers to be released; ...|$|R
5000|$|The same {{application}} programming interface (API) {{and application}} <b>binary</b> <b>interface</b> (ABI), so application programs can be transferred between MFT and MVT without even needing to be modified or re-assembled or re-compiled.|$|R
50|$|An embedded-application <b>binary</b> <b>interface</b> (EABI) {{specifies}} standard conventions for file formats, data types, register usage, stack frame organization, {{and function}} parameter passing of an embedded software program, {{for use with}} an embedded operating system.|$|R
50|$|In 1992, Brown joined Sun Microsystems. He helped {{establish}} the process {{used for the}} company's system software architecture, {{and then went on}} to define the application <b>binary</b> <b>interface</b> for Solaris, Sun's principal system software product.|$|R
50|$|Symbian OS 9 and the Symbian {{platform}} use a {{new application}} <b>binary</b> <b>interface</b> (ABI) {{and needed a}} different compiler. A choice of compilers is available including a newer version of GCC (see external links below).|$|R
50|$|An API {{differs from}} an {{application}} <b>binary</b> <b>interface</b> (ABI) in that an API is source code based while an ABI is binary based. For instance, POSIX provides APIs, while the Linux Standard Base provides an ABI.|$|R
40|$|AbstractThe {{application}} <b>binary</b> <b>interface</b> x 32 (x 32 -ABI) {{was introduced}} in Linux kernel 3. 4 {{and is based on}} the x 64 instruction set. Instead of 64 -bit it uses 32 -bit as size for pointers and C-data type long, reducing consequently memory overhead. As several LHC applications, especially reconstruction and analysis software, suffer memory problems, since the change from 32 - to 64 -bit, this <b>binary</b> <b>interface</b> has been evaluated. This paper shows that in most of the applications, used at CERN, the memory overhead can be reduced between 3 % and 35 % and the corresponding difference in CPU-time can be improved up to 30 %...|$|R
50|$|In {{the early}} to mid-1990s, Microsoft heavily {{promoted}} its COM standard as a <b>binary</b> <b>interface</b> between different OOP programming languages. COM programming equally promoted early and late binding, with many languages supporting both at the syntax level.|$|R
3000|$|... }∪{t 0 ′,t 1 ′,…,t L′′} {{in order}} of time. Equation (2) {{indicates}} {{the sum of the}} Hamming distance between the output of the binary sensor bx,y and that of the corresponding <b>virtual</b> <b>binary</b> sensors b x,y′ for all binary sensors in the set of detecting binary sensors [...]...|$|R
50|$|The Jazelle state {{relies on}} an agreed calling {{convention}} between the JVM and the Jazelle hardware state. This application <b>binary</b> <b>interface</b> is not published by ARM, rendering Jazelle an undocumented feature for most users and Free Software JVMs.|$|R
5000|$|On some {{computer}} architectures the application <b>binary</b> <b>interface</b> also supports an sbss segment for [...] "small data". Typically, these data items {{can be accessed}} using shorter instructions that may {{only be able to}} access a certain range of addresses.|$|R
50|$|Finally, {{the data}} soup concept {{works well for}} data like addresses, which benefit from being shared cross-functionally, but it works poorly for {{discrete}} data sets like files and documents. Later, the 2.0 release of the Newton OS introduced <b>Virtual</b> <b>Binary</b> Objects to alleviate the problem of handling large data objects.|$|R
50|$|The fragile <b>binary</b> <b>interface</b> {{problem or}} FBI is a {{shortcoming}} of certain object-oriented programming language compilers, in which internal changes to an underlying class library can cause descendant libraries or programs to cease working. It {{is an example}} of software brittleness.|$|R
50|$|Solaris also {{supports}} the Linux platform application <b>binary</b> <b>interface</b> (ABI), allowing Solaris to run native Linux binaries on x86 systems. This feature is called Solaris Containers for Linux Applications (SCLA), {{based on the}} branded zones functionality introduced in Solaris 10 8/07.|$|R
50|$|The ALP SDK used an Eclipse-based {{integrated}} {{development environment}} (IDE), with added plug-ins, as did its predecessor Palm OS development environment. The compilers used were embedded application <b>binary</b> <b>interface</b> (EABI) enabled ARM versions of the standard GNU Compiler Collection (GCC) tool chain.|$|R
25|$|Efforts toward {{standardization}} included Sun's Public Windows Interface (PWI) for Win16 (see also: Sun Windows Application <b>Binary</b> <b>Interface</b> (Wabi)), Willows Software's Application Programming Interface for Windows (APIW) for Win16 and Win32 (see also: Willows TWIN), and ECMA-234, which {{attempted to}} standardize the Windows API bindingly.|$|R
50|$|C's {{application}} <b>binary</b> <b>interface</b> (ABI) {{is supported}} {{as well as}} all of C's fundamental and derived types, enabling direct access to existing C code and libraries. D bindings are available for many popular C libraries. Additionally, C's standard library is a part of standard D.|$|R
50|$|Efforts toward {{standardization}} included Sun's Public Windows Interface (PWI) for Win16 (see also: Sun Windows Application <b>Binary</b> <b>Interface</b> (Wabi)), Willows Software's Application Programming Interface for Windows (APIW) for Win16 and Win32 (see also: Willows TWIN), and ECMA-234, which {{attempted to}} standardize the Windows API bindingly.|$|R
50|$|Genesi is an {{official}} Linaro partner and its software development {{team has been}} instrumental in moving Linux on the ARM architecture towards a wider adoption of the hard-float application <b>binary</b> <b>interface,</b> which is incompatible with most existing applications but provides enormous performance gains for many use cases.|$|R
50|$|Some {{processor}} families, {{such as the}} x86, {{have special}} instructions for manipulating the stack of the currently executing thread. Other processor families, including PowerPC and MIPS, do not have explicit stack support, but instead rely on convention and delegate stack management to the operating system's application <b>binary</b> <b>interface</b> (ABI).|$|R
50|$|An {{example of}} a symbol table {{can be found in}} the SysV Application <b>Binary</b> <b>Interface</b> (ABI) specification, which {{mandates}} how symbols are to be laid out in a binary file, so that different compilers, linkers and loaders can all consistently find and work with the symbols in a compiled object.|$|R
50|$|Genie allows {{access to}} C libraries, {{especially}} those based in GObject (like GTK+), without {{using a different}} application <b>binary</b> <b>interface</b> (ABI). During compilation, the code is first translated to C source and header files, which are then compiled to platform-specific machine code using any available C compiler like GCC, thus allowing cross-platform software development.|$|R
50|$|Languages that {{implement}} {{data abstraction}} include Ada and Modula-2. Object-oriented languages are commonly claimed to offer data abstraction; however, their inheritance concept tends to put {{information in the}} interface that more properly belongs in the implementation; thus, changes to such information ends up impacting client code, leading directly to the Fragile <b>binary</b> <b>interface</b> problem.|$|R
5000|$|Autopackage was {{designed}} for installing binary, or pre-compiled, versions of non-core applications such as word processors, web browsers, and personal computer games, rather than core libraries and applications such as operating system shells. Concept of autopackage was to [...] "improve" [...] Linux to a desktop platform, with stable <b>binary</b> <b>interfaces</b> comparable to Windows and MacOS.|$|R
50|$|High-level {{programming}} languages {{can suffer}} from performance penalties because glue code must {{run through the}} language interpreter, even when connecting high-performance subsystems. If performance is crucial, using configuration scripting is often preferred to directly connecting <b>binary</b> <b>interfaces</b> of components. In object-oriented scripting languages, glue code often {{eliminates the need for}} class hierarchies and large numbers of classes.|$|R
