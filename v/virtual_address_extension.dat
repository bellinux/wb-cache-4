6|1376|Public
5000|$|VAX (<b>Virtual</b> <b>Address</b> <b>eXtension),</b> a {{computer}} architecture and family of computers developed by DEC.|$|E
50|$|The VAXstation was {{a family}} of {{workstation}} computers developed and manufactured by Digital Equipment Corporation (DEC) using processors implementing the VAX instruction set architecture (ISA). VAX stood for <b>Virtual</b> <b>Address</b> <b>EXtension.</b>|$|E
5000|$|In April 1975, Digital began a {{hardware}} project, code-named Star, {{to design a}} 32-bit <b>virtual</b> <b>address</b> <b>extension</b> to its PDP-11. In June 1975, Cutler, together with Dick Hustvedt and Peter Lipman, were appointed the technical project leaders for the software project, code-named Starlet, to develop a totally new operating system for the Star family of processors. These two projects were tightly integrated from the beginning.|$|E
5000|$|... 40-bit Large Physical <b>Address</b> <b>Extensions</b> (LPAE) <b>addressing</b> up to 1 TB of RAM. As per the x86 Physical <b>Address</b> <b>Extension,</b> <b>virtual</b> <b>address</b> space remains 32 bit.|$|R
25|$|Memory {{translation}} from 48-bit <b>virtual</b> <b>addresses</b> {{based on}} the existing Large Physical <b>Address</b> <b>Extension</b> (LPAE), {{which was designed to}} be easily extended to 64-bit.|$|R
5000|$|A few {{computers}} have a main memory {{larger than the}} <b>virtual</b> <b>address</b> space of a process, such as the Magic-1, some PDP-11 machines, and some systems using 32-bit x86 processors with Physical <b>Address</b> <b>Extension.</b> This nullifies a significant advantage of virtual memory, since a single process cannot use more main memory than the amount of its <b>virtual</b> <b>address</b> space. Such systems often use paging techniques to obtain secondary benefits: ...|$|R
5000|$|The name [...] "VAX" [...] {{originated}} as {{an acronym}} for <b>virtual</b> <b>address</b> <b>extension,</b> both because the VAX {{was seen as a}} 32-bit extension of the older 16-bit PDP-11 and because it was (after Prime Computer) an early adopter of virtual memory to manage this larger address space. Early versions of the VAX processor implemented a [...] "compatibility mode" [...] that emulated many of the PDP-11's instructions, and were in fact called VAX-11 to highlight this compatibility and that VAX-11 was an outgrowth of the PDP-11 family. Later versions offloaded the compatibility mode and some of the less used CISC instructions to emulation in the operating system software.|$|E
50|$|In 1976, DEC {{decided to}} extend the PDP-11 {{architecture}} to 32 bits while adding a complete virtual memory system to the simple paging and memory protection of the PDP-11. The result was the VAX architecture, where VAX stands for <b>Virtual</b> <b>Address</b> <b>eXtension</b> (from 16 to 32 bits). The first computer to use a VAX CPU was the VAX-11/780, which DEC {{referred to as a}} superminicomputer. Although it was not the first 32-bit minicomputer, the VAX-11/780's combination of features, price, and marketing almost immediately propelled it to a leadership position in the market after it was released in 1978. VAX systems were so successful that in 1983, DEC canceled its Jupiter project, which had been intended to build a successor to the PDP-10 mainframe, and instead focused on promoting the VAX as the single computer architecture for the company.|$|E
50|$|In April 1975, Digital Equipment Corporation {{embarked}} on a hardware project, code named Star, to design a 32-bit <b>virtual</b> <b>address</b> <b>extension</b> to its PDP-11 computer line. A companion software project, code named Starlet, was started in June 1975 to develop a totally new operating system, based on RSX-11M, for the Star family of processors. These two projects were tightly integrated from the beginning. Gordon Bell was the VP lead on the VAX hardware and its architecture. Roger Gourd was the project lead for the Starlet program, with software engineers Dave Cutler (who would later lead development of Microsoft's Windows NT), Dick Hustvedt, and Peter Lipman acting as the technical project leaders, each having responsibility for a different area of the operating system. The Star and Starlet projects culminated in the VAX 11/780 computer and the VAX-11/VMS operating system. The Starlet name survived in VMS as a name {{of several of the}} main system libraries, including STARLET.OLB and STARLET.MLB.|$|E
5000|$|... 32-bit linear <b>addresses</b> are <b>virtual</b> <b>addresses</b> {{rather than}} {{physical}} addresses; they are translated to physical addresses through a page table. In the 80386, 80486, {{and the original}} Pentium processors, the physical address was 32 bits; in the Pentium Pro and later processors, the Physical <b>Address</b> <b>Extension</b> allowed 36-bit physical addresses, although the linear address size was still 32 bits.|$|R
50|$|In the Intel 80386 and later, {{protected}} mode retains the segmentation mechanism of 80286 {{protected mode}}, but a paging unit {{has been added}} as a second layer of address translation between the segmentation unit and the physical bus. Also, importantly, address offsets are 32-bit (instead of 16-bit), and the segment base in each segment descriptor is also 32-bit (instead of 24-bit). The general operation of the segmentation unit is otherwise unchanged. The paging unit may be enabled or disabled; if disabled, operation {{is the same as}} on the 80286. If the paging unit is enabled, addresses in a segment are now <b>virtual</b> <b>addresses,</b> rather than physical addresses as they were on the 80286. That is, the segment starting address, the offset, and the final 32-bit address the segmentation unit derived by adding the two are all <b>virtual</b> (or logical) <b>addresses</b> when the paging unit is enabled. When the segmentation unit generates and validates these 32-bit <b>virtual</b> <b>addresses,</b> the enabled paging unit finally translates these <b>virtual</b> <b>addresses</b> into physical addresses. The physical addresses are 32-bit on the 386, but can be larger on newer processors which support Physical <b>Address</b> <b>Extension.</b>|$|R
5000|$|<b>Address</b> Windowing <b>Extensions</b> (AWE) is a Microsoft Windows {{application}} programming interface {{that allows}} a 32-bit software application to access more physical memory than it has <b>virtual</b> <b>address</b> space, even {{in excess of the}} 4 GB limit. The process of mapping an application's <b>virtual</b> <b>address</b> space to physical memory under AWE is known as [...] "windowing", and is similar to the overlay concept of other environments. AWE is beneficial to certain data-intensive applications, such as database management systems and scientific and engineering software, that need to manipulate very large data sets while minimizing paging.|$|R
50|$|However, {{this does}} not always hold true. Computers can have memory {{addresses}} larger or smaller than their word size. For instance, many 8-bit processors, such as the MOS Technology 6502, supported 16-bit addressesâ€” if not, {{they would have been}} limited to a mere 256 bytes of memory addressing. The 16-bit Intel 8088 and Intel 8086 supported 20-bit addressing via segmentation, allowing them to access 1 MiB rather than 64 KiB of memory. All Intel Pentium processors since the Pentium Pro include Physical <b>Address</b> <b>Extensions</b> (PAE) which support mapping 36-bit physical <b>addresses</b> to 32-bit <b>virtual</b> <b>addresses.</b>|$|R
5000|$|Device {{addressing}} use {{three different}} 'digits' A|PL|GR. The A mean the room, the PL is the Point of Load in the room, and GR is the group. Group join loads in same or different rooms in a logical manner. Not all devices has group addressing. All devices must answer to room broadcast called AMB. All devices must answer to general broadcast called GEN. Physical and <b>Virtual</b> <b>addressing</b> has different limitations:In big houses and buildings, SCS <b>address</b> <b>extension</b> is possible, were different address domains are connected via some bridges. Only {{some kind of}} messages can cross a bridge.Here the values of physical configuration jumpers: ...|$|R
40|$|Security {{systems can}} provide secure and {{efficient}} in-VM monitoring. An exemplary security {{system can be}} built upon hardware virtualization features and can comprise a virtual machine having a plurality of standard <b>virtual</b> <b>address</b> spaces, {{as well as a}} hidden <b>virtual</b> <b>address</b> space. While the standard <b>virtual</b> <b>address</b> spaces can be directly accessible by a kernel in the virtual machine, the hidden <b>virtual</b> <b>address</b> space can be hidden from the kernel, which can be absent a virtual page table corresponding to the hidden <b>virtual</b> <b>address</b> space. A security monitor can reside in the hidden address space, monitoring the kernel without being modifiable by the kernel. A processor can transfer focus from the standard <b>virtual</b> <b>address</b> spaces to the hidden <b>virtual</b> <b>address</b> space only through predetermined entry gates, and the processor can transfer focus from the hidden <b>virtual</b> <b>address</b> space to the standard <b>virtual</b> <b>address</b> spaces only through predetermined exit gates. Georgia Tech Research Corporatio...|$|R
50|$|The Kernel <b>Virtual</b> <b>Address</b> Space (KVA) is {{the virtual}} memory {{area in which}} all Linux kernel threads reside. The {{second part of the}} <b>virtual</b> <b>address</b> space is {{occupied}} by the User <b>Virtual</b> <b>Address</b> Space which contain user threads.|$|R
50|$|Relative <b>virtual</b> <b>addresses</b> (RVAs) {{are not to}} be {{confused}} with standard <b>virtual</b> <b>addresses.</b> A relative <b>virtual</b> <b>address</b> is the <b>virtual</b> <b>address</b> of an object from the file once it is loaded into memory, minus the base address of the file image. If the file were to be mapped literally from disk to memory, the RVA would be the same as that of the offset into the file, but this is actually quite unusual.|$|R
25|$|The kernel has {{full access}} to the system's memory and must allow {{processes}} to safely access this memory as they require it. Often {{the first step in}} doing this is <b>virtual</b> <b>addressing,</b> usually achieved by paging and/or segmentation. <b>Virtual</b> <b>addressing</b> allows the kernel to make a given physical address appear to be another <b>address,</b> the <b>virtual</b> <b>address.</b> <b>Virtual</b> <b>address</b> spaces may be different for different processes; the memory that one process accesses at a particular (<b>virtual)</b> <b>address</b> may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.|$|R
50|$|Although <b>virtual</b> <b>addresses</b> are 64 bits wide in 64-bit mode, current {{implementations}} (and all chips {{known to}} be in the planning stages) do not allow the entire <b>virtual</b> <b>address</b> space of 264 bytes (16 EB) to be used.This would be approximately four billion times the size of <b>virtual</b> <b>address</b> space on 32-bit machines. Most operating systems and applications will not need such a large address space for the foreseeable future, so implementing such wide <b>virtual</b> <b>addresses</b> would simply increase the complexity and cost of address translation with no real benefit. AMD therefore decided that, in the first implementations of the architecture, only the least significant 48 bits of a <b>virtual</b> <b>address</b> would actually be used in address translation (page table lookup).|$|R
40|$|A <b>virtual</b> <b>address</b> cache memory, whose {{operation}} is controlled explicitly by software, is presented. Ad-hoc hardware mechanisms, including new machine instructions {{and a new}} operand addressing mode, reduce the complexity of cache management logic in favour of {{the capacity of the}} cache, and solve the major problem of <b>virtual</b> <b>address</b> cache organization: two or more <b>virtual</b> <b>addresses</b> mapping into the same real address...|$|R
50|$|Nearly all current {{implementations}} {{of virtual}} memory divide a <b>virtual</b> <b>address</b> space into pages, blocks of contiguous <b>virtual</b> memory <b>addresses.</b> Pages on contemporary systems are usually at least 4 kilobytes in size; systems with large <b>virtual</b> <b>address</b> ranges or amounts of real memory generally use larger page sizes.|$|R
25|$|The Alpha has a 64-bit linear <b>virtual</b> <b>address</b> {{space with}} no memory segmentation. Implementations can {{implement}} a smaller <b>virtual</b> <b>address</b> {{space with a}} minimum size of 43 bits. Although the unused bits were not implemented in hardware such as TLBs, the architecture required implementations to check whether they are zero to ensure software compatibility with implementations with a larger (or full) <b>virtual</b> <b>address</b> space.|$|R
5000|$|The AMD64 {{architecture}} {{defines a}} 64-bit <b>virtual</b> <b>address</b> format, {{of which the}} low-order 48 bits are used in current implementations. This allows up to 256 TB (248 bytes) of <b>virtual</b> <b>address</b> space. The architecture definition allows this limit to be raised in future implementations to the full 64 bits, extending the <b>virtual</b> <b>address</b> space to 16 EB (264 bytes). This is compared to just 4 GB (232 bytes) for the x86.|$|R
5000|$|If the {{processor}} and operating system support multiple <b>virtual</b> <b>address</b> spaces, the [...] "extra memory" [...] {{can be used}} to run more processes. Paging allows the cumulative total of <b>virtual</b> <b>address</b> spaces to exceed physical main memory.|$|R
50|$|An iconic {{example of}} virtual-to-physical <b>address</b> {{translation}} is <b>virtual</b> memory, where different pages of <b>virtual</b> <b>address</b> space map either to page file or to main memory physical address space. It {{is possible that}} several numerically different <b>virtual</b> <b>addresses</b> all refer to one physical address and hence to the same physical byte of RAM. It {{is also possible that}} a single <b>virtual</b> <b>address</b> maps to zero, one, or more than one physical address.|$|R
50|$|MIPS32 and MIPS32r2 support 32 bits of <b>virtual</b> <b>address</b> {{space and}} up to 36 bits of {{physical}} address space. MIPS64 supports up to 64 bits of <b>virtual</b> <b>address</b> space {{and up to}} 59 bits of physical address space.|$|R
50|$|In computing, {{virtual memory}} is a memory {{management}} technique that is implemented using both hardware and software. It maps memory addresses {{used by a}} program, called <b>virtual</b> <b>addresses,</b> into physical addresses in computer memory. Main storage, as seen by a process or task, appears as a contiguous address space or collection of contiguous segments. The operating system manages <b>virtual</b> <b>address</b> spaces and the assignment of real memory to <b>virtual</b> memory. <b>Address</b> translation hardware in the CPU, {{often referred to as}} a memory management unit or MMU, automatically translates <b>virtual</b> <b>addresses</b> to physical addresses. Software within the operating system may extend these capabilities to provide a <b>virtual</b> <b>address</b> space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer.|$|R
5000|$|There {{are several}} types of page tables, that are best suited for {{different}} requirements. Essentially, a bare-bones page table must store the <b>virtual</b> <b>address,</b> the physical address that is [...] "under" [...] this <b>virtual</b> <b>address,</b> and possibly some address space information.|$|R
40|$|Most {{operating}} systems execute programs in private address spaces communicating through messages or files. The traditional private address space model {{was developed for}} 16 - and 32 -bit architectures, on which <b>virtual</b> <b>addresses</b> are a scarce resource. The recent appearance of architectures with flat 64 -bit <b>virtual</b> <b>addressing</b> opens an opportunity to reconsider our use of <b>virtual</b> <b>address</b> spaces. In this paper we argue for an alternative addressing model, in which all programs and data reside in a single global <b>virtual</b> <b>address</b> space shared by multiple protection domains. Hardware-based memory protection exists within the single address space, providing firewalls as strong as in conventional systems. We explore the tradeoffs {{in the use of}} a global <b>virtual</b> <b>address</b> space relative to the private address space model. We contend that a shared address space can eliminate obstacles to efficient sharing and exchange of data structures that are inherent in private address space systems. The shared add [...] ...|$|R
40|$|The recent {{appearance}} of architectures with flat 64 -bit <b>virtual</b> <b>addressing</b> opens {{an opportunity to}} reconsider the way our operating systems use <b>virtual</b> <b>address</b> spaces. We are building an operating system called Opal for these wide-address architectures. The key feature of Opal is a single global <b>virtual</b> <b>address</b> space that extends to data on long-term storage and across the network. In this paper we outline {{the case for the}} use of a single <b>virtual</b> <b>address</b> space, present the model of addressing and protection used in Opal, and discuss some of the problems and opportunities raised by our approach. 1 Introduction The Opal project is an investigation into the effect of wide-address architectures on the structure of operating systems and applications. Our premise is that the next generation of workstations and servers will use processors with 64 -bit data paths, and sparse, flat, 64 -bit <b>virtual</b> <b>addressing.</b> The MIPS R 4000 [MIP 91] and Digital's Alpha family [Dobberpuhl et al. 92] are recent e [...] ...|$|R
50|$|The {{effective}} <b>virtual</b> <b>address</b> {{of a word}} is 17 bits wide. <b>Virtual</b> <b>addresses</b> 0 thru 15 {{are reserved}} to reference the corresponding general purpose register, and are not mapped. Otherwise, in virtual memory mode the high-order eight bits of an <b>address,</b> called <b>virtual</b> page number, are used as an index to an array of 256 13-bit memory map registers. The thirteen bits from the map register plus the remaining nine bits of the <b>virtual</b> <b>address</b> form the address used to access real memory.|$|R
50|$|OS/VS1 was OS/360 MFT II with {{a single}} <b>virtual</b> <b>address</b> space; by comparison, OS/VS2 SVS was OS/360 MVT {{with a single}} <b>virtual</b> <b>address</b> space. OS/VS1 was often {{installed}} on mid-range IBM mainframe systems, such as the System/370 Model 145 and, later, the System/370 Model 148.|$|R
5000|$|Granularity: The <b>virtual</b> <b>address</b> {{space is}} broken up into pages. For instance, a 4 GiB <b>virtual</b> <b>address</b> space might be cut up into 1,048,576 pages of 4 KiB size, {{each of which}} can be {{independently}} mapped. There may be multiple page sizes supported; see virtual memory for elaboration.|$|R
2500|$|Starting in August, 1972, the IBM System/370 had {{a similar}} MMU, {{although}} it initially supported only a 24-bit <b>virtual</b> <b>address</b> space rather than the 32-bit <b>virtual</b> <b>address</b> space of the System/360 Model 67. [...] It also stored the accessed and dirty bits outside the page table. [...] In early 1983, the System/370-XA architecture expanded the <b>virtual</b> <b>address</b> space to 31 bits, and in 2000, the 64-bit z/Architecture was introduced, with the address space expanded to 64 bits; those continued to store the accessed and dirty bits outside the page table.|$|R
5000|$|The {{application}} reserves a region, or [...] "window" [...] of <b>virtual</b> <b>address</b> space, and allocates {{one or more}} {{regions of}} physical memory. Using the AWE API, the application can map the virtual window {{to any one of}} the physical regions. The application can reserve more than one <b>virtual</b> <b>address</b> space and map it to any of the allocated regions of physical memory, as long as the number of bytes reserved in the <b>virtual</b> <b>address</b> space matches that of the physical memory region. An application must have the Lock Pages in Memory privilege to use AWE.|$|R
5000|$|Virtually indexed, {{virtually}} tagged (VIVT) caches use the <b>virtual</b> <b>address</b> {{for both}} the index and the tag. This caching scheme can result in much faster lookups, since the MMU {{does not need to}} be consulted first to determine the physical address for a given <b>virtual</b> <b>address.</b> However, VIVT suffers from aliasing problems, where several different <b>virtual</b> <b>addresses</b> may refer to the same physical address. The result is that such addresses would be cached separately despite referring to the same memory, causing coherency problems. Another problem is homonyms, where the same <b>virtual</b> <b>address</b> maps to several different physical addresses. It is not possible to distinguish these mappings merely by looking at the virtual index itself, though potential solutions include: flushing the cache after a context switch, forcing address spaces to be non-overlapping, tagging the <b>virtual</b> <b>address</b> with an address space ID (ASID), or using physical tags. Additionally, there is a problem that virtual-to-physical mappings can change, which would require flushing cache lines, as the VAs would no longer be valid.|$|R
