0|1030|Public
40|$|Security {{systems can}} provide secure and {{efficient}} in-VM monitoring. An exemplary security {{system can be}} built upon hardware virtualization features and can comprise a virtual machine having a plurality of standard <b>virtual</b> <b>address</b> spaces, {{as well as a}} hidden <b>virtual</b> <b>address</b> space. While the standard <b>virtual</b> <b>address</b> spaces can be directly accessible by a kernel in the virtual machine, the hidden <b>virtual</b> <b>address</b> space can be hidden from the kernel, which can be absent a virtual page table corresponding to the hidden <b>virtual</b> <b>address</b> space. A security monitor can reside in the hidden address space, monitoring the kernel without being modifiable by the kernel. A processor can transfer focus from the standard <b>virtual</b> <b>address</b> spaces to the hidden <b>virtual</b> <b>address</b> space only through predetermined entry gates, and the processor can transfer focus from the hidden <b>virtual</b> <b>address</b> space to the standard <b>virtual</b> <b>address</b> spaces only through predetermined exit gates. Georgia Tech Research Corporatio...|$|R
50|$|The Kernel <b>Virtual</b> <b>Address</b> Space (KVA) is {{the virtual}} memory {{area in which}} all Linux kernel threads reside. The {{second part of the}} <b>virtual</b> <b>address</b> space is {{occupied}} by the User <b>Virtual</b> <b>Address</b> Space which contain user threads.|$|R
50|$|Relative <b>virtual</b> <b>addresses</b> (RVAs) {{are not to}} be {{confused}} with standard <b>virtual</b> <b>addresses.</b> A relative <b>virtual</b> <b>address</b> is the <b>virtual</b> <b>address</b> of an object from the file once it is loaded into memory, minus the base address of the file image. If the file were to be mapped literally from disk to memory, the RVA would be the same as that of the offset into the file, but this is actually quite unusual.|$|R
25|$|The kernel has {{full access}} to the system's memory and must allow {{processes}} to safely access this memory as they require it. Often {{the first step in}} doing this is <b>virtual</b> <b>addressing,</b> usually achieved by paging and/or segmentation. <b>Virtual</b> <b>addressing</b> allows the kernel to make a given physical address appear to be another <b>address,</b> the <b>virtual</b> <b>address.</b> <b>Virtual</b> <b>address</b> spaces may be different for different processes; the memory that one process accesses at a particular (<b>virtual)</b> <b>address</b> may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.|$|R
50|$|Although <b>virtual</b> <b>addresses</b> are 64 bits wide in 64-bit mode, current {{implementations}} (and all chips {{known to}} be in the planning stages) do not allow the entire <b>virtual</b> <b>address</b> space of 264 bytes (16 EB) to be used.This would be approximately four billion times the size of <b>virtual</b> <b>address</b> space on 32-bit machines. Most operating systems and applications will not need such a large address space for the foreseeable future, so implementing such wide <b>virtual</b> <b>addresses</b> would simply increase the complexity and cost of address translation with no real benefit. AMD therefore decided that, in the first implementations of the architecture, only the least significant 48 bits of a <b>virtual</b> <b>address</b> would actually be used in address translation (page table lookup).|$|R
40|$|A <b>virtual</b> <b>address</b> cache memory, whose {{operation}} is controlled explicitly by software, is presented. Ad-hoc hardware mechanisms, including new machine instructions {{and a new}} operand addressing mode, reduce the complexity of cache management logic in favour of {{the capacity of the}} cache, and solve the major problem of <b>virtual</b> <b>address</b> cache organization: two or more <b>virtual</b> <b>addresses</b> mapping into the same real address...|$|R
50|$|Nearly all current {{implementations}} {{of virtual}} memory divide a <b>virtual</b> <b>address</b> space into pages, blocks of contiguous <b>virtual</b> memory <b>addresses.</b> Pages on contemporary systems are usually at least 4 kilobytes in size; systems with large <b>virtual</b> <b>address</b> ranges or amounts of real memory generally use larger page sizes.|$|R
25|$|The Alpha has a 64-bit linear <b>virtual</b> <b>address</b> {{space with}} no memory segmentation. Implementations can {{implement}} a smaller <b>virtual</b> <b>address</b> {{space with a}} minimum size of 43 bits. Although the unused bits were not implemented in hardware such as TLBs, the architecture required implementations to check whether they are zero to ensure software compatibility with implementations with a larger (or full) <b>virtual</b> <b>address</b> space.|$|R
5000|$|The AMD64 {{architecture}} {{defines a}} 64-bit <b>virtual</b> <b>address</b> format, {{of which the}} low-order 48 bits are used in current implementations. This allows up to 256 TB (248 bytes) of <b>virtual</b> <b>address</b> space. The architecture definition allows this limit to be raised in future implementations to the full 64 bits, extending the <b>virtual</b> <b>address</b> space to 16 EB (264 bytes). This is compared to just 4 GB (232 bytes) for the x86.|$|R
5000|$|If the {{processor}} and operating system support multiple <b>virtual</b> <b>address</b> spaces, the [...] "extra memory" [...] {{can be used}} to run more processes. Paging allows the cumulative total of <b>virtual</b> <b>address</b> spaces to exceed physical main memory.|$|R
50|$|An iconic {{example of}} virtual-to-physical <b>address</b> {{translation}} is <b>virtual</b> memory, where different pages of <b>virtual</b> <b>address</b> space map either to page file or to main memory physical address space. It {{is possible that}} several numerically different <b>virtual</b> <b>addresses</b> all refer to one physical address and hence to the same physical byte of RAM. It {{is also possible that}} a single <b>virtual</b> <b>address</b> maps to zero, one, or more than one physical address.|$|R
50|$|MIPS32 and MIPS32r2 support 32 bits of <b>virtual</b> <b>address</b> {{space and}} up to 36 bits of {{physical}} address space. MIPS64 supports up to 64 bits of <b>virtual</b> <b>address</b> space {{and up to}} 59 bits of physical address space.|$|R
50|$|In computing, {{virtual memory}} is a memory {{management}} technique that is implemented using both hardware and software. It maps memory addresses {{used by a}} program, called <b>virtual</b> <b>addresses,</b> into physical addresses in computer memory. Main storage, as seen by a process or task, appears as a contiguous address space or collection of contiguous segments. The operating system manages <b>virtual</b> <b>address</b> spaces and the assignment of real memory to <b>virtual</b> memory. <b>Address</b> translation hardware in the CPU, {{often referred to as}} a memory management unit or MMU, automatically translates <b>virtual</b> <b>addresses</b> to physical addresses. Software within the operating system may extend these capabilities to provide a <b>virtual</b> <b>address</b> space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer.|$|R
5000|$|There {{are several}} types of page tables, that are best suited for {{different}} requirements. Essentially, a bare-bones page table must store the <b>virtual</b> <b>address,</b> the physical address that is [...] "under" [...] this <b>virtual</b> <b>address,</b> and possibly some address space information.|$|R
40|$|Most {{operating}} systems execute programs in private address spaces communicating through messages or files. The traditional private address space model {{was developed for}} 16 - and 32 -bit architectures, on which <b>virtual</b> <b>addresses</b> are a scarce resource. The recent appearance of architectures with flat 64 -bit <b>virtual</b> <b>addressing</b> opens an opportunity to reconsider our use of <b>virtual</b> <b>address</b> spaces. In this paper we argue for an alternative addressing model, in which all programs and data reside in a single global <b>virtual</b> <b>address</b> space shared by multiple protection domains. Hardware-based memory protection exists within the single address space, providing firewalls as strong as in conventional systems. We explore the tradeoffs {{in the use of}} a global <b>virtual</b> <b>address</b> space relative to the private address space model. We contend that a shared address space can eliminate obstacles to efficient sharing and exchange of data structures that are inherent in private address space systems. The shared add [...] ...|$|R
40|$|The recent {{appearance}} of architectures with flat 64 -bit <b>virtual</b> <b>addressing</b> opens {{an opportunity to}} reconsider the way our operating systems use <b>virtual</b> <b>address</b> spaces. We are building an operating system called Opal for these wide-address architectures. The key feature of Opal is a single global <b>virtual</b> <b>address</b> space that extends to data on long-term storage and across the network. In this paper we outline {{the case for the}} use of a single <b>virtual</b> <b>address</b> space, present the model of addressing and protection used in Opal, and discuss some of the problems and opportunities raised by our approach. 1 Introduction The Opal project is an investigation into the effect of wide-address architectures on the structure of operating systems and applications. Our premise is that the next generation of workstations and servers will use processors with 64 -bit data paths, and sparse, flat, 64 -bit <b>virtual</b> <b>addressing.</b> The MIPS R 4000 [MIP 91] and Digital's Alpha family [Dobberpuhl et al. 92] are recent e [...] ...|$|R
50|$|The {{effective}} <b>virtual</b> <b>address</b> {{of a word}} is 17 bits wide. <b>Virtual</b> <b>addresses</b> 0 thru 15 {{are reserved}} to reference the corresponding general purpose register, and are not mapped. Otherwise, in virtual memory mode the high-order eight bits of an <b>address,</b> called <b>virtual</b> page number, are used as an index to an array of 256 13-bit memory map registers. The thirteen bits from the map register plus the remaining nine bits of the <b>virtual</b> <b>address</b> form the address used to access real memory.|$|R
50|$|OS/VS1 was OS/360 MFT II with {{a single}} <b>virtual</b> <b>address</b> space; by comparison, OS/VS2 SVS was OS/360 MVT {{with a single}} <b>virtual</b> <b>address</b> space. OS/VS1 was often {{installed}} on mid-range IBM mainframe systems, such as the System/370 Model 145 and, later, the System/370 Model 148.|$|R
5000|$|Granularity: The <b>virtual</b> <b>address</b> {{space is}} broken up into pages. For instance, a 4 GiB <b>virtual</b> <b>address</b> space might be cut up into 1,048,576 pages of 4 KiB size, {{each of which}} can be {{independently}} mapped. There may be multiple page sizes supported; see virtual memory for elaboration.|$|R
2500|$|Starting in August, 1972, the IBM System/370 had {{a similar}} MMU, {{although}} it initially supported only a 24-bit <b>virtual</b> <b>address</b> space rather than the 32-bit <b>virtual</b> <b>address</b> space of the System/360 Model 67. [...] It also stored the accessed and dirty bits outside the page table. [...] In early 1983, the System/370-XA architecture expanded the <b>virtual</b> <b>address</b> space to 31 bits, and in 2000, the 64-bit z/Architecture was introduced, with the address space expanded to 64 bits; those continued to store the accessed and dirty bits outside the page table.|$|R
5000|$|The {{application}} reserves a region, or [...] "window" [...] of <b>virtual</b> <b>address</b> space, and allocates {{one or more}} {{regions of}} physical memory. Using the AWE API, the application can map the virtual window {{to any one of}} the physical regions. The application can reserve more than one <b>virtual</b> <b>address</b> space and map it to any of the allocated regions of physical memory, as long as the number of bytes reserved in the <b>virtual</b> <b>address</b> space matches that of the physical memory region. An application must have the Lock Pages in Memory privilege to use AWE.|$|R
5000|$|Virtually indexed, {{virtually}} tagged (VIVT) caches use the <b>virtual</b> <b>address</b> {{for both}} the index and the tag. This caching scheme can result in much faster lookups, since the MMU {{does not need to}} be consulted first to determine the physical address for a given <b>virtual</b> <b>address.</b> However, VIVT suffers from aliasing problems, where several different <b>virtual</b> <b>addresses</b> may refer to the same physical address. The result is that such addresses would be cached separately despite referring to the same memory, causing coherency problems. Another problem is homonyms, where the same <b>virtual</b> <b>address</b> maps to several different physical addresses. It is not possible to distinguish these mappings merely by looking at the virtual index itself, though potential solutions include: flushing the cache after a context switch, forcing address spaces to be non-overlapping, tagging the <b>virtual</b> <b>address</b> with an address space ID (ASID), or using physical tags. Additionally, there is a problem that virtual-to-physical mappings can change, which would require flushing cache lines, as the VAs would no longer be valid.|$|R
40|$|From <b>virtual</b> to {{physical}} <b>addresses</b> Address space layout Address translation Page directories, page tables Page faults, invalid page table entries Page frame number database 3 Virtual Memory- Concepts Application always references “virtual addresses” Hardware and software translates, or maps, <b>virtual</b> <b>addresses</b> {{to physical}} addresses Not all of an application’s <b>virtual</b> <b>address</b> space is in physical memory {{at one time}} [...] But hardware and software fool the application into thinking that it is The rest is kept on disk, and is brought into physical memory automatically as needed 4 <b>Virtual</b> <b>Address</b> Space Process private address space Can’t access outside <b>virtual</b> <b>addresses</b> unless map to shared memory sections or use cross-process memory functions Page table stored in system space Session space All session-wide data structures Session-specific paged pool Copy of subsystem process (Csrss. exe) and logon process (Winlogon. exe) System space Global OS code and data structures...|$|R
5000|$|... #Caption: <b>Virtual</b> <b>address</b> {{space and}} {{physical}} address space relationship ...|$|R
50|$|A page {{table is}} the data {{structure}} {{used by a}} virtual memory system in a computer operating system to store the mapping between <b>virtual</b> <b>addresses</b> and physical <b>addresses.</b> <b>Virtual</b> <b>addresses</b> are used by the accessing process, while physical addresses are used by the hardware, or more specifically, by the RAM subsystem.|$|R
50|$|MIPS IV is a 64-bit architecture, but the R10000 did not {{implement}} the entire physical or <b>virtual</b> <b>address</b> to reduce cost. Instead, {{it has a}} 40-bit physical address and a 44-bit <b>virtual</b> <b>address,</b> thus {{it is capable of}} addressing 1 TB of physical memory and 16 TB of virtual memory.|$|R
5000|$|... #Subtitle level 3: Main memory {{larger than}} <b>virtual</b> <b>address</b> space ...|$|R
50|$|Example: Assume {{that we have}} a TLB {{mapping of}} <b>virtual</b> <b>address</b> 0x2cfc7000 to {{physical}} address 0x12345000. (Note that both these addresses are aligned at 4 KB boundaries.) Accessing data located at <b>virtual</b> <b>address</b> va=0x2cfc7abc causes a TLB resolution of 0x2cfc7 to 0x12345 to issue a physical access to pa=0x12345abc. Here, the 20/12-bit split luckily matches the hexadecimal representation split at 5/3 digits. The hardware can implement this translation by simply combining the first 20 bits of the physical address (0x12345) and the last 12 bits of the <b>virtual</b> <b>address</b> (0xabc). This is also referred to as virtually indexed (abc) physically tagged (12345).|$|R
50|$|In computing, a <b>virtual</b> <b>address</b> space (VAS) or {{address space}} is {{the set of}} ranges of <b>virtual</b> <b>addresses</b> that an {{operating}} system makes available to a process. The range of <b>virtual</b> <b>addresses</b> usually starts at a low address and can extend to the highest address allowed by the computer's instruction set architecture {{and supported by the}} operating system's pointer size implementation, which can be 4 bytes for 32-bit or 8 bytes for 64-bit OS versions. This provides several benefits, one of which is, if each process is given a separate address space, security through process isolation.|$|R
50|$|The 32-bit {{size of the}} <b>virtual</b> <b>address</b> is not changed, so regular {{application}} software continues to use instructions with 32-bit addresses and (in a flat memory model) is limited to 4 gigabytes of <b>virtual</b> <b>address</b> space. Operating systems supporting this mode use page tables to map the regular 4 GB <b>virtual</b> <b>address</b> space into the physical memory, which, depending on the operating system {{and the rest of}} the hardware platform, may be as big as 64 GB. The mapping is typically applied separately for each process, so that the additional RAM is useful even though no single process can access it all simultaneously.|$|R
5000|$|Virtual {{memory and}} <b>virtual</b> <b>address</b> space allows for memory space isolation.|$|R
5000|$|... #Caption: Common {{method of}} using paging {{to create a}} <b>virtual</b> <b>address</b> space ...|$|R
5000|$|Programs {{with access}} to (for the time) very large <b>virtual</b> <b>address</b> spaces.|$|R
50|$|Windows XP {{supports}} a larger system <b>virtual</b> <b>address</b> space -— 1.3 GB, {{of which the}} contiguous <b>virtual</b> <b>address</b> space {{that can be used}} by device drivers is 960 MB. The Windows XP Memory Manager is redesigned to consume less paged pool, allowing for more caching and greater availability of paged pool for any component that needs it.|$|R
5000|$|The lookup {{may fail}} {{if there is}} no {{translation}} available for the <b>virtual</b> <b>address,</b> meaning that <b>virtual</b> <b>address</b> is invalid. This will typically occur because of a programming error, and the operating system must take some action to deal with the problem. On modern operating systems, it will cause a segmentation fault in the offending program.|$|R
5000|$|There is an {{isolated}} <b>virtual</b> <b>address</b> space for each process in user mode.|$|R
