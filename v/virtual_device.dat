188|586|Public
25|$|When Windows 95 started up, MS-DOS loaded, {{processed}} CONFIG.SYS, launched COMMAND.COM, ran AUTOEXEC.BAT {{and finally}} ran WIN.COM. The WIN.COM program used MS-DOS {{to load the}} virtual machine manager, read SYSTEM.INI, load the <b>virtual</b> <b>device</b> drivers, and then turn off any running copies of EMM386 and switch into protected mode. Once in protected mode, the <b>virtual</b> <b>device</b> drivers (VxDs) transferred all state information from MS-DOS to the 32-bit file system manager, and then shut off MS-DOS. These VxDs allow Windows 9x to interact with hardware resources directly, as providing low-level functionalities such as 32-bit disk access and memory management. All future file system operations would get routed to the 32-bit file system manager. In Windows ME, win.com was no longer executed during the startup process; instead it went directly to execute VMM32.VXD from IO.SYS.|$|E
25|$|Windows 3.0, {{released}} in 1990, improved the design, {{mostly because of}} virtual memory and loadable <b>virtual</b> <b>device</b> drivers (VxDs) that allow Windows to share arbitrary devices between multi-tasked DOS applications. Windows 3.0 applications can run in protected mode, which gives them access to several megabytes of memory without the obligation {{to participate in the}} software virtual memory scheme. They run inside the same address space, where the segmented memory provides a degree of protection. Windows 3.0 also featured improvements to the user interface. Microsoft rewrote critical operations from C into assembly. Windows 3.0 is the first Microsoft Windows version to achieve broad commercial success, selling 2 million copies in the first six months.|$|E
25|$|The Virtual Machine Manager (VMM) is the 32-bit {{protected}} mode kernel {{at the core}} of Windows 9x. Its primary responsibility is to create, run, monitor and terminate virtual machines. The VMM provides services that manage memory, processes, interrupts and protection faults. The VMM works with virtual devices (loadable kernel modules, which consist mostly of 32-bit ring 0 or kernel mode code, but may include other types of code, such as a 16-bit real mode initialisation segment) to allow those virtual devices to intercept interrupts and faults to control the access that an application has to hardware devices and installed software. Both the VMM and <b>virtual</b> <b>device</b> drivers run in a single, 32-bit, flat model address space at privilege level 0 (also called ring 0). The VMM provides multi-threaded, preemptive multitasking. It runs multiple applications simultaneously by sharing CPU (central processing unit) time between the threads in which the applications and virtual machines run.|$|E
5000|$|<b>Virtual</b> <b>devices</b> can {{be added}} or removed dynamically. The number of <b>virtual</b> <b>devices</b> allowed in {{supported}} configurations depends on the release. Versions after 4.3 support up to 256 when accelerated virtual I/Os are used.|$|R
5000|$|... #Subtitle level 2: Conventions {{of names}} and typical {{behaviour}} of <b>virtual</b> <b>devices</b> ...|$|R
25|$|Child {{partitions}} do {{not have}} direct access to hardware resources, but instead have a virtual view of the resources, in terms of <b>virtual</b> <b>devices.</b> Any request to the <b>virtual</b> <b>devices</b> is redirected via the VMBus to the devices in the parent partition, which will manage the requests. The VMBus is a logical channel which enables inter-partition communication. The response is also redirected via the VMBus. If the devices in the parent partition are also <b>virtual</b> <b>devices,</b> it will be redirected further until it reaches the parent partition, where it will {{gain access to the}} physical devices. Parent partitions run a Virtualization Service Provider (VSP), which connects to the VMBus and handles device access requests from child partitions. Child partition <b>virtual</b> <b>devices</b> internally run a Virtualization Service Client (VSC), which redirect the request to VSPs in the parent partition via the VMBus. This entire process is transparent to the guest OS.|$|R
2500|$|Device {{drivers in}} Windows 9x can be <b>virtual</b> <b>device</b> drivers or (starting with Windows 98) WDM drivers. VxDs usually have the {{filename}} extension [...]vxd or [...]386, whereas WDM compatible drivers usually use the extension [...]sys. The 32-bit VxD message server (msgsrv32) {{is a program}} that is able to load <b>virtual</b> <b>device</b> drivers (VxDs) at startup and then handle communication with the drivers. Additionally, the message server performs several background functions, including loading the Windows shell (such as Explorer.exe or Progman.exe).|$|E
5000|$|High reliability. IRF {{provides}} both link and node redundancy. An IRF <b>virtual</b> <b>device</b> comprises multiple member {{devices that}} operate in 1:N redundancy: the master runs, manages and maintains the IRF <b>virtual</b> <b>device,</b> whereas the slaves process services {{as well as}} functioning as the backups. As soon as the master fails, the IRF <b>virtual</b> <b>device</b> immediately elects a new master to prevent service interruption. In addition, you can aggregate both IRF links of members and the links between the IRF <b>virtual</b> <b>device</b> and its upper or lower layer devices.|$|E
5000|$|Low cost. The IRF {{technology}} {{creates an}} IRF <b>virtual</b> <b>device</b> from multiple low-end devices, {{and thus the}} IRF <b>virtual</b> <b>device</b> has a higher port density and bandwidth and costs lower than using high-end devices.|$|E
5000|$|Remote Mounting of <b>Virtual</b> <b>Devices</b> such as CD/DVD drive, USB Flash Drives, ISO / Disk {{images and}} Diskette drive ...|$|R
5000|$|A general {{mechanism}} for implementing <b>virtual</b> <b>devices</b> in software running in user processes (which were called [...] "jobs" [...] in ITS).|$|R
40|$|Abstract. This paper {{presents}} two <b>virtual</b> <b>devices</b> made {{to determine}} {{the behavior of the}} bullet before, during impact and after the collision using different materials. First device was based on a pendulum and second was made with springs. The idea of making these <b>virtual</b> <b>devices</b> was to transform the kinetic energy of the projectile before the collision in a potential energy after impact. The difference between these two types of energies was going to deformations phenomena...|$|R
50|$|Simplified {{topology}} and streamlined management. An IRF <b>virtual</b> <b>device</b> {{appears as}} a node on the network. You can log into it by connecting to any port of any member to manage {{all members of the}} IRF <b>virtual</b> <b>device.</b>|$|E
50|$|<b>Virtual</b> <b>device</b> drivers {{represent}} a particular variant of device drivers. They {{are used to}} emulate a hardware device, particularly in virtualization environments, for example when a DOS program is run on a Microsoft Windows computer or when a guest operating system is run on, for example, a Xen host. Instead of enabling the guest operating system to dialog with hardware, <b>virtual</b> <b>device</b> drivers take the opposite role and emulates a piece of hardware, so that the guest operating system and its drivers running inside a virtual machine can have the illusion of accessing real hardware. Attempts by the guest operating system to access the hardware are routed to the <b>virtual</b> <b>device</b> driver in the host operating system as e.g., function calls. The <b>virtual</b> <b>device</b> driver can also send simulated processor-level events like interrupts into the virtual machine.|$|E
50|$|There {{are several}} {{variants}} of <b>virtual</b> <b>device</b> drivers, such as VxDs, VLMs, VDDs.|$|E
40|$|Abstract. In this paper, {{we propose}} a {{simulator}} for facilitating reliable and inexpensive development of ubiquitous applications where each application software controls {{a lot of}} information appliances based on the state of external environment, user’s contexts and preferences. The proposed simulator realistically reproduces behavior of application software on <b>virtual</b> <b>devices</b> in a <b>virtual</b> 3 D space. For this purpose, the simulator provides functions to facilitate deployment of <b>virtual</b> <b>devices</b> in a 3 D space, simulates communication among the devices from MAC level to application level, and reproduces the change of physical quantities (e. g., temperature) caused by devices (e. g., air conditioners). Also, we keep software portability between <b>virtual</b> <b>devices</b> and real devices. As the most prominent function of the simulator, we provide a systematic and visual testing method for testing whether a given application software satisfies specified requirements. ...|$|R
50|$|OS {{virtualization}} {{can overcome}} {{some of these}} drawbacks on commodity hardware. A modern hypervisor provides virtual machines with CPU time and strongly isolated <b>virtual</b> <b>devices.</b> A library OS running as a virtual machine only needs to implement drivers for these stable <b>virtual</b> hardware <b>devices</b> and can depend on the hypervisor to drive the real physical hardware. However, protocol libraries are still needed to replace {{the services of a}} traditional operating system. Creating these protocol libraries is where the bulk of the work lies when implementing a modern library OS. Additionally, reliance on a hypervisor may reintroduce performance overheads when switching between the unikernel and hypervisor, and when passing data to and from hypervisor <b>virtual</b> <b>devices.</b>|$|R
40|$|This' paper proposes <b>virtual</b> input <b>devices</b> {{based on}} {{collision}} detection for easy construc#on of interactive 3 D graphics applications, which use a motion capture {{system as a}} real-#me input <b>device.</b> Each <b>virtual</b> input <b>device</b> is' composed jm several collision sensor objects and an actuator object. These objects are software components' represented as a visible object which users can manipulate on a computer screen. Each <b>virtual</b> input <b>device</b> has a certain metaphor associated with its' role that is' determined by location and composition structure of its' components: Therefore, it is' possible to define various <b>virtual</b> input <b>devices</b> eas'ily only by combining several sensor objects and an actuator object through direct manipulations on a computer screen. This' paper presents' a realization mechanism and actual examples' of <b>virtual</b> input <b>devices...</b>|$|R
5000|$|VDI - <b>Virtual</b> <b>Device</b> Interface (screen drivers only, {{other drivers}} loaded using GDOS) ...|$|E
5000|$|Windows 95 was {{designed}} to be maximally compatible with existing MS-DOS and 16-bit Windows programs and device drivers, while offering a more stable and better performing system. The Windows 95 architecture is an evolution of Windows for Workgroups' 386 enhanced mode. The lowest level of the operating system consists {{of a large number of}} <b>virtual</b> <b>device</b> drivers (VxDs) running in 32-bit protected mode and one or more virtual DOS machines running in virtual 8086 mode. The <b>virtual</b> <b>device</b> drivers are responsible for handling physical devices (such as video and network cards), emulating virtual devices used by the virtual machines or providing various system services. The three most important <b>virtual</b> <b>device</b> drivers are: ...|$|E
5000|$|Comprehensive product support. An IRF <b>virtual</b> <b>device</b> can {{be created}} from box-type devices or chassis-type {{distributed}} devices.|$|E
40|$|UbiComp 2006 : 8 th International Conference on Ubiquitous Computing, Sep 17 - 21, 2006, Orange County, CA, USAIn this paper, {{we propose}} a {{simulator}} for facilitating reliable and inexpensive development of ubiquitous applications where each application software controls {{a lot of}} information appliances based on the state of external environment, user’s contexts and preferences. The proposed simulator realistically reproduces behavior of application software on <b>virtual</b> <b>devices</b> in a <b>virtual</b> 3 D space. For this purpose, the simulator provides functions to facilitate deployment of <b>virtual</b> <b>devices</b> in a 3 D space, simulates communication among the devices from MAC level to application level, and reproduces the change of physical quantities (e. g., temperature) caused by devices (e. g., air conditioners). Also, we keep software portability between <b>virtual</b> <b>devices</b> and real devices. As the most prominent function of the simulator, we provide a systematic and visual testing method for testing whether a given application software satisfies specified requirements...|$|R
50|$|Each VM {{created by}} VP ran a simple, single-user {{operating}} system called CSS, derived from IBM's Cambridge Monitor System. CSS allowed users to run programs, manipulate a file system, and manage <b>virtual</b> <b>devices.</b>|$|R
40|$|Ensuring {{software}} quality is important, especially for control system applications. Writing tests for such applications requires replacing the real hardware with a virtual implementation in software. Also {{the rest of}} the control system which interacts with the application must be replaced with a mock. In addition, time must be controlled precisely. We present the VirtualLab framework as part of the Chimera Tool Kit (formerly named MTCA 4 U). It has been designed to help implementing such tests by introducing the concept of virtual time, and combining it with an implementation basis for <b>virtual</b> <b>devices</b> and plant models. The <b>virtual</b> <b>devices</b> are transparently plugged into the application in place of real devices. Also tools are provided to simplify the simulated interaction with other parts of the control system. The framework is designed modularly so that <b>virtual</b> <b>devices</b> and model components can be reused to test different parts of the control system software. It interacts seamlessly with the other libraries of the Chimera Tool Kit such as DeviceAccess and the control system adapter...|$|R
5000|$|A layer that abstracts {{multiple}} devices, thereby {{providing a}} single <b>virtual</b> <b>device</b> (e.g. Linux kernel's md and OpenBSD's softraid) ...|$|E
50|$|A mirror {{driver is}} a display driver for a <b>virtual</b> <b>device</b> that mirrors the drawing {{operations}} {{of one or}} more additional physical display devices.|$|E
5000|$|Device {{drivers in}} Windows 9x can be <b>virtual</b> <b>device</b> drivers or (starting with Windows 98) WDM drivers. VxDs usually have the {{filename}} extension [...]vxd or [...]386, whereas WDM compatible drivers usually use the extension [...]sys. The 32-bit VxD message server (msgsrv32) {{is a program}} that is able to load <b>virtual</b> <b>device</b> drivers (VxDs) at startup and then handle communication with the drivers. Additionally, the message server performs several background functions, including loading the Windows shell (such as Explorer.exe or Progman.exe).|$|E
50|$|Marilou {{includes}} {{a complete set}} of user-modifiable <b>virtual</b> <b>devices.</b> The behavior of these devices may be overridden by the properties of real devices available in robotics. This feature allows the programmer to use a known device's parameters directly.|$|R
50|$|The {{result was}} a fully virtualized environment. Each virtual machine had {{its own set of}} <b>virtual</b> <b>devices,</b> mapped from the system's real {{hardware}} environment. Thus a given dial-up teletype was presented to its VM instance as its virtual console.|$|R
50|$|Since Virtual Hubs and Virtual Network Adapters {{are only}} software-emulated <b>virtual</b> Ethernet <b>devices,</b> the Ethernet packets through these <b>virtual</b> <b>devices</b> cannot {{communicate}} with physical Ethernet devices. Therefore, {{a bridge between}} the virtual and the physical is necessary to build a remote-access VPN or site-to-site VPN. To make a bridge, the Local Bridge function exchanges the Ethernet packets between a Virtual Hub and a physical Ethernet network adapter to combine both isolated Ethernet segments into a single Ethernet segment.|$|R
50|$|Virtual Machine Manager (VMM32.VXD): Responsible for memory management, event handling, {{interrupt}} handling, {{loading and}} initializing <b>virtual</b> <b>device</b> drivers, creating new virtual machines and thread scheduling.|$|E
5000|$|EmuTOS and FreeMiNT; fVDI (free <b>Virtual</b> <b>Device</b> Interface), clone of GEM's VDI; XaAES; TeraDesk (Tera Desktop), clone of the {{original}} Desktop Filemanager and [...] "shell" ...|$|E
5000|$|Powerful network {{expansion}} capability. By adding member devices, {{the number}} of IRF ports, network bandwidth, and processing capability of the IRF <b>virtual</b> <b>device</b> can be easily expanded.|$|E
40|$|Abstract: The set of <b>virtual</b> <b>devices</b> {{offered by}} a {{hypervisor}} to its guest VMs is a virtualization component ripe with security exploits – {{more than half of}} all vulnerabilities of today’s hypervisors are found in this codebase. This paper presents Min-V, a hypervisor that disables all <b>virtual</b> <b>devices</b> not critical to running VMs in the cloud. Of the remaining devices, Min-V takes a step further and eliminates all remaining functionality not needed for the cloud. To implement Min-V, we had to overcome an obstacle: the boot process of many commodity OSes depends on legacy <b>virtual</b> <b>devices</b> absent from our hypervisor. Min-V introduces delusional boot, a mechanism that allows guest VMs running commodity OSes to boot successfully without developers having to re-engineer the initialization code of these commodity OSes, as well as the BIOS and pre-OS (e. g., bootloader) code. We evaluate Min-V and demonstrate that our security improvements incur no performance overhead except for a small delay during reboot of a guest VM. Our reliability tests show that Min-V is able to run unmodified Linux and Windows OSes on top of this minimal virtualization interface...|$|R
40|$|The {{interaction}} of real and <b>virtual</b> <b>devices</b> {{is an important}} point in design and development of control system. The central part of embedded control system is controller and it needs input devices and output sensors for realization of the control. The proposed approach allows using real controller with its specific programming tools and languages for intelligent software development and virtual measurement and sensor devices realized in computer environment. Different wireless compounds are necessary for intelligent embedded devices for transport system control. For that reason wireless communication network is needed to ensure data transmission between the controller and supervisory control and data acquisition system. The {{purpose of this paper}} is to propose approach for {{interaction of}} real, embedded and <b>virtual</b> <b>devices</b> in electrical transport control systems. The main tasks are: to analyze objects and functional dependencies of an electric transportation control system, to develop an control algorithm with interaction of real and <b>virtual</b> <b>devices,</b> to ensure a wireless connection for transfer data from the controller to the supervisory control and data acquisition system, to define data processing method of transmitted data. Computer and practical experiments and with real and embedded devices analysis of its results will be described the paper...|$|R
50|$|In the FHS, all {{files and}} {{directories}} appear under the root directory , {{even if they}} are stored on different physical or <b>virtual</b> <b>devices.</b> Some of these directories only exist on a particular system if certain subsystems, such as the X Window System, are installed.|$|R
