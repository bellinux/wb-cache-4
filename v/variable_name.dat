208|1007|Public
25|$|This is not exhaustive, since any Greek letter {{may be used}} freely as a <b>variable</b> <b>name.</b>|$|E
25|$|In {{programming}} languages with static scope, alpha-conversion {{can be used}} to make {{name resolution}} simpler by ensuring that no <b>variable</b> <b>name</b> masks a name in a containing scope (see alpha renaming to make name resolution trivial).|$|E
25|$|Positional parameters, such {{as those}} used above are always required, unless {{followed}} by ? to indicate that they are optional. Named parameters are optional by default, but may be marked as required by adding ! after the <b>variable</b> <b>name.</b> Slurpy parameters are always optional.|$|E
5000|$|<b>Variable</b> <b>names</b> {{were only}} {{significant}} to 2 characters; thus the <b>variable</b> <b>names</b> , [...] and [...] all {{referred to the}} same variable.|$|R
30|$|The <b>variable</b> <b>names</b> used in Algorithm  4 are {{identical}} to those introduced throughout this paper. For the reader’s convenience, {{a summary of the}} <b>variable</b> <b>names</b> used within the Main Algorithm is stated before the algorithm.|$|R
50|$|All {{variables}} were {{stored in a}} single global variable pool which users had to manage {{in order to avoid}} <b>variable</b> <b>naming</b> conflicts. There were no variable scoping capabilities in TEX. <b>Variable</b> <b>names</b> were limited to 40 characters.|$|R
25|$|Charles Simonyi, {{who worked}} at Xerox PARC in the 1970s and later oversaw the {{creation}} of Microsoft's Office suite of applications, invented and taught the use of Hungarian Notation, one version of which uses the lower case letter(s) {{at the start of}} a (capitalized) <b>variable</b> <b>name</b> to denote its type. One account claims that the camel case style first became popular at Xerox PARC around 1978, with the Mesa programming language developed for the Xerox Alto computer. This machine lacked an underscore key, and the hyphen and space characters were not permitted in identifiers, leaving camel case as the only viable scheme for readable multiword names. The PARC Mesa Language Manual (1979) included a coding standard with specific rules for upper and lower camel case that was strictly followed by the Mesa libraries and the Alto operating system.|$|E
500|$|The {{specifics}} of symbolic matrix notation vary widely, with some prevailing trends. Matrices are usually symbolized using upper-case letters (such as A in the examples above), while the corresponding lower-case letters, with two subscript indices (for example, a11, or a1,1), represent the entries. In addition to using upper-case letters to symbolize matrices, many authors use a special typographical style, commonly boldface upright (non-italic), to further distinguish matrices from other mathematical objects. [...] An alternative notation {{involves the use}} of a double-underline with the <b>variable</b> <b>name,</b> with or without boldface style, (for example, [...] ).|$|E
500|$|The {{assignment}} statement (token '=', the equals sign). This operates differently than in traditional imperative programming languages, and this fundamental mechanism (including {{the nature of}} Python's version of variables) illuminates many other features of the language. Assignment in C, e.g., x = 2, translates to [...] "typed <b>variable</b> <b>name</b> x receives a copy of numeric value 2". The (right-hand) value is copied into an allocated storage location for which the (left-hand) <b>variable</b> <b>name</b> is the symbolic address. The memory allocated to the variable is large enough (potentially quite large) for the declared type. In the simplest case of Python assignment, using the same example, x = 2, translates to [...] "(generic) name x receives {{a reference to a}} separate, dynamically allocated object of numeric (int) type of value 2." [...] This is termed binding the name to the object. Since the name's storage location doesn't contain the indicated value, it is improper to call it a variable. Names may be subsequently rebound at any time to objects of greatly varying types, including strings, procedures, complex objects with data and methods, etc. Successive assignments of a common value to multiple names, e.g., x = 2; y = 2; z = 2 result in allocating storage to (at most) three names and one numeric object, to which all three names are bound. Since a name is a generic reference holder it is unreasonable to associate a fixed data type with it. However at a given time a name will be bound to some object, which will have a type; thus there is dynamic typing.|$|E
50|$|A <b>variable</b> <b>name's</b> scope affects its extent.|$|R
50|$|<b>Variable</b> <b>names</b> {{can be of}} {{arbitrary}} length.|$|R
5000|$|<b>Variable</b> <b>names</b> for numeric {{values were}} either a single letter, {{or a single}} letter {{followed}} by a single numeric digit, thus allowing for 286 discreet variables in total. Strings were supported; <b>variable</b> <b>names</b> for them had the same restriction but were followed by a pound (...) symbol.|$|R
2500|$|... where v is a <b>variable</b> <b>name</b> {{drawn from}} a {{predefined}} infinite set of ...|$|E
2500|$|A {{declaration}} couples a <b>variable</b> <b>name</b> to a datatype – for example: [...] var x: integer; ...|$|E
2500|$|In Perl 5, sigils ndash& the {{punctuation}} {{characters that}} precede a <b>variable</b> <b>name</b> ndash& change {{depending on how}} the variable is used: ...|$|E
50|$|Some naming {{conventions}} are enforced at {{the language}} level {{as part of}} the language syntax and involve the format of valid identifiers. In almost all languages, <b>variable</b> <b>names</b> cannot start with a digit (0-9) and cannot contain whitespace characters. Whether, which, and when punctuation marks are permitted in <b>variable</b> <b>names</b> varies from language to language; many languages only permit the underscore ("_") in <b>variable</b> <b>names</b> and forbid all other punctuation. In some programming languages, specific (often punctuation) characters (known as sigils) are prefixed or appended to variable identifiers to indicate the variable's type.|$|R
5000|$|Combinatory logic, a more {{essential}} way {{to eliminate}} <b>variable</b> <b>names.</b>|$|R
50|$|The set of free {{variables}} of a lambda expression, M, is denoted as FV(M). This is {{the set of}} <b>variable</b> <b>names</b> that have instances not bound (used) in a lambda abstraction, within the lambda expression. They are the <b>variable</b> <b>names</b> that may be bound to formal parameter variables from outside the lambda expression.|$|R
2500|$|... where name is the {{environment}} <b>variable</b> <b>name,</b> and value {{is the value}} of that variable. The final element of the envp array must be null.|$|E
2500|$|Calculate the {{percentage}} of men (or other ascribed category) who work {{in each of the}} occupations and {{the percentage}} of women who work in each occupation. [...] Give men and women a <b>variable</b> <b>name</b> (m1 could = men, w1 could = women).|$|E
2500|$|In algebra, {{multiplication}} involving variables {{is often}} written as a [...] (e.g., xy for x times y or 5x for five times x), also called implied multiplication. The notation {{can also be}} used for quantities that are surrounded by parentheses (e.g., 5(2) or (5)(2) for five times two). This implicit usage of multiplication can cause ambiguity when the concatenated variables happen to match the name of another variable, when a <b>variable</b> <b>name</b> in front of a parenthesis can be confused with a function name, or in the correct determination of the order of operations.|$|E
5000|$|Assuming {{there is}} a <b>variable</b> <b>named</b> variablename in your C code: ...|$|R
5000|$|A single {{name space}} for {{function}} and <b>variable</b> <b>names</b> (like Scheme).|$|R
50|$|Abstraction. Use {{renaming}} {{to insure}} that the <b>variable</b> <b>names</b> are all distinct.|$|R
2500|$|In the {{original}} LISP {{there were two}} fundamental data types: atoms and lists. A list was a finite ordered sequence of elements, where each element is either an atom or a list, and an atom was a number or a symbol. A symbol was essentially a unique named item, written as an alphanumeric string in source code, and used either as a <b>variable</b> <b>name</b> or as a data item in symbolic processing. For example, the list [...] contains three elements: the symbol , the list , and the number 2.|$|E
5000|$|Values are {{assigned}} to variable names by entering in the GUI text input/result field a <b>variable</b> <b>name</b> followed by 0 or more spaces, followed by the = character, followed by 0 or more spaces, followed by either a numeric value or an existing <b>variable</b> <b>name,</b> e.g. [...] "x = 2" [...] or [...] "result = subtotal" [...] (if subtotal was already assigned a numeric value). A numeric value is assigned to the first <b>variable</b> <b>name.</b> If the value was entered as an existing <b>variable</b> <b>name</b> {{rather than as a}} numeric value, the existing variable's value is assigned to the first <b>variable</b> <b>name.</b> Assignment to a <b>variable</b> <b>name</b> that does not exist creates the new variable by name with the assigned value. The &rarr;R (assign variable) GUI button shows a popup menu of existing variables (and the current value of each), to which selected variable is assigned the current numeric value displayed in the calculator, just as if that <b>variable</b> <b>name</b> were entered in the GUI text field followed by a = followed by the numeric value.|$|E
5000|$|A {{context is}} a list of pairs x : σ, where x is a <b>variable</b> <b>name</b> and σ is a type, such that no <b>variable</b> <b>name</b> is duplicated. One then defines typing {{judgments}} of terms-in-context in the usual way for the following syntactical constructs: ...|$|E
50|$|<b>Variable</b> <b>names</b> {{and values}} persist between launch and quit of the application.|$|R
5000|$|Checking if <b>variable</b> <b>names</b> are well-formed {{according}} to the project's coding standard ...|$|R
5000|$|Play {{well with}} other scripts by {{avoiding}} global function and <b>variable</b> <b>names.</b>|$|R
5000|$|An {{insurance}} company intends to predict [...] "Average cost of claims" [...] (<b>variable</b> <b>name</b> [...] "claimamt") by three independent variables (Predictors): [...] "Number of claims" [...] (<b>variable</b> <b>name</b> [...] "nclaims"), [...] "Policyholder age" [...] (<b>variable</b> <b>name</b> holderage), [...] "Vehicle age" [...] (<b>variable</b> <b>name</b> vehicleage).Linear Regression procedure has been {{run on the}} data, as follows:The omnibus F test in the ANOVA table implies that the model involved these three predictors can fit for predicting [...] "Average cost of claims", since the null hypothesis is rejected (P-Value=0.000 < 0.01, α=0.01). This rejection of the omnibus test implies that all the coefficients of the predictors in the model have found to be non-zero. The multiple- R-Square reported on the Model Summary table is 0.362, {{which means that the}} three predictors can explain 36.2% from the [...] "Average cost of claims" [...] variation.|$|E
5000|$|Variable {{substitution}} replaces a dollar-sign {{followed by}} the name of a variable with the contents of the variable. For example, “$foo” is replaced with the contents of the variable called “foo”. The <b>variable</b> <b>name</b> may be surrounded in curly braces so as to delimit what is and isn't the <b>variable</b> <b>name</b> in otherwise ambiguous cases.|$|E
5000|$|A {{declaration}} couples a <b>variable</b> <b>name</b> to a datatype - for example: ...|$|E
5000|$|... {{consider}} {{two terms}} equal if they differ {{only in their}} <b>variable</b> <b>naming,</b> ...|$|R
5000|$|... {{declares}} {{a temporary}} <b>variable</b> <b>named</b> index which contains initially the value [...]|$|R
5000|$|<b>Variable</b> <b>names</b> can {{be easy to}} {{remember}} from knowing just their types.|$|R
