127|145|Public
25|$|To recover, this {{ambiguity}} {{is resolved}} by choosing E, because it occurs before F in the grammar. However, the resultant parser {{will not be}} able to recognize the <b>valid</b> <b>input</b> sequence b e c, since the ambiguous sequence e c is reduced to (E → e) c, rather than the correct (F → e) c, but b E c is not in the grammar.|$|E
25|$|Based on the {{definition}} alone {{it is not}} obvious that NP-complete problems exist; however, a trivial and contrived NP-complete problem can be formulated as follows: given {{a description of a}} Turing machine M guaranteed to halt in polynomial time, does there exist a polynomial-size input that M will accept? It is in NP because (given an input) it is simple to check whether M accepts the input by simulating M; it is NP-complete because the verifier for any particular instance of a problem in NP can be encoded as a polynomial-time machine M that takes the solution to be verified as input. Then {{the question of whether the}} instance is a yes or no instance is determined by whether a <b>valid</b> <b>input</b> exists.|$|E
500|$|The {{development}} team {{included the}} producer Motohide Eshiro, the directors Takeshi Yamazaki and Yasuhiro Seto, and the composer Noriyuki Iwadare. Due {{to the game}} being made {{a long time after}} Apollo Justice, the developers wanted it to make a big impact, and {{came up with the idea}} of the player working to revive the trial system. As it was the first Ace Attorney game on the Nintendo 3DS, the developers made use of 3D graphics; they focused on preserving the look of the earlier Ace Attorney games' 2D art, and wanted to ensure that the graphics looked better than those in the simultaneously developed [...] The game's localization was directed by Janet Hsu, and was incorporated into the overall development, allowing the localization team a larger degree of insight into the developers' intentions. The game was generally well received by critics, who praised the visuals and character art, but criticized the game for sometimes not accepting logically <b>valid</b> <b>input</b> during trials. The game achieved the estimated sales, which were high compared to how the franchise had performed in the past.|$|E
3000|$|... a {{watermark}} w {{is valid}} if {{and only if}} it is obtained from <b>valid</b> <b>inputs,</b> (i,m,j) using the valid watermark generation function, G(·) such that, G(i,m,j)=w. Similarly, a watermarked image, ī ∈ Ī is valid {{if and only if}} E(i,w)=ī for <b>valid</b> <b>inputs,</b> (i,w) ∈ I×W. More formally, we can define a digital image watermarking scheme to be complete, if the following is true: for all (i,m,j) ∈ I×M×J there exists [...]...|$|R
3000|$|... (ī,i,w)=⊥ {{for some}} ī. Here, the normal {{condition}} allows the scheme {{to run with}} all of its <b>valid</b> <b>inputs,</b> outputs and functions.|$|R
40|$|We {{present an}} {{algorithm}} for synthesizing a context-free grammar encoding {{the language of}} <b>valid</b> program <b>inputs</b> from a set of input examples and blackbox access to the program. Our algorithm addresses shortcomings of existing grammar inference algorithms, which both severely overgeneralize and are prohibitively slow. Our implementation, GLADE, leverages the grammar synthesized by our algorithm to fuzz test programs with structured inputs. We show that GLADE substantially increases the incremental coverage on <b>valid</b> <b>inputs</b> compared to two baseline fuzzers...|$|R
2500|$|... but [...] "Covers OR CoveredBy" [...] have 41%, {{that is not}} the sum, {{because they}} are not logical {{complements}} neither independent relations; idem [...] "Contains OR Within", that have 21%. The sum 25%+12.5%=37.5% is obtained when ignoring overlaping of lines in [...] "Crosses [...] OR Overlaps", because the <b>valid</b> <b>input</b> sets are disjoints.|$|E
5000|$|Derive the <b>valid</b> <b>input</b> space (VIS) {{from the}} IS of each operation.|$|E
5000|$|Consider {{the above}} set of <b>valid</b> <b>input</b> {{characters}} and the example input string abcdef. To generate the check character, {{start with the}} last character in the string and move left doubling every other code-point. The [...] "digits" [...] of the code-points as written in base 6 (since there are 6 <b>valid</b> <b>input</b> characters) should then be summed up: ...|$|E
40|$|We present CESE, a {{tool that}} {{combines}} exhaustive enumeration of test inputs from a structured domain with symbolic execution driven test generation. We target programs whose <b>valid</b> <b>inputs</b> are determined by some context free grammar. We abstract the concrete input syntax with symbolic grammars, where some original tokens are replaced with symbolic constants. This reduces the set of input strings that must be enumerated exhaustively. For each enumerated input string, which may contain symbolic constants, symbolic execution based test generation instantiates the constants based on program execution paths. The “template ” generated by enumerating valid strings reduces {{the burden on the}} symbolic execution to generate syntactically <b>valid</b> <b>inputs</b> and helps exercise interesting code paths. Together, symbolic grammars provide a link between exhaustive enumeration of <b>valid</b> <b>inputs</b> and execution-directed symbolic test generation. Preliminary experiments with CESE show that the combination achieves better coverage than both pure enumerative test generation and pure directed symbolic test generation, in orders of magnitude less time and number of generated inputs. In addition, CESE is able to automatically generate inputs that achieve coverage within 10 % of manually constructed tests...|$|R
5000|$|False non-match rate (FNMR, {{also called}} FRR = False Reject Rate): the {{probability}} that the system fails to detect a match between the input pattern and a matching template in the database. It measures the percent of <b>valid</b> <b>inputs</b> that are incorrectly rejected.|$|R
40|$|This Article {{describes}} how {{international law and}} institutions are not necessarily incompatible with U. S. sovereign interests today {{and how they were}} historically accepted as <b>valid</b> <b>inputs</b> to interpreting and implementing the Constitution during the founding and infancy of the United States and through the Civil War...|$|R
50|$|This {{extension}} {{shares the}} same weakness {{as the original}} algorithm, namely, it cannot detect the transposition of the sequence to (or vice versa). This {{is equivalent to the}} transposition of 09 to 90 (assuming a set of <b>valid</b> <b>input</b> characters from 0 to 9 in order). On a positive note, the larger the set of <b>valid</b> <b>input</b> characters, the smaller the impact of the weakness.|$|E
50|$|The {{main idea}} behind the {{extension}} is that the full set of <b>valid</b> <b>input</b> characters is mapped {{to a list of}} code-points (i.e., sequential integers beginning with zero). The algorithm processes the input string by converting each character to its associated code-point and then performing the computations in mod N (where N is the number of <b>valid</b> <b>input</b> characters). Finally, the resulting check code-point is mapped back to obtain its corresponding check character.|$|E
5000|$|Let [...] be a Z operation. Let [...] be the {{precondition}} of [...] The <b>Valid</b> <b>Input</b> Space (VIS) of , written , is the Z schema box {{defined by}} [...]|$|E
5000|$|A general {{deterministic}} {{system can be}} described by an operator, , that maps an input, , {{as a function of}} [...] to an output, , a type of black box description. Linear systems satisfy the property of superposition. Given two <b>valid</b> <b>inputs</b> as well as their respective outputsthen a linear system must satisfyfor any scalar values [...] and [...]|$|R
5000|$|Suppose {{we have a}} pair {{of linear}} code [...] and [...] and an encoder-decoder pair based on linear codes which can achieve {{symmetric}} coding. The encoder output is given by: [...] and [...] If there exists two pair of <b>valid</b> <b>inputs</b> [...] and [...] generating the same syndromes, i.e. [...] and , we can get following( [...] represents Hamming weight): ...|$|R
40|$|Abstract—Android {{applications}} {{have been}} tested without any knowledge about them {{using a variety of}} tools such as Monkey [2], Monkey Runner [3] etc. In this paper, we evaluate existing Android testing techniques by comparing each of these tools and evaluate their efficiency based on a number of factors. Next, we propose requirements of an ideal input generator and present an automated input generator using the Robotium [1] test automation framework to test Android applications while generating <b>valid</b> <b>inputs.</b> The proposed system is targeted to automate the use of Robotium and create a generic test script that tests Android applications with <b>valid</b> <b>inputs</b> without the requirement of their source code. Further, we discuss issues encountered during the development phase of the system and by increasing the complexity of Android applications. We evaluated the system on Android applications with a simple user interface and conclude that the proposed framework using UI testing more efficient as compared to a randomized testing approach...|$|R
5000|$|The valid output {{thresholds}} voltages VOH (output high) and VOL (output low), and <b>valid</b> <b>input</b> thresholds VIH (input high) and VIL (input low), {{satisfy a}} robustness principle such that ...|$|E
50|$|SPACE enables {{recording}} for {{the current}} channel. If any other channels have recording enabled, they will have their recording function disabled first. This only works for <b>valid</b> <b>input</b> channels, of course.|$|E
5000|$|Initially, {{a mapping}} between <b>valid</b> <b>input</b> {{characters}} and code-points must be created. For example, {{consider that the}} valid characters are the lower-case letters from a to f. Therefore, a suitable mapping would be: ...|$|E
40|$|IWSDS 2012 : The 4 th International Workshop on Spoken Dialog Systems, November 28 - 30, 2012, Paris, FranceWe {{investigate}} a discrimination method for invalid and <b>valid</b> <b>inputs</b> based on machine learning using bag-of-words comprised from {{automatic speech recognition}} result as a classification feature. Changing the amount of training data, we elucidate that using 3000 of them (approx. 2 weeks of system inputs) shows enough classification performance...|$|R
40|$|Stratified Datalog with integer (gap) -order (or Datalog ¬,<z) is considered. A Datalog ¬,<z-program {{is said to}} be safe iff its bottomup {{processing}} terminates on all <b>valid</b> <b>inputs.</b> We {{prove that}} safe Datalog ¬,<z-programs do not have effective syntax in the sense that there is no recursively enumerable set S of safe Datalog ¬,<z-programs such that every safe Datalog ¬,<z-program is equivalent to a program in S...|$|R
5000|$|Lock — {{indicates}} the decoder has detected and is locked (synchronized) to a <b>valid</b> analog <b>input</b> video signal ...|$|R
5000|$|This function, again {{applied to}} any <b>valid</b> <b>input,</b> will {{generate}} a call tree which is non-linear. In the example on the right, the call tree generated {{by applying the}} [...] function to the input [...]|$|E
50|$|In telecommunications, falsing {{describes}} a decoder assuming {{that it is}} detecting a <b>valid</b> <b>input</b> when one is not present. This {{is also known as}} a false decode. This article will discuss analog circuits used before digital signal processing.|$|E
50|$|A hash {{function}} that is injective—that is, maps each <b>valid</b> <b>input</b> {{to a different}} hash value—is said to be perfect. With such a function one can directly locate the desired entry in a hash table, without any additional searching.|$|E
50|$|Hash tables often contain {{only a small}} {{subset of}} the <b>valid</b> <b>inputs.</b> For instance, a club {{membership}} list may contain only {{a hundred or so}} member names, out of the very large set of all possible names. In these cases, the uniformity criterion should hold for almost all typical subsets of entries that may be found in the table, not just for the global set of all possible entries.|$|R
40|$|Stratied Datalog with integer (gap) -order (or Datalog :;<z) is considered. A Datalog :;<z -program {{is said to}} be safe i its {{bottom-up}} processing terminates on all <b>valid</b> <b>inputs.</b> We prove that safe Datalog :;<z - programs do not have eective syntax in the sense that there is no recursively enumerable set S of safe Datalog :;<z -programs such that every safe Datalog :;<z -program is equivalent to a program in S...|$|R
50|$|A smart (model-based, grammar-based, or protocol-based) fuzzer leverages {{the input}} model to {{generate}} {{a greater proportion of}} <b>valid</b> <b>inputs.</b> For instance, if the input can be modelled as an abstract syntax tree, then a smart mutation-based fuzzer would employ random transformations to move complete subtrees from one node to another. If the input can be modelled by a formal grammar, a smart generation-based fuzzer would instantiate the production rules to generate <b>inputs</b> that are <b>valid</b> w.r.t. the grammar. However, generally the input model must be explicitly provided which is difficult when it is proprietary, unknown, or very complex. If a large corpus of <b>valid</b> and invalid <b>inputs</b> are available, a grammar induction technique, such as Angluin's L* algorithm would be able {{to generate a}}n input model.|$|R
50|$|LR parse {{tables are}} two-dimensional. Each current LR(0) parser state {{has its own}} row. Each {{possible}} next symbol has its own column. Some combinations of state and next symbol are not possible for <b>valid</b> <b>input</b> streams. These blank cells trigger syntax error messages.|$|E
50|$|While expected, <b>valid</b> <b>input</b> {{activates}} the normal, intended functionality in {{a computer}} program, input that was unexpected by the program developer may activate unintended functionality. The weird machine consists of this unintended functionality that can be programmed with selected inputs in an exploit.|$|E
5000|$|Test {{cases can}} be {{designed}} simply by selecting only <b>valid</b> <b>input</b> values for each field in the software. When changes are made in a particular module, the previous values may not actually test the new features introduced after the older version of software.|$|E
30|$|The {{algorithm}} is proposed {{to be used by}} an user to detect the credibility of sources and general acceptability of the tweets. It would also use the cognitive powers of the user to carry out the initial screening of messages. With that, the false positives of the algorithm would be minimum and the algorithm would provide <b>valid</b> <b>inputs</b> to the user in an accurate manner. The users who have a high degree of communication with the segregated sources could also be now identified along with the tweets involved in the spread of false information.|$|R
5000|$|In a {{dataflow}} language {{the operations}} {{can take place}} {{as soon as they}} have <b>valid</b> <b>inputs</b> for all of their connections. That means, in traditional terms, that each operation in this method could be carried out at the same time. In the database example, all of the sorts could take {{place at the same time}} if the computer were capable of supplying the data. Dataflow languages tend to be inherently concurrent, meaning they are capable of running on multiprocessor systems [...] "naturally", one of the reasons that it garnered so much interest in the 1980s.|$|R
50|$|Validity checks - {{controls}} that ensure only <b>valid</b> data is <b>input</b> or processed.|$|R
