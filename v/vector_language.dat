16|91|Public
50|$|The Hewlett-Packard Raster Transfer Language (HP RTL) is {{a subset}} of the Printer Command Language (PCL) language. It is used to embed true raster images (bitmaps) into plotter files. Modern {{plotters}} (like HP DesignJets) are raster devices, so they need a raster-based language. For backward compatibility they also support the HP-GL/2 (formerly HP-GL) <b>vector</b> <b>language,</b> so the HP RTL language is designed for mixing with the HP-GL/2 language.|$|E
50|$|At {{the core}} of kdb+ is the {{built-in}} programming language, q. q is an expressive query language. The concise array language can manipulate streaming, real-time and historical data. kdb+ uses q to aggregate and analyze data, perform statistical functions, and join data sets and supports SQL queries The <b>vector</b> <b>language</b> q was built for speed and expressiveness and mostly {{eliminates the need for}} looping structures. kdb+ includes interfaces in C/C++, Java, C# and Python.|$|E
50|$|Chemical Computing Group is a {{software}} company specializing in research software for computational chemistry, bioinformatics, cheminformatics, docking, pharmacophore searching and molecular simulation. The company's main customer base consists of pharmaceutical and biotechnology companies, {{as well as}} academic research groups. It is a private company that was founded in 1994; it is based in Montreal, Quebec, Canada. Its main product, Molecular Operating Environment (MOE), is written in a self-contained programming system, the Scientific <b>Vector</b> <b>Language</b> (SVL).|$|E
50|$|PGML and <b>Vector</b> Markup <b>Language,</b> another XML-based <b>vector</b> {{graphics}} <b>language</b> W3C submission {{supported by}} Autodesk, Hewlett-Packard, Macromedia, Microsoft, and Visio Corporation, were later joined and improved upon to create Scalable Vector Graphics (SVG).|$|R
50|$|Pen {{plotters}} {{have essentially}} become obsolete, {{and have been}} replaced by large-format inkjet printers and LED toner based printers. Such devices may still understand <b>vector</b> <b>languages</b> originally designed for plotter use, because in many uses, they offer a more efficient alternative to raster data.|$|R
5000|$|<b>Vector</b> {{graphics}} <b>languages</b> HP-GL/2 and PCL-XL, monochrome, and color.|$|R
50|$|In 1993, Whitney left Morgan Stanley and co-founded Kx Systems with Janet Lustgarten {{to commercialize}} his K {{programming}} language. The company signed an exclusive agreement with Union Bank of Switzerland and Whitney developed {{a variety of}} trading applications using K until the contract expired. At {{the outset of the}} contract Whitney developed the kdb database built on K. In 2003, Kx Systems released Q, a new <b>vector</b> <b>language</b> that built upon K and the kdb+ database developed by Whitney.|$|E
50|$|Molecular Operating Environment (MOE) {{is a drug}} {{discovery}} software platform that integrates visualization, modeling and simulations, as well as methodology development, in one package. MOE scientific applications are used by biologists, medicinal chemists and computational chemists in pharmaceutical, biotechnology and academic research. MOE runs on Windows, Linux, Unix, and MAC OS X. Main application areas in MOE include structure-based design, fragment-based design, pharmacophore discovery, medicinal chemistry applications, biologics applications, protein and antibody modeling, molecular modeling and simulations, cheminformatics & QSAR. The Scientific <b>Vector</b> <b>Language</b> (SVL) is the built-in command, scripting and application development language of MOE.|$|E
5000|$|SVL or Scientific <b>Vector</b> <b>Language</b> is a {{programming}} language created by Chemical Computing Group. It was first released in 1994. SVL is the built-in command, scripting and application development language of MOE. It is a [...] "chemistry aware" [...] computer {{programming language}} with over 1,000 specific functions for analyzing and manipulating chemical structures and related molecular objects. SVL is a concise, high-level language whose programs are typically 10 times smaller than their equivalent when compared to C or Fortran. SVL source code is compiled to a [...] "byte code" [...] representation, which is then executed by the base run-time environment making SVL programs inherently portable across different computer hardware and operating systems.|$|E
5000|$|APL A <b>vector</b> {{oriented}} <b>language</b> {{using an}} unusual character set ...|$|R
50|$|<b>Vector</b> Markup <b>Language</b> (VML) was an XML-based {{file format}} for {{two-dimensional}} vector graphics.|$|R
40|$|AbstractIn {{the formal}} setting of finitary/infinitary languages, and {{transition}} systems, we {{build a new}} product, in spirit a shuffle product with rendez-vous on specific alphabet letters. As those languages are often meant to model process behaviors in parallel computing theories, we show the interest of our product in this field, building {{the behavior of a}} system from the ones of its componentsâ€”we focus here on path-expressions and <b>Vector</b> <b>languages</b> theories...|$|R
40|$|Some {{results from}} [2], [5], [6] are {{generalized}} for finite automata over arbitrary groups. The accepting power is smaller when abelian groups are considered, {{in comparison with}} the non-abelian groups. We prove that {{this is due to the}} commutativity. Each language accepted by a finite automaton over an abelian group is actually a unordered <b>vector</b> <b>language.</b> Finally, deterministic finite automata over groups are investigated. TUCS Research Grou...|$|E
40|$|AbstractWithin the {{framework}} of Vector Controlled Concurrent Systems a concurrent system consists of a fixed number of sequential processes together with a vector synchronization mechanism controlling their mutual synchronization. The behaviour of a VCCS is described by a <b>vector</b> <b>language</b> consisting of those combinations of individual sequential computations that observe the synchronization constraints. In this paper VCCS submodels are studied that are obtained by putting certain restrictions on the sequential components or on the control mechanism. First, the inclusion diagram relating the resulting families of vector languages is established. Next, the effect of certain operations on these families is investigated. This leads to representation results characterizing differences between the combinations of restrictions...|$|E
40|$|AbstractSome {{results from}} Dassow and Mitrana (Internat. J. Comput. Algebra (2000)), Griebach (Theoret. Comput. Sci. 7 (1978) 311) and Ibarra et al. (Theoret. Comput. Sci. 2 (1976) 271) are {{generalized}} for finite automata over arbitrary groups. The closure properties of these automata are poorer and the accepting power is smaller when abelian groups are considered. We {{prove that the}} addition of any abelian group to a finite automaton is less powerful than {{the addition of the}} multiplicative group of rational numbers. Thus, each language accepted by a finite automaton over an abelian group is actually a unordered <b>vector</b> <b>language.</b> Characterizations of the context-free and recursively enumerable languages classes are set up in the case of non-abelian groups. We investigate also deterministic finite automata over groups, especially over abelian groups...|$|E
50|$|Since the 2009 release, {{the editor}} TeXworks is {{included}} for Microsoft Windows and Mac OS X {{as well as}} the <b>vector</b> graphics <b>language</b> Asymptote.|$|R
50|$|Iliffe vectors are {{contrasted with}} dope <b>vectors</b> in <b>languages</b> such as Fortran, which contain the stride factors and offset {{values for the}} {{subscripts}} in each dimension.|$|R
30|$|In this article, {{multiple}} {{total factor}} vector are proposed for language recognition based on using total factor <b>vector</b> in <b>language</b> recognition. Our experiments show that total factor <b>vector</b> includes the <b>language</b> dependent information. Further more, multiple total factor <b>vector</b> contains more <b>language</b> dependent information. Comparing to popular acoustic system (MMI and GMM-SVM system) in language recognition, those two new language features contain different language dependent information. We {{believe it is}} attractive that our proposed features can improve our best acoustic performance of {{the combination of the}} MMI and GMM-SVM systems. In our future study, different approaches of intersession compensation will be carried on the new features.|$|R
40|$|We {{consider}} {{a simple and}} natural extension of a finite automaton, namely an element of a given group is associated with each configuration. An input string is accepted {{if and only if}} the neutral element of the group is associated to a final configuration reached by the automaton. The accepting power is smaller when abelian groups are considered, in comparison with the non-abelian groups. We prove that {{this is due to the}} commutativity. Each language accepted by a finite automaton over an abelian group is actually a unordered <b>vector</b> <b>language.</b> We get a new characterization of the context-free languages as soon as the considered group is the binary free group. The result cannot be carried out in the deterministic case. Some remarks about other groups are also presented...|$|E
40|$|The ligand field {{molecular}} mechanics (LFMM) model, which {{incorporates the}} ligand field stabilization energy (LFSE) {{directly into the}} potential energy expression of molecular mechanics (MM), has been implemented in the "chemically aware" molecular operating environment (MOE) software package. The new program, christened DommiMOE, is derived from our original in-house code that {{has been linked to}} MOE via its applications programming interface {{and a number of other}} routines written in MOE's native scientific <b>vector</b> <b>language</b> (SVL). DommiMOE automates the assignment of atom types and their associated parameters and popular force fields available in MOE such as MMFF 94, AMBER, and CHARMM can be easily extended to provide a transition metal simulation capability. Some of the unique features of the LFMM are illustrated using MMFF 94 and some simple [MCl 4](2) - and [Ni(NH 3) (n) ](2 +) species. These studies also demonstrate how density functional theory calculations, especially on experimentally inaccessible systems, provide important data for designing improved LFMM parameters. DommiMOE treats Jahn-Teller distortions automatically, and can compute the relative energies of different spin states for Ni(II) complexes using a single set of LFMM parameters. (C) 2004 Wiley Periodicals, Inc...|$|E
40|$|Copyright Â© 2014 David William Thomas. This is an {{open access}} article {{distributed}} under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. Software to support the Monte Carlo method generates large vectors of pseudo-random numbers and uses these as operands in complex mathematical expressions. When such software is run on standard PC-based hardware, the volume of data involved often exceeds the physical RAM available. To address this problem, vectors must be paged out to disk and paged back in when required. This paging is often the performance bottleneck limiting the execution speed of the software. Because the mathematical expressions are specified in advance of execution, predictive solutions are possible â€“ for instance, by treating the problem similarly to register allocation. The problem of allocating scalar variables to processor registers is a widely studied aspect of compiler implementation. A register allocation algorithm decides which variable is held in which register, when the value in a register can be overwritten, and when a value is stored in, or later retrieved from, main memory. In this paper, register allocation techniques are used to plan the paging of vectors in Monte Carlo software. Two register allocation algorithms are applied to invented vector programs written in a prototype low-level <b>vector</b> <b>language</b> {{and the results are}} compared...|$|E
40|$|Efficient Matlab {{codes in}} 2 D and 3 D have been {{proposed}} recently to assemble finite element matrices. In this paper we present simple, compact and efficient vectorized algorithms, which are variants of these codes, in arbitrary dimension, {{without the use of}} any lower level language. They can be easily implemented in many <b>vector</b> <b>languages</b> (e. g. Matlab, Octave, Python, Scilab, R, Julia, C++ with STL, [...] .). The principle of these techniques is general, we present it for the assembly of several finite element matrices in arbitrary dimension, in the P 1 finite element case. We also provide an extension of the algorithms to the case of a system of PDE's. Then we give an extension to piecewise polynomials of higher order. We compare numerically the performance of these algorithms in Matlab, Octave and Python, with that in FreeFEM++ and in a compiled language such as C. Examples show that, unlike what is commonly believed, the performance is not radically worse than that of C : in the best/worst cases, selected <b>vector</b> <b>languages</b> are respectively 2. 3 / 3. 5 and 2. 9 / 4. 1 times slower than C in the scalar and vector cases. We also present numerical results which illustrate the computational costs of these algorithms compared to standard algorithms and to other recent ones...|$|R
40|$|AbstractWe {{describe}} a true-concurrent approach for managing dependencies between distributed and concurrent coordinator {{components of a}} long-running transaction. In previous work we have described how interactions specified in a scenario can be translated into a tuples-based behavioural description, namely <b>vector</b> <b>languages.</b> In this paper we show how reasoning against order-theoretic properties of such languages can reveal missing behaviours which are not explicitly described in the scenario but are still possible. Our approach supports the gradual refinement of scenarios of interaction into {{a complete set of}} behaviours that includes all desirable orderings of execution and prohibits emergent behaviour of the transaction...|$|R
50|$|A second {{note was}} {{submitted}} came {{a month later}} from a team which included representatives of Hewlett Packard, Macromedia, Microsoft, and Visio; the note contained a draft specification for the <b>Vector</b> Markup <b>Language</b> (VML), another XML-based markup language.|$|R
40|$|A {{well known}} problem when {{reasoning}} about concurrent systems {{is that of}} state explosion. One of the strategies that has been proposed to alleviate this problem is {{to make use of}} the symmetries which a concurrent system may exhibit to construct a symmetry-reduced model that reflects the behaviour of the system. The main contribution of this thesis is an investigation into the theoretical foundations of the method by considering symmetries in the context of category theory. It seems natural to do so since the morphisms that characterise each category may be thought of as a kind of simulation of behaviour. A new category of language systems is presented, together with several subcategories. Morphisms in this category are defined to preserve structure. The notion of a symmetry of a language system is defined and the quotient structure of the language system is given. The important question of behaviour preservation between the system and its symmetry-reduced model is generalised to the notion of morphism in the category. The conditions required on the morphism to ensure that it preserves behaviour are identified. These results are extended to the projection morphism that define the symmetry-reduced model by constructing a split morphism. Two specific behaviours, namely absence of deadlock and extensibility, are considered. The second contribution of this thesis is to establish a categorical relationship between the language system model and elementary nets. A <b>vector</b> <b>language</b> semantics for elementary nets is given. Functors between these categories are defined and the existence of an adjunction is proved...|$|E
40|$|Current {{advances}} in software engineering practice involve {{the adoption of}} a component- based approach in developing large-scale, complex systems. The component-based paradigm provides better structuring of systems and facilitates systematic software reuse. However, complex interactions between components, especially in concurrent and distributed applications, pose greater challenges. This thesis provides a formal framework for managing the dependencies between components, in terms of their interactions in a concurrent setting. In our approach, composites and single components are represented by a component signature, which identifies a component, and a <b>vector</b> <b>language,</b> also called component language, which describes the behaviour of a component. This language-based representation of component behaviour makes it possible to capture concurrency at both the individual component level and the composition level. The interpretation of concurrency is that of a non-interleaving model, with the notion of causal independence lifted to vectors. We describe how component languages are obtained from scenario-based specifications, typically used in an industrial context. Based on the order structure of a component language, we identify implicit or missing interactions which represent potentially faulty or simply unthought scenarios. This excludes pathological behaviour, the source of which {{can be traced back to}} inconsistencies in the sequence diagrams of the scenario specification such as race conditions, and this gives a characterisation of well-behaved components. Components are put together in our approach by matching required and provided interfaces in terms of the respective sequences of events. This builds on the concept of parallel composition in process algebras. We show that the properties that define well-behaved components are preserved under composition in the resulting composite. Well-behaved components give rise to discrete behavioural presentations which can capture concurrency and simultaneity between event occurrences on component interfaces. Well-behaved components are also associated with automata whose transition structure reflects the concurrency in the corresponding component language. This state-based description of component behaviour is graphically represented using state diagrams. This formal framework for components has been related to more conventional approaches to software design, as exemplified by strong connections to UML. It can aid designers in determining the complete set of intended behaviours before generating state models of the scenario-based specifications...|$|E
40|$|This {{thesis is}} {{comprised}} of three projects that are driven by a common theme, which {{is the use of}} computational tools in aiding molecular probe and drug design. In the first project, the feasibility of using molecular docking and scoring to estimate binding affinity for small molecules labelled covalently with fluorophores was tested using several proof-of-concept experiments. The high-throughput nature of computational screening applications such as Hierarchical Virtual Ligand Screening (HierVLS) necessitate that, in order to screen these labelled compounds, there must be an automated way to generate the associated structures virtually from large databases of base compounds and fluorophores. A script was developed in MOE software using scientific <b>vector</b> <b>language</b> (SVL) that could identify key reactive functional groups in both reactive fluorophores and target base compounds, and create the appropriate labelled structures for screening. The final fluorescence-labelled database numbers 14, 862 compounds, each tagged with the ATTO 680 fluorophore. In a subsequent project, the fluorescence-tagged library was screened against carbonic anhydrase 9 (CAIX), a protein implicated as a biomarker in several cancer types. This screening was accompanied by the screening of a validation set of known CAIX ligands and appropriately chosen decoys. The best scoring protocol according to our analyses was that which used principal components analysis. Ten of the top scoring candidates are suggested for future testing as probe candidates. CAIX binding sites were compared with equivalent residues in the sequences of 24 other CA isoforms to identify sites that might confer CAIX specificity, and the top scoring ligands were ranked according to this scheme. Lastly, experimental characterization was performed on three previously identified potential ligands for a cancer-related receptor tyrosine kinase, EphB 4. Two in vitro assay formats were used: a homogenous time-resolved fluorescence assay and an enzyme-coupled spectrophotometric assay. One candidate, DNP-L-Arg, {{was the only one of}} the three with some experimental evidence of affecting kinase activity. The first assays suggested that DNP-L-Arg may have an activating effect on EphB 4. The plausibility of this effect discussed with respect to mechanisms found in the literature, and using predicted and experimental structures for docked ligands. The coupled assay format did not conclusively confirm this effect. The research presented underscores the ability for computational tools to be incorporated into a variety of different areas within the fields of biochemistry and drug design. Future complementary experimental work will be crucial both in evaluating and refining the suggested probe candidates and in further validating and improving the computational techniques used...|$|E
40|$|In {{this paper}} we propose a general {{framework}} for learning distributed represen-tations of attributes: characteristics of text whose representations can be jointly learned with word embeddings. Attributes can correspond {{to a wide variety of}} concepts, such as document indicators (to learn sentence <b>vectors),</b> <b>language</b> in-dicators (to learn distributed language representations), meta-data and side infor-mation (such as the age, gender and industry of a blogger) or representations of authors. We describe a third-order model where word context and attribute vectors interact multiplicatively to predict the next word in a sequence. This leads to the notion of conditional word similarity: how meanings of words change when con-ditioned on different attributes. We perform several experimental tasks including sentiment classification, cross-lingual document classification, and blog author-ship attribution. We also qualitatively evaluate conditional word neighbours and attribute-conditioned text generation. ...|$|R
40|$|Abstract. We {{describe}} different optimization {{techniques to}} perform the assembly of finite element matrices in <b>vector</b> <b>languages</b> (e. g. Matlab, Octave, Python), from the standard approach to recent vectorized ones, without any low level language used. We finally obtain a simple and efficient vectorized algorithm. A comparison is given with a compiled language such as C. Unlike what was expected and generally accepted, examples show that the performances of Matlab, Octave and Python are not {{as far as the}} ones of C. The principle of this assembly algorithm is general, we present it for a large class of partial differential operators in the scalar or vector cases in 2 d and 3 d, in the P 1 finite elements case, with an application to linear elasticity. We present numerical results which illustrate the computational costs of the different approaches...|$|R
50|$|In {{computer}} science, array programming languages (also {{known as}} <b>vector</b> or multidimensional <b>languages)</b> generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays.|$|R
40|$|This thesis {{presents}} {{new approach}} to the supervisory control of complex systems modelled as Multi-Agent (MA) products of finite deterministic automata. First, the centralized supervisory control problem for the MA product is considered. This differs from the standard approach to supervisory control since (i) vector languages are under consideration and (ii) each supervisor can disable only one particular component of a vector event. The notion of MA controllability is introduced and is shown to essentially constitute a necessary and sufficient condition for the synthesis of an MA supervisor. In the case when a given <b>vector</b> <b>language</b> K fails to be MA controllable, an algorithm for finding the infimal MA controllable superlanguage of K is presented. It is also shown that there exists, {{with respect to the}} inclusion partial order, a maximal MA controllable sublanguage of K. The results constitute a natural extension of the central classical supervisory control results for scalar systems to the more general MA product system case. Second, the controllability properties of component structures are investigated. It is proved that the property of MA controllability is preserved under iterative MA product construction. Moreover, it is proved that in this case the MA product of supervisors of subsystems ensures the desired behaviour of the MA product of specifications for the iterative MA product. Several examples illustrate that neither standard controllability nor the second property of MA controllability, so-called MAC 2, are preserved under projection operation. However, a sufficient condition for the standard controllability of a component in terms of the original vector specification and the MA product is given. The equality of the vector specification projected on the set of some components of an original MA product and an MA product of the projections on the corresponding components is shown to be a necessary and sufficient condition for the projected specification having MAC 2 property. Furthermore, a special class of specifications, namely, state trajectory specifications, for both scalar and vector automata is considered and conditions for the embedding of two specifications are presented. Third, the notion of the Graph-Relation MA product is introduced. Through this construction, we modify the connection of supervisors and vector system under consideration, and prove that the property of MA controllably remains the necessary and sufficient condition for the existence of a solution to the supervisory control problem. Next, an initial investigation on the MA product under partial observation is presented. The notions of MA observability and MA co-observability are formulated and it is shown that they {{play a key role in}} the solution of decentralized supervisory control problems for the MA product. Furthermore, applications to hybrid systems are explored. Finally, a line of further research on centralized and decentralized MA product is mapped out, as well as complexity studies and the generation of MA software...|$|E
50|$|Asymptote is a {{descriptive}} <b>vector</b> graphics <b>language</b> â€” developed by Andy Hammerlindl, John C. Bowman (University of Alberta), and Tom Prince â€” {{which provides a}} natural coordinate-based framework for technical drawing. Asymptote runs on all major platforms (Unix, Mac OS, Microsoft Windows). It is free software, available {{under the terms of}} the GNU Lesser General Public License (LGPL).|$|R
40|$|Prefix {{functions}} are thought as a unifying concept for {{different ways of}} looking at discrete processes. The idea of prefix function consists in establishing relations between events and states; different types of such relations correspond to different ways of understanding states being reached in the course of computation. This concept covers such concurrent systems description tools as finite state automata, trees, Petri Nets, traces, occurring graphs, <b>vector</b> <b>languages,</b> multi-trees and similar. Special attention is paid to operations of contraction and synchronization on prefix functions. Keywords: events; states; discrete processes; concurrency. 1 Introduction The purpose of the present paper is to situate trace calculus within a broader context of concurrency description tools. Trace theory turns out to be useful for describing and analysing some concurrency phenomena because of its similarity to the well established and familiar theory of automata and formal languages on one hand [...] ...|$|R
30|$|In this article, {{we propose}} a new feature {{which could be}} used for the {{framework}} of SVM-based language recognition, by introducing the idea of total variability used in speaker recognition to language recognition. We consider the new feature as low-dimensional representation of Gaussian mixture model supervector. Thus we propose multiple total variability (MTV) language recognition system based on total variability (TV) language recognition system. Our experiments show that the total factor <b>vector</b> includes the <b>language</b> dependent information; what's more, multiple total factor <b>vector</b> contains more <b>language</b> dependent information.|$|R
25|$|SVG {{has been}} in {{development}} within the World Wide Web Consortium (W3C) since 1999, after six competing proposals for <b>vector</b> graphics <b>languages</b> had been submitted to the consortium during 1998. The early SVG Working Group decided not to develop any of the commercial submissions, but {{to create a new}} markup language that was informed by but not really based on any of them.|$|R
40|$|Valences are a {{very simple}} and yet {{powerful}} method of regulated rewriting. In this paper we give an overview on different aspects of this subject. We discuss closure properties of valence languages. It is shown that matrix grammars can be simulated by valence grammars over finite monoids. A Chomsky normal form theorem is proved for multiplicative valence grammars, thereby solving the open question {{of the existence of}} normal forms for unordered vector grammars. This also gives an alternative proof of the inclusion of context-free unordered <b>vector</b> <b>languages</b> in LOG(CFL). Moreover, we investigate valences in parallel systems, thereby solving part of open problems posted in [5, p. 267]. 1 Introduction Valences were introduced in 1980 by Paun [13] as a mechanism of regulated rewriting. The original idea was to assign to a context-free core rule an integer, the valence, and to compute for a derivation a value by adding the valences of the applied rule. A derivation is valid iff this sum ev [...] ...|$|R
