22|10000|Public
5000|$|PROGRES, an {{integrated}} environment and <b>very</b> <b>high</b> <b>level</b> <b>language</b> for PROgrammed Graph REwriting Systems ...|$|E
40|$|Languages with {{implicit}} parallelism {{are easier}} to program in than those with explicit parallelism, but finding and efficiently exploiting parallelism in general-purpose programming languages by parallelizing compilers is hard. A compiler for a <b>Very</b> <b>High</b> <b>Level</b> <b>Language,</b> designed for a specific application domain, has more knowledge about its application domain and may use this knowledge to generate efficient parallel code without requiring the programmer to deal with explicit parallelism. To investigate this idea, we designed Multigame, a <b>Very</b> <b>High</b> <b>Level</b> <b>Language</b> for describing board games. A Multigame program is a formal description {{of the rules of}} a game, from which the Multigame compiler automatically generates a parallel game playing program. Keywords: implicit parallelism, <b>Very</b> <b>High</b> <b>Level</b> <b>Language,</b> game-tree searching 1 Introduction Parallelism in general-purpose languages can be either explicit or implicit. Explicit parallelism requires the programmer to explicitly point out in [...] ...|$|E
40|$|In this paper, {{we present}} the Ctadel system, a Code-generation Tool for Applications based on Differential Equations using a <b>very</b> <b>high</b> <b>level</b> <b>Language</b> specification. The Ctadel system generates {{efficient}} and vectorizable Fortran 77 code automatically from a <b>very</b> <b>high</b> <b>level</b> <b>language</b> {{description of a}} model described by partial differential equations (PDEs). The system combines algebraic simplification and powerful global common subexpression elimination to guarantee the generation of efficient code. A prototype implementation has been developed which is currently limited to explicit finite difference methods as solution method. After an informal, but {{detailed description of the}} Ctadel system, results of this prototype implementation will be presented for the time-dependent Euler equations to simulate an inviscid, compressible flow and for the calculation of the explicit dynamical tendencies within the hirlam model, which is a production code for limited area numerical weather forecasting [...] . ...|$|E
5000|$|An anecdote about ML type inference, USENIX <b>Very</b> <b>High</b> <b>Level</b> <b>Languages</b> Symposium, October 1994, Santa Fe ...|$|R
50|$|For {{the purpose}} of clarity ‘source code’ is taken to mean any fully {{executable}} description of a software system. It is therefore so construed as to include machine code, <b>very</b> <b>high</b> <b>level</b> <b>languages</b> and executable graphical representations of systems.|$|R
40|$|Godiva is a dialect of Java that {{provides}} general purpose abstractions {{that have been}} shown to be valuable in several <b>very</b> <b>high</b> <b>level</b> <b>languages.</b> These facilities include additional built-in data types, <b>higher</b> <b>level</b> operators, goal-directed expression evaluation, and pattern matching on strings. Godivas extensions make Java more suitable for rapid prototyping and research programming...|$|R
40|$|This paper {{describes}} the TRAP compiler generator. The object-oriented, dynamic language Python plays {{a central role}} in TRAP: As a <b>very</b> <b>high</b> <b>level</b> <b>language</b> it contributes built-in polymorphic collection and mapping data types, a exible object model, automatic memory management and more features meaning mortal danger to the of complexity" all too common to (even tool-based) compiler development...|$|E
40|$|We {{introduce}} a <b>very</b> <b>high</b> <b>level</b> <b>language</b> for specifying synchronization properties. It is designed using the primitives of temporal logic which facilitates the specification of both invariant and time-dependent properties. The paper {{begins with a}} discussion of properties that affect synchronization. The specification language then introduced features constructs to express each of these in a fairly natural and modular fashion. Since the statements in the language have intuitive interpretations, specifications are humanly readable. Also, since they possess appropriate formal semantics, unambiguous specifications result...|$|E
40|$|IV is a <b>very</b> <b>high</b> <b>level</b> <b>language</b> {{designed}} {{for use in a}} real time production control environment. While most fourth generation languages are intended for use by end users, IV is more suitable for skilled professional programmers. One of the major design objectives of IV is a dramatic improvement in programmer efficiency during application program development. Non-procedural constructs provided by the language and the use of a number of interactive development tools provide an environment for achieving this goal. This report presents a language proposal for IV, and addresses related design and implementation issues...|$|E
50|$|The report {{described}} {{a vision for}} {{a new approach to}} software development. Rather than define specifications with diagrams and manually transform them to code as was the current process, the KBSA vision was to define specifications in <b>very</b> <b>high</b> <b>level</b> <b>languages</b> and then to use transformation rules to gradually refine the specification into efficient code on heterogeneous platforms.|$|R
40|$|AbstractThis paper {{presents}} SPORA, {{a system}} for program synthesis using knowledge bases. The nonprocedural style of problem specification supported by the system is illustrated. The specification language has some features of <b>very</b> <b>high</b> <b>level</b> <b>languages.</b> The {{emphasis is on the}} program synthesis devices underlying the system. In the framework of a single formalism, different algorithms of program synthesis employed in the system are compared...|$|R
50|$|The text {{is written}} in a <b>very</b> <b>high</b> <b>level</b> Greek <b>language,</b> {{displaying}} a real refinement of Greek culture so far east in Kandahar. The verses are in the sophisticated acrostich form.|$|R
40|$|The Problem Specification (PS) nonprocedural {{language}} is a <b>very</b> <b>high</b> <b>level</b> <b>language</b> for algorithm specification. PS is suitable for nonprogrammers, who can specify a problem using mathematically-oriented equations; for expert programmers, who can prototype different versions of a software system for evaluation; {{and for those who}} wish to use specifications for portions (if not all) of a program. PS has data types and modules similar to Modula- 2. The compiler generates C code. In this paper, we first show PS by example, and then discuss efEiciency issues in scheduling and code generation...|$|E
40|$|Electromagnetics (CEM) are {{becoming}} more important as the complexity of CEM codes continue to increase. Object orientated programming (OOP) methods promise to alleviate the challenges posed by more complex software systems, but offers little help for legacy codes. Python, an object-oriented <b>very</b> <b>high</b> <b>level</b> <b>language</b> (VHLL), {{can be used to}} extend legacy codes. It provides the dual benefit of a very productive programming environment and of enabling legacy codes to be migrated to object orientated designs with low risk. The application of this method is described in the context of eMAGUS, a microwave Finite Element Method code...|$|E
40|$|Obol is {{a special}} purpose {{programming}} language {{for the implementation of}} security protocols. It has been designed with the success of ban in mind. In particular, the language mimic the representation used to express protocols before idealization. Obol is a (<b>very)</b> <b>high</b> <b>level</b> <b>language,</b> and, in most cases, it is straight forward to convert a protocol expressed in the traditional notation (e. g. : A → B: {NA, NB}KAB) into Obol. Obol is well suited for experimenting with security protocol design. The Obol runtime, named Lobo, has been implemented; the implementation is presented and the design discussed. Several well known protocols are run to justify the approach. ...|$|E
50|$|Two {{forms of}} GAL are available. The first is General Automation Language for device {{automation}} {{and the second}} is Generalized Automation Language (GAL) which a <b>very</b> <b>high</b> <b>level</b> programming <b>language</b> for MVS based systems such as OS/390 and z/OS.|$|R
40|$|A {{new method}} of programming, called {{relational}} programming, is introduced. This is {{a style of}} programming in which entire relations are manipulated rather than individual data. This is analogous to functional programming, wherein entire functions are the value manipulated by the operators. Because {{of its ability to}} manipulate complex data structures other than lists, relational programming seems to have distinct advantages over other <b>very</b> <b>high</b> <b>level</b> <b>languages.</b> This paper introduces the basic concepts of relational programming and a preliminary notation for expressing them; it does not define a programming language, per se. (Author) Prepared for: Naval Postgraduate School, Monterey, California 93940. [...] Cover. [URL]...|$|R
40|$|Language Reference Manual Godiva is a dialect of Java that {{provides}} general purpose abstractions {{that have been}} shown to be valuable in several <b>very</b> <b>high</b> <b>level</b> <b>languages.</b> These facilities include additional built-in data types, <b>higher</b> <b>level</b> operators, goaldirected expression evaluation, and pattern matching on strings. Godiva's extensions make Java more suitable for rapid prototyping and research programming. Adding these features to the core language increases the expressive power of Java in a way that cannot be achieved by class libraries. Despite introducing <b>higher</b> <b>level</b> structures and expression semantics, Godiva retains as much compatibility with Java as possible. Most Java code does not break when compiled with Godiva, and Godiva programs can utiliz...|$|R
40|$|This book {{describes}} the software for creating networked, 3 D multi-user virtual environments that allow users {{to create and}} remotely share visualizations of program behavior. The authors cover the major features of collaborative virtual environments and how to program them in a <b>very</b> <b>high</b> <b>level</b> <b>language,</b> and show how visualization can enable important advances {{in our ability to}} understand and reduce the costs of maintaining software. The book also examines the application of popular game-like software technologies.   • Discusses the acquisition of program behavior data to be visualized • Demonstrates the integration of multiple 2 D and 3 D dynamic views within a 3 Dscene • Presents the network messaging capabilities to share those visualization...|$|E
40|$|In {{this paper}} a {{software}} tool called attribute grammar based theorem prover (AGBTP) is proposed, {{which can be}} used both as a processor of attribute grammars and as a theorem prover. Hence, attribute grammars' applications from the area of software engineering as well as theorem proving applications from the area of knowledge engineering can be faced using the same tool. The main advantages of the proposed tool are that it can combine procedural and declarative characteristics using a <b>very</b> <b>high</b> <b>level</b> <b>language</b> i. e. the attribute grammars' language and user defined semantic functions in the host language. Second, full theorem proving capabilities are obtained through an extended parser, which implements the model elimination procedure. © 1988...|$|E
40|$|Algorithm {{design is}} a {{challenging}} intellectual activity {{that provides a}} rich source of observation and a test domain for a theory of problem-solving behavior. This paper describes a model of the algorithm design process based on observations of human design. The adaptation of that model to automation in the DESIGNER system helps us understand human design better, and the automation process helps validate the model. Issues discussed include the problem spaces used for design, the loci of knowledge and problem-solving power, and the relationship to other methods of algorithm design and to automatic programming as a whole I. The Algorithm Design Task A. Design as an Intellectual Activity Algorithm design is the process of coming up with a sketch, in a <b>very</b> <b>high</b> <b>level</b> <b>language,</b> of a computationally feasible techniqu...|$|E
40|$|Sparse {{matrices}} {{are first}} class objects in many VHLLs (<b>very</b> <b>high</b> <b>level</b> <b>languages)</b> used for scientific computing. They are a {{basic building block}} for various numerical and combinatorial algorithms. Parallel computing is becoming ubiquitous, specifically due to the advent of multi-core architectures. As existing VHLLs are adapted to emerging architectures, and new ones are conceived, one must rethink tradeoffs in language design. We describe the design and implementation of a sparse matrix infrastructure for Star-P, a parallel implementation of the Matlab R © programming language. We demonstrate the versatility of our infrastructure by using it to implement a benchmark that creates and manipulates large graphs. Our design {{is by no means}} specific to Star-P — we hope it will influence the design of sparse matrix infrastructures in other languages. ...|$|R
50|$|The Knowledge Based Software Assistant (KBSA) was a {{research}} program funded by the United States Air Force. The goal {{of the program was}} to apply concepts from artificial intelligence to the problem of designing and implementing computer software. Software would be described by models in <b>very</b> <b>high</b> <b>level</b> <b>languages</b> (essentially equivalent to first order logic) and then transformation rules would transform the specification into efficient code. The air force hoped to be able to generate the software to control weapons systems and other command and control systems using this method. As software was becoming ever more critical to USAF weapons systems it was realized that improving the quality and productivity of the software development process could have significant benefits for the military, as well as for information technology in other major US industries.|$|R
40|$|Debugging {{tools and}} {{techniques}} have varied from toggling switches and reading lights at CPU console to <b>very</b> sophisticated <b>high</b> <b>level</b> <b>language</b> interactive debuggers Because of its unique internal organization the interactive debugger described here can provide <b>high</b> <b>level</b> <b>language</b> debugging for several languages {{and allows the}} programmer to debug one or more processes which may be executing on different machines from each other andor from the debugge...|$|R
40|$|This paper {{describes}} a parallel version of ELLPACK for shared memory multiprocessors. ELLPACK {{is a system}} for numerically solving elliptic PDEs. It consists of a <b>very</b> <b>high</b> <b>level</b> <b>language</b> for defining PDE problems and selecting methods of solution, and a library of approximately fifty problem solving modules. Earlier work considered three discretization modules (five point star, hodie, and hermite collocation), two linear system solution modules (linpack spd band and jacobi cg), and a triple module (hodie fft) which includes both discretization and solution, all for rectangular domains and simple boundary conditions. Here we describe parallel versions of six additional modules (hermite collocation, hodie helmholtz, five point star, band ge, sor, symmetric sor cg) for general boundary conditions and domains, and discuss modifications to the ELLPACK preprocessor, the tool that translates an ELLPACK "program" into FORTRAN...|$|E
40|$|ISETL is a <b>very</b> <b>high</b> <b>level</b> <b>language</b> {{in which}} {{functions}} {{can be implemented}} quickly and expressively. We used the language ISETL to rapidly build a prototype for an electronic mail system. This prototype is a fully functional version of the mail system. However it lacks the ability to handle many users efficiently. After our prototype was complete, prospective users of the fully implemented version of the mail system used the prototype to request changes and additions to the specification of the final version. 1. 0 Introduction In the software development process {{one of the most}} difficult steps is requirements analysis. The systems analyst may not be able to accurately define the requirements of the system just by talking to the users. Conversely the users may not be able to express the requirements, because they are not able to predict all the implications of an automated system or visualize how the system will behave. However, users can usually determine if the systems does what they [...] ...|$|E
40|$|Many {{traditional}} {{software engineering}} courses, in {{their attempt to}} convey current industry practice, get bogged down in large texts or can implement only toy projects using traditional software engineering languages such as C, C++, Ada, or Oberon. An alternative approach is to use several iterations of rapid prototyping in a <b>very</b> <b>high</b> <b>level</b> <b>language</b> to convey key software engineering concepts and issues in a short time frame. 1 Introduction Software engineering occupies a major position in the computer science curriculum, and its importance has not diminished as time has passed. The complexity of the topic and the abstractness of many of its issues and methods make this material difficult to assimilate by persons who have written only short or perhaps medium-sized programs typical in university courses. This paper presents a brief look at the inherent problems in teaching software engineering, and then introduces a project oriented approach to teaching this material that alleviates s [...] ...|$|E
40|$|This {{dissertation}} {{deals with}} two related problems: {{development of a}} methodology for achieving memory and computation efficiency of computer programs, {{and the use of}} this methodology in very high-level programming and associated automatic program generators. Computer efficiency of programs has many aspects. Usually additional memory saves computation by avoiding the need to recompute certain variables. Our emphasis has been on reducing memory use by variables sharing memory space, without requiring recomputation. It will be shown that this also reduces computation overhead. The most significant savings are due to sharing memory in iterative steps. This is the focus of the reported research. The evaluation of memory use of the many possible alternatives for realizing a computation is highly complex and requires lengthy and expensive computations. We have developed a heuristic approach, which has been very effective in our experience, and which is practical and economical in use of the computer. Basically it consists of evaluating global memory usage altertnatives on each level of nested iteration loops, starting with the outside level and moving inwardly. Thus we neglect the rare impact of a nested iteration loop on the memory usage calculated for an outside iteration. This has lead to the principle of maximizing size of loop scopes in a program as a means to attaining a more efficient program for present-day sequential computers. The automatic design of efficient programs is also essential in use of <b>very</b> <b>high</b> <b>level</b> <b>languages.</b> The use of <b>very</b> <b>high</b> <b>level</b> <b>languages</b> offers many benefits, such as less program coding, less required proficiency in programming and analysis, and ease in understanding maintenance and updating of programs. All these benefits are conditioned on whether the language processor can produce satisfactorily efficient program. The dissertation reports the design and implementation of {{a new version of the}} MODEL language and processor which incorporates algorithms for producing more efficient programs. The dissertation describes briefly the MODEL non-procedural language and the analysis, scheduling, and code generation tasks...|$|R
40|$|A {{powerful}} appli ation of spe ialization is {{to remove}} inter-pretative overhead: a language an be implemented with an interpreter, whose performan e is then improved by spe ial-izing it for a given program sour e. This approa h is only moderately su essful with <b>very</b> <b>high</b> <b>level</b> <b>languages,</b> where the operation of ea h single step an be highly dependent on run-time data and ontext. In the present paper, the Psy o prototype for the Python language is presented. It introdu es two novel te hniques. The rst is just-in-time spe ialization, or spe ialization by need, whi h introdu es the " ability for a value to be promoted from run-time to ompile-time during spe ialization the inverse of the lift operator of partial evaluation. Its presen e gives an unusual and powerful perspe tive on the spe ialization pro ess. The se ond te hnique is representations, a theory of data-oriented spe ialization generalizing the traditional spe ialization domains (i. e. the ompile-time/run-time di-hotomy) ...|$|R
40|$|<b>Very</b> <b>high</b> <b>level</b> {{programming}} <b>languages</b> (<b>higher</b> than PL/I, Algol 60, etc.) {{attempt to}} free the programmer from providing details and let him concentrate on the algorithm for the problem at hand. The importance of <b>very</b> <b>high</b> <b>level</b> programming <b>languages</b> is further emphasized by decreasing machine costs, increased programming costs {{and the desire to}} have programs that are well structured, easy to understand and prove correct. <b>Very</b> <b>high</b> <b>level</b> <b>languages</b> provide powerful control structures and data structures that allow the problem to be specified in a natural manner. In this dissertation, we propose several ways of raising the <b>level</b> of a <b>language.</b> The different types of for iteration statements are consolidated into one general for statement. This, along with a new type, the domain of an array, provides us with an easy way of processing arrays; nested iteration statements are no longer necessary. The syntactic list and array generators and the concept of overloading make programming more flexible. The current notion that a data type is a set of values together with basic operations on that set leads us to conclude that formal parameter types need not be explicitly stated. Given a formal parameter X with operations z_ 1, z_ 2, [...] ., z_n being performed on it within the procedure, one should be able to supply, as an actual parameter in a call, a variable of any type that has the operations z_ 1, z_ 2, [...] ., z_n defined on it. For example, this concept allows us to write one procedure that finds the maximum value of the elements of an array of any dimension and any element or index type. Grids are arrays that can have any shape. Grid elements need not be contiguous i. e. grids can have holes in them. For example, grids can be trapezoidal, parabolic, rectangular with a hole or pyramid-like. Programs written using grids are more general than those written using arrays and/or functions to simulate non-array shapes. To alter an existing program to work for another grid shape one need only modify the grid declaration suitably, leaving the rest of the program intact. Programs are smaller, semantically clearer and have a more natural problem representation. Grids may be used to represent sparse matrices. Data security is achieved by allowing parts of grids pass as parameters to be readd only or completely masked out. Grids have been implemented as an extension to Fortran. Using Pascal as the base language, we show by series of examples from numerical analysis, data processing, engineering etc., how the above concepts raise the level of a programming language and how they blend together naturally and systematically. Efficient ways of implementing them are also discussed...|$|R
40|$|GENERIC is a {{programming}} language for the description and manipulation of integrated circuits. GENERIC works on the layout level with the designer in complete control of the layout process. To design an integrated circuit, a program is written which hierarchically describes the chip. The dynamic calling structure of the program determines the integrated circuit's hierarchical cell structure. These cells are created by special procedures called generators. Generators are capable of producing completely custom structures-they do not consist of predefined layout. In addition to the specification, GENERIC provides operators for the manipulation of integrated circuit layouts, thus enabling existing geometry to be modified. These modifications can be geometrical, topological or circuit. GENERIC is a <b>very</b> <b>high</b> <b>level</b> <b>language.</b> The language is general purpose-the VLSI aspects of the language are layered {{on top of the}} basic language as a run-time library. Since the library itself is written in GENERIC, the language is completely extensible...|$|E
40|$|This paper {{describes}} a fast and reliable algorithm which computes smooth piecewise polynomial approximations to functions. It adaptively locates the knots by {{a procedure that}} {{has been shown to}} provide the optimal rate of convergence as the accuracy requirements (and number of knots) increase. Local Hermite interpolation is used which requires that derivatives of the function be known (or estimated accurately) and that the polynomial degree plus one be twice the smoothness. The theoretical background and interesting algorithm components are described briefly then algorithm usage (user interface, role of two unusual arguments, portability) are discussed in more detail. A very brief summary is given of the extensive testing performed. The algorithm is first described in a <b>very</b> <b>high</b> <b>level</b> <b>language</b> (about 120 lines) and then given in Fortran (about 1250 lines). A test driver and a FUNCTION subprogram containing 20 fun~tio~s (with derivatives) are also given which are useful for testing this and other similar algorithms...|$|E
40|$|The aim of {{this work}} is to {{demonstrate}} the feasibility of using a declarative language {{as a tool for}} automated implementation of requirements written in a semiformal manner. The technique of structural synthesis of programs based on automatic proof search in intuitionistic propositional calculus implemented in the NUT system is used for solving the steam-boiler problem. The goal of the experiment is to bridge a gap between the language of requirements and an implementation. An appropriate set of concepts is developed for representing the problem, i. e. writing the requirements in a form understandable by the program synthesis tools. A complete implementation, including simulator of the actual steam-boiler and control panel, is written in NUT. 1. 0 Introduction This paper concerns automatic application of formal methods in implementation of industrial control systems. The idea is to use an extensible <b>very</b> <b>high</b> <b>level</b> <b>language,</b> extending it with a set of concepts sufficient for writing req [...] ...|$|E
40|$|We {{consider}} {{the problem of}} dynamically maintaining general series parallel directed acyclic graphs (GSP dags), two-terminal series parallel directed acyclic graphs (TTSP dags) and looped series parallel directed graphs (looped SP digraphs). We present data structures for updating (by both inserting and deleting either a group of edges or vertices) GSP dags, TTSP clags and looped SP digraphs of m edges and n vertices in O(log n) worst-case time. The time required to check {{whether there is a}} path between two given vertices is O(log n), while a path of length k can be traced out in O(k + log n) time. For GSP and TTSP dags, our data structures are able to report a regular expression describing all the paths between two vertices x and y in O(h + log n), where h ≤ n is the total number of vertices which are contained in paths from x to y. Although GSP dags can have as many as O(n 2) edges, we use an implicit representation which requires only O(n) space. Motivations for studying dynamic graphs arise in several areas, such as communication networks, Incremental compilation environments and the design of <b>very</b> <b>high</b> <b>level</b> <b>languages,</b> while the dynamic maintenance of series parallel graphs is also relevant in reducible flow diagrams...|$|R
50|$|Several {{just-in-time}} compilation {{techniques were}} pioneered and improved in Self research {{as they were}} required to allow a <b>very</b> <b>high</b> <b>level</b> object oriented <b>language</b> to perform at up to half the speed of optimized C. Much of the development of Self took place at Sun Microsystems, and the techniques they developed were later deployed for Java's HotSpot virtual machine.|$|R
40|$|MatLab {{is one of}} {{the most}} widely used <b>very</b> <b>high</b> <b>level</b> {{programming}} <b>languages</b> for Scientific and engineering computations. It is very user-friendly and needs practically no formal programming knowledge. Presented here are MatLab programming aspects and not just the MatLab commands for scientists and engineers who do not have formal programming training and also have no significant time to spare for learning programming to solve their real world problems. Specifically provided are programs for visualization. Also, stated are the current limitations of the MatLab, which possibly can be taken care of by Mathworks Inc. in a future version to make MatLab more versatile...|$|R
