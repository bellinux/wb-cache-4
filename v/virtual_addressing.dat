50|952|Public
25|$|The kernel has {{full access}} to the system's memory and must allow {{processes}} to safely access this memory as they require it. Often {{the first step in}} doing this is <b>virtual</b> <b>addressing,</b> usually achieved by paging and/or segmentation. <b>Virtual</b> <b>addressing</b> allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.|$|E
25|$|<b>Virtual</b> <b>addressing</b> {{also allows}} {{creation}} of virtual partitions of memory in two disjointed areas, one being {{reserved for the}} kernel (kernel space) {{and the other for}} the applications (user space). The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to the current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g. Singularity) take other approaches.|$|E
25|$|On many systems, a program's {{virtual address}} may refer to data {{which is not}} {{currently}} in memory. The layer of indirection provided by <b>virtual</b> <b>addressing</b> allows the operating system to use other data stores, like a hard drive, to store what would otherwise have to remain in main memory (RAM). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) {{and replacing it with}} the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as demand paging.|$|E
40|$|Security {{systems can}} provide secure and {{efficient}} in-VM monitoring. An exemplary security {{system can be}} built upon hardware virtualization features and can comprise a virtual machine having a plurality of standard <b>virtual</b> <b>address</b> spaces, {{as well as a}} hidden <b>virtual</b> <b>address</b> space. While the standard <b>virtual</b> <b>address</b> spaces can be directly accessible by a kernel in the virtual machine, the hidden <b>virtual</b> <b>address</b> space can be hidden from the kernel, which can be absent a virtual page table corresponding to the hidden <b>virtual</b> <b>address</b> space. A security monitor can reside in the hidden address space, monitoring the kernel without being modifiable by the kernel. A processor can transfer focus from the standard <b>virtual</b> <b>address</b> spaces to the hidden <b>virtual</b> <b>address</b> space only through predetermined entry gates, and the processor can transfer focus from the hidden <b>virtual</b> <b>address</b> space to the standard <b>virtual</b> <b>address</b> spaces only through predetermined exit gates. Georgia Tech Research Corporatio...|$|R
50|$|The Kernel <b>Virtual</b> <b>Address</b> Space (KVA) is {{the virtual}} memory {{area in which}} all Linux kernel threads reside. The {{second part of the}} <b>virtual</b> <b>address</b> space is {{occupied}} by the User <b>Virtual</b> <b>Address</b> Space which contain user threads.|$|R
50|$|Relative <b>virtual</b> <b>addresses</b> (RVAs) {{are not to}} be {{confused}} with standard <b>virtual</b> <b>addresses.</b> A relative <b>virtual</b> <b>address</b> is the <b>virtual</b> <b>address</b> of an object from the file once it is loaded into memory, minus the base address of the file image. If the file were to be mapped literally from disk to memory, the RVA would be the same as that of the offset into the file, but this is actually quite unusual.|$|R
50|$|The kernel has {{full access}} to the system's memory and must allow {{processes}} to safely access this memory as they require it. Often {{the first step in}} doing this is <b>virtual</b> <b>addressing,</b> usually achieved by paging and/or segmentation. <b>Virtual</b> <b>addressing</b> allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.|$|E
50|$|A 32-bit {{system with}} a CISC {{architecture}} based on DEC's earlier PDP-11, VAX ("virtual address extension") was designed to extend or replace DEC's various PDP ISAs. The VAX architecture's primary features were <b>virtual</b> <b>addressing</b> (for example demand paged virtual memory) and its orthogonal instruction set.|$|E
50|$|Later-model PDP-11 {{processors}} included {{memory management}} to support <b>virtual</b> <b>addressing.</b> The physical address space {{was extended to}} 18 or 22 bits, hence allowing up to 256 KB or 4 MB of RAM. The logical address space (that is, the address space available at any moment without changing the memory mapping table) remained limited to 16 bits.|$|E
50|$|Although <b>virtual</b> <b>addresses</b> are 64 bits wide in 64-bit mode, current {{implementations}} (and all chips {{known to}} be in the planning stages) do not allow the entire <b>virtual</b> <b>address</b> space of 264 bytes (16 EB) to be used.This would be approximately four billion times the size of <b>virtual</b> <b>address</b> space on 32-bit machines. Most operating systems and applications will not need such a large address space for the foreseeable future, so implementing such wide <b>virtual</b> <b>addresses</b> would simply increase the complexity and cost of address translation with no real benefit. AMD therefore decided that, in the first implementations of the architecture, only the least significant 48 bits of a <b>virtual</b> <b>address</b> would actually be used in address translation (page table lookup).|$|R
40|$|A <b>virtual</b> <b>address</b> cache memory, whose {{operation}} is controlled explicitly by software, is presented. Ad-hoc hardware mechanisms, including new machine instructions {{and a new}} operand addressing mode, reduce the complexity of cache management logic in favour of {{the capacity of the}} cache, and solve the major problem of <b>virtual</b> <b>address</b> cache organization: two or more <b>virtual</b> <b>addresses</b> mapping into the same real address...|$|R
50|$|Nearly all current {{implementations}} {{of virtual}} memory divide a <b>virtual</b> <b>address</b> space into pages, blocks of contiguous <b>virtual</b> memory <b>addresses.</b> Pages on contemporary systems are usually at least 4 kilobytes in size; systems with large <b>virtual</b> <b>address</b> ranges or amounts of real memory generally use larger page sizes.|$|R
50|$|Used when <b>virtual</b> <b>addressing</b> is enabled, hence {{when the}} PG bit {{is set in}} CR0. CR3 enables the {{processor}} to translate linear addresses into physical addresses by locating the page directory and page tables for the current task. Typically, the upper 20 bits of CR3 become the page directory base register (PDBR), which stores the physical address of the first page directory entry.|$|E
50|$|CP-6 {{was modeled}} on Xerox's CP-V. The code was {{completely}} rewritten {{in a new}} high-level language, PL-6, designed and built expressly for that purpose, rather than in assembly language as CP-V had been, because of increasing complexities of the new <b>virtual</b> <b>addressing</b> hardware (such as that in Honeywellâ€™s L66 and DPS 8 line). During the rewrite existing weaknesses were addressed and many new features added.|$|E
5000|$|Legacy mode is {{the mode}} used by 16-bit ("protected mode" [...] or [...] "real mode") and 32-bit {{operating}} systems. In this mode, the processor {{acts like a}} 32-bit x86 processor, and only 16-bit and 32-bit code can be executed. Legacy mode allows for a maximum of 32 bit <b>virtual</b> <b>addressing</b> which limits the virtual address space to 4 GB. 64-bit programs cannot be run from legacy mode.|$|E
25|$|The Alpha has a 64-bit linear <b>virtual</b> <b>address</b> {{space with}} no memory segmentation. Implementations can {{implement}} a smaller <b>virtual</b> <b>address</b> {{space with a}} minimum size of 43 bits. Although the unused bits were not implemented in hardware such as TLBs, the architecture required implementations to check whether they are zero to ensure software compatibility with implementations with a larger (or full) <b>virtual</b> <b>address</b> space.|$|R
5000|$|The AMD64 {{architecture}} {{defines a}} 64-bit <b>virtual</b> <b>address</b> format, {{of which the}} low-order 48 bits are used in current implementations. This allows up to 256 TB (248 bytes) of <b>virtual</b> <b>address</b> space. The architecture definition allows this limit to be raised in future implementations to the full 64 bits, extending the <b>virtual</b> <b>address</b> space to 16 EB (264 bytes). This is compared to just 4 GB (232 bytes) for the x86.|$|R
5000|$|If the {{processor}} and operating system support multiple <b>virtual</b> <b>address</b> spaces, the [...] "extra memory" [...] {{can be used}} to run more processes. Paging allows the cumulative total of <b>virtual</b> <b>address</b> spaces to exceed physical main memory.|$|R
50|$|All job {{programs}} run in S/360 problem state, may {{run with}} <b>virtual</b> <b>addressing</b> enabled or disabled, and {{may or may}} not be reentrant (more than one instance of the job program {{may or may not}} be allowed to execute). With multiprocessor configurations a single job will only execute on a single processor at a time, but the supervisor may assign a job to different processors at different times.|$|E
50|$|In the 1990s IBM {{introduced}} 370/ESA architecture (later named 390/ESA {{and finally}} ESA/390 or System/390, in short S/390), completing the evolution to full 31-bit <b>virtual</b> <b>addressing</b> and keeping this addressing mode flag. These later architectures allow more than 2 GiB of physical memory and allow multiple concurrent address spaces up to 2 GiB each in size. As of mid-2006 {{there were too}} many programs unduly constrained by this multiple 31-bit addressing mode.|$|E
50|$|DOS/360 {{originally}} supported 24-bit addressing. As {{the underlying}} hardware evolved, VSE/ESA acquired support for 31-bit addressing. IBM released z/VSE Version 4 in 2007. z/VSE Version 4 requires 64-bit z/Architecture hardware and supports 64-bit real mode addressing. With z/VSE 5.1 (available since 2011) z/VSE introduced 64 bit <b>virtual</b> <b>addressing</b> and memory objects (chunks of virtual storage), that are allocated above 2 GB. The latest shipping release is z/VSE 6.1.0 - available since November 2015, {{which includes the}} new CICS Transaction Server for z/VSE 2.1.|$|E
50|$|An iconic {{example of}} virtual-to-physical <b>address</b> {{translation}} is <b>virtual</b> memory, where different pages of <b>virtual</b> <b>address</b> space map either to page file or to main memory physical address space. It {{is possible that}} several numerically different <b>virtual</b> <b>addresses</b> all refer to one physical address and hence to the same physical byte of RAM. It {{is also possible that}} a single <b>virtual</b> <b>address</b> maps to zero, one, or more than one physical address.|$|R
50|$|MIPS32 and MIPS32r2 support 32 bits of <b>virtual</b> <b>address</b> {{space and}} up to 36 bits of {{physical}} address space. MIPS64 supports up to 64 bits of <b>virtual</b> <b>address</b> space {{and up to}} 59 bits of physical address space.|$|R
50|$|In computing, {{virtual memory}} is a memory {{management}} technique that is implemented using both hardware and software. It maps memory addresses {{used by a}} program, called <b>virtual</b> <b>addresses,</b> into physical addresses in computer memory. Main storage, as seen by a process or task, appears as a contiguous address space or collection of contiguous segments. The operating system manages <b>virtual</b> <b>address</b> spaces and the assignment of real memory to <b>virtual</b> memory. <b>Address</b> translation hardware in the CPU, {{often referred to as}} a memory management unit or MMU, automatically translates <b>virtual</b> <b>addresses</b> to physical addresses. Software within the operating system may extend these capabilities to provide a <b>virtual</b> <b>address</b> space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer.|$|R
50|$|<b>Virtual</b> <b>addressing</b> {{also allows}} {{creation}} of virtual partitions of memory in two disjointed areas, one being {{reserved for the}} kernel (kernel space) {{and the other for}} the applications (user space). The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to the current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g. Singularity) take other approaches.|$|E
50|$|Referencing the {{physical}} memory addresses, a TLB may reside between the CPU and the CPU cache, between the CPU cache and primary storage memory, or between levels of a multi-level cache. The placement determines whether the cache uses physical or <b>virtual</b> <b>addressing.</b> If the cache is virtually addressed, requests are sent {{directly from the}} CPU to the cache, and the TLB is accessed only on a cache miss. If the cache is physically addressed, the CPU does a TLB lookup on every memory operation and the resulting physical address {{is sent to the}} cache.|$|E
5000|$|One {{processor}} sends {{messages to}} the other by writing the message into the pre-determined address and then sending an interrupt to signal the other processor that a new message is available. When transferring data buffers, only a pointer to a given buffer needs to be passed since the buffer resides in shared memory that is accessible to both the processors. ARM buffer addresses must be translated into physical addresses when being presented to the DSP, as the DSP {{does not have an}} MMU or a concept of <b>virtual</b> <b>addressing.</b>|$|E
5000|$|There {{are several}} types of page tables, that are best suited for {{different}} requirements. Essentially, a bare-bones page table must store the <b>virtual</b> <b>address,</b> the physical address that is [...] "under" [...] this <b>virtual</b> <b>address,</b> and possibly some address space information.|$|R
50|$|The {{effective}} <b>virtual</b> <b>address</b> {{of a word}} is 17 bits wide. <b>Virtual</b> <b>addresses</b> 0 thru 15 {{are reserved}} to reference the corresponding general purpose register, and are not mapped. Otherwise, in virtual memory mode the high-order eight bits of an <b>address,</b> called <b>virtual</b> page number, are used as an index to an array of 256 13-bit memory map registers. The thirteen bits from the map register plus the remaining nine bits of the <b>virtual</b> <b>address</b> form the address used to access real memory.|$|R
50|$|OS/VS1 was OS/360 MFT II with {{a single}} <b>virtual</b> <b>address</b> space; by comparison, OS/VS2 SVS was OS/360 MVT {{with a single}} <b>virtual</b> <b>address</b> space. OS/VS1 was often {{installed}} on mid-range IBM mainframe systems, such as the System/370 Model 145 and, later, the System/370 Model 148.|$|R
5000|$|Device {{addressing}} use {{three different}} 'digits' A|PL|GR. The A mean the room, the PL is the Point of Load in the room, and GR is the group. Group join loads in same or different rooms in a logical manner. Not all devices has group addressing. All devices must answer to room broadcast called AMB. All devices must answer to general broadcast called GEN. Physical and <b>Virtual</b> <b>addressing</b> has different limitations:In big houses and buildings, SCS address extension is possible, were different address domains are connected via some bridges. Only {{some kind of}} messages can cross a bridge.Here the values of physical configuration jumpers: ...|$|E
5000|$|BS2000/OSD had {{its roots}} in the Time Sharing Operating System (TSOS) first {{developed}} by RCA for the /46 model of the Spectra/70 series, a computer family of the late 1960s related in its architecture to IBMâ€™s /360 series. It was an early operating systems which used <b>virtual</b> <b>addressing</b> and a segregated address space for the programs of different users.From the outset TSOS also allowed data peripherals to be accessed only via record- or block-oriented file interfaces, thereby preventing the necessity to implement device dependencies in user programs. The same operating system was also sold to Sperry Univac when it bought most of RCA's computer division. Univac's [...] "fork" [...] of TSOS would become VS/9, which used many of the same concepts.|$|E
50|$|On many systems, a program's {{virtual address}} may refer to data {{which is not}} {{currently}} in memory. The layer of indirection provided by <b>virtual</b> <b>addressing</b> allows the operating system to use other data stores, like a hard drive, to store what would otherwise have to remain in main memory (RAM). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) {{and replacing it with}} the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as demand paging.|$|E
5000|$|Granularity: The <b>virtual</b> <b>address</b> {{space is}} broken up into pages. For instance, a 4 GiB <b>virtual</b> <b>address</b> space might be cut up into 1,048,576 pages of 4 KiB size, {{each of which}} can be {{independently}} mapped. There may be multiple page sizes supported; see virtual memory for elaboration.|$|R
2500|$|Starting in August, 1972, the IBM System/370 had {{a similar}} MMU, {{although}} it initially supported only a 24-bit <b>virtual</b> <b>address</b> space rather than the 32-bit <b>virtual</b> <b>address</b> space of the System/360 Model 67. [...] It also stored the accessed and dirty bits outside the page table. [...] In early 1983, the System/370-XA architecture expanded the <b>virtual</b> <b>address</b> space to 31 bits, and in 2000, the 64-bit z/Architecture was introduced, with the address space expanded to 64 bits; those continued to store the accessed and dirty bits outside the page table.|$|R
5000|$|The {{application}} reserves a region, or [...] "window" [...] of <b>virtual</b> <b>address</b> space, and allocates {{one or more}} {{regions of}} physical memory. Using the AWE API, the application can map the virtual window {{to any one of}} the physical regions. The application can reserve more than one <b>virtual</b> <b>address</b> space and map it to any of the allocated regions of physical memory, as long as the number of bytes reserved in the <b>virtual</b> <b>address</b> space matches that of the physical memory region. An application must have the Lock Pages in Memory privilege to use AWE.|$|R
