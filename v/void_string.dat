0|36|Public
5000|$|... public <b>void</b> addCommand(final <b>String</b> name, final Command command) { commands.put(name, command); } ...|$|R
5000|$|... public static <b>void</b> main(final <b>String</b> arguments) { Customer firstCustomer = new Customer(new NormalStrategy (...) [...] ); ...|$|R
5000|$|... import evo.ERemote;import evo.annotation.*;import evo.exception.*;@RemoteInterfacepublic {{interface}} Evo extends ERemote { @RemoteMethod public <b>void</b> setValue (<b>String</b> value) throws RemoteException;} ...|$|R
5000|$|An {{example of}} Java {{argument}} parsing would be:public class Echo { public static <b>void</b> main (<b>String</b> args) { for (String s: args) { System.out.println(s); } }} ...|$|R
5000|$|... class Sample : Object { void {{greeting}} (...) { stdout.printf ("Hello World\n"); } [...] static <b>void</b> main (<b>string</b> args) { var sample = new Sample (...) sample.greeting (...) }} ...|$|R
5000|$|... public {{delegate}} <b>void</b> MessageReceivedEventHandler(string message, <b>string</b> from);public class Mediator{ public event MessageReceivedEventHandler MessageReceived; public <b>void</b> Send(string message, <b>string</b> from) { if (MessageReceived != null) { Console.WriteLine("Sending '{0}' from {1}", message, from); MessageReceived(message, from); } }}public class Person{ private Mediator _mediator; public string Name { get; set; } public Person(Mediator mediator, string name) { Name = name; _mediator = mediator; _mediator.MessageReceived += new MessageReceivedEventHandler(Receive); } private <b>void</b> Receive(string message, <b>string</b> from) { if (from != Name) Console.WriteLine("{0} received '{1}' from {2}", Name, message, from); } public void Send(string message) { _mediator.Send(message, Name); }} ...|$|R
2500|$|... static <b>void</b> Permute(string prefix, <b>string</b> suffix, ref int count) ...|$|R
5000|$|... import org.takes.http.Exit;import org.takes.http.FtBasic;import org.takes.facets.fork.TkFork;public final class Hello { public static <b>void</b> main(final <b>String...</b> args) throws Exception { new FtBasic( [...] new TkFork(new FkRegex("/", [...] "hello, world!")), 8080 [...] ).start(Exit.NEVER); }} ...|$|R
2500|$|... bits, bool, bytes, char, compl, int, real, sema, <b>string,</b> <b>void,</b> ...|$|R
5000|$|... // Hello.java (Java SE 5)import javax.swing.*;public class Hello extends JFrame { public Hello (...) { super("hello"); super.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); super.add(new JLabel("Hello, world!")); super.pack (...) super.setVisible(true); } public static <b>void</b> main(final <b>String</b> args) { new Hello (...) }} ...|$|R
5000|$|... /* The test {{class or}} client */public class PressSwitch { public static <b>void</b> main(final <b>String</b> {{arguments}}){ // Check number of arguments if (arguments.length != 1) { System.err.println("Argument \"ON\" [...] or \"OFF\" [...] is required."); System.exit(-1); } ...|$|R
5000|$|... // Fixed-head solutionstatic <b>void</b> Permute(string prefix, <b>string</b> suffix, ref int count){ if (suffix.Length == 0) { ++count; ...|$|R
5000|$|... import evo.RemoteObject;import evo.exception.RemoteException;public class EvoImpl extends RemoteObject {{implements}} Evo { private String value = [...] "sample"; [...] public EvoImpl (...) {} public EvoImpl (Properties env) throws RemoteException { super (env); } public <b>void</b> setValue (<b>String</b> value) throws RemoteException { this.value = value; }} ...|$|R
5000|$|... // Set a file as an attachment. Uses JAF FileDataSource. public static <b>void</b> setFileAsAttachment(Message msg, <b>String</b> filename) throws MessagingException { ...|$|R
5000|$|... class StateContext { private Statelike myState; StateContext (...) { setState(new StateLowerCase (...) [...] ); } /** * Setter {{method for}} the state. * Normally only called by classes {{implementing}} the State interface. * @param newState {{the new state}} of this context */ void setState(final Statelike newState) { myState = newState; } public <b>void</b> writeName(final <b>String</b> name) { myState.writeName(this, name); }} ...|$|R
5000|$|... :import player.PersonBean;/** * Class [...] */public class TestPersonBean { /** * Tester method [...] {{for class}} [...] * * @param {{arguments}} */ public static <b>void</b> main(final <b>String</b> arguments) { final PersonBean person = new PersonBean (...) person.setName("Bob"); person.setDeceased(false); person.setList(new ArrayList (...) [...] ); // Output: [...] "Bob alive" [...] System.out.print(person.getName (...) [...] ); System.out.println(person.isDeceased (...) ? [...] " [...] deceased" [...] : [...] " [...] alive"); }} ...|$|R
5000|$|As an example, an {{implementation}} of a simple distributed hashtable over Cassandra is listed. /** * Insert a new value keyed by key * @param key Key for the value * @param value the String value to insert */ public <b>void</b> insert(final <b>String</b> key, final String value) throws Exception { execute(new Command (...) { public Void execute(final Keyspace ks) throws Exception { ks.insert(key, createColumnPath(COLUMN_NAME), bytes(value)); return null; } }); } /** * Get a string value. * @return The string value; null if no value exists for the given key. */ public String get(final String key) throws Exception { return execute(new Command (...) { public String execute(final Keyspace ks) throws Exception { try { return string(ks.getColumn(key, createColumnPath(COLUMN_NAME)).getValue (...) [...] ); } catch (NotFoundException e) { return null; } } }); } /** * Delete a key from cassandra */ public <b>void</b> delete(final <b>String</b> key) throws Exception { execute(new Command (...) { public Void execute(final Keyspace ks) throws Exception { ks.remove(key, createColumnPath(COLUMN_NAME)); return null; } }); } ...|$|R
5000|$|... import javax.media.*;import java.io.File;import java.awt.*;public class TrivialJMFPlayer extends Frame { public static <b>void</b> main (<b>String</b> args) { try { Frame f = new TrivialJMFPlayer (...) f.pack (...) f.setVisible (true); } catch (Exception e) { e.printStackTrace (...) } } public TrivialJMFPlayer (...) [...] throws java.io.IOException, java.net.MalformedURLException, javax.media.MediaException { FileDialog fd = new FileDialog (this, [...] "TrivialJMFPlayer", FileDialog.LOAD); fd.setVisible(true); File f = new File(fd.getDirectory (...) , fd.getFile (...) [...] ); Player p = Manager.createRealizedPlayer (f.toURI (...) [...]toURL (...) [...] ); Component c = p.getVisualComponent (...) add(c); p.start (...) }} ...|$|R
5000|$|... /** * Represents {{the product}} {{created by the}} builder. */class Car { private int wheels; private String color; public Car (...) { } public String getColor (...) { return color; } public <b>void</b> setColor(final <b>String</b> color) { this.color = color; } public int getWheels (...) { return wheels; } public void setWheels(final int wheels) { this.wheels = wheels; } @Override public String toString (...) { return [...] "Car = [...] " [...] + wheels + [...] ", color = [...] " [...] + color + [...] ""; }}/** * The builder abstraction. */interface CarBuilder { Car build (...) CarBuilder setColor(final String color); CarBuilder setWheels(final int wheels);}class CarBuilderImpl {{implements}} CarBuilder { private Car car; public CarBuilderImpl (...) { car = new Car (...) } @Override public Car build (...) { return car; } @Override public CarBuilder setColor(final String color) { car.setColor(color); return this; } @Override public CarBuilder setWheels(final int wheels) { car.setWheels(wheels); return this; }}public class CarBuildDirector { private CarBuilder builder; public CarBuildDirector(final CarBuilder builder) { this.builder = builder; } public Car construct (...) { return builder.setWheels(4) [...]setColor("Red") [...]build (...) } public static <b>void</b> main(final <b>String</b> arguments) { final CarBuilder builder = new CarBuilderImpl (...) final CarBuildDirector carBuildDirector = new CarBuildDirector(builder); System.out.println(carBuildDirector.construct (...) [...] ); }} ...|$|R
5000|$|... import java.io.File;import java.awt.*;import quicktime.*;import quicktime.std.movies.Movie;import quicktime.app.view.QTFactory;import quicktime.io.*;public class TrivialQTJPlayer extends Frame { public static <b>void</b> main (<b>String</b> args) { try { QTSession.open (...) Frame f = new TrivialQTJPlayer (...) f.pack (...) f.setVisible (true); } catch (Exception e) { e.printStackTrace (...) } } public TrivialQTJPlayer (...) [...] throws QTException { FileDialog fd = new FileDialog (this, [...] "TrivialJMFPlayer", FileDialog.LOAD); fd.setVisible(true); File f = new File (fd.getDirectory (...) , fd.getFile (...) [...] ); OpenMovieFile omf = OpenMovieFile.asRead (new QTFile (f)); Movie m = Movie.fromFile (omf); Component c = QTFactory.makeQTComponent(m).asComponent (...) add (c); m.start (...) }} ...|$|R
5000|$|... {{delegate}} <b>void</b> Notifier (<b>string</b> sender);class Model { public event Notifier notifyViews; public void Change (...) { ... notifyViews("Model"); }}class View1 { public View1(Model m) { m.notifyViews += new Notifier(this.Update1); } void Update1(string sender) { Console.WriteLine(sender + [...] " [...] {{was changed}} during update"); [...] }}class View2 { public View2(Model m) { m.notifyViews += new Notifier(this.Update2); [...] } void Update2(string sender) { Console.WriteLine(sender + [...] " [...] was changed"); [...] }}class Test { static void Main (...) { Model model = new Model (...) new View1(model); new View2(model); model.Change (...) }} ...|$|R
5000|$|The {{following}} is a basic Hello World program using SWT. It shows a window (Shell) and a label.import org.eclipse.swt.*;import org.eclipse.swt.widgets.*;public class HelloWorld { public static <b>void</b> main (<b>String</b> args) [...] { Display display = new Display (...) Shell shell = new Shell(display); Label label = new Label(shell, SWT.NONE); label.setText("Hello World"); label.pack (...) shell.pack (...) shell.open (...) while (!shell.isDisposed (...) [...] ) [...] { if (!display.readAndDispatch (...) [...] ) display.sleep (...) } display.dispose (...) }}Contrary to Swing, a Display class is necessary to access the underlying operating system, and its resources must be explicitly disposed of when {{they are no longer}} used.|$|R
5000|$|... package org.examples;import java.io.IOException;public class HelloApplication { public static {{interface}} Greeter { String getGreeting(String subject); String getIntroduction(String actor); } [...] public static class HelloGreeter implements Greeter { private String hello; private String segmenter; [...] public HelloGreeter(String hello, String segmenter) { this.hello = hello; this.segmenter = segmenter; } public String getGreeting(String subject) { return hello + [...] " [...] " [...] + subject; [...] } public String getIntroduction(String actor) { return actor+segmenter; } } [...] public static interface HelloActable { <b>void</b> sayHello(String actor, <b>String</b> subject) throws IOException; } [...] public static class HelloAction implements HelloActable { private Greeter helloGreeter; private Appendable helloWriter; public HelloAction(Greeter helloGreeter, Appendable helloWriter) { super (...) this.helloGreeter = helloGreeter; this.helloWriter = helloWriter; } public <b>void</b> sayHello(String actor, <b>String</b> subject) throws IOException { [...] helloWriter.append(helloGreeter.getIntroduction(actor)).append(helloGreeter.getGreeting(subject)); } } public static void main(String... args) throws IOException { new HelloAction(new HelloGreeter("hello", [...] ": [...] "), System.out).sayHello("application", [...] "world"); }} ...|$|R
5000|$|... public static void main(String args) { String firstName = args0; String lastName = args1; Integer age = new Integer(args2); String gender = args3; String {{occupation}} = args4; String city = args5; welcomeNew(firstName,lastName,age,gender,occupation,city);}public static <b>void</b> welcomeNew(String firstName, <b>String</b> lastName, Integer age, String gender, String occupation, String city){ System.out.printf("Welcome %s %s, a %d-year-old %s from %s {{who works}} as a%s\n",firstName, lastName, age, gender, city, occupation);} ...|$|R
5000|$|... import java.io.*;public class FileSystem { public static <b>void</b> main (<b>String</b> [...] args) { {{traverse}} (...) } /** * Obtains the filesystem roots * Proceeds {{with the}} recursive filesystem traversal */ private static void traverse (...) { File [...] fs = File.listRoots (...) for (int i = 0; i < fs.length; i++) { if (fsi.isDirectory (...) && fsi.canRead (...) [...] ) { rtraverse (fsi); } } } /** * Recursively traverse a given directory * * @param fd indicates {{the starting point}} of traversal */ private static void rtraverse (File fd) { File [...] fss = fd.listFiles (...) for (int i = 0; i < fss.length; i++) { System.out.println (fssi); if (fssi.isDirectory (...) && fssi.canRead (...) [...] ) { rtraverse (fssi); } } }} ...|$|R
5000|$|... {{interface}} Statelike { <b>void</b> writeName(StateContext context, <b>String</b> name);}class StateLowerCase implements Statelike { @Override public void writeName(final StateContext context, final String name) { System.out.println(name.toLowerCase (...) [...] ); context.setState(new StateMultipleUpperCase (...) [...] ); }}class StateMultipleUpperCase implements Statelike { /** Counter local to {{this state}} */ private int count = 0; @Override public void writeName(final StateContext context, final String name) { System.out.println(name.toUpperCase (...) [...] ); /* Change state after StateMultipleUpperCase's writeName (...) gets invoked twice */ if(++count > 1) { context.setState(new StateLowerCase (...) [...] ); } }} ...|$|R
5000|$|... package player;public class PersonBean {{implements}} java.io.Serializable { /** Properties **/ private boolean deceased = false; private List list; /** Property [...] (note capitalization) readable/writable. */ private String name = null; /** No-arg constructor (takes no arguments). */ public PersonBean (...) { } public List getList (...) { return list; } [...] public void setList(final List list) { this.list = list; } /** * Getter {{for property}} [...] */ public String getName (...) { return name; } /** * Setter for property [...] * * @param value */ public <b>void</b> setName(final <b>String</b> value) { this.name = value; } /** * Getter for property [...] "deceased" [...] * Different syntax for a boolean field (is v.s. get) */ public boolean isDeceased (...) { return deceased; } /** * Setter for property [...] * @param value */ public void setDeceased(final boolean value) { deceased = value; }} ...|$|R
5000|$|... module demo; /* This {{behavior}} simply sends two print(...) {{messages to}} the standardOutput actor.*/behavior HelloWorld { /* The act(...) message handler is invoked by stand-alone theaters automatically and is used to bootstrap salsa programs. */ <b>void</b> act( [...] <b>String</b> argv [...] ) { standardOutput<-print( [...] "Hello" [...] ) @ standardOutput<-print( [...] "World!" [...] ); } /* Notice that the above code is different from standardOutput<-print( [...] "Hello" [...] ); standardOutput<-print( [...] "World!" [...] ); the code above uses a continuation {{to insure that the}} world message is sent after the hello message completes processing. */} ...|$|R
5000|$|The {{following}} is a rather simple JavaFX-based program. It displays a window (a [...] ) containing a button.package javafxtuts; import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.StackPane;import javafx.stage.Stage;public class Javafxtuts extends Application { [...] @Override public void start(final Stage primaryStage) { // Creating the Java button final Button button = new Button (...) // Setting text to button button.setText("Hello World"); // Registering a handler for button button.setOnAction((ActionEvent event) -> { // Printing Hello World! to the console System.out.println("Hello World!"); }); // Initializing the StackPane class final StackPane root = new StackPane (...) // Adding all the nodes to the FlowPane root.getChildren (...) [...]add(button); // Creating a scene object final Scene scene = new Scene(root, 300, 250); // Adding the title to the window (primaryStage) primaryStage.setTitle("Hello World!"); primaryStage.setScene(scene); // Show the window(primaryStage) primaryStage.show (...) } [...] /** * Main function that opens the [...] "Hello World!" [...] window * [...] * @param args the command line arguments */ public static <b>void</b> main(final <b>String</b> arguments) { launch(arguments); }} ...|$|R
5000|$|... {{interface}} Image { public void displayImage (...)}// On System Aclass RealImage implements Image { private String filename = null; /** * Constructor * @param filename */ public RealImage(final String filename) { this.filename = filename; loadImageFromDisk (...) } /** * Loads {{the image}} from the disk */ private void loadImageFromDisk (...) { System.out.println("Loading [...] " [...] + filename); } /** * Displays the image */ public void displayImage (...) { System.out.println("Displaying [...] " [...] + filename); }}// On System Bclass ProxyImage implements Image { private RealImage image = null; private String filename = null; /** * Constructor * @param filename */ public ProxyImage(final String filename) { this.filename = filename; } /** * Displays the image */ public void displayImage (...) { if (image == null) { image = new RealImage(filename); } image.displayImage (...) }}class ProxyExample { /** * Test method */ public static <b>void</b> main(final <b>String</b> arguments) { final Image image1 = new ProxyImage("HiRes_10MB_Photo1"); final Image image2 = new ProxyImage("HiRes_10MB_Photo2"); image1.displayImage (...) // loading necessary image1.displayImage (...) // loading unnecessary image2.displayImage (...) // loading necessary image2.displayImage (...) // loading unnecessary image1.displayImage (...) // loading unnecessary }} ...|$|R
5000|$|... /* Encapsulated {{family of}} Algorithms * Interface and its {{implementations}} */public interface IBrakeBehavior { public void brake (...)}public class BrakeWithABS implements IBrakeBehavior { public void brake (...) { System.out.println("Brake with ABS applied"); }}public class Brake implements IBrakeBehavior { public void brake (...) { System.out.println("Simple Brake applied"); }}/* Client that {{can use the}} algorithms above interchangeably */public abstract class Car { protected IBrakeBehavior brakeBehavior; public void applyBrake (...) { brakeBehavior.brake (...) } public void setBrakeBehavior(final IBrakeBehavior brakeType) { this.brakeBehavior = brakeType; }}/* Client 1 uses one algorithm (Brake) in the constructor */public class Sedan extends Car { public Sedan (...) { this.brakeBehavior = new Brake (...) }}/* Client 2 uses another algorithm (BrakeWithABS) in the constructor */public class SUV extends Car { public SUV (...) { this.brakeBehavior = new BrakeWithABS (...) }}/* Using the Car example */public class CarExample { public static <b>void</b> main(final <b>String</b> arguments) { Car sedanCar = new Sedan (...) sedanCar.applyBrake (...) // This will invoke class [...] "Brake" [...] Car suvCar = new SUV (...) suvCar.applyBrake (...) // This will invoke class [...] "BrakeWithABS" [...] // set brake behavior dynamically suvCar.setBrakeBehavior( [...] new Brake (...) [...] ); suvCar.applyBrake (...) // This will invoke class [...] "Brake" [...] }} ...|$|R
5000|$|... public class Chat extends ReceiverAdapter { JChannel channel; public void viewAccepted(View new_view) { System.out.println("** view: [...] " [...] + new_view); } public void receive(Message msg) { System.out.printf("from %s: %s\n", msg.getSource (...) , msg.getObject (...) [...] ); } private <b>void</b> start(String props, <b>String</b> name) throws Exception { channel=new JChannel(props).setName(name) [...]setReceiver(this).connect("ChatCluster"); eventLoop (...) channel.close (...) } private void eventLoop (...) { BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); while(true) { try { System.out.print("> [...] "); System.out.flush (...) String line=in.readLine (...) [...]toLowerCase (...) Message msg=new Message(null, line); channel.send(msg); } catch(Exception e) { } } } public static void main(String args) throws Exception { String props="udp.xml"; String name=null; for(int i=0; i < args.length; i++) { if(argsi.equals("-props")) { props=args++i; continue; } if(argsi.equals("-name")) { name=args++i; continue; } System.out.println("Chat XML config name"); return; } new Chat (...) [...]start(props, name); }} ...|$|R
40|$|When a {{function}} receives an argument, it performs {{one of two}} actions {{with regards to the}} value of the argument; it might modify the value itself or only use the argument to modify another argument or another of its own variables. If you know that the function is not supposed to alter the value of an argument, you should let the compiler know. This is a safeguard that serves at least two purposes. First, the compiler will make sure that the argument supplied stays intact; if the function tries to modify the argument, the compiler would throw an error, letting you know that an undesired operation took place. Second, this speeds up execution. To let the compiler know that the value of an argument must stay constant, use the const keyword before the data type of the argument. For example, if you declare {{a function}} like <b>void</b> Area(const <b>string</b> Side), the Area() is not supposed to modify the value of the Side argument. Consider a function that is supposed to calculate and return the perimeter of a rectangle if it receives the length and the width from another function, namely main(). Here is a program that would satisfy the operation (notice the Perimeter() function that takes two arguments) : #include #pragma hdrstop #pragma argsuse...|$|R
5000|$|... /** [...] "Implementor" [...] */interface DrawingAPI { public void drawCircle(final double x, final double y, final double radius);}/** [...] "ConcreteImplementor" [...] 1/2 */class DrawingAPI1 {{implements}} DrawingAPI { public void drawCircle(final double x, final double y, final double radius) { System.out.printf("API1.circle at %f:%f radius %f\n", x, y, radius); }}/** [...] "ConcreteImplementor" [...] 2/2 */class DrawingAPI2 implements DrawingAPI { public void drawCircle(final double x, final double y, final double radius) { System.out.printf("API2.circle at %f:%f radius %f\n", x, y, radius); }}/** [...] "Abstraction" [...] */abstract class Shape { protected DrawingAPI drawingAPI; protected Shape(final DrawingAPI drawingAPI){ this.drawingAPI = drawingAPI; } public abstract void draw (...) // low-level public abstract void resizeByPercentage(final double pct); // high-level}/** [...] "Refined Abstraction" [...] */class CircleShape extends Shape { private double x, y, radius; public CircleShape(final double x, final double y, final double radius, final DrawingAPI drawingAPI) { super(drawingAPI); this.x = x; this.y = y; this.radius = radius; } // low-level i.e. Implementation specific public void draw (...) { drawingAPI.drawCircle(x, y, radius); } // high-level i.e. Abstraction specific public void resizeByPercentage(final double pct) { radius *= (1.0 + pct/100.0); }}/** [...] "Client" [...] */class BridgePattern { public static <b>void</b> main(final <b>String</b> args) { Shape shapes = new Shape { new CircleShape(1, 2, 3, new DrawingAPI1 (...) [...] ), new CircleShape(5, 7, 11, new DrawingAPI2 (...) [...] ) }; for (Shape shape : shapes) { shape.resizeByPercentage(2.5); shape.draw (...) } }} ...|$|R
5000|$|... mode, op, prio, proc, flex, heap, loc, long, ref, short, bits, bool, bytes, char, compl, int, real, sema, <b>string,</b> <b>void,</b> channel, file, format, struct, union, at [...] "@", eitherr0, is [...] ":=:", isnt is notr0 [...] ":/=:" [...] ":≠:", of [...] "→"r0, true, false, empty, nil [...] "○", skip [...] "~", co [...] "¢", comment [...] "¢", pr, pragmat, case ~ in ~ ouse ~ in ~ out ~ esac [...] "( [...] ~ | ~ |: ~ | ~ | ~ [...] )", for ~ from ~ to ~ by ~ while ~ do ~ od, if ~ then ~ elif ~ then ~ else ~ fi [...] "( [...] ~ | ~ |: ~ | ~ | ~ [...] )", par begin ~ end [...] "( [...] ~ [...] )", go to, goto, exit [...] "."r0.|$|R
5000|$|... {{interface}} CarElement { void accept(CarElementVisitor visitor);}interface CarElementVisitor { void visit(Body body); void visit(Car car); void visit(Engine engine); void visit(Wheel wheel);}class Body implements CarElement { public void accept(final CarElementVisitor visitor) { visitor.visit(this); }}class Car implements CarElement { CarElement elements; public Car (...) { this.elements = new CarElement { [...] new Wheel("front left"), new Wheel("front right"), new Wheel("back left"), new Wheel("back right"), new Body (...) , new Engine (...) }; } public void accept(final CarElementVisitor visitor) { for (CarElement elem : elements) { elem.accept(visitor); } visitor.visit(this); }}class Engine implements CarElement { public void accept(final CarElementVisitor visitor) { visitor.visit(this); }}class Wheel implements CarElement { private String name; public Wheel(final String name) { this.name = name; } public String getName (...) { return name; } public void accept(final CarElementVisitor visitor) { /* * accept(CarElementVisitor) in Wheel implements * accept(CarElementVisitor) in CarElement, so {{the call}} * to accept is bound at run time. This {{can be considered}} * the *first* dispatch. However, the decision to call * visit(Wheel) (as opposed to visit(Engine) etc.) can be * made during compile time since 'this' is known at compile * {{time to be a}} Wheel. Moreover, each implementation of * CarElementVisitor implements the visit(Wheel), which is * another decision that is made at run time. This can be * considered the *second* dispatch. */ visitor.visit(this); }}class CarElementDoVisitor implements CarElementVisitor { public void visit(final Body body) { System.out.println("Moving my body"); } public void visit(final Car car) { System.out.println("Starting my car"); } public void visit(final Wheel wheel) { System.out.println("Kicking my [...] " [...] + wheel.getName (...) + [...] " [...] wheel"); } public void visit(final Engine engine) { System.out.println("Starting my engine"); }}class CarElementPrintVisitor implements CarElementVisitor { public void visit(final Body body) { System.out.println("Visiting body"); } public void visit(final Car car) { System.out.println("Visiting car"); } public void visit(final Engine engine) { System.out.println("Visiting engine"); } public void visit(final Wheel wheel) { System.out.println("Visiting [...] " [...] + wheel.getName (...) + [...] " [...] wheel"); }}public class VisitorDemo { public static <b>void</b> main(final <b>String</b> args) { final Car car = new Car (...) [...] car.accept(new CarElementPrintVisitor (...) [...] ); car.accept(new CarElementDoVisitor (...) [...] ); }} ...|$|R
