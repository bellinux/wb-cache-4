322|244|Public
25|$|Lambda {{calculus}} (also {{written as}} λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using <b>variable</b> <b>binding</b> and substitution. It {{is a universal}} model of computation {{that can be used}} to simulate any Turing machine and was first introduced by mathematician Alonzo Church in the 1930s as part of his research of the foundations of mathematics.|$|E
2500|$|Scheme is a {{very simple}} language, much easier to {{implement}} than many other languages of comparable expressive power. [...] This ease is attributable {{to the use of}} lambda calculus to derive much of the syntax of the language from more primitive forms. [...] For instance of the 23 s-expression-based syntactic constructs defined in the R5RS Scheme standard, 11 are classed as derived or library forms, which can be written as macros involving more fundamental forms, principally lambda. [...] As R5RS says (R5RS sec. 3.1): [...] "The most fundamental of the <b>variable</b> <b>binding</b> constructs is the lambda expression, because all other <b>variable</b> <b>binding</b> constructs can be explained in terms of lambda expressions." ...|$|E
2500|$|An {{alternate}} {{approach to}} the semantics of first-order logic proceeds via abstract algebra. This approach generalizes the [...] Lindenbaum–Tarski algebras of propositional logic. [...] There are three ways of eliminating quantified variables from first-order logic that do not involve replacing quantifiers with other <b>variable</b> <b>binding</b> term operators: ...|$|E
5000|$|In {{programming}} languages {{that have}} non-hygienic macro systems, {{it is possible}} for existing <b>variable</b> <b>bindings</b> to be hidden from a macro by <b>variable</b> <b>bindings</b> that are created during its expansion. In C, this problem can be illustrated by the following fragment: ...|$|R
5000|$|The {{trail to}} record which <b>variables</b> <b>bindings</b> {{ought to be}} undone on {{backtracking}} ...|$|R
5000|$|The [...] "hygiene problem" [...] {{can extend}} beyond <b>variable</b> <b>bindings.</b> Consider this Common Lisp macro: ...|$|R
5000|$|MEchanized Reasoning about Languages with <b>varIable</b> <b>biNding</b> (MERLIN) ...|$|E
50|$|<b>Variable</b> <b>binding</b> relates three things: a {{variable}} v, a location a for that variable in an expression and a non-leaf node n {{of the form}} Q(v, P). Note: we define a location in an expression as a leaf node in the syntax tree. <b>Variable</b> <b>binding</b> occurs when that location is below the node n.|$|E
5000|$|The formal {{semantics}} of such atoms {{is defined}} given a database db over S and a tuple <b>variable</b> <b>binding</b> val : V → TD that maps tuple variables to tuples over the domain in S: ...|$|E
25|$|Example: a macro to {{implement}} let {{as an expression}} using lambda to perform the <b>variable</b> <b>bindings.</b>|$|R
3000|$|The set {{of matches}} for Q over RDF graph G is denoted as [...] Q [...] _G, based on which, we return <b>variable</b> <b>bindings</b> that are {{defined in the}} SELECT clause.|$|R
50|$|Languages {{generated}} by LMGs contain the context-free languages as a proper subset, as every CFG is an LMG where all predicates have arity 0 and no production rule contains <b>variable</b> <b>bindings</b> or slash deletions.|$|R
5000|$|... the {{location}} of a reference within an expression. If it's the leftmost position of a compound, it refers to a special operator or a macro or function binding, otherwise to a <b>variable</b> <b>binding</b> or something else.|$|E
5000|$|Scheme is a {{very simple}} language, much easier to {{implement}} than many other languages of comparable expressive power. [...] This ease is attributable {{to the use of}} lambda calculus to derive much of the syntax of the language from more primitive forms. For instance of the 23 s-expression-based syntactic constructs defined in the R5RS Scheme standard, 11 are classed as derived or library forms, which can be written as macros involving more fundamental forms, principally lambda. As R5RS says (R5RS sec. 3.1): [...] "The most fundamental of the <b>variable</b> <b>binding</b> constructs is the lambda expression, because all other <b>variable</b> <b>binding</b> constructs can be explained in terms of lambda expressions." ...|$|E
5000|$|An {{alternate}} {{approach to}} the semantics of first-order logic proceeds via abstract algebra. This approach generalizes the Lindenbaum-Tarski algebras of propositional logic. There are three ways of eliminating quantified variables from first-order logic that do not involve replacing quantifiers with other <b>variable</b> <b>binding</b> term operators: ...|$|E
50|$|Note that in {{both cases}} the {{function}} implicitly takes a single argument called x - in general it is possible to use up to three implicit arguments, named x, y and z, or to give arguments local <b>variable</b> <b>bindings</b> explicitly.|$|R
2500|$|Execution of a Prolog {{program is}} {{initiated}} by the user's posting of a single goal, called the query. Logically, the Prolog engine tries to find a resolution refutation of the negated query. The resolution method used by Prolog is called SLD resolution. If the negated query can be refuted, {{it follows that the}} query, with the appropriate <b>variable</b> <b>bindings</b> in place, is a logical consequence of the program. In that case, all generated <b>variable</b> <b>bindings</b> are reported to the user, and the query is said to have succeeded. Operationally, Prolog's execution strategy {{can be thought of as}} a generalization of function calls in other languages, one difference being that multiple clause heads can match a given call. In that case, the system creates a choice-point, unifies the goal with the clause head of the first alternative, and continues with the goals of that first alternative. If any goal fails in the course of executing the program, all <b>variable</b> <b>bindings</b> that were made since the most recent choice-point was created are undone, and execution continues with the next alternative of that choice-point. This execution strategy is called chronological backtracking. For example: ...|$|R
5000|$|Response: Returns <b>variable</b> <b>bindings</b> and {{acknowledgement}} from {{agent to}} manager for GetRequest, SetRequest, GetNextRequest, GetBulkRequest and InformRequest. Error reporting {{is provided by}} error-status and error-index fields. Although it {{was used as a}} response to both gets and sets, this PDU was called GetResponse in SNMPv1.|$|R
5000|$|We {{will assume}} that the quantifiers {{quantify}} over the universe of all tuples over the domain in the schema. This leads to the following formal semantics for formulas given a database db over S and a tuple <b>variable</b> <b>binding</b> val : V -> TD: ...|$|E
5000|$|GetBulkRequest: Optimized {{version of}} GetNextRequest. A manager-to-agent request for {{multiple}} iterations of GetNextRequest. Returns a Response with multiple variable bindings {{walked from the}} <b>variable</b> <b>binding</b> or bindings in the request. PDU specific non-repeaters and max-repetitions fields are used to control response behavior. GetBulkRequest was introduced in SNMPv2.|$|E
5000|$|In this manner, {{function}} definition {{expressions of}} the kind shown above {{can be thought of}} as the <b>variable</b> <b>binding</b> operator, analogous to the lambda expressions of lambda calculus. Other binding operators, like the summation sign, {{can be thought of as}} higher-order functions applying to a function. So, for example, the expression ...|$|E
50|$|Execution of a Prolog {{program is}} {{initiated}} by the user's posting of a single goal, called the query. Logically, the Prolog engine tries to find a resolution refutation of the negated query. The resolution method used by Prolog is called SLD resolution. If the negated query can be refuted, {{it follows that the}} query, with the appropriate <b>variable</b> <b>bindings</b> in place, is a logical consequence of the program. In that case, all generated <b>variable</b> <b>bindings</b> are reported to the user, and the query is said to have succeeded. Operationally, Prolog's execution strategy {{can be thought of as}} a generalization of function calls in other languages, one difference being that multiple clause heads can match a given call. In that case, the system creates a choice-point, unifies the goal with the clause head of the first alternative, and continues with the goals of that first alternative. If any goal fails in the course of executing the program, all <b>variable</b> <b>bindings</b> that were made since the most recent choice-point was created are undone, and execution continues with the next alternative of that choice-point. This execution strategy is called chronological backtracking. For example:mother_child(trude, sally). father_child(tom, sally).father_child(tom, erica).father_child(mike, tom). sibling(X, Y) :- parent_child(Z, X), parent_child(Z, Y). parent_child(X, Y) :- father_child(X, Y).parent_child(X, Y) :- mother_child(X, Y).|$|R
2500|$|In Scheme, {{procedures}} {{are bound to}} variables. [...] At R5RS the language standard formally mandated that programs may change the <b>variable</b> <b>bindings</b> of built-in procedures, effectively redefining them. (R5RS [...] "Language changes") [...] For example, one may extend + to accept strings as well as numbers by redefining it: ...|$|R
5000|$|GetRequest: A manager-to-agent {{request to}} {{retrieve}} {{the value of a}} variable or list of variables. Desired variables are specified in <b>variable</b> <b>bindings</b> (values are not used). Retrieval of the specified variable values is to be done as an atomic operation by the agent. A Response with current values is returned.|$|R
50|$|Literal {{movement}} grammars (LMGs) are a grammar formalism {{introduced by}} Groenink in 1995 intended to characterize certain extraposition phenomena of natural language such as topicalization and cross-serial dependencies. LMGs extend {{the class of}} CFGs by adding introducing pattern-matched function-like rewrite semantics, {{as well as the}} operations of <b>variable</b> <b>binding</b> and slash deletion.|$|E
5000|$|GetNextRequest: A manager-to-agent {{request to}} {{discover}} available variables and their values. Returns a Response with <b>variable</b> <b>binding</b> for the lexicographically next {{variable in the}} MIB. The entire MIB of an agent can be walked by iterative application of GetNextRequest starting at OID 0. Rows of a table can be read by specifying column OIDs in the variable bindings of the request.|$|E
50|$|Lambda {{calculus}} (also {{written as}} λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using <b>variable</b> <b>binding</b> and substitution. It {{is a universal}} model of computation {{that can be used}} to simulate any single-taped Turing machine and was first introduced by mathematician Alonzo Church in the 1930s as part of his research of the foundations of mathematics.|$|E
40|$|Abstract. In {{order to}} cope with the {{ever-increasing}} data volume continuous processing of incoming data via Semantic Flow Processing systems have been proposed. These systems allow to answer queries on streams of RDF triples. To achieve this goal they match (triple) patterns against the incoming stream and generate/update <b>variable</b> <b>bindings.</b> Yet, given the continuous nature of the stream the number of bindings can explode and exceed memory; in particular when computing aggregates. To make the information processing practical Semantic Flow Processing systems, therefore, typically limit the considered data to a (moving) window. Whilst this technique is simple it {{may not be able to}} find patterns spread further than the window or may still cause memory overruns when data is highly bursty. In this paper we propose to maintain bindings (and thus memory) not on recency (i. e., a window) but on the likelihood of contributing to a complete match. We propose to base the decision on the matching likelihood and not creation time (fifo) or at random. Furthermore we propose to drop <b>variable</b> <b>bindings</b> instead of data as do load shedding approaches. Specifically, we systematically investigate deterministic and the matching-likelihood based probabilistic eviction strategy for dropping <b>variable</b> <b>bindings</b> in terms of recall. We find that a matching likelihood based eviction can outperform fifo and random eviction strategies on synthetic as well as real world data...|$|R
5000|$|SetRequest: A manager-to-agent {{request to}} change {{the value of a}} {{variable}} or list of <b>variables.</b> <b>Variable</b> <b>bindings</b> are specified {{in the body of the}} request. Changes to all specified variables are to be made as an atomic operation by the agent. A Response with (current) new values for the variables is returned.|$|R
40|$|An {{example of}} sending two {{messages}} {{in an e-mail}} program reveals a fundamental sequence-construction mechanism by which perceptual categories and motor schema are automatically generalized. By this mechanism, the human brain accomplishes more flexibly what {{we take for granted}} in stored-program computers-ordered steps (a sequence of operators in a problem space), <b>variable</b> <b>bindings,</b> conditional statements, and subgoaling...|$|R
5000|$|Let σx φ(x) {{denote the}} mereological sum (fusion) of all {{individuals}} in the domain satisfying φ(x). σ is a <b>variable</b> <b>binding</b> prefix operator. The axioms of GEM assure that this sum exists if φ(x) is a first-order formula. With σ and the relation IP in hand, we can define the interior of x, [...] as the mereological sum of all interior parts z of x, or: ...|$|E
50|$|Local {{function}} bindings in Lisp have lexical scope, {{and variable}} bindings also have lexical scope by default. By contrast with GO labels, {{both of these}} have indefinite extent. When a lexical function or <b>variable</b> <b>binding</b> is established, that binding continues to exist {{for as long as}} references to it are possible, even after the construct which established that binding has terminated. References to lexical variables and functions after the termination of their establishing construct are possible thanks to lexical closures.|$|E
5000|$|As for {{the second}} meaning, {{incorporating}} elements of symbolic computation and artificial neural networks into one model {{was an attempt to}} combine the advantages of both paradigms while avoid the shortcomings. Symbolic representations have advantages with respect to explicit, direct control, fast initial coding, dynamic <b>variable</b> <b>binding</b> and knowledge abstraction. Representations of artificial neural networks, on the other hand, show advantages for biological plausibility, learning, robustness (fault-tolerant processing and graceful decay), and generalization to similar input. Since the early 1990s many {{attempts have been made to}} reconcile the two approaches.|$|E
50|$|The first logical {{calculus}} {{capable of}} dealing with such inferences was Gottlob Frege's Begriffsschrift (1879), the ancestor of modern predicate logic, which dealt with quantifiers by means of <b>variable</b> <b>bindings.</b> Modestly, Frege did not argue that his logic was more expressive than extant logical calculi, but commentators on Frege's logic regard this {{as one of his}} key achievements.|$|R
40|$|One of the {{problems}} with many partial-order planners is their eager commitment to <b>variable</b> <b>bindings.</b> This is contrary to their control decision in delayedcommitment of operator orderings. In this paper we present an extension to the classical partial-order planners by associating every variable with a finite domain of values. The extended planner applies constraint satisfaction routines to check for the consistency of <b>variable</b> <b>bindings.</b> With the extended planner, we perform a set of experiments to show that it is able {{to reduce the amount of}} backtracking in domains where few variable instantiations can lead to final solutions. We also investigate the frequency of CSP application to determine how often should constraint checking be performed in order to yield the best performance. Introduction Recently, much research effort has been devoted to the study of partial-order planning systems(Barrett & Weld 1992; Chapman 1987). Researchers have studied different methods of imposing ordering [...] ...|$|R
40|$|The {{mechanisms}} {{for the evaluation}} of variables in programming languages (particularly, in applicative or functional languages) are reviewed. The evaluation mechanism with static scoping and dynamic scoping are examined in some details. Next, the techniques of deep binding and shallow binding are presented. They are two techniques for <b>binding</b> <b>variables</b> to their corresponding values in the various environments. Then, the relations among these techniques and the two strategies for determining the scoping of variables are examined. Finally, a proposal is presented on an efficient implementation of <b>variable</b> <b>bindings</b> within the static scoping...|$|R
