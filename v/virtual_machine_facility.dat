5|10000|Public
50|$|VM/370 {{combined}} a <b>virtual</b> <b>machine</b> <b>facility</b> with a single-user {{system called}} Conversational Monitor System (CMS); this combination provided time-sharing by allowing each user {{to run a}} copy of CMS on his / her own virtual machine. This combination was a direct descendant of CP/CMS. The <b>virtual</b> <b>machine</b> <b>facility</b> was often used for testing new software while normal production work continued on another virtual machine, and the CMS timesharing system was widely used for program development.|$|E
50|$|Upon gaining {{virtual memory}} {{capability}} via a microcode update, the 145 could now support the VMF (<b>Virtual</b> <b>Machine</b> <b>Facility)</b> and VM/CMS, a time-sharing system.|$|E
40|$|Design of low-cost, microcomputer-based {{navigation}} receivers, and the assembler are described. The {{development of}} computer software for microprocessors is materially {{aided by the}} assembler program using mnemonic variable names. The flexibility of the environment provided by the IBM's <b>Virtual</b> <b>Machine</b> <b>Facility</b> and the Conversational Monitor System, make possible the convenient assembler access. The implementation of the assembler for the microprocessor chip serves {{a part of the}} present need and forms a model for support of other microprocessors...|$|E
40|$|We {{present the}} design and {{implementation}} {{of a system that}} enables trusted computing for an unlimited number of <b>virtual</b> <b>machines</b> on a single hardware platform. To this end, we virtualized the Trusted Platform Module (TPM). As a result, the TPM’s secure storage and cryptographic functions are available to operating systems and applications running in <b>virtual</b> <b>machines.</b> Our new <b>facility</b> supports higher-level services for establishing trust in virtualized environments, for example remote attestation of software integrity. We implemented the full TPM specification in software and added functions to create and destroy virtual TPM instances. We integrated our software TPM into a hypervisor environment to make TPM functions available to <b>virtual</b> <b>machines.</b> Our <b>virtual</b> TPM supports suspend and resume operations, as well as migration of a virtual TPM instance with its respective <b>virtual</b> <b>machine</b> across platforms. We present four designs for certificate chains to link the virtual TPM to a hardware TPM, with security vs. efficiency trade-offs based on threat models. Finally, we demonstrate a working system by layering an existing integrity measurement application on top of our virtual TPM facility. ...|$|R
40|$|In modern {{on demand}} grid {{computing}} scenarios, services from different organisations will potentially {{run on the}} same web service engine of a grid node. Secure isolation of data and code of different service instances is a vital requirement in such an environment, since mutual trust cannot be assumed between all involved parties. For Java based Grid applications the Java <b>virtual</b> <b>machine</b> offers sandboxing <b>facilities,</b> however the common occurrence of native code (e. g. C/C++, Fortran) in business and scientific Grid applications leads {{to a number of}} security issues which are not handled by the basic Java security mechanisms. In this paper, we analyze the threat scenarios that emanate from native code in a service-oriented Grid scenario. A novel security architecture is presented, which enables a fine grained confinement of native components of Grid applications into a secure environment for protecting the hosting system as well as other service instances. Although our work focuses on Grid services, it is also relevant for any hosting scenario in which multiple web services using native code components are deployed in the same service container. ...|$|R
40|$|TokyoTech <b>Virtual</b> <b>Machine</b> Builder (VMB) is a {{generator}} of <b>virtual</b> <b>machines.</b> VMB takes a formal specification of a <b>virtual</b> <b>machine</b> and generates {{implementation of the}} <b>virtual</b> <b>machine.</b> A specification of a <b>virtual</b> <b>machine</b> comprises configuration of virtual hardware (a set of virtual registers, virtual stacks, and heap organization) and definition of <b>virtual</b> <b>machine</b> instruction set. Behavior of each <b>virtual</b> <b>machine</b> instruction in the instruction set is given in terms of machine state transition system. <b>Virtual</b> <b>machine</b> builder {{has been used to}} generate <b>virtual</b> <b>machines</b> for a couple of programming languages which include ML, Scheme, and a subset of Java. Execution efficiency of the generated <b>virtual</b> <b>machine</b> is nearly the same as a carefully implemented human-crafted <b>virtual</b> <b>machine...</b>|$|R
40|$|The {{design and}} {{operation}} of a microprocessor interface unit which allows use of a computer terminal for communication at 110 or 300 baud both with a central host computer and with the microprocessor monitor are documented. Additionally, the interface permits the host computer to load the microprocessor memory directly with object code, avoiding the use of intermediate data storage such as paper tape. The central computer, containing an assembler language processor for the target microcomputer, can be used from the terminal with all the flexibility offered by the <b>virtual</b> <b>machine</b> <b>facility,</b> producing object code for the micro plus program listings and supporting outputs. The object code can then be loaded directly to the micro and the same terminal device used to run the micro program, communicating with the micro's monitor routine...|$|E
40|$|Approved {{for public}} release; {{distribution}} is unlimitedHighlights of the IBH 4341 and IBM 3033 AP systems {{are presented with}} emphasis on Performance aspects. An analysis of Performance of the <b>Virtual</b> <b>Machine</b> <b>Facility</b> 370 (va- 370) is performed. The main efforts are (1) to present a methodology based on performance measurement and analysis techniques, trying to relate the trends in the data to {{the characteristics of the}} system, and thus gain an insight into what might cause the system to saturate and its performance to degrade, (2) analyze the statistical correlations among performance and resource usage variables in order to estimate the degree of association among these variables, (3) identify those variables that are good indicators of system load, (4) formulate regression equations for forecasting the system performance. This thesis is an effort toward the development of performance and resource usage forecasting equations, and a model for analyzing computer performance and resource allocation, of computer systems using VM/ 370. [URL] Peruvian Nav...|$|E
30|$|In essence, the Dalvik <b>virtual</b> <b>machine</b> is a Java <b>virtual</b> <b>machine,</b> {{but it is}} very {{different}} from the general Java <b>virtual</b> <b>machine.</b> The main differences are: (1) the system architecture of the Dalvik <b>virtual</b> <b>machine</b> is different from the Java <b>virtual</b> <b>machine.</b> The Dalvik <b>virtual</b> <b>machine</b> is based on virtual registers and the Java <b>virtual</b> <b>machine</b> is based on stack. (2) The instruction set of the Dalvik <b>virtual</b> <b>machine</b> (Dalvik byte code) is also completely different from the Java <b>virtual</b> <b>machine</b> (Java byte code). The Dalvik <b>virtual</b> <b>machine</b> is the key part of the whole system. In the process of dynamic taint tracking, most taint communication happens in this part.|$|R
40|$|In a <b>virtual</b> <b>machine</b> interpreter, {{the code}} for each <b>virtual</b> <b>machine</b> {{instruction}} has similarities to code for other instructions. We present an interpreter generator that automatically generates code for the <b>virtual</b> <b>machine</b> instructions from simple instruction descriptions; it generates code for the <b>virtual</b> <b>machine</b> interpreter, for generating <b>virtual</b> <b>machine</b> code, for <b>virtual</b> <b>machine</b> code disassembly, for tracing, and for profiling...|$|R
50|$|In {{addition}} to the portable <b>virtual</b> <b>machines</b> described above, <b>virtual</b> <b>machines</b> are often used as an execution model for individual scripting languages, usually by an interpreter. This table lists specific <b>virtual</b> <b>machine</b> implementations, both of the above portable <b>virtual</b> <b>machines,</b> and of scripting language <b>virtual</b> <b>machines.</b>|$|R
40|$|This {{paper is}} {{a survey of}} changes to <b>virtual</b> <b>machine</b> interfaces, implementation, architecture, and {{simulation}} techniques as they affect IBM System 1370 and 303 X (3031, 3032, 3033) processors, the system control program to which <b>virtual</b> <b>machines</b> interface, and other <b>virtual</b> <b>machines</b> executing on the same real computing system or elsewhere. The paper seeks to summarize such changes and provide a perspective on the <b>virtual</b> <b>machine</b> environment. New uses of <b>virtual</b> <b>machine</b> subsystems are discussed {{as they relate to}} inter-virtual-machine communication. The changing <b>virtual</b> <b>machine</b> environment: Interfaces to real hardware, virtual hardware, and other <b>virtual</b> <b>machines</b> by R. A. MacKinnon When IBM introduced <b>virtual</b> <b>machine</b> products with CP- 67 on the System/ 360 Model 67, an early view of the uniqueness of <b>virtual</b> <b>machines</b> focused on the isolation of one <b>virtual</b> <b>machine</b> fro...|$|R
30|$|Wolinsky et al. [19] use <b>virtual</b> <b>machine</b> sandboxes {{in order}} to provide {{security}} in large scale collaborative environments. Although this work focuses on networked <b>virtual</b> <b>machines</b> hosting <b>virtual</b> workstations, this concept can be extended to virtual networks. Sandboxes are used to limit <b>virtual</b> <b>machine</b> access to physical resources, preventing malicious <b>virtual</b> <b>machines</b> from accessing data within other <b>virtual</b> <b>machines.</b> Moreover, each <b>virtual</b> <b>machine</b> supports IPSec, enabling the creation of secure communication channels, and X. 509, providing <b>virtual</b> <b>machine</b> authentication. The authentication process is detailed in Section 2.|$|R
40|$|<b>Virtual</b> <b>machines</b> {{have been}} widely adapted for {{high-level}} programming language implementations and for providing a degree of platform neutrality. As the overall use and adaptation of <b>virtual</b> <b>machines</b> grow, the overall performance of <b>virtual</b> <b>machines</b> has become a widely-discussed topic. In this paper, we present a survey on the performance differences {{of the two most}} widely adapted types of <b>virtual</b> <b>machines</b> - the stack-based <b>virtual</b> <b>machine</b> and the register-based <b>virtual</b> <b>machine</b> - using various benchmark programs. Additionally, we adopted a new approach of measuring performance by measuring the overall dispatch time, amount of dispatches, fetch time, and execution time while running benchmarks on custom-implemented, lightweight <b>virtual</b> <b>machines.</b> Finally, we present two lightweight, custom-designed, Turing-equivalent <b>virtual</b> <b>machines</b> that are specifically designed in benchmarking <b>virtual</b> <b>machine</b> performance - the "Conceptum" stack-based <b>virtual</b> <b>machine,</b> and the "Inertia" register-based <b>virtual</b> <b>machine.</b> Our result showed that while on average the register machine spends 20. 39 % less time in executing benchmarks than the stack <b>machine,</b> the stack-based <b>virtual</b> <b>machine</b> is still faster than the <b>virtual</b> <b>machine</b> regarding the instruction fetch time. Comment: Short paper for evaluating performance differences between a stack-based and a register-based virtual machin...|$|R
40|$|International audienceThis work {{presents}} a co-hosting approach of multiple software stacks within a many-core system-on-chip. We present a many-core <b>virtual</b> <b>machine</b> monitor executing software stacks in <b>virtual</b> <b>machines.</b> We confine the <b>virtual</b> <b>machines</b> from each others {{to prevent a}} malicious <b>virtual</b> <b>machine</b> user to compromise an other <b>virtual</b> <b>machine</b> or the <b>virtual</b> <b>machine</b> monitor (or hypervisor). We have made a formally verified many-core hypervisor that relies on our own hardware protection mechanism...|$|R
50|$|<b>Virtual</b> <b>machine</b> {{management}} enables selecting {{high availability}} priority, live migration, live snapshots, cloning <b>virtual</b> <b>machines</b> from snapshots, creating <b>virtual</b> <b>machine</b> templates, using cloud-init for automated configuration during provisioning and deployment of <b>virtual</b> <b>machines.</b> Supported guest operating systems include GNU/Linux, Microsoft Windows and FreeBSD. Access to <b>virtual</b> <b>machines</b> {{can be achieved}} from webadmin portal using SPICE, VNC and RDP protocols.|$|R
40|$|Abstract. In {{order to}} ensure that the cloud {{platform}} client runtime kernel <b>virtual</b> <b>machine</b> security, this paper proposes a new framework for dynamic monitoring of <b>virtual</b> <b>machines,</b> it is for the kernel rootkit attacks, study the cloud client <b>virtual</b> <b>machine</b> operating system kernel safety, presented Hyperchk <b>virtual</b> <b>machine</b> dynamic monitoring framework. This framework mainly for kernel rootkit attacks, ensure that customers running <b>virtual</b> <b>machine</b> kernel security...|$|R
50|$|In computing, the Red Hat <b>Virtual</b> <b>Machine</b> Manager, {{also known}} as virt-manager, is a desktop-driven <b>virtual</b> <b>machine</b> manager with which users can manage <b>virtual</b> <b>machines</b> (VMs).|$|R
40|$|The primary {{objective}} of this bachelor thesis is to analyse the <b>virtual</b> <b>machine</b> of Java. The <b>virtual</b> <b>machine</b> is first put {{in the context of}} virtualization and then the reason {{of the success of the}} concept of such <b>virtual</b> <b>machine</b> is shown. The <b>virtual</b> <b>machine</b> is discussed in detail in the next part of this thesis and the basic structure and principles upon which the <b>virtual</b> <b>machine</b> works are explained. In the end the primary language constructs of Java are shown in connection with the <b>virtual</b> <b>machine...</b>|$|R
5000|$|A <b>virtual</b> <b>machine</b> can be {{permitted}} to accept communications from all other <b>virtual</b> <b>machines</b> via the [...] "IUCV ALLOW" [...] directory statement, or establish a communication path with any other <b>virtual</b> <b>machine</b> via the [...] "IUCV ANY" [...] statement. It is also possible to allow a <b>virtual</b> <b>machine</b> to issue path connection requests to other specific <b>virtual</b> <b>machines</b> by specifying the <b>virtual</b> <b>machine</b> name in an IUCV statement, for example: [...] "IUCV TARGETVM". By default, a user is always allowed to connect to itself.|$|R
50|$|HP Virtual Connect brings {{virtualization}} to {{the blade}} server edge. It picks up where <b>virtual</b> <b>machine</b> technology stops. <b>Virtual</b> <b>machine</b> technology can only move workloads across <b>virtual</b> <b>machines</b> {{on a single}} server. It becomes a challenge when moving <b>virtual</b> <b>machines</b> from one physical machine to another or between data center locations, because changes to the LAN and SAN environments require manual intervention by network and storage administrators. By pooling and sharing multiple network connections across multiple servers and <b>virtual</b> <b>machines,</b> <b>Virtual</b> Connect extends Data Center capability by allowing physical setup and movement of <b>Virtual</b> <b>Machine</b> workloads between servers and <b>Virtual</b> <b>Machines,</b> transparently from the LAN and SAN infrastructure.|$|R
40|$|<b>Virtual</b> <b>machine,</b> as an {{engineering}} tool, {{has recently been}} introduced into automation projects in Tetra Pak Processing System AB. The goal {{of this paper is}} to examine how to better utilize <b>virtual</b> <b>machine</b> for the automation projects. This paper designs different project scenarios using <b>virtual</b> <b>machine.</b> It analyzes installability, performance and stability of <b>virtual</b> <b>machine</b> from the test results. Technical solutions concerning <b>virtual</b> <b>machine</b> are discussed such as the conversion with physical computers, the configuration of virtual network and the use on different software platforms. It also suggests a workflow for the company to utilize <b>virtual</b> <b>machine</b> and share <b>virtual</b> <b>machine</b> resources across different project phases...|$|R
5000|$|Visual Studio Lab Management is {{integrated}} with System Center <b>Virtual</b> <b>Machine</b> Manager (SCVMM) to enable management of multiple physical computers that host <b>virtual</b> <b>machines</b> and {{to manage the}} storage of <b>virtual</b> <b>machines,</b> <b>virtual</b> <b>machine</b> templates, and other configuration files in SCVMM library servers. It enables users to: ...|$|R
40|$|Abstract: Cloud {{computing}} {{is becoming}} more and more popular in computing infrastructure and it also introduces new security problems. For example, a physical server shared by many <b>virtual</b> <b>machines</b> can be taken over by an attacker if the <b>virtual</b> <b>machine</b> monitor is compromised through one of the <b>virtual</b> <b>machines.</b> Thus, collocating with vulnerable <b>virtual</b> <b>machines,</b> or “bad neighbours”, on the same physical server introduces additional security risks. Moreover, the connections between <b>virtual</b> <b>machines,</b> such as the network connection between a web server and its back end database server, are natural paths of attacks. Therefore, both <b>virtual</b> <b>machine</b> placement and connections among <b>virtual</b> <b>machines</b> in the cloud have great impact over the overall security of cloud. In this paper, we quantify the security risks of cloud environments based on <b>virtual</b> <b>machine</b> vulnerabilities and placement schemes. Based on our security evaluation, we develop techniques to generate <b>virtual</b> <b>machine</b> placement that can minimize the security risks considering the connections among <b>virtual</b> <b>machines.</b> According to the experimental results, our approach can greatly improve the survivability of most <b>virtual</b> <b>machines</b> and the whole cloud. The computing costs and deployment costs of our techniques are also practical. ...|$|R
40|$|Part 4 : Job PlacementInternational audiencePrevious work on {{optimizing}} resource provisioning in virtualized environments focused {{either on}} mapping <b>virtual</b> <b>machines</b> to physical <b>machines</b> (i. e., <b>virtual</b> <b>machine</b> placement) or mapping computational tasks to <b>virtual</b> <b>machines</b> (i. e., <b>virtual</b> <b>machine</b> selection). In this paper, we investigate how these two optimization problems influence each other. Our {{study shows that}} exploiting knowledge about the physical machines and about the <b>virtual</b> <b>machine</b> placement algorithm {{in the course of}} <b>virtual</b> <b>machine</b> selection leads to better overall results than considering the two problems in isolation...|$|R
40|$|Windowing Toolkit and Swing, {{deal with}} Graphical User Interfaces. Others The {{material}} {{in this section}} and in Annex A is based on [Bro 97]. Further information on Java {{may be found in}} [Fl 97], [AG 96], and [GJS 96]. support specialized areas including distributed component development, security, and database connectivity. There is nothing intrinsic about the Java language that prevents a compiler from translating a source program into a native object module for the target environment, just like a compiler for a traditional language. However, it is more typical for a Java compiler to generate a so-called class file instead: a sequence of instructions, known as "bytecodes", which are executed by a Java <b>Virtual</b> <b>Machine.</b> This <b>facility</b> is especially important for downloading and running applets over the Internet, since the client machine running a Web browser might be different from the server machine from which the applet is retrieved. Obviously security is an issue, which is addressed through several mechanisms, including:. Restrictions in the Java language that prevent potentially insecure operations such as pointer arithmetic and unchecked deallocation. The implementation of the JVM, which performs a load-time analysis of the class file to ensure that it has not been compromised. The implementation of the browser or applet viewer, which checks that a downloaded applet does not invoke methods that directly access the client machine. Security-related classes in the API 2 Criteria for a Foundation Language Very few programming languages have been designed specifically for teaching; fewer have achieved widespread acceptance. Pascal is perhaps an exception, but several omissions have led to its decreasing significance over the years. It lacks, among other things, a modul [...] ...|$|R
40|$|Abstract — Researchers and {{practitioners}} in computer forensics currently must base their analysis on {{information that is}} either incomplete or produced by tools that may themselves be compromised {{as a result of}} the intrusion. Complicating these issues are the techniques employed by the investigators themselves. If the system is quiescent when examined, most of the information in memory has been lost. If the system is active, the kernel and programs used by the forensic investigators are likely to influence the results and as such are themselves suspect. Using <b>virtual</b> <b>machines</b> and a technique called <b>virtual</b> <b>machine</b> introspection can help overcome these limits, but it introduces its own research challenges. Recent developments in <b>virtual</b> <b>machine</b> introspection have led to the identification of four initial priority research areas in <b>virtual</b> <b>machine</b> introspection including <b>virtual</b> <b>machine</b> introspection tool development, applications of <b>virtual</b> <b>machine</b> introspection to non-quiescent <b>virtual</b> <b>machines,</b> <b>virtual</b> <b>machine</b> introspection covert operations, and <b>virtual</b> <b>machine</b> introspection detection. Keywords-virtualization, digital forensics, cirtual machine introspection, VMI. I...|$|R
40|$|Researchers and {{practitioners}} in computer forensics currently must base their analysis on {{information that is}} either incomplete or produced by tools that may themselves be compromised {{as a result of}} the intrusion. Complicating these issues are the techniques employed by the investigators themselves. If the system is quiescent when examined, most of the information in memory has been lost. If the system is active, the kernel and programs used by the forensic investigators are likely to influence the results and as such are themselves suspect. Using <b>virtual</b> <b>machines</b> and a technique called <b>virtual</b> <b>machine</b> introspection can help overcome these limits, but it introduces its own research challenges. Recent developments in <b>virtual</b> <b>machine</b> introspection have led to the identification of four initial priority research areas in <b>virtual</b> <b>machine</b> introspection including <b>virtual</b> <b>machine</b> introspection tool development, applications of <b>virtual</b> <b>machine</b> introspection to non-quiescent <b>virtual</b> <b>machines,</b> <b>virtual</b> <b>machine</b> introspection covert operations, and <b>virtual</b> <b>machine</b> introspection detection...|$|R
40|$|This paper {{describes}} a radical approach to aggressively optimize an embedded Java <b>virtual</b> <b>machine</b> interpretation in a portable way. We call this technique Semantically Enriched Code (sEc). The sEc technique {{can improve the}} speed of a JVM by orders of magnitude. The sEc technique adapts an embedded Java <b>virtual</b> <b>machine</b> to the demands of a Java application by automatically generating an enhanced <b>virtual</b> <b>machine</b> for every application. The bytecode set of the <b>virtual</b> <b>machine</b> is augmented with new application-specific opcodes, enabling the application to achieve greater performance. Aggressive static or offline optimizations are done to ensure tight coupling between the Java application, Java <b>virtual</b> <b>machine</b> and the underlying hardware. sEc makes an embedded Java <b>virtual</b> <b>machine</b> become a domain specific Java <b>virtual</b> <b>machine</b> – a versatility not possible with the hardware. KEY WORDS: embedded JVM, Java <b>virtual</b> <b>machine,</b> optimization, Interpreter, performance, semanticall...|$|R
50|$|JamVM is an {{open source}} Java <b>Virtual</b> <b>Machine</b> (JVM) {{developed}} to be extremely small compared with other <b>virtual</b> <b>machines</b> (VMs) while conforming to the Java <b>virtual</b> <b>machine</b> specification version 2 (blue book).|$|R
40|$|AbstractThe paper {{discusses}} {{application of}} the algorithm based information processes modeling and Q-machine learning {{to the task of}} <b>virtual</b> <b>machines</b> auto configuration. Usage of <b>virtual</b> <b>machines</b> is one the most common solution nowadays for almost every companies. Although using of <b>virtual</b> <b>machines</b> simplifies settings of hardware landscape and allows physical servers decentralization they may cause performance decrease. To overcome this issue, we propose using method of <b>virtual</b> <b>machines</b> auto configuration. The method is based on the following premises: tracking real business process held by <b>virtual</b> <b>machines,</b> using algorithms of machine learning to investigate optimal configuration, and <b>virtual</b> <b>machine</b> configuration by independent process...|$|R
5000|$|... <b>virtual</b> <b>machines</b> as in Java <b>virtual</b> <b>machine,</b> Common Language Runtime, etc.|$|R
40|$|This paper {{proposed}} a new method for sharing symbols between different GIS platform by using <b>virtual</b> <b>machine</b> technology, the symbol system consist of three parts, they are symbol <b>virtual</b> <b>machine,</b> <b>virtual</b> <b>machine</b> articulated plug-in and symbol design tools. Symbol <b>virtual</b> <b>machine</b> is a software simulated <b>machine,</b> it has <b>virtual</b> hardware, such as processor, stacks, registers, {{and the corresponding}} instruction system, symbols are described by these instructions. symbol <b>virtual</b> <b>machine</b> is independent of any specific GIS platform, responsible for dealing with GIS platform-independent function of symbolize; symbol <b>virtual</b> <b>machine</b> articulated plug-in connect the symbol <b>virtual</b> <b>machine</b> with the GIS platform, so that the GIS platform can call symbol <b>virtual</b> <b>machine</b> to do symbolize work; symbol design tools used {{in the production of}} symbols, when produce symbols we only target at symbol <b>virtual</b> <b>machine,</b> not target at specific GIS platform, thus the symbols can be shared in all the GIS platform articulated symbol <b>virtual</b> <b>machine.</b> 1. INTRODUCE Cartographers and geographers use symbols on maps to represent various geographic phenomena involving location, distance, volume, movement, function, process, correlation, etc [1]. These phenomena can be classified into four basic categories: point (non-dimensional data), line (one-dimensiona...|$|R
30|$|Security: In {{the rush}} to take {{advantage}} of the <b>virtual</b> <b>machine</b> live migration, security issues are often ignored. During migration, <b>virtual</b> <b>machine</b> is moved over an insecure channel and stored on some another machine. It is the point where the intruder can get control over the <b>virtual</b> <b>machine</b> and simultaneously affect the target machine. Another issue is <b>virtual</b> <b>machine</b> authentication i.e., only legitimate user should be enabling the <b>virtual</b> <b>machine</b> migration. These security issues are needed to be handled during <b>virtual</b> <b>machine</b> live migration. Zhang et al. (2008) discusses the <b>virtual</b> <b>machine</b> migration security issues and proposes a secure migration system. A detail survey on cloud security is discussed by Vaquero et al. (2011), which helps to better understand the security as a challenge.|$|R
30|$|<b>Virtual</b> <b>Machine</b> Introspection This {{mechanism}} simplifies {{inspecting the}} memory {{space of a}} <b>virtual</b> <b>machine</b> from another <b>virtual</b> <b>machine.</b> The task is fairly complex because of the semantic gap between the memory space of those two <b>virtual</b> <b>machines.</b> XenAccess [18] {{is an example of}} an introspection library. Using XenAccess the privileged domain can monitor another Xen domain.|$|R
40|$|Obtaining high {{flexibility}} to performance-loss ratio {{is a key}} challenge of today’s HPC virtual environment landscape. And while extensive research has been targeted at extract-ing more performance from <b>virtual</b> <b>machines,</b> the idea that whether novel <b>virtual</b> <b>machine</b> usage scenarios could lead to high flexibility Vs performance trade-off has received less attention. We, in this paper, take a step forward by studying and comparing the performance implications of running the Large-scale Atomic/Molecular Massively Parallel Simula-tor (LAMMPS) application on two <b>virtual</b> <b>machine</b> configu-rations. First configuration consists of two <b>virtual</b> <b>machines</b> per node with 1 application process per <b>virtual</b> <b>machine.</b> The second configuration consists of 1 <b>virtual</b> <b>machine</b> per node with 2 processes per <b>virtual</b> <b>machine.</b> Xen {{has been used as}} an hypervisor and standard linux as a guest <b>virtual</b> <b>machine.</b> Our results show that the difference in overall performance impact on LAMMPS between the two <b>virtual</b> <b>machine</b> con-figurations described above is around 3 %. We also study the difference in performance impact in terms of each configu-ration’s individual metrics such as CPU, I/O, Memory, and interrupt/context switches...|$|R
