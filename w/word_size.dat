542|350|Public
5|$|Common memory {{consisted}} of silicon CMOS SRAM, organized into octants of 64 banks each, {{with up to}} eight octants possible. The <b>word</b> <b>size</b> was 64-bits plus eight error-correction bits, and total memory bandwidth was rated at 128 gigabytes per second.|$|E
5|$|Pigeonhole sort, {{counting}} sort, radix sort, and Van Emde Boas tree sorting {{all work}} best when the key size is small; for large enough keys, they become slower than comparison sorting algorithms. However, when the key size or the <b>word</b> <b>size</b> is very large {{relative to the}} number of items (or equivalently when the number of items is small), it may again become possible to sort quickly, using different algorithms that take advantage of the parallelism inherent in the ability to perform arithmetic operations on large words.|$|E
5|$|From {{the advent}} of very-large-scale {{integration}} (VLSI) computer-chip fabrication technology in the 1970s until about 1986, speed-up in computer architecture was driven by doubling computer word sizeâ€”the amount of information the processor can manipulate per cycle. Increasing the <b>word</b> <b>size</b> reduces the number of instructions the processor must execute to perform an operation on variables whose sizes are greater than {{the length of the}} word. For example, where an 8-bit processor must add two 16-bit integers, the processor must first add the 8 lower-order bits from each integer using the standard addition instruction, then add the 8 higher-order bits using an add-with-carry instruction and the carry bit from the lower order addition; thus, an 8-bit processor requires two instructions to complete a single operation, where a 16-bit processor would be able to complete the operation with a single instruction.|$|E
50|$|Fixed point {{digital signal}} {{processors}} often support unusual <b>word</b> <b>sizes</b> and precisions {{in order to}} support specific signal resolutions. For example, the Motorola 56000 DSP chip uses 24-bit <b>word</b> <b>sizes,</b> 24-bit multipliers and 56-bit accumulators to perform multiply-accumulate operations on two 24-bit samples without overflow or rounding. On devices that do not support large accumulators, fixed point operations may be implicitly rounded, reducing precision to below that of the input samples.|$|R
5000|$|The {{number of}} {{multiplexers}} required for an n-bit word is [...] [...] Five common <b>word</b> <b>sizes</b> {{and the number}} of multiplexers needed are listed below: ...|$|R
50|$|For 16-bit words, the rotates are 7 bits {{right and}} 2 bits left; {{for all other}} <b>word</b> <b>sizes,</b> they are 8 and 3 as shown here.|$|R
25|$|High-end {{digital image}} {{equipment}} are often {{able to deal}} with larger integer ranges for each primary color, such as 0..1023 (10 bits), 0..65535 (16 bits) or even larger, by extending the 24-bits (three 8-bit values) to 32-bit, 48-bit, or 64-bit units (more or less independent from the particular computer's <b>word</b> <b>size).</b>|$|E
25|$|The {{behavior}} of GCC's back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define its endianness, <b>word</b> <b>size,</b> and calling conventions. The front {{part of the}} back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have {{to comply with the}} machine description of the target architecture.|$|E
25|$|Transmissions {{normally}} involve two shift registers of some given <b>word</b> <b>size,</b> such {{as eight}} bits, {{one in the}} master {{and one in the}} slave; they are connected in a virtual ring topology. Data is usually shifted out with the most-significant bit first, while shifting a new least-significant bit into the same register. At the same time, Data from the counterpart is shifted into the least-significant bit register. After the register bits have been shifted out and in, the master and slave have exchanged register values. If more data needs to be exchanged, the shift registers are reloaded and the process repeats. Transmission may continue for any number of clock cycles. When complete, the master stops toggling the clock signal, and typically deselects the slave.|$|E
5000|$|... #Caption: A six-bit word {{containing}} the binary encoded representation of decimal value 40. Most modern CPUs employ <b>word</b> <b>sizes</b> {{that are a}} power of two, for example 8, 16, 32 or 64 bits.|$|R
25|$|Transmissions often {{consist of}} 8-bit words. However, other <b>word</b> <b>sizes</b> are also common, for example, 16-bit words for touch screen {{controllers}} or audio codecs, {{such as the}} TSC2101 by Texas Instruments, or 12-bit words for many digital-to-analog or analog-to-digital converters.|$|R
50|$|The format {{dates back}} to the early days of {{business}} computing and is widely used to pass data between computers with different internal <b>word</b> <b>sizes,</b> data formatting needs, and so forth. For this reason, CSV files are common on all computer platforms.|$|R
500|$|... {{combinations}} of the parameters defining {{the number of}} items to be sorted, range of keys, and machine <b>word</b> <b>size.</b>|$|E
500|$|An integer sorting {{algorithm}} {{is said to}} be non-conservative if it requires a <b>word</b> <b>size</b> [...] that is significantly larger than [...] As an extreme instance, if , and all keys are distinct, then the set of keys may be sorted in linear time by representing it as a bitvector, with a 1 bit in position [...] when [...] is one of the input keys, and then repeatedly removing the least significant bit.|$|E
50|$|As {{computer}} designs {{have grown}} more complex, the central importance of a single <b>word</b> <b>size</b> to an architecture has decreased. Although more capable hardware can use {{a wider variety of}} sizes of data, market forces exert pressure to maintain backward compatibility while extending processor capability. As a result, what might have been the central <b>word</b> <b>size</b> in a fresh design has to coexist as an alternative size to the original <b>word</b> <b>size</b> in a backward compatible design. The original <b>word</b> <b>size</b> remains available in future designs, forming the basis of a size family.|$|E
3000|$|For certain fixed sets of diagonals (~polynomial coefficients, {{corresponding}} {{ultimately to}} the rotation distance in a rotate-XOR bit mixing function) we determined {{with a computer}} algebra system, at which <b>word</b> <b>sizes</b> n are the function invertible. We call n [...] "invertible" [...] or [...] "regular".|$|R
50|$|After the {{introduction}} of the IBM System/360 design, which used eight-bit characters and supported lower-case letters, the standard size of a character (or more accurately, a byte) became eight bits. <b>Word</b> <b>sizes</b> thereafter were naturally multiples of eight bits, with 16, 32, and 64 bits being commonly used.|$|R
40|$|Abstract-The Booth {{multiplication}} algorithm produces incorrect re-sults for some <b>word</b> <b>sizes,</b> {{when it is}} extended for higher radix, fixed-point multiplication. We present a modification of the Booth algorithm that produces correct results when the radix is any power of 2 and the multipliers are of any size. Index Terms-Algorithm, fixed-point multiplication, higher-radix mul-tiplication, multiplication, signed numbers. I...|$|R
50|$|The <b>word</b> <b>size</b> was 52 bits.|$|E
5000|$|Increasing the <b>word</b> <b>size</b> can {{accelerate}} {{multiple precision}} mathematical libraries. Applications include cryptography.|$|E
50|$|Modern processors, {{including}} embedded systems, {{usually have}} a <b>word</b> <b>size</b> of 8, 16, 24, 32, or 64 bits, while modern general purpose computers usually use 32 or 64 bits. Special purpose digital processors, such as DSPs for instance, may use other sizes, and many other sizes have been used historically, including 9, 12, 18, 24, 26, 36, 39, 40, 48, and 60 bits. The slab {{is an example of}} a system with an earlier <b>word</b> <b>size.</b> Several of the earliest computers (and a few modern as well) used BCD rather than plain binary, typically having a <b>word</b> <b>size</b> of 10 or 12 decimal digits, and some early decimal computers had no fixed word length at all.|$|E
50|$|The <b>size</b> of a <b>word</b> can {{sometimes}} {{differ from the}} expected due to backward compatibility with earlier computers. If multiple compatible variations or a family of processors share a common architecture and instruction set but differ in their <b>word</b> <b>sizes,</b> their documentation and software may become notationally complex to accommodate the difference (see Size families below).|$|R
40|$|This paper {{reports on}} higher-order square {{analysis}} of the AES cipher. We present experimental results of attack simulations on mini-AES versions with <b>word</b> <b>sizes</b> of 3, 4, 5, 6 and 7 bits and describe the propagation of higher-order Lambda-sets inside some of these distinguishers. A possible explanation {{of the length of}} the square distinguishers uses the concept of higher-order derivatives of discrete mappings...|$|R
40|$|Until recently, verifying {{multipliers}} with formal methods was not feasible, {{even for}} small input <b>word</b> <b>sizes.</b> About two years ago, a new data structure, called Multiplicative Binary Moment Diagram (*BMD), was introduced for representing arithmetic functions over Boolean variables. Based on this data structure, methods were proposed by which verification of multipliers with input <b>word</b> <b>sizes</b> {{of up to}} 256 bits became now feasible. Only experimental data has been provided for these verification methods until now. In this paper we give a formal proof that logic verification using *BMDs is polynomially bounded in both space and time, when applied to the class of Wallace-tree like multipliers. 1. Introduction Verifying that an implementation of a combinational circuit meets its specification {{is an important step}} in the design process. Often this is done by applying a set of test-input patterns to the circuit. With these patterns a simulation is performed to ensure oneself in the correct beha [...] ...|$|R
5000|$|It {{is defined}} for any power-of-two <b>word</b> <b>size,</b> [...] bits. The main SHA-3 {{submission}} uses 64-bit words, [...]|$|E
5000|$|The machine's <b>word</b> <b>size</b> remains 16 bits, but its {{memory is}} now byte-addressable {{with the same}} address space.|$|E
50|$|Note {{that most}} of these are each 32 bits long â€” the <b>word</b> <b>size</b> of most 32-bit {{architecture}} computers.|$|E
25|$|The SPI bus is a {{de facto}} {{standard}}. However, {{the lack of a}} formal standard is reflected {{in a wide variety of}} protocol options. Different <b>word</b> <b>sizes</b> are common. Every device defines its own protocol, including whether it supports commands at all. Some devices are transmit-only; others are receive-only. Chip selects are sometimes active-high rather than active-low. Some protocols send the least significant bit first.|$|R
40|$|Abstract. This paper {{reports on}} higher-order square {{analysis}} of the AES cipher. We present experimental results of attack simulations on mini-AES versions with <b>word</b> <b>sizes</b> of 3, 4, 5, 6 and 7 bits and describe the propagation of higher-order Î›-sets inside some of these distinguishers. A possible explanation {{of the length of}} the square distinguishers uses the concept of higher-order derivatives of discrete mappings. ...|$|R
50|$|The SPI bus is a {{de facto}} {{standard}}. However, {{the lack of a}} formal standard is reflected {{in a wide variety of}} protocol options. Different <b>word</b> <b>sizes</b> are common. Every device defines its own protocol, including whether it supports commands at all. Some devices are transmit-only; others are receive-only. Chip selects are sometimes active-high rather than active-low. Some protocols send the least significant bit first.|$|R
50|$|A <b>word</b> <b>size</b> is {{characteristic}} {{to a given}} computer architecture. It denotes the number of digits that a CPU can process at one time. Modern processors, including embedded systems, usually have a <b>word</b> <b>size</b> of 8, 16, 24, 32 or 64 bits; most current general purpose computers use 32 or 64 bits. Many different sizes have been used historically, including 8, 9, 10, 12, 18, 24, 36, 39, 40, 48 and 60 bits.|$|E
5000|$|Bit {{ratings for}} {{consoles}} largely fell {{by the wayside}} after the fifth generation (32/64-bit) era. The number of [...] "bits" [...] cited in console names referred to the CPU <b>word</b> <b>size,</b> {{but there was little}} to be gained from increasing the <b>word</b> <b>size</b> much beyond 32 bits; performance depended on other factors, such as central processing unit speed, graphics processing unit speed, channel capacity, data storage size, and memory speed, latency, and size.|$|E
50|$|The SHARC has a 32-bit word-addressed address space. Depending on <b>word</b> <b>size</b> this is 16 GB, 20 GB, or 24 GB.|$|E
50|$|Multiple 'slices' can be {{combined}} for arbitrarily large <b>word</b> <b>sizes.</b> For example, sixteen 74S181s and five 74S182 look ahead carry generators can {{be combined}} to perform the same operations on 64-bit operands in 28 nanoseconds (36 MHz). Although overshadowed by the performance of today's multi-gigahertz 64-bit microprocessors, this was quite impressive {{when compared to the}} sub megahertz clock speeds of the early four and eight bit microprocessors.|$|R
5000|$|Prior to the UNIVAC 1107, UNIVAC {{produced}} several vacuum-tube-based {{machines with}} model numbers from 1101 to 1105. These machines had different architectures and <b>word</b> <b>sizes</b> {{and were not}} compatible with each other. They all used vacuum tubes and many used drum memory as their main memory. Some were designed by Engineering Research Associates (ERA) which was later purchased and merged with the UNIVAC company.|$|R
40|$|This thesis {{describes}} {{the design and}} hardware implementation of a high speed multi-processor interface used in a colour graphics animation system. The design {{involves the use of}} Direct Memory Access to move data between the memories of the various CPUs constituting the Grads system. The system accommodates the various bus protocols, <b>word</b> <b>sizes,</b> and interrupt schemes of the different processors. An evaluation of the completed system is presented...|$|R
