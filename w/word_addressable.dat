4|4|Public
50|$|To {{illustrate}} why {{byte addressing}} is useful, consider the IBM 7094 which is <b>word</b> <b>addressable</b> {{and has no}} concept of a byte. It has 36 bit words, and stores its six-bit character codes six to a word.|$|E
50|$|Byte {{addressable}} memory {{refers to}} architectures where {{data can be}} accessed and addressed in units that are narrower than the bus. An eight bit processor like the Intel 8008 addresses eight bits, but as this is the full width of the bus, this is regarded as <b>word</b> <b>addressable.</b> The 386SX, which addresses memory in 8 bit units but can fetch and store it 16 bits at a time, is termed byte addressable.|$|E
40|$|Use of the Raw to Processed SINDA(System Improved Numerical Differencing Analyzer) Program, RTOPHS, which {{provides}} a means of making the temperature prediction data on binary HSTFLO and HISTRY units generated by SINDA available to engineers in an easy to use format, is discussed. The program accomplishes this by reading the HISTRY unit and according to user input instructions, the desired times and temperature prediction data are extracted and written to a <b>word</b> <b>addressable</b> drum file...|$|E
40|$|Abstract—This paper {{proposes a}} simple and {{effective}} built-in self-repair (BISR) scheme for content addressable memo-ries (CAMs) with address-input-free writing function. A pro-grammable built-in self-test (BIST) circuit is designed to generate different March-like test algorithms which can cover typical random access memory faults and comparison faults. A recon-figurable priority encoder is proposed to skip faulty words of a defective CAM. The delay penalty incurred by the reconfigurable priority encoder is regardless {{of the number of}} used spare rows. Analysis and simulation results show that the proposed BISR scheme can efficiently improve the reliability of the CAM. The area cost of the BISR design is only about 4. 87 % for a 256 × 128 -bit CAM with 7 spare <b>words.</b> Index Terms—Content <b>addressable</b> memory, test, repair, built-in self-repair, yield improvement. I...|$|R
40|$|Idea of caching {{is based}} on assumptions: 1. a memory item {{recently}} used {{is likely to be}} referenced again (loop) 2. memory items in the vicinity of a recently referenced memory item are likely to be referenced soon (sequence) ⇒ structure and transfer memory in blocks Cache Internal Layout • A cache consists of a fixed number of lines • each line contains a fixed number of words • each line represents a specific part of the main memory (block) • each byte in a <b>word</b> may be <b>addressable</b> individually • each line has a tag and a set of control bits • tags provide mechanism to map between cache and main memory • mechanism to replace cache lines Cache Lines Cache with 16 lines à 8 words of 2 bytes each: tag...|$|R
50|$|The UNIVAC 1110 had {{enhanced}} multiprocessing support: sixteen-way {{memory access}} allowed {{up to six}} CAUs (Command Arithmetic Unit, the new name for CPU and so called because the CAU no longer had any I/O capability) and four IOAUs (Input Output Access Units, the name for separate units which performed the I/O channel programs). The 1110 CAU expanded the memory address range from the 18-bits (1108 and 1106) to 24-bits, allowing for up to 16 million <b>words</b> of <b>addressable</b> memory. The core memory used on the 1108/1106 systems was replaced with faster plated wire memory. Each memory cabinet contained eight independent 8K plated wire memory modules, or 64K for the entire cabinet. As with the 1108/1106, there was a maximum of four 64K cabinets per system. The 1110 also had 'Extended Memory' cabinets accessible in a 'daisy chain' arrangement to augment main storage. It was possible to utilize the 1108 64K core memory cabinets as Extended Storage, but in most systems utilized, the larger, less expensive 131K memory cabinets from the 1106 system. Up to eight Extended Memory cabinets were allowed, for a maximum of one million words of Extended Storage. An ESC (Extended Storage Controller) was required for each pair of memory cabinets to provide the physical connection, and address translation, from the 1110 CAUs and IOAU(s).|$|R
40|$|We {{report on}} an {{implementation}} of a pascal translator that generates code for mobile software messengers (agents) : these agents can roam a network of interconnected execution platforms {{on behalf of a}} user, enabling users to implement customized network functionality themselves. In this report we focus on the language extensions (pascal-m) and the implementation aspects of the translator. The main departure in pascal-m from standard pascal is that the programmer has access to the generated code in form of string constants. An interesting aspect of the "pascal-to-MØ" (ptom) translator is that pascal-m is translated to the stack-based high-level language MØ. MØ is similar to postscript and has no notion of memory addresses although pascal compilers usually produce code for machines or software interpreters with <b>word</b> <b>addressable</b> memory: because MØ completely hides the exact memory locations of code as well as data, we have to use other implementation approaches for activation frames, var [...] ...|$|E
30|$|When {{using the}} FSLs for pixel-column shifts, since their channel width {{is set to}} the maximum of being 4 -pixels wide (to {{optimize}} data transfers), shifts that occur in multiples of 4 can be handled by relatively straight forward 32 -bit memory word reads from DRAM. Such {{is the case for}} the accelerator scaling levels of 16, 8, and 4 PPUS. However, as the accelerator scaling falls to 2 -PPUs or even a single PPU, the required FSL granularity of shifting becomes 1 / 2 FSL width and 1 / 4 FSL width respectively. Since the Microblaze ISA is byte <b>addressable,</b> <b>word</b> accesses from DRAM can be packed/re-ordered such that a finer granularity of shifting pixels is supported. At the micro-architectural level, Microblaze may make use of barrel shifting within its ALU to get the desired byte from a 32 -bit data bus read. Therefore the Microblaze core was synthesized with its additional barrel-shift logic parameter enabled.|$|R

