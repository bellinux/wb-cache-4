5|39|Public
5000|$|... #Caption: A 24-byte {{keyboard}} circular buffer. When the <b>write</b> <b>pointer</b> {{is about}} to reach the read pointer - because the microprocessor is not responding, the buffer will stop recording keystrokes and - in some computers - a beep will be played.|$|E
50|$|Upon {{decoding}} D, L, c, again, D = LR. When {{the first}} LR characters are {{read to the}} output, this corresponds to a single run unit appended to the output buffer. At this point, the read pointer could {{be thought of as}} only needing to return int(L/LR) + (1 if L mod LR ≠ 0) times to the start of that single buffered run unit, read LR characters (or maybe fewer on the last return), and repeat until a total of L characters are read. But mirroring the encoding process, since the pattern is repetitive, the read pointer need only trail in sync with the <b>write</b> <b>pointer</b> by a fixed distance equal to the run length LR until L characters have been copied to output in total.|$|E
40|$|Abstract：A novel high {{throughput}} globally asynchronous locally synchronous wrapper {{is proposed}} to improve the network interface performance of network on chip. To prevent the occurrence of data sampling error, both the sender and receiver wrapper use the pausable clocking scheme to stop the clock when data come. The VC is based on Muller pipeline and chosen by the VC selector in the circuit. This wrapper can avoid the comparison between read pointer and <b>write</b> <b>pointer</b> in conventional design scheme and can increase the throughput. Simulations were based on SMIC 0. 18 um CMOS technology, and the sender wrapper and receiver wrapper have the throughput as high as 810 Mflit/s and 820 Mflit/s respectively...|$|E
5000|$|Single compare, double swap : Compares one <b>pointer</b> but <b>writes</b> two. The Itanium's cmp8xchg16 {{instruction}} implements this, {{where the}} two <b>written</b> <b>pointers</b> are adjacent.|$|R
50|$|The {{overhead}} of write barriers is {{more likely}} to be noticeable in an imperative-style program which frequently <b>writes</b> <b>pointers</b> into existing data structures than in a functional-style program which constructs data only once and never changes them.|$|R
5000|$|A similar {{version of}} [...] can be <b>written</b> with <b>pointers</b> instead of references: ...|$|R
40|$|Clock {{compensation}} for Gigabit Ethernet is necessary because the clock {{recovered from the}} 1. 25 Gb/s serial data stream {{has the potential to}} be 200 ppm slower or faster than the system clock. The serial data is converted to 10 -bit parallel data at a 125 MHz rate on a clock recovered from the serial data stream. This recovered data needs to be processed by a system clock that is also running at a nominal rate of 125 MHz, but not synchronous to the recovered clock. To cross clock domains, an asynchronous FIFO (first-in-first-out) is used, with the <b>write</b> <b>pointer</b> (wprt) in the recovered clock domain and the read pointer (rptr) in the system clock domain. Because the clocks are generated from separate sources, there is potential for FIFO overflow or underflow. Clock compensation in Gigabit Ethernet is possible by taking advantage of the protocol data stream features. There are two distinct data streams that occur in Gigabit Ethernet where identical data is transmitted for a period of time. The first is configuration, which happens during auto-negotiation. The second is idle, which occurs at the end of auto-negotiation and between every packet. The identical data in the FIFO can be repeated by decrementing the read pointer, thus compensating for a FIFO that is draining too fast. The identical data in the FIFO can also be skipped by incrementing the read pointer, which compensates for a FIFO draining too slowly. The unique and novel features of this FIFO are that it works in both the idle stream and the configuration streams. The increment or decrement of the read pointer is different in the idle and compensation streams to preserve disparity. Another unique feature is that the read pointer to <b>write</b> <b>pointer</b> difference range changes between compensation and idle to minimize FIFO latency during packet transmission...|$|E
40|$|Two {{prototype}} {{chips for}} the analogue readout of silicon strip detectors in the ATLAS Semiconductor Tracker (SCT) {{have been designed}} and manufactured, in 32 channels and 128 channel versions, using the radiation hard BiCMOS DMILL process. The SCTA chip comprises three basic blocks: front-end amplifier, analogue pipeline and output multiplexer. The front-end circuit is a fast transresistance amplifier followed by an integrator, providing fast shaping with a peaking time of 25 ns, and an output buffer. The front end output values are sampled at 40 MHz rate and stored in a 112 -cell deep analogue pipeline. The delay between the <b>write</b> <b>pointer</b> and trigger pointer is tunable between 2 ms and 2. 5 ms. The chip has been tested successfully and subsequently irradiated up to 10 Mrad. Full functionality of all blocks of the chip has been achieved at a clock frequency of 40 MHz {{both before and after}} irradiation. Noise figures of ENC = 720 e- + 33 e-/pF before irradiation and 840 e- + 33 e-/pF after irradiation have been obtained...|$|E
40|$|While {{traditional}} implementations {{of digital}} delay lines {{are based on}} a circular buffer accessed by two pointers, we propose an implementation where a single fractional pointer is used both for reading and writing operations. On modern general-purpose architectures, the proposed method is nearly as efficient as the popular interpolated circular buffer, but it offers better performance in terms of frequency-dependent attenuation and response to delay-length modulations. 1 Prior Art The classic implementation of the digital delay line uses a circular buffer, which is accessed by a <b>writing</b> <b>pointer</b> followed by a reading pointer [5]. When the delay length has to be made variable, the relative distance between the reading <b>pointer</b> and the <b>writing</b> <b>pointer</b> is varied sample by sample. In order to allow for fractional lengths and click-free length modulation, some form of interpolation has to be applied at the reading point [10, 3, 9]. The following properties should be ensured by the inter [...] ...|$|R
50|$|FIFOs are {{commonly}} used in electronic circuits for buffering and flow control between hardware and software. In its hardware form, a FIFO primarily consists {{of a set of}} read and <b>write</b> <b>pointers,</b> storage and control logic. Storage may be static random access memory (SRAM), flip-flops, latches or any other suitable form of storage. For FIFOs of non-trivial size, a dual-port SRAM is usually used, where one port is dedicated to writing and the other to reading.|$|R
50|$|A {{synchronous}} FIFO is a FIFO {{where the}} same clock {{is used for}} both reading and writing. An asynchronous FIFO uses different clocks for reading and writing. Asynchronous FIFOs introduce metastability issues.A common implementation of an asynchronous FIFO uses a Gray code (or any unit distance code) for the read and <b>write</b> <b>pointers</b> to ensure reliable flag generation. One further note concerning flag generation is that one must necessarily use pointer arithmetic to generate flags for asynchronous FIFO implementations. Conversely, one may use either a leaky bucket approach or pointer arithmetic to generate flags in synchronous FIFO implementations.|$|R
5000|$|... "Streets of Gold" [...] - Ruth <b>Pointer</b> <b>written</b> by Dean Pitchford and Tom Snow ...|$|R
5000|$|As a {{final note}} {{regarding}} <b>pointer</b> definitions: always <b>write</b> the <b>pointer</b> symbol (the *) {{as much as}} possible to the right. Attaching the pointer symbol to the type is tricky, as it strongly suggests a pointer type, which isn't the case. Here are some examples: ...|$|R
50|$|It was {{originally}} <b>written</b> by Robey <b>Pointer</b> in December 1993 to help manage {{and protect the}} EFnet channel #gayteen; one Eggdrop bot version was named Valis.|$|R
5000|$|Although C/C++ allows such {{definitions}} (which closely {{match the}} English language when reading the definitions {{from left to}} right), the compiler still reads the definitions according to the abovementioned procedure: from right to left. But putting [...] before what must be constant quickly introduces mismatches between what you intend to write and what the compiler decides you <b>wrote.</b> Consider <b>pointers</b> to pointers: ...|$|R
40|$|Abstract. The C {{programming}} language is still ubiquitous in embedded software development. For many tools that operate on programs <b>written</b> in <b>pointer</b> languages like C, {{it is essential}} to have a good approximation of the information about where the pointer variables possibly may point to at runtime. We present a points-to analysis, which is based on Steensgaard’s approach to points-to analysis [12], but achieves a higher level of precision. ...|$|R
5000|$|A typical use of Gray code {{counters}} {{is building}} a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.The updated read and <b>write</b> <b>pointers</b> need to be passed between clock domains when they change, {{to be able to}} track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a [...] "wrong" [...] binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.|$|R
40|$|Abstract | In {{this paper}} the new packet switch {{architecture}} with multiple output queuing (MOQ) is proposed. In this architecture the nonblocking switch fabric, {{which has the}} ca-pacity of NN 2, and output buers arranged into N separate queues for each output, are applied. Each of N queues in one output port stores packets directed to this output only from one input. Both switch fabric and buers can operate {{at the same speed}} as input and output ports. This solution does not need any speedup in the switch fabric as well as arbitration logic for taking decisions which packets from in-puts will be transferred to outputs. Two possible switch fab-ric structures are considered: the centralized structure with the switch fabric located on one or several separate boards, and distributed structure with the switch fabric distributed over line cards. Buer arrangements as separate queues with independent <b>write</b> <b>pointers</b> or as a memory bank with one pointer are also discussed. The mean cell delay and cell loss probability as performance measures for the proposed switch architecture are evaluated and compared with performance of OQ architecture and VOQ architecture. The hardware com-plexity of OQ, VOQ and presented MOQ are also compared. We conclude that hardware complexity of proposed switch is very similar to VOQ switch but its performance is comparable to OQ switch...|$|R
40|$|This {{book was}} {{published}} {{as a part of}} the highly acclaimed Counselling primer series from PCCS Books which is suitable for both beginners and higher level students who want a succinct boost to their knowledge of a particular area. Beginners will find the style companionable and reassuring, while more advanced readers will appreciate the incisive and authoritative <b>writing</b> with <b>pointers</b> for further reading and resources. Trainers will find the series a dependable learning aid. Counselling primers bridge the gap between introductory, intermediate and diploma level courses, each book providing a concise overview of a particular counselling approach. Each Counselling primer can be a perfect essay resource or a springboard for further study...|$|R
30|$|In {{the second}} scenario, we write an LLVM pass to {{automatically}} identify and instrument all function pointer accesses in Nginx. On serving each HTTP request, Nginx performs 104 function pointer read operations and 17 function <b>pointer</b> <b>write</b> operations on average. In the baseline, serving each request takes 31 microseconds on average. The throughput drops 1.1 to 2.7 % when a primitive’s latency varies from 12 to 36 cycles, and 7.9 % for emulated PTWRITE.|$|R
40|$|<b>Writes</b> via {{unchecked}} <b>pointer</b> dereferences rank {{high among}} vulnerabilities most often exploited by malicious code. The most common attacks use an unchecked string copy {{to cause a}} bu#er overrun, thereby overwriting the return address in the function's activation record. Then, when the function "returns", control is actually transferred to the attacker's code. Other attacks may overwrite function pointers, setjmp bu#ers, system-call arguments, or simply corrupt data to cause a denial of service...|$|R
40|$|Abstract—Use of FIFOs {{in digital}} designs for {{buffering}} and flow control has been widespread since many years. As feature sizes continue their south-bound journey, {{more and more}} complex circuitry has found its way onto the chip. The emergence of system on chip (SOC) and networks on chip (NOC) for internal connections have made it imperative to ensure correct flow of data across the chip {{especially in light of}} the performance shortcomings of global interconnects. One of the design challenges that arises is to ensure safety and fidelity for this data transfer. FIFO cells are a good way to accomplish this task. The FIFOs now require to serve two masters (clocks) instead of one. Such FIFOs are called Asynchronous FIFOs. There are many clever architectures and implementations of FIFOs as enlisted in the references. These aim to maximize benefits in latency or throughput or both. This work aims at comparing two pointer synchronization techniques in FIFOs. to generate the FULL and EMPTY status flags. An EMPTY flag is generated by the comparison of the read and <b>write</b> <b>pointers</b> and results in the number of memory locations between them being zero. If the number of memory locations between them is the maximum FIFO depth, the FULL flag is asserted. It is clear that an EMPTY FIFO cannot be read from and a FULL FIFO cannot be written into. Efficient generation and comparison of these status flags depends on the correct design of the FIFO and is the topic of this study. Sections II and III provide information about the two synchronization and comparison techniques used in this project. Section IV details the implementation of the FIFOs. Section V reports a few results. Conclusion and future work is outlined in Section VI...|$|R
40|$|International audienceIn a {{language}} with procedures calls and pointers as parameters, an instruction can modify memory locations {{anywhere in the}} call-stack. The presence of such side effects breaks most generic interprocedural analysis methods, which assume that only {{the top of the}} stack may be modified. We present a method that addresses this issue, based on the definition of an equivalent local semantics in which <b>writing</b> through <b>pointers</b> has a local effect on the stack. Our second contribution in this context is an adequate representation of summary functions that models the effect of a procedure, not only on the values of its scalar and pointer variables, but also on the values contained in pointed memory locations. Our implementation in the interprocedural analyser PInterproc results in a verification tool that infers relational properties on the value of Boolean, numerical and pointer variables...|$|R
50|$|The TMS9918A's {{method of}} {{accessing}} the video RAM is slower than direct access, {{as used in}} unified-memory computers, because accessing video memory involved first outputting the low- then the hi-byte of the (14-bit) video memory address to I/O port $99, then one or more bytes of 8-bit data to port $98. After each <b>write,</b> the memory <b>pointer</b> advances to the next address, so consecutive addresses can be written to with repeated OUT instructions to $98. This also meant that the fast Z80 blockmove and blockfill instructions {{could not be used}} on the video memory.|$|R
5000|$|Following usual C {{convention}} for declarations, declaration follows use, and the [...] in a <b>pointer</b> is <b>written</b> on the <b>pointer,</b> indicating dereferencing. For example, in {{the declaration}} , the dereferenced form [...] is an , while the reference form [...] is a pointer to an [...] Thus [...] modifies {{the name to}} its right. The C++ convention is instead to associate the [...] with the type, as in [...] and read the [...] as modifying the type to the left. [...] can thus be read as [...] " [...] is a [...] " [...] (the value is constant), or [...] " [...] is a [...] " [...] (the pointer is a pointer to a constant integer). Thus: ...|$|R
40|$|Abstract. This paper {{introduces}} YARRA, {{a conservative}} extension to C to protect applications from non-control data attacks. YARRA programmers specify their data integrity requirements by declaring critical data types and ascribing these critical types to important data structures. YARRA guarantees that such critical data is only <b>written</b> through <b>pointers</b> with the given static type. Any attempt {{to write to}} critical data through a pointer with an invalid type (perhaps because of a buffer overrun) is detected dynamically. We formalize YARRA’s semantics and prove the soundness of a program logic designed for use with the language. A key contribution {{is to show that}} YARRA’s semantics are strong enough to support sound local reasoning and the use of a frame rule, even across calls to unknown, unverified code. We eval-uate a prototype implementation of a compiler and runtime system for YARRA by using it to harden four common server applications against known non-control data vulnerabilities. We show that YARRA successfully defends the applications against these attacks. In our initial experiments, we find that the performance impact of YARRA is small, provided the amount of critical data is small and the application is not compute intensive...|$|R
40|$|A {{hardware}} self-managing heap memory (RCM) for languages like LISP, SMALLTALK, and JAVA {{has been}} designed, built, tested and benchmarked. On every <b>pointer</b> <b>write</b> from the processor, reference-counting transactions are performed {{in real time}} within this memory, and garbage cells are reused without processor cycles. A processor allocates new nodes simply by reading from a distinguished location in its address space. The memory hardware also incorporates support for off-line, multiprocessing, mark-sweep garbage collection. Performance statistics are presented from a partial implementation of SCHEME over five different memory models and two garbage collection strategies, from main memory (no access to RCM) to a fully operational RCM installed on an external bus. The performance of the RCM memory is more than competitive with main memory...|$|R
40|$|<b>Writes</b> via {{unchecked}} <b>pointer</b> dereferences rank {{high among}} vulnerabilities most often exploited by malicious code. The most common attacks use an unchecked string copy {{to cause a}} buffer overrun, thereby overwriting the return address in the function's activation record. Then, when the function &quot;returns&quot;, control is actually transferred to the attacker's code. Other attacks may overwrite function pointers, setjmp buffers, system-call arguments, or simply corrupt data to cause a denial of service. A number of techniques have been proposed to address such attacks. Some are limited to protecting the return address only; others are more general, but have undesirable properties such as having a high runtime overhead, requiring manual changes to the source code, or forcing programmers to give up control of data representations and memory management...|$|R
40|$|Abstract. This {{document}} {{is built around}} a list of thirty-two problems in enumeration of matchings, the first twenty of which were presented in a lecture at MSRI {{in the fall of}} 1996. I begin with a capsule history of the topic of enumeration of matchings. The twenty original problems, with commentary, comprise the bulk of the article. I give an account of the progress that has been made on these problems as of this <b>writing,</b> and include <b>pointers</b> to both the printed and on-line literature; roughly half of the original twenty problems were solved by participants in the MSRI Workshop on Combinatorics, their students, and others, between 1996 and 1999. The article concludes with a dozen new open problems. 1...|$|R
40|$|Abstract —StarSync, a {{mesochronous}} synchronizer, enables {{low latency}} and full throughput crossing of clock domain boundaries having same frequency but different phases. Full back pressure is supported, where the receiver can {{start and stop}} accepting words without any data loss. Variable depth buffering is provided, supporting {{a wide range of}} short and long range communications and accommodating multi-cycle wire delays. Burst data can also be accommodated thanks to buffering. Dynamic phase shifting due to varying voltage and temperature are mitigated by increasing the separation between <b>write</b> and read <b>pointers.</b> The synchronizer is exposed to metastability risk only during reset. It is suitable for implementation using standard cell design and requires neither delay lines nor other full custom circuits. It is shown that a minimum of four buffer stages are required, to mitigate skew in reset synchronization, in contrast with previous proposals for three stages. Keywords—Synchronization, mesochronous, multi-synchronous, buffering, back-pressure 1...|$|R
5000|$|... "Dare Me" [...] {{was written}} by Nashville-based songwriters Sam Lorber and Dave Innis in 1984. Innis, who shortly {{afterwards}} became {{a founding member of}} Restless Heart, was then a staff writer for Warner Bros. music publishing division, and recalls that [...] "Dare Me" [...] was <b>written</b> with the <b>Pointer</b> Sisters in mind, adding: [...] "typically writers look at whos recording now and what kind of material are they looking for, and we would tailor a song for a particular artist and pitch it"..."Sam Lorber and I...did try to put ourselves in the place of what a gal might be thinking...not specifically trying to be a Pointer Sister, but a song written from a female perspective, for sure. There are certain things that are more gender specific and gender appropriate...certain things that a woman can say that a guys {{not going to be able}} to get away with saying." ...|$|R
40|$|A four-stage {{mesochronous}} synchronizer is described. It enables {{low latency}} and full throughput crossing of boundaries of same frequency, different phase clock domains. Full back pressure is supported, where the receiver can {{start and stop}} accepting words without any data loss. Variable depth buffering is provided, supporting {{a wide range of}} short and long range communications and accommodating multi-cycle wire delays. Burst data can also be accommodated thanks to buffering. Dynamic phase shifting due to varying voltage and temperature are mitigated by increasing the separation between <b>write</b> and read <b>pointers.</b> Unlike common synchronizers, this circuit is exposed to metastability risk only during reset. The synchronizer provides lower latency and higher reliability than typical two-clock FIFO and other asynchronous and mesochronous synchronizers. It is suitable for implementation using standard cell design and does not require any delay lines, tuning of clock trees and other full custom circuits. It is shown that a minimum of four buffer stages are required, in contrast with previous proposals for three stages. 1...|$|R
40|$|This {{document}} {{is built around}} a list of thirty-two problems in enumeration of matchings, the first twenty of which were presented in a lecture at MSRI {{in the fall of}} 1996. I begin with a capsule history of the topic of enumeration of matchings. The twenty original problems, with commentary, comprise the bulk of the article. I give an account of the progress that has been made on these problems as of this <b>writing,</b> and include <b>pointers</b> to both the printed and on-line literature; roughly half of the original twenty problems were solved by participants in the MSRI Workshop on Combinatorics, their students, and others, between 1996 and 1999. The article concludes with a dozen new open problems. (Note: This article supersedes math. CO/ 9801060 and math. CO/ 9801061.) Comment: 1 + 37 pages; to appear in "New Perspectives in Geometric Combinatorics" (ed. by Billera, Bjorner, Green, Simeon, and Stanley), Mathematical Science Research Institute publication # 37, Cambridge University Press, 199...|$|R
5000|$|Anita Pointer {{has stated}} that she wrote this breakup song from {{personal}} experience: pre-stardom the <b>Pointer</b> Sisters had <b>written</b> and recorded radio spots, for which purpose they'd borrowed equipment from San Francisco radio station KSAN, and Anita had become romantically involved with a KSAN deejay who'd neglected to mention being married - [...] "He lied to me so when I found out that's when that song 'came out' took shape". [...] "Fairytale" [...] was <b>written</b> while the <b>Pointer</b> Sisters were {{on one of their}} earliest tours as support for Dave Mason: staying at a motel in Woodstock (NY) Anita was listening to a cassette by James Taylor - [...] "I love him. I just think he’s so great. And I wrote Fairytale that night." [...] At the conclusion of the tour with Mason, Anita gave what she'd written at the motel to Bonnie Pointer for polishing into the song which the Pointer Sisters recorded at Quadraphonic Studios in Nashville TN.|$|R
40|$|This {{document}} {{is built around}} a list of thirty-two problems in enumeration of matchings, the first twenty of which were presented in a lecture at MSRI {{in the fall of}} 1996. I begin with a capsule history of the topic of enumeration of matchings. The twenty original problems, with commentary, comprise the bulk of the article. I give an account of the progress that has been made on these problems as of this <b>writing,</b> and include <b>pointers</b> to both the printed and on-line literature; roughly half of the original twenty problems were solved by participants in the MSRI Workshop on Combinatorics, their students, and others between 1996 and 1999. The article concludes with a dozen new open problems. 1 Introduction How many perfect matchings does a given graph G have? That is, in how many ways can one choose a subset of the edges of G so that each vertex of G belongs to one and only one chosen edge? (See Figure 1 (a) for an example of a perfect matching of a graph.) For general graphs G, it is [...] ...|$|R
40|$|This {{document}} {{is built around}} a list of twenty problems in enumeration of matchings that were gathered together in 1996 and presented in a lecture at MSRI that fall. Since then, roughly half of the problems have been solved by participants in the MSRI Workshop on Combinatorics, their students, and others. The article begins with a capsule history of the topic of enumeration of matchings. The twenty problems themselves, with commentary, comprise {{the bulk of the}} article. The final section gives an account of the progress that has been made on these problems as of this <b>writing,</b> and includes <b>pointers</b> to both the printed and on-line literature. 1 Introduction How many perfect matchings does a given graph G have? That is, in how many ways can one choose a subset of the edges of G so that each vertex of G belongs to one and only one chosen edge? (See Figure 1 (a) for an example of a matching of a graph. The book by Lov'asz and Plummer [LP] gives general background on matchings of graphs.) [...] ...|$|R
