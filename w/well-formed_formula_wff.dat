4|181|Public
50|$|Construction Rule I: For each {{natural number}} n, the symbol pn is a <b>well-formed</b> <b>formula</b> (<b>wff),</b> called an atom.|$|E
40|$|The {{purpose of}} this paper is to explain a {{computerized}} process whereby any <b>well-formed</b> <b>formula</b> (<b>wff)</b> of first order predicate calculus can be moved to its prenex normal form (PNF). The main features of the program demonstrate some of the interesting capabilities of the WATFIV compiler in utilizing Markov Algorithms...|$|E
40|$|This {{paper is}} not for {{reproduction}} without permission of the authors. Reality, both material and conceptual, functions as a complex network of continuous adaptive morphological formation. The morphological form is a <b>well-formed</b> <b>formula</b> (<b>wff),</b> a Sign, an organized process of information. The Sign is formed within a triadic set of relations, which are encoded spatial and temporal measurements. Using a Cartesian quadrant, the six possible relational modes are examined to show how reality is moulded within both symmetrical and asymmetrical functions. 1. MORPHOLOGICAL FORMATION I am examining reality as a complex network of continuous adaptive morphological formation. Physical reality whether crisp or vague exists only within morphological forms, and equally, conceptual reality, whether experienced as individual information or as shared knowledge, functions only within morphological forms. I refer {{to the process of}} morphological generation as semiosis. The morphological form in itself, material and conceptual, is a <b>well-formed</b> <b>formula</b> (<b>wff),</b> termed a Sign. In defining the morphological entity as a wff, I refer to its development as a coherent form within a triadic set of relations, which are encoded spatial and temporal measurements. As a result of this triadic interaction the Sign exists as itself and in relations with other Signs, a process that permits both the networked continuity and diversity of reality (Taborsk...|$|E
5000|$|Quasi-quotation is {{particularly}} useful for stating formation rules for formal languages. Suppose, for example, that {{one wants to}} define the <b>well-formed</b> <b>formulas</b> (<b>wffs)</b> of a new formal language, L, with only a single logical operation, negation, via the following recursive definition: ...|$|R
50|$|Another {{option is}} to use Greek lower-case letters to {{represent}} such metavariable predicates. Then, such letters {{could be used to}} represent entire <b>well-formed</b> <b>formulae</b> (<b>wff)</b> of the predicate calculus: any free variable terms of the wff could be incorporated as terms of the Greek-letter predicate. This is the first step towards creating a higher-order logic.|$|R
2500|$|The set of <b>formulas</b> (also called <b>well-formed</b> <b>formulas</b> or <b>WFFs)</b> is inductively {{defined by}} the {{following}} rules: ...|$|R
40|$|MPL is the {{language}} with which a modeler describes a system to be diagnosed or controlled by Livingstone. MPL is used to specify what are {{the components of the}} system, how they are interconnected, and how they behave both nominally and when failed. Component behavioral models used by Livingstone are described by a set of propositional, <b>well-formed</b> <b>formula</b> (<b>wff).</b> An understanding of well-formed formula, primitive component types specified through defcomponent, and device structure specified by defmodule, is essential to understanding of MPL, This document describes: welI-formed formula (wff) : The basis for describing the behavior of a component in a system defvalues: Specifies the domain (legal values) of a variable defcomponent: Defines the modes, behaviors and mode transitions for primitive components deftnodule: Defines composite devices, consisting of interconnected components defrelation: A macro mechanism for expanding a complex wff according to the value of an argument forall: An iteration construct used to expand a wff or relation on a set of arguments defsymbol-expansion: A mechanism for naming a collection of symbols (eg the name of all valves in the system...|$|E
50|$|A formal {{language}} {{consists of a}} fixed collection of sentences (also called words or formulas, depending on the context) composed from a fixed set of letters or symbols. The inventory from which these letters are taken is called the alphabet over which the language is defined. To distinguish the strings of symbols that are in a {{formal language}} from arbitrary strings of symbols, the former are sometimes called <b>well-formed</b> <b>formulæ</b> (<b>wff).</b> The essential feature of a formal language is that its syntax can be defined without reference to interpretation. For example, we can determine that (P or Q) is a <b>well-formed</b> <b>formula</b> even without knowing whether it is true or false.|$|R
5000|$|A grammar, {{which tells}} how <b>well-formed</b> <b>formulas</b> (abbreviated <b>wff)</b> are {{constructed}} {{out of the}} symbols in the alphabet. It is usually required {{that there be a}} decision procedure for deciding whether a formula is well formed or not.|$|R
50|$|In {{mathematical}} logic, {{propositional logic}} and predicate logic, a <b>well-formed</b> <b>formula,</b> abbreviated <b>WFF</b> or <b>wff,</b> often simply <b>formula,</b> is a finite {{sequence of symbols}} from a given alphabet {{that is part of}} a formal language. A formal language can be identified with the set of formulas in the language.|$|R
50|$|Formal proofs are {{sequences}} of <b>well-formed</b> <b>formulas</b> (or <b>wff</b> for short). For a wff {{to qualify as}} part of a proof, it might either be an axiom or be the product of applying an inference rule on previous wffs in the proof sequence. The last wff in the sequence is recognized as a theorem.|$|R
50|$|General Problem Solver or G.P.S. was a {{computer}} program created in 1959 by Herbert A. Simon, J.C. Shaw, and Allen Newell intended {{to work as a}} universal problem solver machine. Any problem that can be expressed as a set of <b>well-formed</b> <b>formulas</b> (<b>WFFs)</b> or Horn clauses, and that constitute a directed graph with one or more sources (viz., axioms) and sinks (viz., desired conclusions), can be solved, in principle, by GPS. Proofs in the predicate logic and Euclidean geometry problem spaces are prime examples of the domain the applicability of GPS. It was based on Simon and Newell's theoretical work on logic machines. GPS was the first computer program which separated its knowledge of problems (rules represented as input data) from its strategy of how to solve problems (a generic solver engine). GPS was implemented in the third-order programming language, IPL.|$|R
40|$|Writing correct {{programming}} code {{is necessary}} in computer system development, where complete testing is not possible. Intuitionistic type theory leads to a mechanical generation of correct code by using specifications. The {{idea is that the}} specification of a program is its type, and the specification can be expressed by logical statements called <b>well-formed</b> <b>formulas</b> (<b>wffs)</b> and therefore proved by using mathematical axioms and inference rules of logic. Then, using the correspondences propositions are types are specifications and proofs are programs are values [16], a proof can be translated into a correct programming code. The fundamental idea of realizability theory is that a proof can be translated into not only correct, but also minimal programming code, which contains only computational values. Based on these theories, a realizability algorithm developed by John Hatcliff defines how the translation can be done. We analyzed Hatcliff's algorithm and implemented it in a system. System [...] ...|$|R
40|$|AbstractWe {{focus on}} {{families}} of Pawlak approximation spaces, called multiple-source approximation systems (MSASs). These reflect {{the situation where}} information arrives from multiple sources. The behaviour of rough sets in MSASs is investigated – different notions of lower and upper approximations, and definability of a set in a MSAS are introduced. In this context, a generalized version of an information system, viz. multiple-source knowledge representation (KR) -system, is discussed. Apart from the indiscernibility relation which can be defined on a multiple-source KR-system, two other relations, viz. similarity and inclusion are considered. To facilitate formal reasoning with rough sets in MSASs, a quantified propositional modal logic LMSAS is proposed. Interpretations for sets of <b>well-formed</b> <b>formulae</b> (<b>wffs)</b> of LMSAS are defined on MSASs, and the various properties of rough sets in MSASs translate into logically valid wffs of the system. LMSAS is shown to be sound and complete {{with respect to this}} semantics. Some decidable problems are addressed. In particular, it is shown that for any LMSAS-wff α, it is possible to check whether α is satisfiable in a certain class of interpretations with MSASs of a given finite cardinality. Moreover, it is also decidable whether any wff α is satisfiable in the class of all interpretations with MSASs having domain of a given finite cardinality...|$|R
5000|$|In {{a formal}} language, a <b>well-formed</b> <b>formula</b> (or <b>wff)</b> is {{a string of}} symbols {{constituted}} {{in accordance with the}} rules of syntax of the language. A term is a variable, an individual constant or a n-place function letter followed by n terms. An atomic <b>formula</b> is a <b>wff</b> consisting of either a sentential letter or an n-place predicate letter followed by n terms. A sentence is a wff in which any variables are bound. An atomic sentence is an atomic formula containing no variables. It follows that an atomic sentence contains no logical connectives, variables or quantifiers. A sentence consisting of one or more sentences and a logical connective is a compound (or molecular sentence). See vocabulary in First-order logic ...|$|R
40|$|Abstract: A multiple-source {{approximation}} system (MSAS) is a tuple F: = (U, {Ri}i∈N), where U is a non-empty set, N {{an initial}} {{segment of the}} set N of positive integers, and each Ri, i ∈ N, is an equivalence relation on the domain U. A quantified propositional modal logic LMSAS was defined in [1] in order to study MSAS. In this paper, we will present an algebraic semantics for LMSAS. Syntax of the logic LMSAS is given as follows: There is a (i) a non-empty countable set V ar of variables, (ii) a (possibly empty) countable set Con of constants, (iii) a non-empty countable set P V of propositional variables and (iv) the propositional constants ⊤, ⊥. The set T of terms of the language is given by V ar ∪ Con. Using the standard Boolean logical connectives ¬ (negation) and ∧ (conjunction), a unary modal connective 〈t 〉 (possibility) for each term t ∈ T, and the universal quantifier ∀, <b>well-formed</b> <b>formulae</b> (<b>wffs)</b> of LMSAS are defined recursively as: ⊤|⊥|p|¬α|α ∧ β|〈t〉α|∀xα, where p ∈ P V, t ∈ T, x ∈ V ar, and α, β are wffs. The set of all wffs and closed wffs of LMSAS will be denoted by F and F respectively. For a wff α of LMSAS, Con(α) will denote the set of constants used in α. Let Γ be a set of wffs of LMSAS. An interpretation for Γ is given by a triple M: = (µ, V, I), where µ: = (U, {Ri}i∈N) is a MSAS, V: P V → P(U) and I: Con(Γ) → N. An assignment for a...|$|R
40|$|RUM (Reasoning with Uncertainty Module), is an {{integrated}} software tool {{based on a}} KEE, a frame system implemented in an object oriented language. RUM's architecture is composed of three layers: representation, inference, and control. The representation layer is based on frame-like data structures that capture the uncertainty information used in the inference layer and the uncertainty meta-information used in the control layer. The inference layer provides a selection of five T-norm based uncertainty calculi with which to perform the intersection, detachment, union, and pooling of information. The control layer uses the meta-information to select the appropriate calculus for each context and to resolve eventual ignorance or conflict in the information. This layer also provides a context mechanism that allows the system {{to focus on the}} relevant portion of the knowledge base, and an uncertain-belief revision system that incrementally updates the certainty values of <b>well-formed</b> <b>formulae</b> (<b>wffs)</b> in an acyclic directed deduction graph. RUM has been tested and validated in a sequence of experiments in both naval and aerial situation assessment (SA), consisting of correlating reports and tracks, locating and classifying platforms, and identifying intents and threats. An example of naval situation assessment is illustrated. The testbed environment for developing these experiments has been provided by LOTTA, a symbolic simulator implemented in Flavors. This simulator maintains time-varying situations in a multi-player antagonistic game where players must make decisions in light of uncertain and incomplete data. RUM has been used to assist one of the LOTTA players to perform the SA task. Comment: Appears in Proceedings of the Third Conference on Uncertainty in Artificial Intelligence (UAI 1987...|$|R
40|$|We {{describe}} an automatic programmer, or “compiler” which accepts as input a predicate calculus specification {{of a set}} to generate or a condition to test, along {{with a description of}} the underlying representation of the data. This compiler searches a space of possible algorithms for the one that is expected to be most efficient. We describe the knowledge that is and is not available to this compiler, and its corresponding capabilities and limitations. This compiler is now regularly used to produce large programs. 1. Int reduction This work is motivated by a desire to help programmers do their job better, i. e., more easily and quickly create and modify programs that are more efficient, correct and understandable. Our approach follows the well-travelled route of supplying a “higher level language ” which allows a programmer to say more of what he wants the machine to do and less of the details of how it is to be done. This leads to programs that are shorter, easier to understand and modify, and contain fewer bugs. However, higher level languages tend to degrade efficiency, since their compilers fail to make many optimizations that a human might make. In fact, some optimizations cannot even be expressed in the higher level language. Our higher level language, APS, is an extension of lisp in which programs can be written with much less commitment to particular algorithms or data representations. This is a benefit to the degree (which we believe is quite large) that programmers spend their effort dealing with these issues. One way to avoid thinking about data representation is to use a single powerful representation for all data. To some extent this is the approach of APL [Pakin 681, PROLOG [Clocksin 841 and Relational Databases [Ullman 821. This unfortunately results in a large performance penalty. APT, SETL [Schonberg 811 and MRS [Genesereth 811 provide the illusion of a uniform relational representation, but avoid the penalty by representing different relations with different data structures. APT goes further by accepting ‘*specifications ” that contain compound <b>well-formed</b> <b>formulas</b> (<b>wffs).</b> Its compiler assumes the responsibility of finding good algorithms t...|$|R
5000|$|... {{the set of}} <b>well-formed</b> <b>formulas</b> {{generated}} {{equals the}} set of <b>well-formed</b> <b>formulas</b> generated by classical logic.|$|R
2500|$|Completeness: If {{the set of}} <b>well-formed</b> <b>formulas</b> [...] semantically {{entails the}} <b>well-formed</b> <b>formula</b> [...] then [...] {{syntactically}} entails [...]|$|R
5000|$|... {{the set of}} <b>well-formed</b> <b>formulas</b> {{generated}} is {{a proper}} superset of the set of <b>well-formed</b> <b>formulas</b> generated by classical logic.|$|R
5000|$|Unary {{operators}} are <b>well-formed</b> <b>formulas</b> whenever B (...) is well-formed. Binary {{operators are}} <b>well-formed</b> <b>formulas</b> whenever B (...) and C (...) are well-formed.|$|R
5000|$|In formal languages, truth {{functions}} {{are represented by}} unambiguous symbols. These symbols are called [...] "logical connectives", [...] "logical operators", [...] "propositional operators", or, in classical logic, [...] "truth-functional connectives". See <b>well-formed</b> <b>formula</b> for the rules which allow new <b>well-formed</b> <b>formulas</b> to be constructed by joining other <b>well-formed</b> <b>formulas</b> using truth-functional connectives.|$|R
5000|$|The theorem is a {{syntactic}} {{consequence of}} all the <b>well-formed</b> <b>formulas</b> preceding it in the proof. For a <b>well-formed</b> <b>formula</b> to qualify {{as part of a}} proof, it must be the result of applying a rule of the deductive apparatus of some formal system to the previous <b>well-formed</b> <b>formulae</b> in the proof sequence.|$|R
5000|$|... #Caption: This diagram {{shows the}} {{syntactic}} entities {{which may be}} constructed from formal languages. The symbols and strings of symbols may be broadly divided into nonsense and <b>well-formed</b> <b>formulas.</b> A formal language {{is identical to the}} set of its <b>well-formed</b> <b>formulas.</b> The set of <b>well-formed</b> <b>formulas</b> may be broadly divided into theorems and non-theorems.|$|R
2500|$|The <b>well-formed</b> <b>formulas</b> of New Foundations (NF) are {{the same}} as the <b>well-formed</b> <b>formulas</b> of TST, but with the type {{annotations}} erased. The axioms of NF are: ...|$|R
50|$|Since biconditionality is an {{equivalence}} relation, any {{instance of}} ¬¬A in a <b>well-formed</b> <b>formula</b> {{can be replaced}} by A, leaving unchanged the truth-value of the <b>well-formed</b> <b>formula.</b>|$|R
5000|$|The <b>well-formed</b> <b>formulas</b> of New Foundations (NF) are {{the same}} as the <b>well-formed</b> <b>formulas</b> of TST, but with the type {{annotations}} erased. The axioms of NF are: ...|$|R
5000|$|Let , , and [...] {{stand for}} <b>well-formed</b> <b>formulas.</b> (The <b>well-formed</b> <b>formulas</b> {{themselves}} would not contain any Greek letters, but only capital Roman letters, connective operators, and parentheses.) Then the axioms are as follows: ...|$|R
5000|$|... #Caption: This diagram {{shows the}} {{syntactic}} divisions within a formal system. Strings of symbols may be broadly divided into nonsense and <b>well-formed</b> <b>formulas.</b> The set of <b>well-formed</b> <b>formulas</b> {{is divided into}} theorems and non-theorems.|$|R
5000|$|It is chiefly in logic or {{computer}} programming that recursive definitions are found. For example, a well formed <b>formula</b> (<b>wff)</b> {{can be defined}} as: ...|$|R
5000|$|... {{the set of}} theorems {{generated}} is {{a proper}} superset of the set of theorems generated by classical logic, both in that the quasi-deviant logic generates novel theorems using <b>well-formed</b> <b>formulas</b> held in common with classical logic, as well as novel theorems using novel <b>well-formed</b> <b>formulas.</b>|$|R
5000|$|This is the {{language}} of Peano arithmetic. A <b>well-formed</b> <b>formula</b> is a sequence of these symbols that is formed so as to have a well-defined reading as a mathematical formula. Thus [...] is well formed while [...] is not well formed. A theory is a set of <b>well-formed</b> <b>formulas</b> with no free variables.|$|R
2500|$|Logic, {{especially}} {{in the field of}} proof theory, considers theorems as statements (called formulas or well formed formulas) of a formal language. The statements of the language are strings of symbols and [...] may be broadly divided into nonsense and <b>well-formed</b> <b>formulas.</b> A set of deduction rules, also called transformation rules or rules of inference, must be provided. These deduction rules tell exactly when a formula can be derived from a set of premises. The set of <b>well-formed</b> <b>formulas</b> may be broadly divided into theorems and non-theorems. However, according to Hofstadter, a formal system often simply defines all its <b>well-formed</b> <b>formula</b> as theorems.|$|R
2500|$|For example, , is a <b>well-formed</b> <b>formula</b> of second-order {{arithmetic}} that is arithmetical, has {{one free}} set variable X and one bound individual variable n (but no bound set variables, as {{is required of}} an arithmetical formula)mdash&whereas [...] is a <b>well-formed</b> <b>formula</b> that is not arithmetical, having one bound set variable X and one bound individual variable n.|$|R
50|$|All other <b>well-formed</b> <b>formulae</b> are {{obtained}} by composing atoms with logical connectives and quantifiers.|$|R
