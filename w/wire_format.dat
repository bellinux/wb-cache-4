36|24|Public
50|$|OpenWire is {{a binary}} {{protocol}} designed {{for working with}} message-oriented middleware. It is the native <b>wire</b> <b>format</b> of ActiveMQ.|$|E
50|$|The <b>wire</b> <b>format</b> for {{records in}} the query section is {{slightly}} modified from that in unicast DNS, adding one single-bit field.|$|E
5000|$|The last {{version of}} RMDS, version 6, {{included}} Reuters <b>Wire</b> <b>Format</b> (RWF) {{as a major}} improvement to Marketfeed (MF) used in RMDS version 5 and prior technologies like Triarch, TIB.|$|E
50|$|The <b>wire</b> frame <b>format</b> is {{also well}} suited and {{widely used in}} {{programming}} tool paths for direct numerical control (DNC) machine tools.|$|R
5000|$|The spice-{{protocol}} module {{defines the}} SPICE <b>wire</b> protocol <b>formats.</b> This is made available under the BSD license, and is portable across the Linux and Windows platforms.|$|R
40|$|New {{trends in}} {{high-performance}} software development such as tool- and component-based approaches {{have increased the}} need for exible and high-performance communi-cation systems. High-performance computing applications are being integrated {{with a variety of}} software tools to allow on-line remote data visualization, enable real-time inter-action with remote sensors and instruments, and provide novel environments for human collaboration. There has also been a growing interest among high-performance researchers in component-based approaches, in an attempt to facilitate software evolution and pro-mote software reuse. When trying to reap the well-known benets of these approaches, the question of what communications infrastructure should be used to link the various components arises. In this context, exibility and high-performance seem to be incompatible goals. Tradi-tional HPC-style communication libraries, such as MPI, oer good performance, but are not intended for loosely-coupled systems. Object- and metadata-based approaches like XML oer the needed plug-and-play exibility, but with signicantly lower performance. We observe that the exibility and baseline performance of data exchange systems are strongly determined by their <b>wire</b> <b>formats,</b> or by how they represent data for transmission in the heterogeneous environments. After examining the performance implications of using a number of dierent <b>wire</b> <b>formats,</b> we propose an alternative approach for exible high-performance data exchange, Native Data Representation, and evaluate its current implementation in the Portable Binary I/O library. Index Terms: High-performance, distributed computing, communication, wire for-mat...|$|R
5000|$|Streaming Text Oriented Messaging Protocol (STOMP), {{formerly}} known as TTMP, is a simple text-based protocol, provides an interoperable <b>wire</b> <b>format</b> that allows STOMP clients to talk with any Message Broker supporting the protocol.|$|E
50|$|Note: The XML {{document}} {{describes the}} logical ordering {{of the fields}} for the protocol. The actual <b>wire</b> <b>format</b> (and typical in-memory representation) has the fields reordered to reduce Data structure alignment issues. This can {{be a source of}} confusion when reading the code generated from the message definitions.|$|E
5000|$|Jayrock is an {{open source}} (LGPL) {{implementation}} of JSON and JSON-RPC for Microsoft [...]NET Framework, including ASP.NET. Jayrock allows clients such as client-side web page JavaScript, {{to be able to}} call into server-side methods using JSON as the <b>wire</b> <b>format</b> and JSON-RPC as the procedure invocation protocol. The methods can be called synchronously or asynchronously.|$|E
5000|$|In practice, it {{does not}} matter if non-crossover Ethernet cables are wired as T568A or T568B, just so long as both ends follow the same <b>wiring</b> <b>format.</b> Typical commercially {{available}} [...] "pre-wired" [...] cables can follow either format depending on the manufacturer. What this means is that one manufacturer's cables are wired one way and another's the other way, yet both are correct and will work. In either case, T568A or T568B, a normal (un-crossed) cable will have both ends wired identically according to the layout in either the Connection 1 column or the Connection 2 column.|$|R
40|$|Definition and {{translation}} of metadata {{is incorporated in}} all systems that exchange structured data. We observe that the manipulation of his metadata can be decomposed into three separate steps: discovery of the metadata, binding of program objects to the message formats represented in the metadata, and marshaling of data to and from <b>wire</b> <b>formats</b> using the metadata. We have designed a method of representing message formats in XML, using datatypes available in the XML Schema specification. We have implemented a tool, xml 2 wire, that uses such metadata and exploits this decomposition {{in order to provide}} flexible metadata definition facilities for an efficient binary communications mechanism. We also observe that the use of xml 2 wire makes possible such flexibility without intolerable performance effects...|$|R
30|$|The {{notion of}} a {{framework}} for building monitoring tools is a novel break from the other tools surveyed in this paper. Conceptually Lattice {{can be used to}} build different monitoring tools for different use cases rather than reapplying existing tools to different uses cases. While this allow for the best fitting tools possible it requires significant labour to develop and test tools based upon Lattice. Lattice does not provide a library of probes, requiring the developer to implement their own library of data collection scripts, a significant limitation when compared to other tools including collectd and Nagios. Additionally, Lattice requires the developer to make design decisions regarding the distribution framework; which network architectures, <b>wire</b> <b>formats,</b> discovery mechanisms and so forth are used. This degree of effort is likely to be prohibitive to the vast majority of users.|$|R
50|$|Avro is {{a remote}} {{procedure}} call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Its primary use is in Apache Hadoop, where it can provide both a serialization format for persistent data, and a <b>wire</b> <b>format</b> for communication between Hadoop nodes, and from client programs to the Hadoop services.|$|E
50|$|Simple (or Streaming) Text Oriented Message Protocol (STOMP), {{formerly}} known as TTMP, is a simple text-based protocol, designed for working with message-oriented middleware (MOM). It provides an interoperable <b>wire</b> <b>format</b> that allows STOMP clients to talk with any message broker supporting the protocol. It is thus language-agnostic, meaning a broker developed for one programming language or platform can receive communications from client software developed in another language.|$|E
50|$|Usually XML {{objects are}} used when data {{needs to be}} {{transferred}} between processes, threads or systems, because this results in shorter message <b>wire</b> <b>format</b> and efficient data transfers. Once the data is transferred back to a program or an application, {{it needs to be}} converted back to an executable object for usage. Hence, unmarshalling is generally used in the receiver end of the implementations of Remote Method Invocation (RMI) and Remote Procedure Call (RPC) mechanisms to unmarshal transmitted objects in an executable form.|$|E
40|$|Nanoporous gold (NPG) {{electrodes}} were fabricated in {{film and}} <b>wire</b> array <b>formats</b> by selectively dealloying Ag from Au 0. 18 Ag 0. 82. The ammonia borane (AB) oxidation reaction was studied by cyclic voltammetry at the NPG electrodes. The onset {{potential for the}} oxidation at NPG in a <b>wire</b> array <b>format</b> shifted to more negative potentials than that observed at a Au disc and higher currents were realised. An onset potential of - 1. 30 V vs. SCE was recorded which is 0. 28 V lower than that at a Au disc. The oxidation current for 20 mM AB in 1 M NaOH increased from 2. 65 mA cm(- 2) at a Au disc to 13. 1 mA cm(- 2) at a NPG wire array. NPG is a viable candidate as an anode catalyst for a direct ammonia borane fuel cell...|$|R
40|$|Although most {{business}} application data {{is stored in}} relational databases, programming languages and <b>wire</b> <b>formats</b> in integration middleware systems are not table-centric. Due to costly format conversions, data-shipments and faster computation, the trend is to "push-down" the integration operations closer to the storage representation. We address the alternative case of defining declarative, table-centric integration semantics within standard integration systems. For that, we replace the current operator implementations for the well-known Enterprise Integration Patterns by equivalent "in-memory" table processing, and show a practical realization in a conventional integration system for a non-reliable, "data-intensive" messaging example. The results of the runtime analysis show that table-centric processing is promising already in standard, "single-record" message routing and transformations, and can potentially excel the message throughput for "multi-record" table messages. Comment: 18 Pages, extended version of the contribution to British International Conference on Databases (BICOD), 2015, Edinburgh, Scotlan...|$|R
40|$|High-performance {{computing}} faces considerable {{change as}} the Internet and the Grid mature. Applications that once were tightly-coupled and monolithic are now decentralized, with collaborating components spread across diverse computational elements. Such distributed systems most commonly communicate through the exchange of structured data. Definition and translation of metadata is incorporated in all systems that exchange structured data. We observe that the manipulation of this metadata can be decomposed into three separate steps: discovery, binding of program objects to the metadata, and marshaling of data to and from <b>wire</b> <b>formats.</b> We have designed a method of representing message formats in XML, using datatypes available in the XML Schema specification. We have implemented a tool, XMIT, that uses such metadata and exploits this decomposition {{in order to provide}} flexible run-time metadata definition facilities for an efficient binary communication mechanism. We also demonstrate that the use of XMIT makes possible such flexibility at little performance cost. 1...|$|R
5000|$|Canonically, {{messages}} are serialized into a binary <b>wire</b> <b>format</b> which is compact, forward- and backward-compatible, but not self-describing (that is, {{there is no}} way to tell the names, meaning, or full datatypes of fields without an external specification). There is no defined way to include or refer to such an external specification (...) within a Protocol Buffers file. The officially supported implementation includes an ASCII serialization format, but this format—though self-describing—loses the forward- and backward-compatibility behavior, and is thus not a good choice for applications other than debugging.|$|E
5000|$|Though it is standardized, full-zone {{transfer}} {{being described}} {{as one of}} the possible database replication mechanisms in RFC 1034 and RFC 5936 (incremental zone transfer described in RFC 1995), zone transfer is the most limited of those database replication mechanisms. Zone transfer operates in terms of [...] "wire format" [...] resource records, i.e. resource records as they are transferred using the DNS protocol. However, the schema of <b>wire</b> <b>format</b> resource records may not match the database schema used by the back ends of the DNS servers themselves.|$|E
5000|$|Every D-Bus message {{consists}} of a header and a body. The header is formed by several fields that identifies the type of message, the sender, {{as well as information}} required to deliver the message to its recipient (destination bus name, object path, method or signal name, interface name, etc.). The body contains the data payload that the receiver process interprets [...] - for instance the input or output arguments. All the data is encoded in a well known binary format called the <b>wire</b> <b>format</b> which supports the serialization of various types, such as integers and floating-point numbers, strings, compound types, and so on, also referred to as [...] marshaling.|$|E
40|$|Flexible and {{high-performance}} {{data exchange}} {{is becoming increasingly}} important. This trend {{is due in part}} to the growing interest among high-performance researchers in tool- and component-based approaches to software development. In trying to reap the well-known benefits of these approaches, the question of what communications infrastructure should be used to link the various application components arises. Traditional HPC-style communication libraries such as MPI offer good performance, but are not intended for loosely-coupled systems. Object- and metadata-based approaches like XML offer the needed plug-and-play flexibility, but with significantly lower performance. We observe that the flexibility and baseline performance of data exchange systems are strongly determined by their "wire formants," or by how they represent data for transmission in the heterogeneous environments. Upon examining the performance implications of using a number of different <b>wire</b> <b>formats,</b> we propose an alternative approach to flexible high-performance data exchange, Native Data Representation, and evaluate its current implementation in the Portable Binary I/O library...|$|R
40|$|We discuss {{approaches}} to {{approaches to}} synthesis of high efficiency low cost photovoltaics that employ single crystal GaAs and Si in thin film and <b>wire</b> array <b>formats.</b> A common theme {{is the use}} of lift-off processes that enable cell fabrication without consumption of a thick crystalline wafer per cell. Use of single crystal materials enables the achievement of high open circuit voltages relative to polycrystalline materials...|$|R
40|$|A Java {{application}} is built {{of a large}} number of Java class files, which are collected and compressed in Java archive (jar) files. But the jar files typically shrink original class files by only fifty percent. Various projects have pursued ever smaller class files and they achieved very impressive results, but these results come at the cost of complicated and slow transformations. The class archive (car) format is an alternative for groups of class files. Car files are between one third and two thirds of the size of the corresponding jar files and between one seventh and one half of the size of the original class files. Although there are more compact archive formats, the car tools themselves are smaller and take far less time than the alternatives. This article also introduces a method to compare <b>wire</b> <b>formats.</b> The method does not only consider the size of the archive but also the bandwidth and the decompression speed. This method demonstrates that car is a better archive format in many situations...|$|R
40|$|This thesis {{presents}} {{the development of}} a <b>wire</b> <b>format</b> for Java applications. Whereas file formats, such as the Java class file format, put nowadays the emphasis on the ease with which they can be manipulated {{at the expense of the}} space they need, a <b>wire</b> <b>format</b> is specialized to achieve short transmission times. A <b>wire</b> <b>format</b> puts hence the emphasis on the space needed and takes a complex decoding step into account. The thesis {{presents the}} principal features of code systems, such as how the programs are represented, how they are executed and how portable the resulting environments are; it builds with these features a taxonomy of code systems. The special requirements of mobile code systems are discussed in this context. Java class files belong to the category of object files, which are files that contain compiled code. All these files have a strict syntax and are frequently transformed to acquire specific properties, such as a smaller size. The thesis discusses the tools and techniques used to reduce the file size. The thesis presents for the first time detailed results of the analysis of Java applications. Beside external characteristics, such as the size and number of files, the analysis explores the content of the files. The development of the <b>wire</b> <b>format</b> takes place in two stages. In the first stage, the format of the class file is changed in order to reduce the size of individual files. In the second stage, redundancies are detected in groups of classes and the format is adapted to take advantage of them. All these transformations are confirmed experimentally. Abstract ii Compressing Java Binaries Finally, a measure of the distance between two classes is introduced. With this measure, data clustering algorithms can be used to define groups of [...] ...|$|E
40|$|Component frameworks, {{including}} those supporting the Common Component Architecture (CCA), comprise the software infrastructure necessary for disjoint components to interact and coordinate to accomplish an application’s task. The CCA specification does not prescribe a <b>wire</b> <b>format</b> for inter-component calls in distributed frameworks, thereby promoting considerable flexibility and customization for the framework developer. This approach thus requires an additional specific strategy {{outside of the}} CCA to support interoperability between distributed frameworks. Mandating one common <b>wire</b> <b>format,</b> however, risks choosing the wrong format. This paper describes one solution to this problem, namely {{the use of a}} common, multiprotocol messaging layer within two disjoint framework implementations. The Proteus multi-protocol communication layer will allow the Legion-CCA and XCAT-C++ CCA framework implementations to support component-based applications to span the two distributed frameworks. This paper describes working implementations of Proteus within both Legion and XCAT-C++, and outlines plans for full integration and communication interoperability. ...|$|E
40|$|InterWeave is a {{middleware}} {{system that}} supports the sharing of strongly typed data structures across heterogeneous languages and machine architectures. Java presents special challenges for InterWeave, including write detection, data translation, and the interface with the garbage collector. In this paper, we discuss our implementation of J-InterWeave, a JVM based on the Kaffe virtual machine and on our locally developed InterWeave client software. J-InterWeave uses bytecode instrumentation to detect writes to shared objects, and leverages Kaffe's class objects to generate type information for correct translation between the local object format and the machineindependent InterWeave <b>wire</b> <b>format.</b> Experiments indicate that our bytecode instrumentation imposes less than 2 % performance cost in Kaffe interpretation mode, and less than 10 % overhead in JIT mode. Moreover, JInterWeave 's translation between local and <b>wire</b> <b>format</b> is more than 8 {{times as fast as}} the implementation of object serialization in Sun JDK 1. 3. 1 for double arrays. To illustrate the flexibility and efficiency of J-InterWeave in practice, we discuss its use for remote visualization and steering of a stellar dynamics simulation system written in C...|$|E
40|$|Name {{services}} {{are critical for}} mapping logical resource names to physical resources in large-scale distributed systems. The Domain Name System (DNS) used on the Internet, however, is slow, vulnerable to denial of service attacks, and does not support fast updates. These problems stem fundamentally from {{the structure of the}} legacy DNS. This paper describes the design and implementation of the Cooperative Domain Name System (CoDoNS), a novel name service, which provides high lookup performance through proactive caching, resilience to denial of service attacks through automatic load-balancing, and fast propagation of updates. CoDoNS derives its scalability, decentralization, self-organization, and failure resilience from peer-to-peer overlays, while it achieves high performance using the Beehive replication framework. Cryptographic delegation, instead of host-based physical delegation, limits potential malfeasance by namespace operators and creates a competitive market for namespace management. Backwards compatibility with existing protocols and <b>wire</b> <b>formats</b> enables CoDoNS to serve as a backup for legacy DNS, as well as a complete replacement. Performance measurements from a real-life deployment of the system in PlanetLab shows that CoDoNS provides fast lookups, automatically reconfigures around faults without manual involvement and thwarts distributed denial of service attacks by promptly redistributing load across nodes...|$|R
40|$|Nanoporous gold (NPG) {{electrodes}} were fabricated in {{film and}} <b>wire</b> array <b>formats</b> by selectively dealloying Ag from Au 0. 18 Ag 0. 82. Borohydride oxidation reaction (BOR) was studied by cyclic voltammetry at the NPG electrodes. The onset {{potential for the}} oxidation at NPG in a <b>wire</b> array <b>format</b> shifted to more negative potentials that than observed at an Au disc and higher currents were realized. An onset potential of − 1. 07 V vs SCE which is 0. 207 V lower than that at an Au disc was recorded. The oxidation current for 20 mM borohydride in 1 M NaOH increased to 73. 6 mA cm− 2 from 3. 17 mA cm- 2 at an Au disc. An n value of 7. 49 was determined for the oxidation peak at high potential (− 0. 49 V) while a value of 4. 26 was determined at low potential for the oxidation plateau centered at − 0. 05 V. NPG presents an attractive alternative to gold nanoparticle-based catalysts for use in direct borohydride fuel cells. NPG can establish intimate contact with an electrical substrate and {{eliminates the need for}} a carbon support...|$|R
40|$|International audienceTLS is {{possibly}} the most used protocol for secure communications, with a 18 -year history of flaws and fixes, ranging from its protocol logic to its cryptographic design, and from the Internet standard to its diverse implementations. We develop a verified reference implementation of TLS 1. 2. Our code fully supports its <b>wire</b> <b>formats,</b> ciphersuites, sessions and connections, re-handshakes and resumptions, alerts and errors, and data fragmentation, as prescribed in the RFCs; it interoperates with mainstream web browsers and servers. At the same time, our code is carefully structured to enable its modular, automated verification, from its main API down to computational assumptions on its cryptographic algorithms. Our implementation is written in F# and specified in F 7. We present security specifications for its main components, such as authenticated stream encryption for the record layer and key establishment for the handshake. We describe their verification using the F 7 typechecker. To this end, we equip each cryptographic primitive and construction of TLS with a new typed interface that captures its security properties, and we gradually replace concrete implementations with ideal functionalities. We finally typecheck the protocol state machine, and obtain precise security theorems for TLS, as it is implemented and deployed. We also revisit classic attacks and report a few new ones...|$|R
40|$|We {{present an}} {{abstract}} machine that encodes both type safety and control safety in an efficient manner {{and that is}} suitable as a mobile-code format. At the code consumer, a single linear-complexity algorithm performs not only verification, but simultaneously also transforms the stack-based <b>wire</b> <b>format</b> into a register-based internal format. The latter is beneficial for interpretation and native code generation. Our dual-representation approach overcomes some of the disadvantages of existing mobile-code representations, such as the JVM and CLR wire formats...|$|E
40|$|This {{document}} specifies an Internet standards track {{protocol for}} the Internet community, and requests discussion {{and suggestions for}} improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2004). This document redefines the <b>wire</b> <b>format</b> of the "Type Bit Map " field in the DNS NextSECure (NSEC) resource record RDATA format to cove...|$|E
40|$|Component frameworks, {{including}} those that support the Common Component Architecture (CCA), represent a promising approach to addressing this challenge, one that is being realized, for example, in our LegionCCA and XCAT-C++ frameworks. The next step beyond building independent individual frameworks is making them interoperate. Component-based applications {{should be able to}} transparently span multiple disjoint component frameworks with low overhead as compared to the same applications running within a single framework. Interoperable frameworks enable applications to take advantage of more resources, and to better match constituent parts to the underlying resources that best support them. The CCA specification does not prescribe a <b>wire</b> <b>format</b> for inter-component calls in distributed frameworks, thereby promoting considerable flexibility and customization for the framework developer. This approach thus requires an additional specific strategy outside of the CCA to support interoperability between distributed frameworks. Mandating one common <b>wire</b> <b>format,</b> however, risks choosing the wrong format. We discuss in detail five underlying component framework interoperability requirements, and three general approaches to addressing them. We then discuss how the approaches can be applied to meet the requirements, and address the advantages, issues, and implications of doing so. This effectively defines a design space for framework interoperability approaches. We then address the communication interoperability in detail via a single multiprotocol communication library called Proteus, and discuss how we have incorporated it into two distinct distributed framework implementations of the CCA specification: LegionCC...|$|E
5000|$|The {{station was}} {{mentioned}} as officially opening its new studios {{on the show}} [...] "Nightbeat" [...] on October 27, 1950. For most of the 1960s, 70s and 80s, its programming consisted of country music, which proved an enormous ratings success. In 1970, <b>WIRE's</b> country <b>format</b> was {{number one in the}} Indianapolis radio market with a 25.6 Pulse rating share, also making it the highest-rated country station in the nation, according to a 1970 Billboard magazine article. [...] But over time, country music fans shifted their listening to FM radio.|$|R
40|$|In {{an effort}} to develop {{low-cost}} solar energy conversion techniques, high uniformity vertically oriented silicon wire arrays have been fabricated. These arrays, which allow for radial diffusion of minority charge carriers, have been measured in a photoelectrochemical cell. Large photovoltages (∼ 400 mV) have been measured, and these values are significantly greater than those obtained from the substrate alone. Additionally, the wire array samples displayed much higher current densities than the underlying substrate, demonstrating that significant energy conversion was occurring due to the absorption and charge-carrier transport in the vertically aligned Si wires. This method therefore represents {{a step toward the}} use of collection-limited semiconductor materials in a <b>wire</b> array <b>format</b> in macroscopic solar cell devices...|$|R
40|$|Web Services {{is gaining}} {{popularity}} in distributed computing {{due to its}} loosely-coupled, high-interoperable and platform-independent characteristics. However, web services suffers performance penalty because XML based SOAP is used to specify <b>wire</b> message <b>format,</b> and SOAP processing largely affects the performance of web services. In this paper, we identify that data model mapping between XML data and Java data is the main impact factor on performance, and propose a new paradigm of data model mapping- “Dynamic Early Binding ” which enables to improve SOAP processing by avoiding Java reflection operations and proactively generating processing codes. This dynamic early binding is realized by Data Mapping Template (DMT), which is specified by extended context free grammar and implemented by pushdown automaton with output. We illustrate the effectiveness by applying it into a SOAP engine- SOAPExpress, and yielding over 100 % speedups compared to Apache Axis 1. 2 in our benchmark...|$|R
