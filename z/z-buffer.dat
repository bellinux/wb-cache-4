319|23|Public
500|$|For the game, Crash Bandicoot co-creator Andy Gavin {{programmed}} a {{new engine}} named [...] "Game-Oriented Object LISP 2" [...] (GOOL 2); being three {{times faster than}} the previous game's engine, it could handle ten times the animation frames and twice the polygon count. Crash Bandicoot - Time Line ] |publisher=Naughty Dog |accessdate=March 10, 2010}} A flat plane <b>z-buffer</b> was created for the game; because the water surfaces and mud in the jungle had to be a flat plane and be exactly flat on the Y-axis, there could be no waves and the subdividing plane could not be at an odd angle. The effect only worked on objects in the foreground and was only used on Crash, some enemies and a few boxes at the same time.|$|E
500|$|Production of Crash Bandicoot: Warped {{began on}} January 1998, with Naughty Dog given only ten {{and a half}} months and a budget of 2.2 million to {{complete}} the game. Crash Bandicoot - Time Line ] |publisher=Naughty Dog |accessdate=April 4, 2010 |deadurl=yes |df= }} Programmers Andy Gavin, Stephen White and Greg Omi created three new gameplay engines for the game. Two of the three new engines were three-dimensional in nature and were created for the airplane and jet-ski levels; the third new engine was created for the motorcycle levels in the style of a driving simulator. The new engines combined make up a third of the game, while the other two-thirds of the game consist of the same engine used in the previous games. Jason Rubin explained that the [...] "classic" [...] engine and game style was preserved due {{to the success of the}} previous two games and went on to say that [...] "were we to abandon that style of gameplay, that would mean that we would be abandoning a significant proportion of gamers out there." [...] An arbitrary plane <b>z-buffer</b> was created for the jet-ski and flooded Egyptian hallway levels of the game. To create a completely fluid feel for the water on these levels, an environment map that reflects the sky was fitted onto the surface of the water. A real shadow was given to the Crash character at the request of the Sony Computer Entertainment America producers, who were [...] "sick of that little discus that's following him around." [...] To create an [...] "arcade" [...] experience in the airplane levels and to differentiate them from flight simulators, the enemy planes were programmed to come out in front of the player and give the player ample time to shoot them before they turn around and shoot the player rather than come up behind the player and hit them from behind. The Relic system was introduced to give players a reason to return to the game after it has been completed.|$|E
5000|$|The {{granularity}} of a <b>z-buffer</b> has a {{great influence}} on the scene quality: a 16-bit <b>z-buffer</b> can result in artifacts (called [...] "z-fighting" [...] or stitching) when two objects {{are very close to}} each other. A 24-bit or 32-bit <b>z-buffer</b> behaves much better, although the problem cannot be entirely eliminated without additional algorithms. An 8-bit <b>z-buffer</b> is almost never used since it has too little precision.|$|E
5000|$|... 3 Million fully {{featured}} triangles/sec (Filtered, LOD MIP-mapped, <b>Z-buffered,</b> alpha-blended, fogging enabled, textured triangles).|$|R
40|$|We {{present an}} {{architecture}} for a hogh-performance programmable rendering engine. This chip or chip-set {{will be able}} to deliver one Gouraud-shaded, <b>z-buffered,</b> texture-modulated and alphablended pixel every clock cycle. Focus of the paper is the derivation of the architecture of the pixel processing block from the applied algorithms. (IGD...|$|R
40|$|We {{present a}} <b>z-buffered</b> image-space-based {{rendering}} technique that allows navigation in complex static environments. The rendering speed is relatively {{insensitive to the}} complexity of the scene as the rendering is performed apriori, and the scene is converted into a bounded complexity representation in the image space. Realtime performance is attained by using hardware texture mapping to implement the image-space warping and hardware affine transformations to compute the viewpoint [...] dependent warping function. Our proposed method correctly simulates the kinetic depth effect (parallax), occlusion, and can resolve the missing visibility information by combining <b>z-buffered</b> environment maps from multiple viewpoints. CRCategories and Subject Descriptors: I. 3. 3 [Computer Graphics]: Picture/Image Generation - Display Algorithms, Viewing Algorithms; I. 3. 7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Animation, Texture; I. 4. 8 [Image Processing]: Scene Analysis - Range data. A [...] ...|$|R
5000|$|Fast Z clear [...] - [...] Rather than writing zeros {{throughout}} the entire <b>Z-buffer,</b> and thus using the bandwidth of another <b>Z-Buffer</b> write, a Fast Z Clear technique is used that can tag entire blocks of the <b>Z-Buffer</b> as cleared, such that only each of these blocks need be tagged as cleared. On Radeon 8500, ATI claimed that this process could clear the <b>Z-Buffer</b> up to approximately 64 times faster {{than that of a}} card without fast Z clear.|$|E
50|$|The {{irregular}} <b>Z-buffer</b> is an algorithm {{designed to}} solve the visibility problem in real-time 3-d computer graphics. It {{is related to the}} classical <b>Z-buffer</b> in that it maintains a depth value for each image sample and uses these to determine which geometric elements of a scene are visible. The key difference, however, between the classical <b>Z-buffer</b> and the irregular <b>Z-buffer</b> is that the latter allows arbitrary placement of image samples in the image plane, whereas the former requires samples to be arranged in a regular grid.|$|E
50|$|The <b>Z-buffer</b> is a {{technology}} used {{in almost all}} contemporary computers, laptops and mobile phones for performing 3D graphics, for example for computer games. The <b>Z-buffer</b> is implemented as hardware in the silicon ICs (integrated circuits) within these computers. The <b>Z-buffer</b> is also used (implemented as software as opposed to hardware) for producing computer-generated special effects for films.|$|E
50|$|The {{technique}} {{was used in}} the first Quake engine for software rendering of environments (but moving objects were <b>Z-buffered</b> over the top). Static scenery used BSP-derived sorting for priority. It proved better than Z-buffer/painter's type algorithms at handling scenes of high depth complexity with costly pixel operations (i.e. perspective-correct texture mapping without hardware assist). This use preceded the widespread adoption of Z-buffer-based GPUs now common in PCs.|$|R
50|$|Even {{with small}} enough granularity, quality {{problems}} may arise when precision in the <b>z-buffer's</b> distance values is not spread evenly over distance. Nearer values {{are much more}} precise (and hence can display closer objects better) than values which are farther away. Generally, this is desirable, but sometimes it will cause artifacts to appear as objects become more distant. A variation on z-buffering which results in more evenly distributed precision is called w-buffering (see below).|$|R
40|$|A pair of {{rendered}} {{images and}} their <b>Z-buffers</b> contain {{almost all of}} the information necessary to re-render from nearby viewpoints. For the small changes in viewpoint that occur in a fraction of a second, this information is sufficient for high quality re-rendering with cost independent of scene complexity. Re-rendering from previously computed views allows an order-of-magnitude increase in apparent frame rate over that provided by conventional rendering alone. It can also compensate for system latency in local or remote display. We us...|$|R
5000|$|To {{implement}} a <b>z-buffer,</b> {{the values of}} [...] are linearly interpolated across screen space between the vertices of the current polygon, and these intermediate values are generally stored in the <b>z-buffer</b> in fixed point format.|$|E
50|$|All PXG {{variants}} {{are capable}} of either 8-bit or 24-bit color, a resolution of 1280 × 1024 and a refresh rate of either 66 or 72 Hz. The PXG also has an 8-bit or 24-bit <b>Z-buffer</b> and is double buffered. The color depth {{and the depth of}} <b>Z-buffer</b> can be extended by installing additional VSIMMs or <b>Z-buffer</b> modules on the module. The PXG Turbo variants {{are capable of}} 24-bit color, a resolution of 1280 × 1024 and a refresh rate of either 66 or 72 Hz. They differ by featuring a 24-bit buffer for storing off-screen pixmaps in addition to the 24-bit <b>Z-buffer</b> and double buffer.|$|E
5000|$|Z {{compression}} [...] - [...] The <b>Z-buffer</b> {{is stored}} in a lossless compressed format to minimize the <b>Z-Buffer</b> bandwidth as Z read or writes are taking place. The compression scheme ATI used on Radeon 8500 operated 20% more effectively than on the original Radeon 256.|$|E
40|$|We {{present a}} <b>z-buffered</b> image-space-based {{rendering}} technique that allows navigation in complex static environments. The rendering speed is relatively {{insensitive to the}} complexity of the scene as the rendering is performed a priori, and the scene is converted into a bounded complexity representation in the image space. Real-time performance is attained by using hardware texture mapping to implement the imagespace warping and hardware fine transformations to compute the viewpoint-dependent warping function. Our pro posed method correctly simulates the kinetic depth effect (parallax), occlusion, and can resolve the missing visibility information by combining z-bufTered environment maps from multiple viewpoints...|$|R
40|$|In {{this paper}} we {{describe}} a real-time shadow generation with volume shadow algorithm in virtual {{environment that is}} illuminated by light sources with possibility to move separately. This algorithm uses the combination of stencil and <b>Z-buffers</b> to generate shadow volume. It is simple to understand and implement. We have significantly improved and implemented recent techniques {{that are used in}} shadow volume algorithms using stencil buffers especially in order to recognize silhouette, reduce the number of shadow polygons and also redundant length of each triangles that makes the volume shadow. This work may be applied in commercial games or other virtual reality systems...|$|R
50|$|One key {{disadvantage}} of deferred rendering is {{the inability to}} handle transparency within the algorithm, although this problem is a generic one in <b>Z-buffered</b> scenes and {{it tends to be}} handled by delaying and sorting the rendering of transparent portions of the scene. Depth peeling can be used to achieve order-independent transparency in deferred rendering, but at the cost of additional batches and g-buffer size. Modern hardware, supporting DirectX 10 and later, is often capable of performing batches fast enough to maintain interactive frame rates. When order-independent transparency is desired (commonly for consumer applications) deferred shading is no less effective than forward shading using the same technique.|$|R
5000|$|Z-buffering During {{rasterization}} the depth/Z {{value of}} each pixel (or sample {{in the case of}} anti-aliasing, but without loss of generality the term pixel is used) is checked against an existing depth value. If the current pixel is behind the pixel in the <b>Z-buffer,</b> the pixel is rejected, otherwise it is shaded and its depth value replaces the one in the <b>Z-buffer.</b> Z-buffering supports dynamic scenes easily, and is currently implemented efficiently in graphics hardware. This is the current standard. The cost of using Z-buffering is that it uses up to 4 bytes per pixel, and that the rasterization algorithm needs to check each rasterized sample against the <b>z-buffer.</b> The <b>z-buffer</b> can also suffer from artifacts due to precision errors (also known as z-fighting).|$|E
5000|$|Hierarchical <b>Z-buffer</b> [...] - [...] This feature {{allows for}} the pixel being {{rendered}} to be checked against the <b>z-buffer</b> before the pixel actually arrives in the rendering pipelines. This allows useless pixels to be thrown out early (Early Z Reject), before the Radeon has to render them.|$|E
5000|$|The <b>z-buffer</b> {{resolution}} {{in terms of}} camera space would be the incremental value resulted from the smallest change in the integer stored in the <b>z-buffer,</b> which is +1 or -1. Therefore this resolution can be calculated from the derivative of [...] {{as a function of}} : ...|$|E
5000|$|Coverage buffers (C-Buffer) and Surface buffer (S-Buffer): {{faster than}} <b>z-buffers</b> and {{commonly}} used in games in the Quake I era. Instead of storing the Z value per pixel, they store list of already displayed segments per line of the screen. New polygons are then cut against already displayed segments that would hide them. An S-Buffer can display unsorted polygons, while a C-Buffer requires polygons to be displayed from the nearest to the furthest. Because the C-buffer technique {{does not require a}} pixel to be drawn more than once, the process is slightly faster. This was commonly used with binary space partitioning (BSP) trees, which would provide sorting for the polygons.|$|R
40|$|A {{parallel}} algorithm for the rasterization of polygons {{is presented}} {{that is particularly}} well suited for 3 D <b>Z-buffered</b> graphics implementations. The algorithm represents each edge of a polygon by a linear edge function that has a value greater than zero {{on one side of}} the edge and less than zero on the opposite side. The value of the function can be interpolated with hardware similar to hardware required to interpolate color and Z pixel values. In addition, the edge function of adjacent pixels may be easily computed in parallel. The coefficients of the "Edge function " can be computed from floating point endpoints in such a way that sub-pixel precision of the endpoints can be retained in an elegant way. CR catagories and subject descriptors: 1. 3. 1 [Computer Graphics]...|$|R
40|$|Games are {{commonly}} programmed in imperative languages. Functional languages {{have been known}} to have benefits but have rarely been used to program games. In this thesis we implement a first person shooting game in Haskell and Yampa. The merits of this approach are examined. 2 Acknowledgements Big thanks goes to Sean Seefried who I frequently turn to for programming and writing advice. Thanks to Dr Manual Chakravarty, who allowed me to do a thesis that is game related, which is something I have great interest in, and gave me help and advice Thanks to Don Stewart and André Pang for the help they offered. Finally, big, big, thanks goes to the community who write game related programming tutorials. Their tutorials that tackle topics from Alpha testing to <b>Z-buffers</b> helped me write this game...|$|R
50|$|Consequently, in {{contemporary}} interactive graphics applications, the <b>Z-buffer</b> has become ubiquitous. The <b>Z-buffer</b> allows larger volumes of primitives to be traversed linearly, in parallel, {{in a manner}} friendly to modern hardware. Transformed coordinates, attribute gradients, etc., need never leave the graphics chip; only the visible pixels and depth values are stored.|$|E
5000|$|... {{hardware}} <b>z-buffer</b> (16-bit) (actually a {{block floating}} point with multiple (4) range w-buffer) ...|$|E
50|$|Whether a <b>z-buffer</b> or w-buffer {{results in}} a better image depends on the application.|$|E
40|$|Current {{graphics}} {{systems have}} reached the capability of rendering millions of transformed, shaded and <b>z-buffered</b> polygons per second [3, 14]. However in many applications involving CAD/CAM, virtual reality, animation and visualization the object models are {{described in terms of}} non-uniform rational B-spline (NURBS) surfaces. This class includes B'ezier surfaces and other rational parametric surfaces like tensor product and triangular patches. Large scale models consisting of thousands of such surfaces are commonly used to represent shapes of automobiles, submarines, airplanes, building architectures, sculptured models, mechanical parts and in applications involving surface fitting over scattered data or surface reconstruction. Current renderers of sculptured models on commercial graphics systems, while faster than ever before, are not able to render them in real time for applications involving virtual worlds, walkthroughs and other immersive technologies...|$|R
5000|$|Nevertheless, {{several of}} the ideas pioneered in the Talisman system have since become common in most accelerators. In particular, texture {{compression}} is now widely used. On more recent cards, compression has also been used on the <b>z-buffers</b> to reduce memory demands while sorting the display. The idea of using [...] "chunks" [...] to sort the display has also been used in {{a small number of}} cards, referred to as tile based rendering, but like Talisman in general these have never become competitive in the desktop space due to the rapid changes in the market. However, many recent graphics processors specifically designed for mobile devices (such as cell phones) employ a tile-based approach. Only the one key idea of Talisman, asking for updates to geometry only [...] "when needed", has not been attempted since.|$|R
40|$|We present serial and {{parallel}} algorithms for interactive rendering of large scale and complex NURBS models on current graphics systems. The algorithms tessellate the NURBS surfaces into triangles and render them using triangle rendering engines. The main {{characteristics of the}} algorithms are handling of arbitrary surface topologies, the exploitation of spatial and temporal coherence, optimal polygonization, and back-patch culling. Polygonization anomalies like cracks and angularities are avoided as well. We analyze {{a number of issues}} in parallelization of these techniques, as well. The algorithms work well in practice and are able to display models consisting of thousands of surfaces at interactive frame rates. on the highly parallel graphics system, Pixel-Planes 5. 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and <b>z-buffered</b> polygons per second [Ake 93, Fea 89]. However in many applications involving CAD/CAM, virtu [...] ...|$|R
5000|$|Random {{access of}} frame buffer and <b>z-buffer</b> (actually w-buffer) {{possible}} {{at the same}} time ...|$|E
50|$|When {{an object}} is rendered, {{the depth of}} a {{generated}} pixel (z coordinate) is stored in a buffer (the <b>z-buffer</b> or depth buffer). This buffer is usually arranged as a two-dimensional array (x-y) with one element for each screen pixel. If another object of the scene must be rendered in the same pixel, the method compares the two depths and overrides the current pixel if the object {{is closer to the}} observer. The chosen depth is then saved to the <b>z-buffer,</b> replacing the old one. In the end, the <b>z-buffer</b> will allow the method to correctly reproduce the usual depth perception: a close object hides a farther one. This is called z-culling.|$|E
5000|$|RAM {{configured}} into 4 Megabytes for frame buffer(s) and <b>Z-buffer</b> and 4 or 8 Megabytes texture memory.|$|E
40|$|We {{present a}} new {{computer}} graphics rendering architecture that allows “all possible views ” to be extracted from a single traversal of a scene description. It supports {{a wide range of}} rendering primitives, including polygonal meshes, higher-order surface primitives (e. g. spheres, cylinders, and parametric patches), point-based models, and image-based representations. To demonstrate our concept, we have implemented a hardware prototype that includes a 4 D, <b>z-buffered</b> frame-buffer supporting dynamic view selection at the time of raster scan-out. As a result, our implementation supports extremely low display-update latency. The PixelView architecture also supports rendering of the same scene for multiple eyes, which provides immediate benefits for stereo viewing methods like those used in today’s virtual environments, particularly when there are multiple participants. In the future, view-independent graphics rendering hardware will also be essential to support the multitude of viewpoints required for real-time autostereoscopic and holographic display devices...|$|R
40|$|When the {{original}} design of the algorithm for Binary Space Partitioning (BSP) -trees was formulated {{the idea was to}} use it to sort the polygons in the world. The reason for this was there did not exist hardware accelerated Zbuffers, and software Z-buffering was too slow. Today that area of usage is obsolete, since hardware accelerated <b>Z-buffers</b> exist. Instead the usage is to optimise a wide variety of areas, such as radiosity calculations, drawing of the world, collision detection and networking. We set out to examine the areas where one can draw advantages of the structure supplied and study the generating process. As conclusion a BSP-tree is a very useful structure in most game engines. Although there are some drawbacks with it, such as that it is static and it is very expensive to modify during run-time. Hopefully some ideas can be taken from the BSP-tree algorithm to develop a more dynamic structure that ha...|$|R
40|$|We {{present a}} new method {{for the global}} {{registration}} of several overlapping 3 D surfaces sampled on an object. The method {{is based on the}} ICP algorithm and on a segmentation of the sampled points in an optimized set of <b>z-buffers.</b> This multi-z-buffer technique provides a 3 D space partitioning which greatly accelerates the search of the nearest neighbours in the establishment of the point-to-point correspondence between overlapping surfaces. Then a randomized iterative registration is processed on the surface set. We have tested an implementation of this technique on real sampled surfaces. It appears to be rapid, accurate and robust, {{especially in the case of}} highly curved objects. 1. Introduction A single scan of a complex 3 D object is in general not sufficient to fully describe its surface because of the presence of occluded parts. Additional scans from different view points are thus required to recover the occluded parts and improve the surface description. To reach these different vie [...] ...|$|R
