17|10|Public
50|$|The {{first problem}} to {{consider}} {{is whether or not}} to draw a pixel at all. For a pixel to be rendered, it must be within a triangle, and it must not be occluded, or blocked by another pixel. There are a number of algorithms to fill in pixels inside a triangle, the most popular of which is the scanline algorithm. Since {{it is difficult to know}} that the rasterization engine will draw all pixels from front to back, there must be some way of ensuring that pixels close to the viewer are not overwritten by pixels far away. A <b>z</b> <b>buffer</b> is the most common solution. The <b>z</b> <b>buffer</b> is a 2d array corresponding to the image plane which stores a depth value for each pixel. Whenever a pixel is drawn, it updates the <b>z</b> <b>buffer</b> with its depth value. Any new pixel must check its depth value against the <b>z</b> <b>buffer</b> value before it is drawn. Closer pixels are drawn and farther pixels are disregarded.|$|E
5000|$|Pixel configuration: RGB: Alpha:Z Buffer (24:8, 15:1 for RGB, 16, 24, or 32-bit <b>Z</b> <b>buffer)</b> ...|$|E
5000|$|Not unlike its Personal IRIS variant, IrisVision {{was capable}} of {{handling}} 8-bit and 24-bit raster images with a 24-bit <b>Z</b> <b>buffer.</b> The difference lay in that all this was integrated with a fifth generation Geometry Engine without having to upgrade the cards themselves. Around the same time, SGI was preparing to introduce the next series of graphics cards for their IRIS Indigo workstations, called [...] "Express Graphics", which came in two variants for the Personal IRIS: Turbo Graphix and the Elan Graphics pipeline, both of them an evolution of IrisVision.|$|E
5000|$|... pinterp interpolates {{between two}} images {{provided}} {{they both have}} <b>z</b> <b>buffers.</b> Uses rtrace to fill in gaps. Is used {{to speed up the}} rendering speed of simple animations.|$|R
5000|$|Depth peeling {{works by}} {{rendering}} the image multiple times. The twist is that depth peeling uses two <b>Z</b> <b>buffers,</b> one that works conventionally, {{and one that}} is not modified, and sets the minimum distance at which a fragment can be drawn without being discarded. For each pass, the previous pass' conventional Z-buffer is used as the minimal Z-buffer, so each pass draws what was [...] "behind" [...] the previous pass. The resulting images can be combined to form a single image.|$|R
50|$|The GS {{workstations}} {{used the}} X window {{system and the}} 3D hardware was programmed through an X extension known as XFDI (X Floating-point Device Interface). There were bindings for C and Fortran. The display supported 1280 by 1024 resolution at 12 or 24 bits per pixel (in pseudo-color and true-color modes). 12 and 24-bit <b>Z</b> <b>buffers</b> were supported. The GS2000 cabinet was quite large: approximately 30 inches wide by 48 inches tall by 36 inches deep. There was a companion expansion chassis of {{about the same size}} which could contain a 9-track tape drive, for example.|$|R
5000|$|The Indigo's XS Graphics option has {{a single}} GE7 Geometry Engine (GE), a RE3 Raster engine, a HQ2 Command engine, VC1, XMAP5. It is ideal for {{low-cost}} wireframe operations, compared to more powerful, and expensive options for textured graphics. [...] Part of SGI's Express line of graphics, four XS graphics options were produced for the Indigo: the XS-8 offers 8-bit color, with one VM2 video RAM module; the XS-Z adds the ZB-4 Z buffer; the XS-24 adds two VM2 modules and offers 24 color bits and 32 bits including brightness; and the XS-24Z adds a <b>Z</b> <b>buffer.</b>|$|E
40|$|Described {{here is how}} {{researchers}} {{implemented a}} scan line graphics generation algorithm on the Massively Parallel Processor (MPP). Pixels are computed in parallel and their results are applied to the <b>Z</b> <b>buffer</b> in large groups. To perform pixel value calculations, facilitate load balancing across the processors and apply the results to the <b>Z</b> <b>buffer</b> efficiently in parallel requires special virtual routing (sort computation) techniques developed by the author especially for use on single-instruction multiple-data (SIMD) architectures...|$|E
30|$|Mid-log phase {{cultures}} in LB, RB or minimal media (with or without supplementation with various carbon sources), {{were collected by}} centrifugation, washed twice with <b>Z</b> <b>Buffer</b> (Miller 1972) and assayed for β-galactosidase activity after lysis with sodium dodecyl sulfate-chloroform (Miller 1972). The data were recorded in triplicate with no less than three independent experiments.|$|E
40|$|This paper {{describes}} a hierarchical visibility technique that significantly accelerates terrain rendering. With this technique, {{large parts of}} the terrain that are hidden from the viewpoint are culled, thus avoiding the expense of uselessly sending them down the graphics pipeline (only to find in the <b>z</b> [...] <b>buffer</b> step that they are hidden). The hierarchical visibility technique has been implemented in a multiresolution terrain rendering algorithm and experimental results show very large speedups in some situations. 1 Introduction In rendering a terrain, the greatest time is spent sending polygons down the graphics pipeline, where they are transformed, clipped, rasterized, shaded, and <b>z</b> [...] <b>buffered.</b> This paper describes hierarchical visibility, a technique that efficiently culls terrain regions that are not visible from the current viewpoint. It avoids altogether the overhead of sending these regions down the graphics pipeline. The technique is hierarchical in the sense that terrain reg [...] ...|$|R
50|$|Other {{architectural}} changes include {{improvements to}} anti-aliasing functionality. Previous GeForce chips could perform only super-sampled anti-aliasing (SSAA), a demanding process that renders the image {{at a large}} size internally and then scales {{it down to the}} end output resolution. GeForce 3 adds multi-sampling anti-aliasing (MSAA) and Quincunx anti-aliasing methods, both of which perform significantly better than super-sampling anti-aliasing at the expense of quality. With multi-sampling, the render output units super-sample only the <b>Z</b> <b>buffers</b> and stencil buffers, and using that information get greater geometry detail needed to determine if a pixel covers more than one polygonal object. This saves the pixel/fragment shader from having to render multiple fragments for pixels where the same object covers all of the same sub-pixels in a pixel. This method fails with texture maps which have varying transparency (e.g. a texture map that represents a chain link fence). Quincunx anti-aliasing is a blur filter that shifts the rendered image a half-pixel up and a half-pixel left in order to create sub-pixels which are then averaged together in a diagonal cross pattern, destroying both jagged edges but also some overall image detail. Finally, the GeForce 3's texture sampling units were upgraded to support 8-tap anisotropic filtering, compared to the previous limit of 2-tap with GeForce 2. With 8-tap anisotropic filtering enabled, distant textures can be noticeably sharper.|$|R
40|$|More {{and more}} {{machines}} are increasing their flexibility {{so as to}} be able to produce different products with the same tooling. In this context, it is necessary to have fast and accurate methods to evaluate the system performance. This paper presents an approximate analytical method for the performance evaluation of production systems in which Z different types of products are produced. The proposed method is based on the decomposition of the complex system into a set of simpler building blocks, each one formed by two machines and <b>Z</b> homogeneous <b>buffers.</b> The set of building blocks models the whole behavior of the original system. The performance of each building block is evaluated by using the aggregation technique applied to two-machine lines in which the behavior of several products is modeled by an aggregate product, thus simplifying the complexity of the analysis. The numerical results reported in this paper prove the method provides accurate results...|$|R
40|$|There are two {{important}} {{issues in the}} realization of telescope function in the visual system of ship handling simulator: telescope window clips and the display of LOD objects. A method using <b>Z</b> <b>buffer</b> to achieve window clips was proposed. Meanwhile, the display of LOD objects in the visual system was discussed in details before the algorithm was presented...|$|E
3000|$|..., 0.1 % glycerol, 0.200  mM IPTG and {{specified}} {{concentrations of}} glycerol (Merck). The <b>Z</b> <b>Buffer</b> (pH  7.0) contained: 60  mM Na 2 HPO 4, 40  mM NaH 2 PO 4, 10  mM KCl, 1  mM MgSO 4, 50  mM 2 -mercaptoethanol. ONPG (pH  7.0) contained: 40  mg ONPG dissolved in 10.0  ml of 0.1  M potassium phosphate buffer. For the cost experiment specified concentrations of IPTG obtained from (Invitrogen) were used. Lactose Monohydrate obtained from Himedia {{was also used}} in some experiments.|$|E
40|$|For {{measurements}} of β-galactosidase activity, cells were harvested by centrifugation and assays were performed in triplicate using a protocol {{similar to that}} described previously (Miller, 1972). Briefly, cell pellets were resuspended in 1. 0 ml <b>Z</b> <b>buffer</b> (Miller, 1972). 10 μl of toluene was added and the cell suspension was vortexed for 30 seconds whereupon the toluene was evaporated under a hood for 15 minutes. 0. 15 ml (0. 6 mg) orthonitrophenyl-β-D-galactoside was added to 0. 75 ml permeabilized cell suspension to initiate the enzymatic assay (Ti). Reactions were terminated (Tf) by addition of 0. 375 ml 1 M Na 2 CO 3, centrifuged briefly, and analyzed for absorbance at A 420. Data was analyzed relative to control reactions containing <b>Z</b> <b>buffer</b> alone. Miller Units were calculated using the equation [(1000 x A 420) /((Tf – Ti) x 0. 75 ml x A 600) ]. All A 420 readings were taken within 20 minutes of reaction termination. RNA Structural Probing DNA templates for in vitro studies of different RNAs were created by PCR using appropriate oligonucleotide primers. PCR products were then prepared using the QIAGEN PCR clean-up kit or ethanol precipitated (2 X). RNAs were synthesized at 37 ºC in vitro from 25 – 50 μl reactio...|$|E
50|$|The Silicon Graphics Indigo Elan option Graphics systems {{consist of}} four GE7 Geometry Engines {{capable of a}} {{combined}} 128 MFLOPS and one RE3 Raster Engine. Together, {{they are capable of}} rendering 180K Z-buffered, lit, Gouraud-shaded triangles per second. The framebuffer has 56 bits per pixel, causing 12-bits per pixel (dithered RGB 4/4/4) to be used for a double-buffered, depth buffered, RGB layout. When double-buffering isn't required, it is possible to run in full 24-bit color. Similarly, when Z-buffering is not required, a double-buffered 24-bit RGB framebuffer configuration is possible. The Elan Graphics system also implemented hardware stencil buffering by allocating 4 bits from the Z-buffer to produce a combined 20-bit <b>Z,</b> 4-bit stencil <b>buffer.</b>|$|R
40|$|Preparation of {{oligomers}} for ATPase assay- The oligomer and monomeric form of Fe-Dph 4 {{was separated}} using gel filteration column Superdex 75 16 / 60 (GE Healthcare Biosciences). Both the forms retained brown color after gel filteration. Both monomeric and oligomeric forms were used instantly for ATPase assays. As another approach, the oligomers were stabilized by treating the corresponding fractions with 0. 05 % of cross-linking agent gluteraldehyde for 30 min. The protein was then dialysed against <b>buffer</b> <b>Z</b> (HEPES–KOH pH 7. 5, 200 mM NaCl and 5 % glycerol) {{and used for}} ATPase assay. NMR experiments and sequence specific resonance assignments- All NMR experiments were performed on Bruker Avance 700 MHz spectrometer equipped with a triple resonance cryogenic probe containing actively shielded Z-axis gradients. Experiments with uniformly 15 N-labeled Zn-Dph 4 include 2 D [15 N- 1 H] HSQC and those with doubly labeled protein include 3 D 13 C / 15 N edited NOESY-HSQC (1) (mixing time: m = 100 ms), GFT (4, 3) D NOESY-HCCH (2) acquired in 100 % 2 H 2 O and the following triple resonanc...|$|R
40|$|IQ vs. OQ {{crossbar}} switches z In input-queued (IQ), buffers which queue packets at the inputs {{need only}} run {{twice as fast}} the line rates. z If time were slotted so that at most one packet arrived at each input of the switch per time slot, then an input buffer potentially needs to make up to two transactions per time slot: (1) write in an incoming packet, and (2) copy a buffered packet onto the crossbar fabric <b>z</b> the <b>buffers</b> of an N x N output-queued (OQ) switch are required to run at least N + 1 times the line rate IQ vs. OQ crossbar switches (cont) z IQ switches which maintain a single first-in-first-out (FIFO) buffer at the inputs are known to suffer from the so-called head-of-line (HoL) blocking problem z this problem can limit the throughput of the switch to about 58 % when the input traffic is independent, identically distributed (i. i. d.) Bernoulli and the output destinations are uniform [12] z OQ switches which always deliver 100 % throughput, since no output will idle {{as long as there}} is a packet in the switch destined for it IQ HOL Blocking problem z The low throughput of IQ switches is merely an artifact of HoL blocking caused due to a FIFO organization of the input buffers, and that IQ switches can achieve a throughput of up to 100 % by using “virtual output queuing ” and suitable packet scheduling algorithms. z However, all of these results are shown to hold only when the input traffic is i. i. d. although they allow a non-uniform loading of the switch. ([13], [14], [15]) z It has been believed for some time now that an IQ switch can deliver 100 % throughput for arbitrarily distributed input patterns so long as no input or output is oversubscribed. ([13], [14], [15]) First result of paper z These results ought to be true for a wider class of input distributions and that the i. i. d. assumption is only required by their method of proof. z Theorem 1, provides a proof of this belief using fluid model techniques. More precisely, Theorem 1 proves that an IQ switch using a maximum weight matching algorithm can achieve a throughput of up to 100 % when subjected to arbitrarily distributed input traffic that satisfies the following mild conditions: (i) It obeys the strong law of large numbers, and (ii) it does not oversubscribe any input or output...|$|R
40|$|Image {{generation}} of scenes with {{over a thousand}} polygons can be generated on a general purpose raster system rapidly enough for interactive use. We report new results from an algorithm first reported in [Fuchs 1980], which achieves this level of performance for a large class of applications in which the world model changes much less frequently than the viewing position. Since this algorithm is particularly simple to implement, {{it appears to be}} an attractive alternative {for its class of applications) to the common <b>Z</b> <b>buffer</b> visible-surface algorithm. 1...|$|E
40|$|An {{architecture}} is presented for fast high-quality rendering of complex images. All objects {{are reduced to}} common world-space geometric entities called micropolygons, {{and all of the}} shading and visibility calculations operate on these micropo-lygons. Each type of calculation is performed in a coordinate system that is natural for that type of calculation. Micropo-lygons are created and textured in the local coordinate system of the object, with the result that texture filtering is simplified and improved. Visibility is calculated in screen space using stochas-tic point sampling with a <b>z</b> <b>buffer.</b> There are no clipping or inverse perspective calculations. Geometric and texture locality are exploited to minimize paging and to support models that contain arbitrarily many primitives...|$|E
40|$|GPUs {{continue}} to evolve rapidly, but toward what? �raphics architectures {{are in the midst}} of a major transition. In the past, these were specialized architectures designed to support a single rendering algorithm: the standard <b>Z</b> <b>buffer.</b> Realtime 3 D graphics has now advanced to the point where the Z-buffer algorithm has serious shortcomings for generating the next generation of higherquality visual effects demanded by games and other interactive 3 D applications. There is also a desire to use the high computational capability of graphics architectures to support collision detection, approximate physics simulations, scene management, and simple artificial intelligence. In response to these forces, graphics architectures are evolving toward a general-purpose parallel-programming more queue: www. acmqueue. co...|$|E
40|$|H 2 A. Z-specific {{polyclonal}} antisera {{were generated}} against a peptide specific for the C-terminus of S. cerevisiae H 2 A. Z (custom-generated). The HA epitope tag in the degron alleles was detected using monoclonal antibody HA. 11 (Covance). Abf 1 was detected using polyclonal antibodies directed towards the Abf 1 C-terminus (yC- 20, Santa Cruz). Histone H 3 -specific polyclonal antibodies were directed towards the C-terminus of human histone H 3 (ab 1791, abcam). Assaying {{the requirement of}} essential genes with degron technology The essential genes ABF 1, REB 1, and STH 1 were studied by regulated degradation of their encoded protein via degron alleles. Each degron allele was {{under the control of}} the pMET 3 promoter, which is repressed by methionine. The REB 1 and STH 1 degron alleles had an arginine-capped N-terminal fusion of DHFRts and a triple-HA tag, while the ABF 1 degron allele was an abf 1 (M 1 R) allele. UBR 1, the N-end rule pathway E 3 ubiquitin ligase, was placed under the control of a pGAL 1 promoter. To study phenotypes arising from loss of Abf 1, Reb 1 or Sth 1, degron cultures were grown at 30 °C to mid-log phase in synthetic complete media lacking methionine and cysteine with 2 % raffinose and 0. 1 % dextrose as carbon sources. Activation of the degron was achieved by first adding galactose to a final concentration of 2 % for 30 min, followed by centrifugation at room temperature to collect the cells. These cells were next grown at 37 °C in rich media prewarmed at 37 °C and supplemented with 2 % galactose (YPAG). Preparation of mononucleosomal-sized DNA for tiling microarrays Approximately 20 OD 600 units of cells were spheroplasted with 0. 25 mg Zymolyase 100 -T (Seikagaku) in 2 ml <b>Buffer</b> <b>Z</b> (1 M sorbitol, 50 mM Tris-Cl pH 7. 4, 10 mM β-mercaptoethanol) at 30 °C with shaking. The spheroplasting time ranged from 30 min to 75 min, depending on the strain and media conditions used for growth. The ideal spheroplasting time was one that yielded appropriately digested chromatin (~ 90 % mononucleosomal-sized DNA) after 20 min of micrococcal nuclease (MNase) treatment. Spheroplasts were collected by centrifugation at 4 °C and resuspended in 500 µ...|$|R
40|$|Introduction In past years, in the SIGGRAPH Real-Time Shading course, we {{have covered}} {{the details of}} {{real-time}} hardware shading on the R 300 generation of products from ATI. Perhaps {{just as important as}} shading performance, however, is knowing when not to shade. The R 300 -based architectures from ATI have a variety of mechanisms for visibility-related culling, including asynchronous visibility queries, hierarchical-z culling and early-z culling. In these notes, we will outline a number of different applications which take specific advantage of early-z culling to achieve significant performance increases. Early-Z Prior to execution of the pixel shader, R 300 -based chips from ATI perform a check of the interpolated z value against the z value in the <b>z</b> <b>buffer.</b> This occurs for any pixels which passed the hierarchical z test and which are actually going to use the primitive's interpolated z (rather than compute z in the pixel shader itself). This additional check provides not only an added...|$|E
40|$|Tile-based {{rendering}} (also called chunk rendering or bucket rendering) is {{a promising}} technique for low-power, 3 D graphics platforms. This technique decomposes a scene into smaller regions called tiles and renders the tiles oneby-one. The {{advantage of this}} scheme is that a small memory integrated on the graphics accelerator {{can be used to}} store the color components and z values of one tile, so that accesses to the frame and <b>z</b> <b>buffer</b> are local, on-chip accesses which consume significantly less power than off-chip accesses. Tile-based rendering, however, requires that the primitives (commonly triangles) are sorted into bins corresponding to the tiles. This paper describes several algorithms for sorting the primitives into bins and evaluates their computational complexity and memory requirements. In addition, we present and evaluate several tests for determining if a triangle and a tile overlap. Experimental results obtained using several suitable 3 D graphics workloads show that various trade-offs can be made and that, usually, better performance can be obtained by trading it for memory. This information allows the designer to select the appropriate method depending on the amount of memory available and the computational power. 1...|$|E
30|$|The Y 2 H assay was {{performed}} by following the procedure as described previously (Park et al. 2012) using the ProQuest Two-Hybrid system (Invitrogen, USA). The mature form of AvrPiz-t (residues 19 – 108) was cloned into pDBLeu-BD to generate the BD:Ns-AvrPiz-t bait construct. The full length, N-terminus, middle portion (M) and C-terminus of APIP 12 were cloned into pPC 86 -AD to generate the AD:APIP 12 F, AD:APIP 12 N, AD:APIP 12 M and AD:APIP 12 C prey constructs, respectively. All the primers are given in Additional file 5 : Table S 1. Yeast cells with co-transformed pDBLeu- and pPC 86 -derived vectors were plated and incubated on synthetic medium lacking leucine, tryptophan (DOB-Leu-Trp) and the selective medium DOB-Leu-Trp-His (supplemented with 50  mM of 3 -amino- 1, 2, 4 -triazole) at 30  °C for 3  days for the observation of cell growth to detect the His reporter gene activity. The yeast colonies gowning on DOB-Leu-Trp medium were blotted onto filter papers. The filter papers were frozen in liquid nitrogen for 1  min, and then were placed {{on top of a}} pre-soaked filter paper in a 100  mm sterile plate with Z buffer/X-gal solution [2  ml of <b>Z</b> <b>buffer,</b> 6  μl ofβ-mercaptoethanol, 20  μl of X-gal stock solution (40  mg/ml)]. The plate is placed in the incubator at 30  °C for 8  h to detect the LacZ reporter gene activity.|$|E
40|$|Figure 1 : Ray tracing {{acceleration}} structures can be {{made more}} efficient by choosing split planes that are parallel or nearly-parallel to the rays being traced (subfigure d). For rays that share a common or near-common origin, this choice {{can be made}} most simply by building an acceleration structure that uses axis-aligned split planes specified in a space transformed by a perspective projection (subfigure b). The key to efficient ray tracing {{is the use of}} effective acceleration data structures. Traditionally, acceleration structures have been constructed under the assumption that rays approach from any direction with equal probability. However, we observe that for any particular frame the system has significant knowledge about the rays, especially eye rays and hard/soft shadow rays. In this paper we demonstrate that by using this information in conjunction with an appropriate acceleration structure – a set of one or more perspective grids – that ray tracing performance can be significantly improved over prior approaches. This acceleration structure can easily be rebuilt per frame, and provides significantly improved performance for rays originating at or near particular points such as the eye point and the light source(s), without sacrificing the ability to trace arbitrary rays. We demonstrate true real-time frame rates on a game-like scene rendered on an eight-core desktop PC at 1920 x 1200 resolution for primary visibility, and hard shadows, along with lower frame rates for Monte Carlo soft shadows. In particular, we demonstrate the fastest hard shadow ray-tracing results that we are aware of. We argue that the perspective grid acceleration structure provides insight into why the <b>Z</b> <b>buffer</b> algorithm is faster than traditional ray tracing and shows there is a useful continuum of visibility algorithms between the two traditional approaches...|$|E
40|$|In this paper, {{we propose}} {{a new class}} of {{hierarchical}} depth test which saves memory bandwidth in 3 D graphics rendering engine by reducing the number of pixels being passed to the per-pixel operation pipeline. This new filtering, Depth Filter, can be implemented by adding a simple hardware in front of the per-pixel operation pipeline. m e Depth Filter is a filtering block which decides whether a pixel is shaded by celiain plane. The plane is the mask which has the history that a pixel has appeared in front of the plane. If the pixel is shaded, the pixel can be removed. The simulation shows that Depth Filter reduces the number of pixels to the next stage up to 62. 1 percent in random scene. As a result, 62. 1 % of memory bandwidth is saved with simple extra hardware. 1. INTRODUCTlON Consumer-oriented 3 D graphics hardware rapidly incorporates algorithms that increase flexibility and quality of per-pixel color processing; a recent example is a pixel shader [I]. However, determination if a pixel is visible and needs to be processed by a shader still relies on the screen <b>Z</b> <b>buffer</b> algorithm [2]. If the scene is more and more complex, depth buffer test also becomes a burden to the rendering engine. Consider, for example, an interactive walk-through of a detailed geometric database describing an entire city, complete with vegetation, buildings, Furniture inside the buildings and the contents of the furniture. Traditional visibility test which runs on current graphics hardware, the screen 2 buffer algorithm, is not capable of rendering very complex images at interactive rates because of the shortage of memory bandwidth. The vast memory bandwidth is used in the 2 buffer algorithm because every pixel requests the depth value stored in the depth buffer and the depth of every pixels survived in the depth test must be updated to the depth buffer...|$|E

