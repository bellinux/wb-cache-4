30|45|Public
25|$|A simple {{text file}} needs no {{additional}} metadata {{to assist the}} reader in interpretation, and therefore may contain no data at all, which {{is a case of}} <b>zero</b> <b>byte</b> file.|$|E
25|$|Modern {{programs}} use Unicode strings {{to allow}} internationalization of text. Often, these programs will convert incoming ASCII strings to Unicode before processing them. Unicode strings encoded in UTF-16 use two bytes to encode each character (or four bytes for some special characters). When an ASCII string {{is transformed into}} UTF-16, a <b>zero</b> <b>byte</b> is inserted after each byte in the original string. Obscou proved in Phrack 61 {{that it is possible}} to write shellcode that can run successfully after this transformation. Programs that can automatically encode any shellcode into alphanumeric UTF-16-proof shellcode exist, based on the same principle of a small self-modifying decoder that decodes the original shellcode.|$|E
2500|$|B's value has {{now been}} {{inadvertently}} replaced by a number formed from part of the character string. In this example [...] "e" [...] followed by a <b>zero</b> <b>byte</b> would become 25856.|$|E
25|$|Initially, A {{contains}} {{nothing but}} <b>zero</b> <b>bytes,</b> and B contains the number 1979.|$|R
2500|$|... var buffer byte [...] // {{variable}} of size 1024 bytes will be assigned 1024 <b>zero</b> <b>bytes</b> ...|$|R
50|$|The {{second to}} last line {{is also a}} {{character}} indicating the line length with the grave accent signifying <b>zero</b> <b>bytes.</b>|$|R
50|$|There {{are many}} ways that could {{manually}} create a <b>zero</b> <b>byte</b> file, for example, saving empty content in a text editor, using utilities provided by operating systems, or programming to create it. On Unix-like systems, the shell command $ printf > filename results in a <b>zero</b> <b>byte</b> file filename. <b>Zero</b> <b>byte</b> files may arise in cases where a program creates a file but aborts or is interrupted prematurely while writing to it. Because writes are cached in memory and only flushed to disk {{at a later time}} (page cache), a program that does not flush its writes to disk or terminate normally may result in a <b>zero</b> <b>byte</b> file. When the <b>zero</b> <b>byte</b> file is made, file system does not record the file's content on storage, but only updates its index table.|$|E
50|$|COBS {{transforms}} a {{data set}} {{of up to}} 254 bytes in the range 0,255 into bytes in the range 1,255. Having eliminated all zero bytes from the data, a <b>zero</b> <b>byte</b> can now be used to unambiguously {{mark the end of}} the transformed data. This is done by appending a <b>zero</b> <b>byte</b> to the transformed data, and thus forming a packet consisting of the COBS-encoded data (the payload) and the <b>zero</b> <b>byte,</b> end-of-packet marker.|$|E
5000|$|This code {{takes an}} {{argument}} from the command line and copies it {{to a local}} stack variable [...] This works fine for command line arguments smaller than 12 characters (as {{you can see in}} [...] below). Any arguments larger than 11 characters long will result in corruption of the stack. (The maximum number of characters that is safe is one less than the size of the buffer here because in the C programming language strings are terminated by a <b>zero</b> <b>byte</b> character. A twelve-character input thus requires thirteen bytes to store, the input followed by the sentinel <b>zero</b> <b>byte.</b> The <b>zero</b> <b>byte</b> then ends up overwriting a memory location that's one byte beyond the end of the buffer.) ...|$|E
5000|$|... {{indicates}} a <b>zero</b> data <b>byte</b> that was altered by encoding. All <b>zero</b> data <b>bytes</b> are replaced during encoding by one plus {{the number of}} non-zero bytes that follow.|$|R
50|$|Note: Instead of {{creating}} a real file with only <b>zero</b> <b>bytes,</b> many file systems also support the creation of sparse files which returns zeros upon reading but use less actual space.|$|R
5000|$|When reading sparse files, {{the file}} system transparently {{converts}} metadata representing empty blocks into [...] "real" [...] blocks filled with <b>zero</b> <b>bytes</b> at runtime. The application is unaware of this conversion.|$|R
50|$|A <b>zero</b> <b>byte</b> file or zero length file is a {{computer}} file containing no data; that is, it has a length or size of zero bytes.|$|E
50|$|As {{a special}} case, {{if any of}} the marker symbols are {{followed}} by a <b>zero</b> <b>byte</b> (0), the marker symbol itself is written to the decompressed buffer.|$|E
50|$|A simple {{text file}} needs no {{additional}} metadata {{to assist the}} reader in interpretation, and therefore may contain no data at all, which {{is a case of}} <b>zero</b> <b>byte</b> file.|$|E
5000|$|Zero padding is {{sometimes}} {{also referred to}} as [...] "null padding" [...] or [...] "zero byte padding". Some implementations may add an additional block of <b>zero</b> <b>bytes</b> if the plaintext is already divisible by the block size.|$|R
5000|$|... #Caption: NSFNET Traffic 1991, NSFNET {{backbone}} nodes {{are shown}} at the top, regional networks below, traffic volume is depicted from purple (<b>zero</b> <b>bytes)</b> to white (100 billion bytes), visualization by NCSA using traffic data provided by the Merit Network.|$|R
25|$|Inbound traffic measured: This {{image is}} a {{visualization}} study of inbound traffic measured in billions of bytes on the NSFNET T1 backbone {{for the month of}} September 1991. The traffic volume range is depicted from purple (<b>zero</b> <b>bytes)</b> to white (100 billion bytes). It represents data collected by Merit Network, Inc.|$|R
50|$|<b>Zero</b> <b>byte</b> files {{cannot be}} loaded or used by most applications. Even a file {{describing}} an empty word processor document, an image file with zero by zero dimensions, or an audio file of length zero seconds usually still contains metadata identifying the file format and describing some basic {{attributes of the}} file; it results in the file with some positive size. Some very simple formats do not use metadata, such as ASCII text files; these may validly be zero bytes (a common convention terminates text files with a one- or two-byte newline, however). Conversely, <b>zero</b> <b>byte</b> files must use some disk space to be indexed by a filesystem (though none for content, in most cases).|$|E
50|$|No {{capability}} for transmit buffer byte count of zero.Receive lockup may occur if bus latency is large.External loopback on a live network may cause reception of invalid loopback failure indications.Receive descriptor <b>zero</b> <b>byte</b> count buffer interpreted as 4096 available bytes.Will poll computer memory every 1.6 ms for new packets to transmit.|$|E
50|$|In some cases, <b>zero</b> <b>byte</b> files {{may be used}} {{to convey}} {{information}} like file metadata (for example, its filename may contain an instruction to a user viewing a directory listing such as documents-have-been-moved-to-partition-D, etc); or to put in a directory to ensure that it is nonempty, since some tools such as backup and revision control software may ignore the empty directories.|$|E
50|$|UTF-16 and UTF-32 are {{incompatible}} with ASCII files, and thus require Unicode-aware programs to display, print and manipulate them, {{even if the}} file is known to contain only characters in the ASCII subset. Because they contain many <b>zero</b> <b>bytes,</b> the strings cannot be manipulated by normal null-terminated string handling for even simple operations such as copy.|$|R
5000|$|... accepts and {{discards}} all input; {{produces a}} continuous stream of NUL (<b>zero</b> value) <b>bytes</b> ...|$|R
40|$|Special {{thanks to}} Chris Johnson, Brendan Moloney and JB Poline. 	New feature and bugfix release 	Add ability to write Freesurfer {{triangle}} files (Chris Johnson) 	Relax threshold for detecting rank deficient affines in orientation detection (JB Poline) 	Fix for DICOM slice normal numerical error (issue # 137) (Brendan Moloney) 	Fix for Python 3 error when writing <b>zero</b> <b>bytes</b> for offset paddin...|$|R
5000|$|The term {{length of}} a string is used in C to {{describe}} the number of bytes preceding the <b>zero</b> <b>byte.</b> [...] is a standardised function commonly {{used to determine the}} {{length of a}} string. A common mistake is to not realize that a string uses one more unit of memory than this length, in order to store the zero that ends the string.|$|E
50|$|In {{all modern}} {{character}} sets the null character has a code point value of zero. In most encodings this is translated {{to a single}} code unit with a zero value. For instance in UTF-8 it is a single <b>zero</b> <b>byte.</b> However in Modified UTF-8 the null character is encoded as two bytes: 0xC0, 0x80. This allows the byte with the value of zero, which is now not used for any character, {{to be used as}} a string terminator.|$|E
5000|$|Every Ogg page {{begins with}} the four-byte magic string [...] "OggS". If sync is lost a decoder can look for the next {{occurrence}} of this sequence to begin decoding again.These four bytes are followed by a <b>zero</b> <b>byte</b> for Ogg version 0. The version field had originally been intended to allow multiple Ogg page types tuned for different payloads to coexist in the same stream. In the 2000s {{it became clear that}} only one page version will be used.|$|E
50|$|Zero padding {{may not be}} {{reversible}} if {{the original}} file ends {{with one or more}} <b>zero</b> <b>bytes,</b> making it impossible to distinguish between plaintext data bytes and padding bytes. It may be used when the length of the message can be derived out-of-band. It is often applied to binary encoded strings as the null character can usually be stripped off as whitespace.|$|R
50|$|Consistent Overhead Byte Stuffing (COBS) is an {{algorithm}} for encoding data bytes {{that results}} in efficient, reliable, unambiguous packet framing regardless of packet content, thus making it easy for receiving applications to recover from malformed packets. It employs a particular <b>byte</b> value, typically <b>zero,</b> {{to serve as a}} packet delimiter (a special value that indicates the boundary between packets). When zero is used as a delimiter, the algorithm replaces each <b>zero</b> data <b>byte</b> with a non-zero value so that no <b>zero</b> data <b>bytes</b> will appear in the packet and thus be misinterpreted as packet boundaries. The value substituted for each <b>zero</b> data <b>byte</b> is equal to one plus the number of non-zero data bytes that follow.|$|R
5000|$|... {{produces}} a continuous stream of NUL (<b>zero</b> value) <b>bytes</b> when read, and returns a [...] "disk full" [...] message when written to ...|$|R
50|$|In {{the case}} of byte streams, or fixed-size data sets larger than 254 bytes, COBS {{requires}} data to be encoded a section at a time, such that no section exceeds 254 bytes in size. The unambiguous <b>zero</b> <b>byte</b> packet delimiter allows a receiver to synchronize reliably {{with the beginning of}} the next packet, even after an error. It also allows new listeners, which might join a broadcast stream at any time, to reliably detect the beginning of the first complete packet in the received byte stream.|$|E
50|$|Following {{the header}} {{structure}} is a variable-length annotation field. The contents of this field are currently undefined, except that its length {{must be a}} multiple of eight bytes {{and it must be}} terminated with at least one null (<b>zero)</b> <b>byte.</b> The audio data segment begins on an eight-byte boundary immediately following the annotation field. Audio data is encoded in the format identified by the file header. The current implementation supports only a single audio data segment per file. The variable-length annotation field is currently ignored by most audio applications.|$|E
5000|$|The {{mathematical}} algorithm itself requires initialization with 18 32-bit subkeys (equivalent to 72 octets/bytes). The original {{specification of}} bcrypt does not mandate any one particular method for mapping text-based passwords from userland into numeric {{values for the}} algorithm. One brief comment in the text mentions, but does not mandate, the possibility of simply using the ASCII encoded value of a character string, [...] "Finally, the key argument is a secret encryption key, {{which can be a}} user-chosen password of up to 56 bytes (including a terminating <b>zero</b> <b>byte</b> when the key is an ASCII string)." ...|$|E
50|$|In Unix the {{end-of-file}} character (by default EOT) {{causes the}} terminal driver {{to make available}} all characters in its input buffer immediately; normally the driver would collect characters until it sees an end-of-line character. If the input buffer is empty (because no characters have been typed since the last end-of-line or end-of-file), a program reading from the terminal reads a count of <b>zero</b> <b>bytes.</b> In Unix, such a condition is understood as having {{reached the end of}} the file.|$|R
40|$|In this paper, we {{make the}} case for {{building}} high-performance Asymmetric-Cell Caches (ACCs) that employ recentlyproposed asymmetric SRAMs to reduce leakage proportionally to the number of resident zero bits. Because ACCs target memory value content (independent of cell activity and access patterns), they complement prior proposals for reducing cache leakage that target memory access characteristics. Through detailed simulation and leakage estimation using a commercial 0. 13 μ CMOS process model, we show that: (1) on average 75 % of resident data cache bits and 64 % of resident instruction cache bits are zero; (2) while prior research carefully evaluated the fraction of accessed <b>zero</b> <b>bytes,</b> we show that a high fraction of accessed <b>zero</b> <b>bytes</b> is neither a necessary nor a sufficient condition for a high fraction of resident zero bits; (3) the zero-bit program behavior persists even when we restrict our attention to live data, thereby complementing prior leakage-saving techniques that target inactive cells; (4) ACCs can reduce leakage on the average to 23 % compared to a conventional data cache without any performance loss, and to 11 % at the cost of a 5 % increase in overall cache access latency. ...|$|R
5000|$|In Linux [...] or {{the always}} full device {{is a special}} file that always returns the error code [...] (meaning [...] "No space left on device") on writing, and {{provides}} {{an infinite number of}} <b>zero</b> <b>bytes</b> to any process that reads from it (similar to [...] ). This device is usually used when testing the behaviour of a program when it encounters a [...] "disk full" [...] error.$ echo [...] "Hello world" [...] > /dev/fullbash: echo: write error: No space left on device ...|$|R
