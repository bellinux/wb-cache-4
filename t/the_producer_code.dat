2|10000|Public
50|$|An egg mark {{may contain}} {{a number of}} {{information}} parts - in the EU only <b>the</b> <b>producer</b> <b>code</b> is required. Additional information may be printed along with the date of production being the most common to find. Other information may contain the method of production especially in the non-EU world where the numbered levels do not apply.|$|E
50|$|There {{have been}} {{multiple}} occurrences of <b>the</b> <b>producer</b> <b>code</b> being forged - a common concept {{is to have}} multiple barns on the same farm with some having efficient caged hen production and one with an organic egg production code. Eggs are then silently moved to the other barn giving an egg code {{as if they were}} from organic production allowing for a higher price on the market. In Lower Saxony (Germany) the state attorney has accused 150 farmers in a year.|$|E
50|$|On April 5, 2010, <b>the</b> <b>Producers</b> Guild of America Board of Directors officially {{approved}} its New Media Code of Credits, adding twenty-six {{major new}} credits to cover New Media <b>producers.</b> <b>The</b> <b>code</b> is significant {{in that it}} {{marks the first time}} <b>the</b> <b>Producers</b> Guild of America recognized New Media producer industry credits and responsibilities in Broadband, DVD/Blu-ray, Animation, Games (console and online), Mobile, Digital Visual Effects, iTV (interactive/enhanced Television), Special Venues, and Transmedia.|$|R
40|$|In a {{certified}} code system, a <b>code</b> <b>producer</b> wishes {{to convince a}} code consumer that her program is safe to execute. To that end, <b>the</b> <b>producer</b> provides to <b>the</b> consumer a certificate — a machine-checkable proof — of safety of her program in some formal language. The code consumer no longer has to trust <b>the</b> <b>code</b> <b>producer,</b> instead, <b>the</b> consumer only needs to trust the implementer of the certificate checker and the runtime facilities. Typically, {{a certified}} code system {{does not provide a}} way for <b>the</b> <b>code</b> <b>producer</b> to manually allocate and deallocate memory. Instead, a garbage collector is provided as part of the trusted computing base, without proof. Recently, formal proofs of correctness for the Cheney copying collector have been tackled in separation and linear logic. Expanding on this work, I propose to reason about garbage collection in a dependent, higher order, linear logic with few unusual connectives and in the setting of a machine model that i...|$|R
40|$|Abstract. Proof-carrying code {{approaches}} aim at safe {{execution of}} un-trusted code by having <b>the</b> <b>code</b> <b>producer</b> attach a safety proof to the code which the code consumer {{only has to}} validate. Depending {{on the type of}} safety property, proofs can however become quite large and their validation- though faster than their construction- still time consuming. In this paper we introduce a new concept for safe execution of un-trusted code. It keeps the idea of putting the time consuming part of proving on the side of <b>the</b> <b>code</b> <b>producer,</b> however, attaches no proofs to code anymore but instead uses the proof to transform the program into an equivalent but more efficiently verifiable program. Code consumers thus still do proving themselves, however, on a computationally inex-pensive level only. Experimental results show that the proof effort can be reduced by several orders of magnitude, both with respect to time and space. ...|$|R
40|$|Abstract: Proof-carrying code {{approaches}} aim at {{the safe}} execution of untrusted code by having <b>the</b> <b>code</b> <b>producer</b> attach a safety proof to the code which the code consumer only has to validate. Depending {{on the type of}} safety property, proofs can however become quite large and their validation- though faster than their construction- still time consuming. Programs from Proofs is a new concept for the safe execution of untrusted code. It keeps the idea of putting the time consuming part of proving on the side of <b>the</b> <b>code</b> <b>producer,</b> however, attaches no proofs to code anymore but instead uses the proof to transform the program into an equivalent but more efficiently verifiable program. Code consumers thus still do proving themselves, however, on a computationally inexpen-sive level only. In case that the initial proving effort does not yield a conclusive result (e. g., due to a timeout), the very same technique of program transformation can be used to obtain a zero overhead runtime monitoring technique. ...|$|R
50|$|Yusuke Naora (直良 有祐 Naora Yūsuke) (born January 9, 1971) is a Japanese {{video game}} art {{director}} and character designer {{who worked for}} Square Enix (formerly Square). He served as the art director for several Final Fantasy and Compilation of Final Fantasy VII titles. He also served as <b>the</b> <b>producer</b> of <b>the</b> <b>Code</b> Age franchise. On October 1, 2016 he announced on Twitter that {{he had left the}} company, but would continue to contribute to Square Enix games as a freelancer.|$|R
40|$|Annotations {{are often}} added to mobile code {{to reduce the}} {{optimization}} burden of just-intime compilers. However, these annotations are not checked for correctness and must be trusted [...] -incorrect or malicious annotations {{could lead to the}} generation of incorrect or insecure code. We present a time- and space efficient method for verifying the results of the large class of data flow optimizations. This allows the safe movement of computationintensive optimizations away from the code consumer towards <b>the</b> <b>code</b> <b>producer...</b>|$|R
40|$|Weintroduce SafeTSA, a type-safe {{mobile code}} {{representation}} based on static single assignment form. We are developing SafeTSA {{as an alternative}} to the Java Virtual Machine, over which it has several advantages: # 1 # SafeTSA is better suited as input to optimizing dynamic code generators and allows CSE to be performed at <b>the</b> <b>code</b> <b>producer's</b> site. # 2 # SafeTSA provides incorruptible referential integrity and uses #type separation" to achieveintrinsic type safety. These properties reduce the code veri#cation e#ort at the code consumer's site considerably...|$|R
40|$|Dynamic {{compilation}} {{often comes}} {{at the price of}} reduced code quality since there is not enough time available to perform expensive optimizations. One solution to this problem has been the addition of annotations by <b>the</b> <b>code</b> <b>producer</b> that enable an annotation-aware dynamic code generator on the code consumer's side to shortcut certain analysis and optimization steps. However, code annotation often creates a new problem in that most annotations are unsafe [...] if they become corrupted during transit, the safety of the target system is jeopardized...|$|R
500|$|Conceptual work by Yusuke Naora, <b>the</b> <b>producer</b> of <b>the</b> <b>Code</b> Age franchise, {{began in}} 2002; and Code Age Commanders was officially {{announced}} in the April 2005 edition of the Japanese gaming magazine Famitsu. The development team was nicknamed [...] "Warhead" [...] and specifically assembled for the game, with its lead developers Yusuke Naora and Toshiyuki Itahana belonging to the art field rather than project management. Several connections to the mobile phone game Code Age Brawls and the manga Code Age Archives were put throughout the game, so that information learnt from {{it could be used}} by players and readers of the other installments to understand the full picture.|$|R
40|$|Proof-Carrying Code (PCC) is a {{technique}} {{that can be used}} for safe execution of untrusted code. In a typical instance of PCC, a code receiver establishes a set of safety rules that guarantee safe behavior of programs, and <b>the</b> <b>code</b> <b>producer</b> creates a formal safety proof that proves, for the untrusted code, adherence to the safety rules. Then, the receiver is able to use a simple and fast proof validator to check, with certainty that the proof is valid and hence the untrusted code is safe to execute...|$|R
40|$|The language-based {{approach}} to security employs programming language technologies to construct secure environments for hosting untrusted code. The recently proposed notion of confined types effectively prevents accidental reference leaks {{that could lead}} to security breaches in mobile code platforms such as Java. Enforcing a stronger notion of encapsulation than conventional object-oriented programming models, confined types may be exploited as an access control mechanism in language-based environments. Unfortunately, existing formulations of confined types target only Java-like source languages, and thus they can only be enforced by <b>the</b> <b>code</b> <b>producer</b> at compile time. This pape...|$|R
40|$|Security is a {{fundamental}} aspect of every architecture based {{on a number of}} actors that exchange information among them, and the growing ubiquity of mobile and distributed systems has accentuated the problem. Mobile code is software that is transferred between systems and executed on a local system without explicit installation by the recipient, even if it is delivered through an insecure network or retrieved from an untrusted source. During delivery, the code may be corrupted or a malicious cracker could change the code damaging the entire system. Code-Carrying Theory (CCT) is one of the technologies aimed at solving these problems. The key idea of CCT is based on proof-based program synthesis, where a set of axioms that deﬁne functions are provided by <b>the</b> <b>code</b> <b>producer</b> together with suitable proofs guaranteeing that deﬁned functions obey certain requirements. The form of the function-deﬁning axioms is such that it is easy to extract executable code from them. Thus, all that has to be transmitted from <b>the</b> <b>producer</b> to <b>the</b> consumer is a theory (a set of axioms and theorems) and a set of proofs of the theorems. There is no need to transmit code explicitly. Many transformation systems for program optimization, program synthesis, and program specialization are based on fold/unfold transformations. We discuss a fold/unfold–based transformation framework for rewriting logic theories which is based on narrowing. When performing program transformation, we end up with a ﬁnal program which is semantically equal to the initial one. We consider possibly non-conﬂuent and non-terminating rewriting logic theories, and the rules for transforming these rewriting logic theories (deﬁnition introduction, deﬁnition elimination, folding, unfolding) that preserves the rewriting logic semantics of the original theory. The process for obtaining a correct and efficient program can be split in two phases, which may be performed by diﬀerent actors: the ﬁrst phase is to write an initial maybe inefficient program whose correctness can be easily shown by hand or by automatic tools; in the second phase, the actor transforms the initial program by applying a certiﬁcate (a ordered set of instantiated rules of the framework) to derive a more efficient one. The transformation system is naturally extended to CCT: • Code Consumer provides the requirements to <b>the</b> <b>code</b> <b>producer</b> in <b>the</b> form of a rewrite theory. • <b>The</b> <b>Code</b> <b>Producer</b> uses <b>the</b> fold/unfold-based transformation system in order to obtain an efficient implementation of the speciﬁed functions. Subsequently, <b>the</b> <b>producer</b> will send only a Certiﬁcate to be used by the Code Consumer to derive the program. • Once the Certiﬁcate is received, the code consumer can apply the transformation sequence, described in the Certiﬁcate, to the initial theory, and the ﬁnal program is automatically obtained. The strong correctness of the transformation system ensures that the obtained program is correct w. r. t. the initial Consumer speciﬁcations. So the Code Consumer does not need to check extra proofs provided by <b>the</b> <b>Code</b> <b>Producer.</b> If we apply a correct certiﬁcate it is impossible to reach terms that carry malicious code or improper operations. Although <b>the</b> <b>code</b> <b>producer</b> should ensure <b>the</b> correctness of the certiﬁcate and the framework for fold/unfold transformation ensures the correctness and completeness of the ﬁnal program, {{there is no guarantee that}} the requirements of the transformation rules are met correctly. During delivery, the certicate might be corrupted, or a malicious hacker might change the code. Potential problems can be categorized as security problems (i. e., unauthorized access to data or system resources), safety problems (i. e., illegal operations), or functional incorrectness (i. e., the delivered code fails to satisfy a required relation between its input and output) If there is no automatic support, it is very easy for an expert malicious hacker to intercept the certiﬁcate through an insecure network, modify it and resend to the code consumer. We have demonstrated that we cannot apply a certiﬁcate regardless of its contents. We need to check that all the operation descriptions to be carried over to the system are lawful and all operations are done in the correct order. We implemented in a prototypical system, the transformation framework extended with the infrastructure for certiﬁcate checking, which consists of a suit of tools. The implementation is written in Maude easily using the reﬂection, Python and some scripts in Bash. So the Code Consumer which uses our framework can receive, check and apply a certiﬁcate to a initial theory; detect and refuse bad certiﬁcates with a detailed report; and then avoids data corruption or attacks from malicious actors...|$|R
40|$|We {{introduce}} SafeTSA, a type-safe {{mobile code}} representation based on static single assignment form. We are developing SafeTSA {{as an alternative}} to the Java Virtual Machine, over which it has several advantages: (1) SafeTSA is better suited as input to optimizing dynamic code generators and allows CSE to be performed at <b>the</b> <b>code</b> <b>producer's</b> site. (2) SafeTSA provides incorruptible referential integrity and uses "type separation" to achieve intrinsic type safety. These properties reduce the code verification e#ort at the code consumer's site considerably. (3) SafeTSA can transport the results of type and bounds-check elimination in a tamper-proof manner. Despite these advantages, SafeTSA is more compact than Java bytecode...|$|R
40|$|In this paper, {{we propose}} a proof-carrying code {{framework}} for program-generators. The en-abling technique is abstract parsing, a static string analysis technique, {{which is used}} as a component for generating and validating certificates. Our framework provides an efficient solution for certify-ing program-generators whose safety properties are expressed in terms of the grammar representing the generated program. The fixed-point solution of the analysis is generated and attached with the program-generator on <b>the</b> <b>code</b> <b>producer</b> side. <b>The</b> consumer receives the code with a fixed-point solution and validates that the received fixed point is indeed a fixed point of the received code. This validation can be done in a single pass. ...|$|R
5000|$|A film {{adaptation}} of Bellamann's controversial novel, modeled {{on his home}} town of Fulton, Missouri, presented significant problems for movie industry censors, who sought to bring the film into conformity with the Hays Code. Screenwriter Casey Robinson believed the project was hopeless because of <b>the</b> Hays <b>Code.</b> <b>Producer</b> Hal B. Wallis said that Robinson felt [...] "I was crazy to have bought so downbeat a property." [...] Wallis urged him to reconsider, {{and it occurred to}} Robinson that he could turn this into the story of [...] "an idealistic young doctor challenged by the realities of a cruel and horrifying world." ...|$|R
40|$|AbstractStatic Single Assignment (SSA) form {{is often}} used as an {{intermediate}} representation during code optimization in Java Virtual Machines. Recently, SSA has successfully been used for bytecode verification. However, constructing SSA at the code consumer is costly. SSA-based mobile code transport formats {{have been shown to}} eliminate this cost by shifting SSA creation to <b>the</b> <b>code</b> <b>producer.</b> These new formats, however, are not backward compatible with the established Java class-file format. We propose a novel approach to transport SSA information implicitly through structural code properties of standard Java bytecode. While the resulting bytecode sequence can still be directly executed by traditional Virtual Machines, our novel VM can infer SSA form and confirm its safety with virtually no overhead...|$|R
40|$|Modern {{and likely}} future {{architectures}} require compilers to perform extensive restructuring of programs during optimization. We have been building {{a system in}} which JVM bytecode is compiled off-line into an alternative, enhanced mobile-code format. This alternative format is still fully target-machine independent but can be more easily verified and compiled into native code. In particular, our approach permits shifting of analyses and optimizations to <b>the</b> <b>code</b> <b>producer</b> that, because of the necessity to perform bytecode verification, could only occur on the code consumer if JVM bytecode were used. Our approach naturally encompasses irreducible control flow, which can result from the use of bytecode optimizers, obfuscators and compilers for source languages other than Java. Our techniques are applicable beyond JVM bytecode. Although some optimizations can be moved to <b>the</b> <b>code</b> <b>producer,</b> we believe that it will still be unavoidable to perform some restructuring optimizations on the target machine. For example, loop transformations, code scheduling, and parallelization are vital to achieve high performance on EPIC and multithreaded architectures. In this paper, we introduce the Augmented Dominator Tree (ADT) as a candidate mobile code format enabling efficient program analysis. The ADT may be quickly validated on the target machine; we give an O(E + V) algorithm for this. However, our algorithm not only verifies the validity of the data structure, but also reconstructs the control flow graph, and computes the dominance frontier. Furthermore, we show how to quickly compute the postdominator tree, using a more efficient variant of Cooper, Harvey, and Kennedy’s iterative dominator algorithm. We intend the ADT to form the basis of simple and efficient algorithms for performing sophisticated program analysis in a just-in-time compiler for highperformance architectures. 1...|$|R
40|$|As the emerged {{threaten}} {{caused by}} unsafe execution of mobile code, Proof-Carrying Code (PCC) was adopted to establish “trust ” between <b>the</b> <b>code</b> <b>producer</b> and consumer. In PCC, <b>the</b> <b>code</b> <b>producer</b> generates a formal proof automatically by Certifying compiler {{which indicates the}} code’s adherence to the security properties specified by the code consumer. Proof- Transforming Compilers (PTC) [3, 4] is a similar approach to Certifying compiler in PCC, but take a source proof as input and produce the bytecode proof, and with interactive source code verification compared to Certifying compiler, more complex properties can be handled. In order to simplify the translation from source proof to the bytecode level, they presented a Hoare- style logic for bytecode similar with the source code logic, proof transformation was formalized and soundness result was proved in their works. Separation logic[5] is an extension to Hoare logic that permits reasoning about shared mutable heap structures, {{and it has been}} utilized to modular reasoning in object- oriented languages in many works[6, 7]. In order to automatically translate source code proof to bytecode logic by PTC, a separation logic for bytecode is needed. This project consists of the separation logic for bytecode, and the translation from source to bytecode level. Scope of the work This project will develop a proof transformation for separation logic from source to bytecode level, the task of this project consists of developing separation logic for CIL/java bytecode, and the proof transformation from the source separation logic to the bytecode separation logic. Intended results The result will be a bytecode logic using separation logic, and proof translation functions which takes the source code proof and translates it to the bytecode level...|$|R
40|$|Proof Carrying Code (PCC) is a {{technique}} for downloading mobile code on a host machine while ensuring that the code adheres to the host's security policy. We show how certified abstract interpretation {{can be used to}} build a PCC architecture where <b>the</b> <b>code</b> <b>producer</b> can produce program certificates automatically. Code consumers use proof checkers derived from certified analysers to check certificates. Proof checkers carry their own correctness proofs and accepting a new proof checker amounts to type checking the checker in Coq. The checking of certificates is accelerated by {{a technique}} for (post-) fixpoint compression. The PCC architecture has been evaluated experimentally on a byte code language for which we have designed an interval analysis that allows to generate certificates ascertaining that no array-out-of-bounds accesses will occur...|$|R
40|$|Modern {{and likely}} future {{architectures}} require compilers to perform extensive restructuring of programs during optimization. We have been building {{a system in}} which JVM bytecode is compiled off-line into an alternative, enhanced mobile-code format. This alternative format is still fully target-machine independent but can be more easily verified and compiled into native code. In particular, our approach permits shifting of analyses and optimizations to <b>the</b> <b>code</b> <b>producer</b> that, because of the necessity to perform bytecode verification, could only occur on the code consumer if JVM bytecode were used. Our approach naturally encompasses irreducible control flow, which can result from the use of bytecode optimizers, obfuscators and compilers for source languages other than Java. Our techniques are applicable beyond JVM bytecode...|$|R
40|$|Static Single Assignment (SSA) form {{is often}} used as an {{intermediate}} representation during code optimization in Java Virtual Machines. Recently, SSA has successfully been used for bytecode verification. However, constructing SSA at the code consumer is costly. SSAbased mobile code transport formats {{have been shown to}} eliminate this cost by shifting SSA creation to <b>the</b> <b>code</b> <b>producer.</b> These new formats, however, are not backward compatible with the established Java class-file format. We propose a novel approach to transport SSA information implicitly through structural code properties of standard Java bytecode. While the resulting bytecode sequence can still be directly executed by traditional Virtual Machines, our novel VM can infer SSA form and confirm its safety with virtually no overhead. Key words: mobile code, verification, optimization...|$|R
40|$|Aspect Oriented Programming (AOP) is a {{paradigm}} with significant potential to separate functionality and cross-cutting concerns. In particular, AOP supports an incremental development process, {{in which the}} expected functionality is provided by a baseline program, that is successively refined, possibly by third parties, with aspects that improve non-functional concerns, such as efficiency and security. Therefore, AOP is a natural enabler for Proof Carrying Code (PCC) scenarios that involve, in addition to <b>the</b> <b>code</b> <b>producer</b> and <b>the</b> <b>code</b> consumer, untrusted intermediaries that modify the code. The {{purpose of this article}} is to explore a PCC architecture that accommodates such an incremental development process. In order to support a wide range of policies, we extend our earlier work on certificate translation, and show in the context of a very simple language that it is possible to generate certificates of executable code from proofs of aspect-oriented programs. To achieve this goal, we introduce a notion of specification-preserving advice, which provides a mild generalization of the notion of harmless advice by Dantas and Walker, and provide a sound verification method for programs with specification-preserving advices. 1...|$|R
40|$|Proof-Carrying Code (PCC) is a {{technique}} for downloading mobile code on a host machine while ensuring that the code adheres to the host's safety policy. We show how certified abstract interpretation {{can be used to}} build a PCC architecture where <b>the</b> <b>code</b> <b>producer</b> can produce program certi cates automatically. Code consumers use proof checkers derived from certi ed analysers to check certificates. Proof checkers carry their own correctness proofs and accepting a new proof checker amounts to type checking the checker in Coq. Certi cates take the form of strategies for reconstructing a xpoint and are kept small due to {{a technique}} for fixpoint compression. The PCC architecture has been implemented and evaluated experimentally on a byte code language for which we have designed an interval analysis that allows to generate certificates ascertaining that no array-out-of-bounds accesses will occur...|$|R
40|$|Confined types {{enforce a}} form of {{encapsulation}} stronger than what the standard Java type system offers. It is known that confined types effectively prevent accidental reference leaks {{that could lead to}} security breaches in object-oriented programs. Because existing formulations of confined types target the Java source language, they can only be enforced by <b>the</b> <b>code</b> <b>producer</b> at compile time. As such these formulations fail to qualify as practical languagebased protection mechanisms for the Java platform. This paper presents a capability-based formulation of confined types for JVM bytecode, and reports the first implementation to enforce confined types at link time, on the code consumer side. This novel formulation of confined types is backward compatible, modular, and interoperable with lazy dynamic linking. The paper also demonstrates how this bytecode-level formulation of confined types can be applied to facilitate {{a form of}} secure cooperation between mutually suspicious code units. ...|$|R
40|$|The earlier {{errors are}} found, the less costly {{they are to}} fix! ” 1 Code {{consumers}} make high demands on software applications. By providing a certificate associated with a program, <b>the</b> <b>code</b> <b>producers</b> can guarantee <b>the</b> properties the consumer demands on. The project team of MOBIUS is developing techniques to verify security and functional properties of Java programs in order to generate certificates. Based on ESC/-Java 2, an already existing static checker, the new environment of MOBIUS produce proof obligations of difficult security properties {{that have to be}} discharged manually, using Coq. In order to achieve this, we integrate a new direct Verification Condition generator (VCGen) into ESC/Java 2. This master thesis covers the work needed to integrate this VCGen. We developed the translations of code specifications into first order logic terms. Code specifications, to specify the functional behavior of a particular program, are annotations written in Java Modeling Language (JML). We have define...|$|R
5000|$|On September 3, 2015, Joey Badass {{released}} a collaborative single with Korean hip-hop group Epik High's Tablo and <b>producer</b> <b>Code</b> Kunst called [...] "Hood". On October 6, 2015, he collaborated with British indie rock band Glass Animals, releasing a single titled [...] "Lose Control".|$|R
40|$|This paper {{describes}} proof-carrying code (PCC), {{a mechanism}} by which a host system can determine with certainty that {{it is safe to}} execute a program supplied (possibly in binary form) by an untrusted source. For this to be possible, <b>the</b> untrusted <b>code</b> <b>producer</b> must supply with the code a safety proof that attests to the code's adherence to a previously defined safety policy. The host can then easily and quickly validate the proof without using cryptography and without consulting any external agents. In order to gain preliminary experience with PCC, we have performed several case studies. We show in this paper how proof-carrying code might be used to develop safe assembly-language extensions of ML programs. In the context of this case study, we present and prove the adequacy of concrete representations for the safety policy, the safety proofs, and the proof validation. Finally, we briefly discuss how we use proof-carrying code to develop network packet filters that are faster than simil [...] ...|$|R
50|$|Egg marking {{is a form}} of egg {{labeling}} {{that includes}} an egg code stamped on the egg itself. In the EU there is a <b>producer</b> <b>code</b> regulated by law since 2004. It allows consumers to distinguish free range eggs and organic farming eggs from the industrial caged hen production.|$|R
40|$|A logical {{framework}} {{is a general}} meta-language for specifying and implementing de-ductive systems, given by axioms and inference rules. Examples of deductive systems are plentiful in computer science. In computer security, we find authentication and security logics to describe access and security criteria. In programming languages, we use deductive systems to specify the operational semantics, type-systems or other as-pects of the run-time behavior of programs. Recently, one major application of {{logical framework}}s {{has been in the}} area of “certified code”. To provide guarantees about the behavior of mobile code, safety properties are expressed as deductive systems. <b>The</b> <b>code</b> <b>producer</b> then verifies <b>the</b> program according to some predetermined safety pol-icy, and supplies a binary executable together with its safety proof (certificate). Before executing the program, the host machine then quickly checks the code’s safety proof against the binary. The safety policy and the safety proofs can be expressed in the logical framework thereby providing a general safety infrastructure. There are two main variants of logical frameworks which are specifically designed to support the implementation of deductive systems. λProlog and Isabelle are base...|$|R
40|$|Virtual Machines (VMs) and Proof-Carrying Code (PCC) are two {{techniques}} {{that have been}} used independently to provide safety for (mobile) code. Existing virtual machines, such as the Java VM, have several drawbacks: First, the e#ort required for safety verification is considerable. Second and more subtly, the need to provide such verification by the code consumer inhibits the amount of optimization that can be performed by <b>the</b> <b>code</b> <b>producer.</b> This in turn makes justin -time compilation surprisingly expensive. Proof-Carrying Code, on the other hand, has its own set of limitations, among which are the sizes of the proofs {{and the fact that the}} certified code is no longer machine-independent. In this paper, we describe work in progress on combining these approaches. Our hybrid safe-code solution uses a virtual machine that has been designed specifically to support proofcarrying code, while simultaneously providing e#cient justin -time compilation and target-machine independence. In particular, our approach reduces the complexity of the required proofs, resulting in fewer proof obligations that need to be discharged at the target machine...|$|R
40|$|Abstract. We {{classify}} existing {{approaches to}} resource-bounds checking as static or dynamic. Dynamic checking performs checks during program execution, while static checking performs them before execution. Dynamic checking {{is easy to}} implement but incurs runtime cost. Static checking avoids runtime overhead but typically involves difficult, often incomplete program analyses. In particular, static checking is hard {{in the presence of}} dynamic data and complex program structure. We propose a new resource management paradigm that offers the best of both worlds. We present language constructs that let <b>the</b> <b>code</b> <b>producer</b> optimize dynamic checks by placing them either before each resource use, or {{at the start of the}} program, or anywhere in between. We show how the code consumer can then statically verify that the optimized dynamic checks enforce his resource bounds policy. We present a practical language that is designed to admit decidable yet efficient verification and prove that our procedure is sound and optimal. We describe our experience verifying a Java implementation oftar for resource safety. Finally, we outline how our method can improve the checking of other dynamic properties. ...|$|R
40|$|AbstractVirtual {{machines}} and proof-carrying code provide two techniques {{that have been}} used independently to provide safety for mobile code. Both these techniques have strengths and limitations. Existing virtual machines, such as the Java VM, have several drawbacks. First, the effort required for safety verification is considerable. Second, and more subtly, the need to provide such verification by the code consumer inhibits the amount of optimization that can be performed by <b>the</b> <b>code</b> <b>producer.</b> This in turn makes just-in-time compilation surprisingly expensive. Proof-carrying code, on the other hand, has its own set of limitations, among which are the size of proofs {{and the fact that the}} certified code is no longer machine independent. By combining the two techniques, we are able to overcome these limitations. Our hybrid safe-code solution uses a virtual machine that has been designed specifically to support proof-carrying code, while simultaneously providing efficient just-in-time compilation and target-machine independence. In particular, our approach reduces the complexity of the required proofs, resulting in fewer proof obligations that need to be discharged at the target machine...|$|R
40|$|Proof-carrying code {{provides}} {{a mechanism for}} insuring that a host, or code consumer, can safely run code delivered by a <b>code</b> <b>producer.</b> <b>The</b> host specifies a safety policy {{as a set of}} axioms and inference rules. In addition to a compiled program, <b>the</b> <b>code</b> <b>producer</b> delivers a formal proof of safety expressed in terms of those rules that can be easily checked. Foundational proof-carrying code (FPCC) provides increased security and greater flexibility in the construction of proofs of safety. Proofs of safety are constructed from the smallest possible set of axioms and inference rules. For example, typing rules are not included. In our semantic approach to FPCC, we encode a semantics of types from first principles and the typing rules are proved as lemmas. In addition, we start from a semantic definition of machine instructions and safety is defined directly from this semantics. Since FPCC starts from basic axioms and low-level definitions, it is necessary to build up a library of lemmas and definitions so that reasoning about particular programs can be carried out at a higher level, and ideally, also be automated. We describe a high-level organization that involves Hoare-style reasoning about machine code programs. This organization is presented using a detailed example. The example, as well as illustrating the above mentioned approach to organizing proofs, is designed to provide a tutorial introduction to a variety of facets of our FPCC approach. For example, it illustrates how to prove safety of programs that traverse input data structures as well as allocate new ones...|$|R
40|$|We {{show how}} to {{determine}} statically {{whether it is}} safe for untrusted machine code to be loaded into a trusted host system. Our safety-checking technique operates directly on the untrusted machine-code program, requiring only that the initial inputs to the untrusted program be annotated with typestate information and linear constraints. This approach opens up {{the possibility of being}} able to certify code produced by any compiler from any source language, which gives <b>the</b> <b>code</b> <b>producers</b> more freedom in choosing the language in which they write their programs. It eliminates the dependence of safety on the correctness of the compiler because the final product of the compiler is checked. It leads to the decoupling of the safety policy from the language in which the untrusted code is written, and consequently, makes it possible for safety checking to be performed with respect to an extensible set of safety properties that are specified on the host side. We have implemented a prototype safety checker for SPARC machine-language programs, and applied the safety checker to several examples. The safety checker was able to either prove that an example met the necessary safety conditions, or identify the places where the safety conditions were violated. The checking times ranged from less than a second to 14 seconds on an UltraSPARC machine...|$|R
