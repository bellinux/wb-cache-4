3309|1290|Public
5|$|Christoph Benzmuller and Bruno Woltzenlogel Paleo used an {{automated}} <b>theorem</b> <b>prover</b> to validate Scott's version of Gödel's ontological argument. It {{has been shown}} by the same researchers that Gödel's ontological argument is inconsistent. However, Scott's version of Gödel's ontological argument is consistent and thus valid.|$|E
25|$|McCarthy's advice-taker {{proposal}} of 1958 represents an early proposal to use logic for representing common-sense knowledge in mathematical logic and using an automated <b>theorem</b> <b>prover</b> to derive {{answers to questions}} expressed in logical form. Compare Leibniz's calculus ratiocinator and characteristica universalis.|$|E
25|$|Despite the {{simplicity}} of the above proof, it is rather difficult for an automated <b>theorem</b> <b>prover</b> to produce it. The main difficulty lies in an automated discovery of the Cantor diagonal set. Lawrence Paulson noted in 1992 that Otter could not do it, whereas Isabelle could, albeit {{with a certain amount of}} direction in terms of tactics that might perhaps be considered cheating.|$|E
40|$|Abstract: This note {{considers}} {{the design of}} user interfaces for interactive <b>theorem</b> <b>provers.</b> The basic rules of interface design are reviewed, and their applicability to <b>theorem</b> <b>provers</b> is discussed, leading to considerations about the particular chal-lenges of interface design for <b>theorem</b> <b>provers.</b> A short overview and classification of existing interfaces is given, followed by suggestions of possible future work in the area...|$|R
40|$|<b>Theorem</b> <b>provers</b> are {{computer}} programs capable of finding proofs for theorems within mathematical theories. <b>Theorem</b> <b>provers</b> {{have been an}} important part of the computer science field. The birth of <b>theorem</b> <b>provers</b> could be traced to the 50 's with the introduction of the electronic computer to the universities. This paper presents the actual classification of <b>theorem</b> <b>provers,</b> and present an evaluation of an application of <b>theorem</b> <b>provers</b> to an specific problem. 1 Introduction <b>Theorem</b> <b>provers</b> are {{computer programs}} that automate the reasoning of finding proofs within a mathematical theory [3]. To understand what automated reasoning is, we must first understand what reasoning is. Reasoning is the process of drawing conclusions from facts. These conclusions must follow inevitably from the facts from which they are drawn. In other words, reasoning is not concerned with some conclusion that has a good chance of being true when the facts are true. Indeed, reasoning refers to logical reason [...] ...|$|R
40|$|Automated <b>Theorem</b> <b>Provers</b> (ATPs) and SAT/SMT solvers are [...] . {{fast and}} efficient; [...] . applied in {{different}} contexts: program verification, scheduling, test case generation, etc. Interactive <b>Theorem</b> <b>Provers</b> (ITPs) have been [...] . enriched with dependent types, (co) inductive types, type classes and provide rich programming environments...|$|R
25|$|In 2005, Avigad et al. {{employed}} the Isabelle <b>theorem</b> <b>prover</b> {{to devise a}} computer-verified variant of the Erdős–Selberg proof of the PNT. This was the first machine-verified proof of the PNT. Avigad chose to formalize the Erdős–Selberg proof rather than an analytic one because while Isabelle's library at the time could implement the notions of limit, derivative, and transcendental function, it had almost no theory of integration to speak of.|$|E
25|$|Hayes and Kowalski in Edinburgh {{tried to}} {{reconcile}} the logic-based declarative approach to knowledge representation with Planner's procedural approach. Hayes (1973) developed an equational language, Golux, in which different procedures could be obtained by altering {{the behavior of the}} <b>theorem</b> <b>prover.</b> Kowalski, on the other hand, developed SLD resolution, a variant of SL-resolution, and showed how it treats implications as goal-reduction procedures. Kowalski collaborated with Colmerauer in Marseille, who developed these ideas in the design and implementation of the programming language Prolog.|$|E
500|$|Newell and Simon {{tried to}} capture a general version of this {{algorithm}} in a program called the [...] "General Problem Solver". Other [...] "searching" [...] programs were able to accomplish impressive tasks like solving problems in geometry and algebra, such as Herbert Gelernter's Geometry <b>Theorem</b> <b>Prover</b> (1958) and SAINT, written by Minsky's student James Slagle (1961). Other programs searched through goals and subgoals to plan actions, like the STRIPS system developed at Stanford to control the behavior of their robot Shakey.|$|E
50|$|<b>Theorem</b> <b>provers</b> use {{automated}} reasoning {{techniques to}} determine proofs of mathematical theorems. They {{may also be}} used to verify existing proofs. In addition to academic use, typical applications of <b>theorem</b> <b>provers</b> include verification of the correctness of integrated circuits, software programs, engineering designs, etc.|$|R
40|$|The use of {{interactive}} <b>theorem</b> <b>provers</b> {{to establish the}} correctness of critical parts of a software development or for formalising mathematics is becoming more common and feasible in practice. However, most mature <b>theorem</b> <b>provers</b> lack a direct treatment of partial and general recursive functions; overcoming this weakness has been the objective of intensive research during the last decades. In this article, we review many techniques that have been proposed in the literature to simplify the formalisation of partial and general recursive functions in interactive <b>theorem</b> <b>provers.</b> Moreover, we classify the techniques according to their theoretical basis and their practical use. This uniform presentation of the different techniques facilitates the comparison and highlights their commonalities and differences, {{as well as their}} relative advantages and limitations. We focus on <b>theorem</b> <b>provers</b> based on constructive type theory (in particular, Agda and Coq) and higher-order logic (in particular Isabelle/HOL). Other systems and logics are covered to a certain extend, but not exhaustively. In addition to the description of the techniques, we also demonstrate tools which facilitate working with the problematic functions in particular <b>theorem</b> <b>provers.</b> 1...|$|R
40|$|To support {{reasoning}} about {{properties of}} programs operating with boolean values one needs <b>theorem</b> <b>provers</b> {{to be able}} to natively deal with the boolean sort. This way, program pro perties can be translated to first-order logic and <b>theorem</b> <b>provers</b> can be used to prove program properties efficiently. However, in the TPTP language, the input language of automated first-order <b>theorem</b> <b>provers,</b> the use of the boolean sort is limited compared to other sorts, thus hindering the use of first-order <b>theorem</b> <b>provers</b> in program analysis and verification. In this paper, we present an extension FOOL of many-sorted first-order logic, in which the boolean sort is treated as a first-class sort. Boolean terms are indistinguishable from formulas and can appear as arguments to functions. In addition, FOOL contains if-then-else and let-in constructs. We define the syntax and semantics of FOOL and its model-preserving translation to first-order logic. We also introduce a new technique of dealing with boolean sorts in superposition-based <b>theorem</b> <b>provers.</b> Finally, we discuss how the TPTP language can be changed to support FOOL...|$|R
500|$|This {{definition}} has {{the conceptual}} advantage of relying {{only on the}} minimal foundations of the natural numbers: the existence of 0 and of successors. As such, it is useful for computer logic systems such as LF and the Isabelle <b>theorem</b> <b>prover.</b> With this definition, the evenness of zero is not a theorem but an axiom. Indeed, [...] "zero is an even number" [...] may be interpreted {{as one of the}} Peano axioms, of which the even natural numbers are a model. A similar construction extends the definition of parity to transfinite ordinal numbers: every limit ordinal is even, including zero, and successors of even ordinals are odd.|$|E
500|$|The first ontological {{argument}} in the Western Christian tradition was proposed by Anselm of Canterbury in his 1078 work Proslogion. Anselm defined God as [...] "that than which nothing greater can be thought", and argued that this being must exist in the mind, even {{in the mind of}} the person who denies the existence of God. He suggested that, if the greatest possible being exists in the mind, it must also exist in reality. If it only exists in the mind, then an even greater being must be possible—one which exists both in the mind and in reality. Therefore, this greatest possible being must exist in reality. Seventeenth century French philosopher René Descartes deployed a similar argument. Descartes published several variations of his argument, each of which centred on the idea that God's existence is immediately inferable from a [...] "clear and distinct" [...] idea of a supremely perfect being. In the early eighteenth century, Gottfried Leibniz augmented Descartes' ideas in an attempt to prove that a [...] "supremely perfect" [...] being is a coherent concept. A more recent ontological argument came from Kurt Gödel, who proposed a formal argument for God's existence. Norman Malcolm revived the ontological {{argument in}} 1960 when he located a second, stronger ontological argument in Anselm's work; Alvin Plantinga challenged this argument and proposed an alternative, based on modal logic. Attempts have also been made to validate Anselm's proof using an automated <b>theorem</b> <b>prover.</b> Other arguments have been categorised as ontological, including those made by Islamic philosophers Mulla Sadra and Allama Tabatabai.|$|E
2500|$|... : {{a simple}} <b>theorem</b> <b>prover</b> written in Haskell that uses {{analytic}} tableaux for propositional logic.|$|E
40|$|To appearInternational audienceThe use of {{interactive}} <b>theorem</b> <b>provers</b> {{to establish the}} correctness of critical parts of a software development or for formalising mathematics is becoming more common and feasible in practice. However, most mature <b>theorem</b> <b>provers</b> lack a direct treatment of partial and general recursive functions; overcoming this weakness has been the objective of intensive research during the last decades. In this article, we review many techniques that have been proposed in the literature to simplify the formalisation of partial and general recursive functions in interactive <b>theorem</b> <b>provers.</b> Moreover, we classify the techniques according to their theoretical basis and their practical use. This uniform presentation of the different techniques facilitates the comparison and highlights their commonalities and differences, {{as well as their}} relative advantages and limitations. We focus on <b>theorem</b> <b>provers</b> based on constructive type theory (in particular, Agda and Coq) and higher-order logic (in particular Isabelle/HOL). Other systems and logics are covered to a certain extent, but not exhaustively. In addition to the description of the techniques, we also demonstrate tools which facilitate working with the problematic functions in particular <b>theorem</b> <b>provers...</b>|$|R
40|$|Portable proofs {{are a new}} and {{interesting}} way of integrating <b>theorem</b> <b>provers</b> into distributed environments like the web. This article reports on user interface’s challenges and opportunities for <b>theorem</b> <b>provers</b> in such environments. In particular, this article reports {{on the design of}} user interfaces used for searching, browsing and inspecting TSTP problems when published as portable proofs...|$|R
40|$|<b>Theorem</b> <b>provers</b> {{were also}} called 'proof checkers' {{because that is}} what they were in the beginning. They have grown powerful, however, capable in many cases to {{automatically}} produce complicated proofs. In particular, higher order logic based <b>theorem</b> <b>provers</b> such as HOL and PVS became popular because the logic is well known and very expressive. They are generally considered to be potential platforms to embed a programming logic for the purpose of formal verification. In this paper we investigate a number of most commonly used methods of embedding programming logics in such <b>theorem</b> <b>provers</b> and expose problems we discover. We will also propose an alternative approach: hybrid embedding...|$|R
2500|$|Pure Prolog was {{originally}} {{restricted to the}} use of a resolution <b>theorem</b> <b>prover</b> with Horn clauses of the form: ...|$|E
50|$|Nqthm is a <b>theorem</b> <b>prover</b> {{sometimes}} referred to as the Boyer-Moore <b>theorem</b> <b>prover.</b> It was a precursor to ACL2.|$|E
50|$|Prover9 is an {{automated}} <b>theorem</b> <b>prover</b> for First-order and equational logic developed by William McCune. Prover9 is the successor of the Otter <b>theorem</b> <b>prover.</b>|$|E
50|$|Automated <b>theorem</b> <b>provers</b> {{are also}} used to {{implement}} formal verification in computer science. In this setting, <b>theorem</b> <b>provers</b> are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} formal specification. Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|R
40|$|Ideally, {{automated}} <b>theorem</b> <b>provers</b> {{would be}} called from within a CAS whenever the user made a conjecture about the functions they were defining. However, this will take increased sophistication in the automated <b>theorem</b> <b>provers</b> and is unlikely {{to happen in the}} short term. If the aim of the integration of mathematical systems is to generate conjectures, rather than theorems about the function...|$|R
40|$|We {{present a}} new {{approach}} to implementing graphical user interfaces (GUIs) for <b>theorem</b> <b>provers</b> and applications using <b>theorem</b> <b>provers.</b> A typed interface to Standard ML from Tcl/Tk provides the foundations upon which a generic user interface is built. Besides the advantage of type safeness, this technique yields access to the full power of the modularization concepts of Standard ML. It leads to a generic GUI, which instantiated with a particular application yields a GUI for this application. We present a prototypical implementation with two instantiations: an interface to Isabelle itself and a system for transformational program development based on Isabelle. 1 Introduction Graphical user interfaces have been identified as a major potential to increase the usability and productivity of interactive <b>theorem</b> <b>provers</b> (like HOL [GM 93] and Isabelle [Pau 94]) and formal program development tools [HK 93, Smi 91]. The question of how to hide the <b>theorem</b> <b>prover's</b> internals in an easy-to-use interf [...] ...|$|R
50|$|The Isabelle <b>theorem</b> <b>prover</b> is an {{interactive}} <b>theorem</b> <b>prover,</b> a Higher Order Logic (HOL) <b>theorem</b> <b>prover.</b> It is an LCF-style <b>theorem</b> <b>prover</b> (written in Standard ML), {{so it is}} based on a small logical core to ease logical correctness. Isabelle is generic: it provides a meta-logic (a weak type theory), which is used to encode object logics like first-order logic (FOL), higher-order logic (HOL) or Zermelo-Fraenkel set theory (ZFC). Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification. Though interactive, Isabelle also features efficient automatic reasoning tools, such as a term rewriting engine and a tableaux prover, as well as various decision procedures. Isabelle has been used to formalize numerous theorems from mathematics and computer science, like Gödel's completeness theorem, Gödel's theorem about the consistency of the axiom of choice, the prime number theorem, correctness of security protocols, and properties of programming language semantics. The Isabelle <b>theorem</b> <b>prover</b> is free software, released under the revised BSD license.|$|E
5000|$|Christoph Weidenbach, {{author of}} SPASS, {{automated}} <b>theorem</b> <b>prover.</b>|$|E
50|$|Otter is an {{automated}} <b>theorem</b> <b>prover</b> developed by William McCune at Argonne National Laboratory in Illinois. Otter {{was the first}} widely distributed, high-performance <b>theorem</b> <b>prover</b> for first-order logic, and it pioneered {{a number of important}} implementation techniques. Otter is an acronym for Organized Techniques for Theorem-proving and Effective Research.|$|E
40|$|Logic {{programming}} languages {{have many}} characteristics that {{indicate that they}} should serve as good implementation languages for <b>theorem</b> <b>provers.</b> For example, {{they are based on}} search and unification which are also fundamental to theorem proving. We show how an extended logic programming language can be used to implement <b>theorem</b> <b>provers</b> and other aspects of proof systems for a variety of logics. In this language first-order terms are replaced with simply-typed λ-terms, and thus unification becomes higher-order unification. Also, implication and universal quantification are allowed in goals. We illustrate that inference rules can be very naturally specified, and that the primitive search operations of this language correspond to those needed for searching for proofs. We argue on several levels that this extended logic programming language provides a very suitable environment for implementing tactic style <b>theorem</b> <b>provers.</b> Such <b>theorem</b> <b>provers</b> provide extensive capabilities for integrating techniques for automated theorem proving into an interactive proof environment. We are also concerned with representing proofs as objects. We illustrate how such objects can be constructed and manipulated in the logic programming setting. Finally, we propose extensions to tactic style <b>theorem</b> <b>provers</b> in working toward the goal of developing an interactive theorem proving environment that provides a user with many tools and techniques for building and manipulating proofs, and that integrate...|$|R
50|$|This notation, {{besides being}} used in some {{automated}} <b>theorem</b> <b>provers,</b> sometimes appears in catalogs of proofs.|$|R
2500|$|Automated <b>theorem</b> <b>provers</b> {{are also}} used to {{implement}} formal verification in computer science. [...] In this setting, <b>theorem</b> <b>provers</b> are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} formal specification. Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|R
5000|$|CARINE is a first-order {{classical}} logic automated <b>theorem</b> <b>prover.</b>|$|E
50|$|Prover9 is the {{successor}} of the Otter <b>theorem</b> <b>prover.</b>|$|E
5000|$|Carsten Sinz: ARA / An Automatic <b>Theorem</b> <b>Prover</b> for Relation Algebras ...|$|E
40|$|Abstract. We {{show how}} LCF-style {{interactive}} <b>theorem</b> <b>provers</b> might use BDD engines and SAT solvers to perform normalization, simplification of terms and theorems, and assist with interactive proof. The treatment builds on recent work integrating SAT solvers as non-trusted decision procedures for LCF-style <b>theorem</b> <b>provers.</b> We limit ourselves to propositional logic, but briefly {{note that the}} results may be lifted to more expressive logics. ...|$|R
5000|$|Jessie verifies {{properties}} in a deductive manner. Jessie {{relies on the}} Why or Why3 back-end to enable proof obligations {{to be sent to}} automatic <b>theorem</b> <b>provers</b> like Z3, Simplify, Alt-Ergo or interactive <b>theorem</b> <b>provers</b> like Coq or Why. Using Jessie, an implementation of bubble-sort or a toy e-voting system can be proved to satisfy their respective specifications. It uses a separation memory model inspired by separation logic.|$|R
40|$|Different {{reasoning}} {{systems have}} different strengths and weaknesses, and {{often it is}} useful to combine these systems to gain as much as possible from their strengths and retain as little as possible from their weaknesses. Important examples of this include the relationship between first-order and higher-order automated <b>theorem</b> <b>provers,</b> between automated <b>theorem</b> <b>provers</b> and computer algebra systems, and between <b>theorem</b> <b>provers</b> and model generators. We present a general agent-based methodology for integrating such different reasoning systems, and empirically evaluate its usefulness, effectiveness and efficiency by case studies. Of particular interest is the integration of higher-order and first-order automated <b>theorem</b> <b>provers.</b> Namely, first-order automated theorem proving systems have reached considerable strength, but in many areas of mathematics they are still a long way from reliably proving theorems that would be considered relatively simple by humans. For example, when reasoning about sets, relations, or functions, first-order systems still exhibit serious weaknesses. While it has been shown in the past that higher-order reasoning systems can solve problems of this kind automatically, the complexity inherent in their calculi and their inefficiency in dealing with large numbers of clauses prevent these systems from solving a whole range of problems. While our framework is general enough to facilitate cooperation of first-order and higher-order automated <b>theorem</b> <b>provers,</b> we also present a refinement of the general approach that enables a more efficient integration...|$|R
