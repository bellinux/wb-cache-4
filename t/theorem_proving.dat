3405|8360|Public
25|$|Computer science also {{contributes}} to mathematics by developing techniques for the automatic checking or even finding of proofs, such as automated <b>theorem</b> <b>proving</b> and logic programming.|$|E
25|$|For {{constraint}} frameworks {{which are}} strictly compositional, graph unification is the sufficient satisfiability and combination function. Well-known applications include automatic <b>theorem</b> <b>proving</b> and modeling {{the elaboration of}} linguistic structure.|$|E
25|$|In {{artificial}} intelligence and computer science, scientists study and use automated reasoning for diverse applications including automated <b>theorem</b> <b>proving</b> the formal semantics of programming languages, and formal specification in software engineering.|$|E
30|$|The {{following}} <b>theorem</b> <b>proves</b> that MHMM is NP-complete.|$|R
5000|$|Notable <b>theorems</b> <b>proved</b> using {{homology}} {{include the}} following: ...|$|R
50|$|The <b>theorem,</b> <b>proven</b> by Tits, is stated as follows.|$|R
25|$|The {{resolution}} rule is {{a single}} rule of inference that, together with unification, is sound and complete for first-order logic. As with the tableaux method, a formula is proved by showing that the negation of the formula is unsatisfiable. Resolution is commonly used in automated <b>theorem</b> <b>proving.</b>|$|E
25|$|Automated <b>theorem</b> <b>proving</b> {{refers to}} the {{development}} of computer programs that search and find derivations (formal proofs) of mathematical theorems. Finding derivations is a difficult task because the search space can be very large; an exhaustive search of every possible derivation is theoretically possible but computationally infeasible for many systems of interest in mathematics. Thus complicated heuristic functions are developed to attempt to find a derivation in less time than a blind search.|$|E
25|$|Logic is {{the study}} of the {{principles}} of valid reasoning and inference, as well as of consistency, soundness, and completeness. For example, in most systems of logic (but not in intuitionistic logic) Peirce's law (((P→Q)→P)→P) is a theorem. For classical logic, it can be easily verified with a truth table. The study of mathematical proof is particularly important in logic, and has applications to automated <b>theorem</b> <b>proving</b> and formal verification of software.|$|E
5000|$|... #Caption: Ceva's {{parallel}} <b>theorem</b> <b>proved</b> by Al-Mu'taman ibn Hūd.|$|R
5000|$|Poincaré-Birkhoff <b>theorem</b> <b>proves</b> the {{existence}} of two fixed points ...|$|R
5000|$|A strong {{converse}} <b>theorem,</b> <b>proven</b> by Wolfowitz in 1957, states that, ...|$|R
25|$|There {{are many}} {{deductive}} systems for first-order logic which are both sound (all provable statements are true in all models) and complete (all statements which are true in all models are provable). Although the logical consequence relation is only semidecidable, much {{progress has been}} made in automated <b>theorem</b> <b>proving</b> in first-order logic. First-order logic also satisfies several metalogical theorems that make it amenable to analysis in proof theory, such as the Löwenheim–Skolem theorem and the compactness theorem.|$|E
25|$|Primitives. What is the {{underlying}} framework {{used to represent}} knowledge? Semantic networks {{were one of the}} first knowledge representation primitives. Also, data structures and algorithms for general fast search. In this area there is a strong overlap with research in data structures and algorithms in computer science. In early systems the Lisp programming language which was modeled after the lambda calculus was often used as a form of functional knowledge representation. Frames and Rules were the next kind of primitive. Frame languages had various mechanisms for expressing and enforcing constraints on frame data. All data in frames are stored in slots. Slots are analogous to relations in entity-relation modeling and to object properties in object-oriented modeling. Another technique for primitives is to define languages that are modeled after First Order Logic (FOL). The most well known example is Prolog but there are also many special purpose <b>theorem</b> <b>proving</b> environments. These environments can validate logical models and can deduce new theories from existing models. Essentially they automate the process a logician would go through in analyzing a model. <b>Theorem</b> <b>proving</b> technology had some specific practical applications in the areas of software engineering. For example, it is possible to prove that a software program rigidly adheres to a formal logical specification.|$|E
25|$|Research in {{discrete}} mathematics {{increased in}} the latter half of the twentieth century partly due to the development of digital computers which operate in discrete steps and store data in discrete bits. Concepts and notations from discrete mathematics are useful in studying and describing objects and problems in branches of computer science, such as computer algorithms, programming languages, cryptography, automated <b>theorem</b> <b>proving,</b> and software development. Conversely, computer implementations are significant in applying ideas from discrete mathematics to real-world problems, such as in operations research.|$|E
5000|$|The proof also {{relies on}} the {{following}} <b>theorem</b> <b>proven</b> in [...] p. 185: ...|$|R
5000|$|... #Subtitle level 2: List of <b>theorems</b> <b>proved</b> {{with the}} help of {{computer}} programs ...|$|R
30|$|We {{recall the}} one-level {{version of the}} q-analog of the Ramis-Sibuya <b>theorem</b> <b>proved</b> in [1].|$|R
25|$|The need {{to break}} German codes in World War II led to {{advances}} in cryptography and theoretical computer science, with the first programmable digital electronic computer being developed at England's Bletchley Park with the guidance of Alan Turing and his seminal work, On Computable Numbers. At the same time, military requirements motivated advances in operations research. The Cold War meant that cryptography remained important, with fundamental advances such as public-key cryptography being developed in the following decades. Operations research remained important as a tool in business and project management, with the critical path method being developed in the 1950s. The telecommunication industry has also motivated advances in discrete mathematics, particularly in graph theory and information theory. Formal verification of statements in logic has been necessary for software development of safety-critical systems, and advances in automated <b>theorem</b> <b>proving</b> have been driven by this need.|$|E
2500|$|Melvin Fitting (1996). First-order {{logic and}} {{automated}} <b>theorem</b> <b>proving</b> (2nd ed.). [...] 	Springer-Verlag.|$|E
2500|$|In the US in 1971, Stephen Cook {{published}} his paper [...] "The complexity of <b>theorem</b> <b>proving</b> procedures" [...] in conference {{proceedings of the}} newly founded ACM Symposium on Theory of Computing. Richard Karp's subsequent paper, [...] "Reducibility among ...|$|E
30|$|The {{following}} <b>theorem</b> <b>proved</b> by Tsukada [13] {{plays an}} important role in our results.|$|R
30|$|In our proofs, {{we use the}} {{following}} <b>theorem</b> <b>proved</b> by Wu and Debnath [11].|$|R
5000|$|In mathematics, Denjoy's theorem may {{refer to}} several <b>theorems</b> <b>proved</b> by Arnaud Denjoy, {{including}} ...|$|R
2500|$|The {{process of}} {{abstract}} axiomatization {{as exemplified by}} Hilbert's axioms reduces geometry to <b>theorem</b> <b>proving</b> or predicate logic. In contrast, the Greeks used construction postulates, and emphasized problem solving. For the Greeks, constructions are more primitive than existence propositions, {{and can be used}} to prove existence propositions, but not vice versa. To describe problem solving adequately requires a richer system of logical concepts. [...] The contrast in approach may be summarized: ...|$|E
2500|$|Prolog {{was one of}} {{the first}} logic {{programming}} languages, and remains the most popular among such languages today, with several free and commercial implementations available. The language has been used for <b>theorem</b> <b>proving,</b> expert systems, term rewriting, type inference, and automated planning, as well as its original intended field of use, natural language processing. [...] Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications.|$|E
2500|$|Recently, some formalist mathematicians have {{proposed}} {{that all of our}} formal mathematical knowledge should be systematically encoded in computer-readable formats, so as to facilitate automated proof checking of mathematical proofs and the use of interactive <b>theorem</b> <b>proving</b> in the development of mathematical theories and computer software. Because of their close connection with computer science, this idea is also advocated by mathematical intuitionists and constructivists in the [...] "computability" [...] tradition (see below). See QED project for a general overview.|$|E
30|$|The {{proof of}} Theorem 3.4 uses the {{following}} <b>theorem,</b> <b>proved</b> by I. Blank in [9].|$|R
5000|$|Chebyshev's theorem {{is a name}} {{given to}} several <b>theorems</b> <b>proven</b> by Russian {{mathematician}} Pafnuty Chebyshev ...|$|R
50|$|More general results {{than this}} theorem exist, such as Olson's <b>theorem,</b> Kemnitz's {{conjecture}} (<b>proved</b> by Christian Reiher in 2003), and the weighted EGZ <b>theorem</b> (<b>proved</b> by David J. Grynkiewicz in 2005).|$|R
2500|$|The {{underlying}} {{issues were}} first {{discussed in the}} 1950s, in letters from John Forbes Nash Jr. to the National Security Agency, and from Kurt Gödel to John von Neumann. The precise statement of the P versus NP problem was introduced in 1971 by Stephen Cook in his seminal paper [...] "The complexity of <b>theorem</b> <b>proving</b> procedures" [...] and {{is considered by many}} to be the most important open problem in the field. It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute to carry a US$1,000,000 prize for the first correct solution.|$|E
2500|$|The P versus NP {{problem is}} a major unsolved problem in {{computer}} science. [...] Informally, it asks whether every [...] problem whose solution can be quickly verified by a computer can also be quickly solved by a computer; it is widely conjectured {{that the answer is}} no. [...] It was essentially first mentioned in a 1956 letter written by Kurt Gödel to John von Neumann. [...] Gödel asked whether a certain NP complete problem could be solved in quadratic or linear time. The precise statement of the P=NP problem was introduced in 1971 by Stephen Cook in his seminal paper [...] "The complexity of <b>theorem</b> <b>proving</b> procedures" [...] and is {{considered by many to be}} the most important open problem in the field. It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute to carry a US$1,000,000 prize for the first correct solution.|$|E
2500|$|The {{integration}} of Frames, rules, and object-oriented programming was significantly driven by commercial ventures such as KEE and Symbolics spun off from various research projects. At {{the same time}} as this was occurring, there was another strain of research which was less commercially focused and was driven by mathematical logic and automated <b>theorem</b> <b>proving.</b> [...] One of the most influential languages in this research was the KL-ONE language of the mid 80's. KL-ONE was a frame language that had a rigorous semantics, formal definitions for concepts such as an Is-A relation. KL-ONE and languages that were influenced by it such as Loom had an automated reasoning engine that was based on formal logic rather than on IF-THEN rules. This reasoner is called the classifier. A classifier can analyze a set of declarations and infer new assertions, for example, redefine a class to be a subclass or superclass of some other class that wasn't formally specified. In this way the classifier can function as an inference engine, deducing new facts from an existing knowledge base. The classifier can also provide consistency checking on a knowledge base (which in the case of KL-ONE languages is also referred to as an Ontology).|$|E
30|$|The {{following}} <b>theorem</b> <b>proves</b> {{that the}} proposed weight restriction approach is feasible and generates positive weights.|$|R
30|$|In this section, {{we present}} two {{examples}} {{to illustrate the}} main <b>theorems</b> <b>proved</b> in Section  2.|$|R
2500|$|... a digest of the axioms used, and <b>theorems</b> <b>proved,</b> by Wilson and Lewis. Archived by WebCite.|$|R
