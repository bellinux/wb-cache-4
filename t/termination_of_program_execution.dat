0|10000|Public
40|$|When a {{computer}} program requires legitimate access to confidential data, the question arises whether such a program may reveal sensitive information to an unauthorised observer. There is therefore a need {{to ensure that a}} program, which processes confidential data, is free of unwanted information flow. This thesis presents a formal framework for the analysis and enforcement of secure information flow in computational systems such as computer programs. An important aspect of the problem of secure information flow is the development of policies by which we can express intended information release. For this reason information lattices and maps on these lattices are presented as models, which capture intuitive notions about information and information flow. A definition of security is given, based on the lattice formalisation of information and information flow, that exploits the partial order of the information lattice. The lattice formalisation gives us a uniform way to enforce information security policies under various qualitative and quantitative representations of information. An input-output relational model, which describes how a system transforms its input to publicly observable outputs with respect to a given attacker model, is presented as a primitive for the study of secure information flow. By using the relational model, various representations of information, which are shown to fit into the lattice model of information, are derived for the analysis of information flow under deterministic and nondeterministic system models. A systematic technique to derive the relational model of a system, under a given attacker model, from the operational semantics in a language-based setting, is also presented. This allows the development of information flow analyses parametrised by chosen attacker models. A flow-sensitive and termination-sensitive static analysis calculus is presented for the analysis of information flow in programs written in a deterministic While language with outputs. The analysis is shown to be correct with respect to an attacker model that is able to observe all program outputs and which can determine the <b>termination</b> or nontermination <b>of</b> <b>program</b> <b>execution.</b> The static analysis also detects certain disjunctive information release. A termination-sensitive dependency analysis is developed which demonstrates how, by employing abstract interpretation techniques, other less precise but possibly more efficient information flow analysis may be obtained. The thesis concludes with further examples to highlight various aspects of the information flow analysis and enforcement framework developed. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
40|$|Assurance of {{software}} quality {{and security of}} computer systems have become dominant concerns in our networking age, to which models <b>of</b> <b>program</b> <b>execution</b> are important. A good model <b>of</b> <b>program</b> <b>execution</b> would allow <b>program</b> <b>execution</b> to be reliably and efficiently identified and verified online. On one hand, online <b>program</b> <b>execution</b> identification and verification help increase assurance of trustworthy software with respect to specific concerns in software quality and vulnerability. On the other hand, they are also helpful in detecting risks in untrustworthy software. We in this paper present a formal specification <b>of</b> <b>program</b> <b>execution</b> events for security purposes, and a model <b>of</b> <b>program</b> <b>execution</b> based upon the specification. This paper discusses the <b>program</b> <b>execution</b> model, specifically its background, the formal specification <b>of</b> <b>program</b> <b>execution</b> events with an underlying concept <b>of</b> <b>program</b> system call footprints, a formal description <b>of</b> the <b>program</b> <b>execution</b> model, two applications of the model in <b>program</b> <b>execution</b> identification and verification, and our experimental results of the model...|$|R
40|$|This paper {{describes}} {{a system for}} identification <b>execution</b> <b>of</b> <b>programs</b> using <b>execution</b> events <b>of</b> the <b>programs.</b> This system {{is based on a}} model <b>of</b> <b>program</b> <b>execution</b> for security purposes, and is implemented on the Microsoft Windows platforms using an operating system technique called DLL (Dynamic Linked Library) replacement. Compared to other related works, this paper has two key contributions: It {{describes a}} systematic way to retain all system DLLs made by application programs dynamically and in real-time on the Microsoft Windows platforms. It also presents a new model <b>of</b> <b>program</b> <b>execution,</b> in which frequencies <b>of</b> <b>program</b> <b>execution</b> events are considered in addition to their patterns. Our experiment data indicate improved results...|$|R
5000|$|... {{saves the}} current {{environment}} (the program state), {{at some point}} <b>of</b> <b>program</b> <b>execution,</b> into a platform-specific data structure (...) {{that can be used}} at some later point <b>of</b> <b>program</b> <b>execution</b> by [...] to restore the program state to that saved by [...] into [...] This process can be imagined to be a [...] "jump" [...] back to the point <b>of</b> <b>program</b> <b>execution</b> where [...] saved the environment. The (apparent) return value from [...] indicates whether control reached that point normally (zero) or from a call to [...] (nonzero). This leads to a common idiom: [...]|$|R
40|$|International audienceThis paper {{describes}} our generic {{framework for}} detecting <b>termination</b> <b>of</b> <b>programs</b> handling infinite and complex data domains, such as pointer structures. The framework {{is based on}} a counterexample-driven abstraction refinement loop. We have instantiated the framework for programs handling tree-like data structures, which allowed us to prove automatically <b>termination</b> <b>of</b> <b>programs</b> such as the depth-first tree traversal, the Deutsch-Schorr-Waite tree traversal, or the linking leaves algorithm...|$|R
40|$|Technical report DSIC-II/ 15 / 03 Verifying {{termination}} {{is often}} {{considered as one}} of the most important aspects <b>of</b> <b>program</b> verification. In this paper we present Hasta-La-Vista an automatic tool for analysing <b>termination</b> <b>of</b> logic <b>programs.</b> To the best of our knowledge, Hasta-La-Vista is unique in being able to prove <b>termination</b> <b>of</b> <b>programs</b> depending on integer computations. status: publishe...|$|R
40|$|What is N_AShell? [...] . 3 What's New? [...] . 3 Introduction to {{association}} analysis [...] 4 Overview <b>of</b> <b>program</b> <b>execution</b> [...] . ...|$|R
40|$|Strategy {{annotations}} {{have been}} used in several programming languages to improve <b>termination</b> and efficiency <b>of</b> computations. Eager (rewriting-based) languages (e. g., Lisp, OBJ*, CafeOBJ, or Maude) interpret them as replacement restrictions in order to become `more lazy', thus (hopefully) avoiding nontermination. In this paper, we investigate some computational properties (<b>termination</b> and completeness) <b>of</b> <b>programs</b> whose <b>execution</b> is controlled by strategy annotations...|$|R
50|$|In {{computer}} science, trace-based simulation {{refers to}} system simulation performed {{by looking at}} traces <b>of</b> <b>program</b> <b>execution</b> or system component access {{with the purpose of}} performance prediction.|$|R
50|$|SCOPE, {{an acronym}} for Supervisory Control <b>Of</b> <b>Program</b> <b>Execution,</b> was the name used by the Control Data Corporation {{for a number of}} {{operating}} system projects in the 1960s.|$|R
50|$|In mathematics, the Dershowitz-Manna {{ordering}} is a well-founded ordering on multisets {{named after}} Nachum Dershowitz and Zohar Manna. It {{is often used}} in context <b>of</b> <b>termination</b> <b>of</b> <b>programs</b> or term rewriting systems.|$|R
50|$|This term is {{frequently}} {{used in the}} compiler and binary translation community. By tracking a call graph, {{it may be possible}} to detect anomalies <b>of</b> <b>program</b> <b>execution</b> or code injection attacks.|$|R
30|$|In {{the main}} fuzzing loop, target {{programs}} are executed repeatedly. Information <b>of</b> <b>program</b> <b>execution</b> status are extracted {{and used to}} improve the <b>program</b> <b>execution.</b> Two key problems involved in the execution phase is how to guide the fuzzing process and how to explore new path.|$|R
40|$|We {{describe}} {{a tool that}} enables users to record and visualise runtime behaviour of software applications developed in Java. The execution trace, stored {{in the form of}} an XML file is visualized using 3 D call graphs that are an extension of the Cone Tree information visualisation technique. This tool gives the user the ability to create several call graph views from a <b>program’s</b> <b>execution</b> trace, providing additional representations <b>of</b> the <b>program</b> <b>execution</b> to both novice and expert programmers for the purposes <b>of</b> <b>program</b> <b>execution</b> analysis. ...|$|R
40|$|AbstractA {{methodology}} for proving the <b>termination</b> <b>of</b> well-moded logic <b>programs</b> is developed {{by reducing the}} <b>termination</b> problem <b>of</b> logic <b>programs</b> to that <b>of</b> term rewriting systems. A transformation procedure is presented to derive a term rewriting system from a given well-moded logic program such that the <b>termination</b> <b>of</b> the derived rewrite system implies the <b>termination</b> <b>of</b> the logic <b>program</b> for all well-moded queries under a class of selection rules. This facilitates applicability of a vast source <b>of</b> <b>termination</b> orderings proposed {{in the literature on}} term rewriting, for proving <b>termination</b> <b>of</b> logic <b>programs.</b> The <b>termination</b> <b>of</b> various benchmark <b>programs</b> has been established with this approach. Unlike other mechanizable approaches, the proposed approach does not require any preprocessing and works well, even in the presence of mutual recursion. The transformation has also been implemented as a front end to Rewrite Rule Laboratory (RRL) and has been used in establishing <b>termination</b> <b>of</b> nontrivial Prolog <b>programs</b> such as a prototype compiler for ProCoS, PL 0 language...|$|R
50|$|In {{computer}} programming languages, a switch statement {{is a type}} of selection control mechanism used to allow the value of a variable or expression to change the control flow <b>of</b> <b>program</b> <b>execution</b> via a multiway branch.|$|R
40|$|In {{recent years}} {{increasing}} consensus has emerged that program transformers, e. g., partial evaluation and unfold/fold transformations, should terminate; a compiler should stop {{even if it}} performs fancy optimizations! A number of techniques to ensure <b>termination</b> <b>of</b> <b>program</b> transformers have been invented, but their correctness proofs are sometimes long and involved. We present a framework for proving <b>termination</b> <b>of</b> <b>program</b> transformers, cast in the metric space of trees. We first introduce the notion <b>of</b> an abstract <b>program</b> transformer; a number <b>of</b> well-known <b>program</b> transformers {{can be viewed as}} instances of this notion. We then formalize what it means that an abstract program transformer terminates and give a general sufficient condition for an abstract program transformer to terminate. We also consider some specific techniques for satisfying the condition. As applications we show that <b>termination</b> <b>of</b> some well-known <b>program</b> transformers either follows directly from the specific techn [...] ...|$|R
50|$|In computing, {{an alien}} thread in a multi-processor {{system is a}} thread <b>of</b> <b>program</b> <b>execution</b> {{executed}} by one processor {{on behalf of a}} process running on another processor. Alien threads are implemented in the Fiasco.OC/L4 microkernel operating system.|$|R
40|$|AbstractIn this paper, we {{describe}} a methodology for proving <b>termination</b> <b>of</b> logic <b>programs.</b> First, we introduce U-graphs as an abstraction <b>of</b> logic <b>programs</b> and establish that SLDNF derivations {{can be realized}} by instances of paths in the U-graphs. Such a relation enables us to use U-graphs for establishing the universal <b>termination</b> <b>of</b> logic <b>programs.</b> In our method, we associate pre- and postassertions to the nodes of the graph and order assertions to selected edges of the graph. With this as the basis, we develop a simple method for establishing the <b>termination</b> <b>of</b> logic <b>programs.</b> The simplicity/practicality <b>of</b> the method is illustrated through examples...|$|R
40|$|Program {{debugging}} {{can be an}} expensive, {{complex and}} frustrating process. Conventional programming environments provide little explicit support for the cognitive tasks of diagnosis and visualization faced by the programmer. ZStep 94 is a program debugging environment designed to help the programmer understand the correspondence between static program code and dynamic <b>program</b> <b>execution.</b> Some <b>of</b> ZStep 94 's innovations include: • An animated view <b>of</b> <b>program</b> <b>execution,</b> using the very same display used to edit the source code • A window that displays values which follows the stepper's focus • An incrementally-generated complete history <b>of</b> <b>program</b> <b>execution</b> and output • &quot;Video recorder &quot; controls to run the program in forward and reverse directions and control the level of detail displayed • One-click access from graphical objects to the code tha...|$|R
30|$|Equipment layer: It is {{the lowest}} level of the whole system. The system is a {{high-performance}} computing platform based on GPU, where GPU is responsible for massive data high-performance parallel computing, and CPU is responsible for process control <b>of</b> <b>program</b> <b>execution.</b>|$|R
5000|$|Profiler-driven program {{analysis}} on Unix {{dates back to}} at least 1979, when Unix systems included a basic tool, , which listed each function and how much <b>of</b> <b>program</b> <b>execution</b> time it used. In 1982 [...] extended the concept to a complete call graph analysis.|$|R
50|$|Newline {{characters}} {{indicate the}} <b>termination</b> <b>of</b> <b>programming</b> statements. A programming statement can be distributed on multiple consecutive lines {{by using the}} underscore line continuation char (_), whereas multiple statements may be written on a single line by separating each statement with a colon (:).|$|R
40|$|FuncTion is {{a static}} {{analyzer}} designed for proving conditional <b>termination</b> <b>of</b> C <b>programs</b> by means <b>of</b> abstract interpretation. Its underlying abstract domain {{is based on}} piecewise-defined functions, which provide an upper bound on the number <b>of</b> <b>program</b> <b>execution</b> steps until <b>termination</b> as a function <b>of</b> the <b>program</b> variables. 	 In this paper, we fully parameterize {{various aspects of the}} abstract domain, gaining a flexible balance between the precision and the cost of the analysis. We propose heuristics to improve the fixpoint extrapolation strategy (i. e., the widening operator) of the abstract domain. In particular we identify new widening operators, which combine these heuristics to dramatically increase the precision of the analysis while offering good cost compromises. We also introduce a more precise, albeit costly, variable assignment operator and the support for choosing between integer and rational values for the piecewise-defined functions. 	 We combined these improvements to obtain an implementation of the abstract domain which subsumes the previous implementation. We provide experimental evidence in comparison with state-of-the-art tools showing a considerable improvement in precision at a minor cost in performance...|$|R
5000|$|It {{requires}} notification to the United States Congress if {{the cost}} per unit goes more than 25% beyond what was originally estimated, and calls for the <b>termination</b> <b>of</b> <b>programs</b> with total cost growth greater than 50%, unless the Secretary of Defense submits a detailed explanation certifying: ...|$|R
40|$|Termination is {{a crucial}} {{property}} <b>of</b> <b>programs.</b> Therefore, techniques to analyze termi-nation automatically are highly important for program verification. Traditionally, tech-niques for automated termination analysis were mainly studied for declarative program-ming paradigms such as logic programming and term rewriting. However, in the last years, several powerful techniques and tools have been developed which analyze the <b>termination</b> <b>of</b> <b>programs</b> in many programming languages including Java, C, Haskell, and Prolog. In order to re-use the wealth of existing tools and techniques developed for <b>termination</b> analysis <b>of</b> term rewriting (see e. g., [GTSKF 06, Zan 03]), we developed a transforma-tional methodology to prove <b>termination</b> <b>of</b> <b>programs</b> in different languages. In a front end, the program is automatically transformed into a term rewrite system (TRS) such that <b>termination</b> <b>of</b> the TRS implies <b>termination</b> <b>of</b> the original <b>program.</b> To obtain TRSs which are suitable for automated termination proofs, the front end proceeds in two steps. In the first step, the program is executed symbolically to generate a so-called termination graph. This graph represents all possible evaluations <b>of</b> the <b>program</b> in a finite way. In the second step, {{the edges of the}} graph are transformed to rewrite rules. Finally, existing rewriting techniques are used in the back end to prove <b>termination</b> <b>of</b> the resulting TRS...|$|R
30|$|Hardware {{instruction}} tracing is {{a dedicated}} hardware facility {{to collect information}} on <b>program</b> <b>execution</b> for debugging. Examples are Intel Processor Trace (Intel PT) (Reinders 2013) and ARM Embedded Trace Macrocells (ETM) (ARM 2016). They capture the information <b>of</b> <b>program</b> <b>execution</b> path in real-time and record the trace {{in the form of}} data packets. The debugger analyzes the trace and infers <b>program</b> <b>execution</b> events such as what instructions the program has just executed.|$|R
40|$|Visual {{programming}} systems {{use their}} original notation {{to represent the}} programs. The users have difficulty for understanding programs through the observation <b>of</b> <b>program</b> <b>execution.</b> An understandable representation is desired. We propose a method of view customization in a visual programming system. The objects of the view customization are the data structures, which is called “term, ” in a term rewriting system. Term rewriting systems have an important feature, that is, a <b>program</b> <b>execution</b> can be expressed with terms. For the feature, the user-customized view is useful {{not only in the}} data structures but also in the <b>program</b> <b>execution.</b> We describe methods for emphatic representation <b>of</b> the <b>program</b> <b>execution</b> with the customized views. We have also implemented the view customization mechanism in our visual programming system...|$|R
40|$|This thesis desribe {{methodology}} <b>of</b> writing computer <b>programs</b> {{to achieve}} higher speed <b>of</b> <b>program</b> <b>execution.</b> It describe general implementation tricks and ways <b>of</b> writing <b>programs</b> for arbitary computer architecture. Below this thesis descibe selected architecture and optimalization doable on it. Part of this thesis is test of this methodology on some opensource software...|$|R
40|$|<b>Termination</b> <b>of</b> binary CLP <b>programs</b> has {{recently}} {{become an important}} question in the termination analysis community. The {{reason for this is}} due to the fact that a number <b>of</b> approaches to <b>termination</b> <b>of</b> logic <b>programs</b> abstract the input program to a binary CLP <b>program</b> and conclude <b>termination</b> <b>of</b> the input <b>program</b> from <b>termination</b> <b>of</b> the abstracted <b>program.</b> In this paper we introduce a class <b>of</b> binary CLP <b>programs</b> such that their termination can be proved by using linear level mappings. We show that membership to this class is decidable and present a decision procedure. Further, we extend this class to programs such that their termination proofs require a combination of linear functions. In particular we consider as level mappings tuples of linear functions and piecewise linear functions...|$|R
40|$|Proving <b>termination</b> <b>of</b> <b>programs</b> is an {{undecidable}} problem. In {{this work}} we provide a sound method for proving the <b>termination</b> <b>of</b> a certain class <b>of</b> <b>programs</b> {{by using the}} power <b>of</b> linear <b>programming</b> tools. We handle while-loops with a simple loop condition where the assignment of the variables is nondeterministically-chosen out {{of a set of}} possible linear assignments. We implement a simple efficient tool for proving termination and compare it with other existing tools. ...|$|R
50|$|At a {{programming}} level, software may {{be implemented}} using constructs generally represented or understood as tabular, whether to store data (perhaps to memoize earlier results), for example, in arrays or hash tables, or control tables determining the flow <b>of</b> <b>program</b> <b>execution</b> {{in response to}} various events or inputs.|$|R
40|$|AbstractTraces <b>of</b> <b>program</b> <b>executions</b> are {{a helpful}} source <b>of</b> {{information}} for <b>program</b> debugging. They, however, give a picture <b>of</b> <b>program</b> <b>executions</b> {{at such a}} low level that users often have difficulties to interpret the information. Opium, our extendable trace analyzer, is connected to a “standard” Prolog tracer. Opium is programmable and extendable. It provides a trace query language and abstract views of executions. Users can therefore examine <b>program</b> <b>executions</b> at the levels of abstraction which suit them. Opium has shown its capabilities to build abstract tracers and automated debugging facilities. This article describes in depth the trace query mechanism, from the model to its implementation. Characteristic examples are detailed. Extensions written so far {{on top of the}} trace query mechanism are listed. Two recent extensions are presented: the abstract tracers for the LO (Linear Objects) and the CHR (Constraint Handling Rules) languages. These two extensions were specified and implemented within a few days. They show how to use Opium for real applications...|$|R
50|$|Exception {{handling}} is {{the process}} of responding to the occurrence, during computation, of exceptions - anomalous or exceptional conditions requiring special processing - often changing the normal flow <b>of</b> <b>program</b> <b>execution.</b> It is provided by specialized programming language constructs, computer hardware mechanisms like interrupts or operating system IPC facilities like signals.|$|R
50|$|The school’s {{endowment}} {{grew from}} $197M {{at the start}} of his tenure to $475M at the end date, not including the effects of David Booth’s gift. During his deanship, the cumulative operating surplus at Chicago Booth was $100.4M. This reflected strong performance in terms <b>of</b> <b>program</b> <b>execution,</b> overall management, and development.|$|R
50|$|The {{replacement}} {{depends on}} well-designed management of flash memory, which {{is carried out}} by either software on a host system (as a raw medium) or hardware circuits/firmware inside its devices. Here, an efficient prediction mechanism with limited memory-space requirements and an efficient implementation is proposed. The prediction mechanism collects the access patterns <b>of</b> <b>program</b> <b>execution</b> to construct a prediction graph by adopting the working set concept. According to the prediction graph, the prediction mechanism prefetches data (/code) to the SRAM cache, so as to reduce the cache miss rate. Therefore, the performance <b>of</b> the <b>program</b> <b>execution</b> is improved and the read performance gap between NAND and NOR is filled up effectively.|$|R
