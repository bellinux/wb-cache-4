371|1458|Public
50|$|To {{use this}} fault model, each input pin on each gate in turn, {{is assumed to}} be grounded, and a <b>test</b> <b>vector</b> is {{developed}} to indicate the circuit is faulty. The <b>test</b> <b>vector</b> is a collection of bits to apply to the circuit's inputs, and a collection of bits expected at the circuit's output. If the gate pin under consideration is grounded, and this <b>test</b> <b>vector</b> is applied to the circuit, {{at least one of the}} output bits will not agree with the corresponding output bit in the <b>test</b> <b>vector.</b> After obtaining the test vectors for grounded pins, each pin is connected in turn to a logic one and another set of test vectors is used to find faults occurring under these conditions. Each of these faults is called a single stuck-at-0 or a single stuck-at-1 fault, respectively.|$|E
5000|$|In {{order to}} test the login page, it is {{necessary}} to pass some sample input vectors [...] In this context [...] is called a <b>test</b> <b>vector.</b>|$|E
5000|$|<b>Test</b> <b>vector</b> {{generator}} is {{a program}} used to automatically generate test data for use in automated testing of software. This can generate many individual test vectors.|$|E
40|$|The device has a {{determining}} device (102) {{for determining}} multiple <b>test</b> <b>vectors</b> {{based on an}} audio sequence (110). A provision unit provides a code book with multiple support vectors. An approximating device approximates the <b>test</b> <b>vectors</b> based on the support <b>vectors</b> to approximated <b>test</b> <b>vectors,</b> where error vectors describe a deviation of the <b>test</b> <b>vectors</b> from the approximated <b>test</b> <b>vectors.</b> A detection device detects an acoustic event based on the error vectors and determines a point of time of detection of the acoustic event. Independent claims are also included for the following: (1) a method for recognizing an acoustic event in an audio sequence (2) a computer program comprising a set of instructions to execute a method for recognizing an acoustic event in an audio sequence...|$|R
30|$|The {{condition}} coverage (CC) needs {{a relative}} {{high number of}} <b>test</b> <b>vectors.</b> This is because of <b>test</b> <b>vectors</b> that enforce the entering of a program decision do not necessarily enforce the execution of a specific condition within the decision. Multiple condition coverage (MCC) has a relative high cost for testing a single decision. However, {{when looking at the}} whole program, then path coverage (PC) is typically much more complex, and depending on the definition of program scopes, scoped path coverage (SPC) requires significantly less <b>test</b> <b>vectors</b> than PC.|$|R
50|$|Each {{standard}} defines different protector characteristics, <b>test</b> <b>vectors,</b> or operational purpose.|$|R
50|$|Two faults are {{functionally}} equivalent if {{they produce}} identical faulty functions {{or we can}} say, two faults are functionally equivalent {{if we can not}} distinguish them at primary outputs (PO) with any input <b>test</b> <b>vector.</b>|$|E
5000|$|Fault grading is a {{procedure}} that rates testability by relating the number of fabrication defects that can in fact be detected with a <b>test</b> <b>vector</b> set under consideration to {{the total number of}} conceivable faults.|$|E
5000|$|In {{computer}} science and engineering, a <b>test</b> <b>vector</b> {{is a set}} of inputs provided to a system in order to test that system. In software development, test vectors are a methodology of software testing and software verification and validation.|$|E
50|$|Methods {{based on}} Boolean satisfiability are {{sometimes}} {{used to generate}} <b>test</b> <b>vectors.</b>|$|R
50|$|<b>Tests</b> <b>vector,</b> bitmap, {{and text}} {{rendering}} for both Adobe Flash and HTML5.|$|R
40|$|The {{simulation}} of <b>test</b> <b>vectors</b> in ATE formats {{is shown to}} facilitate diagnosis and prevention of failures at the ATE. This paper discusses the requirements for a simulationbased flow to validate the <b>test</b> <b>vectors</b> before being handed out to the ATE engineers. The experiences of running such a flow, developed based on this methodology, is also briefly described. 1...|$|R
5000|$|The {{values of}} the <b>test</b> <b>vector</b> at the strict {{condition}} of the equality that is [...] and [...] are called the boundary values, Boundary-value analysis has detailed information about it. Note that the graph only covers the overflow case, first quadrant for X and Y positive values.|$|E
5000|$|The {{fundamental}} {{concept of}} ECP comes from equivalence class {{which in turn}} comes from equivalence relation.A software system is in effect a computable function implemented as an algorithm in some implementation programming language.Given an input <b>test</b> <b>vector</b> some instructions of that algorithm get covered, ( [...] see code coverage for details [...] ) others do not.This gives the interesting relationship between input test vectors:- is an equivalence relation between test vectors [...] {{if and only if}} the coverage foot print of thevectors [...] are exactly the same, that is, they cover the same instructions, at same step.This would evidently mean that the relation cover [...] would partition the input vector space of the <b>test</b> <b>vector</b> into multiple equivalence class. This partitioning is called equivalence class partitioning of test input. If there are [...] equivalent classes, only [...] vectors are sufficient to fully cover the system.|$|E
50|$|NIST Special Publication 800-38G, Recommendation for Block Cipher Modes of Operation: Methods for Format-Preserving Encryption. This {{publication}} specifies {{two methods}} FF1 and FF3. Details on the proposals submitted for each {{can be found}} at the NIST Block Cipher Modes Development site, including patent and <b>test</b> <b>vector</b> information. Sample values are available for both FF1 and FF3.|$|E
5000|$|The {{following}} <b>test</b> <b>vectors</b> {{are defined}} in RFC 1320 (The MD4 Message-Digest Algorithm) ...|$|R
40|$|Abstract 1 The {{quality of}} test is highly {{related to the}} number of faults that can be {{detected}} during the testing (fault coverage) and the defect probability of each testable unit. High test quality is reached by applying an excessive number of good <b>test</b> <b>vectors,</b> however, such a high test data volume can be problematic to fit in the ATEâ€™s (automatic test equipment) limited memory. We therefore propose, for core-based designs, a scheme that selects <b>test</b> <b>vectors</b> for each core, and schedule the <b>test</b> <b>vectors</b> {{in such a way that}} the test quality is maximized under a given test time constraint given by the ATE memory depth. 1...|$|R
40|$|A new {{technique}} for diagnosis in a scan-based BIST environment is presented. It allows non-adaptive identification {{of both the}} scan cells that capture errors (space information) {{as well as a}} subset of the failing <b>test</b> <b>vectors</b> (time information). Having both space and time information allows a faster and more precise diagnosis. Previous techniques for identifying the failing <b>test</b> <b>vectors</b> during BIST have been limited in the multiplicity of errors that can be handled and/or require a very large hardware overhead. The proposed approach, however, uses only two cycling registers at the output of the scan chain to accurately identify a subset of the failing BIST <b>test</b> <b>vectors.</b> This is accomplished using some novel pruning techniques that efficiently extract information from the signatures of the cycling registers. While not all the failing BIST <b>test</b> <b>vectors</b> can be identified, results indicate that a significant number of them can be. This additional information can save {{a lot of time in}} failu [...] ...|$|R
5000|$|Formally the {{boundary}} values {{can be defined}} as below:-Let the set of the test vectors be [...]Let's assume that there is an ordering relation defined over them, as [...]Let [...] be two equivalent classes.Assume that <b>test</b> <b>vector</b> [...] and [...]If [...] or [...] then the classes [...] are in the same neighborhood and the values [...] are boundary values.|$|E
50|$|Straightforward {{application}} of scan techniques {{can result in}} large vector sets with corresponding long tester time and memory requirements. Test compression techniques address this problem, by decompressing the scan input on chip and compressing the test output. Large gains are possible since any particular <b>test</b> <b>vector</b> usually only needs to set and/or examine {{a small fraction of}} the scan chain bits.|$|E
5000|$|The key {{property}} of the Galerkin approach is that the error is orthogonal to the chosen subspaces. Since [...] , we can use [...] as a <b>test</b> <b>vector</b> in the original equation. Subtracting the two, we get the Galerkin orthogonality relation for the error, [...] which is the error between {{the solution of the}} original problem, , and the solution of the Galerkin equation, ...|$|E
40|$|The {{generation}} of <b>test</b> <b>vectors</b> and design-for-test {{aspects of the}} Jet Propulsion Laboratory (JPL) Very Large Scale Integration (VLSI) Viterbi decoder chip is discussed. Each processor integrated circuit (IC) contains over 20, 000 gates. To achieve {{a high degree of}} testability, a scan architecture is employed. The logic has been partitioned so that very few <b>test</b> <b>vectors</b> are required to test the entire chip. In addition, since several blocks of logic are replicated numerous times on this chip, <b>test</b> <b>vectors</b> need only be generated for each block, rather than for the entire circuit. These unique blocks of logic have been identified and test sets generated for them. The approach employed for testing was to use pseudo-exhaustive <b>test</b> <b>vectors</b> whenever feasible. That is, each cone of logid is tested exhaustively. Using this approach, no detailed logic design or fault model is required. All faults which modify the function of a block of combinational logic are detected, such as all irredundant single and multiple stuck-at faults...|$|R
40|$|In this paper, {{multi-frequency}} test is presented, {{which can}} maximize {{differences between the}} failure state and the normal state of the analog circuit's response. Using sensitivity analysis, the multi-frequency <b>test</b> <b>vectors</b> of the circuit under test(CUT) are generated and chosen. The experimental results show that this approach is very effective and highly practical for multi-frequency <b>test</b> <b>vectors</b> of the analog circuits. Â© 2013 IEEE...|$|R
40|$|When {{running a}} set of <b>test</b> <b>vectors</b> to detect path delay faults in a digital system, desired test {{frequencies}} are needed. In this paper we determine the guaranteed failure-frequency (GFF) and the guaranteed working frequency (GWF) for a given set of <b>test</b> <b>vectors</b> used for path delay testing of a sequential circuit. If the circuit passes the <b>test</b> when the <b>vectors</b> are applied at GFF, then all paths activated by those vectors are guaranteed {{to be free from}} delay faults provided the clock frequency does not exceed the GWF. Ambiguity cancellation and minmax-delay or statistical-delay modeling techniques are used in a timing simulation system to determine GFF and GWF. Experiments show that by using the guaranteed failure frequency, we can obtain the best (most reliable) path delay fault coverage provided by the given <b>test</b> <b>vectors...</b>|$|R
50|$|Rijndael is {{free for}} any use public or private, {{commercial}} or non-commercial. The authors of Rijndael {{used to provide}} a homepage for the algorithm. Care should be taken when implementing AES in software. Like most encryption algorithms, Rijndael was designed on big-endian systems. For this reason, little-endian systems, which include the common PC, return correct <b>test</b> <b>vector</b> results only through swapping bytes of the input and output words.|$|E
50|$|Sequential-circuit ATPG {{searches}} for {{a sequence of}} test vectors to detect a particular fault through the space of all possible <b>test</b> <b>vector</b> sequences. Various search strategies and heuristics have been devised to find a shorter sequence, or to find a sequence faster. However, according to reported results, no single strategy or heuristic out-performs others for all applications or circuits. This observation implies that a test generator should include a comprehensive set of heuristics.|$|E
5000|$|In {{the age of}} computers, this pangram is {{commonly}} used to display font samples and for testing computer keyboards. In cryptography, it {{is commonly}} used as a <b>test</b> <b>vector</b> for hash and encryption algorithms to verify their implementation, as well as to ensure alphabetic character set compatibility. Microsoft Word has a command to auto-type the sentence, in versions up to Word 2003, using the command =rand (...) , and in Microsoft Office Word 2007 and later using the command =rand.old (...) [...]|$|E
5000|$|These <b>test</b> <b>vectors</b> {{only show}} the first 256 {{bits of the}} output of RadioGatÃºn's {{arbitrarily}} long output stream: ...|$|R
40|$|Testing {{of digital}} VLSI {{circuits}} encounters many challenges {{as a result}} of rapidly growing semiconductor manufacturing technologies along with unexampled levels of design complexity and the gigahertz range of operating frequencies. These challenges include keeping the average and peak power dissipation and test application time within acceptable limits. This paper proposes a new output sequence of an LFSR to design a low-power test-patterngenerator for built-in self-test (BIST) to achieve reduction in the overall switching activity in the circuit-under-test (CUT). Conventional and low power test patterns are applied on an industry standard ISCAS- 85 c 432 27 -channel interrupt controller circuit and total power consumption is measured. The obtained results show up to 18 % power reduction for the proposed design. Fault simulation tool is used to estimate the number of <b>test</b> <b>vectors</b> required for high fault coverage of the interrupt controller. It generates 261 <b>test</b> <b>vectors</b> for the conventional TPG and 678 <b>test</b> <b>vectors</b> for the low power TPG, thus indicating 160 % increase in <b>test</b> <b>vectors.</b> The results obtained show a significant increase in test application time for low power TPG...|$|R
50|$|Boundary value {{analysis}} is a software testing technique in which tests {{are designed to}} include representatives of boundary values in a range. The idea comes from the boundary. Given {{that we have a}} set of <b>test</b> <b>vectors</b> to <b>test</b> the system, a topology can be defined on that set. Those inputs which belong to the same equivalence class as defined by the equivalence partitioning theory would constitute the basis. Given that the basis sets are neighbors, there would exist a boundary between them. The <b>test</b> <b>vectors</b> {{on either side of the}} boundary are called boundary values. In practice this would require that the <b>test</b> <b>vectors</b> can be ordered, and that the individual parameters follows some kind of order (either partial order or total order).|$|R
50|$|Once memory traces {{corresponding}} to specific memory {{are stored in}} the matrix, to retrieve the memory for the recall process one must cue the memory matrix with a specific probe, which {{would be used to}} calculate the similarity between the <b>test</b> <b>vector</b> and the vectors stored in the memory matrix. Because the memory matrix is constantly growing with new traces being added in, one would have to perform a parallel search through all the traces present within the memory matrix to calculate the similarity, whose result can be used to perform either associative recognition, or with probabilistic choice rule, used to perform a cued recall.|$|E
50|$|The k-NN {{algorithm}} {{is a well}} known pattern recognition algorithm where a set of predetermined prototypes {pk} are used during the sample, or testing phase, of a supposed event. The prototypes model the events that are {{of interest in the}} application. The distance between each <b>test</b> <b>vector</b> and each prototype is calculated and the k test vectors closest to the prototype vectors are taken as the most likely classification or group of classifications. From there the probability that x belongs to the prototype event can be calculated. This approach, however, requires much memory and processing power as the number of prototypes increases and thus it is not a very practical choice for WSNs. It does however act as a good baseline to gauge performance of other classifiers since it is well known and that probability of misclassification when k=1 approaches twice the optimal Bayes error.|$|E
5000|$|This model {{worked so}} well for transistor-transistor logic (TTL), which was the logic of choice during the 1970s and 1980s, that {{manufacturers}} advertised how well they tested their circuits by a number called [...] "stuck-at fault coverage", which represented the percentage of all possible stuck-at faults that their testing process could find.While the same testing model works moderately well for CMOS, it {{is not able to}} detect all possible CMOS faults. This is because CMOS may experience a failure mode known as a stuck-open fault, which cannot be reliably detected with one <b>test</b> <b>vector</b> and requires that two vectors be applied sequentially. The model also fails to detect bridging faults between adjacent signal lines, occurring in pins that drive bus connections and array structures. Nevertheless, the concept of single stuck-at faults is widely used, and with some additional tests has allowed industry to ship an acceptable low number of bad circuits.|$|E
40|$|ISBN : 1 - 4244 - 0898 - 9 We propose an {{efficient}} solution to automatically generate <b>test</b> <b>vectors</b> that satisfy an assumed property written in PSL. From a formula, we build a synthesizable generator that produces random temporal <b>test</b> <b>vectors</b> compliant with the formula. Generators are space and speed efficient when synthesized on FPGA, and their {{connection to the}} device under test is a portable solution across verification platforms for simulation and emulation...|$|R
40|$|Compact set of 3 -valued <b>test</b> <b>vectors</b> for random pattern {{resistant}} faults {{are covered}} in multiple test passes. During a pass, its associated test cube specifies certain bits in the scan chain to be held fixed and others to change pseudo-randomly. We propose an algorithm to find {{a small number of}} cubes to cover all the <b>test</b> <b>vectors,</b> thus minimizing total test length. The test-cube finding algorithm repeatedly evaluates small perturbations of the current solution so as to maximize the expected test coverage of the cube. Experimental results show that our algorithm covers the <b>test</b> <b>vectors</b> by <b>test</b> cubes that are one to two orders of magnitude smaller in number with a much smaller increase in the percentage of specified bits. It outperforms comparable schemes reported in the literature...|$|R
50|$|Automatic {{test pattern}} {{generation}} is a term of art in electronic design automation for the automatic generation of <b>test</b> <b>vectors</b> for electronic circuits.|$|R
