38|2112|Public
5000|$|Parallel {{programming}} is also supported through the [...] functional programming operators in the F# standard library, direct {{use of the}} [...] <b>task</b> <b>programming</b> model, the direct use of [...]NET thread pool and [...]NET threads and through dynamic translation of F# code to alternative parallel execution engines such as GPU code.|$|E
5000|$|FBP has {{undergone}} a number of name changes over the years: the original implementation was called AMPS (Advanced Modular Processing System). One large application in Canada went live in 1975, and, as of 2013, has been in continuous production use, running daily, for almost 40 years. Because IBM considered the ideas behind FBP [...] "too much like a law of nature" [...] to be patentable they instead put the basic concepts of FBP into the public domain, {{by means of a}} Technical Disclosure Bulletin, [...] "Data Responsive Modular, Interleaved <b>Task</b> <b>Programming</b> System", in 1971. An article describing its concepts and experience using it was published in 1978 in the IBM Research IBM Systems Journal under the name DSLM. [...] A second implementation was done as a joint project of IBM Canada and IBM Japan, under the name [...] "Data Flow Development Manager" [...] (DFDM), and was briefly marketed in Japan in the late '80s under the name [...] "Data Flow Programming Manager".|$|E
40|$|MBASIC is high-level, {{interactive}} {{computer language}} that reduces time of computer <b>task</b> <b>programming.</b> Outstanding features of MBASIC include: multiple assignments or statements in single instruction; conditional, assignment, and repetitive statement modifiers; and excellent string-handling capabilities. Two machine versions are available: UNIVAC (written in reentrant Assembler code for execution under EXEC 8) AND DEC- 10 (written in Assembler code for execution under TOPS- 10) ...|$|E
40|$|Abstract — Researchers and {{engineers}} have used primitive actions to facilitate <b>programming</b> of <b>tasks</b> {{since the days}} of Shakey [1]. Task-level programming, which requires the user to specify only subgoals of a task to be accomplished, depends on such a set of primitive <b>task</b> <b>programs</b> to perform these subgoals. Past research in this area has used the commands from robot programming languages as the vocabulary of primitive tasks for robotic manipulators. We propose drawing from work measurement systems to construct the vocabulary of primitive <b>task</b> <b>programs.</b> We describe one such work measurement system, present several primitive <b>task</b> <b>programs</b> for humanoid robots inspired from this system, and show how these primitive programs can be used to construct complex behaviors. Index Terms — robot programming, task-level programming, humanoid robots I...|$|R
40|$|Abstract A new {{correctness}} concept, called partial-order preserving property, for event-driven execution {{monitoring of}} Ada <b>tasking</b> <b>programs</b> is presented. By using this concept, we can describe {{whether or not}} the tasking behavior of monitored Ada programs refrains from interference by monitoring actions of an event-driven execution monitor. In this paper, we define the equivalence of dynamic concurrent structures with respect to Ada program transformation, and propose this equivalence as a partial-order preserving criterion of the $pro$gram transformation used in a preprocessor of an event-driven execution monitor of Ada <b>tasking</b> <b>programs.</b> The equivalence is formally based on the lattice of dynamic concurrent structure of Ada programs which provides an abstraction of the <b>tasking</b> behavior ofAda <b>programs</b> in terms of task interactions. 1...|$|R
30|$|When the Schedule module {{receives}} the task, {{according to the}} content of the <b>task</b> (<b>program</b> ID, program location), it downloads the procedures to be tested from a specified location to the local and hands the program over to TaintChaser for analysis.|$|R
40|$|Programming takes {{designers}} {{away from}} typical domain- and task-based interfaces such as three-dimensional modellers. It thus imposes additional cognitive {{load on the}} already challenging design <b>task.</b> <b>Programming</b> in the model is a system design strategy that embeds the act of programming in a 3 D CAD model. This paper presents the argument for programming in the model and two user interface constructs that support such programming...|$|E
40|$|The present work {{studies the}} <b>task</b> <b>programming</b> {{problem in the}} garment {{industry}} and uses the Job Shop method to solve the problem. A representation is proposed for the numerical solution of the problem based on a heuristic optimization methods known as Simulated Annealing. Although the algorithm is capable of identifying the ideal solution in some cases, at times solution are proposed that deviate up to 10 % from the optimum...|$|E
40|$|A {{performance}} {{prediction method}} is presented, which accurately predicts the runtime of a parallel application using the messagepassing {{model and the}} asynchronous <b>task</b> <b>programming</b> paradigm. The introduced model also considers the complete memory hierarchyofa multiprocessor node architecture. We study the optimizied parallel Linpack application as an example benchmark program. The predicted performances are compared with measurements on a PowerPC based distributed memory computer with shared memory nodes. We discuss {{the quality of the}} model for various processor numbers and problem sizes...|$|E
50|$|The z/OS {{operating}} system allows started tasks {{to be modified}} by an operator command. That allows {{the behavior of the}} started task to be dynamically altered. The degree of modification permitted {{is a function of the}} started <b>task</b> <b>program</b> and the limits of the environment.|$|R
50|$|The game {{features}} hacker-themed puzzles {{where the}} stylus is used for, among other <b>tasks,</b> <b>program</b> repair and password cracking. Project Hacker plays like a first person point and click adventure game outside of these puzzles, {{similar to the}} Ace Attorney series (also known as the Phoenix Wright series).|$|R
40|$|The paper {{describes}} the silicon material {{task of the}} low-cost solar array project, which has the objective of establishing a silicon production capability equivalent to 500 mW per year at a price less than 10 dollars/kg (1975 dollars) in 1986. The <b>task</b> <b>program</b> is divided into four phases: technical feasibility, scale-up studies (the present phase), experimental process system development units, and implementation of large-scale production plants, and it involves the development of processes for two groups of materials, that is, semiconductor grade and solar cell grade. In addition, the effects of impurities on solar cell performance are being investigated. Attention is given to problem areas of the <b>task</b> <b>program,</b> such as environmental protection, material compatibility between the reacting chemicals and materials of construction of the equipment, and waste disposal...|$|R
40|$|A {{ubiquitous}} {{network is}} characterised {{by a large}} number of small computers embedded in our environment. Writing distributed applications for this kind of network can be a challenging <b>task.</b> <b>Programming</b> and re-programming each single device is not feasible; it is too time consuming, too costly and too error prone. We argue that a top-down approach to writing applications is useful. We propose a highlevel language that can specify a ubiquitous network’s global behaviour. A compiler can automatically generate device-level executables from this global specification...|$|E
40|$|Heuristic {{procedures}} {{based on}} priority rules are quite frequently used {{to solve the}} multiple resource-constrained project-scheduling problem (RCPSP), i. e. <b>task</b> <b>programming</b> with limited resources. The rules {{are based on the}} problem knowledge. Different local search procedures have been proposed in order to look for acceptable solutions in scheduling problems. In this work, local search procedures, that define the solution neighborhood based on greedy heuristics, are proposed to assign assembly operations to a fixed number of robots in a manufacturing cell. A genetic algorithm is used to generate the solutionPostprint (published version...|$|E
40|$|Organizing the {{programming}} effort for large projects {{can be a}} daunting <b>task.</b> <b>Programming</b> teams are under pressure to complete work accurately and rapidly, while using standard templates and macros whenever possible. Add to that several levels of documentation and a manager’s need for frequent status updates {{and you have an}} administrative nightmare. A system is necessary to integrate programming documentation, validation checklists, and real-time status reports. After deciding to centralize our project management spreadsheet, program header documentation, and validation documents in a database, we found that we had the beginnings of a web-based programming development environment (PDE) for SAS programs...|$|E
40|$|The {{applications}} for which Ada was developed require distributed implementations {{of the language}} and extensive use of tasking facilities. Debugging and testing technology {{as it applies to}} parallel features of languages currently falls short of needs. Thus, the development of embedded systems using Ada pose special challenges to the software engineer. Techniques for distributing Ada programs, support for simulating distributed target machines, testing facilities for <b>tasked</b> <b>programs,</b> and debugging support applicable to simulated and to real targets all need to be addressed. A technique is presented for debugging Ada <b>programs</b> that use <b>tasking</b> and it describes a debugger, called AdaTAD, to support the technique. The debugging technique is presented together with the use interface to AdaTAD. The component of AdaTAD that monitors and controls communication among tasks was designed in Ada and is presented through an example with a simple <b>tasked</b> <b>program...</b>|$|R
40|$|The Java {{language}} {{enables the}} development of concurrent and distributed software through the concepts of thread and remote method invocation (RMI). It is known that developing concurrent and distributed software is a challenging task, mainly because of potential concurrency errors such as deadlocks and livelocks. One promising way to help the designer bl this task is providing static analysis tools that can detect such errors in the source code, as documented in the rich literature on static analysis of Ada <b>tasking</b> <b>programs.</b> This paper extends the approach followed for Ada <b>tasking</b> <b>programs</b> to the new Java language, providing formal models for the main thread synchronization primitives offered by the language. The formalism used is Promela, the input language of the model checker SPIN, {{which is based on}} extended communicating finite state machines and provides an efficient analysis algorith...|$|R
40|$|Static {{analysis}} of Ada <b>tasking</b> <b>programs</b> has been hindered by the well known state explosion problem that arises in the verification of concurrent systems. Many different techniques {{have been proposed}} to combat this state explosion. All proposed methods excel on certain kinds of systems, {{but there is little}} empirical data comparing the performance of the methods. In this paper, we select one representative from each of three very different approaches to the state explosion problem: partial-orders (representing state-space reductions), symbolic model checking (representing OBDD-based approaches), and inequality necessary conditions (representing integer programming-based approaches). We apply the methods to several scalable concurrency examples from the literature and to one real Ada <b>tasking</b> <b>program.</b> The results of these experiments are presented and their significance is discussed. 1 Introduction Ada tasks arm software developers with the power, and dangers, of concurrency. With this p [...] ...|$|R
40|$|Abstract: Teaching {{computer}} programming to artists and designers with no prior programming {{experience is a}} challenging <b>task.</b> <b>Programming</b> relies {{on the ability to}} observe, analyse, classify and organize thinking, analytically structuring the reasoning, processes with which artists and designers typically are not familiar with or at least do not formalize them in the same way programmers do. The aim {{of this paper is to}} share an experience on the teaching/learning of {{computer programming}} by artists and designers. This work was developed during the school year of 2007 - 2008, in the context of the course of Fundamentals of We...|$|E
40|$|Software {{development}} is a complex and error prone <b>task.</b> <b>Programming</b> languages with strong static type systems assist programmers by capturing and checking the fundamental structure of programs in a very intuitive way. Given this success, it is natural to ask: can we capture and check more {{of the structure of}} programs? In this dissertation I describe an approach called refinement-type checking that allows many common program properties to be captured and checked. This approach builds on the strength of the type system of a language by adding the ability to specify refinements of each type. Following previous work, I focus on refinements that include subtyping and a form of intersection types. Cental to m...|$|E
40|$|Despite the {{increasing}} attention to global IS work, {{there is limited}} understanding of why and how global IS development projects succeed or fail. Based on the literature on IS success and global teams, we develop a conceptual framework for global IS development project success. We also conducted interviews with nine global IS project managers to validate this framework through a qualitative attribution analysis to identify common themes and patterns of the interview results. Global project managers identified time separation, cultural differences and geographic distance as the most significant barriers to project success. Organizations implemented various communication mechanisms, <b>task</b> <b>programming,</b> and project control methods to mitigate global risks, leading to project success. 1...|$|E
30|$|Participants {{were asked}} to press the space button as quickly as {{possible}} every time the red ‘dot’ was presented on the monitor in 121 trials for the PPVT (PEBL Perceptual Vigilance <b>Task)</b> <b>program</b> of PEBL. The stimuli were presented with an inter-stimulus interval that varied randomly between 1 and 3.5  seconds. Reaction Times (RTs) were recorded in milliseconds.|$|R
40|$|In {{this paper}} I present an {{automatic}} technique for transforming a program {{by changing the}} data types in that program to ones which are more appropriate for the <b>task.</b> <b>Programs</b> are synthesised by proving modified synthesis theorems in the proofs-as-programs paradigm. The transformation can be verified in the logic of type theory. Transformations are motivated by [...] ...|$|R
40|$|Abstract. Programming {{education}} and contests have introduced software to help evaluation by executing submitted taskwork. We present {{the notion of}} a task package as a unit for collecting, storing, archiving, and exchanging all information concerning a <b>programming</b> <b>task.</b> We also de-scribe a specific format for such task packages as used in our system Peach, and illustrate it with an example. Our goal is to stimulate the development of an international standard for packaging of <b>programming</b> <b>tasks.</b> Key words: <b>programming</b> education, <b>programming</b> contest, <b>programming</b> <b>task,</b> task package, grading support software, data format. 1...|$|R
40|$|In this work, {{we propose}} a novel robot {{learning}} framework called Neural <b>Task</b> <b>Programming</b> (NTP), which bridges {{the idea of}} few-shot learning from demonstration and neural program induction. NTP takes as input a task specification (e. g., video demonstration of a task) and recursively decomposes it into finer sub-task specifications. These specifications are fed to a hierarchical neural program, where bottom-level programs are callable subroutines that interact with the environment. We validate our method in three robot manipulation tasks. NTP achieves strong generalization across sequential tasks that exhibit hierarchal and compositional structures. The experimental results show that NTP learns to generalize well to- wards unseen tasks with increasing lengths, variable topologies, and changing objectives...|$|E
40|$|Abstract — Understanding and {{interpreting}} dynamic scenes and activities {{is a very}} challenging problem. In this paper we present a system capable of learning robot tasks from demonstration. Classical robot <b>task</b> <b>programming</b> requires an experienced programmer {{and a lot of}} tedious work. In contrast, Programming by Demonstration is a flexible framework that reduces the complexity of programming robot tasks, and allows end-users to demonstrate the tasks instead of writing code. We present our recent steps towards this goal. A system for learning pick-andplace tasks by manually demonstrating them is presented. Each demonstrated task is described by an abstract model involving a set of simple tasks such as what object is moved, where it is moved, and which grasp type was used to move it. I...|$|E
40|$|On many {{parallel}} target platforms {{it can be}} {{advantageous to}} implement parallel applications {{as a collection of}} multiprocessor tasks that are concurrently executed and are internally implemented with fine-grain SPMD parallelism. A class of applications which can benefit from this programming style are methods for solving systems of ordinary differential equations. Many recent solvers have been designed with an additional potential of method parallelism, but the actual effectiveness of mixed task and data parallelism depends on the specific communication and computation requirements imposed by the equation to be solved. In this paper we study mixed task and data parallel implementations for general linear methods realized using a library for multiprocessor <b>task</b> <b>programming.</b> Experiments on a number of different platforms show good efficiency results...|$|E
5000|$|... #Caption: Skinner's {{teaching}} machine, {{a mechanical}} invention to automate the <b>task</b> of <b>programmed</b> instruction ...|$|R
5000|$|Script dynamic imaging: A shell {{script is}} used to {{automate}} repeated <b>tasks</b> in <b>programs.</b>|$|R
40|$|We {{introduce}} here {{a software}} architecture {{for the control}} of a sensor based manufacturing system consisting {{of a number of}} machines and peripheral equipment. The architecture divides the programming effort into two levels, <b>task</b> level <b>programming</b> and control level <b>programming.</b> The <b>task</b> level <b>programming</b> is based on the programming of a discrete model of the world, the World Model (WM). The WM provides a symbolic representation of the world state and isolates the <b>task</b> <b>programs</b> from the control level algorithms. Programming the control level amounts to modelling the manufacturing equipment as components with `behaviour' using object oriented techniques. Each component specifies how it should react to changes in the WM, i. e. selection and specification of the control algorithms to be executed. Programming at both levels can be done incrementally and control algorithms may be changed dynamically in the real-time kernel. INTRODUCTION This report presents a model for the execution of task le [...] ...|$|R
40|$|Abstract—This paper {{presents}} {{the development of}} a software application for Off-line robot <b>task</b> <b>programming</b> and simulation. Such application is designed to assist in robot task planning and to direct manipulator motion on sensor based programmed motion. The concept of the designed programming application is to use the power of the knowledge base for task accumulation. In support of the programming means, an interactive graphical simulation for manipulator kinematics was also developed and integrated into the application as the complimentary factor to the robot programming media. The simulation provides the designer with useful, inexpensive, off-line tools for retain and testing robotics work cells and automated assembly lines for various industrial applications. Keywords—Robot programming, task-level programming, robot languages, robot simulation, robotics software. R I...|$|E
40|$|Part 1 : Hyperconnectivity and Interoperation - Hyperconnected SystemsInternational audienceIn {{the past}} years, {{the use of}} {{industrial}} robots was on the rise. Today, they are used for mass production in large enterprises. On the contrary, deployment of robots in small enterprises is lagging behind. Programming time is usually two orders of magnitude larger than the cycle time, and this fact severely limits applicability of robots in small batch production. This work analyzes opportunities to profitably employ robots {{also in this case}} through the adoption of the human-robot collaboration. A collaboration paradigm is proposed, where the tasks are assigned to robotic and human workers based on the batch size, <b>task</b> <b>programming</b> complexity (time), and manual execution time. The validity of this approach is demonstrated in a case study conducted in a collaborative human-robot work cell...|$|E
40|$|Bifocal VDT (Visual Display Terminal) {{operators}} (50) {{were studied}} from different fields (data entry, conversational <b>task,</b> <b>programming,</b> CAD/CAM etc.) through user-product-environment system. Users profile includes experiments pertaining to users reactions, while products profile covers designs, manufacturing {{and marketing of}} existing computer furniture in the market. Existing VDT workstations were observed inappropriate for bifocal people facing vision problem, which was analysed thoroughly in simulated laboratory conditions by preparing a test fig with adjustable monitor angle from horizontal. Work posture of VDT operators was assessed with EMG, Photogram Metric Technique, and Centre of Gravity in four stages of test rig. An ergonomics criterion for redesigning VDT workstation was developed. It is appropriate and natural for the man-machine-environment system and also allows comfortable posture and greater efficiency of bifocal and normal VDT operators...|$|E
40|$|This article {{introduces}} a task-oriented system for off-line programming of welding robots. The programming approach {{is based on}} models of the workpiece and welding system. The integration of task- specific models and the access to a technology data base with tested welding parameters enable the generation of robot <b>task</b> <b>programs</b> for direct on site execution. Required program adaptions are considered by off-line planning of sensor integration...|$|R
40|$|This {{case study}} {{describes}} {{the implementation of}} the Participative Ergonomics for Manual <b>tasks</b> <b>program</b> (PErforM) at 12 surface and underground coal mines. More than 400 miners have been trained in manual tasks risk assessment and control. This paper describes the project outcomes, presents examples of the risk assessments undertaken and resulting control suggestions; and discusses the lessons learned about the implementation of participative ergonomics programs in coal mining...|$|R
40|$|Any {{object or}} thing in {{computer}} {{has its own}} “Monitor ” So at a time only one <b>task</b> (<b>program,</b> process, or thread) can enter into monitor. So point to discuss is, at the depth or by looking from monitors view Where is the Multitasking (Multiprogramming, Multiprocessing, Multithreading) ????? Even though there are DUAL Core Processors. So this paper discusses how we can achieve a real Multitasking, Multiprocessing & Multithreading by creating and maintaining number of monitors...|$|R
