134|102|Public
25|$|Several state <b>transition</b> <b>table</b> {{types are}} used. The most common {{representation}} is shown below: {{the combination of}} current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using state tables (see also virtual finite-state machine).|$|E
500|$|These methods take {{polynomial}} time, {{proportional to}} {{the square of the}} size of the state <b>transition</b> <b>table</b> of the input automaton. A related algorithm of [...] determines whether a given rule is surjective when applied to finite-length arrays of cells with periodic boundary conditions, and if so, for which lengths.|$|E
2500|$|The {{turnstile}} {{state machine}} {{can be represented}} by a state <b>transition</b> <b>table,</b> showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input: ...|$|E
50|$|State <b>transition</b> <b>tables</b> are {{typically}} two-dimensional tables. There are two common forms for arranging them.|$|R
40|$|Two-level phonology, as {{currently}} practiced, has two severe limitations. One is that phonological generalizations are generally {{expressed in terms}} of <b>transition</b> <b>tables</b> of finite-state automata, and these tables are cumbersome to develop and refine. The other is that lexical idiosyncrasy is encoded by introducing arbitrary discritics into the spelling of a morpheme. This paper explains how phonological rules may be employed instead of <b>transition</b> <b>tables</b> and describes a more elegant way of expressing phonological irregularity than with arbitrary discritics, making use of the fact that generalizations are expressed with rules instead of automata...|$|R
40|$|Given the immanent gene {{expression}} mapping covering whole genomes during development, health and disease, we seek computational methods to maximize functional inference from such large data sets. Is it possible, in principle, to completely infer a complex regulatory network architecture from input/output patterns of its variables? We investigated this possibility using binary models of genetic networks. Trajectories, or state <b>transition</b> <b>tables</b> of Boolean nets, resemble time series of {{gene expression}}. By systematically analyzing the mutual information between input states and output states, one {{is able to}} infer the sets of input elements controlling each element or gene in the network. This process is unequivocal and exact for complete state <b>transition</b> <b>tables.</b> We implemented this REVerse Engineering ALgorithm (REVEAL) in a C program, and found the problem to be tractable within the conditions tested so far. For n= 50 (elements) and k= 3 (inputs per element), the analysis of incomplete state <b>transition</b> <b>tables</b> (100 state <b>transition</b> pairs {{out of a possible}} 10 15) reliably produced the original rule and wiring sets. While this study is limited to synchronous Boolea...|$|R
2500|$|There is a {{wide variety}} of {{representations}} possible and one can express a given Turing machine program as a sequence of machine tables (see more at finite-state machine, state <b>transition</b> <b>table</b> and control table), as flowcharts and drakon-charts (see more at state diagram), or as a form of rudimentary machine code or assembly code called [...] "sets of quadruples" [...] (see more at Turing machine).|$|E
2500|$|In {{computer}} science, simulation {{has some}} specialized meanings: Alan Turing {{used the term}} [...] "simulation" [...] to refer to {{what happens when a}} universal machine executes a state <b>transition</b> <b>table</b> (in modern terminology, a computer runs a program) that describes the state transitions, inputs and outputs of a subject discrete-state machine. [...] The computer simulates the subject machine. Accordingly, in theoretical computer science the term simulation is a relation between state transition systems, useful in the study of operational semantics.|$|E
5000|$|Consider the {{classical}} deterministic finite automaton {{given by the}} state <b>transition</b> <b>table</b> ...|$|E
5000|$|The LR(1) parser is a {{deterministic}} automaton {{and as such}} {{its operation}} is based on static state <b>transition</b> <b>tables.</b> These codify the grammar of the language it recognizes and are typically called [...] "parsing tables".|$|R
40|$|We use latent class {{models to}} correct {{measurement}} error in {{estimates of the}} dynamics of relative income poverty in ten EU countries measured over four waves of the European Community Household Panel. A latent mover-stayer Markov model gives an acceptable fit to all ten <b>transition</b> <b>tables.</b> We focus in more detail on four countries – Denmark, the Netherlands, Italy and the UK – and show that mobility in poverty <b>transition</b> <b>tables</b> is over-estimated by between 25 and 50 percent if measurement error is ignored. In addition, once error is corrected, poverty rates show less cross-national variation. Copyright Kluwer Academic Publishers 2004 income poverty, poverty dynamics, measurement error, latent class models,...|$|R
50|$|If the set {{of states}} Q is finite, then the {{transition}} functions are commonly represented as state <b>transition</b> <b>tables.</b> The construction of all possible transitions driven by strings in the free group has a graphical depiction as de Bruijn graphs.|$|R
50|$|State <b>transition</b> <b>table</b> is a table showing {{relation}} between an input and a state.|$|E
50|$|An {{example of}} a state <b>transition</b> <b>table</b> for a machine M {{together}} with the corresponding state diagram is given below.|$|E
50|$|Langton's Loops {{run in a}} CA {{that has}} 8 states, and uses the von Neumann {{neighborhood}} with rotational symmetry. The <b>transition</b> <b>table</b> can be found here: http://code.google.com/p/ruletablerepository/wiki/TheRules#Self-replicating_loops.|$|E
30|$|DBN_TE {{receives}} as input the received ISI-corrupted coded symbols, the <b>transition</b> probability <b>table,</b> the <b>transition</b> output <b>table,</b> the codeword length, the coded {{data block}} length, {{the number of}} states of the graph, the new channel after transformation, the number of iterations and the noise standard deviation.|$|R
5000|$|PALASM is {{an early}} {{hardware}} description language, used to translate Boolean functions and state <b>transition</b> <b>tables</b> into a fuse map for use with Programmable Array Logic (PAL) devices introduced by Monolithic Memories, Inc. The language was developed by John Birkner in the early 1980s. It is not case-sensitive.|$|R
40|$|We {{present a}} formal {{approach}} for handling inconsistencies in Software Cost Reduction (SCR) specifications. The approach uses an event-based logic, called the Event Calculus, to represent SCR mode <b>transition</b> <b>tables.</b> Building on this formalism, the approach provides an abductive reasoning mechanism {{that enables the}} analysis of inconsistencies between SCR mode <b>transition</b> <b>tables</b> and global requirements (invariants), and the identification of alternative changes that would resolve such inconsistencies. Changes include addition of new invariants, refinement of existing invariants, and changes on conditions of mode transitions. The methodology is widely applicable, in particular to systems embedded in complex environments whose initial conditions cannot be completely predicted. A case study of an automobile cruise control system is used to illustrate our approach. The technique described is implemented using existing tools for abductive logic programming...|$|R
5000|$|Implement a finite-state machine, using a state <b>transition</b> <b>table</b> and goto {{to switch}} between states (in absence of tail call elimination), {{particularly}} in automatically generated C code. For example, goto in the canonical LR parser.|$|E
5000|$|The {{turnstile}} {{state machine}} {{can be represented}} by a state <b>transition</b> <b>table,</b> showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input: ...|$|E
50|$|Simultaneous {{transitions}} in multiple finite state machines {{can be shown}} in what is effectively an n-dimensional state <b>transition</b> <b>table</b> in which pairs of rows map (sets of) current states to next states. This is an alternative to representing communication between separate, interdependent state machines.|$|E
50|$|DEVS abbreviating Discrete Event System Specification is a modular and {{hierarchical}} formalism for {{modeling and}} analyzing general systems {{that can be}} discrete event systems which might be described by state <b>transition</b> <b>tables,</b> and continuous state systems which might be described by differential equations, and hybrid continuous state and discrete event systems. DEVS is a timed event system.|$|R
50|$|Stateflow (developed by MathWorks) is {{a control}} logic tool used to model {{reactive}} systems via state machines and flow charts within a Simulink model. Stateflow uses {{a variant of}} the finite-state machine notation established by David Harel, enabling the representation of hierarchy, parallelism and history within a state chart. Stateflow also provides state <b>transition</b> <b>tables</b> and truth tables.|$|R
40|$|This paper {{studies the}} problem of {{synthesis}} of linear sequential machines from <b>transition</b> <b>tables</b> which are not necessarily coded and reduced. Two synthesis procedures are presented. One is adopted from linear system theory; {{the other is a}} modification of Cohn and Even's method. These two procedures not only are computationally simpler than any existing methods, but also yield minimal canonical form equations...|$|R
50|$|The state {{value is}} conceptually based on {{which of the}} {{patterns}} in the following table match the latest 2-4 packet types seen, and is implemented as a state machine state updated according to the <b>transition</b> <b>table</b> listed in the table every time a packet is output.|$|E
50|$|Frances Grodzinsky et al. {{considered}} artificial {{systems that}} could be modelled as finite state machines. They posited that if the machine had a fixed state <b>transition</b> <b>table,</b> then {{it could not be}} morally responsible. If the machine could modify its table, then the machine's designer still retained some moral responsibility.|$|E
5000|$|These methods take {{polynomial}} time, {{proportional to}} {{the square of the}} size of the state <b>transition</b> <b>table</b> of the input automaton. A related algorithm of [...] determines whether a given rule is surjective when applied to finite-length arrays of cells with periodic boundary conditions, and if so, for which lengths.|$|E
40|$|We {{describe}} a recurrent connectionist network, called CONCERT, {{that uses a}} set of melodies written in a given style to compose new melodies in that style. CONCERT {{is an extension of}} a traditional algorithmic composition tech-nique in which <b>transition</b> <b>tables</b> specify the probability of the next note as a function of previous context. A central ingredient of CONCERT is the use of a psychologically-grounded representation of pitch. ...|$|R
40|$|This paper {{presents}} a basic enhancement to the DeSTIN deep learning architecture by replacing the explicitly calculated <b>transition</b> <b>tables</b> {{that are used}} to capture temporal features with a simpler, more scalable mechanism. This mechanism uses feedback of state information to cluster over a space comprised of both the spatial input and the current state. The resulting architecture achieves state-of-the-art results on the MNIST classification benchmark. ...|$|R
5000|$|Black-box testing {{treats the}} {{software}} as a [...] "black box", examining functionality without {{any knowledge of}} internal implementation, without seeing the source code. The testers are only aware of what the software is supposed to do, not how it does it. Black-box testing methods include: equivalence partitioning, boundary value analysis, all-pairs testing, state <b>transition</b> <b>tables,</b> decision table testing, fuzz testing, model-based testing, use case testing, exploratory testing and specification-based testing.|$|R
50|$|For a nondeterministic finite {{automaton}} (NFA), a new input may cause {{the machine to}} be {{in more than one}} state, hence its non-determinism. This is denoted in a state <b>transition</b> <b>table</b> by a pair of curly braces { } with the set of all target states between them. An example is given below.|$|E
5000|$|As with Turing machines, {{the actions}} are {{specified}} {{by a state}} <b>transition</b> <b>table</b> listing the current internal state of the turmite {{and the color of}} the cell it is currently standing on. For example, the turmite shown in the image {{at the top of this}} page is specified by the following table: ...|$|E
50|$|Note {{that the}} {{resulting}} stack {{can be interpreted}} as the history of a finite state automaton that has just read a nonterminal E followed by a terminal '+'. The <b>transition</b> <b>table</b> of this automaton is defined by the shift actions in the action table and the goto actions in the goto table.|$|E
40|$|A {{computer}} {{program has been}} written which composes blues melodies to fit a given backing chord sequence. The program is comprised of an analysis stage followed by a synthesis stage. The analysis stage takes blues tunes and produces zero, first and second order Markov <b>transition</b> <b>tables</b> covering both pitches and rhythms. In order to capture the relationship between harmony and melody, a set of <b>transition</b> <b>tables</b> is produced for each chord in the analysed songs. The synthesis stage uses the output tables from analysis to generate new melodies; second order tables are used as much as possible, with fall back procedures, to first and zero order tables, to deal with zero frequency problems. Some constraints are encoded {{in the form of}} rules to control the placement of rhythmic patterns within measures, pitch values for long duration notes and pitch values for the start of new phrases. A listening experiment was conducted to determine how well the program captures the structure of blues melodies. Results showed that listeners were unable to reliably distinguish human from computer composed melodies...|$|R
40|$|This work is an {{extension}} of research done by the Evolving Cellular Automata (EvCA) group at the Santa Fe Institute. Specifically, it is {{an extension}} of their application of genetic algorithms (GAs) to design cellular automata (CAs) that synchronize globally while using only local information [1]. In the work of Das et. al, 1 -D CA <b>transition</b> <b>tables</b> for a neighborhood of size seven (radius of 3) are searched with a GA. The fitnes...|$|R
40|$|All {{experimental}} psychologists {{understand the}} importance of randomizing lists of items. However, randomization is generally constrained and these constraints, in particular, not allowing immediately repeated items, which are designed to eliminate particular biases, frequently engender others. We describe a simple Monte Carlo randomization technique that solves a number of these problems. However, in many experimental settings, we are concerned not only with the number and distribution of items, but also with the number and distribution of transitions between items. The above algorithm provides no control over this. We, therefore, introduce a simple technique using <b>transition</b> <b>tables</b> for generating correctly randomized sequences. We present an analytic method of producing item-pair frequency tables and item-pair transitional probability tables when immediate repetitions are not allowed. We illustrate these difficulties – and how to overcome them – with reference to a classic paper on infant word segmentation. Finally, we make available an Excel file that allows users to generate <b>transition</b> <b>tables</b> with up to ten different item types, and to generate appropriately distributed randomized sequences of any length without immediately repeated elements. This file is freely available at...|$|R
