10|9|Public
50|$|Software {{prototyping}} {{has many}} variants. However, {{all of the}} methods are in some way based on two major forms of prototyping: <b>throwaway</b> <b>prototyping</b> and evolutionary prototyping.|$|E
50|$|The {{usage of}} storyboards, {{animatics}} or drawings {{is not exactly}} the same as <b>throwaway</b> <b>prototyping,</b> but certainly falls within the same family. These are non-functional implementations but show how the system will look.|$|E
50|$|Another {{strength}} of <b>throwaway</b> <b>prototyping</b> {{is its ability}} to construct interfaces that the users can test. The user interface is what the user sees as the system, and by seeing it in front of them, {{it is much easier to}} grasp how the system will function.|$|E
5000|$|Iteratively {{produces}} production software, {{as opposed}} to a <b>throwaway</b> <b>prototype.</b>|$|R
50|$|After {{the user}} session is over, the prototyper {{constructs}} a <b>throwaway</b> <b>prototype</b> {{on top of}} the baseline system.|$|R
50|$|Prototypes can be {{classified}} according to the fidelity with which they resemble the actual product in terms of appearance, interaction and timing. One method of creating a low fidelity <b>throwaway</b> <b>prototype</b> is paper prototyping. The prototype is implemented using paper and pencil, and thus mimics {{the function of the}} actual product, but does not look at all like it. Another method to easily build high fidelity <b>throwaway</b> <b>prototypes</b> is to use a GUI Builder and create a click dummy, a prototype that looks like the goal system, but does not provide any functionality.|$|R
5000|$|Developer {{attachment}} to prototype: Developers can also {{become attached to}} prototypes they have {{spent a great deal}} of effort producing; this can lead to problems, such as attempting to convert a limited prototype into a final system when it does not have an appropriate underlying architecture. (This may suggest that <b>throwaway</b> <b>prototyping,</b> rather than evolutionary prototyping, should be used.) ...|$|E
5000|$|Operational {{prototyping}} {{was proposed}} by Alan Davis {{as a way}} to integrate throwaway and evolutionary prototyping with conventional system development. [...] "It offers the best of both the quick-and-dirty and conventional-development worlds in a sensible manner. Designers develop only well-understood features in building the evolutionary baseline, while using <b>throwaway</b> <b>prototyping</b> to experiment with the poorly understood features." ...|$|E
50|$|Evolutionary {{prototyping}} (also {{known as}} breadboard prototyping) {{is quite different}} from <b>throwaway</b> <b>prototyping.</b> The main goal when using evolutionary prototyping is to build a very robust prototype in a structured manner and constantly refine it. The reason for this approach is that the evolutionary prototype, when built, forms the heart of the new system, and the improvements and further requirements will then be built.|$|E
50|$|Evolutionary prototypes have an {{advantage}} over <b>throwaway</b> <b>prototypes</b> {{in that they are}} functional systems. Although they may not have all the features the users have planned, they may be used on an interim basis until the final system is delivered.|$|R
5000|$|Also called close-ended <b>prototyping.</b> <b>Throwaway</b> or rapid <b>prototyping</b> {{refers to}} the {{creation}} of a model that will eventually be discarded rather than becoming part of the final delivered software. After preliminary requirements gathering is accomplished, a simple working model of the system is constructed to visually show the users what their requirements may look like when they are implemented into a finished system.It is also a rapid prototyping.|$|R
40|$|In this paper, {{we present}} an {{approach}} to the object-oriented software development which is based on: i) automatic generation of a <b>throwaway</b> <b>prototype</b> from the initial specification in a formal, declarative, object-oriented specification language, ii) validation of user requirements and refinement of the specification by using this prototype, and iii) automatic translation from the validated specification types to programming classes including the semantics of the formal specification by means of assertions. The last step is achieved by using an object-oriented implementation language supporting Eiffel-like assertions and the "Design by Contract" technique; therefore, these classes force the first evolutionary prototype (that will evolve to the final software) to be formally consistent with the validated specification. This approach {{is supported by a}} high level CARE (Computer-Aided Requirements Engineering) tool...|$|R
50|$|In human-computer interaction, paper {{prototyping}} is {{a widely}} used method in the user-centered design process, a process that helps developers to create software that meets the user's expectations and needs—in this case, especially for designing and testing user interfaces. It is <b>throwaway</b> <b>prototyping</b> and involves creating rough, even hand-sketched, drawings of an interface to use as prototypes, or models, of a design. While paper prototyping seems simple, this method of usability testing can provide {{a great deal of}} useful feedback which will result in the design of better products. This is supported by many usability professionals.|$|E
50|$|The {{most obvious}} reason for using <b>throwaway</b> <b>prototyping</b> {{is that it}} can be done quickly. If the users can get quick {{feedback}} on their requirements, {{they may be able to}} refine them early in the development of the software. Making changes early in the development lifecycle is extremely cost effective since there is nothing at that point to redo. If a project is changed after a considerable amount of work has been done then small changes could require large efforts to implement since software systems have many dependencies. Speed is crucial in implementing a throwaway prototype, since with a limited budget of time and money little can be expended on a prototype that will be discarded.|$|E
40|$|From a {{software}} engineering perspective, moving a business software {{application to the}} web presents interesting challenges. These include frequent changes to requirements, changes to the underlying business function {{as a consequence of}} moving to the web, tight time and cost constraints, and producing quality user interfaces within the restrictions of the web environment. This paper describes a lightweight, two-phase process that integrates advantages from incremental development, <b>throwaway</b> <b>prototyping,</b> and waterfall process models to address these challenges. A successful development experience using this process is summarized. ...|$|E
40|$|This paper {{describes}} {{a major part}} of an architecting methodology developed for safety-critical fault-tolerant software systems. The methodology coverage centers on specificationdriven prototyping. This approach to prototyping is seen to be superior to the customary approaches of <b>throwaway</b> and evolutionary <b>prototyping.</b> A still developmental form of representation, higher-level statecharts, provides a suitably expressive prototype specification language...|$|R
40|$|Software {{prototyping}} {{is considered}} {{to be one of the}} most important tools that are used by software engineersnowadays to be able to understand the customer’s requirements, and develop software products that are efficient,reliable, and acceptable economically. Software engineers can choose any of the available prototyping approaches tobe used, based on the software that they intend to develop and how fast they would like to go during the softwaredevelopment. But generally speaking all prototyping approaches are aimed to help the engineers to understand thecustomer’s true needs, examine different software solutions and quality aspect, verification activities…etc, that mightaffect the quality of the software underdevelopment, as well as avoiding any potential development risks. A combination of several prototyping approaches, and brainstorming techniques which have fulfilled the aim of theknowledge extraction approach, have resulted in developing a prototyping approach that the engineers will use todevelop one and only one <b>throwaway</b> <b>prototype</b> to extract more knowledge than expected, in order to improve thequality of the software underdevelopment by spending more time studying it from different points of view. The knowledge extraction approach, then, was applied to the developed prototyping approach in which thedeveloped model was treated as software prototype, in order to gain more knowledge out of it. This activity hasresulted in several points of view, and improvements that were implemented to the developed model and as a resultAgile Prototyping AP, was developed. AP integrated more development approaches to the first developedprototyping model, such as: agile, documentation, software configuration management, and fractional factorialdesign, in which the main aim of developing one, and only one prototype, to help the engineers gaining moreknowledge, and reducing effort, time, and cost of development was accomplished but still developing softwareproducts with satisfying quality is done by developing an evolutionary prototyping and building throwawayprototypes on top of it...|$|R
40|$|This thesis investigates {{free and}} open source {{software}} (FLOSS), and FLOSS {{in the context of}} developing countries. The research is based on two action research case studies. Both case studies are done within the Health Information Systems Programme (HISP) network. HISP is a research and development network focusing on promoting effective use of information in the health systems of developing countries. The first case study was conducted in the Tigray region of Ethiopia. In this case study a team of researchers used action research to configure and adapt District Health Information Software (DHIS) to the local context of the Tigray health system. DHIS is a flexible health information system used to collect routine data from health systems. DHIS is distributed under a FLOSS license. I participated in this team as a software developer. In the second case study I participated in the development of DHIS 2 which is a total reimplementation of DHIS based on a platform of FLOSS technologies. DHIS 2 is developed using distributed voluntary development and licensed under a FLOSS license. In other words DHIS 2 is developed using a community model commonly used by large scale FLOSS projects. I participated in this project as a FLOSS developer, and I focused on the extensibility of DHIS 2. I created a <b>throwaway</b> <b>prototype</b> of a plug-in framework. Through this two case studies I investigate FLOSS and how FLOSS can benefit and are benefiting both Ethiopia and the HISP network. I argue that the access to source code facilitates technology transfer/translation of information and communication technologies (ICT). Context dependent software like health information systems need to be adapted to each local context in order to be useful and effective, having access to source code is a life saver in this process...|$|R
40|$|The {{main goal}} of digital {{forensics}} is {{the extraction of}} suspected files from the target devices that {{can be defined as}} digital evidence. Nowadays, law enforcement agencies in Malaysia such as The Royal Malaysian Police have extensively varying capabilities to conduct forensics, and sometimes have to enlisting the assist from other agencies or outside consultants to perform digital forensics investigation and analysis. Unfortunately, new forensics discoveries are seldom formally shared among the organization or agency even under the same roof. One main problem needs to be addressed is there is no effective way that allows digital forensics experts to share their expertise and collaborate among them. A web-based Knowledge Management System (KMS) for digital forensics is needed to encourage experts in digital forensics share and improve their knowledge. This paper presents a prototype web-based application using the concept of Web 2. 0 technologies integrated with the suitable features of KM System. We had adopted <b>throwaway</b> <b>prototyping</b> methodology and the results show that the system had passed the unit testing...|$|E

