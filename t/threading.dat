4386|10000|Public
5|$|A {{concurrent}} programming language called Alef {{was available in}} the first two editions, but was then dropped for maintenance reasons and replaced by a <b>threading</b> library for C.|$|E
5|$|On 31 March, Triton {{crossed over}} the Philippine Trench and began <b>threading</b> {{her way through the}} vast Philippine archipelago, passing from the Philippine Sea through the Surigao Strait and then the Mindanao Sea, and finally through the Bohol Strait into the Camotes Sea.|$|E
5|$|As {{support for}} {{multiple}} instruction set architectures complicates symmetric multiprocessing (SMP) support, DragonFly BSD now limits its {{support to the}} x86-64 platform. DragonFly originally ran on the x86 architecture, however as of version 4.0 {{it is no longer}} supported. Since version 1.10, DragonFly supports 1:1 userland <b>threading</b> (one kernel thread per userland thread), which is regarded as a relatively simple solution that is also easy to maintain. Inherited from FreeBSD, DragonFly also supports multi-threading.|$|E
50|$|This weave {{code means}} that the <b>threads</b> begin with 8 <b>threads</b> of yellow, {{followed}} by 2 <b>threads</b> of black, 20 <b>threads</b> of green, 4 <b>threads</b> of scarlet, 20 <b>threads</b> of green, 8 <b>threads</b> of scarlet, 20 <b>threads</b> of green, 4 <b>threads</b> of scarlet, 20 <b>threads</b> of green, 32threads of black, 56 <b>threads</b> of azure, 2 <b>threads</b> of black, and 8 <b>threads</b> of sky blue. At that point the weave pivots and returns, beginning with 2 <b>threads</b> of black, and continuing the sequence in reverse order through 8 <b>threads</b> of yellow, at which point it pivots back again.|$|R
50|$|A Unified <b>Thread</b> Standard UNC <b>thread</b> is {{mechanically}} interchangeable with a USS <b>thread</b> of {{the same}} diameter. However, there are tolerance and other differences between a <b>thread</b> compliant with the USS <b>thread</b> and a Unified <b>Thread</b> Standard UNC <b>thread.</b> The Unified <b>Thread</b> Standard for quarter inch and larger <b>threaded</b> fasteners was adopted on November 18, 1948, and was subsequently adopted for smaller <b>thread</b> series.|$|R
50|$|United States Standard <b>thread</b> (USS <b>thread),</b> {{also known}} as Sellers Standard <b>thread,</b> Franklin Institute <b>thread</b> and American Standard <b>thread,</b> is a {{standard}} for inch based <b>threaded</b> fasteners and washers.|$|R
5|$|Dillon started DragonFly in {{the belief}} that the methods and {{techniques}} being adopted for <b>threading</b> and symmetric multiprocessing in FreeBSD 5 would lead to poor system performance and cause maintenance difficulties. He sought to correct these suspected problems within the FreeBSD project. Due to ongoing conflicts with other FreeBSD developers over the implementation of his ideas, his ability to directly change the FreeBSD codebase was eventually revoked. Despite this, the DragonFly BSD and FreeBSD projects still work together contributing bug fixes, driver updates, and other system improvements to each other.|$|E
5|$|The Kootenay rises on the {{northeast}} slopes of the Beaverfoot Range of southeastern British Columbia, and flows initially southeast through the valleys of Kootenay National Park. Its first few kilometers (miles) are quiet, <b>threading</b> slowly {{through a series of}} marshes and small lakes. The river becomes significantly enlarged as it reaches the confluence with the Vermilion River, which is actually the larger of the two where they meet near the settlement of Kootenay Crossing. It continues southeast, receiving the Palliser River from the left, and swings southwards into a gorge at the confluence with the White River.|$|E
5|$|In DragonFly, each CPU {{has its own}} thread scheduler. Upon creation, threads are {{assigned}} to processors and are never preemptively switched from one processor to another; they are only migrated by the passing of an inter-processor interrupt (IPI) message between the CPUs involved. Inter-processor thread scheduling is also accomplished by sending asynchronous IPI messages. One advantage to this clean compartmentalization of the <b>threading</b> subsystem is that the processors' on-board caches in Symmetric Multiprocessor Systems do not contain duplicated data, allowing for higher performance by giving each processor in the system {{the ability to use}} its own cache to store different things to work on.|$|E
50|$|Acme <b>threads</b> have a 29° <b>thread</b> angle, {{which is}} easier to machine than square <b>threads.</b> They are not as {{efficient}} as square <b>threads,</b> due to the increased friction induced by the <b>thread</b> angle. ACME <b>Threads</b> are generally also stronger than square <b>threads</b> due to their trapezoidal <b>thread</b> profile, which provides greater load-bearing capabilities.|$|R
25|$|The {{trapezoidal}} metric <b>thread</b> form {{is similar}} to the Acme <b>thread</b> form, except the <b>thread</b> angle is 30°. It is codified by DIN 103. While metric screw <b>threads</b> are more prevalent worldwide than imperial <b>threads</b> for triangular <b>thread</b> forms, the imperially sized Acme <b>threads</b> predominate in the trapezoidal <b>thread</b> form. In some cases customers prefer Acme <b>threads</b> for power screws regardless of metric standards used elsewhere in the product.|$|R
5|$|Cylinder <b>threads</b> {{may be in}} {{two basic}} configurations: Taper <b>thread</b> and {{parallel}} <b>thread.</b> These <b>thread</b> specifications are detailed in a previous section. The valve <b>thread</b> specification must exactly match the neck <b>thread</b> specification of the cylinder. Improperly matched neck <b>threads</b> can fail under pressure and can have fatal consequences.|$|R
25|$|Thread cutting, as {{compared}} to thread forming and rolling, is used when full thread depth is required, when the quantity is small, when the blank is not very accurate, when <b>threading</b> up to a shoulder is required, when <b>threading</b> a tapered thread, or when the material is brittle.|$|E
25|$|There {{are various}} types of thread milling, {{including}} several variants of form-milling and a combination of drilling and <b>threading</b> with one cutter, called thrilling.|$|E
25|$|MDAC 1.5c: fixed {{issues with}} ADO <b>threading</b> and ODBC Connection Pooling and was {{distributed}} via the Microsoft website. It only {{came with the}} ADO/MDAC runtime components.|$|E
25|$|Machine {{embroidery}} commonly uses polyester, rayon, or metallic embroidery <b>thread,</b> though other <b>thread</b> {{types are}} available. 40 wt <b>thread</b> {{is the most}} commonly used embroidery <b>thread</b> weight. Bobbin <b>thread</b> is usually either 60 wt or 90 wt. The quality of <b>thread</b> used can greatly affect the number of <b>thread</b> breaks and other embroidery problems. Polyester <b>thread</b> is generally more color-safe and durable. High quality embroidery <b>thread</b> is produced by Exquisite, Gunold, Madeira, Amann and Robison-Anton.|$|R
50|$|A <b>thread</b> {{block is}} a {{programming}} abstraction {{that represents a}} group of <b>threads</b> that can be executing serially or in parallel. For better process and data mapping, <b>threads</b> are grouped into <b>thread</b> blocks. The number of <b>threads</b> varies with available shared memory. 'The number of <b>threads</b> in a <b>thread</b> block is also limited by the architecture {{to a total of}} 512 <b>threads</b> per block.' The <b>threads</b> in the same <b>thread</b> block run on the same stream processor. <b>Threads</b> in the same block can communicate with each other via shared memory, barrier synchronization or other synchronization primitives such as atomic operations.|$|R
40|$|Permits {{concurrent}} {{execution of}} several sequential codes to execute {{within the same}} process (so share memory) method main = new <b>thread,</b> 1 process: the VM the programmer can start new <b>threads,</b> modeled by the <b>Thread</b> class. <b>Thread</b> t = new <b>Thread</b> (); t. s t a r t (); execute method run() in a new <b>Thread</b> the method run() must be overridden <b>Thread</b> t = new <b>Thread</b> () ...|$|R
25|$|The Open Source Technology Center at Intel hosts PowerTOP and LatencyTOP, and {{supports}} other open-source {{projects such as}} Wayland, Intel Array Building Blocks, and <b>Threading</b> Building Blocks (TBB), and Xen.|$|E
25|$|Epilation is {{the removal}} of the entire hair, {{including}} the part below the skin. Methods include waxing, sugaring, epilation devices, lasers, <b>threading,</b> intense pulsed light or electrology. Hair is also sometimes removed by plucking with tweezers.|$|E
25|$|The {{coordination}} of various machine elements including leadscrew, slide rest, and change gears was the technological advance {{that allowed the}} invention of the screw-cutting lathe, which was the origin of single-point <b>threading</b> as we know it today.|$|E
50|$|A client <b>thread</b> {{sending a}} message is BLOCKED (the process <b>thread</b> {{execution}} is temporarily suspended) until the server <b>thread</b> sends a received message acknowledgement, processes the message, and executes a reply. When the server <b>thread</b> replies the client <b>thread</b> becomes READY (unblocked). The server <b>thread</b> typically loops, waiting to receive a message from a client <b>thread.</b>|$|R
40|$|The {{design of}} a kernel-level <b>thread</b> package for dynamic, hard {{real-time}} environments is presented. A highly integrated design is used to ensure predictability. A system description language and real-time programming language are used to specify key properties of <b>threads</b> and <b>thread</b> groups. For a <b>thread,</b> this includes {{whether or not the}} <b>thread</b> spawns other <b>threads</b> at run-time, the type of performance guarantee the <b>thread</b> requires, how the <b>thread</b> interacts with other <b>threads,</b> and what processors the <b>thread</b> may execute on. A predictable kernel uses this information along with on-line dynamic guarantees to ensure predictable execution of <b>threads.</b> The first phase of the <b>thread</b> package has been implemented and performance measurements have indicated a 66 % improvement in context switching costs. 1 Introduction In many non-real-time operating systems, <b>threads</b> have been adopted as the programming model. As opposed to the UNIX-like process model, a <b>thread</b> model separates the address space from [...] ...|$|R
40|$|Using the 2 {{chain stitch}} sewing machine, the dynamic {{tensions}} of needle and looper <b>threads,</b> {{the amount of}} their <b>threads</b> which were fed, {{and the range of}} arm shaft turning angle when their <b>threads</b> were being fed, were simultaneously measured during sewing operation. The three peaks in needle <b>thread</b> tension curve and the two peaks in looper <b>thread</b> tension curve were observed, but the needle <b>thread</b> was fed twice and the looper <b>thread</b> was fed only once during a cycle of the sewing operation. As the tensions pulling out the needle <b>thread</b> increased, the range of arm shaft turning angle when needle <b>thread</b> was being fed the second time, decreased, a smaller amount of needle <b>threads</b> was fed and the each peak values of needle <b>thread</b> tension became large. Also as the tensions pulling out the looper <b>thread</b> increased, the same result was obtained on looper <b>threads.</b> However a smaller amount of needle <b>threads</b> was not fed the first time. As the tensions pulling out the needle <b>thread</b> varied, the relation between the feed length of each <b>thread</b> and peak tension of needle <b>thread</b> was shown by the regression equations...|$|R
25|$|Definition: Forming loops for {{the purpose}} of weaving or the making of net like materials. This is also the <b>threading</b> of two heddles on a loom to allow a 'shed' for the {{shuttlecock}} to pass through. According to the Rambam it is the making of net-like materials.|$|E
25|$|The Raspberry Pi3, with a quad-core Cortex-A53 processor, is {{described}} as 10 times {{the performance of a}} Raspberry Pi1. This was suggested to be highly dependent upon task <b>threading</b> and instruction set use. Benchmarks showed the Raspberry Pi3 to be approximately 80% faster than the Raspberry Pi2 in parallelized tasks.|$|E
25|$|There {{are many}} <b>threading</b> {{processes}} including: cutting threads with a tap or die, thread milling, single-point thread cutting, thread rolling, cold root rolling and forming, and thread grinding. A tap {{is used to}} cut a female thread on the inside surface of a pre-drilled hole, while a die cuts a male thread on a preformed cylindrical rod.|$|E
40|$|DE 102005050126 B 3 UPAB: 20070517 NOVELTY - In a {{monitored}} <b>thread</b> {{guiding device}} in a knitting machine, {{in which a}} <b>thread</b> is guided under tension along a free <b>thread</b> transport zone, having <b>thread</b> supply unit(s), a receiving unit and an optical sensor unit for contact-free detection of <b>thread</b> in the transport zone, sideways oscillation of the <b>thread</b> from its path is caused along the transport zone. DETAILED DESCRIPTION - A monitored <b>thread</b> guiding device in a knitting machine, in which at least one <b>thread</b> is guided under predetermined tension along a free <b>thread</b> transport zone, has unit(s) for supplying the <b>thread</b> along the zone and a unit for receiving and/or further guiding the tensioned <b>thread.</b> An optical sensor unit, for contact-free detection of <b>thread</b> in the transport zone, generates a control or regulation signal for the <b>thread</b> supply and/or receiving unit(s). The novel feature is that a device for causing sideways oscillation of the <b>thread</b> from its path is provided along the transport zone. An INDEPENDENT CLAIM is included for a corresponding monitored <b>thread</b> guiding process, in which controlled transverse oscillations are induced in the <b>thread</b> in the transport zone, optical detection of a consequent dynamic sensor signal is used to indicate an undamaged <b>thread</b> and lack of detection of such a signal is used to detect a broken <b>thread,</b> in which case operation of the knitting machine is halted. USE - For monitored guiding of <b>thread</b> in a knitting machine, especially a circular knitting machine. ADVANTAGE - Guiding of the <b>threads</b> is effectively monitored (especially as regards <b>thread</b> tension) while avoiding additional wear on the knitting machine side components (including the <b>thread</b> itself), so {{that the need for}} expensive and time-consuming maintenance operations is eliminated. Constant <b>thread</b> quality is ensured, especially so that <b>threads</b> of low (specifically non-optically resolvable) roughness are obtained. Yarn guiding within several <b>thread</b> guides can be individually monitored, so that a higher quality knitted product is obtained. The <b>thread</b> tension can be regulated in individual <b>thread</b> guides...|$|R
30|$|Prediction of sewing <b>thread</b> {{consumption}} {{is one of}} the significant factors in <b>thread</b> procurement. In apparel industry both garment manufacturers and <b>thread</b> suppliers predict <b>thread</b> consumption per unit length of stitch for their <b>thread</b> purchasing and logistics processes. Inaccurate <b>thread</b> consumption predictions lead to inaccurate costing and reduction of warehouse utilization for both garment manufacturers and sewing <b>thread</b> manufacturers. Purchase of excess or shortage quantities of <b>thread</b> cones make suppliers to endure those excess or shortage <b>thread</b> quantities, so that both parties undergo inflexible logistic process (Jaouadi et al. 2006). In this context sewing <b>thread</b> manufacturers and garment manufacturers are looking for accurate method predicting sewing <b>thread</b> consumption for given stitch lengths so that wastages could be minimized.|$|R
40|$|<b>Thread</b> milling is {{becoming}} more and more employed as a technique for producing <b>thread,</b> due to its advantages for industrial manufacturing sectors, such as the aeronautics, aerospace, and energy industries. The <b>thread</b> milling operation is atypical and several aspects have to be taken into account to perform it in good conditions. As for milling or grinding worms, grooves, <b>thread</b> or others sculptured surfaces, in <b>thread</b> milling, there exists a geometrical interference between the tool and the nominal surface which would be obtained. <b>Thread</b> mills have quite complex geometry and their profile has an effect on the machined <b>thread.</b> The present study details geometrical aspects of the <b>thread</b> milling process. This article deals with the link between <b>thread</b> mill geometry and nominal <b>thread</b> profile. An approach is proposed to analyze the <b>thread</b> profile generated by the <b>thread</b> mill envelope. It is deduced that <b>thread</b> milling produces interferences, i. e. the machined <b>thread</b> profile is affected by an overcut. A method is proposed to correct this geometrical error in order to produce accurate <b>thread...</b>|$|R
25|$|When American carrier {{strikes against}} the Marianas {{indicated}} {{an invasion of}} Saipan was imminent, the Japanese Combined Fleet staff initiated Operation A-GO on 11 June. Taihō {{and the rest of}} Ozawa's First Mobile Force departed Tawi-Tawi on 13 June, <b>threading</b> their way through the Philippine Islands and setting course for Saipan to attack American carrier forces operating in the vicinity.|$|E
25|$|<b>Threading</b> is {{the process}} of {{creating}} a screw thread. More screw threads are produced each year than any other machine element. There are many methods of generating threads, including subtractive methods (many kinds of thread cutting and grinding, as detailed below); deformative or transformative methods (rolling and forming; molding and casting); additive methods (such as 3D printing); or combinations thereof.|$|E
25|$|The exact set of GCC {{optimizations}} {{varies from}} release to release as it develops, but includes the standard algorithms, such as loop optimization, jump <b>threading,</b> common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance {{with the addition}} of global SSA-based optimizations on GIMPLE trees, as RTL optimizations have a much more limited scope, and have less high-level information.|$|E
50|$|A <b>threaded</b> insert, {{also known}} as a <b>threaded</b> bushing, is a {{fastener}} element that is inserted into an object to add a <b>threaded</b> hole. They may be used to repair a stripped <b>threaded</b> hole, provide a durable <b>threaded</b> hole in a soft material, place a <b>thread</b> on a material too thin to accept it, mold or cast <b>threads</b> into a workpiece thereby eliminating a machining operation, or simplify changeover from unified to metric <b>threads</b> or vice versa.|$|R
5000|$|It is {{necessary}} to set <b>thread</b> priorities in RTLinux. <b>Threads</b> with higher priorities can preempt <b>threads</b> with lower priorities. For example, {{we can have a}} <b>thread</b> controlling a stepper motor. In order to move the motor fluently, it {{is necessary}} to start this <b>thread</b> in strictly regular intervals. This can be guaranteed by assigning a high priority to this <b>thread.</b> The example threads2.c sets different <b>thread</b> priorities. Setting of <b>thread</b> priority is done by code shown below: ...|$|R
50|$|The rounded crest {{and root}} of knuckle <b>threads</b> resembles the Edison screw used on light bulbs, {{although}} bulbs {{have a much}} shallower <b>thread</b> angle than most knuckle <b>threads.</b> The root profile of knuckle <b>threads</b> resembles a ball screw <b>thread,</b> although the flank and crest of ball screw <b>threads</b> is often truncated.|$|R
