0|52|Public
50|$|<b>Thread</b> <b>checking</b> {{includes}} race conditions, deadlocks, depth configurable {{call stack}} analysis, diagnostic guidance, built-in knowledge of Threading Building Blocks (TBB), OpenMP, and POSIX or Win32 threads.|$|R
50|$|Intel Inspector (successor of Intel Thread Checker) is {{a memory}} and <b>thread</b> <b>checking</b> and {{debugging}} toolto increase the reliability, security, {{and accuracy of}} C/C++ and Fortran applications.|$|R
50|$|Note that {{as in the}} {{original}} paper, the <b>thread</b> <b>checks</b> itself before entering the critical section.Since the loop conditions will evaluate as false, this does not cause much delay.|$|R
50|$|The Intel Advisor 2017 is a {{vectorization}} optimization {{and thread}} prototyping tool. It integrates several steps into its workflow {{to search for}} parallel sites, enable users to mark loops for vectorization and <b>threading,</b> <b>check</b> loop-carried dependencies and memory access patterns for marked loops, and insert pragmas for vectorization and threading.|$|R
2500|$|Process and <b>thread</b> blocks: <b>check</b> whether {{process and}} thread blocks have been {{manipulated}} ...|$|R
50|$|Dynamic {{analysis}} tools include: Intel Inspector, a memory and <b>thread</b> <b>checking</b> and debugging tool {{to increase the}} reliability, security, and accuracy of C/C++ and Fortran applications; Intel Advisor, a sampling based, SIMD vectorization optimization and shared memory threading assistance tool for C, C++, C#, and Fortran software developers and architects; ThreadSanitizer, which uses binary (Valgrind-based) or source, LLVM-based instrumentation, and supports PThreads); and Helgrind, a Valgrind tool for detecting synchronisation errors in C, C++, and Fortran programs that use the POSIX pthreads threading primitives.|$|R
5000|$|Control thread Creates as many working threads as {{specified}} in the initialization parameter when Tibero is started, allocates new client connection requests to an idle working <b>thread,</b> and <b>Checks</b> signal processing.|$|R
50|$|Prototype Threading DesignsSoftware architects add code {{annotations}} {{to describe}} threading that are understood by Advisor, but {{ignored by the}} compiler. Advisor then projects the scalability of the <b>threading</b> and <b>checks</b> for synchronization errors.|$|R
40|$|Pointer bugs {{associated}} with dynamically-allocated objects resulting in out-of-bounds memory access {{are an important}} class of software bugs. Because such bugs cannot be detected easily via static-checking techniques, dynamic monitoring schemes have been proposed. However, the key challenge with dynamic monitoring schemes is the runtime overhead (slowdowns {{of the order of}} 10 x are common). Previous approaches have used thread-level speculation (TLS) to reduce the overhead. However, the approaches still incur substantial slowdowns while requiring complex TLS hardware. We make the key observation that because the monitor code and user code are largely and unambiguously independent, TLS hardware with all its complexity to handle speculative parallelism is unnecessary. We explicitly multithread the monitor code in which a <b>thread</b> <b>checks</b> one access and use SMT to exploit the parallelism in the monitor code...|$|R
40|$|In this {{technical}} report we describe describe the Domain Specific Language (DSL) of the Workflow Execution Execution (WEE). Instead of interpreting an XML based workflow description language like BPEL, the WEE uses a minimized but expressive set of statements that runs directly on to of a virtual machine {{that supports the}} Ruby language. Frameworks/Virtual Machines supporting supporting this language include Java,. NET and there exists also a standalone Virtual Machine. Using a DSL gives us the advantage of maintaining a very compact code base of under 400 lines of code, as the host programming language implements all the concepts like parallelism, <b>threads,</b> <b>checking</b> for syntactic correctness. The implementation just hooks into existing statements {{to keep track of}} the workflow and deliver information about current existing context variables and state to the environment that embeds WEE...|$|R
40|$|Abstract—Pointer bugs {{associated}} with dynamically-allocated objects resulting in out-of-bounds memory access {{are an important}} class of software bugs. Because such bugs cannot be detected easily via static-checking techniques, dynamic monitoring schemes have been proposed. However, the key challenge with dynamic monitoring schemes is the runtime overhead (slowdowns {{of the order of}} 10 x are common). Previous approaches have used thread-level speculation (TLS) to reduce the overhead. However, the approaches still incur substantial slowdowns while requiring complex TLS hardware. We make the key observation that because the monitor code and user code are largely and unambiguously independent, TLS hardware with all its complexity to handle speculative parallelism is unnecessary. We explicitly multithread the monitor code in which a <b>thread</b> <b>checks</b> one access and use SMT to exploit the parallelism in the monitor code. Despite multithreading the monitor code on SMT, dynamic monitorin...|$|R
30|$|Out of 15 apps {{considered}} to be designed for orthodontic clinicians, two are related to orthodontic news. Through the Orthotown app, we can post new topics, respond to <b>threads,</b> <b>check</b> out the active topics and cases {{of the day and}} access Orthotown magazine. The Orthodontic exam pro app is the perfect app for those who want face exams worldwide or take up P.G. Exams like MS Ortho or MOrth RCS. Four apps were used to access publications. The app American Journal of Orthodontics & Dentofacial Orthopedics, AJO-DO provides access to AJO-DO, a monthly clinical journal published by AJO-DO. The app Dental press provides access to the Journal of Orthodontics and Maxillary Orthopedics with the objective to publish not only scientific studies, but also other text of interest for clinical orthodontics. The app Intl Asso for Orthodontics provides access to the International Journal of Orthodontics, a quarterly peer- reviewed clinical journal. The Orthodontic Products app is a print and digital publication covering topics such as efficient treatment, staff management, and marketing methods.|$|R
40|$|This thesis {{deals with}} methods for {{inspection}} of {{internal and external}} threads. One of {{the aims of the}} thesis is to give reader insight into the given topic, another one is to improve and simplify process of the <b>thread</b> gauge <b>check</b> at the Czech Metrology Institute (CMI). A database of the thread gauges that are not automatically recognizable by the software used at the CMI will be created. Such thread gauges are still used in practice, but are marked according to the old standards ČSN...|$|R
40|$|VeriFast is a {{verifier}} for single-threaded and multithreaded C and Java programs. It takes a C or Java program annotated with preconditions and postconditions in {{a separation}} logic notation, and verifies statically that these preconditions and postconditions hold, using symbolic execution. In plain separation logic, a thread either has full {{ownership of a}} memory location and knows the value at the location, or it has no ownership and {{no knowledge of the}} value of the location. Existing work proposes a marriage of rely-guarantee reasoning and separation logic to address this. In this document, we describe the shared boxes mechanism, which marries separation logic and rely-guarantee reasoning in VeriFast. We introduce and motivate the shared boxes mechanism using a minimalistic example and a realistic example. The minimalistic example is a counter program where one thread continuously increments a counter and other <b>threads</b> <b>check</b> that the counter does not decrease. For the realistic example, we verify functional correctness of the Michael-Scott queue, a lock-free concurrent data structure. We define the syntax and semantics of a simple C-like programming language, and we define a separation logic with shared boxes and prove its soundness. We discuss the implementation in VeriFast and the examples we verified using our VeriFast implementation. nrpages: 19 status: publishe...|$|R
40|$|The actor {{programming}} {{model is}} based on asynchronous message passing and offers a promising approach for developing reliable concurrent systems. However, lack of guarantees to control {{the order in which}} messages are processed next by an actor makes implementing synchronization and coordination patterns difficult. In this work, we address this issue by introducing our extension to the actor model called selectors. Selectors have multiple mailboxes and each mailbox is guarded i. e. it can be enabled or disabled to affect the order in which messages are processed. The view of having guarded mailboxes is inspired by condition variables where a <b>thread</b> <b>checks</b> whether a condition is true before continuing its execution. Selectors allow us to simplify writing of synchronization and coordination patterns using actors such as a) synchronous request-reply, b) join patterns in streaming applications, c) supporting pri-orities in message processing, d) variants of reader-writer concur-rency, and e) producer-consumer with bounded buffer. We present solutions to each of these patterns using selectors. Selectors can also be implemented efficiently – we evaluate the performance of our library implementation of selectors on benchmarks that exhibit such patterns and we compare our implementation against actor-based solutions using Scala, Akka, Jetlang, Scalaz, Functional-Java and Habanero actor libraries. Our experimental results for the benchmarks show that using selector-based solutions simplify pro-grammability and deliver performance improvements ranging from 1. 1 × to 2 × compared to other actor-based solutions...|$|R
50|$|Upon hearing this, {{the guys}} of Waverly {{decide to make}} history by sneaking into Dumbarton while it is still on lock-down through secret tunnels built during the Cold War. Led by Heath Ferro, Easy Walsh, Brandon Buchanan, Alan St. Girard, Jeremiah Mortimer, and Julian McCafferty make it to Dumbarton unseen by the administration. Upon arrival, they break out the kegs stored under The Girl In Black's room, who {{turns out to be}} Kara Whalen, a {{previously}} chubby girl who was teased mercilessly by Heath Ferro her freshman year. In the spirit of generosity, Tinsley suggests that the girls of Dumbarton open their closets to the other residents so everyone can borrow each other's clothes. Tinsley, on a hunt for the hottest <b>threads,</b> <b>checks</b> on the kegs in Kara's room and discovers Kara has a fantastic wardrobe, thanks to her designer mother. She offers to help Kara with her make up but quickly forgets as the party begins. Jenny and Easy are reunited at the party but he still doesn't mention his dinner with his father and Callie the previous night before. Jenny leaves him in her room to grab drinks but a rumor quickly spreads that a teacher is roaming the hallways. He hides in the closet but is found by Callie who joins him. After she does so, the two begin to kiss but Easy realizes he has strong feelings for Jenny but is confused as to why he is still so attracted to Callie.|$|R
40|$|For {{software}} executing several threads in parallel, {{testing is}} unreliable, as it cannot cover all <b>thread</b> schedules. Model <b>checking,</b> however, can cover all possible thread interleavings. Software model checkers can directly verify an implementation, but typically cannot handle network input/output operations, which most programs require. This shortcoming {{can be addressed}} by a special model checker designed for multiple processes, or by different kinds of extensions and preprocessors for existing model checkers. This paper surveys currently existing approaches and tools...|$|R
40|$|The current {{trend toward}} chip {{multiprocessor}} architectures has placed great pressure on programmers and compilers to generate thread-parallel programs. Improved exe-cution performance {{can no longer}} be obtained via traditional single-thread instruction level parallelism (ILP), but, instead, via multithreaded execution. One notable tech-nique that facilitates the extraction of parallel threads from sequential applications is thread-level speculation (TLS). This technique allows programmers/compilers to gen-erate <b>threads</b> without <b>checking</b> for inter-thread data and control dependences, which are then transparently enforced by the hardware. Most prior work on TLS has concen-trated on thread selection and mechanisms to efficiently support the main TLS opera-tions, such as squashes, data versioning, and commits. This thesis seeks to enhance TLS functionality by combining it with other spec-ulative multithreaded execution models. The main idea is that TLS already requires extensive hardware support, which when slightly augmented can accommodate other speculative multithreaded techniques. Recognizing that for different applications, o...|$|R
40|$|Ensuring the {{reliability}} of multithreaded software systems is difficult due to the potential for subtle interactions between <b>threads.</b> Unfortunately, <b>checking</b> tools for such systems do not scale to programs {{with a large number}} of threads and procedures. To improve this shortcoming, we present a verification technique that uses concise specifications to analyze large multithreaded programs modularly. We achieve thread-modular analysis by annotating each shared variable by an access predicate that summarizes the condition under which a thread may access that variable. We achieve procedure-modular analysis by annotating each procedure by its specification, which is related to its implementation by an abstraction relation that combines the notions of simulation and reduction. We have implemented our analysis in Calvin-R, a static checker for multithreaded Java programs. To validate our methodology, we have used Calvin-R to check a number of important properties for a file system. Our experience shows that requirements for complex multithreaded systems can be stated concisely and verified in our framework...|$|R
40|$|Abstract. The {{problem of}} model <b>checking</b> <b>threads</b> {{interacting}} purely via the standard synchronization primitives is key for many concurrent program analyses, particularly dataflow analysis. Unfortunately, it is undecidable {{even for the}} most commonly used synchronization primitive, i. e., mutex locks. Lock usage in concurrent programs can be characterized in terms of lock chains, where a sequence of mutex locks is said to be chained if the scopes of adjacent (non-nested) mutexes overlap. Although the model checking problem for fragments of Linear Temporal Logic (LTL) is known to be decidable for threads interacting via nested locks, i. e., chains of length one, these techniques don’t extend to programs with non-nested locks used in crucial applications like databases. We exploit the fact that lock usage patterns in real life programs do not produce unbounded lock chains. For such a framework, we show, by using the new concept of Lock Causality Automata (LCA), that pre ∗-closures of regular sets of states can be computed efficiently. Leveraging this new technique then allows us to formulate decision procedures for model <b>checking</b> <b>threads</b> communicating via bounded lock chains for fragments of LTL. Our new results narrow the decidability gap for LTL model <b>checking</b> of <b>threads</b> communicating via locks by providing a more refined characterization for it in terms of boundedness of lock chains rather than the current state-of-the-art, i. e., nestedness of locks (chains of length one). ...|$|R
30|$|Generally {{high-pressure}} steam {{is known to}} be cheaper to produce than compressed air. This factor is critical when it is considered that the largest obstacle {{to the development of a}} successful performance air-jet textured yarn has been the energy cost involved in generating compressed air. Although the reduced cost of a pressurised fluid was of great interest on its own, high pressure steam has extra useful properties such as the in-built high energy content which could theoretically be used to thermally set the thread, thus obviating the need for separate electric heaters to achieve stabilisation. This could reduce further the energy requirement of the process and simplify the production machine design thus driving down cost further. The aim of this paper is to analyze and compare the properties of steam-jet textured yarns with air-jet textured yarns made under similar process conditions with varying effect-yarn draw ratio and overfeed. Furthermore, sewing threads were manufactured using both air-jet and steam-jet textured yarns and tested for sewability of the <b>threads</b> to <b>check</b> the feasibility of this yarns for sewing thread applications.|$|R
40|$|Abstract. Ensuring the {{reliability}} of multithreaded software systems is difficult due to the potential for subtle interactions between <b>threads.</b> Unfortunately, <b>checking</b> tools for such systems do not scale to programs {{with a large number}} of threads and procedures. To improve this shortcoming, we present a verification technique that uses concise specifications to analyze large multithreaded programs modularly. We achieve thread-modular analysis by annotating each shared variable by an access predicate that summarizes the condition under which a thread may access that variable. We achieve procedure-modular analysis by annotating each procedure by its specification, which is related to its implementation by an abstraction relation that combines the notions of simulation and reduction. We have implemented our analysis in Calvin-R, a static checker for multithreaded Java programs. To validate our methodology, we have used Calvin-R to check a number of important properties for a file system. Our experience shows that requirements for complex multithreaded systems can be stated concisely and verified in our framework. Presented at the Workshop on Formal Techniques for Java-like Programs, 2003...|$|R
40|$|Thus {{far we have}} {{developed}} {{the notion of a}} lock and seen how one can be properly built with the right combination of hardware and OS support. Unfortunately, locks are not the only primitives that are needed to build concurrent programs. In particular, there are many cases where a <b>thread</b> wishes to <b>check</b> whether a condition is true before continuing its execution. For example, a parent thread might wish to check whether a child thread has completed before continuing (this is often called a join()); how should such a wait be implemented? Let’s look at Figure 29. 1. 1 void * 2 child(void *arg) 3 printf("child"); 4 / / XXX how to indicate we are done? 5 return NULL...|$|R
5000|$|Snap gauges {{are often}} used when a large {{quantity}} of work pieces must be inspected. The snap gauge has four anvils or jaws, the first one or pair (outermost) are set using the upper limit (tolerance) of the part and the inner set adjusted to the lower limit of the part. A correctly machined part will pass {{the first set of}} jaws and stop at the second [...] - [...] end of test. In this manner, a part may be checked in one action, unlike the plug gauge that needs to be used twice and flipped to access the second gauge. The first go/no-go snap gage for <b>checking</b> <b>thread</b> rolls was invented in 1943 to speed production of parts during WWII.|$|R
40|$|Abstract. Concurrent {{programs}} {{are notorious for}} containing errors {{that are difficult to}} reproduce and diagnose. A common kind of concurrency error is deadlock, which occurs when a set of threads is blocked each trying to acquire a lock held by another thread in that set. Static and dynamic (run-time) analysis techniques exist to detect deadlocks. Havelund’s GoodLock algorithm detects potential deadlocks at runtime. However, it detects only potential deadlocks involving exactly two threads. This paper presents a generalized version of the GoodLock algorithm that detects potential deadlocks involving any number of <b>threads.</b> Run-time <b>checking</b> may miss errors in unexecuted code. On the positive side, run-time checking generally produces fewer false alarms than static analysis. This paper explores the use of static analysis to automatically reduce the overhead of run-time checking. We extend our type system, Extended Parameterized Atomic Java (EPAJ), which ensures absence of races and atomicity violations, with Boyapati et al. ’s deadlock types. We give an algorithm that infers deadlock types for a given program and an algorithm that determines, based on the result of type inference, which run-time checks can safely be omitted. The new type system, called Deadlock-Free EPAJ (DEPAJ), has the added benefit of giving stronger atomicity guarantees than previous atomicity type systems. ...|$|R
40|$|Cycles {{count in}} a graph is an NP-complete problem. This work {{minimizes}} the execution time {{to solve the}} problem compared to the other traditional serial, CPU based one. It reduces the hardware resources needed to a single commodity GPU. We developed an algorithm to approximate counting the number of cycles in an undirected graph, by utilizing a modern parallel computing paradigm called CUDA (Compute Unified Device Architecture) from nVIDIA, using the capabilities of the massively parallel multi-threaded specialized processor called Graphics Processing Unit (GPU). The algorithm views the graph from combinatorial perspective rather than the traditional adjacency matrix/list view. The design philosophy of the algorithm shows that each thread will perform simple computation procedures in finite loop iterations to be executed in polynomial time. The algorithm is divided into two stages, the first stage is to extract a unique number of vertices combinations for a given cycle length using combinatorial formulas, and then examine whether given combination can for a cycle or not. The second stage is to approximate the number of exchanges (swaps) between vertices for each <b>thread</b> to <b>check</b> the possibility of cycle existence. An experiment was conducted to compare the results between the proposed algorithm and another distributed serial based algorithm based on the Donald Johnson backtracking algorithm...|$|R
40|$|The current trend towardmulticore {{architectures}} {{has placed}} great pressure on programmers and compilers to generate thread-parallel programs. Improved execution performance {{can no longer}} be obtained via traditional single-thread instruction level parallelism (ILP), but, instead, via multithreaded execution. One notable technique that facilitates the extraction of parallel threads from sequential applications is thread-level speculation (TLS). This technique allows programmers/compilers to generate <b>threads</b> without <b>checking</b> for inter-thread data and control dependences, which are then transparently enforced by the hardware. Most prior work on TLS has concentrated on thread selection and mechanisms to efficiently support the main TLS operations, such as squashes, data versioning, and commits. This article seeks to enhance TLS functionality by combining it with other speculative multithreaded execution models. The main idea is that TLS already requires extensive hardware support, which when slightly augmented can accommodate other speculative multithreaded techniques. Recognizing that for different applications, or even program phases, the application bottlenecks may be different, {{it is reasonable to assume}} that themore versatile a system is, themore efficiently it will be able to execute the given program. Toward this direction, we first show that mixed execution models that combine TLS with Helper Threads (HT), RunAhead execution (RA) and MultiPath execution (MP) perform better than any of the models alone...|$|R
5000|$|TLS {{is used in}} {{some places}} where ordinary, {{single-threaded}} programs would use global variables, but where this would be inappropriate in multithreaded cases. An example of such situations is where functions use a global variable to set an error condition (for example the global variable [...] used by many functions of the C library). If [...] were a global variable, a call of a system function on one thread may overwrite the value previously set by a call of a system function on a different thread, possibly before following code on that different <b>thread</b> could <b>check</b> for the error condition. The solution is to have [...] be a variable {{that looks like it}} is global, but in fact exists once per thread—i.e., it lives in thread-local storage. A second use case would be multiple threads accumulating information into a global variable. To avoid a race condition, every access to this global variable would have to be protected by a mutex. Alternatively, each thread might accumulate into a thread-local variable (that, by definition, cannot be read from or written to from other threads, implying {{that there can be no}} race conditions). Threads then only have to synchronise a final accumulation from their own thread-local variable into a single, truly global variable.|$|R
40|$|Given its pervasiveness, it {{is unfortunate}} that writing multi-threaded {{software}} is an in-tricate and tedious task due to a multitude of <b>thread</b> interactions. Model <b>checking</b> ap-proaches that are based on formal specifications can significantly improve programmers productivity by allowing systematically and exhaustively exploring program behaviours and checking their correctness. However, efficient model checking is inhibited by the so-called state explosion problem. In this thesis, we propose two promising approaches to cope with this problem by reducing the number of program states that have to be explored- transaction summarization and may-happen-in-parallel information. We show that es-pecially a priori identified transactions can significantly improve the efficiency of compo-sitional verification. Our experimental evaluation indicate that the approaches compare favourably with state-of-the-art verifiers and can lead to two orders of magnitude reduc-tion of verification time...|$|R
40|$|This paper {{presents}} a new concurrent multiplethreaded architectural model, called superthreading, for exploiting thread-level parallelism on a processor. This architectural model adopts a thread pipelining execution model that allows threads with data dependences and control dependences {{to be executed}} in parallel. The basic idea of thread pipelining is to compute and forward recurrence data and possible dependent store addresses to the next thread as soon as possible, so the next thread can start execution and perform runtime data dependence <b>checking.</b> <b>Thread</b> pipelining also forces contiguous threads to perform their memory write-backs in order, which enables the compiler to fork threads with control speculation. With run-time support for data dependence checking and control speculation, the superthreaded architectural model can exploit loop-level parallelism from {{a broad range of}} applications. 1 Introduction As the rapid progress of VLSI technology allows microprocessors to have more [...] ...|$|R
40|$|Many {{parallel}} {{programs are}} written in a single-program, multiple-data (SPMD) style, in which synchronization is provided using collective operations that all threads execute simultaneously. If these operations are not properly aligned on all threads, deadlock can occur, and many compiler analyses and optimizations that depend on proper alignment fail. In this paper, we discuss the flaws in the Titanium language's type system for enforcing textual alignment of collectives. We then present a system that uses runtime checks to ensure alignment for two definitions of textual alignment. The system instruments the code {{to keep track of}} alignment in each <b>thread</b> and then <b>checks</b> that alignment matches prior to performing a collective operation. We have implemented the system in the Titanium compiler, verifying that it catches alignment errors. We tested its performance on multiple application programs, demonstrating that the checks have no appreciable impact on execution time. © 2010 Springer-Verlag...|$|R
40|$|This thesis {{reports on}} the {{implementation}} of a runtime verification system for object lifetime specifications. This system is used to explore and evaluate the expressiveness object lifetime specifications. Object lifetime specifications are program annotations that indicate, in terms of program execution, when objects should be reclaimed. Object lifetime specifications are designed to be used within the context of an object-oriented programming language with automatic storage reclamation (i. e., garbage collection). Our runtime verification system observes program execution and reports objects that are not re-claimed before the end of their specified lifetime. We implement our system with the Java Path Finder model-checking framework. JPF supports modeling non-determinism in programs. We leverage this support to verify all possible <b>thread</b> interleavings when <b>checking</b> user programs. by Zev Benjamin. Thesis (M. Eng.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2009. Includes bibliographical references (leaves 48 - 49) ...|$|R
40|$|Abstract. While {{symmetry}} reduction {{has been}} established {{to be an important}} technique for reducing the search space in model checking, its application in concurrent software verification is still limited, due to the difficulty of specifying symmetry in realistic software. We propose an algorithm for automatically discovering and applying transition symmetry in multithreaded programs during dynamic model checking. Our main idea is using dynamic program analysis to identify a permutation of variables and labels of the program that entails syntactic equivalence among the residual code of <b>threads</b> and to <b>check</b> whether the local states of threads are equivalent under the permutation. The new transition symmetry discovery algorithm can bring substantial state space savings during dynamic verification of concurrent programs. We have implemented the new algorithm in the dynamic model checker Inspect. Our preliminary experiments show that this algorithm can successfully discover transition symmetries that are hard or otherwise cumbersome to identify manually, and can significantly reduce the model checking time while using Inspect to examine realistic multithreaded applications. ...|$|R
40|$|In {{a precise}} data race detector, a race is {{detected}} {{only if the}} execution exhibits a real race. In such tools, every memory access from each <b>thread</b> is typically <b>checked</b> by a happens-before algorithm. Whats the optimal runtime performance of such tools? In this paper, we identify that {{a significant percentage of}} memory access checks in real-world program executions are often redundant: removing these checks affects neither the precision nor the capability of race detection. We show that if all such redundant checks were eliminated with no cost, the optimal performance of a state-of-the-art dynamic race detector, FastTrack, could be improved by 90 %, reducing its runtime overhead from 68 X to 7 X on a collection of CPU intensive benchmarks. We further develop a purely dynamic technique, ReX, that efficiently filters out redundant checks and apply it to FastTrack. With ReX, the runtime performance of FastTrack is improved by 31 % on average...|$|R
40|$|Assertions are a {{powerful}} bug detection technique. Traditional assertion checking, however, is performed synchronously, imposing its full cost on the runtime of the program. As a result, many useful kinds of checks are impractical because they lead to extreme slowdowns. We present {{a solution that}} decouples assertion evaluation from program execution: assertions are evaluated asynchronously while the program continues to execute. Our technique ensures that the assertion <b>checking</b> <b>thread</b> operates on a consistent view of the global state, and that an assertion always produces the same result as it would in a serial execution. We implemented our technique in a system called STROBE, a snapshot-based system for asynchronous assertion checking in both single-and multi-threaded Java applications. STROBE runs inside the Java virtual machine and uses copy-on-write to build snapshots incrementally. We find that asynchronous checking scales almost perfectly over synchronous checking in many cases, indicating that the snapshot overhead is quite low. STROBE provides tolerable overheads (under 2 X) even for heavy-weight assertions that would otherwise result in crushing slowdowns. 1...|$|R
40|$|Implementing ozone {{depleting}} chemicals (ODC) -free solvents into full-scale reusable {{solid rocket}} motor cleaning operations has presented problems {{due to the}} low vapor pressures of the solvents. Because of slow evaporation, solvent retention is a problem on porous substrates or on surfaces with irregular geometry, such as <b>threaded</b> boltholes, leak <b>check</b> ports, and nozzle backfill joints. The new solvents are being evaluated to replace 1, 1, 1 -trichloroethane, which readily evaporates from these surfaces. Selection of the solvents to be evaluated on full-scale hardware was made based on results of subscale tests performed with flat surface coupons, which did not manifest the problem. Test efforts have been undertaken to address concerns with the slow-evaporating solvents. These concerns include effects on materials due to long-term exposure to solvent, potential migration from bolthole threads to seal surfaces, and effects on bolt loading due to solvent retention in threads. Tests performed to date have verified that retained solvent does not affect materials or hardware performance. Process modifications have also been developed to assist drying, and these can be implemented if additional drying becomes necessary...|$|R
