35|303|Public
25|$|Templates in C++ {{provide a}} {{sophisticated}} mechanism for writing generic, polymorphic code (i.e. parametric polymorphism). In particular, through the curiously recurring template pattern, it's possible {{to implement a}} form of static polymorphism that closely mimics the syntax for overriding virtual functions. Because C++ templates are type-aware and Turing-complete, {{they can also be}} used to let the compiler resolve recursive conditionals and generate substantial programs through template metaprogramming. Contrary to some opinion, <b>template</b> <b>code</b> will not generate a bulk code after compilation with the proper compiler settings.|$|E
500|$|Many vendors {{provide the}} typeof {{operator}} as a compiler extension. As early as 1997, before C++ was fully standardized, Brian Parker proposed a portable solution {{based on the}} sizeof operator. His work was expanded on by Bill Gibbons, who concluded that the technique had several limitations and was generally less powerful than an actual typeof mechanism. In an October 2000 article of Dr. Dobb's Journal, Andrei Alexandrescu remarked that [...] "having a typeof would make much <b>template</b> <b>code</b> easier to write and understand." [...] He also noted that [...] "typeof and sizeof share the same backend, because sizeof has to compute the type anyway." [...] Andrew Koenig and Barbara E. Moo also recognized the usefulness of a built-in typeof facility, with the caveat that [...] "using it often invites subtle programming errors, {{and there are some}} problems that it cannot solve." [...] They characterized the use of type conventions, like the typedefs provided by the Standard Template Library, as a more powerful and general technique. However, Steve Dewhurst argued that such conventions are [...] "costly to design and promulgate", {{and that it would be}} [...] "much easier to ... simply extract the type of the expression." [...] In a 2011 article on C++0x, Koenig and Moo predicted that [...] "decltype will be widely used to make everyday programs easier to write." ...|$|E
50|$|If the {{templates}} {{are used}} to generate code then programmers are able to inject their own code into the generated code to alter, or extend, the functionality offered by the template layer. This process of embedding code can be done while viewing the surrounding generated code. This mixing of <b>template</b> <b>code</b> and generated code allows the template settings to be updated, and the code regenerated, without {{the loss of the}} embedded code.|$|E
25|$|Templates - Templates: These include leaked {{commercial}} website <b>templates</b> <b>coded</b> by companies.|$|R
5000|$|Eclipse-based IDE with editing, <b>code</b> <b>templates,</b> <b>code</b> completion, refactoring, browsing, searching, etc.|$|R
5000|$|Templates - Templates: These include leaked {{commercial}} website <b>templates</b> <b>coded</b> by companies.|$|R
5000|$|... vBulletin 4 was {{released}} 21 December 2009. New for vBulletin 4 is the vBulletin publishing suite, which includes CMS and blog functions. Other updates to the software included a cross-content search system, improved search engine optimization and a centralized attachment system {{which allows the}} sharing of attachments across products. Additionally, the template and styling engine was changed for vBulletin. The StyleVars system was added to draw CSS variables directly from the vBulletin <b>Template</b> <b>code.</b>|$|E
50|$|Templates in C++ {{provide a}} {{sophisticated}} mechanism for writing generic, polymorphic code (i.e. parametric polymorphism). In particular, through the Curiously Recurring Template Pattern, it's possible {{to implement a}} form of static polymorphism that closely mimics the syntax for overriding virtual functions. Because C++ templates are type-aware and Turing-complete, {{they can also be}} used to let the compiler resolve recursive conditionals and generate substantial programs through template metaprogramming. Contrary to some opinion, <b>template</b> <b>code</b> will not generate a bulk code after compilation with the proper compiler settings.|$|E
50|$|Though it is {{possible}} and sometimes necessary, due to licensing restrictions of existing parsers or if the list of tokens is small, to write a lexer by hand, lexers are often generated by automated tools. These tools generally accept regular expressions that describe the tokens allowed in the input stream. Each regular expression {{is associated with a}} production rule in the lexical grammar of the programming language that evaluates the lexemes matching the regular expression. These tools may generate source code that can be compiled and executed or construct a state transition table for a finite-state machine (which is plugged into <b>template</b> <b>code</b> for compiling and executing).|$|E
5000|$|The Quality of Implementation (QoI) of the C++ {{compiler}} {{has a large}} {{impact on}} usability of STL (and <b>templated</b> <b>code</b> in general): ...|$|R
5000|$|Coding {{assistance}} with code completion, code generation options, live <b>templates,</b> <b>code</b> formatting, multiple carets and selections, automatic insert of imports and imports optimization.|$|R
5000|$|Escape abstractions and <b>templated</b> <b>code.</b> Hand coding allows {{more refined}} control of code, which may improve efficiency, or add {{functionality}} that is otherwise unavailable.|$|R
50|$|Unlike {{function}} templates, class templates can {{be partially}} specialized. That means that an alternate {{version of the}} class <b>template</b> <b>code</b> can be provided {{when some of the}} template parameters are known, while leaving other template parameters generic. This can be used, for example, to create a default implementation (the primary specialization) that assumes that copying a parameterizing type is expensive and then create partial specializations for types that are cheap to copy, thus increasing overall efficiency. Clients of such a class template just use specializations of it without needing to know whether the compiler used the primary specialization or some partial specialization in each case. Class templates can also be fully specialized, which means that an alternate implementation can be provided when all of the parameterizing types are known.|$|E
5000|$|Many vendors {{provide the}} [...] {{operator}} as a compiler extension. As early as 1997, before C++ was fully standardized, Brian Parker proposed a portable solution {{based on the}} [...] operator. His work was expanded on by Bill Gibbons, who concluded that the technique had several limitations and was generally less powerful than an actual [...] mechanism. In an October 2000 article of Dr. Dobb's Journal, Andrei Alexandrescu remarked that [...] "having a typeof would make much <b>template</b> <b>code</b> easier to write and understand." [...] He also noted that [...] "typeof and sizeof share the same backend, because sizeof has to compute the type anyway." [...] Andrew Koenig and Barbara E. Moo also recognized the usefulness of a built-in [...] facility, with the caveat that [...] "using it often invites subtle programming errors, {{and there are some}} problems that it cannot solve." [...] They characterized the use of type conventions, like the typedefs provided by the Standard Template Library, as a more powerful and general technique. However, Steve Dewhurst argued that such conventions are [...] "costly to design and promulgate", {{and that it would be}} [...] "much easier to ... simply extract the type of the expression." [...] In a 2011 article on C++0x, Koenig and Moo predicted that [...] "decltype will be widely used to make everyday programs easier to write." ...|$|E
40|$|Following the "convention over configuration" paradigm, model-driven {{development}} (MDD) generates code {{to implement}} the "default" behaviour that has been specified by a template separate from the input model, reducing the decision effort of developers. For flexibility, users of MDD are allowed to customise the model and the generated code in parallel. A synchronisation of changed model or code is maintained by reflecting them {{on the other end}} of the code generation, as long as the traceability is unchanged. However, such invariant traceability between corresponding model and code elements can be violated either when (a) users of MDD protect custom changes from the generated code, or when (b) developers of MDD change the template for generating the default behaviour. A mismatch between user and <b>template</b> <b>code</b> is inevitable as they evolve for their own purposes. In this paper, we propose a two-layered invariant traceability framework that reduces the number of mismatches through bidirectional transformations. On top of existing vertical (model↔code) synchronisations between a model and the <b>template</b> <b>code,</b> a horizontal (code↔code) synchronisation between user and <b>template</b> <b>code</b> is supported, aligning the changes in both directions. Our blinkit tool is evaluated using the data set available from the CVS repositories of a MDD project: Eclipse MDT/GMF...|$|E
50|$|Clarion generates its code {{by means}} of <b>templates.</b> <b>Code</b> {{generated}} by <b>templates</b> tends to be very reliable especially if the template has been in use for some time.|$|R
30|$|Second, {{three factors}} are {{considered}} necessary to successfully comply with web accessibility—a {{content management system}} (CMS) that supports web accessibility and web standard; a technological <b>template</b> <b>coding</b> that properly supports the global web standard; data that is entered after properly understanding the concept of web accessibility. web standard content management system is a core engine of a home page. On the other hand, <b>template</b> <b>coding</b> {{is similar to a}} mold. Thus, web accessibility, mobile home page, search and PR optimization, coding optimization, etc., should also be considered in entering the contents.|$|R
50|$|PascalABC.NET is also {{a simple}} and {{powerful}} IDE with integrated debugger, IntelliSense system, form designer, <b>code</b> <b>templates</b> and <b>code</b> auto-formatting. Command-line PascalABC.NET compiler {{is also a}}vailable on Linux and MacOS (under Mono).|$|R
40|$|Generic {{programming}} {{using the}} C++ template facility {{has been a}} successful method for creating high-performance, yet general algorithms for scientific computing and visualization. However, adding <b>template</b> <b>code</b> tends to require more <b>template</b> <b>code</b> in surrounding structures and algorithms to maintain generality. Compiling all possible expansions of these templates can lead to massive template bloat. Furthermore, compile-time binding of templates requires that all possible permutations be known at compile time, limiting the runtime extensibility of the generic code. We present a method for deferring the compilation of these templates until an exact type is needed. This dynamic compilation mechanism will produce the minimum amount of compiled code needed for a particular application, while maintaining the generality and performance that templates innately provide. Through {{a small amount of}} supporting code within each templated class, the proper templated code can be generated at runtime without modifying the compiler. We describe the implementation of this goal within the SCIRun dataflow system. SCIRun is freely available online for research purposes...|$|E
30|$|The Cleanup method uses a {{template}} data structure, CV 4 L 2 SourceImpl (see Listing Listing 9 CV 4 L 2 SourceImpl <b>template</b> <b>code</b> structure), which defines three specialized templates, {{one for each}} capture mode. Based on the selected capture mode, one of these templates is instantiated with an inline Cleanup function whose body is statically patched into the place where Cleanup {{is supposed to be}} called.|$|E
40|$|This paper {{describes}} how the computer algebra system, Mathematica, {{can be used to}} introduce students to the finite element method. Typical students are juniors, seniors, and beginning graduate students in mathematics, computer science, and various engineering disciplines. Students were given <b>template</b> <b>code.</b> They were instructed to modify the code in order to solve two-dimensional elliptic boundary-value problems and to verify the correctness of their numerical solution...|$|E
40|$|Application programing {{interfaces}} promote reuse by facilitating {{interaction between}} software components and/or software libraries. API <b>code</b> <b>templates</b> are parameterized API scenarios {{that can be}} quickly instantiated by copy-and-pasting or through support from integrated development environments. They provide the skeletal structure of an API coding scenario and let developers simply “fill in the blanks ” with {{the details of their}} coding task. Unfortunately, creating relevant API <b>code</b> <b>templates</b> requires time and experience with the API. To address these problems we present a technique that mines API usage patterns and transforms them into API <b>code</b> <b>templates.</b> Our intuition is that API usage patterns are a solid basis for <b>code</b> <b>templates</b> because they are grounded by actual API usage. We evaluate our approach performing retroactive study on the Mammoth, ArgoUML, and Eclipse projects to see if API <b>code</b> <b>templates</b> created from earlier versions could have been helpful to developers in later versions. Our results show that, on average, each API <b>code</b> <b>template</b> our technique mined could have helped developers with creating six, nine, and twelve new methods in Mammoth, ArgoUML, and Eclipse, respectively. In our evaluation, we mined many API <b>code</b> <b>templates</b> from the three test projects that provide evidence that ou...|$|R
40|$|Modern {{software}} development teams are distributed across onsite and off-shore locations. Each team has developers with varying experience levels and English communication skills. In such a diverse development environment {{it is important}} to maintain the software quality, coding standards, timely delivery of features and bug fixes. It is also important to reduce testing effort, minimize side effects such as change in functionality, user experience or application performance. Code reviews are intended to control code quality. Unfortunately, many projects lack enforcement of processes and standards because of approaching deadlines, live production issues and lack of resource availability. This study examines a novel structured, unit testable <b>templated</b> <b>code</b> method to enforce code review standards with an intent to reduce coding effort, minimize revisions and eliminate functional and performance side effects on the system. The proposed method would also result in unit-testable code that can also be easily rolled back and increase team productivity. The baseline for traditional code review processes using metrics such as code review duration, bug regression rate, revision count was measured. These metrics were then compared with results from the proposed code review process that used structured unit testable <b>templated</b> <b>code.</b> The performance on 2 large enterprise level applications spanning over 2 years and 9 feature and maintenance release cycles was evaluated. The structured unit testable <b>templated</b> <b>code</b> method resulted in a decrease in total code review time, revision count and coding effort. It also decreased the number of live production issues caused by code churn or side effects of bug fix when compared to traditional code review process. Comment: 13 pages, 12 figure...|$|R
5000|$|It {{has been}} {{proposed}} (as of 2016) for addition to C++ by Bjarne Stroustrup and Herb Sutter, to reduce the ambiguous decision between writing free functions and member functions, to simplify the writing of <b>templated</b> <b>code.</b> Many programmers are tempted to write member-functions to get {{the benefits of the}} member-function syntax - e.g. [...] "dot-autocomplete" [...] to list member functions, however this leads to excessive coupling between classes.|$|R
40|$|Description Boost {{provides}} free peer-reviewed portable C++ source libraries. A {{large part}} of Boost is provided as C++ <b>template</b> <b>code</b> which is resolved entirely at compile-time without linking. This package aims to provide the most useful subset of Boost libraries for template use among CRAN package. By placing these libraries in this package, we offer a more efficient distribution system for CRAN as replication of this code in the sources of other packages is avoided...|$|E
40|$|VMSCRIPT is a {{scripting}} language {{designed to allow}} small programs to be compiled {{for a range of}} generated tiny virtual machines, suitable for sensor network devices. The VMSCRIPT compiler is an optimising compiler designed to allow quick re-targeting, based on a <b>template,</b> <b>code</b> rewrit-ing model. A compiler backend can be specified {{at the same time as}} a virtual machine, with the compiler reading the specification and using it as a code generator. 1...|$|E
40|$|This note {{explains}} how MPI {{may be used}} with the Julia programming language. An example of a simple Monte Carlo study is presented, with code. The code is intended {{to serve as a}} general purpose template for more relevant applications. A second example shows how the <b>template</b> <b>code</b> may be adapted to perform a Monte Carlo study of the properties of an approximate Bayesian computing estimator of actual research interest. All of the code is available at [URL]...|$|E
50|$|The {{operations}} performed at compile time usually include syntax analysis, {{various kinds of}} semantic analysis (e.g., type checks and instantiation of <b>template)</b> and <b>code</b> generation.|$|R
5000|$|Feature {{templates}} - implementing features <b>templates</b> {{instead of}} <b>coding</b> new features ...|$|R
5000|$|The toolkit is {{implemented}} using generic programming principles. Such heavily <b>templated</b> C++ <b>code</b> challenges many compilers; hence development {{was carried out}} with the latest versions of the MSVC, Sun, gcc, Intel, and SGI compilers.|$|R
40|$|We {{developed}} a parallel, numerically accurate and stable, and computationally efficient finate-difference incompressible Navier-Stokes (N-S) fluid flow solver. The solver runs on both sequential and massively parallel computers. The numerical method used {{here is a}} second-order projection method on a staggered grid. The code is highly modular {{and it can be}} used either as a stand-alone flow solver and or a <b>template</b> <b>code</b> which can be adapted or expanded to a specific application. Numerical results and parallel performances of our code on Intel Delta and Paragon are reported...|$|E
30|$|Type- 2 cloned {{methods are}} {{syntactically}} identical code fragments except for variations in identifiers, literals, types, white space, layout and comments. Hence the textual comparison is {{performed on the}} <b>template</b> <b>code</b> created by the tool. The methods with the same computed metric values and same patterns for template comparison are short listed as clone pairs. The comparison in the template identifies type- 1 cloned method along, with type- 2 cloned methods. So {{they need to be}} removed separately. Further, for this reason textual comparison with original source code is compared to identify the differences in the parameters.|$|E
30|$|Now let’s {{take the}} input filter V 4 L 2 as {{represented}} by the feature diagram in Figure 8 to partially describe the artifact template of such kind of filters. Due to huge extension of the code we’ll focus on the filter Cleanup method needed to free all allocated resource by the filter. Three created structures, one for each capture method and a skeleton artifact template for CV 4 L 2 Source along with the Cleanup method are created as shown by Listings Listing 7 Data type definition for the capture mode and Listing 8 CV 4 L 2 class skeleton artifact <b>template</b> <b>code,</b> respectively.|$|E
5000|$|Cheetah — an {{open source}} <b>template</b> engine and <b>code</b> {{generation}} tool, written in Python.|$|R
3000|$|Intervention {{to support}} the {{development}} of <b>template</b> quality <b>codes</b> is appropriate {{to support the}} balancing of customer and supplier in sectors {{where there is a}} significant distortion or imbalance, e.g. provision of infrastructure or oligopolistic sectors such as railfreight; [...]...|$|R
40|$|ProGUM-Web is a {{tool that}} {{supports}} model-based development of Web applications using an extension of UML. It accounts for the characteristics of Web applications and their specific development. <b>Code</b> <b>templates</b> are generated from the model for both graphic designers and software developers. These <b>code</b> <b>templates</b> can iteratively and independently be advanced and are reintegrated within ProGUM-Web. Prototypes of Web applications can automatically be generated throughout the development...|$|R
