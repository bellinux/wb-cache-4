26|10000|Public
50|$|XPath is used {{primarily}} for selecting parts of an XML document. For this purpose the XML document is modelled as a <b>tree</b> <b>of</b> <b>nodes.</b> XPath allows nodes {{to be selected}} {{by means of a}} hierarchic navigation path through the document tree.|$|E
5000|$|The {{following}} {{example is}} in the language Java, and shows how {{the contents of a}} <b>tree</b> <b>of</b> <b>nodes</b> (in this case describing the components of a car) can be printed. Instead of creating [...] methods for each node subclass ( [...] , , , and [...] ), one visitor class (...) performs the required printing action. Because different node subclasses require slightly different actions to print properly, [...] dispatches actions based on the class of the argument passed to its [...] method. , which is analogous to a save operation for a different file format, does likewise.|$|E
5000|$|A {{computation}} tree is {{a representation}} for the computation {{steps of a}} non-deterministic Turing machine on a specified input. A computation tree is a rooted <b>tree</b> <b>of</b> <b>nodes</b> and edges. Each node in the tree represents a single computational state, while each edge represents a transition to the next possible computation. The number of nodes of the tree {{is the size of}} the tree and the length of the path from the root to a given node is the depth of the node. The largest depth of an output node is the depth of the tree. The output nodes of the tree are called leaves.|$|E
40|$|Method of and {{device for}} {{querying}} of protected data structured {{in the form}} <b>of</b> a <b>tree.</b> A corresponding <b>tree</b> <b>of</b> <b>node</b> polynomials is constructed such that each node polynomial evaluates to zero for an input equal to an identifier assigned to a node name occurring in a branch <b>of</b> the data <b>tree</b> starting with the node in question. A <b>tree</b> <b>of</b> blinding polynomials and a <b>tree</b> <b>of</b> difference polynomials are constructed such that each polynomial in the <b>tree</b> <b>of</b> <b>node</b> polynomials equals {{the sum of the}} corresponding polynomial in the <b>tree</b> <b>of</b> blinding polynomials and the corresponding polynomial in the <b>tree</b> <b>of</b> difference polynomials. The blinding tree is given to a client, the difference tree to a server. By combining the outcomes of the evaluations of the client and the server, it is possible to identify nodes that match a given query...|$|R
2500|$|The number <b>of</b> {{internal}} <b>nodes</b> in {{a complete}} binary <b>tree</b> <b>of</b> n <b>nodes</b> is [...]|$|R
5000|$|The number <b>of</b> {{different}} Cartesian <b>trees</b> <b>of</b> [...] <b>nodes</b> is , the 'th Catalan number ...|$|R
5000|$|Leo's outline or {{hierarchical}} structure {{is distinct from}} the web of interleaved program and documentation [...] "chunks" [...] associated with classic literate programming tools. The body text of any Leo node may contain a Leo script, a Python script executed {{in the context of}} a Leo outline. A simple API gives Leo scripts full access to all data in loaded outlines, as well as full access to Leo's own source code. The API includes Python iterators that allow scripts to traverse outlines easily. Scripts may be composed of any <b>tree</b> <b>of</b> <b>nodes.</b> A markup language similar to noweb tells Leo how to create scripts from (parts of) an outline. Headlines control and guide scripts. Examples are: ...|$|E
50|$|The {{data in a}} JCR {{consists}} of a <b>tree</b> <b>of</b> <b>nodes</b> with associated properties. Data is stored in the properties, which may hold simple values such as numbers and strings or binary data of arbitrary length. Nodes may optionally have one or more types associated with them which dictate the kinds of properties, number and type of child nodes, and certain behavioral characteristics of the nodes. Nodes may point to other nodes via a special reference type property. In this way nodes in a JCR offer both referential integrity and object-oriented concept of inheritance. Additional node types include the referenceable node type which allows the user to reference said node through use of a universally unique identifier. Another popular type is the versionable type. This makes the repository track a document's history and store copies of each version of the document.|$|E
5000|$|The {{technique}} {{works by}} creating a binary <b>tree</b> <b>of</b> <b>nodes.</b> These {{can be stored in}} a regular array, the size of which depends on the number of symbols, [...] A node can be either a leaf node or an internal node. Initially, all nodes are leaf nodes, which contain the symbol itself, the weight (frequency of appearance) of the symbol and optionally, a link to a parent node which makes it easy to read the code (in reverse) starting from a leaf node. Internal nodes contain a weight, links to two child nodes and an optional link to a parent node. As a common convention, bit '0' represents following the left child and bit '1' represents following the right child. A finished tree has up to [...] leaf nodes and [...] internal nodes. A Huffman tree that omits unused symbols produces the most optimal code lengths.|$|E
2500|$|Using the Standard ML {{data type}} above, the size <b>of</b> a <b>tree</b> (number <b>of</b> <b>nodes)</b> can be {{computed}} via the following mutually recursive functions: ...|$|R
25|$|The maximum {{possible}} {{number of}} null links (i.e., absent children <b>of</b> the <b>nodes)</b> {{in a complete}} binary <b>tree</b> <b>of</b> n <b>nodes</b> is (n+1), where only 1 node exists in bottom-most level to the far left.|$|R
25|$|Document Object Model (DOM) is an API {{that allows}} for {{navigation}} of the entire document {{as if it were}} a <b>tree</b> <b>of</b> <b>node</b> objects representing the document's contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM nodes are abstract; implementations provide their own programming language-specific bindings. DOM implementations tend to be memory intensive, as they generally require the entire document to be loaded into memory and constructed as a <b>tree</b> <b>of</b> objects before access is allowed.|$|R
40|$|A simple {{programmable}} Java platform-independent distributed computation {{system has}} been developed to exploit the free resources on computers linked together by a network. It is a multi-tiered distributed system model, which is unbounded in principal. The system consists of an n-ary <b>tree</b> <b>of</b> <b>nodes</b> where the internal nodes perform the scheduling and the leaves do the processing. The scheduler nodes communicate in a peer-to-peer manner and the processing nodes operate in a strictly client-server manner with their respective scheduler. The independent schedulers on each tier dynamically allocate resources between jobs based on the constantly changing characteristics of the underlying network. The {{system has been}} evaluated over a network of 90 PCs with a bioinformatics application. 1...|$|E
40|$|Complex {{implicit}} CSG {{models can}} be represented heirarchically as a <b>tree</b> <b>of</b> <b>nodes</b> (the BlobTree). However, current methods cannot be used to visualize changes made to these models at interactive rates due to {{the large number of}} potential field evaluations required. A heirarchical spatial caching technique is presented which accelerates evaluations of the potential function. This method introduces the concept of a caching node inserted into the implicit model tree. Caching nodes store exact potential field values at the vertices of a voxel grid and rely on tri-linear and tri-quadratic reconstruction filters to locally approximate the potential field of a sub-tree. A lazy evaluation scheme is used to avoid expensive pre-computation [...] ...|$|E
40|$|Determining {{the optimal}} {{location}} of a switching center in a tree network of users is accurately modeled by the median problem. A real-time approach is used in this paper to investigate the dynamics of such a communication network in two cases: (1) a growing <b>tree</b> <b>of</b> <b>nodes</b> associated with equal demand rates, and (2) a stream of corrections that arbitrarily change the demand rates at the nodes. The worst-case analysis performed in both situations clearly demonstrates the importance of parallelism in such real-time paradigms. It is shown that the error generated by the best sequential algorithm {{in the first case}} can be arbitrarily large. A synergistic behavior is revealed when the quality-up is investigated in the second case. ...|$|E
40|$|Hybrid Approach for {{synchronizing}} time in wireless {{sensor network}} was formulated to overcome the drawbacks of the frequently used approaches for time synchronization namely “sender to receiver” and “receiver to receiver”. A Hybrid approach {{is based on the}} creation <b>of</b> <b>tree</b> structure <b>of</b> <b>nodes</b> before synchronizing nodes in the network. After surveying the traditional approaches we optimize the Hybrid approach to combine the creation <b>of</b> <b>tree</b> structure <b>of</b> <b>nodes</b> along with its synchronization. The optimized approach reduces the message communication and energy consumption <b>of</b> <b>nodes.</b> Simulations <b>of</b> the proposed approach under different scenarios amply demonstrate the improved performance of the same in terms of message transfer and energy consumption, as compared to the other peer approache...|$|R
40|$|In {{this paper}} we {{consider}} the routing number <b>of</b> <b>trees,</b> denotedby rt(), {{with respect to the}} matching routing model. The only known resultis that rt(T) 3 n for an arbitrary <b>tree</b> T <b>of</b> n <b>nodes</b> [2, 3]. By providingoff-line permutation routing algorithms we prove that: i) rt(T) n + o(n) fora complete d-ary <b>tree</b> T <b>of</b> n <b>nodes...</b>|$|R
40|$|In {{this paper}} we {{consider}} the routing number <b>of</b> <b>trees,</b> denoted by rt(), {{with respect to the}} matching routing model. The only known result is that rt(T) ! 3 n for an arbitrary <b>tree</b> T <b>of</b> n <b>nodes</b> [2, 3]. By providing (recursive) off-line permutation routing algorithms we show that: 1. rt(T) n + o(n) for a complete d-ary <b>tree</b> T <b>of</b> n <b>nodes</b> (note that rt(T) n), 2. rt(T) 2 n + o(n) for an arbitrary bounded degree <b>tree</b> T <b>of</b> n <b>nodes,</b> 3. rt(T) 2 n for a maximum degree 3 <b>tree</b> T <b>of</b> n <b>nodes,</b> and 4. rt(T) 2 : 3 n for an arbitrary <b>tree</b> T <b>of</b> n <b>nodes.</b> During the course <b>of</b> our off-line <b>tree</b> routing algorithms we need to have an arbitrary tree heapordered with respect to key values assigned to the packets at its nodes. We analyze an already known heap construction algorithm based on potential functions. It is our belief that potential functions will be the main vehicle in analysing fast non-recursive routing algorithms. Technical Report 494 Basser Dept. of Computer Science University of Sydney Ja [...] ...|$|R
40|$|Abstract—We {{describe}} a natural {{extension of the}} banker’s algorithm for deadlock avoidance in operating systems. Representing the control flow of each process as a rooted <b>tree</b> <b>of</b> <b>nodes</b> corresponding to resource requests and releases, we propose a quadratic-time algorithm which decomposes each flow graph into a nested family of regions, such that all allocated resources are released before the control leaves a region. Also, information on the maximum resource claims for each of the regions can be extracted prior to process execution. By inserting operating system calls when entering a new region for each process at runtime, and applying the original banker’s algorithm for deadlock avoidance, this method has the potential to achieve better resource utilization because information on the “localized approximate maximum claims ” is used for testing system safety. Index Terms—Banker’s algorithm, deadlock, deadlock avoidance, graph reduction, operating system, worst-case complexity. ...|$|E
40|$|A denial-of-service {{bandwidth}} {{attack is}} an attempt to disrupt an online service by generating a traffic over-load that clogs links or causes routers near the victim to crash. We propose a heuristic and a data-structure that network devices (such as routers) can use to detect (and eliminate) such attacks. With our method, each network device maintains a data-structure, MULTOPS, that mon-itors certain traffic characteristics. MULTOPS (MUlti-Level Tree for Online Packet Statistics) is a <b>tree</b> <b>of</b> <b>nodes</b> that contains packet rate statistics for subnet prefixes at different aggregation levels. The tree expands and con-tracts within a fixed memory budget. A network device using MULTOPS detects ongoing bandwidth attacks by the significant, disproportional dif-ference between packet rates going to and coming from the victim or the attacker. MULTOPS-equipped routing software running on an off-the-shelf 700 Mhz Pentium III PC can process up to 340, 000 packets per second. ...|$|E
40|$|International audienceAbstract:Complex {{implicit}} CSG {{models can}} be represented hierarchically as a <b>tree</b> <b>of</b> <b>nodes</b> (the BlobTree). However, current methods cannot be used to visualize changes made to these models at interactive rates due to {{the large number of}} potential field evaluations required. A hierarchical spatial caching technique is presented which accelerates evaluations of the potential function. This method introduces the concept of a caching node inserted into the implicit model tree. Caching nodes store exact potential field values at the vertices of a voxel grid and rely on tri-linear and tri-quadratic reconstruction filters to locally approximate the potential field of a sub-tree. A lazy evaluation scheme is used to avoid expensive pre-computation. Polygonization timings with and without caching are compared for a complex model undergoing manipulation in an interactive modeling tool. An order-of-magnitude improvement in visualization time is achieved for complex implicit models containing thousands of primitives...|$|E
40|$|In {{this paper}} we {{consider}} the routing number <b>of</b> <b>trees,</b> denoted by rt(), {{with respect to the}} matching routing model. The only known result is that rt(T) 3 n for an arbitrary <b>tree</b> T <b>of</b> n <b>nodes</b> [2, 3]. By providing off-line permutation routing algorithms we prove that: i) rt(T) n + o(n) for a complete d-ary <b>tree</b> T <b>of</b> n <b>nodes,</b> ii) rt(T) 2 n + o(n) for an arbitrary bounded degree <b>tree</b> T <b>of</b> n <b>nodes,</b> iii) rt(T) 2 n for a maximum degree 3 <b>tree</b> T <b>of</b> n <b>nodes,</b> iv) rt(T) 13 5 n for an arbitrary <b>tree</b> T <b>of</b> n <b>nodes.</b> 1 Introduction The permutation packet routing problem on a connected undirected graph is the following: We are given a graph G = (V; E) and a permutation ß of the vertices of G. Every vertex v of G contains a packet destined for ß(v). Our task is to route all packets to their destinations. During the routing, the movement of the packets follows a set of rules. These rules specify the routing model. Let rtM (G; ß) be the number of steps required to route permutation ß on graph [...] ...|$|R
500|$|The dual <b>of</b> a <b>tree</b> is {{sometimes}} called a maze [...] It consists of spaces connected by links {{in the same way}} that the <b>tree</b> consists <b>of</b> <b>nodes</b> connected by <b>tree</b> branches.|$|R
5000|$|... phylogeographic studies (requires {{annotation}} <b>of</b> <b>tree</b> <b>nodes</b> with taxonomic {{and geographic}} information) ...|$|R
40|$|There {{have been}} a number of formal models {{proposed}} for XML. Almost all of these models focus on treating XML as semistructured data, typically as edge-labeled graphs, or as a <b>tree</b> <b>of</b> <b>nodes.</b> While this approach is fine for more traditional database applications, or situations where structure is of paramount importance, it fails to deal with the issues found in the use of XML for text. In particular, unless special functions are introduced, queries that involve text spanning node boundaries are not closed over a set of nodes, and likewise, the returned sets of nodes are not necessarily well-formed XML documents. This paper presents an algebra for data that, when applied to XML, is not only closed over the entire set of operations permissible in more traditional XML query languages, but over the operations that involve text and XML fragments that are not in themselves well-formed...|$|E
40|$|A {{programmable}} Java distributed system, which adapts to available resources, {{has been}} developed to minimise the overall processing time of computationally intensive problems. The system exploits the free resources of a heterogeneous set of computers linked together by a network, communicating using SUN Microsystems' Remote Method Invocation and Java sockets. It uses a multi-tiered distributed system model, which in principal allows for a system of unbounded size. The system consists of an n-ary <b>tree</b> <b>of</b> <b>nodes</b> where the internal nodes perform the scheduling and the leaves do the processing. The scheduler nodes communicate in a peer-to-peer manner and the processing nodes operate in a strictly client-server manner with their respective scheduler. The independent schedulers on each tier of the tree dynamically allocate resources between problems based on the constantly changing characteristics of the underlying network. The system has been evaluated over a network of 86 PCs with a bioinformatics application and the travelling salesman optimisation problem...|$|E
40|$|Interactive {{modeling}} using implicit surfaces {{requires a}} fast visualization technique. Complex implicit CSG models {{can be represented}} hierarchically as a <b>tree</b> <b>of</b> <b>nodes</b> (the BlobTree). However, current methods cannot be used to visualize changes made to these models at interactive rates due to {{the large number of}} potential field evaluations required. We present a heirarchical spatial caching technique which accelerates evaluations of the potential function. The method introduces the concept of a caching node inserted into the implicit model tree. Caching nodes store exact potential field values at the nodes of a voxel grid and rely on tri-linear and tri-quadratic reconstruction filters to locally approximate the potential field of a sub-tree. The caching nodes employ a lazy evaluation scheme to avoid expensive pre-computation. With spatial caching nodes an order-of-magnitude decrease in polgyonization time is achieved for complex implicit models containing thousands of primitives. Interactive manipulation of these models is demonstrated in a BlobTree modeling tool. 1...|$|E
5000|$|Gives {{access to}} an ordered <b>tree</b> {{structure}} <b>of</b> synthesis <b>nodes</b> which define the order of execution ...|$|R
3000|$|..., for sufficiently-high k, {{the number}} <b>of</b> <b>nodes</b> visited by the trip. We {{demonstrate}} {{this in the}} Appendix for an arbitrary <b>tree</b> with <b>nodes</b> <b>of</b> degree [...]...|$|R
5000|$|... {{evolution}} of host-parasite interactions (requires annotation <b>of</b> <b>tree</b> <b>nodes</b> with taxonomic information for both host and parasite) ...|$|R
40|$|Introduction In {{this chapter}} we explore {{the lower level}} {{implementation}} issues surrounding {{what we call the}} Genome Interpreter. Provided is example code from 5 test programs which were used to evaluate performance. Section 13. 8 summarizes the results of these tests and discusses the trade-offs involved with the various implementations. For the upcoming discussion, what we call an interpreter specifies the following lower level aspects of the design:. the raw node representation. how a <b>tree</b> <b>of</b> <b>nodes</b> is represented. the method for evaluating an individual node. the method for evaluating the tree as a whole. the methods for (or methods to assist) those genetic operators which are dependent on the node or tree representation. A key point is that the interpreter specifies the node implementation which is the particular part of the platform-coding in which the overhead will be magnified. Therefore, the interpreter is the most crucial component in the overall design with respect...|$|E
40|$|MULTOPS: a data-structure for {{bandwidth}} attack detection A denial-of-service bandwidth {{attack is}} an attempt to disrupt an online service by generating a traffic overload that clogs links or causes routers near the victim to crash. We propose a heuristic and a data-structure that network devices (such as routers) can use to detect (and eliminate) such attacks. With our method, each network device maintains a data-structure, MULTOPS, that monitors certain traffic characteristics. MULTOPS (MUlti-Level Tree for Online Packet Statistics) is a <b>tree</b> <b>of</b> <b>nodes</b> that contains packet rate statistics for subnet prefixes at different aggregation levels. The tree expands and contracts within a fixed memory budget. A network device using MULTOPS detects ongoing bandwidth attacks by the significant, disproportional difference between packet rates going to and coming from the victim or the attacker. MULTOPS-equipped routing software running on an off-the-shelf 700 Mhz Pentium III PC can process up to 340, 000 packets per second. ...|$|E
40|$|ABSTRACT: In {{this thesis}} we {{investigate}} path finding problems, that is, planning routes from a start node to some goal nodes in a graph. Such problems arise in many fields of technology, for example, production planning, energy-aware message routing in large networks, resource allocation, and vehicle navigation systems. We concentrate mostly on planning a minimum cost path using the A ∗ algorithm. We begin by proving new theorems comparing {{the performance of}} A ∗ to other (generalized) path finding algorithms. In some cases, A ∗ is an optimal method in a large class of algorithms. This means, roughly speaking, that A ∗ explores a smaller region of the search space than the other algorithms in the given class. We develop a new method of improving a given (static) heuristic for A ∗ dynamically, during search. A heuristic controls the search of A ∗ so that unnecessary branches of the <b>tree</b> <b>of</b> <b>nodes</b> that A ∗ visits are pruned. The new method also finds an optimal path to any node it visits {{for the first time}} s...|$|E
50|$|The device tree is a data {{structure}} for describing hardware, which originated from Open Firmware. The {{data structure}} can hold {{any kind of}} data as internally it is a <b>tree</b> <b>of</b> named <b>nodes</b> and properties. Nodes contain properties and child nodes, while properties are name-value pairs.|$|R
5000|$|Red-black trees, {{like all}} binary search trees, allow {{efficient}} in-order traversal (that is: {{in the order}} Left-Root-Right) of their elements. The search-time results from the traversal from root to leaf, and therefore a balanced <b>tree</b> <b>of</b> n <b>nodes,</b> having the least possible tree height, results in [...] search time.|$|R
40|$|Consider {{laying out}} a fixed-topology binary <b>tree</b> <b>of</b> N <b>nodes</b> into {{external}} memory with block size B {{so as to}} minimize the worst-case number of block memory transfers required to traverse a path from the root to a <b>node</b> <b>of</b> depth D. We prove that the optimal number of memory transfers is (Formula Presented.) SCOPUS: ar. jinfo:eu-repo/semantics/publishe...|$|R
