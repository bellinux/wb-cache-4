0|3022|Public
50|$|When a {{piece of}} {{computer}} hardware can interpret a programming language directly, that language is called machine code. A so-called native code compiler is one that compiles a program into machine code. Actual compilation is often separated into multiple passes, like code generation (often <b>for</b> <b>assembler</b> <b>language),</b> <b>translator</b> (generating native code), linking, loading and execution.|$|R
40|$|This {{publication}} {{explains the}} use of the Time Sharing System (TSS) <b>for</b> <b>assembler</b> <b>language</b> programmers. It describes how to assemble, store, and execute programs in TSS, introduces the com-mand system, and explains the basic rules of task and data man-agement. Numerous examples are given showing typical user-system interaction. The appendixes include information on assembler options, output, and restrictions, as well as progra...|$|R
50|$|In older {{operating}} {{systems such as}} those used on IBM mainframes, full operating system functionality was only available to <b>assembler</b> <b>language</b> programs, not to high level language programs (unless assembly language subroutines were used, of course), as the standard macro instructions did not always have counterparts in routines available to high-level languages. In modern {{operating systems}} such as Unix and its derivatives, operating system access is provided through subroutines, usually provided by dynamic libraries. High-level languages such as C offer comprehensive access to operating system functions, obviating the need <b>for</b> <b>assembler</b> <b>language</b> programs <b>for</b> such functionality.|$|R
5000|$|System {{software}} {{including a}} {{disk operating system}} and FORTRAN, BASIC and <b>assembler</b> <b>for</b> assembly <b>language.</b>|$|R
50|$|High-level {{assemblers}} in computing are <b>assemblers</b> <b>for</b> assembly <b>language</b> {{that incorporate}} features found in high-level programming languages.|$|R
50|$|Fresh, an {{internet}} community supported project started by John Found, is an {{integrated development environment}} (IDE) <b>for</b> flat <b>assembler</b> <b>language.</b> The primary goal of Fresh is to make programming in assembly as fast and efficient as in other visual languages, without sacrificing the small application size and the raw power of assembly language. Fresh {{can be used for}} Windows programming, but also to create programs for any OS that FASM supports: MS-DOS, Linux, FreeBSD, BeOS, MenuetOS.|$|R
40|$|This paper {{focuses on}} the {{usability}} of the PINPAS tool. The PINPAS tool is an instruction-level interpreter <b>for</b> smartcard <b>assembler</b> <b>languages,</b> augmented with facilities to study side-channel vulnerabilities. The tool can simulate side-channel leakage and has a suite of utilities to analyze this. The usage of the tool, {{for the analysis of}} a cryptographic algorithm is illustrated using the standard AES and RSA. Vulnerabilities of the implementations are identied and protective measures added. It is argued, that the tool can be instrumental for the design and realization of secure smartcard implementations in a systematic way...|$|R
50|$|There {{are also}} {{low-level}} languages {{such as the}} Lx family implemented by the bootstrapping method. The L0 language may be considered as <b>assembler</b> <b>for</b> transformation <b>languages.</b> There is also a high-level graphical language built on upon Lx called MOLA.|$|R
40|$|The {{aim of this}} {{bachelor}} {{thesis is}} to create adaptor with microcontroller for data acgusition system. Function of the device is to receive serial asynchronous string of ASCII characters which was send from ultrasonic thickness gauge. Baud rate of transmittion is 2400 Bd. Transmittion is realized according to RS- 232 standard. Part of the string contains numeric information about value which was measured by thickness gauge. This numeric information is in microcontroller multiplied with corrective constant and decimal point in result is placed to right position. Corrective constant is stored in EEPROM memory. After that adaptor transsmits data to superior system in format of serial asynchronous string of ASCII with baud rate 9600 Bd. Thesis describes service code <b>for</b> microcontroller in <b>Assembler</b> <b>language</b> and hardware construction of device...|$|R
40|$|Practice and {{reinforce}} concepts and techniques learned in CSCE- 230. Specifically: – Arithmetic and Logic Level Implementation: Basic logic design of combinational and sequential logic, schematic capture, {{implementation of a}} control-datapath design. – <b>Assembler</b> <b>Language</b> Programming: assembling, loading, & linking in one <b>assembler</b> <b>language,</b> with simplified applications involving flow of control, arrays, loops, procedure calls, parameter passing, and floating point arithmetic. • Introduction to team work and written & oral communication {{in the context of}} a technical design project. • Gain experience with typical logic design tools & one <b>assembler</b> <b>language</b> programming environment...|$|R
40|$|The {{objective}} {{of the project was}} to develop a machine <b>language</b> to <b>assembler</b> <b>language</b> <b>translator</b> <b>for</b> the IBM 360 computer. The translator developed has the capability of processing modules in any of the formats accepted by the IH"I 360. That is, source modules in any language, object modules and load modules can all be processed by the translator. The output from the translator consists of a machine <b>language</b> display, an <b>assembler</b> code display, a storage map display and a display of register contents at initiation and termination of module processing. Ball State UniversityMuncie, IN 47306 Thesis (M. S.) [...] Ball State University, 1975...|$|R
50|$|The {{scores of}} these chiptunes {{were written in}} Motorola 68000 <b>Assembler</b> <b>language,</b> not {{with the help of}} a {{graphical}} music editor. The program routines used to play the Yamaha YM2149 (soundchip in the Atari 1040STF) were all coded and optimized in Motorola 68000 <b>Assembler</b> <b>language</b> by Benjamin Gerard, born 1973, his brother.|$|R
5000|$|Generally {{accepted}} standards, although by {{no means}} mandatory, include the identification of general purpose registers with mnemonics. Unlike <b>assemblers</b> <b>for</b> some other systems, such as X86 assembly language, register mnemonics are not reserved symbols but are defined through EQU statements elsewhere in the program. This improves readability of <b>assembler</b> <b>language</b> programs and provides a cross-reference of register usage. Thus typically you may see the following in an assembler program: ...|$|R
50|$|Software {{developed}} by Psion {{as part of}} the Organiser I project and application software after its launch was written in 6301 <b>assembler</b> <b>language,</b> in POPL, and in other custom-designed <b>languages.</b> <b>Assembler</b> <b>language</b> development at Psion itself was carried out using cross-development tools, including a cross assembler and linker, all of which ran on a DEC VAX.|$|R
40|$|The {{development}} of a reconfigurable micro-assembler to provide the micro-programmer the capability to specify micro-instructions in concise, meaningful terms is discussed. The implementation plan for the {{development of}} the micro-assembler was predicted on the existing capabilities of the SUMC Reconfigurable Assembler. Utilizing the reconfigurable assembler as a base, new directives and existing directive modifications were implemented to provide the micro-assembly as a new capability of the reconfigurable <b>assembler.</b> The micro-assembler <b>language</b> allows the specification of all micro-instruction control field settings in one concise assembler source statement. The language appears very similar to a conventional machine instruction <b>assembler</b> <b>language.</b> The machine instruction <b>assembler</b> <b>language</b> has the characteristic of one operation specification per statement whereas, the micro-instruction <b>assembler</b> <b>language</b> allows multiple operations to be designated per statement...|$|R
25|$|Michael Singer, PDP-11. <b>Assembler</b> <b>Language</b> Programming and Machine Organization, John Wiley & Sons, NY: 1980.|$|R
40|$|A {{portable}} {{system for}} translating APL programs into programs in an <b>assembler</b> <b>language</b> is presented; the translation is performed in two steps; {{in the first}} step the APL program is translated into a program in an intermediate lanuage {{which can be used}} as a documentation of the program itself; the second step consists in defining the intermediate language in terms of pre-defined routines in the <b>assembler</b> <b>language...</b>|$|R
50|$|The {{principal}} high-level programming languages were GEORGE, ALPHACODE, STEVE, TIP, GIP, and Algol. <b>Assembler</b> <b>language</b> translators included ZP43 and STAC.|$|R
50|$|The {{format of}} <b>assembler</b> <b>language</b> {{statements}} reflects {{the layout of}} an 80-column punched card, though successive versions have relaxed most of the restrictions.|$|R
50|$|The {{efficiency}} of compiled high-level COBOL and PL/I language programs left {{much to be}} desired. Many CICS application programs continued to be written in <b>assembler</b> <b>language,</b> even after COBOL and PL/I support became available.|$|R
50|$|For maximum {{efficiency}} all calculations were programmed {{using the}} <b>assembler</b> <b>language</b> supplied with the hardware. A high-level language resembling Fortran was provided for coordinating tasks and controlling data transfers {{to and from}} the host computer.|$|R
50|$|The team first {{built an}} OOPS {{environment}} {{using a combination}} of procedural Rexx and <b>assembler</b> <b>language.</b> Valour may {{have been one of the}} first commercial products that looked to object-oriented programming to underpin its development platform.|$|R
5000|$|The MALPAS toolset {{comprises}} five {{specific analysis}} tools that address various properties of a program. The input to the analysers {{needs to be}} written in MALPAS Intermediate Language (IL); this can be hand-written or produced by an automated translation tool from the original source code. Automatic <b>translators</b> exist <b>for</b> common high-level programming languages such as Ada, C and Pascal, as well as <b>assembler</b> <b>languages</b> such as Intel 80*86, PowerPC and 68000. The IL text is input into MALPAS via the [...] "IL Reader", which constructs a directed graph and associated semantics for the program under analysis. The graph is reduced using a series of graph reduction techniques.|$|R
40|$|The clean, simple, {{and elegant}} {{architecture}} of the classic PDP- 8 makes it an ideal candidate for studying concepts in computer organization. The PDP- 8 Emulator Program allows a user to write, edit, assemble, debug, trace and execute PDP- 8 machine code and PDP- 8 <b>assembler</b> <b>language</b> programs. With it the user can obtain {{a feel for the}} PDP- 8. The PDP- 8 Emulator Program includes a simple built-in text editor which is used to write and edit PDP- 8 <b>Assembler</b> <b>Language</b> programs, an <b>assembler</b> to translate these programs into PDP- 8 machine code and a virtual PDP- 8 engine upon which to execute the code. PDP- 8 code can be executed from a debug screen display that allows the user to observe the contents of registers and memory as the code executes or code can be executed using an I/O interface that requires user-written PDP- 8 I/O routines. This paper provides an introduction to both the PDP- 8 architecture and PDP- 8 <b>Assembler</b> <b>Language</b> and discusses how to use the PDP- 8 Emulator Program. The PDP- 8 Emulator Program was written using Borland’s Turbo Pascal v 6. 0 and runs under MS-DOS in a Command window...|$|R
50|$|Schönhage {{designed}} and implemented together with Andreas F. W. Grotefeld and Ekkehart Vetter a multitape Turing machine, called TP, in software. The machine is programmed in TPAL, an <b>assembler</b> <b>language.</b> They implemented numerous numerical algorithms including the Schönhage-Strassen algorithm on this machine.|$|R
50|$|IBM offered <b>assembler</b> <b>language</b> macros {{to provide}} {{programming}} support. During the System/360 era, these access methods were BTAM (Basic Telecommunications Access Method) and QTAM (Queued Telecommunications Access Method) - which was later replaced by Telecommunications Access Method (TCAM). IBM introduced VTAM (Virtual Telecommunications Access Method) with the System/370.|$|R
40|$|In this {{dissertation}} I present my thesis: A high-level type {{system is}} a good aid for developing signal processing programs in handwritten Digital Signal Processor (DSP) assembler code. The problem behind the thesis is that it if often necessary to programing software for embedded systems in <b>assembler</b> <b>language.</b> However, programming in assembler causes numerous problems, such as memory corruption, for instance. To test the thesis I define a model <b>assembler</b> <b>language</b> called Featherweight DSP which captures some of the essential features of a real custom DSP used in the industrial partner’s digital hearing aids. I present a baseline type system which is the type system of DTAL adapted to Featherweight DSP. I then explain two classes of programs that uncovers some shortcomings of the baseline type systesm. The classes of problematic program...|$|R
2500|$|More {{sophisticated}} high-level <b>assemblers</b> provide <b>language</b> abstractions such as: ...|$|R
40|$|This {{bachelor}} {{thesis is}} focused on development of applications for gamepad. Applications are programmed in <b>assembler</b> <b>language</b> and in C. Gamepad are created by 8 -bit microprocessor AVR ATmega 32, monochromatic LCD display with screen resolution 128 x 64 dots and the joystick is connected in order to manage the easy control...|$|R
50|$|PRTV {{was written}} {{in a mixture of}} languages. The higher layers were written in MP/3 and PL/I, whereas the lower layers were written in PL/I and System/370 <b>assembler</b> <b>language.</b> MP/3 was a macro {{processing}} language developed at Peterlee from 1973 onwards, similar to ML/I or TRAC. PRTV ran on System/370 IBM mainframes.|$|R
50|$|For {{performance}} reasons, in 1992 and 1993 SK8 was re-implemented {{from the}} ground up. Working at Apple's Cambridge Research Center, the Macintosh Common Lisp object store was isolated and directly hooked into SK8's store. The SK8Script debugger was re-implemented at the <b>assembler</b> <b>language</b> level (previously in Lisp) and the compiler and runtime performance improved.|$|R
40|$|This paper {{addresses}} the vectorization of the lifting-based wavelet transform on general-purpose microprocessors {{in the context}} of JPEG 2000. Since SIMD exploitation strongly depends on an efficient memory hierarchy usage, this research is based on previous work about cacheconscious DWT implementations [1, 2,$]. Furthermore, the vectorization has been performed avoiding <b>assembler</b> <b>language</b> programming in order to improve code portability...|$|R
5000|$|As {{explained}} {{further in}} [...] "Usage" [...] below, the name [...] "BR14" [...] {{comes from the}} IBM assembler-language instruction [...] "Branch (to the address in) Register 14", which by convention is used to [...] "return from a subroutine". Most early users of OS/360 were familiar with IBM <b>Assembler</b> <b>Language</b> and would have recognized this at once.|$|R
50|$|William Daly Jr. {{wrote and}} {{described}} a Qubic-playing program {{as part of}} his Master's program at the Massachusetts Institute of Technology. The program was written in <b>assembler</b> <b>language</b> <b>for</b> the TX-0 computer. It included lookahead to 12 moves and kept a history of previous games with each opponent, modifying its strategy according to their past behavior.|$|R
50|$|GEC 4000 series {{computers}} {{were capable of}} running a number of operating systems but in practice Prestel machines exclusively ran OS4000 which itself was developed by GEC. This in turn supported BABBAGE, the so-called high level <b>assembler</b> <b>language</b> {{in which all the}} Prestel software for both IRC and UDC machines (and later the messaging machine) was written.|$|R
40|$|A {{software}} {{model of}} a reversible processor ReveR with the stack is discussed in this paper. An architecture, the minimal set of elementary reversible operations together with an implementation of the basic control flow structures and procedures calls using simple <b>assembler</b> <b>language</b> are described. Comment: LaTeX, 7 pages, no figures, 3 tables, v 2 : spelling and grammar corrected; project url [URL]...|$|R
