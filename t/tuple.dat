3501|3569|Public
5|$|Graphs and {{directed}} graphs {{can be viewed}} as a special case of the far more general notion called relational structures (defined as a set with a <b>tuple</b> of relations on it). Directed graphs are structures with a single binary relation (adjacency) on the domain (the vertex set). Under this view, homomorphisms of such structures are exactly graph homomorphisms.|$|E
5|$|An {{endpoint}} of a pipe is addressable with a <b>tuple</b> (device_address, endpoint_number) as {{specified in}} a TOKEN packet that the host sends when {{it wants to}} start a data transfer session. If {{the direction of the}} data transfer is from the host to the endpoint, an OUT packet (a specialization of a TOKEN packet) having the desired device address and endpoint number is sent by the host. If the direction of the data transfer is from the device to the host, the host sends an IN packet instead. If the destination endpoint is a uni-directional endpoint whose manufacturer's designated direction does not match the TOKEN packet (e.g. the manufacturer's designated direction is IN while the TOKEN packet is an OUT packet), the TOKEN packet is ignored. Otherwise, it is accepted and the data transaction can start. A bi-directional endpoint, on the other hand, accepts both IN and OUT packets.|$|E
25|$|Records: Records {{provide a}} {{convenient}} way for associating a tag {{with each of}} the elements in a <b>tuple.</b> This allows one to refer to an element of a <b>tuple</b> by name and not by position. A pre-compiler takes the record definition and replaces it with the appropriate <b>tuple</b> reference.|$|E
40|$|Association {{rules are}} {{a class of}} regularities {{existing}} between binary data <b>tuples.</b> This paper proposes an extension of association rules which {{can be applied to}} real-valued <b>tuples.</b> It discovers and describes association rules among real-valued <b>tuples</b> using fuzzy sets. The proposed method needs user-defined fuzzy sets for describing association rules. It extends the given <b>tuples</b> using the fuzzy sets and converts the extended <b>tuples</b> into binary <b>tuples.</b> Finally, it finds association rules by applying the existing algorithms for binary <b>tuples</b> to the converted binary <b>tuples.</b> Keywords: Data mining, Association rules, Fuzzy sets 1 Introduction Data mining is the technique which extracts the previously unknown and potentially useful information from large amount of data [1], [2]. Discovering association rules is one of the data mining techniques. Association rules give simple but strong knowledge on binary data <b>tuples.</b> They are the description that the <b>tuples</b> having a certain set of attrib [...] ...|$|R
50|$|In the {{resulting}} relation, <b>tuples</b> in R which have no common values in common attribute names with <b>tuples</b> in S take a null value, ω. <b>Tuples</b> in S which have no common values in common attribute names with <b>tuples</b> in R {{also take a}} null value, ω.|$|R
40|$|We generalize the {{concepts}} of neutral and absorbent elements of aggregation operators. We introduce two types of <b>tuples</b> of values: the neutral <b>tuples</b> and the absorbent <b>tuples.</b> the neutral <b>tuples</b> are useful in situations in which information from different sources, or preferences of several decision makers, cancel each other. Absorbent <b>tuples</b> are useful in situations in which certain decision makers may decide the outcome irrespective of {{the opinion of the}} others. We examine the most important classes of aggregation operators in respect to their neutral and absorbent <b>tuples.</b> <br /...|$|R
25|$|As most {{definitions}} of color distance are distances within a color space, the standard means of determining distances is the Euclidean distance. If one presently has an RGB (Red, Green, Blue) <b>tuple</b> and wishes {{to find the}} color difference, computationally {{one of the easiest}} is to call R, G, B linear dimensions defining the color space.|$|E
25|$|More formally, {{the data}} being sorted can be {{represented}} as a record or <b>tuple</b> of values, and {{the part of the}} data that is used for sorting is called the key. In the card example, cards are represented as a record (rank, suit), and the key is the rank. A sorting algorithm is stable if whenever there are two records R and S with the same key, and R appears before S in the original list, then R will always appear before S in the sorted list.|$|E
25|$|In {{abstract}} algebra, the {{symmetric group}} Sn on a finite set of n symbols {{is the group}} whose elements are all the permutation operations that can be performed on n distinct symbols, and whose group operation is the composition of such permutation operations, which are defined as bijective functions from the set of symbols to itself. Since there are n! (n factorial) possible permutation operations that can be performed on a <b>tuple</b> composed of n symbols, {{it follows that the}} order (the number of elements) of the symmetric group Sn is n!.|$|E
40|$|In many data {{streaming}} applications, streams {{may contain}} data <b>tuples</b> {{that are either}} redundant, repetitive, or that are not “interesting” {{to any of the}} standing continuous queries. Processing such <b>tuples</b> may waste system resources without producing useful answers. To the contrary, some other <b>tuples</b> can be categorized as promising. This paper proposes that stream query engines can have the option to execute on promising <b>tuples</b> only and not on all <b>tuples.</b> We propose to maintain intermediate stream summaries and indices that can direct the stream query engine to detect and operate on promising <b>tuples.</b> As an illustration, the proposed intermediate stream summaries are tuned towards capturing promising <b>tuples</b> that (1) maximize the number of output <b>tuples,</b> (2) contribute to producing a faithful representative sample of the output <b>tuples</b> (compared to the output produced when assuming infinite resources), or (3) produce the outlier or deviant results. Experiments are conducted in the context of Nile [24], a prototype stream query processing engine developed at Purdue University. ...|$|R
3000|$|Contrarily to the Mapper, the Reducer {{receives}} its input <b>tuples</b> at once, and is hence {{allowed to}} iterate through and retain information about previously seen <b>tuples.</b> Again, the Reducer’s {{task is to}} read the input <b>tuples,</b> and produce as output one final set of <b>tuples</b> of the form 〈t [...]...|$|R
50|$|Since {{there are}} no <b>tuples</b> in Employee with a DeptName of Production, ωs occur in the Name {{attribute}} of the resulting relation where <b>tuples</b> in DeptName had <b>tuples</b> of Production.|$|R
25|$|This {{branch of}} {{recursion}} theory analyzed the following question: For fixed m and n with 0<m<n, for which functions A {{is it possible}} to compute for any different n inputs x1,x2,...,xn a <b>tuple</b> of n numbers y1,y2,...,yn such that at least m of the equations A(xk) = yk are true. Such sets are known as (m,n)-recursive sets. The first major result in this branch of Recursion Theory is Trakhtenbrot's result that a set is computable if it is (m,n)-recursive for some m,n with 2m>n. On the other hand, Jockusch's semirecursive sets (which were already known informally before Jockusch introduced them 1968) are examples of a set which is (m,n)-recursive if and only if 2m<n+1. There are uncountably many of these sets and also some recursively enumerable but noncomputable sets of this type. Later, Degtev established a hierarchy of recursively enumerable sets that are (1,n+1)-recursive but not (1,n)-recursive. After a long phase of research by Russian scientists, this subject became repopularized in the west by Beigel's thesis on bounded queries, which linked frequency computation to the above-mentioned bounded reducibilities and other related notions. One of the major results was Kummer's Cardinality Theory which states that a set A is computable if and only if there is an n such that some algorithm enumerates for each <b>tuple</b> of n different numbers up to n many possible choices of the cardinality of this set of n numbers intersected with A; these choices must contain the true cardinality but leave out at least one false one.|$|E
500|$|Python makes a {{distinction}} between lists and tuples. Lists are written as , are mutable, and cannot {{be used as the}} keys of dictionaries (dictionary keys must be immutable in Python). Tuples are written as (1, 2, 3), are immutable and thus can be used as the keys of dictionaries, provided all elements of the <b>tuple</b> are immutable. The + operator can be used to concatenate two tuples, which does not directly modify their contents, but rather produces a new <b>tuple</b> containing the elements of both provided tuples. Thus, given the variable t initially equal to (1, 2, 3), executing t = t + (4, 5) first evaluates t + (4, 5), which yields (1, 2, 3, 4, 5), which is then assigned back to t, thereby effectively [...] "modifying the contents" [...] of t, while conforming to the immutable nature of <b>tuple</b> objects. Parentheses are optional for tuples in unambiguous contexts.|$|E
500|$|These rules {{ensure that}} the map f from the [...] to [...] that maps a <b>tuple</b> [...] to [...] is bilinear. The {{universality}} states that given any vector space X and any bilinear map , there exists a unique map u, shown in the diagram with a dotted arrow, whose composition with f equals g: [...] This is called the universal property of the tensor product, an instance of the method—much used in advanced abstract algebra—to indirectly define objects by specifying maps from or to this object.|$|E
50|$|The full {{outer join}} is written as R ⟗ S where R and S are relations. The {{result of the}} full outer join is the set of all {{combinations}} of <b>tuples</b> in R and S that are equal on their common attribute names, in addition to <b>tuples</b> in S that have no matching <b>tuples</b> in R and <b>tuples</b> in R that have no matching <b>tuples</b> in S in their common attribute names.|$|R
30|$|Note {{that there}} are some {{exceptional}} cases where conflicts between two <b>tuples</b> remain. These conflicts should be solved after resolving the ones with more <b>tuples.</b> Also note that we have not yet mentioned which cells of the <b>tuples</b> to be corrected. Still, the problem of selecting <b>tuples</b> to be corrected is already NP-hard.|$|R
50|$|The {{relational}} model specifies that the <b>tuples</b> of a relation have no specific order {{and that the}} <b>tuples,</b> in turn, impose no order on the attributes. Applications access data by specifying queries, which use operations such as select to identify <b>tuples,</b> project to identify attributes, and join to combine relations. Relations can be modified using the insert, delete, and update operators. New <b>tuples</b> can supply explicit values or be derived from a query. Similarly, queries identify <b>tuples</b> for updating or deleting.|$|R
500|$|Python {{features}} sequence unpacking where multiple expressions, each evaluating {{to anything}} that can be assigned to (a variable, a writable property, etc), are associated in the identical manner to that forming <b>tuple</b> literals and, as a whole, are put on the left hand side of the equal sign in an assignment statement. The statement expects an iterable object on the right hand side of the equal sign that produces the same number of values as the provided writable expressions when iterated through, and will iterate through it, assigning each of the produced values to the corresponding expression on the left.|$|E
2500|$|Tuples: Tuples are {{containers}} for a fixed number of Erlang data types. The syntax {D1,D2,...,Dn} denotes a <b>tuple</b> whose arguments are D1, D2, ... Dn. The arguments can be primitive data types or compound data types. Any {{element of a}} <b>tuple</b> can be accessed in constant time.|$|E
2500|$|Definition (continuous formulation): Active {{inference}} {{rests on}} the <b>tuple</b> , ...|$|E
3000|$|SA computes {{the union}} of the <b>tuples</b> {{returned}} from each sub-query, and then decrypts the result <b>tuples.</b> (The union is efficiently computable because it is apriori known that the sub-queries access disjoint sets of <b>tuples.)</b> [...]...|$|R
50|$|SETL {{provides}} {{two basic}} aggregate data types: unordered sets, and sequences (the latter also called <b>tuples).</b> The elements of sets and <b>tuples</b> {{can be of}} any arbitrary type, including sets and <b>tuples</b> themselves. Maps are provided as sets of pairs (i.e., <b>tuples</b> of length 2) and can have arbitrary domain and range types. Primitive operations in SETL include set membership, union, intersection, and power set construction, among others.|$|R
40|$|We {{study the}} {{relations}} between Multi-valued Decision Diagrams (MDD) and <b>tuples</b> (i. e. elements of the Cartesian Product of variables). First, we improve the existing methods for transforming a set of <b>tuples,</b> Global Cut Seeds, sequences of <b>tuples</b> into MDDs. Then, we present some in-place algorithms for adding and deleting <b>tuples</b> from an MDD. Next, we consider an MDD constraint which is modified during the search by deleting some <b>tuples.</b> We give an algorithm which adapts MDD- 4 R to these dynamic and persistent modifications. Some experiments show that MDD constraints are competitive with Table constraints. Comment: 15 pages, 16 figure...|$|R
2500|$|... if {{and only}} if any two {{assignments}} [...] whose evaluations of the <b>tuple</b> [...] coincide assign the same value to ...|$|E
2500|$|For every {{assignment}} , [...] {{the evaluation}} of the <b>tuple</b> [...] according to [...] is in the interpretation of [...] in ...|$|E
2500|$|A linear {{dependence}} among vectors v1, ..., vn is a <b>tuple</b> (a1, ..., a'n) with n scalar components, not all zero, {{such that}} ...|$|E
5000|$|<b>Tuples</b> (class [...] ) are {{immutable}} {{sequences of}} items of arbitrary types. There {{is also a}} special syntax to create <b>tuples</b> ...|$|R
40|$|We generalize {{the notion}} of an {{absorbent}} element of aggregation operators. Our construction involves <b>tuples</b> of values that decide the result of aggregation. Absorbent <b>tuples</b> are useful to model situations in which certain decision makers may decide the outcome irrespective of the opinion of the others. We examine the most important classes of aggregation operators in respect to their absorbent <b>tuples,</b> and also construct new aggregation operators with predefined sets of absorbent <b>tuples.</b> <br /...|$|R
50|$|That is, {{the grammar}} of p2 is the base grammar {{composed}} with its extension (gj+gf), {{the source of}} p2 is the base source composed with its extension (sj+sf), and so on. As elements of delta <b>tuples</b> can themselves be delta <b>tuples,</b> composition recurses, e.g., sj+sf= c1…cn+c1…cn=c1+c1…cn+cn.Summarizing, GenVoca values are nested <b>tuples</b> of program artifacts, and features are nested delta <b>tuples,</b> where + recursively composes them by vector addition. This {{is the essence of}} AHEAD.|$|R
2500|$|For every {{assignment}} , [...] {{the evaluation}} of the <b>tuple</b> [...] according to [...] is not in the interpretation of [...] in ...|$|E
2500|$|... (the {{relation}} [...] {{does not}} hold for a <b>tuple</b> [...] {{if there is no}} evidence that it does). For instance, the stable model of the program ...|$|E
2500|$|L-system grammars {{are very}} similar to the semi-Thue grammar (see Chomsky hierarchy). [...] L-systems are now {{commonly}} known as parametric L systems, defined as a <b>tuple</b> ...|$|E
5000|$|The CDH {{assumption}} is {{also related to}} the decisional Diffie-Hellman assumption (DDH), which holds {{that it is hard}} to distinguish <b>tuples</b> of the form [...] from random <b>tuples.</b> If computing [...] from [...] were easy, then one could detect DDH <b>tuples</b> trivially. It is believed that CDH is a weaker assumption than DDH: there are groups for which detecting DDH <b>tuples</b> is easy, but solving CDH problems is believed to be hard.|$|R
3000|$|Here, we try {{to solve}} the {{conflicts}} that involve more <b>tuples</b> first, i.e., we do not take a naive approach such as modifying all <b>tuples</b> {{that are involved in}} a conflict. Let the set of <b>tuples</b> that are involved in multi-tuple conflicts be D_doubt, and the set of conflicts between <b>tuples</b> t_i, t_j ∈ D_doubt be f_ij. The problem of finding <b>tuples</b> to be corrected is selecting the subset D_doubt' of D_doubt at least one of whose members have conflict with all the remaining <b>tuples</b> in set D_doubt D_doubt'. There is a polynomial time projection from the set D_doubt to the set of vertices V and from conflicts f_ij to the set of edges E of a graph (V, E). Hence, the problem can be reduced to the dominating set problem of a graph (V, E), which is known to be NP-complete. A naive solution for this problem takes computation order of O(2 ^nn) and will be intractable as the number of <b>tuples</b> in D_doubt  increases.|$|R
40|$|In {{this work}} we address the {{classical}} problem of classifying <b>tuples</b> of linear operators and linear functions on a finite dimensional vector space up to base change. Having adopted {{for the situation}} considered a construction of framed moduli spaces of quivers, we develop an explicit classification of <b>tuples</b> belonging to a Zariski open subset. For such <b>tuples</b> we provide a finite family of normal forms and a procedure allowing to determine whether two <b>tuples</b> are equivalent...|$|R
