116|3960|Public
5000|$|In 1963 there {{started a}} program, led by Igor Gladilin and Lev Shugurov to design an engine for a true {{international}} Formula One car. The effect was the GD-1, an eight-cylinder 1500 cc DOHC engine {{which was to}} give [...] at 10,500 rpm. Moskvitch factory had no suitable test stand for high-rev engines, but already during tests the engine produced [...] at 6000 rpm. The engine was fitted with four dual Weber 280DKB carburettors and the total weight was 148 kg. The fibreglass body was designed using a wind tunnel. The engine and a five-gear gearbox were built in 1965 and a new G5 chassis was modified for <b>test</b> <b>purpose,</b> {{although it was not}} meant to be a final car. However, in 1965 a government funding was cut, and Moskvitch factory alone could not afford a program, so it was abandoned in 1967. Also, by that year more powerful 3000 cc engines were introduced to Formula One. Only the new gearbox, with four upper gears synchronised, was adapted for G5 cars.|$|E
40|$|Conformance testing {{focuses on}} {{checking}} whether an implementation. under test (IUT) behaves {{according to its}} specification. Typically, testers are interested it? performing targeted tests that exercise certain features of the IUT This intention is formalized as a <b>test</b> <b>purpose.</b> The tester needs a "strategy" to reach the goal specified by the <b>test</b> <b>purpose.</b> Also, for a particular test case, the strategy should tell the tester whether the IUT has passed, failed. or deviated front the <b>test</b> <b>purpose.</b> In [8] Jeron and Morel show how to compute, for a given finite state machine specification and a <b>test</b> <b>purpose</b> automaton, a complete test graph (CTG) which represents all test strategies. In this paper; we consider the case when the specification is a hierarchical state machine and show how to compute a hierarchical CTG which preserves the hierarchical structure of the specification. We also propose an algorithm for an online test oracle which avoids a space overhead associated with the CTG...|$|E
40|$|This paper {{presents}} a new test case generation method based on formal system specifications in SDL. The <b>test</b> <b>purpose</b> {{of a specific}} test case is specified formally by one or many Message Sequence Charts (MSCs). Based on the <b>test</b> <b>purpose</b> and the system specification a complete test case can be generated automatically in the TTCN format, including preamble, postamble and test body with all test verdicts...|$|E
40|$|AbstractThis paper {{presents}} an approach for {{the generation of}} <b>test</b> <b>purposes</b> {{in the form of}} labelled transition systems from specifications of properties in CTL. The approach is aimed at adapting the model checking process, by extending search algorithms to perform further analysis so that examples and counter-examples can be extracted. An algorithm for the generation of <b>test</b> <b>purposes</b> through analysis over the examples and counter-examples is presented, along with a case study to show the correspondence between the CTL properties and the generated <b>test</b> <b>purposes...</b>|$|R
50|$|One NUH-1B was {{produced}} for <b>test</b> <b>purposes.</b>|$|R
40|$|International audienceWe {{present a}} {{technique}} dedicated to compute automatically sets of <b>test</b> <b>purposes</b> from IOSTS specification. A coverage criterion, namely the inclusion criterion, is defined. Inclusion criterion {{is dedicated to}} decide whether set of <b>test</b> <b>purposes</b> are sufficiently complete or not. Test case generation is then studied...|$|R
40|$|AbstractThis paper {{deals with}} {{targeted}} testing of timed systems whose models may have uncontrollable behavior. The testing activity {{is viewed as}} a game between the tester and the system under test (SUT) towards a given <b>test</b> <b>purpose.</b> The SUT is modeled as Timed Game Automaton and the <b>test</b> <b>purpose</b> is specified in Timed CTL formula. We employ a timed game solver UPPAAL-TIGA to check if the <b>test</b> <b>purpose</b> is ture w. r. t. the model, and if yes, to generate a winning strategy and use it for black-box conformance testing of the SUT implementation. Specifically, we show that in case the checking yields a negative result, we can still test the SUT implementation against the <b>test</b> <b>purpose</b> as long as the SUT implementation reacts to our moves in a cooperative style. We present an operational framework of cooperative winning strategy generation, test case derivation and execution. The test method is proved to be sound and complete. Preliminary experimental results indicate that this approach is applicable to non-trivial timed systems...|$|E
40|$|We give a {{formalization}} of {{the notion}} of <b>test</b> <b>purpose</b> based on (suitably restricted) Message Sequence Charts. We define the validity of test cases with respect to such a formal <b>test</b> <b>purpose</b> and provide a simple decision procedure for validity. Comment: This paper appeared in the proceedings of the 22 nd IFIP WG 6. 1 International Conference on Formal Techniques for Networked and Distributed Systems (FORTE 2002), number 2529 Lecture Notes in Computer Scienc...|$|E
40|$|Verification of a {{test case}} for testing the {{conformance}} of protocol implementations against the formal description of the protocol involves verifying three aspects of the test case: expected input/output test behavior, test verdicts, and the <b>test</b> <b>purpose.</b> We model the safety and liveness properties {{of a test}} case using branching time temporal logic. There are four types of safety properties: transmission safety, reception safety, synchronization safety, and verdict safety. We model a <b>test</b> <b>purpose</b> as a liveness property and give a set of notations to formally specify a <b>test</b> <b>purpose.</b> All these properties expressed as temporal formulas are verified using model checking on an extended state machine graph representing the composed behavior of a test case and protocol specification. This methodology is shown {{to be effective in}} finding errors in manually developed conformance test suites. © 1993 Kluwer Academic Publishers...|$|E
50|$|Luftwaffe {{operated}} two captured PZL.37s for <b>testing</b> <b>purposes.</b>|$|R
50|$|UNLHA32.DLL {{uses its}} own method for <b>testing</b> <b>purposes.</b>|$|R
40|$|Abstract. We {{present a}} {{technique}} dedicated to compute automatically sets of <b>test</b> <b>purposes</b> from IOSTS specification. A coverage criterion, namely the inclusion criterion, is defined. Inclusion criterion {{is dedicated to}} decide whether set of <b>test</b> <b>purposes</b> are sufficiently complete or not. Test case generation is then studied. 1...|$|R
40|$|When testing {{real time}} system, Automating timed test suite {{generation}} has much advantages over manual test suite generation. Formal models are usually {{used to describe}} the complex system behaviours, such as TIOA (Timed Input Output Automaton) and MSC (Message Sequence Charts). Therefore, test suite can be generated from the formal model of the specification. Exhaustive test are preferred to cover all faults in a test, but it is almost impossible. <b>Test</b> <b>purpose</b> represents the partial requirements to be tested. In this thesis, we present a new method for automatically generating timed test suite based on the <b>test</b> <b>purpose</b> expressed in MSC, and the specification expressed in TIOA. A set of integrated algorithms is provided to process input <b>test</b> <b>purpose</b> and specification to generate timed test suite. In this method, MSC is transformed to TIOA, and the <b>test</b> <b>purpose</b> and the specification are synchronized as one single product. This single product is then sampled to construct a grid automaton. Finally, a traversal algorithm is applied to the grid automaton to generate test suite. We implemented this method and experimented it with different examples. Comparing with other methods, test cases generated by our method have a smaller number, and they are self-evident and can be easily represented by TTCN (Tree and Tabular Combined Notation...|$|E
30|$|Out of 450 {{images taken}} into {{consideration}} for each database, 360 images are used to create the training dataset and the remaining 90 images are used for <b>test</b> <b>purpose.</b>|$|E
40|$|International audienceThis paper {{deals with}} test case {{selection}} from axiomatic speci cations whose axioms are quanti er-free rst-order formulas with equality. We rst prove {{the existence of}} an ideal exhaustive test set to start the selection from. We then propose an extension of the test selection method called axiom unfolding, originally de ned for algebraic speci cations, to quanti er-free rst-order speci cations with equality. This method basically consists of a case analysis of the property under test (the <b>test</b> <b>purpose)</b> according to the speci cation axioms. It is based on a proof search for the di erent instances of the <b>test</b> <b>purpose,</b> thus allowing a sound and complete coverage of this property. The generalisation we propose allows to deal with any kind of predicate (not only equality) and with any form of axiom and <b>test</b> <b>purpose</b> (not only equations or Horn clauses). Moreover, it improves our previous works with e ciently dealing with the equality predicate, thanks to the paramodulation rule...|$|E
25|$|NRA-3B: Six RA-3Bs {{converted}} {{for various}} non-combat <b>test</b> <b>purposes.</b>|$|R
50|$|One EA-6A {{aircraft}} was modified for special <b>test</b> <b>purposes.</b>|$|R
50|$|Soviet Air Force {{operated}} three captured PZL.37s for <b>testing</b> <b>purposes.</b>|$|R
40|$|International audienceThis paper {{deals with}} test case {{selection}} from axiomatic specifications whose axioms are quantiter-free first-order formulæ. Test cases are modeled as ground formulæ and any specification has an exhaustive test data set whose successful submission means correctness, {{provided that the}} software under verification can be modeled as a first-order structure over the same signature. As {{it has already been}} done for positive conditional equational specifications, we derive test cases from selection criteria based on axiom coverage. Our selection criteria allows us to select test cases by iteratively unfolding an initial target <b>test</b> <b>purpose,</b> given as a formula. The initial reference test set is iteratively split into successive subsets. Each subset of test cases is defined by constraints which are increasingly introduced by the unfolding procedure to ensure an appropriate matching between the current <b>test</b> <b>purpose</b> under unfolding and specification axioms. Our unfolding procedure is sound (no test is added) and complete (no test is lost) with respect to the starting <b>test</b> <b>purpose.</b> It is exemplified on a simple example...|$|E
40|$|We {{propose a}} low cost and low {{intrusive}} approach to test on line the scheduler of high performance microprocessors. Differently from traditional approaches, {{it is based}} on looking for the information redundancy that the scheduler inherently has due to its performed functionality, rather than adding such a redundancy for on line <b>test</b> <b>purpose...</b>|$|E
40|$|This paper {{presents}} {{a technique to}} testing real-time systems through the derivation of executable test cases from test purposes (express user properties) on a specification, modelled as a timed automaton. The study deals with an equivalent representation of timed automata: clock region graphs. A <b>test</b> <b>purpose</b> is an acyclic graph, all paths of this graphs which are found on the specification will {{be considered as a}} test case. The timing constraints of both the specification and the <b>test</b> <b>purpose</b> should be the same. We will also show how to execute the derived test cases on the implementation through a dedicated test architecture. This execution allows both to discriminate between the different cases (input, output or waiting) and to test a representative part of the infinite set of clock values. Finally, a simple example illustrates the use of this technique...|$|E
50|$|Some {{software}} libraries are available, {{mainly for}} <b>testing</b> <b>purposes</b> and research.|$|R
50|$|In total, three P35 chassis {{were built}} in total for <b>testing</b> <b>purposes.</b>|$|R
50|$|Microsoft Dynamic Language Runtime has an {{implementation}} of LOLCODE for <b>testing</b> <b>purposes.</b>|$|R
40|$|In this paper, {{we present}} an {{algorithm}} for generating <b>test</b> <b>purpose</b> descriptions {{in form of}} MSC's from a given labeled event structure that represents {{the behavior of a}} system of asynchronously communicating extended finite state machines. The labeled event structure is a non-interleaving behavior model describing the behavior of a system in terms of the partial ordering of events...|$|E
40|$|Abstract. This paper adresses the {{generation}} of test cases for testing the conformance of a reactive black-box implementation with respect to its specification. We aim at extending the principles and algorithms of model-based testing for recursive interprocedural specifications that can be modeled by Push-Down Systems (PDS). Such specifications may be more compact than non-recursive ones and are more expressive. The generated test cases are selected according to a <b>test</b> <b>purpose,</b> a (set of) scenario of interest that one wants to observe during test execution. The test generation method we propose in this paper is based on program transformations and a coreachability analysis, which allows to decide whether and how the <b>test</b> <b>purpose</b> can still be satisfied. However, despite the possibility to perform an exact analysis, the inability of test cases to inspect their own stack prevents it from using fully the coreachability information. We discuss this partial observation problem, its consequences, and how to minimize its impact. ...|$|E
40|$|This paper adresses the {{generation}} of test cases for testing the conformance of a black-box implementation with respect to its specification, {{in the context of}} reactive systems. We aim at extending the principles and algorithms of model-based testing à la ioco for recursive specifications that can be modeled by Push-Down Systems (PDS). Such specifications may be more compact than non-recursive ones and are more expressive. The generated test cases are selected according to a <b>test</b> <b>purpose,</b> a (set of) scenario of interest that one wants to observe during test execution. The test generation method we propose in this paper is based on program transformations and a coreachability analysis, which allows to decide whether and how the <b>test</b> <b>purpose</b> can still be satisfied. However, despite the possibility to perform an exact analysis, the inability of test cases to inspect their own stack prevents it from using fully the coreachability information. We discuss this partial observation problem, its consequences, and how to minimize its impact...|$|E
5000|$|... "For <b>testing</b> <b>purposes</b> V1.0" [...] (2000)track list:1. Sapphire2. Flawless3. Die Together4. Champagne ...|$|R
5000|$|... #Caption: Pleurosigma angulatum, a diatom {{frequently}} used for <b>test</b> <b>purposes</b> in microscopy ...|$|R
40|$|We {{study the}} use of model {{checking}} techniques for the generation of test sequences. Given a formal model of the system to be tested, one can formulate <b>test</b> <b>purposes.</b> A model checker then derives test sequences that fulfill these <b>test</b> <b>purposes.</b> The method is demonstrated by applying it to a specification of an Intelligent Network with two features...|$|R
40|$|Test {{generation}} is a program-synthesis problem: {{starting from the}} formal specification of a system under test, and from a <b>test</b> <b>purpose</b> describing a set of behaviours to be tested, compute a reactive program that observes an implementation of the system to detect non-conformant behaviour, while trying to control it towards satisfying the <b>test</b> <b>purpose.</b> In this paper we describe an approach for generating symbolic test cases, {{in the form of}} input-output automata with variables and parameters. 1 Introduction It is widely recognized that testing is an essential component of the full lifecycle of software systems. Among the many di#erent testing techniques, conformance testing [11] {{is one of the most}} rigorous. The usual theoretical approach [5, 16] is to consider a formal specification of the intended behaviour of the Implementation Under Test (IUT). It allows to define the notion of conformance relation, which defines the correct implementations with respect to the specification. It also [...] ...|$|E
40|$|Abstract. Testing {{real-time}} {{systems is}} an important and not obvious step in the validation process of critical systems. This paper proposes an efcient algorithm for solving the feasi-bility problem corresponding to a path of length in a timed automaton, with 	 clocks. The given solution, combined with synchronous product, allows in particular, generating both the fastest and the slowest timed test cases for a given <b>test</b> <b>purpose.</b> 1...|$|E
40|$|International audienceThis paper {{addresses}} {{the problem of}} generating symbolic test cases for testing the conformance of a black-box implementation {{with respect to a}} specification, in the context of reactive systems. The challenge we consider is the selection of test cases according to a <b>test</b> <b>purpose,</b> which is here a set of scenarii of interest that one wants to observe during test execution. Because of the interactions that occur between the test case and the implementation, test execution {{can be seen as a}} game involving two players, in which the test case attempts to satisfy the <b>test</b> <b>purpose.</b> Efficient solutions to this problem have been proposed in the context of finite-state models, based on the use of fixpoint computations. We extend them in the context of infinite-state symbolic models, by showing how approximate fixpoint computations can be used in a conservative way. The second contribution we provide is the formalization of a quality criterium for test cases, and a result relating the quality of a generated test case to the approximations used in the selection algorithm...|$|E
25|$|UP-2J :P-2J {{converted}} for drone support, target towing and <b>test</b> <b>purposes.</b> Four converted.|$|R
50|$|A {{wireless}} bus is also implemented as {{a secondary}} payload for <b>testing</b> <b>purposes.</b>|$|R
50|$|The {{designation}} of two EA-6B prototypes, which were modified for special <b>test</b> <b>purposes.</b>|$|R
