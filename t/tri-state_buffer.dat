10|8|Public
50|$|Tri-state voltage buffers {{are used}} widely on buses, which allows {{multiple}} devices {{communicate with each}} other. A bus can only read one data input from a device at one time, {{and that is when}} a <b>tri-state</b> <b>buffer</b> is applied. A <b>Tri-state</b> <b>buffer,</b> with its control input, can prevent a bus from reading excessive input.|$|E
5000|$|This system {{promoted}} a useful set of logic values that typical CMOS logic designs could implement {{in the vast}} majority of modeling situations. The [...] literal makes <b>tri-state</b> <b>buffer</b> logic easy. The [...] and [...] weak drives permit wired-AND and wired-OR logic. Additionally, the [...] state is the default value for all object declarations so that during simulations uninitialized values are easily detectable and thus easily corrected if necessary.|$|E
40|$|For {{the recent}} CMOS feature sizes power {{dissipation}} becomes an overriding concerns for VLSI circuit design. We propose {{a novel approach}} named <b>tri-state</b> <b>buffer</b> with common data bus which reduces the total power & delay of elastic buffer. The paper presents a design and implementation of <b>tri-state</b> <b>buffer</b> mechanism. This design offers also the advantage of third state (High Impedance state) of <b>tri-state</b> <b>buffer.</b> The proposed elastic buffer design using <b>tri-state</b> <b>buffer</b> is implemented in Cadence tools. The obtained result shows that our design is effective in terms 20. 50...|$|E
50|$|Active high <b>Tri-state</b> digital <b>buffer</b> is {{a buffer}} with control input high {{as an active}} state.|$|R
40|$|An {{interesting}} {{target for}} the intruders is computers, since valuable data are fed into it. The need for impeccable intrusion detection system is growing every day. Hardware based Network Intrusion Detection System (NIDS) relies upon power, delay and area. The Counting Bloom filter (CBF), improves the power and speed of membership test by maintaining a hazy and compact representation of large set to be searched. Our proposed architecture utilizes an array of Linear Feedback Shift Register (LFSR) along with <b>tri-state</b> <b>buffers.</b> Circuit simulation is shown for 8 -bit count per entry. Simulation results show that proposed architecture is 35 % hardware efficient compared to Low Power Fast Countin...|$|R
40|$|Abstract — This paper {{presents}} a hybrid logic simulator using both an event-driven and a cycle-based methods. For special primitives such as memories and <b>tri-state</b> <b>buffers,</b> {{it uses a}}n event-driven method. For other parts, it uses a cycle-based method using LUT cascade emulators. To simulate a large scale circuit, it partitions the circuit into smaller ones, and realizes each part by an LUT cascade emulator. Next, it combines these emulators by interconnections. Since a mul-tiplier often requires large memories in an LUT cascade, an instruction of the processor is used instead of the LUT cas-cade. This will reduce the code size and the simulation time. Our experiment shows that proposed method is effective for circuits including arithmetic operations. I...|$|R
40|$|This paper {{examines}} the electrical design of FPGA interconnect circuitry. We explore the circuit design of pass transistor and <b>tri-state</b> <b>buffer</b> routing switches, determine which transistor sizing, metal width and metal spacing {{are best for}} FPGA interconnect, and show that FPGA interconnect should be electrically heterogeneous [...] some (~ 20 %) of the routing tracks should be designed for maximum speed while the remainder should be more area-efficient. 1...|$|E
40|$|In {{this work}} we {{investigate}} the routing architecture of FPGAs, focusing primarily on determining the best distribution of routing segment lengths {{and the best}} mix of pass transistor and <b>tri-state</b> <b>buffer</b> routing switches. While most commercial FPGAs contain many length 1 wires (wires that span only one logic block) we find that wires this short lead to FPGAs that are inferior {{in terms of both}} delay and routing area. Our results show instead that it is best for FPGA routing segments to have lengths of 4 to 8 logic blocks. We also show that 50 % to 80 % of the routing switches in an FPGA should be pass transistors, with the remainder being tri-state buffers. Architectures that employ the best segmentation distributions and the best mixes of pass transistor and <b>tri-state</b> <b>buffer</b> switches found in this paper are not only 11 % to 18 % faster than a routing architecture very {{similar to that of the}} Xilinx XC 4000 X but also considerably simpler. These results are obtained using an architecture invest [...] ...|$|E
40|$|We {{propose a}} new energy {{efficient}} method of designing switch blocks inside FPGAs using novel {{variations of the}} Dual Threshold CMOS (DTMOS) based switches instead of the conventional NMOS pass transistor or <b>tri-state</b> <b>buffer</b> based switches. By intelligently sharing the extra transistor needed for using DTMOS based switches, the area overhead is kept to a minimum. Sleep transistors are used to reduce sub-threshold leakage. Using our new, novel design, we obtain a 16 % improvement in the power-delay product during the active mode per switch and a factor of 20 improvement in the stand-by mode, over conventional approaches. Extensive simulation results over benchmark circuits in CMOS 0. 13 µ are presented to illustrate {{the superiority of the}} proposed techniques. Since the proposed techniques target the switches and multiplexers which are present in large numbers on FPGAs, the overall improvement in the power-delay product is significant for an application implemented on a FPGA having the proposed features...|$|E
40|$|This paper {{presents}} in-order pulsed charge recycling {{to reduce}} energy consumption in an off-chip data bus. The proposed technique performs charge recycling by employing three steps: i) At {{the beginning of}} an off-chip data bus transaction, all bus lines which are expected to fall are connected to a common node, ii) next, one at a time and for a fixed period of time, each of the bus lines which are expected to rise are connected to the same common node to allow charge recycling, and finally, iii) regular data bus transaction is resumed by enabling the <b>tri-state</b> <b>buffers</b> to complete the remaining charging (discharging) of the rising (falling) bus lines. Experimental results in Hspice show that the proposed technique achieves 17. 4 % average energy savings in a 32 bit-wide data bus implemented in a 0. 13 μm technology with a 1. 8 V supply voltage...|$|R
5000|$|The digital buffer is {{important}} because it can control the on and off of data transmission, which is used widely in the world of registers(sophisticated data storage device) and buses(data transferring device). A typical digital buffer that is used to control multiple data inputs written onto a bus is a <b>Tri-State</b> Digital <b>Buffer,</b> which controls the data flow by [...] "tri-state" [...] pins.|$|R
5000|$|... tri-state bufferUnlike {{the single}} input digital buffer which {{has only one}} input, <b>Tri-state</b> digital <b>buffer</b> has two inputs: a data input and a control input. (A control input is {{analogous}} to a valve, which controls the data flow.) When the control input is active, the output value is the input value, and the buffer is not different from the single input digital buffer.|$|R
40|$|We {{propose a}} {{technique}} to reduce the effective parasitic capaci-tance of interconnect routing conductors {{in a bid to}} simultaneously reduce power consumption and improve delay. The parasitic ca-pacitance reduction is achieved by ensuring routing conductors ad-jacent to those used by timing critical or high activity nets are left floating- disconnected from either VDD or GND. In doing so, the effective coupling capacitance between the conductors is reduced, because the original coupling capacitance between the conductors is placed in series with other capacitances in the circuit (series com-binations of capacitors correspond to lower effective capacitance). To ensure unused conductors can be allowed to float requires the use of tri-state routing buffers, and to that end, we also propose low-cost <b>tri-state</b> <b>buffer</b> circuitry. We also introduce CAD tech-niques to maximize the likelihood that unused routing conductors are made to be adjacent to those used by nets with high activity or low slack, improving both power and speed. Results show that interconnect dynamic power reductions of up to ∼ 15. 5 % are ex-pected to be achieved with a critical path degradation of ∼ 1 %, and a total area overhead of ∼ 2. 1 %. 1...|$|E
40|$|We {{present a}} VLSI CMOS-mixed analog-digital circuit for high-rate pixel X-ray imaging applications. It {{consists}} of 32 channels at 80 mu m pitch. The total die size is 3. 7 x 14 mm(2). Each channel features: a low-noise charge preamplifier, a CR-RC shaper, a buffer, a threshold discriminator and a 16 -bit binary counter. The readout is done serially on a <b>tri-state</b> <b>buffer.</b> The main {{parameters of the}} analog part are: shaping time of 850 ns at 5 pF input capacitance, gain of 180 mV/fC, ENC (e(-) rms) = 60 + 17 C-d (pF) and a power consumption of 3. 8 W/channel. The counting rate {{is limited by the}} analog part to around 100 kHz/channel for 1 fC charge pulses. Due to the parallelism of the circuit, photon rate in the order of 1 GHz/cm(2) can be measured for a pixel size of the order of 200 x 200 mu m(2). The parameters of the circuit were optimised for the Syrmep experiment, an R&D project in digital mammography. The circuit was produced in 1. 2 mu m CMOS technology by AMS (Austria). Characterisation of the circuit, as well as first-imaging results of the circuit connected to microstrips or pixel detectors are presented. They show the circuit works according to specification and can be used for imaging applications...|$|E
40|$|In {{this paper}} a new {{hardware}} circuit {{has been proposed}} for evaluating value of a term {{in the form of}} xi easily,where x is the prime base and i is the exponent. Using greedy algorithm a large integer number can be represented by the multiplication of various prime numbers and each of the prime number may be in the form of xi. Without taking the general approach of multiplication for finding out the result of xi, the new and simple approach has been adopted. Certain pattern has been shown by detail study of the binary form of the prime basesand its exponent. Instead of multiply the prime base x with i times with itself, it can be possible to calculate the xi by performing simple logical shifts, addition or subtraction operations. Those operations are similar in nature. To calculate the exponent part, set of some similar operations have been performed repeatedly. The proposed circuit has been implemented by decoder, shift register, adder-subtractor, lookup table, counter and <b>tri-state</b> <b>buffer.</b> Exponent part of each of the prime base x has been computed by this common circuit by selecting appropriate similar type of operations by the help of the lookup table. Due to the fixed size of shift register and adder-subtractor, finite range of operations of the exponent of the corresponding prime base x has been computed with this proposed hardware circuit...|$|E
40|$|As CMOS {{processes}} {{scale and}} digital gates become faster, it is practical to implement precisely-timed digital circuits switching in the GHz range. As a result, traditionally analog circuits have moved towards mostly-digital designs, utilizing accurate time control and digital signal processing. Recently published all-digital architectures have shown several advantages over conventional analog circuits {{in terms of}} area, scalability, testability, and programmability. This thesis proposes a cell-based design methodology for synthesizable RF/analog circuits, where all functional blocks are not only implemented in all-digital architectures, {{but they are also}} described in a hardware description language, synthesized from commercial standard cell libraries, and automatically placed and routed using design tools. This cell-based design procedure significantly shortens the design time, and enhances portability of the circuits for various applications and different design nodes. A cell-based digitally controlled oscillator (DCO) is proposed as a core block for synthesizable circuits. The DCO consists of <b>tri-state</b> <b>buffers</b> from standard cell libraries, and the frequency of the DCO is digitally controlled by turning on/off the buffers. Instead of custom layout, the buffers in the DCO are automatically placed and routed (P&R), and systematic mismatch from automatic P&R is modeled and utilized to characterize the DCO in the design phase. Calibration schemes utilizing systematic mismatch are also proposed to achieve higher DCO resolution. This thesis presents an ultra-wideband (UWB) transmitter, a time-to-digital converter (TDC), and a PLL in 65 nm CMOS technologies as prototypes of cell-based circuits. The UWB transmitters embed the proposed DCO to control the center frequency and width of output pulses in the 3. 1 GHz- 5. 0 GHz UWB band, and the measured active energy efficiency of the transmitter ranges from 12 pJ/pulse to 19 pJ/pulse. The TDC adopts a cyclic Vernier structure, where two DCOs are oscillating with slightly different periods. The resolution of the TDC is the difference between two periods, which is measured as low as 8 ps. The prototype PLL adopts the TDC and the DCO, and shows 3. 2 psrms of period jitter at 2. 5 GHz output frequency, which is comparable to state-of-the-art full-custom ADPLLs...|$|R
40|$|Ping-Ki Tsang. Thesis (M. Phil.) [...] Chinese University of Hong Kong, 2000. Includes bibliographical {{references}} (leaves 87 - 95). Abstracts in English and Chinese. Abstract [...] - p. iAcknowledgments [...] - p. iiiChapter 1 [...] - Introduction [...] - p. 1 Chapter 1. 1 [...] - Motivation and Aims [...] - p. 1 Chapter 1. 2 [...] - Contributions [...] - p. 3 Chapter 1. 3 [...] - Overview of the Thesis [...] - p. 4 Chapter 2 [...] - Asynchronous Logic g [...] - p. 6 Chapter 2. 1 [...] - Motivation [...] - p. 6 Chapter 2. 2 [...] - Timing Models [...] - p. 9 Chapter 2. 2. 1 [...] - Fundamental-Mode Model [...] - p. 9 Chapter 2. 2. 2 [...] - Delay-Insensitive Model [...] - p. 10 Chapter 2. 2. 3 [...] - QDI and Speed-Independent Models [...] - p. 11 Chapter 2. 3 [...] - Asynchronous Signalling Protocols [...] - p. 12 Chapter 2. 3. 1 [...] - 2 -phase Handshaking Protocol [...] - p. 12 Chapter 2. 3. 2 [...] - 4 -phase Handshaking Protocol [...] - p. 13 Chapter 2. 4 [...] - Data Representations [...] - p. 14 Chapter 2. 4. 1 [...] - Dual Rail Coded Data [...] - p. 15 Chapter 2. 4. 2 [...] - Bundled Data [...] - p. 15 Chapter 2. 5 [...] - Previous Asynchronous Processors [...] - p. 16 Chapter 2. 6 [...] - Summary [...] - p. 20 Chapter 3 [...] - The MSL 16 Architecture [...] - p. 21 Chapter 3. 1 [...] - RISC Machines [...] - p. 21 Chapter 3. 2 [...] - Stack Machines [...] - p. 23 Chapter 3. 3 [...] - Forth and its Applications [...] - p. 24 Chapter 3. 4 [...] - MSL 16 [...] - p. 26 Chapter 3. 4. 1 [...] - Architecture [...] - p. 28 Chapter 3. 4. 2 [...] - Instruction Set [...] - p. 30 Chapter 3. 4. 3 [...] - The Datapath [...] - p. 32 Chapter 3. 4. 4 [...] - Interrupts and Exceptions [...] - p. 33 Chapter 3. 4. 5 [...] - Implementing Forth primitives [...] - p. 34 Chapter 3. 4. 6 [...] - Code Density Estimation [...] - p. 34 Chapter 3. 5 [...] - Summary [...] - p. 35 Chapter 4 [...] - Design Methodology [...] - p. 37 Chapter 4. 1 [...] - Basic Notation [...] - p. 38 Chapter 4. 2 [...] - Specification of MSL 16 A [...] - p. 39 Chapter 4. 3 [...] - Decomposition into Concurrent Processes [...] - p. 41 Chapter 4. 4 [...] - Separation of Control and Datapath [...] - p. 45 Chapter 4. 5 [...] - Handshaking Expansion [...] - p. 45 Chapter 4. 5. 1 [...] - 4 -Phase Handshaking Protocol [...] - p. 46 Chapter 4. 6 [...] - Production-rule Expansion [...] - p. 47 Chapter 4. 7 [...] - Summary [...] - p. 48 Chapter 5 [...] - Implementation [...] - p. 49 Chapter 5. 1 [...] - C-element [...] - p. 49 Chapter 5. 2 [...] - Mutual Exclusion Elements [...] - p. 51 Chapter 5. 3 [...] - Caltech Asynchronous Synthesis Tools [...] - p. 53 Chapter 5. 4 [...] - Stack Design [...] - p. 54 Chapter 5. 4. 1 [...] - Eager Stack Control [...] - p. 55 Chapter 5. 4. 2 [...] - Lazy Stack Control [...] - p. 56 Chapter 5. 4. 3 [...] - Eager/Lazy Stack Datapath [...] - p. 53 Chapter 5. 4. 4 [...] - Pointer Stack Control [...] - p. 61 Chapter 5. 4. 5 [...] - Pointer Stack Datapath [...] - p. 62 Chapter 5. 5 [...] - ALU Design [...] - p. 62 Chapter 5. 5. 1 [...] - The Addition Operation [...] - p. 63 Chapter 5. 5. 2 [...] - Zero-Checker [...] - p. 64 Chapter 5. 6 [...] - Memory Interface and <b>Tri-state</b> <b>Buffers</b> [...] - p. 64 Chapter 5. 7 [...] - MSL 16 A [...] - p. 65 Chapter 5. 8 [...] - Summary [...] - p. 66 Chapter 6 [...] - Results [...] - p. 67 Chapter 6. 1 [...] - FPGA based {{implementation of}} MSL 16 [...] - p. 67 Chapter 6. 2 [...] - MSL 16 A [...] - p. 69 Chapter 6. 2. 1 [...] - A Comparison of 3 Stack Designs [...] - p. 69 Chapter 6. 2. 2 [...] - Evaluation of the ALU [...] - p. 73 Chapter 6. 2. 3 [...] - Evaluation of MSL 16 A [...] - p. 74 Chapter 6. 3 [...] - Summary [...] - p. 81 Chapter 7 [...] - Conclusions [...] - p. 83 Chapter 7. 1 [...] - Future Work [...] - p. 85 Bibliography [...] - p. 87 Publications [...] - p. 9...|$|R

