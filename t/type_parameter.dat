99|2075|Public
2500|$|Note {{that this}} monad, unlike those already seen, takes a <b>type</b> <b>parameter,</b> {{the type of}} the state information. The monad {{operations}} are defined as follows: ...|$|E
2500|$|Type-parameters are names used {{in place}} of {{concrete}} types when defining a new generic. They {{may be associated with}} classes or methods by placing the <b>type</b> <b>parameter</b> in angle brackets [...] When instantiating (or calling) a generic, you can then substitute a concrete type for the type-parameter you gave in its declaration. Type parameters may be constrained by use of the [...] keyword and a constraint specification, any of the six comma separated constraints may be used: ...|$|E
50|$|A {{method is}} generic if it {{declares}} {{one or more}} type variables. These type variables are known as the formal type parameters of the method. The form of the formal <b>type</b> <b>parameter</b> list is identical to a <b>type</b> <b>parameter</b> list of a class or interface.|$|E
50|$|In Java, is-a {{relation}} between the <b>type</b> <b>parameters</b> of one class or interface and the <b>type</b> <b>parameters</b> of another {{are determined by the}} extends and implements clauses.|$|R
5000|$|... #Subtitle level 3: Covariant and {{contravariant}} generic <b>type</b> <b>parameters</b> ...|$|R
5000|$|Templates {{are written}} as compile time {{functions}} with <b>type</b> <b>parameters.</b>|$|R
50|$|Because {{there is}} only one copy per generic class at runtime, static {{variables}} are shared among all the instances of the class, regardless of their <b>type</b> <b>parameter.</b> Consequently, the <b>type</b> <b>parameter</b> cannot be used in the declaration of static variables or in static methods.|$|E
50|$|Generic {{abstraction}} enables generic definitions {{be defined}} by abstracting a <b>type</b> <b>parameter</b> (of a given kind).|$|E
50|$|A {{constructor}} can {{be declared}} as generic, independently {{of whether the}} class that the constructor is declared in is itself generic. A constructor is generic if it declares one or more type variables. These type variables are known as the formal type parameters of the constructor. The form of the formal <b>type</b> <b>parameter</b> list is identical to a <b>type</b> <b>parameter</b> list of a generic class or interface.|$|E
5000|$|In Haskell, type {{classes have}} been refined {{to allow the}} {{programmer}} to declare functional dependencies between <b>type</b> <b>parameters</b> - a concept inspired from relational database theory. That is, the programmer can assert that a given assignment of some subset of the <b>type</b> <b>parameters</b> uniquely determines the remaining <b>type</b> <b>parameters.</b> For example, general monads [...] which carry a state <b>parameter</b> of <b>type</b> [...] satisfy the type class constraint [...] In this constraint, there is a functional dependency [...] This means that for a given monad, the state type accessible from this interface is uniquely determined. This aids the compiler in type inference, as well as aiding the programmer in type-directed programming.|$|R
50|$|The GHC {{implementation}} provides {{support for}} existentially quantified <b>type</b> <b>parameters</b> and for local constraints.|$|R
40|$|We {{propose a}} per-type {{instantiation}} mechanism for generic aspects. Though AspectJ supports generic aspects, which declare <b>type</b> <b>parameters,</b> we cannot declare aspects that are parametrized over both field types and return types of applied join points without manually concretizing the <b>type</b> <b>parameters.</b> Our mechanism creates automatically {{an instance of}} a generic aspect {{for each type of}} the applied join points...|$|R
5000|$|In {{the body}} of a generic unit, the (formal) <b>type</b> <b>parameter</b> is handled like its upper bound (expressed with [...] if not constrained). If the return type of a method is the <b>type</b> <b>parameter,</b> the result (e.g. of type [...] ) can be {{referenced}} by a variable of the type of the upper bound (or [...] ). In the other direction, the wildcard fits no other type, not even : If [...] has been applied as the formal <b>type</b> <b>parameter</b> of a method, no actual parameters can be passed to it. However, objects of the unknown type can be read from the generic object and assigned to a variable of a supertype of the upperbound.|$|E
50|$|Publication <b>type</b> <b>parameter</b> allows searching by {{the type}} of publication, {{including}} reports of various kinds of clinical research.|$|E
5000|$|Note {{that this}} monad, unlike those already seen, takes a <b>type</b> <b>parameter,</b> {{the type of}} the state information. The monad {{operations}} are defined as follows: ...|$|E
5000|$|An {{optional}} base64 extension , {{separated from}} the preceding part by a semicolon. When present, this indicates that the data content of the URI is binary data, encoded in ASCII format using the Base64 scheme for binary-to-text encoding. The base64 extension is distinguished from any media <b>type</b> <b>parameters</b> by virtue of not having a [...] component and by coming after any media <b>type</b> <b>parameters.</b>|$|R
2500|$|Generics (or {{parameterized}} types, parametric polymorphism) use <b>type</b> <b>parameters,</b> {{which make}} it possible to design classes and methods that do not specify the type used until the class or method is instantiated. The main advantage is that one can use generic <b>type</b> <b>parameters</b> to create classes and methods that can be used without incurring the cost of runtime casts or boxing operations, as shown here: ...|$|R
5000|$|In {{many cases}} the user of the method need not {{indicate}} the <b>type</b> <b>parameters,</b> {{as they can be}} inferred: ...|$|R
5000|$|An array {{object that}} is an array of a {{parameterized}} type can only parameterized by an unconstrained (i.e. with an unbound wildcard <b>type</b> <b>parameter)</b> type as the component type: ...|$|E
50|$|While these {{variations}} of ISUP differ in subtle ways, {{the vast majority}} of ISUP message <b>type,</b> <b>parameter</b> type, and parameter field code-points, and related fundamental call processing procedures, agree across all variants.|$|E
5000|$|Intersection types {{can be used}} to get a non-optional {{type out}} of a possibly-optional type, such as a <b>type</b> <b>parameter.</b> For example, the {{signature}} of a function that removes [...] elements from a stream of values could be: ...|$|E
40|$|This paper {{presents}} strong {{connections between}} four variants of the zero forcing number and four variants of the Grundy domination number. These connections bridge the domination {{problem and the}} minimum rank problem. We show that the Grundy domination <b>type</b> <b>parameters</b> are bounded above by the minimum rank <b>type</b> <b>parameters.</b> We also give a method to calculate the $L$-Grundy domination number by the Grundy total domination number, giving some linear algebra bounds for the $L$-Grundy domination number...|$|R
50|$|To convert {{between the}} {{representations}} involving the two <b>types</b> of <b>parameter,</b> use the formulas below for writing one <b>type</b> of <b>parameter</b> {{in terms of}} the other.|$|R
3000|$|... [...]. The {{objective}} function {{is the total}} coverage defined in (1). The computation of (1) {{is based on the}} orientations, locations, and the <b>type</b> <b>parameters</b> ([...] [...]...|$|R
5000|$|The [...] and [...] {{classes are}} subclasses of the [...] class. The [...] class accepts the <b>type</b> <b>parameter</b> [...] that {{specifies}} {{the type of}} the object reference. (See [...] "Generics in Java" [...] for a description of type parameters in Java).|$|E
50|$|For optional/variable-length {{parameter}}s, the parameter <b>type,</b> <b>parameter</b> length, and {{parameter value}} fields all behave just like their chunk counterparts.The minimum size of parameter is 4 bytes and this {{occurs when the}} parameter value field is empty and the parameter consists only of the type & length fields.|$|E
50|$|The <b>type</b> <b>parameter</b> {{must be a}} {{data type}} to which object can be {{converted}} via a known method, {{whether it be a}} builtin or a cast. The type can be a reference or an enumerator.All types of conversions that are well-defined and allowed by the compiler are performed using static_cast.|$|E
40|$|Symmetric {{multiple}} dispatch, generic functions, and variant <b>type</b> <b>parameters</b> {{are powerful}} language features {{that have been}} shown to aid in modular and extensible library design. However, when symmetric dispatch is applied to generic functions, <b>type</b> <b>parameters</b> may have to be instantiated as a part of dispatch. Adding variant generics increases the complexity of type instantiation, potentially making it prohibitively expensive. We present a syntactic restriction on generic functions and an algorithm designed and implemented for the Fortress programming language that simplifies the computation required at runtime when these features are combined. 1...|$|R
5000|$|The {{rules for}} scalar numeric {{expressions}} and assignments accommodate the non-default kinds. Thus, the mixed-mode numeric expression and assignment rules incorporate different kind <b>type</b> <b>parameters</b> in an expected way: ...|$|R
5000|$|Functional {{dependencies}} {{are another}} type system feature that have similar uses to associated types. While an associated type adds a named type function mapping the enclosing <b>type</b> class's <b>parameters</b> to another <b>type,</b> a functional dependency lists the result <b>type</b> as another <b>parameter</b> of the <b>type</b> class and adds a constraint between the <b>type</b> <b>parameters</b> (e.g. [...] "parameter a uniquely determines parameter b", written [...] ). The most common uses of functional dependencies {{can be directly}} converted to associated types and vice versa.|$|R
50|$|A bounded {{wildcard}} is {{one with}} either an upper or a lower inheritance constraint. The bounds {{can be both}} class and interface types. Upper bounds are expressed using the extends keyword and lower bounds using the super keyword. An upper bound on a wildcard must be a subtype of the upper bound on the <b>type</b> <b>parameter</b> it is assigned.|$|E
5000|$|In his framework, subsort {{declarations}} are propagated {{to complex}} type expressions.As a programming example, a parametric sort [...] may be declared (with [...] being a <b>type</b> <b>parameter</b> as in a C++ template), {{and from a}} subsort declaration [...] the relation [...] is automatically inferred, meaning that each list of integers is also a list of floats.|$|E
5000|$|The {{capitalisation}} varies {{according to}} programming language and programmer preference. , , , , and [...] are all possible. Alternate labels are also used, especially in complex templates where more than one <b>type</b> <b>parameter</b> is necessary. , , , , , [...] are typical alternate labels. Many programming languages are case-sensitive, making a consistent choice of labels important. The CamelCase [...] {{is one of the}} most commonly used.|$|E
5000|$|Data {{manipulation}} enhancements: allocatable components (incorporating TR 15581), deferred <b>type</b> <b>parameters,</b> [...] attribute, explicit type specification {{in array}} constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures ...|$|R
50|$|On Feb 22, 2017, Vaadin 8 was released. Biggest {{enhancement}} is re-written {{data binding}} API utilizing modern Java features, such as <b>type</b> <b>parameters</b> and lambda expressions. Also, more efficient memory and CPU.|$|R
5000|$|It {{supports}} [...] "virtual types": <b>type</b> <b>parameters</b> {{of classes}} and packages (families of related classes). As a consequence, undermining of strong type checks by [...] "type casts" [...] {{is no longer}} required.|$|R
