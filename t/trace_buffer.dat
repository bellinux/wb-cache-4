39|46|Public
5000|$|The debug {{interface}} is SWD {{with four}} breakpoints, two watchpoints, 1 KB Micro <b>Trace</b> <b>Buffer</b> (MTB). JTAG debugging is not supported.|$|E
50|$|The Cortex-M0+ is an {{optimized}} superset of the Cortex-M0. The Cortex-M0+ has {{complete instruction}} set compatibility with the Cortex-M0 thus allowing {{the use of}} the same compiler and debug tools. The Cortex-M0+ pipeline was reduced from 3 to 2 stages, which lowers the power usage. In addition to debug features in the existing Cortex-M0, a silicon option can be added to the Cortex-M0+ called the Micro <b>Trace</b> <b>Buffer</b> (MTB) which provides a simple instruction <b>trace</b> <b>buffer.</b> The Cortex-M0+ also received Cortex-M3 and Cortex-M4 features, which can be added as silicon options, such as the memory protection unit (MPU) and the vector table relocation.|$|E
5000|$|The OMAP2420, which {{includes}} a boundary scan TAP, the ARM1136 Debug TAP, an ETB11 <b>trace</b> <b>buffer</b> TAP, a C55x DSP, and a TAP for an ARM7 TDMI-based imaging engine, with the boundary scan TAP ("ICEpick-B") having the ability to splice TAPs {{into and out of}} the JTAG scan chain.|$|E
40|$|Abstract—In {{multi-core}} designs, distributed embedded logic an-alyzers {{with multiple}} trigger units and <b>trace</b> <b>buffers</b> with real-time offload capability through high-speed trace ports {{can be placed}} on-chip. This brings new challenges on how to connect the debug units together in such way that the limited storage space in the <b>trace</b> <b>buffers</b> can be used efficiently. This problem is further ag-gravated when shadow registers are used to capture data for some signals in the design. In this paper, we propose a new architecture that can dynamically allocate the <b>trace</b> <b>buffers</b> at runtime based on the needs for debug data acquisition coming from multiple data sources and user-programmable priorities. Experimental results show that using the proposed architecture, real-time observability can be improved using {{only a small amount}} of on-chip logic hard-ware, while avoiding excessive storage on-chip. Index Terms—Design-for-debug, distributed embedded logic analysis, post-silicon validation, real-time observability. I...|$|R
40|$|The {{level of}} {{intrusion}} of this monitoring system {{depends upon the}} overhead of gathering the data associated with each event {{and the amount of}} data. An intrusive system will increase drastically the execution time of the parallel program and will alter the behavior of the parallel programs we want to observe. We describe a monitoring system based on software probes inserted into a parallel program. In our system as in many other cases, a significant level of intrusion is caused by the act of storing the <b>trace</b> <b>buffers</b> on some external device, because (a) the limited I/O bandwidth of parallel systems, (b) the high latency of I/O operations, and (c) the contention for I/O devices and the interconnects. Several choices to reduce the level of the intrusion, by selecting the size for the <b>trace</b> <b>buffers,</b> by choosing the mechanism for transporting the <b>trace</b> <b>buffers</b> to the I/O devices are discussed in this paper. Contents 1 Statement of the Problem 1 2 The Trace System 1 3 The Environment 2 4 [...] ...|$|R
50|$|Tentative tracing is {{a concept}} that allows the trace output of a block of code to be labeled as tentative. The output of this code can later be {{committed}} to the <b>trace</b> <b>buffers</b> as visible output or it can be discarded. This works conceptually much like transaction controls in SQL.|$|R
5000|$|... Embedded Trace Module (ETM), 40 bits (7 bit address, one 32-bit long data word, and a R/W bit) used {{to control}} the {{operation}} of a passive instruction and data trace mechanism. This feeds either an on-chip Embedded <b>Trace</b> <b>Buffer</b> (ETB), or an external high speed trace data collection pod. Tracing supports passive debugging (examining execution history) and profiling for performance tuning.|$|E
5000|$|... {{adapters}} {{with full}} speed USB links {{are probably the}} most common approach, and new products often include high speed USB support. Higher end products often support Ethernet, with the advantage that the debug host can be quite remote. Adapters which support high speed trace ports generally include several megabytes of <b>trace</b> <b>buffer</b> and provide high speed links (USB or Ethernet) to get that data to the host.|$|E
50|$|Probes {{are added}} {{directly}} to the RTL design to make specific signals available for observation. When the system is run, the RTL-based probe connected {{to each of the}} instrumented signals collects the signal’s value at each clock cycle. The data is stored in a <b>trace</b> <b>buffer</b> in FPGA block RAM. An analyzer connected to the prototype downloads the information giving the user offline visibility into the system for efficient debug.|$|E
5000|$|The {{following}} {{is an example of}} a probe that is defined for whenever a process with a PID of 123456 enters the read (...) system call. When that event happens this script will call the built-in printf (...) function to print a message to its output <b>trace</b> <b>buffers.</b> The first line in the action block is a C-style comment and therefore will not execute in the ProbeVue environment.|$|R
40|$|Abstract—Silicon debug poses {{a unique}} {{challenge}} to the en-gineer because of the limited access to internal signals of the chip. Embedded hardware such as <b>trace</b> <b>buffers</b> helps overcome this challenge by acquiring data in real time. However, <b>trace</b> <b>buffers</b> only provide access to a limited subset of pre-selected signals. In order to effectively debug, {{it is essential to}} configure the trace-buffer to trace the relevant signals selected from the pre-defined set. This can be a labor-intensive and time-consuming process. This paper introduces a set of techniques to automate the configuring process for trace buffer-based hardware. First, the proposed approach utilizes UNSAT cores to identify signals that can provide valuable information for localizing the error. Next, it finds alternatives for signals not part of the traceable set so that it can imply the corresponding values. Integrating the proposed techniques with a debugging methodology, experiments show that the methodology can reduce 30 % of potential suspects with as low as 8 % of registers traced, demonstrating the effectiveness of the proposed procedures. Index Terms—Silicon debug, post-silicon diagnosis, data acqui-sition setup I...|$|R
40|$|Post-silicon {{validation}} is used {{to identify}} design errors in silicon. Its main limitation is real-time observability of the circuit’s internal nodes. In this paper, we introduce a novel design-for-debug architecture which automatically allocates distributed <b>trace</b> <b>buffers</b> to handle debug data ac-quisition requests from multiple sources located in differ-ent cores. Using resource-efficient and intelligent control placed on-chip, we show how real-time observability can be improved, thus helping {{bridge the gap between}} pre-silicon verification and post-silicon validation for SOC designs. 1...|$|R
40|$|Trace buffers are {{commonly}} used to capture data during in-system silicon debug. This paper exploits {{the fact that it}} is not necessary to capture error-free data in the <b>trace</b> <b>buffer</b> since that information is obtainable from simulation. The <b>trace</b> <b>buffer</b> need only capture data during clock cycles in which errors are present. A three pass methodology is proposed. During the first pass, the rough error rate is measured, in the second pass, a set of suspect clock cycles where errors may be present is determined, and then in the third pass, the <b>trace</b> <b>buffer</b> captures only during the suspect clock cycles. In this manner, the effective observation window of the <b>trace</b> <b>buffer</b> can be expanded significantly, by up to orders of magnitude. This greatly increases the effectiveness of a given size <b>trace</b> <b>buffer</b> and can rapidly speed up the debug process. The suspect clock cycles are determined through a two dimensional (2 -D) compaction technique using a combination of multiple-input signature register (MISR) signatures and cycling register signatures. By intersecting the signatures, the proposed 2 -D compaction technique generates a small set of remaining suspect clock cycles for which the <b>trace</b> <b>buffer</b> needs to capture data. Experimental results indicate very significant increases in the effective observation window for a <b>trace</b> <b>buffer</b> can be obtained. 1...|$|E
40|$|Abstract—This paper {{presents}} a novel technique for extending {{the capacity of}} trace buffers when capturing debug data during post-silicon debug. It exploits the fact that is it not necessary to capture error-free data in the <b>trace</b> <b>buffer</b> since that information {{can be obtained from}} simulation. A selective data capture method is proposed in this paper that only captures debug data during clock cycles in which errors are present. The proposed debug method requires only three debug sessions. The first session estimates a rough error rate, the second session identifies a set of suspect clock cycles where errors may be present, and the third session captures the suspect clock cycles in the <b>trace</b> <b>buffer.</b> The suspect clock cycles are determined through a 2 -D compaction technique using multiple-input signature register signatures and cycling register signatures. Intersecting both signatures generates a small number of suspect clock cycles for which the <b>trace</b> <b>buffer</b> needs to capture. The effective observation window of the <b>trace</b> <b>buffer</b> can be expanded significantly, by up to orders of magnitude. Experimental results indicate very significant increases in the effective observation window for a <b>trace</b> <b>buffer</b> can be obtained. Index Terms— 2 -D compaction, observation window, post-silicon debug, selective data capture, <b>trace</b> <b>buffer.</b> I...|$|E
30|$|Intel PT records all {{control flow}} {{transfer}} instructions by default, which fill the <b>Trace</b> <b>Buffer</b> with {{large quantities of}} uninteresting packets to DTrace like conditional branch taken-not-taken. The irrelevant packets increase the burden of packet decoding {{and the number of}} interrupts for the <b>Trace</b> <b>Buffer</b> filling events.|$|E
40|$|Capturing {{program and}} data traces during program {{execution}} unobtrusively on-the-fly {{is crucial in}} debug-ging and testing of cyber-physical systems. However, tracing a complete program unobtrusively is often cost-prohibitive, requiring large on-chip <b>trace</b> <b>buffers</b> and wide <b>trace</b> ports. This article describes a new hardware-based load data value filtering technique called Cache First-access Tracking. Coupled with an effective variable encoding scheme, this technique achieves a significant reduction of load data value traces, from 5. 86 to 56. 39 times depending on the data cache size, thus enabling cost-effective, unobtrusive on-the-fly tracing and debugging...|$|R
40|$|VLIW {{processors}} are statically scheduled {{processors and}} their performance {{depends on the}} quality of schedules generated by the compiler's scheduler. We propose a multithreaded architectural support for speculative trace scheduling in VLIW processors. In this multithreaded architecture the next most probable trace is speculatively executed, overlapping the stall cycles of the processor during cache misses and page faults. Switching between traces is achieved with the help of special hardware units viz. Operation State <b>Buffers</b> and <b>Trace</b> <b>Buffers.</b> We observe an 8. 39 % reduction in the overall misprediction penalty as compared to that incurred when the stall cycles due to cache misses alone are not overlapped...|$|R
40|$|The {{capacity}} of on-chip <b>trace</b> <b>buffers</b> employed for embedded logic analysis limits the observation {{window of a}} debug ex-periment. To increase the debug observation window, we pro-pose a novel architecture for embedded logic analysis based on lossless compression. The proposed architecture is particu-larly useful for in-field debugging of custom circuits that have sources of nondeterministic behavior such as asynchronous interfaces. In order to measure the tradeoff between the area overhead {{and the increase in}} the observation window, we also introduce a new compression ratio metric. We use this metric to quantify the performance gain of three lossless compression algorithms suitable for embedded logic analysis. ...|$|R
30|$|Intel PT {{locates the}} <b>Trace</b> <b>Buffer</b> with Table of Physical Addresses (ToPA) structure. In Fig.  5, each ToPA entry {{points to a}} {{physical}} memory region with physically continuous pages. The last entry has a special bit named END set, indicating that it points to the first ToPA table entry rather than a buffer page. When the last physical page in the <b>Trace</b> <b>Buffer</b> is filled, Intel PT moves forward to the first physical page pointed to by the first ToPA entry and overwrites the first few packets in {{the head of the}} <b>Trace</b> <b>Buffer.</b>|$|E
30|$|As {{shown in}} the shaded area in Fig.  3, the <b>Trace</b> <b>Buffer</b> is {{allocated}} in kernel’s memory space. The Intel PT Driver and the Trace Analyzer work in kernel mode. Note that Intel PT writes the packets into the <b>Trace</b> <b>Buffer</b> without being restricted by virtual page permission (Step 5 b).|$|E
40|$|Abstract [...] Although event tracing of {{parallel}} applications offers highly detailed performance information, tracing on current leading edge systems {{may lead to}} unacceptable perturbation of the target program and unmanageably large trace files. High end systems of the near future promise even greater scalability challenges. In this work we identify and quantify the overheads of application tracing. We report results for two ASC Purple Benchmarks with different communication characteristics: SMG 2000, which exhibits an extremely high message rate, and SPhot, an embarrassingly parallel application with relatively little communication. We investigate several different sources of overhead related to tracing: instrumentation, differing <b>trace</b> <b>buffer</b> sizes, periodic buffer flushes to disk, system changes, and increasing numbers of processors in the target application. Our results show that tracing overhead is affected by differences in system software, {{as well as the}} choice of <b>trace</b> <b>buffer</b> size. As expected, the overhead of instrumentation correlates strongly with the number of events; however, our results indicate that the overhead of writing the <b>trace</b> <b>buffer</b> increases with increasing numbers of processors. 1...|$|E
40|$|Unobtrusive {{capturing}} {{of program}} execution traces in real-time {{is crucial in}} debugging cyber-physical systems. However, tracing even limited program segments is often cost-prohibitive, requiring wide trace ports and large on-chip <b>trace</b> <b>buffers.</b> This paper introduces a new cost-effective technique for capturing and compressing program execution traces in real time. It uses branch predictor-like structures in the trace module to losslessly compress the traces. This approach results in high compression ratios because it only has to transmit misprediction events to the software debugger. Coupled with an effective variable encoding scheme, our technique requires merely 0. 036 bits/instruction of trace port bandwidth (a 28 -fold improvement over the commercial state-of-the-art) {{at a cost of}} roughly 5, 200 logic gates...|$|R
40|$|One of {{the most}} {{challenging}} problems in post-silicon validation is to identify those errors that cause prohibitive extra delay on speedpaths in the circuit under debug (CUD) and only expose themselves in a certain electrical environment. To address this problem, we propose a trace-based silicon debug solution, which provides real-time visibility to the speedpaths in the CUD during normal operation. Since tracing all speedpath-related signals can cause prohibited design for debug (DfD) overhead, we present an automated trace signal selection methodology that maximizes error detection probability under a given constraint. In addition, we develop a novel trace qualification technique that reduces the storage requirement in <b>trace</b> <b>buffers.</b> The effectiveness of the proposed methodology is verified with large benchmark circuits. 1...|$|R
40|$|The {{introduction}} of complex SoCs with multiple processor cores presents new development challenges, such that development support {{is now a}} decisive factor when choosing a System-on-Chip (SoC). The presented developments support strategy addresses the challenges using both architecture and technology approaches. The Multi-Core Debug Support (MCDS) architecture provides flexible triggering using cross triggers and a multiple core break and suspend switch. Temporal trace ordering is guaranteed down to cycle level by on-chip time stamping. The Package Sized-ICE (PSI) approach is a novel method of including <b>trace</b> <b>buffers,</b> overlay memories, processing resources and communication interfaces without changing device behavior. PSI requires no external emulation box, as the debug host interfaces directly with the SoC using a standard interface. Comment: Submitted on behalf of EDAA ([URL]...|$|R
40|$|Abstract—The {{localisation}} of faults in {{integrated circuits}} is a challenging problem and a dominating factor in the overall verification effort. Electrical bugs, in particular, surface only in the fabricated prototypes, leading to behaviour deviating from the golden model. Limited observability complicates their localisation: Logging mechanisms such as trace buffers allow us to retain only a limited execution history. A symbolic analysis of the RTL design can find discrepancies between the values recorded in the <b>trace</b> <b>buffer</b> and the intended behaviour. Contemporary MAX-SAT solvers are then able to identify a maximal subset of the RTL design {{that is consistent with}} the observed behaviour. The elements in the complement of this subset represent potential locations of the fault. The scalability of contemporary decision procedures dictates the size of a window of execution cycles which we can analyse using symbolic techniques. Current MAX-SAT-based fault localisation techniques require this window to span the fault as well as the error it causes. To address the scalability issues resulting from large window sizes, we propose to slide a smaller window along the temporal axis, constraining it with the information recorded in the <b>trace</b> <b>buffer</b> for the respective execution cycles. In this scenario, the localisation attempt may fail: The limited information provided by the <b>trace</b> <b>buffer</b> may be insufficient to pin down the exact temporal and spatial location of the fault. We propose to use backbones to identify information that can be propagated across sliding windows. The backbone of a symbolic representation of a circuit is the set of signals that are immutable under the given constraints (e. g., the output and <b>trace</b> <b>buffer</b> values). This additional information has several benefits: Firstly, it may be instrumental in locating the fault. Secondly, it may enable a reduction {{of the size of the}} of trace buffers and the sliding window. Our preliminary experimental results demonstrate that the use of backbones allows us to reduce the size of the sliding windows or the <b>trace</b> <b>buffer.</b> I...|$|E
40|$|Concurrent trace is an {{emerging}} challenge when debug-ging multicore systems. In concurrent trace, <b>trace</b> <b>buffer</b> becomes a bottleneck since all trace sources try to access it simultaneously. In addition, the on-chip interconnection fab-ric is extremely high hardware {{cost for the}} distributed trace signals. In this paper, we propose a clustering-based scheme which implements concurrent trace for debugging Network-on-Chip (NoC) based multicore systems. In the proposed scheme, a unified communication framework eliminates the requirement for interconnection fabric which is only used during debugging. With clustering scheme, multiple concur-rent trace sources can access distributed <b>trace</b> <b>buffer</b> via NoC under bandwidth constraint. We evaluate the proposed scheme using Booksim and the results show {{the effectiveness of the}} proposed scheme. 1...|$|E
30|$|As {{configured}} by the Driver, Intel PT notifies the Driver via a Performance Monitoring Interrupt (PMI) {{when the}} <b>Trace</b> <b>Buffer</b> becomes overloaded (Step 6 a). The processor pauses the traced program execution and switches to the PMI handler. The PMI handler invokes the Trace Analyzer (Step 6 b).|$|E
40|$|Abstract—With {{the growing}} size of modern designs and more strict {{time-to-market}} constraints, design errors unavoidably escape pre-silicon verification and reside in silicon prototypes. As a result, silicon debug {{has become a}} necessary step in the digital integrated circuit design flow. Although embedded hardware blocks, such as scan chains and <b>trace</b> <b>buffers,</b> provide a means to acquire data of internal signals in real time for debugging, there is a relative shortage in methodologies to efficiently analyze this vast data to identify root-causes. This paper presents an automated software solution that attempts to fill-in the gap. The presented techniques automate the configuration process for trace-buffer based hardware in order to acquire helpful information for debugging the failure, and detect suspects of the failure in both the spatial and temporal domain. I...|$|R
40|$|Abstract — Unobtrusive {{capturing}} {{of program}} execution traces in real-time {{is crucial for}} debugging many embedded systems. However, tracing even limited program segments is often cost-prohibitive, requiring wide trace ports and large on-chip <b>trace</b> <b>buffers.</b> This paper introduces a new cost-effective technique for capturing and compressing program execution traces on-thefly. It relies on branch predictor-like structures in the trace module and corresponding software modules in the debugger to significantly {{reduce the number of}} events that need to be streamed out of the target system. Coupled with an effective variable encoding scheme that adapts to changing program patterns, our technique requires merely 0. 029 bits per instruction of trace port bandwidth, providing a 34 -fold improvement over the commercial state-of-the-art and a five-fold improvement over academic proposals, at the low cost of under 5, 000 logic gates...|$|R
50|$|Buffers {{can be used}} {{to isolate}} {{capacitance}} on one segment from another and/or allow I²C to be sent over longer cables or <b>traces.</b> <b>Buffers</b> for bi-directional lines such as I²C must use one of several schemes for preventing latch-up. I²C is open-drain, so buffers must drive a low on one side when they see a low on the other. One method for preventing latch-up is for a buffer to have carefully selected input and output levels such that the output level of its driver is higher than its input threshold, preventing it from triggering itself. For example, a buffer may have an input threshold of 0.4 V for detecting a low, but an output low level of 0.5 V. This method requires that all other devices on the bus have thresholds which are compatible and often means that multiple buffers implementing this scheme cannot be put in series with one another.|$|R
40|$|Abstract — The main {{challenge}} in post-silicon debug {{is the lack}} of observability to the internal signals of a chip. <b>Trace</b> <b>buffer</b> technology provides one venue to address this challenge by online tracing of a few selected state elements. Due to the limited bandwidth of the <b>trace</b> <b>buffer,</b> only a few state elements can be selected for tracing. Recent research has focused on automated trace signal selection problem in order to maximize restoration of the untraced state elements using the few traced signals. Existing techniques can be categorized into high quality but slow “simulation-based”, and lower quality but much faster “metric-based” techniques. This work presents a new trace signal selection technique which has comparable or better quality than simulation-based while it has a fast runtime, comparable to the metric-based techniques. I...|$|E
30|$|The Intel PT {{driver and}} Trace Analyzer are {{implemented}} as a kernel module for Linux 4.9 without any kernel modification. The kernel module registers a non-maskable interrupt handler to receive PMI when the <b>Trace</b> <b>Buffer</b> is full. The prototype is evaluated on a machine with Intel Core i 7 - 7700 running at 3.6 GHz and 16 GB memory.|$|E
40|$|Abstract. Although event tracing of {{parallel}} applications offers highly detailed performance information, tracing on current leading edge systems {{may lead to}} unacceptable perturbation of the target program and unmanageably large trace files. High end systems of the near future promise even greater scalability challenges. Development of more scalable approaches requires a detailed understanding of the interactions between current approaches and high end runtime environments. In this paper we present the results of studies that examine several sources of overhead related to tracing: instrumentation, differing <b>trace</b> <b>buffer</b> sizes, periodic buffer flushes to disk, system changes, and increasing numbers of processors in the target application. As expected, the overhead of instrumentation correlates strongly {{with the number of}} events; however, our results indicate that the contribution of writing the <b>trace</b> <b>buffer</b> increases with increasing numbers of processors. We include evidence that the total overhead of tracing is sensitive to the underlying file system. ...|$|E
40|$|Capturing {{program and}} data traces during program {{execution}} unobtrusively in real-time {{is crucial in}} debugging and testing of cyber-physical systems. However, tracing a complete program unobtrusively is often cost-prohibitive, requiring large on-chip <b>trace</b> <b>buffers</b> and wide <b>trace</b> ports. Whereas program execution traces can be efficiently compressed in hardware, compression of data address and data value traces is much more challenging due to limited redundancy. In this paper we describe two hardwarebased filtering techniques for data traces: cache first-access tracking for load data values and data address filtering using partial register-file replay. The results of our experimental analysis indicate that the proposed filtering techniques can significantly {{reduce the size of}} the data traces (~ 5 - 20 times for the load data value trace, depending on the data cache size; and ~ 5 times for the data address trace) at the cost of rather small hardware structures in the trace module...|$|R
40|$|Abstract—Unobtrusive {{capturing}} {{of program}} execution traces in real-time {{is crucial for}} debugging many embedded systems. However, tracing even limited program segments is often cost-prohibitive, requiring wide trace ports and large on-chip <b>trace</b> <b>buffers.</b> This paper introduces a new cost-effective technique for capturing and compressing program execution traces on-the-fly. It relies on branch predictor-like structures in the trace module and corresponding software modules in the debugger to significantly {{reduce the number of}} events that need to be streamed out of the target system. Coupled with an effective variable encoding scheme that adapts to changing program patterns, our technique requires merely 0. 029 bits per instruction of trace port bandwidth, providing a 34 -fold improvement over the commercial state-of-the-art and a five-fold improvement over academic proposals, at the low cost of under 5, 000 logic gates. Index Terms—Compression technologies, real time and embedded systems, testing and debugging, tracing Ç...|$|R
40|$|The {{increasing}} device {{count and}} design complexity are posing significant challenges to post-silicon validation. Bug diagnosis {{is the most}} difficult step during post-silicon validation. Limited reproducibility and low testing speeds are common limitations in current testing techniques. Moreover, low observability defies full-speed testing approaches. Modern solutions like on-chip <b>trace</b> <b>buffers</b> alleviate these issues, but are unable to store long activity traces. As a consequence, the cost of post-Si validation now represents a large fraction of the total design cost. This work describes a hybrid post-Si approach to validate a modern load-store queue. We use an effective error detection mechanism and an expandable logging mechanism to observe the microarchitectural activity for long periods of time, at processor full-speed. Validation is performed by analyzing the log activity by means of a diagnosis algorithm. Correct memory ordering is checked to root the cause of errors. Peer ReviewedPostprint (published version...|$|R
