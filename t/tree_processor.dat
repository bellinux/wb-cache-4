6|46|Public
40|$|In this study, a whole-tree {{harvesting}} {{system designed to}} produce logs and chips was evaluated on four sites, each with a different silvicultural prescription. The system consisted of: feller-bunchers, grapple-equipped rubber-tired skidders, a <b>tree</b> <b>processor,</b> a whole-tree chipper, and a hydraulic log loader. Production rates for the overall system and for its various components were developed with time-motion study techniques. Variation in productivity between study areas was analyzed with respect to stand and site characteristics...|$|E
40|$|Two related image {{processing}} problems are {{addressed in this}} thesis. First, the problem of identification of 3 -D objects in real time is explored. An algorithm {{to solve this problem}} and a hardware system for parallel implementation of this algorithm are proposed. The classification scheme is based on the 2 ̆ 2 Invariant Numerical Shape Modeling 2 ̆ 2 (INSM) algorithm originally developed for 2 -D pattern recognition such as alphanumeric characters. This algorithm is then extended to 3 -D and is used for general 3 -D object identification. The hardware system is an SIMD parallel processor, designed in bit slice fashion for expandability. It consists of a library of images coded according to the 3 -D INSM algorithm and the SIMD classifier which compares the code of the unknown image to the library codes in a single clock pulse to establish its identity. The output of this system consists of three signals: U, for unique identification; M, for multiple identification; and N, for non-identification of the object. Second, the problem of real time image compaction is addressed. The quad tree data structure is described. Based on this structure, a parallel processor with a tree architecture is developed which is independent of the data entry process, i. e., data may be entered pixel by pixel or all at once. The hardware consists of a <b>tree</b> <b>processor</b> containing a tree generator and three separate memory arrays, a data transfer processor, and a main memory unit. The tree generator generates the quad tree of the input image in tabular form, using the memory arrays in the <b>tree</b> <b>processor</b> for storage of the table. This table can hold one picture frame at a given time. Hence, for processing multiple picture frames the data transfer processor is used to transfer their respective quad trees from the <b>tree</b> <b>processor</b> memory to the main memory. An algorithm is developed to facilitate the determination of the connections in the circuit...|$|E
40|$|A {{parameterized}} {{version of}} the <b>tree</b> <b>processor</b> has been designed and tested (by simulation). The leaf processor design is 90 % complete. We expect to complete and test a combination of tree and leaf cell design in the next period. Work has been proceeding on algorithms for the CAM, and once the design is complete we will begin simulating algorithms for large problems. In the last 6 months we have produced four publications that describe various components of our research. They are summarized below...|$|E
5000|$|Raymond's {{algorithm}} {{is guaranteed to}} be O(log n) per critical section entry if the processors are organized into a K-ary <b>tree.</b> Additionally, each <b>processor</b> needs to store at most O(log n) bits because it must track O(1) neighbors.123 ...|$|R
40|$|We {{describe}} a parallel design principle for hash functions. Given a secure hash function with n 2 m, and a binary <b>tree</b> of 2 <b>processors</b> we show how to construct which can hash messages of lengths less than 2 and a secure hash function h which can hash messages of arbitrary length. The number of parallel rounds required to hash {{a message of}} length L is b t c + t + 2. Further, our algorithm is incrementally parallelizable in the following sense: given a digest produced using a binary <b>tree</b> of 2 <b>processors,</b> we show that the same digest can also be produced using a binary tree of 2 (0 t t) processors...|$|R
40|$|A new, {{parallel}} {{approach for}} generating Bresenham-type lines is developed. Coordinate pairs which approximate straight lines on a square grid {{are derived from}} line equations. These pairs serve {{as a basis for}} the development of four new parallel algorithms. One of the algorithms uses the fact that straight line generation is equivalent to a vector prefix sums calculation. The algorithms execute on a binary <b>tree</b> of <b>processors.</b> Each node in the tree performs a simple calculation that involves only additions and shifts. All four algorithms have time complexity O(log 2 n) where n in the form 2 m denotes the number of points generated and n Γ 1 is the number of <b>processors</b> in the <b>tree.</b> This compares to O(n) for Bresenham's algorithm executed on a sequential processor. Pipelining can be used to achieve a constant time per line generation as long as line length is less than n. Keywords: line generation, parallel algorithms, binary <b>processor</b> <b>tree,</b> middle cut algorithm, prefix sums, binar [...] ...|$|R
40|$|In this paper, we {{proposed}} a flexible VLSI-based parallel processing architecture for an improved three-step search (ITSS) motion estimation algorithm that is superior to the existing three-step search (TSS) algorithm in all cases and also to the recently proposed new three-step search (NTSS) algorithm if used for low bit-rate video coding, as with the H. 261 standard. Based on a VLSI <b>tree</b> <b>processor</b> and an FPGA addressing circuit, the architecture can successfully implement the ITSS algorithm on silicon with the minimum number of gates. Because of {{the flexibility of the}} architecture, it can also be extended to implement other three-step search algorithms...|$|E
40|$|The {{original}} publication {{is available}} at www. springerlink. com??? Copyright Springer [Full text {{of this article is}} not available in the UHRA]In this paper, we design a flexible VLSI-based parallel processing system for an improved three-step search (ITSS) motion estimation algorithm that is superior to the existing three-step search (TSS) algorithm in all cases and also to the recently proposed new three-step search (NTSS) algorithm if used for low bit-rate video coding, as with the H. 261 standard. Based on a VLSI <b>tree</b> <b>processor</b> and an FPGA addressing circuit, the proposed architecture can successfully implement the ITSS algorithm on silicon with the minimum number of gates. Because of the flexibility of the architecture, it can also be extended to implement other three-step search algorithms...|$|E
40|$|The {{problem of}} tree pattern {{matching}} for object recognition in images is computationally intensive in nature. In two-dimensional images, the objects {{can be represented}} through multiscale decomposition as tree structures. The pattern tree representing an object can be matched with a subject tree representing an image in order to detect the objects within the image. In this paper, we describe a new systolic algorithm and its realization as a VLSI chip for tree pattern matching. The hardware algorithm {{is based on a}} linear array of processing elements (PEs) where the pattern matching is done in a pipelined fashion relying on nearestneighbor communication between the PE’s and the subject and pattern trees of arbitrary length can be processed using a fixed size PE array. The algorithm has an improved execution time of O(⎡m/a⎤n) required to perform the matching where m, a and n are the sizes of the pattern <b>tree,</b> <b>processor</b> array, subject tree respectively. A prototype CMOS VLSI chip implementing the proposed algorithm has been designed and verified. It is shown that the hardware algorithm proposed in this work represent a significant improvement in terms of computational complexity, data flow, and architecture over the ones previously proposed for this problem. 1...|$|E
30|$|A hierarchic {{transformation}} {{is an important}} and powerful computing operation. This motivates the studies of parallel approaches, such as graphical processing units, or low level complexity algorithms, such as the adaptive resonance theory (ART). Though ART was realized with graphic processing units (GPUs), {{there are a few}} hierarchical applications of GPU ART. Every ART layer is propagating in the GPU while being trained at the same time. Experimental results show that for deep <b>trees,</b> graphic <b>processors</b> should be used due to the significant advantage of GPUs.|$|R
40|$|The {{problem of}} optimally distributing a {{divisible}} load to the nodes of an arbitrary <b>processor</b> <b>tree</b> is tackled in this paper. The rigorous mathematical foundation presented allows the derivation {{of the sequence}} of operations {{that is necessary to}} obtain the minimum processing time, along with closed-form expressions that yield the solution in time O(NP), where P is the number of tree nodes and N their maximum degree. The main contributions of this work are: (1) both load distribution and result collection overheads are considered, thus providing better resource utilization, and (2) arbitrary <b>processor</b> <b>trees</b> are examined in contrast with previous approaches that examined either complete homogeneous trees, or single level trees. Additionally, approximate algorithms for solving the problem of specifying the optimum subset of active processors for a given load, are presented and evaluated. © 1998 IEEE...|$|R
40|$|This {{paper is}} devoted to the study of tree-scheduling {{problems}} within the execution model described by Anderson, Beame and Ruzzo [3]. We first prove the NP-completeness of the problem of minimizing the overhead for scheduling <b>trees</b> on m <b>processors,</b> and then we propose an algorithm that provides optimal schedules when complete trees are considered...|$|R
40|$|The VLSI {{design and}} {{implementation}} of a Tree Searched Vector Quantizer is presented. The number of processors needed {{is equal to the}} depth of the <b>tree.</b> All <b>processors</b> are identical and data flow between processors is regular. No global control signals are needed. The processors have been fabricated using MOSIS' 2 mm N- well process on a 7. 9 mm x 9. 2 mm die. Each processor chip contains 25, 000 transistors and has 84 pins. The processors have been thoroughly tested at a clock frequency of 10 MHz. These processors will be used in an adaptive image compression system to compress LANDSAT images...|$|R
5000|$|Sakari Pinomäki's first company, PIKA Forest Machines, is {{credited}} with designing the first self-propelled <b>tree</b> length timber <b>processor,</b> the PIKA Model 60, in 1968, and the first fully mobile timber [...] "harvester", the PIKA Model 75, in 1974. These machines differed significantly from other [...] "retro-fitted" [...] forestry machines in that they were designed from inception to be timber harvesting and processing equipment, and were not conventional farming or earth moving equipment with additional apparatus welded onto them to allow timber processing work to be possible. Pinomäki coined the term [...] "harvester" [...] to describe his Model 75 machine, which differs from a <b>tree</b> length <b>processor</b> in that a harvester grips, fells, de-limbs and sections the tree on site, while a processor simply de-limbs a tree that has been felled by chain saws and dragged to the delimbing equipment. His designs and innovations have been subsequently copied by at least five other major manufacturers of heavy timber equipment, including Timberjack, Valmet and Ponsse, and were instrumental in developing the [...] "Scandinavian" [...] system of timber harvesting, which is far more sustainable and nature conserving than the methods employed up till the mid-20th century. The two machine harvester-forwarder system consequently became the worldwide standard for sustainable forestry.|$|R
40|$|In this paper, {{we propose}} a prefix code {{matching}} parallel load-balancing method (PCMPLB) to efficiently {{deal with the}} load unbalancing problems of solution-adaptive finite element application programs on distributed memory multicomputers. The main idea of the PCMPLB method is first to construct a prefix code <b>tree</b> for <b>processors.</b> Based on the prefix code tree, a schedule for performing load transfer among processors can be determined by concurrently and recursively dividing the tree into two subtrees and finding a maximum matching for processors in the two subtrees until {{the leaves of the}} prefix code tree are reached. The experimental results show that the execution time of an application program under the PCMPLB method is less than that of the direct diffusion method and the multilevel diffusion method. 1...|$|R
40|$|A {{scalable}} parallel plane-wave time-domain (PWTD) algorithm for {{efficient and}} accurate analysis of transient scattering from electrically large objects is presented. The algorithm produces scalable communication patterns on very {{large numbers of}} processors by leveraging two mechanisms: (i) a hierarchical parallelization strategy to evenly distribute the computation and memory loads {{at all levels of}} the PWTD <b>tree</b> among <b>processors,</b> and (ii) a novel asynchronous communication scheme to reduce the cost and memory requirement of the communications between the processors. The efficiency and accuracy of the algorithm are demonstrated through its applications to the analysis of transient scattering from a perfect electrically conducting (PEC) sphere with a diameter of 70 wavelengths and a PEC square plate with a dimension of 160 wavelengths. Furthermore, the proposed algorithm is used to analyze transient fields scattered from realistic airplane and helicopter models under high frequency excitation...|$|R
40|$|Applications {{typically}} have several {{potential sources of}} parallelism, and in choosing a particular parallelization, the programmer must balance the benefits of each source of parallelism with the corresponding overhead. The trade-offs are often difficult to analyze, as they may depend on the hardware architecture, software environment, input data, and properties of the algorithm. An example of this dilemma occurs {{in a wide range}} of problems that involve processing <b>trees,</b> wherein <b>processors</b> can be assigned either to separate subtrees, or to parallelizing the work performed on individual tree nodes. We explore the complexity of the trade-offs involved in this decision by considering alternative parallelizations of combinatorial search, examining the factors that deter-mine the best-performing implementation for this important class of problems. Using subgraph isomorphism as a representative search problem, we show how the density of the solution space, th...|$|R
40|$|Nowadays, it is {{possible}} to find out different viable architectures that implements P Systems in a distributed cluster of processors. These proposed architectures have reached a certain compromise between the massively parallelism character of the system and the evolution step times. They are based in the distribution of several membranes in each processor, the use of proxies to control the communication between membranes and mainly, the suitable distribution of the architecture in a balanced <b>tree</b> of <b>processors.</b> For a given P-system and K processors, there exists a great volume of possible distributions of membranes over these. The main disadvantage related with these architectures is focused in the selection of the distribution of membranes that minimizes the external communications between them and maximizes the parallelism grade. In this paper, we suggest the use of Self-Organizing Neural Networks (SONN) with growing capability to help in this selection process for a given P-system...|$|R
40|$|Let G(V, E, w) be an undirected, weighted, {{connected}} simple graph. Let P be a minimization {{problem in}} G. Edge e ∗ ∈ E {{is called the}} most vital edge if its removal from G maximizes the value of P in G(V, E − {e ∗}, w). This paper considers the most vital edge {{with respect to the}} minimum spanning tree problem and the single-source shortest path problem. An O(n) optimal algorithm for finding the most vital edge with respect to these two problems is presented on an n × n mesh. The algorithm is simulated on an n × n × n hypercube array, and an O(log 2 n) time algorithm is then obtained, which is faster than a previously known result on the same model. Key Words Minimum spanning <b>tree,</b> mesh-connected <b>processor</b> array, hypercube-connected processor array, shortest path, network optimization, most vital edge, parallel algorithms 1...|$|R
40|$|The tree {{machine has}} been well defined as a {{concurrent}} computing system by Sally Browning & Carver Mead [1]. Many algorithms have been developed and shown to have better time-performance than conventional sequential algorithms. And since a tree machine is being built {{and is expected to}} become operational within a year, a real tree machine (not just a mathematical model or some pieces of hardware) is about to face the world. This report is treating the bridging between the mathematical model and the hardware machine to make the Tree Machine become real! In the following sections, I will describe the hardware structure of the <b>tree</b> machine <b>processors,</b> the software structure of the machine operating system, the detailed description of the assembler, the loader and the simulator. Some of the tree machine algorithms have been tested under this software system. Some performance evaluation is presented in the last section...|$|R
40|$|A new load-balancing {{strategy}} for the solution of dynamical large-treesearch problems using a hierarchical approach We describe a new load-balancing strategy, applied here to the protein structure prediction problem, for improving {{the efficiency of the}} hierarchical approach when dealing with coarse-grained problems associated with large tree searches. Unlike other load-balancing strategies that reassign load from the heavily loaded processors to the lightly loaded or idle ones, the proposed strategy changes the virtual communication <b>tree</b> among the <b>processors</b> as the computational tree changes. The strategy incurs minimal overhead and is scalable. 1...|$|R
40|$|An {{extension}} of the complete ringtrees {{to the case of}} arbitrary binary trees is presented. The extension provides a systematic way to construct a binary tree of any shape out of a linear array. The resulting graph may be useful as the basis for interconnecting processors such as transputers [2] in some specialized systems such as certain embedded systems, where the underlying computation to be performed demands the existence of both a binary tree and a linear array, yet due to some practical considerations, the use of the processors in the systems must be maximized. An general ringtree allows all processors to be fully used either as a binary <b>tree</b> connected <b>processors,</b> or a linear array connected processors depending on the needs of the computation. An efficient VLSI layout scheme for any complete ringtree is also presented. 886 1 Introduction It is well known that both linear array and binary tree are simple yet very useful interconnection topologies in parallel computing [...] ...|$|R
40|$|The {{operations}} of scattering and gathering {{in a network}} of processors involve one processor of the network (P 0) communicating with all other processors. In scattering, P 0 sends distinct messages to P 0. The authors consider networks that are <b>trees</b> of <b>processors.</b> Algorithms for scattering messages from and gathering messages to the processor that resides {{at the root of}} the tree are presented. The algorithms are quite general, in that the messages transmitted can differ arbitrarily in length; quite strong, in that they send messages along noncolliding paths, and hence do not require any buffering or queueing mechanisms in the processors; and quite efficient in that algorithms for scattering in general trees are optimal, the algorithm for gathering in a path is optimal and the algorithms for gathering in general trees are nearly optimal. The algorithms can easily be converted using spanning trees to efficient algorithms for scattering and gathering in networks of arbitrary topologie...|$|R
40|$|This paper {{introduces}} C++ programming abstractions {{for maintaining}} load-balanced partitions of irregular and adaptive trees. Such abstractions are useful across {{a range of}} applications and MIMD architectures. They free the user from low-level implementation details including interprocessor communication, data partitioning, and load balancing. We illustrate the use of these abstractions for gravitational N-body simulation. Our strategy for parallel N-body simulation is based on a technique for implicitly representing a global <b>tree</b> across multiple <b>processors.</b> This substantially reduces the programming complexity and the overhead for distributed memory architectures. We further reduce the overhead by maintaining incremental data structures...|$|R
40|$|For partitionable Mesh architectures, a {{modified}} QT (Quad <b>Tree)</b> -based <b>processor</b> allocation scheme (MQT) with two new task embedding heuristics is proposed. Existing processor allocation strategies assume any incoming request is also {{represented as a}} mesh. This paper introduces flexibility with which the requested task can be a linear array, a ring, or a mesh and still be allocated into a partitionable Mesh network architecture. In particular, two task embedding heuristics are proposed for embedding a requested k-PE task into an "m X k/m" mesh sub-system in O(k) time: 1) {{the first one is}} called the FS (First Size) task embedding heuristic, where m @ #rows of the first available sub-partition in the QT and 2) the BS (Best Size) task embedding heuristic, where embedded row = m @ k and embedded column = k/m such that m - k/m | is minimum. For task embedding, the time complexity of this modified QTbased processor allocation is only O(n) if n > k; otherwise it is O(k), where n is the number [...] ...|$|R
40|$|We present {{fast and}} {{accurate}} solutions of large-scale scattering problems formulated with the combined-field integral equation. Using the multilevel fast multipole algorithm (MLFMA) parallelized on {{a cluster of}} computers, we easily solve scattering problems that are discretized with {{tens of millions of}} unknowns. For the efficient parallelization of MLFMA, we propose a hierarchical partitioning scheme based on distributing the multilevel <b>tree</b> among the <b>processors</b> with an improved load-balancing. The accuracy of the solutions is demonstrated on scattering problems involving spheres of various radii from 80 λ to 110 λ. In addition to canonical problems, we also present the solution of real-life problems involving complicated targets with large dimensions. © 2007 IEEE...|$|R
40|$|International audienceThis paper {{presents}} {{two approaches}} in parallel modeling of vascular system development in internal organs. In the first approach, new parts of tissue are distributed among processors and each processor {{is responsible for}} perfusing its assigned parts of tissue to all vascular <b>trees.</b> Communication between <b>processors</b> is accomplished by passing messages, and therefore, this algorithm is perfectly suited for distributed memory architectures. The second approach is designed for shared memory machines. It parallelizes the perfusion process during which individual processing units perform calculations concerning different vascular trees. The experimental results, performed on a computing cluster and multicore machines, show that both algorithms provide a significant speedup...|$|R
40|$|Abstract—The paper {{presents}} {{two approaches}} in parallel modeling of vascular system development in internal organs. In the first approach, new parts of tissue are distributed among processors and each processor {{is responsible for}} perfusing its assigned parts of tissue to all vascular <b>trees.</b> Communication between <b>processors</b> is accomplished by passing messages and therefore this algorithm is perfectly suited for distributed memory architectures. The second approach is designed for shared memory machines. It parallelizes the perfusion process during which individual processing units perform calculations concerning different vascular trees. The experimental results, performed on a computing cluster and multi-core machines, show that both algorithms provide a significant speedup. Index Terms—computational modeling, vascular system, parallel com-puting, distributed memory algorithms, shared memory algorithms...|$|R
40|$|Abstract It {{is known}} that {{computations}} of anonymous networks {{can be reduced to}} the construction of a certain graph, the minimum base of the network. The crucial step of this construction is the inference of the minimum base from a finite <b>tree</b> that each <b>processor</b> can build (its truncated view). We isolate those trees that make this inference possible, and call them holographic. Intuitively, a tree is holographic if it is enough self-similar to be uniquely extendible to an infinite tree. This possibility depends on a size function for the class of graphs under examination, which we call a holographic bound for the class. Holographic bounds give immediately, for instance, bounds for the quiescence time of selfstabilizing protocols. In this paper we give weakly tight holographic bounds for some classes of graphs. ...|$|R
40|$|We {{present a}} {{design for a}} class of {{computers}} whose "instruction sets" are based on LISP. LISP, like traditional stored-program machine languages and unlike most high-level languages, conceptually stores programs and data {{in the same way}} and explicitly allows programs to be manipulated as data. LISP is therefore a suitable language around which to design a stored-program computer architecture. LISP differs from traditional machine languages in that the program/data storage is conceptually an unordered set of linked record structures of various sizes, rather than an ordered, indexable vector or integers or bit fields of fixed size. The record structures can be organized into trees or graphs. An instruction set can be designed for programs expressed as such <b>trees.</b> A <b>processor</b> can interpret these trees in a recursive fashion, and provide autoaatic storage management for the record structures. We concentrate here on the issues of memory management in such a computer, and the reasons why a layered design strategy is not only desirable and natural but even mandatory. A prototype VLSI LISP microprocessor has been designed and fabricated for testing. It is a small-scale version of the ideas presented here, containing a sufficiently complete instruction interpreter to execute small programs, and a rudimentary storage allocator. We intend to design and fabricate a full-scale VLSI version of this architecture in 1979...|$|R
40|$|Abstract. In this paper, {{we propose}} a prefix code {{matching}} parallel load-balancing method Ž PCMPLB. to efficiently {{deal with the}} load imbalance of solution-adaptive finite element application programs on distributed memory multicomputers. The main idea of the PCMPLB method is first to construct a prefix code <b>tree</b> for <b>processors.</b> Based on the prefix code tree, a schedule for performing load transfer among processors can be determined by concurrently and recursively dividing the tree into two subtrees and finding a maximum matching for processors in the two subtrees until {{the leaves of the}} prefix code tree are reached. We have implemented the PCMPLB method on an SP 2 parallel machine and compared its performance with two load-balancing methods, the directed diffusion method and the multilevel diffusion method, and five mapping methods, the AE�ORB method, the AE�MC method, the ML kP method, the PARTY library method, and the JOSTLE-MS method. An unstructured finite element graph Truss was used as a test sample. During the execution, Truss was refined five times. Three criteria, the execution time of mapping�load-balancing methods, the execution time of an application program under different mapping�load-balancing methods, and the speedups achieved by mapping� load-balancing methods for an application program, are used for the performance evaluation. The experimental results show that Ž. 1 if a mapping method is used for the initial partitioning and thi...|$|R
40|$|We {{present a}} binary tree based {{parallel}} algorithm for extending {{the domain of}} a UOWHF. The key length expansion is 2 m bits for t = 2; m(t+ 1) bits for 3 t 6 and m(t+blog 2 (t 1) c) bits for t 7, where m is {{the length of the}} message digest and t 2 is the height of the binary tree. The previously best known binary tree algorithm required a key length expansion of m 2 (t 1) bits. We also obtain the lower bound that any binary tree based algorithm must make a key length expansion of 2 m bits if t = 2 and a key length expansion of m (t + 1) bits for t 3. Hence for 2 t 6 our algorithm makes optimal key length expansion and for practical sized <b>processor</b> <b>trees</b> the key length expansion is close to the lower bound...|$|R
40|$|Many {{practical}} applications generate irregular, non-balanced divide-and-conquer trees which have different depths, possibly also different numbers of successors at different levels. Efcient parallelization is difcult as it requires dynamic partitioning and mapping of such <b>trees</b> to available <b>processors.</b> Irregular applications can ob-tain unpredictable intermediate results which then affect creation and termination of processes. The new proposed C++ framework called DAMPVM/DAC offers a combined scheme of dynamic process/data partitioning and migration which enables automatic parallelization of irregular divide-and-conquer applications {{taking into account}} processor speeds, network status, changing application requirements as well as external load introduced by other users. Ex-periments on a network of workstations include adaptive integration with and without process migration as well as static and dynamic codes for image recognition. The lat-ter ones enable to assess both the overhead of the dynamic scheme compared to serial implementations for regular ap-plications and scalability gains for non-uniform images...|$|R
40|$|Many {{algorithms}} {{in operations}} research and artificial intelligence {{are based on}} depth first search in implicitly defined trees. For parallelizing these algorithms, a load balancing scheme is needed which is able to evenly distribute parts of an irregularly shaped <b>tree</b> over the <b>processors.</b> It should work with minimal interprocessor communication and without prior knowledge of the tree's shape. Previously known load balancing algorithms either require sending a message for each tree node or they only work efficiently for large search trees. This paper introduces new randomized dynamic load balancing algorithms for tree structured computations, a generalization of backtrack search. These algorithms only need to communicate when necessary and have an asymptotically optimal scalability for many important cases. They work work on hypercubes, butterflies, meshes and many other architectures. 1 Introduction Load balancing {{is one of the}} central issues in parallel computing. Since for many appl [...] ...|$|R
40|$|Bayesian {{inference}} {{is widely}} used nowadays and relies largely on Markov chain Monte Carlo (MCMC) methods. Evolutionary biology has greatly benefited from the developments of MCMC methods, but the design of more complex and realistic models and the ever growing availability of novel data is pushing {{the limits of the}} current use of these methods. We present a parallel Metropolis-Hastings (M-H) framework built with a novel combination of enhancements aimed towards parameter-rich and complex models. We show on a parameter-rich macroevolutionary model increases of the sampling speed up to 35 times with 32 processors when compared to a sequential M-H process. More importantly, our framework achieves up to a twentyfold faster convergence to estimate the posterior probability of phylogenetic <b>trees</b> using 32 <b>processors</b> when compared to the well-known software MrBayes for Bayesian inference of phylogenetic trees. [URL] nicolas. salamin@unil. ch. Supplementary data are available at Bioinformatics online...|$|R
40|$|This paper {{describes}} {{the design and}} development of the Ames Interactive Dynamic Display Editor language (AIDDE). AIDDE and its associated tools are a software system that facilitates the interactive creation and use of real-time displays. For the present purposes, real-time displays are pictures on a CRT that change over time to reflect the state of a system. A graphics tree describes a display. Display dynamics are specified by attaching expressions to the tree. Offline, AIDDE is used to draw displays, define display dynamics, and generate host computer source code and a representation of the tree convenient for use in a graphics device. At run time, the compiled host code passes the results of the expressions to a graphics device to modify the <b>tree.</b> The graphics <b>processor</b> repeatedly traverses the tree to draw a changing display on the CRT. Several real-time displays have been implemented using AIDDE with good results...|$|R
