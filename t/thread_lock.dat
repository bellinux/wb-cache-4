4|212|Public
50|$|Zinc flake {{coatings}} {{are used}} as cathodic protective layers against corrosion {{all over the world}} in the automotive and construction industries. Combined with cured, thin, organic or inorganic coatings, these can also provide colour (black, silver, green, blue, etc.), chemical resistance, low electrical conductivity (due to the influence of the organic layer) and assembly properties. If required, re-lubrication or a <b>thread</b> <b>lock</b> (patch) is also possible.|$|E
30|$|The polymer ‘bung’ {{within the}} device is {{designed}} to reseal after being penetrated by a needle or <b>thread</b> <b>lock</b> cannula. As such, the ‘bung’ is capable of gripping the probe with considerable force, and this may obstruct the lumen if used to secure microdialysis or other catheters.|$|E
40|$|As thread level {{parallelism}} in applications {{has continued}} to expand, so has research in chip multi-core processors. Since more and more applications become multi-threaded we expect to find {{a growing number of}} threads executing on a machine. Consequently, the operating system will require increasingly larger amounts of CPU time to schedule these threads efficiently. Instead of perpetuating the trend of performing more complex thread scheduling in the operating system, we propose a two lightweight hardware thread scheduling mechanisms. First is a Hardware Round-Robin Scheduling (HRRS) policy which is influenced by Fairness Scheduling techniques thereby reducing thread serialization and improving parallel thread performance. Second is a <b>Thread</b> <b>Lock</b> Section-aware Scheduling (TLSS) policy which extends HRRS policy. TLSS policy is influenced by the Fairness-aware Scheduling and bottleneck identification techniques. It complements the HRRS scheduler by identifying multithreaded application bottlenecks such as thread synchronization sections. We show that HRRS outperforms Fairness scheduler by 17 percent while TLSS outperforms HRRS by 11 percent on an ACMP consisted of one large (out-of-order) core and three small (in-order) cores...|$|E
50|$|However, {{programs}} that use multithreading {{need to take}} extra care of objects shared between <b>threads,</b> <b>locking</b> access to shared methods or blocks when they are used {{by one of the}} <b>threads.</b> <b>Locking</b> a block or an object is a time-consuming operation {{due to the nature of}} the underlying operating system-level operation involved (see concurrency control and lock granularity).|$|R
30|$|Longer probes, such {{as those}} based on fibre optics, may be {{introduced}} as shown in Figure  3 either {{before or after the}} device is fitted to the skull. The modified injection site and <b>threaded</b> <b>lock</b> cannula are assembled and the probe passed through. The probe is advanced the required distance past the end of the luer tip and held in place with the fingers. The <b>threaded</b> <b>lock</b> cannula is unscrewed, and the probe is then held by the injection site bung. The <b>threaded</b> <b>lock</b> cannula remains floating on the probe throughout the study. At the end of the study, the cannula is again screwed onto the injection site to allow removal of the probe.|$|R
50|$|Prior to the Actor model, {{concurrency}} {{was defined}} in low-level machine terms of <b>threads,</b> <b>locks</b> and buffers(channels). It certainly {{is the case}} that implementations of the Actor model typically make use of these hardware capabilities. However, there is no reason that the model could not be implemented directly in hardware without exposing any hardware <b>threads</b> and <b>locks.</b> Also, there is no necessary relationship between the number of Actors, <b>threads,</b> and <b>locks</b> that might be involved in a computation. Implementations of the Actor model are free to make use of <b>threads</b> and <b>locks</b> in any way that is compatible with the laws for Actors.|$|R
40|$|Compared to the {{hydrostatic}} {{hydrodynamic model}}, the non-hydrostatic hydrodynamic model can accurately simulate flows that feature vertical accelerations. The model’s low computational efficiency severely restricts its wider application. This paper proposes a non-hydrostatic hydrodynamic model {{based on a}} multithreading parallel computing method. The horizontal momentum equation is obtained by integrating the Navier–Stokes equations from the bottom to the free surface. The vertical momentum equation is approximated by the Keller-box scheme. A two-step method is used to solve the model equations. A parallel strategy based on block decomposition computation is utilized. The original computational domain is subdivided into two subdomains that are physically connected via a virtual boundary technique. Two sub-threads are created and tasked with the computation of the two subdomains. The producer–consumer model and the <b>thread</b> <b>lock</b> technique are used to achieve synchronous communication between sub-threads. The validity of the model was verified by solitary wave propagation experiments over a flat bottom and slope, followed by two sinusoidal wave propagation experiments over submerged breakwater. The parallel computing method proposed here was found to effectively enhance computational efficiency and save 20 %– 40 % computation time compared to serial computing. The parallel acceleration rate and acceleration efficiency are approximately 1. 45 % and 72 %, respectively. The parallel computing method makes {{a contribution to the}} popularization of non-hydrostatic models...|$|E
5000|$|Since {{only the}} <b>thread</b> that <b>locked</b> the mutex is {{supposed}} to unlock it, a mutex may store the id of <b>thread</b> that <b>locked</b> it and verify the same thread unlocks it.|$|R
50|$|Model 1907 and 1905/1910 Match Target Rifle These very {{important}} single-shot rifles (two rifles {{are known to}} exist) are bearing special feature {{that would make the}} M1910 so different; the <b>threaded</b> <b>locking</b> lugs and receiver.|$|R
50|$|Because <b>thread</b> <b>locking</b> {{adhesives}} typically rely on {{the electrochemical}} activity of a metal substrate to form a bond, substrates often require thorough cleaning, {{and in the case}} of less electrochemically active metals such as aluminium, priming.|$|R
50|$|A Captive {{fastener}} {{is often}} made with <b>thread</b> <b>locking,</b> press-fitting, or broaching to accomplish an anchor-hold {{within a larger}} assembly housing. However, a captive fastener may also be melded with the material into which it is joined, either through cold forming or welding.|$|R
40|$|Presentation {{focusing}} on software synchronization, <b>thread</b> <b>locking,</b> transactional memory, and relativistic programming. Hash table algorithms {{are presented with}} examples of relativistic list insertion and removal, and related data structures. Existing approaches are compared to new methodologies and future work with relativistic data structures...|$|R
50|$|SCOOP {{defines a}} way for an object {{oriented}} program to be written without the concept of <b>threads,</b> <b>locks,</b> or other typical multiprogramming methods. This allows the compiler or runtime environment to optimize the amount of concurrency as well as eliminate typical design flaws such as deadlock.|$|R
5000|$|For {{real-time}} applications, {{a barrel}} processor can guarantee that a [...] "real-time" [...] thread can execute with precise timing, {{no matter what}} happens to the other threads, even if some other <b>thread</b> <b>locks</b> up in an infinite loop or is [...] continuously interrupted by hardware interrupts.|$|R
5000|$|Track {{sprocket}} - There is no {{mechanism that}} allows the rider to coast. There are two sets of threads on the hub shell. The threads are in opposite directions. The inner (clockwise) set of threads is for a track sprocket and the outer (counter-clockwise) set is for a reverse <b>threaded</b> <b>lock</b> ring. The reverse <b>threads</b> on the <b>lock</b> ring keep the sprocket from unscrewing from the hub, which is otherwise possible when slowing down.|$|R
40|$|Abstract. In this paper, we simplify a Parallel Asynchronous Cellular Genetic Algorithm, by {{removing}} <b>thread</b> <b>locks</b> for shared memory access. This deliberate error aims {{to accelerate the}} algorithm, while preserving its search capability. Experiments with three benchmark problems show an acceleration, and even a slight improvement in search capability, with statistical significance...|$|R
30|$|With {{the use of}} {{a needle}} as an introducer, the maximum probe size is limited to the inside {{diameter}} of a needle that will pass through the luer tip, approximately 2.2  mm. Using the <b>threaded</b> <b>lock</b> cannula is easier and safer, but the probe diameter is limited to the inside diameter of the cannula, approximately 1.3  mm.|$|R
40|$|Background: Distal radius {{fractures}} {{represent the}} most common fractures in adult individuals. Volar fixed-angle plating has become a popular modality for treating unstable distal radius fractures. Most of the plates allow insertion of either <b>threaded</b> <b>locking</b> screws or smooth locking pegs. To date, no biomechanical studies compare locking screws and pegs under axial and torsional loading. Methods: Ten Sawbones radii were used to simulate an AO/OTA A 3 fracture. Volar fixed-angle plates (Aptus Radius 2. 5, Medartis, Switzerland) with <b>threaded</b> <b>locking</b> screws (n = 5) or smooth locking pegs (n = 5) were used to fix the distal metaphyseal fragment. Each specimen was tested under axial compression and under torsional load with a servohydraulic testing machine. Qualitative parameters were recorded as well as axial and torsional stiffness, torsion strength, energy absorbed during monotonic loading and energy absorbed in one cycle. Results: Axial stiffness was comparable between both groups (p = 0. 818). If smooth pegs were used, a 17...|$|R
5000|$|... #Caption: Detail of scuba {{manifold}} showing barrel seal o-rings {{and left}} hand <b>thread</b> with <b>lock</b> nut ...|$|R
40|$|A {{draft for}} a revised ISO C++ standard, C++ 0 x, has been produced. The speaker {{will present the}} {{background}} of C++, its aims, the standards process (with opinions), some of the guiding design principles (with tiny code examples), and two case studies. The case studies are initialization (a general and uniform syntax and semantics for initializers in all contexts) and concurrent support facilities (memory model, <b>threads,</b> <b>locks,</b> futures) ...|$|R
50|$|The {{property}} of not needing to access a reference count when a reference is copied is particularly helpful when the object's reference count is expensive to access, for example {{because it is}} in another process, on disk, or even across a network. It can also help increase concurrency by avoiding many <b>threads</b> <b>locking</b> a reference count to increase it. Thus, weighted reference counting is most useful in parallel, multiprocess, database, or distributed applications.|$|R
5000|$|Atomic {{operations}} : Shared {{data are}} accessed by using atomic operations which cannot be interrupted by other threads. This usually requires using special machine language instructions, {{which might be}} available in a runtime library. Since the operations are atomic, the shared data are always kept in a valid state, no matter how other threads access it. Atomic operations {{form the basis of}} many <b>thread</b> <b>locking</b> mechanisms, and are used to implement mutual exclusion primitives.|$|R
5000|$|FC connectors' {{floating}} ferrule provides good mechanical isolation. FC connectors {{need to be}} mated {{more carefully}} than the push-pull types due {{to the need to}} align the key, and due to the risk of scratching the fiber end face while inserting the ferrule into the jack. FC connectors should not be used in vibrating environments due to its <b>threaded</b> <b>lock.</b> FC connectors have been replaced in many applications by SC and LC connectors.|$|R
5000|$|Karbonite gears are a {{reinforced}} plastic composite material used in Hitec RC servos that show almost {{five times the}} strength of nylon gears and better wear resistance. Cycle times of over 300,000 have been observed with these gear trains showing virtually no wear. Karbonite-geared servos are more expensive than those using nylon ones but are highly durable. [...] Hobbyists are advised avoid use of <b>thread</b> <b>locking</b> compounds on Karbonite as this will cause the plastic to fail.|$|R
5000|$|... {{enter the}} monitor: enter the method if the monitor is <b>locked</b> add this <b>thread</b> to e block this <b>thread</b> else <b>lock</b> the monitor ...|$|R
5|$|One <b>thread</b> will {{successfully}} <b>lock</b> variable V, {{while the}} other <b>thread</b> will be <b>locked</b> out—unable to proceed until V is unlocked again. This guarantees correct execution of the program. Locks, while necessary to ensure correct program execution, can greatly slow a program.|$|R
5|$|Locking {{multiple}} variables using non-atomic locks {{introduces the}} possibility of program deadlock. An atomic lock locks multiple variables all at once. If it cannot lock all of them, it does not lock any of them. If two threads each need to lock the same two variables using non-atomic locks, {{it is possible that}} one <b>thread</b> will <b>lock</b> one of them and the second <b>thread</b> will <b>lock</b> the second variable. In such a case, neither thread can complete, and deadlock results.|$|R
50|$|Another way to {{classify}} locks is by {{what happens when}} the lock strategy prevents progress of a <b>thread.</b> Most <b>locking</b> designs block the execution of the <b>thread</b> requesting the <b>lock</b> until it is allowed to access the locked resource. With a spinlock, the thread simply waits ("spins") until the lock becomes available. This is efficient if threads are blocked for a short time, because it avoids the overhead of operating system process re-scheduling. It is inefficient if the lock is held for a long time, or if the progress of the thread that is holding the lock depends on preemption of the <b>locked</b> <b>thread.</b>|$|R
5000|$|Synchronization between <b>threads</b> using read/write <b>locks</b> and {{barriers}} ...|$|R
40|$|International audienceThis paper {{investigate}} a mutual exclusion algorithm on distributed systems. We {{introduce a new}} algorithm based on the Naimi-Trehel algorithm, {{taking advantage of the}} distributed approach of Naimi-Trehel while allowing to request partial locks. Such ranged locks offer a semantic close to POSIX file <b>locking,</b> where <b>threads</b> <b>lock</b> some parts of the shared file. We evaluate our algorithm by comparing its performance with to the original Naimi-Trehel algorithm and to a centralized mutual exclusion algorithm. The considered performance metric is the average time to obtain a lock...|$|R
5000|$|... "High-level language" [...] {{refers to}} the higher level of {{abstraction}} from machine language. Rather than dealing with registers, memory addresses and call stacks, high-level languages deal with variables, arrays, objects, complex arithmetic or boolean expressions, subroutines and functions, loops, <b>threads,</b> <b>locks,</b> and other abstract computer science concepts, {{with a focus on}} usability over optimal program efficiency. Unlike low-level assembly languages, high-level languages have few, if any, language elements that translate directly into a machine's native opcodes. Other features, such as string handling routines, object-oriented language features, and file input/output, may also be present.|$|R
3000|$|... <b>thread,</b> blocked, <b>locked,</b> race, dead-lock, deadlock, concurrent, concurrency, atomic, synchronize, synchronous, synchronization, starvation, suspension, “order violation”, “atomicity violation”, “single {{variable}} atomicity violation”, “multi variable atomicity violation”, livelock, live-lock, multi-threaded, multithreading, and multi-thread.|$|R
5000|$|While {{any attempt}} to perform the [...] "lock" [...] {{operation}} on an ordinary mutex (lock) would either fail or block when the mutex is already locked, on a recursive mutex this operation will succeed {{if and only if}} the <b>locking</b> <b>thread</b> is the one that already holds the lock. Typically, a recursive mutex tracks the number of times it has been locked, and requires equally many unlock operations to be performed before other <b>threads</b> may <b>lock</b> it.|$|R
40|$|The rise of {{multicore}} computing {{has made}} synchronization necessary {{to overcome the}} challenge of sharing data between multiple <b>threads.</b> <b>Locks</b> are critical synchronization primitives for maintaining data integrity and preventing race conditions in multithreaded applications. This thesis explores the lock design space. We propose a hardware lock implementation, called the lock arbiter, which reduces lock latency while minimizing hardware overheads and maintaining high levels of fairness between threads. We evaluate our mechanism against state-of-the-art software lock algorithms and find that our mechanism has comparable performance and fairness. by Rachael Harding. Thesis: S. M., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2014. Cataloged from PDF version of thesis. Includes bibliographical references (pages 53 - 55) ...|$|R
5000|$|<b>Threads</b> can use <b>locks</b> {{in order}} to {{guarantee}} mutual access. Access to locks is via single instructions.|$|R
2500|$|The moderators (short {{singular}} form: [...] "mod") are users (or employees) of {{the forum}} who are granted {{access to the}} posts and threads of all members {{for the purpose of}} moderating discussion (similar to arbitration) and also keeping the forum clean (neutralizing spam and spambots etc.). Moderators also answer users' concerns about the forum, general questions, as well as respond to specific complaints. Common privileges of moderators include: deleting, merging, moving, and splitting of posts and <b>threads,</b> <b>locking,</b> renaming, stickying of threads, banning, suspending, unsuspending, unbanning, warning the members, or adding, editing, removing the polls of threads. [...] "Junior Modding", [...] "Backseat Modding", or [...] "Forum copping" [...] can refer negatively to the behavior of ordinary users who take a moderator-like tone in criticizing other members.|$|R
