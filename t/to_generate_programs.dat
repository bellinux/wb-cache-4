41|10000|Public
2500|$|Non-tree {{representations}} {{have been}} suggested and successfully implemented, such as linear genetic programming which suits the more traditional imperative languages [...] The commercial GP software Discipulus uses automatic induction of binary machine code ("AIM") to achieve better performance. µGP uses directed multigraphs <b>to</b> <b>generate</b> <b>programs</b> that fully exploit the syntax of a given assembly language ...|$|E
50|$|Nonetheless, {{the success}} of KTN {{inspired}} Africans. As a result, several independent productions were set up in Kenya <b>to</b> <b>generate</b> <b>programs</b> to service both KTN and KBC,.. {{as well as other}} stations that were to be established. Many of the exile communities from neighboring African states relied on KTN to air their concerns. The station fostered a marked change in the urban culture of Kenya as well.|$|E
40|$|To find {{solutions}} to Combinatorial Explosive {{problems such as}} NP Complete problems require high computational power. Parallel Algorithms can be used <b>to</b> <b>generate</b> <b>programs</b> {{which can be used}} to {{find solutions}} for them in finite time. Many approaches are used to develop better parallel algorithms, where Bio-Inspired approaches have proved to be more successful than other approache...|$|E
40|$|This is the {{language}} manual for OPTIMIX, the optimizer generator. OPTIMIX can be used <b>to</b> <b>generate</b> <b>program</b> analyses and transformations. Its input language is based on Datalog and graph rewriting. Especially two new classes of graph rewrite systems are used: edge addition rewrite systems (EARS) and exhaustive graph rewrite systems (XGRS) ...|$|R
40|$|Traditional parallelizing compilers are {{designed}} <b>to</b> <b>generate</b> paral-lel <b>programs</b> that produce identical outputs {{as the original}} sequen-tial program. The difficulty of performing the program analysis re-quired to satisfy this goal and the restricted space of possible target parallel programs have both posed significant obstacles to the de-velopment of effective parallelizing compilers. The QuickStep compiler is instead designed <b>to</b> <b>generate</b> paral-lel <b>programs</b> that satisfy statistical accuracy guarantees. The free-dom <b>to</b> <b>generate</b> parallel <b>programs</b> whose output may differ (within statistical accuracy bounds) from {{the output of the}} sequential pro-gram enables a dramatic simplification of the compiler and a signif-icant expansion in the range of parallel programs that it can legally generate. QuickStep exploits this flexibility to take a fundamen-tally different approach from traditional parallelizing compilers. I...|$|R
40|$|We have {{developed}} Tm, a template-based metacompiler. Given {{a set of}} data-structure definitions and a template, Tm generates files that instantiate the template for the given data structures. With this process, Tm is able <b>to</b> <b>generate</b> <b>program</b> code <b>to</b> manipulate these data structures. Since it uses templates, the generated code is not restricted to a specific programming language: any sufficiently powerful programming language can be targeted...|$|R
40|$|Programming-by-example (PBE) systems attempt <b>to</b> <b>generate</b> <b>programs</b> by {{learning}} a task from the user’s actions. It {{is a field}} with great potential, but little success so far. Most existing PBE systems are both highly specialised and quite limited in the tasks they can accomplish. This paper sets out {{a new approach to}} PBE that is general-purpose and can handle variables, branching and loops. It could therefore offer non-experts a genuine alternative to conventional programming. Our approach makes use of automated reasoning techniques, and is based on work in interactive theorem proving using model-instance based reasoning (where general theorems are proved by considering specific cases). The ‘proof-as-programs ’ paradigm (where theorem provers are used <b>to</b> <b>generate</b> <b>programs)</b> leads us to propose that modelinstance based reasoning can be applied to program generation. The proposed method has the added benefit that-because of the link to an underlying logic- certain types of common bug cannot occur. We are currently working on an implementation for the domain of XML object manipulation...|$|E
40|$|Abstract. This {{proof of}} concept study {{examines}} the possibility of spe-cifying the construction of programs using a Particle Swarm algorithm, and represents {{a new form of}} automatic programming based on Social Learning, Social Programming or Swarm Programming. Each individual particle represents choices of program construction rules, where these rules are specified using a Backus-Naur Form grammar. The results de-monstrate that it is possible <b>to</b> <b>generate</b> <b>programs</b> using the Grammatical Swarm technique. ...|$|E
40|$|Abstract — This {{proof of}} concept study {{examines}} the possibility of specifying the construction of programs using Differential Evolution, and represents {{a new form of}} grammar-based genetic programming, Grammatical Differential Evolution (GDE). In GDE each individual member of the population represents a specific choice of program construction rules, where these rules are specified using a Backus-Naur Form grammar. The results demonstrate that it is possible <b>to</b> <b>generate</b> <b>programs</b> using the Grammatical Differential technique...|$|E
50|$|The Africa Channel sources much of {{its content}} from {{production}} companies in Africa. The channel broadcasts a range of genres including lifestyle, live news, travel, music, documentaries (e.g. Cuba, an African Odyssey and Surfing Soweto) and films (e.g. Daratt, Imani and Rachida). In 2012 the channel began developing its own production arm <b>to</b> <b>generate</b> <b>programming</b> focussed on Africa-related subject matter including a documentary about the Pan-African bank Ecobank first broadcast in December 2012.|$|R
50|$|EXAPT ("EXtended Subset of APT") is a {{production}} oriented <b>programming</b> language <b>to</b> <b>generate</b> NC <b>programs</b> with control information for machining tools and enables to consider production-related issues of various machining processes.|$|R
40|$|This is the {{language}} manual for OPTIMIX, the optimizer generator. It can be used <b>to</b> <b>generate</b> <b>program</b> analyses and transformations. Its input language is based on Datalog and graph rewriting. Especially two new classes of graph rewrite systems are used: edge addition rewrite systems (EARS) and stratified graph rewrite systems (stratified GRS). OPTIMIX has been developed in the Esprit project COMPARE (No. 5399). It is currently not free {{and can be used}} only {{in the context of the}} CoSy compiler framework. For a licence, contact the author or info@ace. nl...|$|R
40|$|Consideration of {{the systems}} {{designed}} <b>to</b> <b>generate</b> <b>programs</b> for the increasingly complex digital computers being used on board unmanned deep-space probes. Such programming systems must accommodate the special-purpose features incorporated in the hardware. The use of higher-level language facilities in the programming system can significantly simplify the task. Computers for Mariner and for the Outer Planets Grand Tour are briefly described, {{as well as their}} programming systems. Aspects of the higher level languages are considered...|$|E
40|$|International audienceIn the Design By Contract (DBC) approach, programmers specify methods with pre and postconditions (also called contracts). Earlier work added {{protocols}} to the DBC {{approach to}} describe allowed method call sequences for classes. We extend this work {{to deal with}} a variant of generic classes and multithreaded classes. We present the semantical foundations of our extension. We describe a new technique to check that method contracts are correct w. r. t. to protocols. We show how <b>to</b> <b>generate</b> <b>programs</b> that must be proven to show that method contracts are correct w. r. t. to protocols. Because little support currently exists to help writing method contracts, our technique helps programmers to check their contracts early in the development process...|$|E
40|$|Automated code {{generation}} {{is the process}} whereby a computer program takes user specifications in some form and produces a program as output. Automated code generation can be the process undertaken by a compiler, which generates an executable program from a source program, but it also applies to the situation where the input is a task described at some level of abstraction and the output is a program that can perform that task. Several different approaches have been utilized to {{varying degrees of success}} to automate code generation, including Case-Based Reasoning, formal methods and evolutionary algorithms. In this paper, a system is introduced which combines Case-Based Reasoning, Routine Design and Template-Based Programming <b>to</b> <b>generate</b> <b>programs</b> tha...|$|E
40|$|This paper {{proposes a}} method <b>to</b> <b>generate</b> <b>program</b> code for {{embedded}} systems using Multi-valued Decision Diagrams (MDDs) that are called heterogeneous MDDs. The heterogeneous MDDs represent logic functions more compactly, and have shorter average path length than other Decision Diagrams (DDs). The code generated using heterogeneous MDDs can evaluate logic functions faster {{using a small}} amount of memory. Our experimental results show that some functions are suitable for this method, while others are suitable for Levelized Compiled Code (LCC) method. We also introduce a new measure of logic functions, the LN-ratio to determine which of the two methods is better...|$|R
50|$|This {{response}} is easier <b>to</b> <b>generate</b> by CGI <b>programs</b> because {{one does not}} need to change the default status code.|$|R
40|$|Animation of {{execution}} {{is a necessary}} feature of source-level debuggers. We present a framework where animators are generated from existing algebraic specifications of interpreters. To this end, a patternmatching mechanism is {{used in conjunction with}} origin tracking, a generic tracing technique. The generation of animators is illustrated using an example language named CLaX, a Pascal relative. We study how our approach can be extended to the generation of source-level debuggers and algorithmic debuggers from specifications of interpreters. 1 Introduction We study animators for <b>generated</b> <b>programming</b> environments. An animator is a tool which visualizes program execution; typically, it highlights the statement that is currently executing. Animators are especially useful for (automated) debugging and tutoring. We use the ASF+SDF Meta-environment [14] <b>to</b> <b>generate</b> <b>programming</b> environments, consisting of syntax-directed editors, type-checkers, and interpreters, from algebraic spec [...] ...|$|R
40|$|In the Design By Contract (DBC) approach, programmers specify methods with pre and postconditions (also called contracts). Earlier work added {{protocols}} to the DBC {{approach to}} describe allowed method call sequences for classes. We extend this work {{to deal with}} a variant of generic classes and multithreaded classes. We present the semantical foundations of our extension. We describe a new technique to check that method contracts are correct w. r. t. to protocols. We show how <b>to</b> <b>generate</b> <b>programs</b> that must be proven to show that method contracts are correct w. r. t. to protocols. Because little support currently exists to help writing method contracts, our technique helps programmers to check their contracts early in the development process...|$|E
40|$|Software {{fault-tolerance}} schemes often employ multiple software versions {{developed to}} meet the same specification. If the versions fail independently of each other, they can be combined to give high levels of reliability. Although design diversity is a means to develop these versions, it has been questioned because it increases development costs and because reliability gains are limited by common-mode failures. The use of genetic programming is proposed to generate multiple software versions by varying parameters of the genetic programming algorithm. An environment is developed <b>to</b> <b>generate</b> <b>programs</b> for a controller in an aircraft arrestment system. Eighty programs have been developed and tested on 10000 test cases. The experimental data show that failure diversity is achieved, but for the top performing programs its levels are limited...|$|E
40|$|Abstract-This {{case study}} {{examines}} {{the application of}} Grammatical Swarm to classification problems, and illustrates the Particle Swarm algorithms ’ ability to spify the construction of programs. Each individual particle represents choices of program construction rules, where these rules are specified using a Backus-Naur Form grammar. Two problem instances are tackled, the first a mushroom classification problem, the second a bioinformalics problem that involves the detection of eukaryotic DNA promoter sequences. For the first problem we generate solutions that {{take the form of}} conditional statements in a C-like language subset, and for the second problem we generate simple regular expressions. The results demonstrate that it is possible <b>to</b> <b>generate</b> <b>programs</b> using the Grammatical Swarm technique with a performance similar to the Grammatical Evolution evolutionary automatic programming approach. I...|$|E
40|$|The precise {{specification}} of software models {{is a major}} concern in the model-driven design of object-oriented software. Models are commonly given as graph-like diagrams so that graph grammars are a natural candidate for specifying them. However, context-free graph grammars are not powerful enough to specify all static properties of a model. Even the recently proposed adaptive star grammars cannot capture all properties of object-oriented models. So we extend adaptive star rules by positive and negative application conditions to overcome these deficiencies without sacrificing parsing algorithms. It turns out that conditional adaptive star grammars are powerful enough <b>to</b> <b>generate</b> <b>program</b> graphs, a software model with rather complicated contextual properties...|$|R
40|$|Abstract. This paper {{argues that}} genetic {{programming}} {{has not made}} good on its promise <b>to</b> <b>generate</b> computer <b>programs</b> automatically. It then describes an approach that would allow that promise to be fulfilled by running a genetic programming engine under human guidance. Keywords: guided genetic programming. 1...|$|R
40|$|Abstract Many {{important}} computation {{problems can}} be specified by block recursive algorithms. For exam-ple, matrix transposition and fast Fourier transform are block recursive algorithms. In this paper, we present a methodology of VLSI circuit design for block recursive algorithms based on the tensor product theory. Matrix transposition and fast Fourier transform algorithms are designed and implemented following this methodology. First, matrix transposition and fast Fourier transform algorithms are expressed as tensor product formulas. The tensor product formulas are modified to fit into interconnection networks, including the omega network and the hypercube network. The formulas are then used <b>to</b> <b>generate</b> high-level <b>programming</b> language code. Finally, a hardware description language, Verilog, is used to realize the algorithms according <b>to</b> the <b>generated</b> <b>programs.</b> The major goal {{of this paper is}} to provide an effective way to design VLSI circuits for block recursive algorithms...|$|R
40|$|We {{describe}} Genesis, {{a language}} for {{the generation of}} synthetic programs. The language allows users to annotate a template program to customize its code using statistical distributions and to generate program instances based on those distributions. This effectively allows users <b>to</b> <b>generate</b> <b>programs</b> whose characteristics vary in a statistically controlled fashion, thus improving upon existing program generators and alleviating the difficulties associated with ad hoc methods of program generation. We describe the language constructs, a prototype preprocessor for the language, and five case studies that show the ability of Genesis to express a range of programs. We evaluate the preprocessor’s performance and the statistical quality of the samples it generates. We thereby show that Genesis is a useful tool that eases the expression and creation of large and diverse program sets...|$|E
40|$|Run-time {{specialization}} (RTS) techniques e#ciently generate specialized {{programs with}} respect to run-time values. They construct compiled native-code fragments called templates at compile-time, and generate a specialized program by merely copying the templates. The generated programs are less e#cient than those generated by static partial evaluation techniques because the RTS techniques prevent many optimizations. The proposed bytecode specialization (BCS) technique is used <b>to</b> <b>generate</b> <b>programs</b> in a bytecode language and then translate the generated bytecode into native code by using a just-in-time (JIT) compiler. Its advantages are (1) e#cient specialization processes {{that are similar to}} those of RTS techniques, (2) e#cient specialized programs thanks to optimizations by the JIT compilers, and (3) that it is independent of the source-to-bytecode and the bytecode-to-native compilers thanks to a binding-time analysis algorithm that directly handles bytecode programs. Th [...] ...|$|E
40|$|Stack-based genetic {{programming}} {{is an alternative}} to Koza-style tree-based {{genetic programming}} that generates linear programs that are executed on a virtual machine using a FORTH-style operand stack instead of tree-based function calls. A stack-based genetic programming system was extended to include the ability <b>to</b> <b>generate</b> <b>programs</b> containing automatically defined functions. Experiments were run to test the system using Koza's lawnmower problem. The stack-based system using automatically defined functions was able to successfully solve the lawnmower problem. Solutions sizes using automatically defined functions were comparable to those reported by Koza for the tree-based system. Solution sizes without using automatically defined functions were much larger in the stack-based system. The stack-based system both with and without automatically defined functions required significantly more search than was performed by the tree-based system. The efficiency and average structural co [...] ...|$|E
50|$|Programming Metadata Communication Protocol (PMCP) is a {{standard}} for use within digital television broadcast facilities for transfer of the source data used <b>to</b> <b>generate</b> electronic <b>program</b> guide listings and other program-related information. The resulting data may then be sent to a PSIP generator for conversion to broadcast-ready format.|$|R
40|$|Abstract—Advances {{in recent}} years have made it {{possible}} in some cases to locate bugs automatically. But debugging is also about correcting bugs. Can tools do this automatically? The results reported in this paper, from the new PACHIKA tool, suggest that such a goal may be reachable. PACHIKA leverages differences in <b>program</b> behavior <b>to</b> <b>generate</b> <b>program</b> fixes directly. It automatically infers object behavior models from executions, determines differences between passing and failing runs, generates possible fixes, and assesses them via the regression test suite. Evaluated on the ASPECTJ bug history, PACHIKA generates a valid fix for 3 out of 18 crashing bugs; every fix pinpoints the bug location and passes the ASPECTJ test suite. Keywords-debugging; fixing; object usage patterns () setLocalAddress(...|$|R
40|$|Abstract. We {{present an}} {{approach}} <b>to</b> <b>generating</b> <b>program</b> code from Event-B models that is correct-by-construction. Correctness is {{guaranteed by the}} com-bined use of well-definedness restrictions, refinement, and assertions. By enforc-ing the well-definedness of the translated model, we prevent runtime errors that originate from semantic differences between the target language and Event-B, such as different interpretations {{of the range of}} integer values. Using refine-ment, we show that the generated code correctly implements the original Event-B model. We provide a simple yet powerful scheduling language that allows one to specify an execution sequence of the model’s guarded events where assertions are used to express properties established by the event execution sequence, which are necessary for well-definedness and refinement proofs...|$|R
40|$|While many {{applications}} export data in hierarchical formats like XML and JSON, {{it is often}} necessary to convert such hierarchical documents to a relational representation. This paper presents a novel programming-by-example approach, and its implementation in a tool called Mitra, for automatically migrating tree-structured documents to relational tables. We have evaluated the proposed technique using two sets of experiments. In the first experiment, we used Mitra to automate 98 data transformation tasks collected from StackOverflow. Our method can generate the desired program for 94 % of these benchmarks with an average synthesis time of 3. 8 seconds. In the second experiment, we used Mitra <b>to</b> <b>generate</b> <b>programs</b> that can convert real-world XML and JSON datasets to full-fledged relational databases. Our evaluation shows that Mitra can automate the desired transformation for all datasets...|$|E
40|$|Constructive logic {{can be used}} to {{consider}} program speci cations as logical formulas. The advantage of this approach is <b>to</b> <b>generate</b> <b>programs</b> which are certi ed with respect to some given speci cations. The programs created in such away are not e cient because they may contain large parts with no computational meaning. The elimination of these parts is an important issue. Many attempts to solve this problem have been already done. We call this extracting procedure. In this work we present anewway to understand the extraction problem. This is the marking technique. This new point of view enables us, thanks to a high abstraction level, to unify what was previously done on the subject. It enables also to extend to higher{order languages some pruning techniques developed by Berardi and Boerio, which were only used in rst and second order language...|$|E
40|$|We {{describe}} a Genetic Algorithm that can evolve complete programs using a variable length linear genome {{to govern the}} mapping of a Backus Naur Form grammar definition to a program. Expressions and programs of arbitrary complexity may be evolved. Our system, Grammatical Evolution, has already been applied to a symbolic regression problem. Here we apply our system to find Trigonometric Identities for Cos 2 x. 1 Introduction Evolutionary Algorithms have been used with much success for the automatic generation of programs. In particular, Koza's [Koza 92] Genetic Programming has enjoyed considerable popularity and widespread use. Koza originally employed Lisp as his target language, however, many experimenters generate a home grown language, peculiar to their particular problem. Grammatical Evolution (GE) can be used <b>to</b> <b>generate</b> <b>programs</b> in any language, using Backus Naur Form definitions we allow a genetic algorithm to control what production rules are used. GE has proved successful [Rya [...] ...|$|E
40|$|Abstract. The precise {{specification}} of software models {{is a major}} concern in model-driven design of object-oriented software. In this paper, we investigate how program graphs, a language-independent model of object-oriented programs, can be specified precisely, with a focus on static structure rather than behavior. Graph grammars are a natural candidate for specifying the structure of a class of graphs. However, neither star grammars—which are equivalent to the well-known hyperedge replacement grammars—nor the recently proposed adaptive star grammars allow all relevant properties of program graphs to be specified. So we extend adaptive star rules by positive and negative application conditions, and show that the resulting conditional adaptive star grammars are powerful enough <b>to</b> <b>generate</b> <b>program</b> graphs. ...|$|R
40|$|Software {{product line}} {{engineering}} is one approach to implement sets of related programs efficiently. Software product lines (SPLs) {{can be implemented}} by code transformations which are combined in order <b>to</b> <b>generate</b> a <b>program.</b> A code transformation may add functionality to a base program or may alter its structure. Though implemented with less effort, <b>generated</b> <b>programs</b> are harder <b>to</b> debug because debug changes must effect the SPL transformations which the program was built from. In this paper, we present {{a new approach to}} debug programs (of an SPL) <b>generated</b> by <b>program</b> transformations...|$|R
40|$|Traditional parallelizing compilers are {{designed}} <b>to</b> <b>generate</b> parallel <b>programs</b> that produce identical outputs {{as the original}} sequential program. The difficulty of performing the program analysis required to satisfy this goal and the restricted space of possible target parallel programs have both posed significant obstacles {{to the development of}} effective parallelizing compilers. The QuickStep compiler is instead designed <b>to</b> <b>generate</b> parallel <b>programs</b> that satisfy statistical accuracy guarantees. The freedom <b>to</b> <b>generate</b> parallel <b>programs</b> whose output may differ (within statistical accuracy bounds) from the output of the sequential program enables a dramatic simplification of the compiler and a significant expansion in the range of parallel programs that it can legally generate. QuickStep exploits this flexibility to take a fundamentally different approach from traditional parallelizing compilers. It applies a collection of transformations (loop parallelization, loop scheduling, synchronization introduction, and replication introduction) <b>to</b> <b>generate</b> a search space of parallel versions of the original sequential program. It then searches this space (prioritizing the parallelization of the most time-consuming loops in the application) to find a final parallelization that exhibits good parallel performance and satisfies the statistical accuracy guarantee. At each step in the search it performs a sequence of trial runs on representative inputs to examine the performance, accuracy, and memory accessing characteristics of the current <b>generated</b> parallel <b>program.</b> An analysis of these characteristics guides the steps the compiler takes as it explores the search space of parallel programs. Results from our benchmark set of applications show that QuickStep can automatically <b>generate</b> parallel <b>programs</b> with good performance and statistically accurate outputs. For two of the applications, the parallelization introduces noise into the output, but the noise remains within acceptable statistical bounds. The simplicity of the compilation strategy and the performance and statistical acceptability of the <b>generated</b> parallel <b>programs</b> demonstrate the advantages of the QuickStep approach...|$|R
