0|10000|Public
50|$|A {{definition}} {{is a special}} <b>type</b> <b>of</b> <b>declaration.</b> A variable definition sets aside storage and possibly initializes it, a function definition provides its body.|$|R
5000|$|This <b>type</b> <b>of</b> <b>declaration</b> {{has been}} {{available}} since J2SE 5.0. Static import declarations allow access to static members defined in another class, interface, annotation, or enum; without specifying the class name: ...|$|R
50|$|Article 19(2) ECC gives States the {{possibility}} to exclude certain matters from the scope of application of the ECC. These exceptions could be similar to those made in corresponding national legislation: Singapore has lodged this <b>type</b> <b>of</b> <b>declaration</b> upon ratification <b>of</b> the Electronic Communications Convention.|$|R
40|$|This report {{describes}} the declaration {{process and the}} <b>types</b> <b>of</b> <b>declarations</b> that can be issued under the Stafford Act: (1) emergency and major disaster declarations, and (2) Fire Management Assistance Grants. The report also examines how the Disaster Relief Fund (DRF) is financed and analyzes the {{issues related to the}} DRF, including the debate over supplemental appropriations, how the DRF is budgeted, and the influence the Budget Control Act has had on the DRF...|$|R
50|$|It is {{sufficient}} to specify the <b>type</b> <b>of</b> a <b>declaration</b> (one <b>of</b> the above), whereas the exact suit or ranks are not required. A card can participate in at most one declaration.|$|R
30|$|The {{generation}} of “Type Extensions” is slightly different. Whenever {{there is a}} single type extension, the code generator creates a single aspect that aggregates every type extension using “declare parents”; a specific <b>type</b> <b>of</b> intertype <b>declaration.</b>|$|R
30|$|An urgent {{channel is}} a <b>type</b> <b>of</b> channel <b>declaration</b> offered by UPPAAL (Larsen et al. 1997) tool. When a channel is {{declared}} urgent, the transition pertaining to that channel will fire immediately upon being enabled. A drawback of using urgent channels {{is that the}} urgent channel guard cannot contain a clock variable.|$|R
25|$|The declare(strict_types=1) in PHP on a per-file basis allows only a {{variable}} <b>of</b> exact <b>type</b> <b>of</b> the <b>type</b> <b>declaration</b> will be accepted, or a TypeError will be thrown.|$|R
25|$|Hollerith {{cards were}} {{named after the}} elder Herman Hollerith, as were Hollerith {{constants}} (also sometimes called Hollerith strings), an early <b>type</b> <b>of</b> string constant <b>declaration</b> (in computer programming).|$|R
5000|$|The [...] in PHP on a per-file basis allows only a {{variable}} <b>of</b> exact <b>type</b> <b>of</b> the <b>type</b> <b>declaration</b> will be accepted, or a [...] will be thrown.|$|R
40|$|One of {{the most}} {{confusing}} concepts in the Verilog language is, when is a variable a "reg " and when is it a "wire? " Although the rules for declaring registers and wires are really very simple, most new and self-taught Verilog users don't understand when and why one <b>type</b> <b>of</b> <b>declaration</b> is required over another. This paper will detail the differences between register and net data types and propose an enhancement to the Verilog language that would eliminate the need to declare register data types altogether. The proposal Proposal: • Remove the requirement to declare scalar register data types and replace vector register data types with vector net declarations. • Report a syntax error whenever a procedural assignment is made to a variable that is also being driven to a value by a continuous assignment or instance port. Reasons: • To remove an annoying and confusin...|$|R
50|$|For certain <b>types</b> <b>of</b> customs <b>declarations,</b> traders may access CHIEF {{without going}} through a CSP. This is {{achieved}} over the Internet using email, an XML web service or a website. The endpoint for the trade is a front door to all UK government services, the Government Gateway, who then use the GSI (Government Secure Intranet) to reach CHIEF (and indeed any other government computer systems).|$|R
50|$|Since {{the only}} aspect of C data {{structures}} that {{is missing from}} Modula-3 is theunion type, all existing Modula-3 implementations are able to provide good binary compatibility with C language <b>type</b> <b>declarations</b> <b>of</b> arrays and structs.|$|R
50|$|A player {{declares}} when {{he plays}} the first hand. If a player has nothing to declare he simply plays his first card. If player has something to declare, he declares it when it's his turn to play his first card. It is sufficient to specify the <b>type</b> <b>of</b> a <b>declaration</b> (one <b>of</b> the above), whereas the exact suit or ranks are not required. The question of which are the highest declarations is settled when the game finishes.|$|R
40|$|Declarations on Sustainability in Higher Education (SHE) {{have grown}} in number and {{significance}} over the last decade. SHE declarations {{can be viewed as}} a piece of non binding international regulation that shapes universities’ pioneering role in ensuring sustainable development. Examination of the international SHE literature reveals no study that deals specifically with the interaction between declarations developed by the university sector and declarations developed by governmental and intergovernmental institutions. An analysis <b>of</b> this <b>type</b> can give us important insights in what themes these parties think should be given top priority in order to develop a sustainable society. Hence, the article addresses the following issues: (1) a thematic analysis of the relation between declarations developed by the university sector and those developed by governmental and intergovernmental institutions; (2) an analysis of themes the two <b>types</b> <b>of</b> <b>declarations</b> might have in common; and if so (3) an analysis of how they have developed during the past decade. The article finds four new themes that previous research has not identified, and shows how the valuation of nature is under reconfiguration in higher education policy...|$|R
40|$|Improving {{human and}} {{planetary}} wellbeing Momentum is building towards {{the development of}} universally applicable sustainable development goals. Owen Gaffney reports on the progress so far and explores the path ahead. In the last few years, every Anthropocene-related symposium I’ve attended concludes humanity is on a dangerous course. The excesses of a privileged few portend unprecedented destabilisation of Earth’s life-support system, leaving little room for other nations to develop. These <b>types</b> <b>of</b> <b>declarations</b> are often swiftly followed by dark mutterings that politicians are either unwilling to act or impotent {{in the face of}} clear and present danger. The principles of scientific neutrality and objectivity are being severely tested. Of course, political leaders are not sitting idle, but the list of issues is daunting, some barriers seem immovable and the institutions we have – the United Nations (UN), for example – seem ill-equipped at times for life in the Anthropocene. However, a new, and in some ways remarkable plan is being developed and scheduled for launch in September 2015 : th...|$|R
40|$|This paper {{compares the}} tasks <b>of</b> <b>type</b> {{checking}} and type inference {{in the context}} of a simple many-sorted prescriptive type system. Type inference is an extension <b>of</b> <b>type</b> checking in the context <b>of</b> incomplete <b>type</b> declarations; while checking the well-typedness <b>of</b> some expressions, <b>type</b> inference also infers type declarations for undeclared symbols. The basis of our approach is a declarative representation of the concept of a well-typed expression by a formal denition in a logic theory. We show that type checking can be implemented as a deductive task with respect to this logical theory augmented with an exhaustive enumeration <b>of</b> <b>type</b> <b>declarations.</b> We show that type inference can be implemented as an abductive task with respect to the same logical theory augmented with a partial enumeration <b>of</b> <b>type</b> <b>declarations</b> and some axioms expressing general properties <b>of</b> the <b>type</b> system. 1 Introduction This paper studies two tasks {{in the context of}} a simple many-sorted prescriptive type system [...] ...|$|R
5000|$|Java has a set <b>of</b> {{predefined}} annotation <b>types,</b> but it {{is allowed}} to define new ones. An annotation type declaration is a special <b>type</b> <b>of</b> an interface <b>declaration.</b> They are declared {{in the same way}} as the interfaces, except the [...] keyword is preceded by the [...] sign. All annotations are implicitly extended from [...] and cannot be extended from anything else.@interface BlockingOperations {} ...|$|R
5000|$|The Lisp {{family of}} {{languages}} are all [...] "strongly typed" [...] {{in the sense that}} typing errors are prevented at runtime. Some Lisp dialects like Common Lisp or Clojure do support various forms <b>of</b> <b>type</b> <b>declarations</b> and some compilers (CMUCL and related) use these declarations together with type inference to enable various optimizations and also limited forms <b>of</b> compile time <b>type</b> checks.|$|R
50|$|The concept places {{emphasis}} on the manners by which identity is passed or brought to life through discourse. Performative acts are <b>types</b> <b>of</b> authoritative speech. This can only happen and be enforced through the law or norms of the society. These statements, just by speaking them, carry out a certain action and exhibit {{a certain level of}} power. Examples <b>of</b> these <b>types</b> <b>of</b> statements are <b>declarations</b> <b>of</b> ownership, baptisms, inaugurations, and legal sentences. Something that is key to performativity is repetition. The statements are not singular in nature or use and must be used consistently in order to exert power (Hall 2000).|$|R
40|$|Treball Final de Grau en Administració d'Empreses. Codi: AE 1049. Curs acadèmic: 2016 / 2017 Business Opportunity: In Spain the {{household}} chores sector have involved around 630. 000 people who realise these activities types. Moreover, this sector {{have a big}} “black” market {{because the majority of}} these jobs don not realise any <b>type</b> <b>of</b> <b>declaration</b> or affiliation in the social security. For this reason, many people in the following years will not realise any <b>type</b> <b>of</b> contribution in the social security, therefore, in the future they cannot access to collect a pension. Activity: It is a platform that serves as link connection between costumers and professionals. In this platform costumers can contract the services below: Elder care, child care, pet care, cleaning, ironing, washing and food cooked. The platform allows contract these services per hours. Trade Name: Aequor Value proposition and competitive strategy: The value proposition of our business idea is directed to be an intermediary between the customers who are looking for certain services and the users who offer the services offered in the platform, being a nexus of union between both parties. The business idea is a strategy based on differentiation since the company is located in a sector {{with a high level of}} rivalry. This differentiation will be based on the characteristics and the channel in which the services are contracted since the business idea makes available a series of specialized professional services through a single "click" through the use of a computer, Smartphone or Tablet. Objective Segments: People of a mature age (between 36 - 60 years) who have both a stable job and a home, in addition to having a family unit...|$|R
40|$|This study {{analyzes}} the impact <b>of</b> different <b>types</b> <b>of</b> dividend <b>declaration,</b> namely stock and cash dividends. Using event study method, MAAR and CAAR, {{this study found}} no evidence of abnormal returns on the declaration day for either <b>of</b> the <b>types</b> <b>of</b> dividends. However, significant negative returns are reported on days prior to the declaration day for stock dividend, indicating speculative nature of the investors. Furthermore, it provides positive returns during the post-announcement period as the investors realize the chance of potential gains. However, as far as cash dividend is concerned companies listed under DSE do not provide any significant abnormal returns during the 60 days event window. For CAAR, no significant return is reported for cash dividend, while stock dividend provided a maximum 5. 6 % abnormal returns during the post announcement period. JEL Classification Code: M 41; M 49...|$|R
40|$|The present paper {{deals with}} the {{problems}} of the intracommunitary operations in Romania according to the current legislation. The intracommunitary acquisitions and deliveries of goods are being presented as well as the intracommunitary acquisitions and carrying out of services. We have also referred to the registering obligations towards the fiscal institutions, <b>types</b> <b>of</b> <b>declarations</b> and the penalties for not obeying the current legislation {{in the case of the}} economic agents undergoing intracommunitary operations. At the end of the present paper, we have chosen to present three cases of fiscal fraud as well as the measures which have been adopted by Romania in 2012 in order to prevent the fiscal fraud in the field of intracommunitary acquisitions. As a research method, the authors have used not only the theoretical approach, but also the empirical one. First of all, the theoretical approach has been chosen because there have been analyzed a lot of notions on intracommunitary acquisitions and deliveries of goods and services in accordance to the current legislation. Secondly, we have considered the empirical approach as we have concentrated on three fiscal fraud cases highly met in the case of the intracommunitary trade. Even though Romania, as a European state member, has a public debt rate of 32 % of GDP, which is far below the average EU 27, it still continues to borrow money from the international financial institutions in order to cover the public debt. Besides the measures presented in this paper, we propose fighting against the fiscal fraud by using all the possible means of attracting supplementary budgetary sources...|$|R
40|$|Scheme Type Recovery 1 1 Introduction Scheme is a latently typed {{language}} [R 3 RS]. This means that unlike statically {{typed language}}s suchas ML or Pascal, types are associated only with run-time values, not with variables. A variable can potentially be bound to values <b>of</b> any <b>type,</b> and type tests {{can be performed}} at run time to determinethe execution path through a program. This gives the programmer an extremely powerful form of polymorphism without requiring a verbose system <b>of</b> <b>type</b> <b>declarations.</b> This power and convenience is not without cost, however. Since run-time behavior can determinewhich values are bound to a given variable, precisely determining the <b>type</b> <b>of</b> a given reference to...|$|R
5000|$|An OpenDDL file is {{composed}} of a sequence of structures that can be either user-defined types or built-in primitive data <b>types.</b> The <b>declaration</b> <b>of</b> a structure consists of an identifier followed by an optional name, an optional property list, and finally, the structure's contents enclosed in braces. Raw data is always contained within structures whose identifiers are one <b>of</b> the data <b>types</b> described in the next section. For example, one may define a [...] structure that holds the floating-point coordinates of a three-dimensional point as follows.|$|R
40|$|This paper {{presents}} a new static type system for multithreaded programs; well-typed programs {{in our system}} are guaranteed {{to be free of}} data races and deadlocks. In recent previous work, we presented a static type system to prevent data races. In this paper, we extend the race-free type system to prevent both data races and deadlocks. The basic idea behind our system is as follows. When programmers write multithreaded programs, they already have a locking discipline in mind. Our system allows programmers to specify this locking discipline in their programs. The resulting specifications take the form <b>of</b> <b>type</b> <b>declaration...</b>|$|R
40|$|Cascading Style Sheets (CSS) is a {{language}} used for describing {{the look and}} formatting of HTML documents. CSS has been widely adopted in web and mobile development practice, since it enables a clean separation of content from presentation. The language exhibits complex features, such as inheritance, cascading and specificity, which make CSS code hard to maintain. Therefore, {{it is important to}} find ways to improve the maintainability of CSS code. In this paper, we propose an automated approach to remove duplication in CSS code. More specifically, we have developed a technique that detects three <b>types</b> <b>of</b> CSS <b>declaration</b> duplication and recommends refactoring opportunities to eliminate those duplications. Our approach uses preconditions that ensure the application of a refactoring will preserve the original document styling. We evaluate our technique on 38 real-world web systems and 91 CSS files, in total. Our findings show that duplication in CSS code is widely prevalent. Additionally, there is a significant number of presentation-preserving refactoring opportunities that can reduce the size of the CSS files and increase the maintainability of the code...|$|R
40|$|Since record {{polymorphism}} is one {{of essential}} factors for object-oriented languages, various approaches to incorporate record polymorphism into type systems have been proposed to {{lay the foundation for}} object-oriented languages. Recursive types, which are essentially <b>types</b> <b>of</b> lists or trees, are major programming tools. In object-oriented languages, a pseudo variable "self " has a recursive type, which requires that type systems be able to treat recursive <b>types.</b> The purpose <b>of</b> this paper is to provide a type system and its type inference algorithm which can handle subtyping, recursive types and parametric polymorphism without any kind <b>of</b> <b>type</b> <b>declaration</b> or unnatural restrictions. We prove soundness and completeness <b>of</b> the <b>type</b> inference algorithm. Our system integrates subtyping and recursive types into Damas and Milner's type system and preserves important properties such as existence <b>of</b> principal <b>typing.</b> The basic idea is that we consider a type as a regular tree. 1 Introduction [...] ...|$|R
40|$|EXtensible Markup Language (XML) -Schemas are the {{emerging}} standards for describing and validating semi-structured documents across the Internet, {{due to the}} rich set <b>of</b> modeling constructors, <b>types</b> and constraints they provide. Semantic similarity is growing in importance in different settings, such as digital libraries, heterogeneous databases and, in particular, the Semantic Web. The focus {{of this paper is}} the definition of a method for determining semantic similarity of XML-Schema elements in the presence <b>of</b> <b>type</b> hierarchies. Such a method has been defined by combining and revisiting: (i) the information content approach, and (ii) a method for comparing the structural components <b>of</b> <b>type</b> <b>declarations,</b> inspired by the maximum weighted matching problem in bipartite graphs. Keywords: Semantic Web; XML-Schemas; type hierarchies; information content; similarity reasoning 1...|$|R
50|$|Statically typed {{languages}} can {{be either}} manifestly typed or type-inferred. In the first case, the programmer must explicitly write types at certain textual positions (for example, at variable declarations). In the second case, the compiler infers the <b>types</b> <b>of</b> expressions and <b>declarations</b> based on context. Most mainstream statically typed languages, such as C++, C# and Java, are manifestly typed. Complete type inference has traditionally been associated with less mainstream languages, such as Haskell and ML. However, many manifestly typed languages support partial type inference; for example, Java and C# both infer types in certain limited cases. Additionally, some programming languages allow for some types to be automatically converted to other types; for example, an int can be used where the program expects a float.|$|R
40|$|Issues {{concerning}} {{the implementation of}} a notion of modules in the higher-order logic programming language Prolog are examined. A program in this language is a composite <b>of</b> <b>type</b> <b>declarations</b> and procedure definitions. The module construct that is considered permits large collections <b>of</b> such <b>declarations</b> and definitions to be decomposed into smaller units. Mechanisms are provided for controlling the interaction of these units and for restricting the visibility of names used within any unit. The typical interaction between modules has both a static and a dynamic nature. The parsing of expressions in a module might require declarations in a module that it interacts with, and this information must be available during compilation. Procedure definitions within a module might utilize procedures presented in other modules and support must be provided for making the appropriate invocation during execution. Our concern here is largely with the dynamic aspects of module interaction. We describe a [...] ...|$|R
40|$|In {{this paper}} we {{investigate}} the type inference and checking for a polymorphic order-sorted typed functional logic language. This language {{consists of a}} specification <b>of</b> <b>types,</b> a set <b>of</b> <b>type</b> <b>declarations</b> for data constructors and functions {{and a set of}} constructor-based conditional rewriting rules including data and type conditions as constraints in the rule applicability. We have interested in type conditions that can be satisfiable (i. e. the satisfiability depends on the program rules and therefore it is not decidable statically) and make the program rules well-typed. The well-typedness of a program rule establishes that expressions occurring in it must be well-typed w. r. t. the type declarations and its type conditions. We present an algorithm that infers a minimal set <b>of</b> <b>type</b> conditions making well-typed a rule and that checks satisfiability <b>of</b> the <b>type</b> information provided by the user. This algorithm is shown to be sound and complete. 1 Introduction The usefulness <b>of</b> <b>type</b> systems [...] ...|$|R
50|$|During argument-dependent lookup, other namespaces not {{considered}} during normal lookup may be searched where {{the set of}} namespaces to be searched depends on the <b>types</b> <b>of</b> the function arguments. Specifically, the set <b>of</b> <b>declarations</b> discovered during the ADL process, and considered for resolution of the function name, is the union <b>of</b> the <b>declarations</b> found by normal lookup with the declarations found by looking in the set of namespaces associated with the <b>types</b> <b>of</b> the function arguments.|$|R
40|$|AbstractThis paper {{presents}} a Horn clause logic where functions and predicates are declared with polymorphic types. Types are parameterized with type variables. This {{leads to an}} ML-like polymorphic type system. A <b>type</b> <b>declaration</b> <b>of</b> a function or predicate restricts the possible use of this function or predicate so that only certain terms are allowed to be arguments for this function or predicate. The semantic models for polymorphic Horn clause programs are defined and a resolution method {{for this kind of}} logic programs is given. It will be shown that several optimizations in the resolution method are possible for specific kinds of programs. Moreover, it is shown that higher-order programming techniques can be applied in our framework...|$|R
40|$|Lisp {{applications}} {{need to show}} {{a reasonable}} cost-benefit relationship between the offered expressiveness and their demand for storage and run-time. Drawbacks in efficiency, apparent in Lisp as a dynamically typed programming language, can be avoided by doing compiling optimizations. Statically inferred type information can be decisive {{for the success of}} these optimizations. This paper describes a practical approach to type inference used in a module and application compiler for EuLisp. The approach is related to Milner-style polymorphic type inference, but differs by handling refined types, e. g., cons-nodes, recursive lists, structures, classes, singleton types and fine-grained number types, in the absence <b>of</b> <b>type</b> <b>declarations.</b> Due to module compilation inferred <b>type</b> signatures <b>of</b> exported functions are provided in export interfaces, in order to reuse them for later import. The type inference is integrated with the process of compilation to make use of information previously analyse [...] ...|$|R
40|$|International audienceGuaranteeing {{that the}} parties of a network {{application}} respect a given protocol is a crucial issue. Session types offer a method for abstracting and validating structured communication sequences (sessions). Object-oriented programming is an established paradigm for large scale applications. Union types, which behave as the least common supertypes {{of a set of}} classes, allow the implementation of unrelated classes with similar interfaces without additional programming. We have previously developed an integration of the features above into a class-based core language for building network applications, and this successfully amalgamated sessions and methods so that data can be exchanged flexibly according to communication protocols (session types). The first aim of the work reported in this paper is to provide a full proof <b>of</b> the <b>type</b> safety property for that core language by renewing syntax, typing and semantics. In this way, static typechecking guarantees that after a session has started, computation cannot get stuck on a communication deadlock. The second aim is to define a constraint-based type system that reconstructs the appropriate session <b>types</b> <b>of</b> session <b>declarations</b> instead <b>of</b> assuming that session types are explicitly given by the programmer. Such an algorithm can save programming work, and automatically presents an abstract view of the communications of the sessions...|$|R
