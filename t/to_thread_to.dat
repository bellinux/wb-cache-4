0|8562|Public
50|$|Tatting: These {{are built}} long {{with an even}} {{thickness}} for their entire length, including at the eye, <b>to</b> enable <b>thread</b> <b>to</b> be pulled through the double stitches used in tatting.|$|R
5000|$|... schedule(type, chunk): This {{is useful}} if the work sharing {{construct}} is a do-loop or for-loop. The iteration(s) {{in the work}} sharing construct are assigned <b>to</b> <b>threads</b> according <b>to</b> the scheduling method defined by this clause. The three types of scheduling are: ...|$|R
5000|$|Owner identifier, unique <b>to</b> each <b>thread</b> (defaulting <b>to</b> empty / not set) ...|$|R
50|$|Blocking synchronizes {{the client}} thread execution, {{blocking}} it and implicitly schedules the server <b>thread</b> <b>to</b> be scheduled for execution without requiring explicit process control {{work by the}} kernel <b>to</b> determine which <b>thread</b> <b>to</b> run next as with other forms of IPC.|$|R
5000|$|Simple 2000 Series Vol. 45: The Koi to Namida <b>to,</b> Tsuioku <b>to...</b> <b>Thread</b> Colors: Sayonara no Mukou Gawa ...|$|R
6000|$|... "Yes, I am Maudie," [...] she answered. [...] "Mr. Mitchell {{wants to}} try some experiment. He wishes you <b>to</b> tie the <b>threads</b> <b>to</b> {{the legs of the}} table." ...|$|R
50|$|In group forums, {{allowing}} users <b>to</b> reply <b>to</b> <b>threads</b> {{will reduce}} the number of new posts shown in the list.|$|R
50|$|Film {{transport}} {{was fully}} automatic in both directions, but {{the camera was}} not fitted with Canon's Quick Load feature; film still had <b>to</b> be manually <b>threaded</b> <b>to</b> the take-up spool.|$|R
50|$|Many {{spindles}} {{will have}} a point {{at the top of}} the shaft <b>to</b> fix the <b>thread</b> <b>to.</b> Options include a simple length of shaft <b>to</b> tie the <b>thread</b> around, a shaped notch or bulb, or a hook.|$|R
5|$|Given Intel's {{history of}} {{disclosing}} details about Itanium microprocessors at ISSCC, this paper most likely refers to Poulson. Analyst David Kanter speculates that Poulson {{will use a}} new microarchitecture, with a more advanced form of multithreading that uses up <b>to</b> two <b>threads,</b> <b>to</b> improve performance for single threaded and multithreaded workloads.|$|R
50|$|OS X exposes an {{affinity}} APIthat provides hints to the kernel how <b>to</b> schedule <b>threads</b> according <b>to</b> affinity sets.|$|R
25|$|D3D10 {{functionality}} requires WDDM and new graphics hardware. The graphics hardware will be pre-emptively multithreaded, <b>to</b> allow multiple <b>threads</b> <b>to</b> use the GPU in turns. It {{will also}} provide paging of the graphics memory.|$|R
50|$|The pragma omp {{parallel}} is used <b>to</b> fork additional <b>threads</b> <b>to</b> {{carry out}} the work enclosed in the construct in parallel. The original thread will be denoted as master thread with thread ID 0.|$|R
50|$|Mollusks and clams {{that live}} in areas with substrate, and need them to survive, use their silky byssal <b>threads</b> <b>to</b> cling to it. See Cteniodes Ales for reference.|$|R
40|$|Component-based {{software}} development {{is an effective}} technique for tackling the increasing complexity of largescale embedded software systems. After building a logical software model, the designer must make design decisions, including choosing a multi-threading strategy and assigning priorities <b>to</b> <b>threads,</b> <b>to</b> ensure that the final implementation on the target execution platform satisfies non-functional requirements. Code generators for software design tools produce functional code, but typically ignore concurrency and timing issues. In this paper, we describe techniques for real-time scheduling and designspace exploration and optimization, {{with the goal of}} helping the designer synthesize efficient real-time implementations from component-based software models. Experimental evaluation shows that our techniques yield highquality implementations with reasonable running time of the optimization algorithm...|$|R
2500|$|The name Rocket {{comes from}} the Italian rocchetta, meaning [...] "bobbin" [...] or [...] "little spindle", given due to the {{similarity}} in shape to the bobbin or spool used <b>to</b> hold the <b>thread</b> <b>to</b> be fed to a spinning wheel.|$|R
50|$|Sewing {{machines}} {{can make}} {{a great variety of}} plain or patterned stitches. Ignoring strictly decorative aspects, over three dozen distinct stitch formations are formally recognized by the ISO 4915:1991 standard, involving one <b>to</b> seven separate <b>threads</b> <b>to</b> form the stitch.|$|R
50|$|If the {{scheduler}} interrupts {{the current}} process or thread {{in a critical}} section, the scheduler will either allow the currently executing process or <b>thread</b> <b>to</b> run to completion of the critical section, or it will schedule the process or thread for another complete quantum. The scheduler will not migrate the process or <b>thread</b> <b>to</b> another processor, {{and it will not}} schedule another process or <b>thread</b> <b>to</b> run while the current process or thread is in a critical section.|$|R
5000|$|Alaska Airlines's {{extended}} {{end play}} check interval and the FAA's approval of that extension, which allowed the acme nut <b>threads</b> <b>to</b> deteriorate {{to the point}} of failure without the opportunity for detection ...|$|R
25|$|Programming {{languages}} typically {{deal with}} this by limiting asynchronicity, for example Java has deprecated the use of its ThreadDeath exception that was used <b>to</b> allow one <b>thread</b> <b>to</b> stop another one. Instead, there can be semi-asynchronous exceptions that only raise in suitable locations of the program or synchronously.|$|R
50|$|The capsule is {{attached}} <b>to</b> a long <b>thread</b> <b>to</b> control {{the position of}} the capsule in the stomach. After the pH measurements have been recorded, the capsule may be allowed to pass into the intestine and be expelled through the rectum. The testing procedure may take 1-2 hours.|$|R
50|$|Programming {{languages}} typically {{deal with}} this by limiting asynchronicity, for example Java has deprecated the use of its ThreadDeath exception that was used <b>to</b> allow one <b>thread</b> <b>to</b> stop another one. Instead, there can be semi-asynchronous exceptions that only raise in suitable locations of the program or synchronously.|$|R
40|$|Based on the Brown Threads package {{which runs}} {{on a single}} process, I built a thread package running on {{multiple}} processes. In order <b>to</b> allow <b>threads</b> <b>to</b> migrate among different processes, the address space should look the same in all the processes from the thread's {{point of view and}} each process's filedescriptor table should be consistent with those of the other processes so the threads can run on anyone of the processes. ...|$|R
50|$|Several {{types of}} {{embroidery}} canvas are available: single thread and double thread embroidery canvas are open even-weave meshes, with large spaces or holes <b>to</b> allow heavy <b>threads</b> <b>to</b> pass through without fraying. Aida cloth or Hardanger fabric {{can also be}} used for canvas work, and plastic canvas is used in craft projects.|$|R
40|$|Abstract—Heterogeneity in {{multicore}} processor systems creates challenges in effectively mapping processes to diverse cores. While most approaches require programmer partitioning between core types or permutation of <b>thread</b> schedules <b>to</b> find the optimal mapping, we {{introduce a new}} machine learning approach <b>to</b> automated <b>thread</b> assignment. We train a reinforcement learning agent <b>to</b> assign <b>threads</b> <b>to</b> the best performing core {{given the state of}} the program and the processor cores. We present preliminary results demonstrating the promise of this approach for two and four heterogeneous cores using multiprogram workloads from SPEC CPU 2006 benchmarks. We further discuss the limitations of this initial approach and propose future directions for improving our technique. I...|$|R
25|$|Droplets {{are about}} 2.5mm in diameter. The {{internal}} structure is complex, {{consisting of a}} mass of curled or folded fibre embedded in a viscid matrix which is in turn surrounded by a less viscous layer. This results in the low viscosity liquid flowing past the moth's scales to reach the cuticle below, while the more viscous liquid forms a bond <b>to</b> the <b>thread</b> <b>to</b> sustain the moth's weight. The folded thread inside the ball permits elastic elongations which extend the spider's striking range.|$|R
40|$|Debugging a {{distributed}} application is inherently difficult because {{such factors as}} network delay and varying system loads may cause the behaviour of the application to change from one execution to another. Using a standard debugger with such an application {{is also likely to}} perturb its behaviour sufficiently that some bugs will not be manifested when the debugger is used. Fortunately, a replay mechanism can be used to circumvent these problems. Replaying a program involves a monitoring phase, during which the behaviour of the program is logged, and a replay phase, during which the behaviour of the program is coerced to follow the partial order logged during the monitoring phase. In this paper, 1 we describe an implementation of the replay technique for use with the Open Software Foundation's Distributed Computing Environment (OSF DCE). OSF DCE presents a special problem in that servers are multithreaded and incoming RPCs are assigned dynamically <b>to</b> <b>threads.</b> <b>To</b> preserve the event par [...] ...|$|R
40|$|This paper {{describes}} a technique for integrating run-time compilation which is effectively pause free {{and for which}} the worst-case impact can be bounded. Three extensions to a JVM implementation are used. Firstly, a new scheduler allows the allocation of CPU time <b>to</b> <b>threads</b> <b>to</b> be controlled. Secondly, a code generator provides a mechanism for run-time compilation. Finally, a control interface allow application-specific compilation policies to be specified. By defining a compilation policy in which native code is generated in a designated compiler thread with a limited CPU allocation, {{it is possible to}} bound the worst-case impact of the compiler. 1 Introduction The widespread deployment of the Java language is curtailed by the performance of existing implementations of the Java Virtual Machine (JVM, [LY 97]). Although there are numerous and well known techniques for optimizing object-oriented programming languages, {{the extent to which these}} can be applied within the JVM is limited by th [...] ...|$|R
50|$|Several {{types of}} {{embroidery}} canvas are available: single thread and double thread embroidery canvas are open even-weave meshes, with large spaces or holes <b>to</b> allow heavy <b>threads</b> <b>to</b> pass through without fraying. Canvas is sized by mesh sizes, or thread count per inch. Sizes vary from 5 <b>threads</b> per inch <b>to</b> 24 <b>threads</b> per inch; popular mesh sizes are 10, 12, 14, 18, and 24 (Congress Cloth). The {{different types of}} needlepoint canvas available on the market are interlock, mono, penelope, plastic, and rug.|$|R
40|$|We {{present a}} {{parallel}} implementation of SPH for shared memory computers. Our approach {{is based on}} domain decomposition and space filling curves (SFC). The particles are sorted and assigned <b>to</b> <b>threads</b> according <b>to</b> the Z-curve. This ensures per thread local storage of most frequently accessed data, avoids NUMA-unfriendly memory allocations, reduces data races and allows efficient calculation of symmetric inter-particle forces. We describe a simple and inexpensive dynamic load balancing algorithm. Finally, we present strong and weak scalability results of the implementation, and we identify sources of overhead. status: accepte...|$|R
50|$|On modern platforms, code is {{frequently}} not executed {{in the order}} it was written. It is reordered by the compiler, the processor and the memory subsystem to achieve maximum performance. On multiprocessor architectures, individual processors may have their own local caches {{that are out of}} sync with main memory. It is generally undesirable <b>to</b> require <b>threads</b> <b>to</b> remain perfectly in sync with one another because this would be too costly from a performance point of view. This means that at any given time, different threads may see different values for the same shared data.|$|R
30|$|We {{develop the}} program {{spawning}} the <b>threads</b> <b>to</b> crawl to each specified website {{to gather the}} information. The program is developed using Java Concurrency package in JDK 1.7. The thread writes the information found to the text file. All files are used to the next MapReduce phase after the data cleaning.|$|R
40|$|While threads {{have become}} an {{accepted}} and standardized model for expressing concurrency and exploiting parallelism for the shared-memory model, debugging threads is still poorly supported. This paper identies challenges in debugging <b>threads</b> and oers solutions <b>to</b> them. The contributions of this paper are threefold. First, an open interface for debugging as an extension <b>to</b> <b>thread</b> implementations is proposed. Second, extensions for thread-aware debugging are identied and implemented within the Gnu Debugger to provide additional features {{beyond the scope of}} existing debuggers. Third, an active debugging framework is proposed that includes a language-independent protocol to communicate between debugger and application via relational queries ensuring that the enhancements of the debugger are independent of actual thread implementations. Partial or complete implementations of the interface for debugging can be added <b>to</b> <b>thread</b> implementations <b>to</b> work in unison with the enhanced debugger wit [...] ...|$|R
40|$|International audienceObjective Caml is {{a famous}} dialect of the ML family languages. It is {{well-known}} for its {{performance as a}} compiled programming language, notably thanks to its incremental generational automatic memory collection. However, for historical reasons, the latter was built for monocore processors. One consequence is the runtime library assumes there is effectively {{no more than one}} thread running at a time, which allows many optimisations for monocore architectures: very few <b>thread</b> mutexes are sufficient <b>to</b> prevent more than a single <b>thread</b> <b>to</b> run at a time. This makes memory allocation and collection quite easier. The way it was built makes it not possible to take advantage of now widespread multicore CPU architectures. This paper presents our feedback on removing Objective Caml's garbage collector and designing a "Stop-The-World Stop&Copy" garbage collector <b>to</b> permit <b>threads</b> <b>to</b> take advantage of multicore architectures...|$|R
5000|$|Bottoming tap or plug tap: [...] The tap {{illustrated}} {{in the top of}} the image has a continuous cutting edge with almost no taper — between 1 and 1.5 threads of taper is typical. [...] This feature enables a bottoming tap <b>to</b> cut <b>threads</b> <b>to</b> the bottom of a blind hole. A bottoming tap is usually used <b>to</b> cut <b>threads</b> in a hole that has already been partially threaded using one of the more tapered types of tap; the tapered end ("tap chamfer") of a bottoming tap is too short to successfully start into an unthreaded hole. In the US, they are commonly known as bottoming taps, but in Australia and Britain they are also known as plug taps.|$|R
30|$|According to the {{principle}} of the AIDW interpolation algorithm, it is perfect that a single GPU thread can take the responsibility to calculate the prediction value of an interpolated point. For example, assuming there are n interpolation points that are needed to be predicted their values such as elevations, and then it is required <b>to</b> allocate n <b>threads</b> <b>to</b> calculate the desired prediction values for all those n interpolated points concurrently.|$|R
