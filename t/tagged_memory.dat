13|114|Public
50|$|B5000 {{machines}} with their stack-based architecture and <b>tagged</b> <b>memory</b> also heavily influenced the Soviet Elbrus series of mainframes and supercomputers. The first {{two generations of}} the series featured <b>tagged</b> <b>memory</b> and stack-based CPUs that were programmed only in high-level languages. There existed {{a kind of an}} assembly language for them, called El-76, but it was more or less a modification of ALGOL 60 and supported structured programming and first-class procedures. Later generations of the series, though, switched away from this architecture to the EPIC-like VLIW CPUs.|$|E
50|$|Key to the BiiN {{system was}} the 960 MX processor, {{essentially}} a RISC-based {{version of the}} earlier i432. Like the i432, the 960 MX included <b>tagged</b> <b>memory</b> for complete memory protection even within programs (as opposed to most CPU's, which offer protection only between programs), {{a full set of}} instructions for task control, and complex microcode to run it all.|$|E
5000|$|With {{the closing}} of the project, Intel used the basic RISC core of the CPU design {{as the basis for the}} i960 CPU. For this role most of the [...] "advanced" [...] {{features}} were removed, including the complex <b>tagged</b> <b>memory</b> system, task control system, most of the microcode and even the FPU. The result was a [...] "naked" [...] core, useful for embedded processor use. Before Intel switched to the StrongARM for the embedded role in the late 1990s, the i960 was one of Intels most popular products.|$|E
30|$|Passive tags {{systems have}} limited link budget [2]; however, they are {{attracting}} attention {{due to their}} low cost and long life. The reader first energizes passive tags by means of electromagnetic energy and then identifies the objects by collecting unique IDs stored in the <b>tag’s</b> <b>memory.</b>|$|R
40|$|Combining RFID and sensors {{leads to}} a wide field of {{possible}} applications. To address many of them while reducing the development cycle for individual specialized systems a flexible RFID sensor tag platform was developed. A solution based on a small integrated microcontroller and the RFID <b>tag</b> <b>memory</b> as data interface will be presented in this paper...|$|R
40|$|We {{introduce}} server impersonation attacks, {{a practical}} security threat to RFID security protocols {{that has not}} pre-viously been described. RFID <b>tag</b> <b>memory</b> is generally not tamper-proof for cost reasons. We show that, if a tag is compromised, such attacks can give rise to desynchronisa-tion between server and tag {{in a number of}} existing RFID authentication protocols. We also describe possible coun-termeasures to this novel class of attacks. ...|$|R
40|$|Computers are {{notoriously}} insecure, {{in part because}} application security policies do not map well onto traditional protection mechanisms such as Unix user accounts or hardware page tables. Recent work has shown that application policies can be {{expressed in terms of}} information flow restrictions and enforced in an OS kernel, providing a strong assurance of security. This paper shows that enforcement of these policies can be pushed largely into the processor itself, by using <b>tagged</b> <b>memory</b> support, which can provide stronger security guarantees by enforcing application security even if the OS kernel is compromised. We present the Loki <b>tagged</b> <b>memory</b> architecture, along with a novel operating system structure that takes advantage of <b>tagged</b> <b>memory</b> to enforce application security policies in hardware. We built a full-system prototype of Loki by modifying a synthesizable SPARC core, mapping it to an FPGA board, and porting HiStar, a Unix-like operating system, to run on it. One result is that Loki allows HiStar, an OS already designed to have a small trusted kernel, to further reduce the amount of trusted code by a factor of two, and to enforce security despite kernel compromises. Using various workloads, we also demonstrate that HiStar running on Loki incurs a low performance overhead. ...|$|E
40|$|We have {{approached}} {{the problem of}} improving the run-time supports for operating system, high-level languages and programming environments, {{within the framework of}} a project aimed at defining a microprocessor-based advanced architecture whose main goal is the reduction of the so-called semantic-gap. The principal features of the resulting architecture are a capability-based addressing scheme, an implementation of <b>tagged</b> <b>memory</b> relying on the concept of tagged segments, a single level store approach to memory management, and significant hardware supports for multitasking. The architecture has actually been implanted as a research prototype, and the most noticeable choice concerning implementation was to give separate hardware support to memory management functionalities: this not only led to a high degree of parallelism in the execution of kernel activities, but also improved the overall manageability and simplified the testing, debugging and tuning phases of system development...|$|E
40|$|This thesis {{examines}} {{the feasibility of}} using a <b>tagged</b> <b>memory</b> and a stack processor to implement a capability based computer. The hypothesis put forth here is that these two architectural features {{reduce the cost of}} the capability mechanism and result in a simpler implementation. We begin by motivating memory protection and protection systems as a basic need of modern computer systems. A brief historical survey is presented which begins with Dennis and Van Horn 2 ̆ 7 s paper on the semantics of multi-programmed computations and ends with a review of the major capability machines which resulted from this paper. ^ We then introduce the memory and processor organization proposed for this design and compare this organization with that used in previous architectures. This discussion shows that a tagged-memory organization reduces the number of segments used by a process by allowing segments to contain both pointer and data information. This reduces memory management overhead and allows a simpler representation of objects. Moreover, the <b>tagged</b> <b>memory</b> simplifies the mechanisms used to change domains, pass parameters, and address information in primary memory. The stack processor is shown to further reduce the cost of the capability mechanism by providing an inexpensive way to allocate procedure activation records, handle domain changes, and address objects on the stack. ^ Next we present the capability mechanism for the proposed design and discuss the process of mapping capability based virtual addresses into absolute primary memory addresses, and show how the abstract type concept is directly supported by the capability mechanism. ^ A discussion of the hardware facilities needed to support the design follows. This discussion presents a detailed view of the registers of the central processor, the organization of the process stack, the instruction set, and a possible firmware organization which could be used to implement the design. ^ The proposed architecture is then compared with two conventional machines and shown to be more efficient in representing programs. Moreover, evidence is presented which suggests that the performance of the proposed machine would be competitive with current state-of-the-art machines. Finally, two examples are presented which use the abstract type, process synchronization, and process communication facilities provided by the design. ^ The major contribution of this thesis is the thorough examination it provides of the <b>tagged</b> <b>memory</b> approach to capability addressing. Out research shows a tagged-memory capability machine is powerful enough to implement an operating system and the resulting operating system has a complexity about equal to that of the older generation of simple systems with little memory protection. This thesis also illustrates that advanced programming concepts can be implemented quite simply if the proper hardware support is provided. Finally, we show that the process control mechanism introduced in this thesis removes an important source of memory contention from the mutual exclusion mechanism. This is seen as a partial solution to the memory contention problem found on many multi-processor systems. ...|$|E
40|$|We {{describe}} an experiment investigating how <b>tagging</b> affects human <b>memory.</b> We compare a low-cost tagging by mouse-clicking interface (Click 2 Tag) to traditional tagging by typing {{and to a}} baseline, no tagging condition. Our results suggest that tagging is beneficial for memory. However, the two tagging methods impact distinct aspects of memory: tagging by typing promotes elaboration of read contents and, thus, enhances free recall, whereas tagging by clicking strengthens the memory traces by repeated readings of relevant words in the text and, thus, improves recognition of facts from the text. Author Keywords <b>Tagging,</b> <b>memory,</b> interaction cost, social bookmarkin...|$|R
40|$|Abstract—The {{proliferation}} of {{radio frequency identification}} (RFID) systems in application domains such as supply chain man-agement requires an IT infrastructure that provides RFID device and data management and supports application development. In this paper, we discuss these application requirements in detail. We also contend that the characteristics of passive RFID tech-nology introduce constraints that are unique {{to the development of}} middleware for the RFID domain. These constraints include the occurrence of false negative reads, <b>tag</b> <b>memory</b> variations, the heterogeneous reader landscape, and the limited communication bandwidth available to RFID readers. To address these constraints and the application requirements for filtered and aggregated RFID data, we developed Accada, an open source RFID platform. This paper shows that the Accada implementation, which is based on a set of specifications developed by the EPCglobal community and a number of extensions, such as the surrogate concept and the vir-tual <b>tag</b> <b>memory</b> service, addresses the majority of the application requirements and limitations of passive RFID technology. Index Terms—EPC network, middleware, radio frequency iden-tification (RFID) ...|$|R
50|$|Designs {{that use}} {{content-addressable}} memory (CAM) are called dynamic dataflow machines. They use <b>tags</b> in <b>memory</b> to facilitate parallelism.|$|R
40|$|Experimental and {{commercial}} parallel machines have matured {{to a point}} where it is possible to quantify the performance enhancement due to the novel mechanisms supporting fine-grain parallel programs in the experimental machines. The MIT J-Machine provides a register-level message send, autonomous message receive and dispatch, a prioritized scheduler with multiple contexts, and <b>tagged</b> <b>memory</b> with fast traps. The Thinking Machines CM- 5 is essentially a collection of conventional processors with user-level messages. However, it is difficult to establish a meaningful workload for a comparison that adequately accounts for compiler optimizations which specifically address the lack of available mechanisms. This paper uses an abstract machine approach in a relative evaluation of the J-Machine and CM- 5. High-level parallel programs are translated by a single optimizing compiler to a fine-grained abstract parallel machine, TAM. The final compilation step is unique to each architecture and optimi [...] ...|$|E
40|$|This paper uses an {{abstract}} machine approach {{to compare the}} mechanisms of two parallel machines: the J-Machine and the CM- 5. High-level parallel programs are translated by a single optimizing compiler to a finegrained abstract parallel machine, TAM. A final compilation step is unique to each machine and optimizes for specifics of the architecture. By determining {{the cost of the}} primitives and weighting them by their dynamic frequency in parallel programs, we quantify the effectiveness of the followingmechanisms individuallyand in combination. Efficient processor/network coupling proves valuable. Message dispatch is found to be less valuable without atomic operations that allow the scheduling levels to cooperate. Multiple hardware contexts are of small value when the contexts cooperate and the compiler can partition the register set. <b>Tagged</b> <b>memory</b> provides little gain. Finally, the performance of the overall system is strongly influenced by the performance of the memory system and the f [...] ...|$|E
40|$|Abstract This paper uses an {{abstract}} machine approach tocompare {{the mechanisms of}} two parallel machines: the J-Machine and the CM- 5. High-level parallel programsare translated by a single optimizing compiler to a finegrained abstract parallel machine, TAM. A final compi-lation step is unique to each machine and optimizes for specifics of the architecture. By determining the cost of theprimitives and weighting them by their dynamic frequency in parallel programs, we quantify the effectiveness of thefollowingmechanisms individually and in combination. Efficient processor/network coupling proves valuable. Mes-sage dispatch {{is found to be}} less valuable without atomic operations that allow the scheduling levels to cooperate. Multiple hardware contexts are of small value when the contexts cooperate and the compiler can partition the reg-ister set. <b>Tagged</b> <b>memory</b> provides little gain. Finally, the performance of the overall system is strongly influenced bythe performance of the memory system and the frequency of control operations. Keywords: Parallel Processing, Performance Analysis, Compilation. ...|$|E
5000|$|... #Caption: The new {{memorial}} <b>tag</b> in <b>memory</b> of Giuseppe Pinelli, as of {{opposed to}} the old one which is also still there ...|$|R
40|$|Abstract. We {{propose to}} enhance EPCglobal RFIDs {{enriching}} them with semantic capabilities. <b>Memory</b> organization of <b>tags</b> {{and the data}} exchange protocol are exploited and extended to the purpose. By design, the proposed enhancements do not alter the basic behavior of protocol and <b>tag</b> <b>memory</b> organization and are thus fully backward compatible. In order to store annotated descriptions a compression algorithm for DIG descriptions has also been devised. We report here results in comparison with other XML-based compression tools and simulations for enhanced tags reading and decompression. ...|$|R
40|$|Abstract. We {{propose to}} extend basic RFID usage by storing semantically {{annotated}} data within RFID <b>tags</b> <b>memory,</b> so that objects may actually “describe themselves ” {{in a variety}} of scenarios. In particular here we exploit our approach to carry out an advanced discovery process using annotations stored in RFIDs. A –fully backward compatible – modification to the original RFID data exchange protocol is presented, integrated in a semantic-enabled Bluetooth resource discovery framework. Motivations and benefits of the approach are outlined in a u–commerce context. ...|$|R
40|$|The Extended Dataflow Architecture (EDA) is a {{synchronization}} {{and communication}} framework for medium-grain parallel environments. In this paper we will touch upon some possibilities for implementing EDA, focussing on using stock hardware. Keywords: Dataflow, Implementation, Parallel processing, Shared data. 1. Introduction EDA is a programming model for parallel systems. The model {{is intended to}} unify long-haul and local communications in parallel systems. EDA has evolved over the years. The next section will introduce EDA as described in [M 92]. In section 3 we consider a current refinement introduced in [T 94]. Section 4 discusses the implementation of <b>tagged</b> <b>memory</b> in some detail, pointing out problems that an implementation must solve. Section 5 touches on some points of similar interest concerning EDA requests, and suggests using Active Messages [E 92] {{as a vehicle for}} these. Section 6 introduces the Threaded Abstract Machine and describes a possible mapping of the EDA model on [...] ...|$|E
40|$|Heavyweight {{security}} analysis systems, such as taint analysis and dynamic type checking, are powerful technologies {{used to detect}} security vulnerabilities and software bugs. Traditional software implementations of these systems have high instrumentation overhead and suffer from significant performance impacts. To mitigate these slowdowns, a few hardware-assisted techniques have been recently proposed. However, these solutions incur a large memory overhead and require hardware platform support {{in the form of}} <b>tagged</b> <b>memory</b> systems and extended bus designs. Due to these costs and limitations, the deployment of heavyweight {{security analysis}} solutions is, as of today, limited to the research lab. In this paper, we describe Testudo, a novel hardware approach to heavyweight security analysis that is based on statistical sampling of a program’s dataflow. Our dynamic distributed debugging reduces the memory overhead to a small storage space by selectively sampling only a few tagged variables to analyze during any particular execution of the program. Our system requires only small hardware modifications: it adds a small sample cache to the main processor and extends the pipeline registers to propagate analysis tags. To gain high analysis coverage, we rely on a population of users to run the program, sampling a different random set of variables during each new run. We show that we can achieve high coverage analysis at virtually no performance impact, even with a reasonably-sized population of users. In addition, our approach even scales to heavyweight debugging techniques by keeping per-user runtime overheads low despite performing traditionally costly analyses. Moreover, the low hardware cost of our implementation allows it to be easily distributed across large user populations, leading to a higher level of security analysis coverage than previously. 1...|$|E
40|$|Lightweigth byte code {{verification}} uses stack maps {{to annotate}} Java byte code programs with type information {{so that the}} byte code verifier (BCV) only has to check this typing, without having to do any data flow analysis. This report describes an improved analysis technique together with algorithms for optimizing the stack maps generated by the analyser. The improved BCV {{is based on a}} modified version of the abstract domain. This domain is simplified in its treatment of base values, keeping only the necessary information to ensure the memory safety property. It is richer in its representation of interface types, using the known Dedekind-MacNeille completion technique to construct abstract domain elements representing sets of interfaces. Tracking interface information allows to remove the dynamic checks at interface method invocations. We prove the memory safety property guaranteed by BCV using an operational semantics whose distinguishing feature is a low-level memory model operating on untagged 32 -bit values, as opposed to the standard, higher-level memory models using <b>tagged</b> <b>memory</b> objects. For bytecode that is typable without sets of types (this includes any code compiled from Java) we show how to prune the fix-point to obtain a stack map that can be validated without the interface set computations arising from this extension. In the context of lightweight verification, this is an advantage as it does not make the verification more complex or costly. The size of the certificates is not significantly modified. Experiments show that the pruning can be done by reasonably efficient (though in theory exponential) algorithms that uses heuristics to explore the space of valid program typings from the least fixpoint generated by the analyser. Stack maps for three substantial test suites were correctly handled by the optimized (but incomplete) pruning algorithm...|$|E
40|$|Radio Frequency Identification (RFID) {{technology}} is an electronic labeling technique. These electronic labels are called tags and read wirelessly. In this thesis a battery and amicroprocessor {{are connected to}} the tag. The work consisted of programming themicroprocessor to transfers sensor data into the <b>tags</b> <b>memory.</b> The <b>tags</b> are placed ontrains and data is collected from sensors at the train's axle. That way sensor data can betransmitted from a train to readers stationed along the railroad tracks. The aim of the project is to predict service intervals. There is currently no possibility tosee wear in real time and stop a train before it breaks. At present, there is a form of heatdetectors located along the railroad tracks to measure temperatures of wheels and axlesof passing trains. These are expensive and have the disadvantage of being able to detecterrors that have already occurred, they can not detect errors that do not radiate heat. The thesis aims to provide a solution for this. By programming a microprocessor totransmit sensor data to the <b>tags</b> <b>memory</b> it is possible for an RFID reader to read thesensor data from the tag. Ensuring that data and identity can be read from the tag atspeeds up to 250 km/h, you can get the status of a trains wagon before it breaks...|$|R
500|$|Metal Gear Solid {{was first}} {{released}} for the PlayStation in Japan on September 3, 1998. The game {{was available in}} a standard edition, {{as well as a}} limited [...] "Premium Package" [...] edition sold in a large box that also contained a t-shirt, a pair of FOXHOUND-themed dog <b>tags,</b> <b>memory</b> card stickers, an audio CD featuring the soundtracks from the MSX2 Metal Gear games (including a few bonus arranged tracks), and a 40-page booklet titled Metal Gear Solid Classified featuring production notes, interviews with the developers, and a glossary of terminology in the game.|$|R
40|$|Accurate garbage {{collection}} of C++ requires that every memory location and ev ery register be known to contain either a pointer or a non-pointer. In order to mini-mize the run-time overhead of <b>tagging</b> <b>memory</b> locations and registers, techniques for partitioning memory and registers into separate classes dedicated independently to {{the representation of}} pointers and non-pointers respectively have been developed. This paper describes the implementation and performance of a specially designed activation frame targeted to the SPARC architecture, as implemented in a customized version of the GNU g++ compiler. 1...|$|R
40|$|Gao, Guang R. The Cray XMT {{supercomputer}} {{system is}} the third generation of the Cray MTA supercomputer architecture. It is a scalable massively multithreaded platform {{which is based on}} the Cray XT infrastructure and uses the Cray massively parallel processing (MPP) system design. The XMT system uses Threadstorm processors which have a global shared memory. A very interesting feature of XMT is that it provides a fine-grain data-centric synchronization for managing concurrency by extending each memory word with tag bits. A tag bit can be in one of two states: full or empty. Cray XMT supports a number of synchronized memory operations to read from and write to <b>tagged</b> <b>memory.</b> A synchronized read/write operation can be suspended if a corresponding memory cell is not in an expected state. For example, a synchronized memory operation can be suspended if it reads from an empty memory address or writes to a full memory address. If in a parallel program a suspended operation can never get to an expected memory state, the operation will be suspended forever. We say that the program/operation is "deadlocked". Although the synchronized operations provide extreme exibility to implement fine-grain parallelization of both regular and irregular applications, it is very easy to get programs into deadlock. And {{due to the lack of}} parallel program debugging tools and runtime support to detect such program deadlocks, it is hard to locate this kind of synchronization errors. So it is important to develop an effective static analysis algorithm which can detect them as early as possible. The typestate analysis is a static program verification technique which can identify illegal operations performed on some objects due to the wrong object state. However, almost all the previous works on typestate analysis only deal with sequential programs and cannot work for concurrent programs. In this thesis we present a new analysis technique, called memory state flow analysis to determine whether a given parallel program with synchronized read/write operations will deadlock. We extend the classical static single assignment (SSA) form with memory state information (called MSSA form) and use that to compute the memory state of each program variable at certain program points. Based on the MSSA form, we perform memory state verification to determine whether a synchronized read or write operation will ever be deadlocked. Our approach can also handle pointer variables and array sections. The main contributions of our work are: (1) a framework to do memory state analysis is built, which catches the main features related to the memory state of parallel programs. (2) a memory state veri cation method to detect a potential program deadlock is developed. Thus, the essentially exponential-complex problem is decoupled and solved using dataflow analysis with simple heuristics, and most program deadlocks problems can be caught by careful heuristics design. We have implemented our analysis using the Open 64 compiler, and we present some preliminary results. The preliminary results show that our memory state flow analysis can detect most of the program deadlock problems. For example we can detect program deadlocks due to unbalanced synchronized operation types, defective operation order, etc. We also include a survey of related work, such as static program veri cation for concurrent systems, program representation and dataflow analysis for parallel programs, typestate analysis, etc. A conclusion and a survey of future work are also presented. University of Delaware, Department of Electrical and Computer EngineeringM. S...|$|E
5000|$|Metal Gear Solid {{was first}} {{released}} for the PlayStation in Japan on September 3, 1998. The game {{was available in}} a standard edition, {{as well as a}} limited [...] "Premium Package" [...] edition sold in a large box that also contained a t-shirt, a pair of FOXHOUND-themed dog <b>tags,</b> <b>memory</b> card stickers, an audio CD featuring the soundtracks from the MSX2 Metal Gear games (including a few bonus arranged tracks), and a 40-page booklet titled Metal Gear Solid Classified featuring production notes, interviews with the developers, and a glossary of terminology in the game.|$|R
40|$|Gadgets {{helping the}} disabled, {{especially}} blind {{that are in}} least accessibility of information, use acoustic methods that can cause stress to ear and infringe user's privacy. Even if some project uses embedded Radio Frequency Identification (RFID) into the sidewalk for blind's free walking, the <b>tag</b> <b>memory</b> design is not specified for buildings and road conditions. This paper suggested allocation scheme of RFID tag referring to EPCglobal SGLN, tactile method for conveying information, and use of lithium battery as power source with solar cells as an alternative. Results have shown independent mobility, accidents prevention, stress relief and satisfied factors in terms of cost and human usability. Comment: 9 pages, 5 figures, Presented at IEOM 201...|$|R
40|$|Data {{acquisition}} processes {{the sampling}} and conditioning the signals that measure real world physical {{conditions such as}} temperature, pressure, flow etc. and convert the signal into in appropriate format for displaying and transmission to remote end. Now a days RFID i. e. Radio Frequency Identification plays {{a vital role in}} Data acquisition system. The present article proposes a smart DAS scheme containing RFID reader and Active tag. The data acquisition system is interfaced with tag through I 2 C bus. The reader communicates with tag following RFID communication protocol requesting to send the logged data which are refreshed and stored into <b>tag</b> <b>memory</b> periodically. The communication is simulated using MATLAB software successfully. ...|$|R
40|$|Abstract:-. This paper {{presents}} {{a survey of}} common security threats which mobile IP networks are exposed to {{as well as some}} proposed solutions to deal with such threats. In a typical RFID (Radio Frequency Identification) system, tags storing a unique identifier and additional data are attached to objects or issued to people. When a tag or a group of tags is placed in the radio frequency field of a reader, the data contained in the <b>tag’s</b> <b>memory</b> can be accessed by the reader. The data are usually preprocessed and passed on to enterprise applications by the RFID middleware. The RFID system, consisting of readers and tags, along with the RFID middleware and the enterprise applications {{is referred to as the}} RFID infrastructure...|$|R
5000|$|MTuner SDK: manual {{instrumentation}} {{of applications}} adds timed events and <b>memory</b> <b>tags.</b> Timed events help distinguish different phases of application execution.|$|R
40|$|AbstractRFID {{technology}} {{is widely used}} in various areas and found to be very useful in the business which includes supply chain management. Also the amount of RFID data is very huge as well. Hence too much time is needed to get particular information from an RFID data set. This paper proposes an efficient method to manage large amount of RFID data set. Also this proposes a unique group-id for RFID tags of unique items {{with which we can}} verify the integrity of the group of items by checking the group-id written in the <b>tag</b> <b>memory.</b> Then we devise a storage scheme called MckoiDDB that can process queries in a distributed environment. Lastly we present a graph called product localization graph to represent the tag movements in supply chain management...|$|R
40|$|Abstract. We {{leverage}} increasing passive RFID <b>tag</b> <b>memory</b> {{to propose}} distributed RFID tag storage infrastructures (D-RFID stores). A D-RFID store {{is a large}} set of tags with significantly sized re-writeable storage. Interrogators interact with D-RFID stores by reading from and writing to tags, providing {{a wide range of}} possible applications that are otherwise resource-inefficient. Examples include tagging trees in a forest to track hikers, interactive smart posters to provide location-based social interaction and collaboration, and tags transporting digital information in situations where reliable network connectivity is not available. We propose a system architecture for D-RFID stores by describing the tag distribution in space and time, different storage structures, and the middleware linking the different components together. We also describe assurance in our system. We motivate D-RFID stores through examples and describe potential avenues of research. ...|$|R
40|$|This study {{describes}} {{the characteristics of}} data tampering in RFID-based information systems and a method addressing it is proposed using hashing techniques in mobile RFID environment. The proposed method requires only hash, XOR and simple calculations but can provide good {{security and privacy protection}} features. Mobile RFID-enhanced applications (Mobile RFID) offer a unique way of interacting with the physical world by using the touch paradigm. They offer an intuitive way to interact with physical objects to which RFID transponders are attached. However, the development of mobile RFID applications is not well supported yet, in contrast to stationary RFID applications because of security and privacy related issues. A critical threat for Mobile RFID based information systems is represented by data tampering which corresponds to the malicious alteration of data recorded in the <b>tag</b> <b>memory...</b>|$|R
40|$|Register Allocation for Accurate Garbage Collection of C++ S. Satishkumar* M. S. Creative Component Accurate garbage {{collection}} of C++ requires that every memory location and every register be known to contain either a pointer or a non-pointer. In {{order to minimize}} the run-time overhead of <b>tagging</b> <b>memory</b> locations and registers, techniques for partitioning memory and registers into separate classes dedicated independently to the representation of pointers and non-pointers respectively have been developed. This paper describes the implementation and performance of a specially designed register allocator for the GNU g++ compiler. * Portions of this paper were excerpted from 2 ̆ 2 Code Generation to Support Efficient Accurate Garbage Collection of C++ on Stock Hardware 2 ̆ 2, a paper currently being prepared for publication by Kelvin Nilsen, Ravichandran Ganesan, Satish Guggilla, Satish Kumar, and Kannan Narasimha...|$|R
5000|$|<b>Memory</b> <b>tag</b> trees: {{allocations}} can {{be categorized}} through manual instrumentation and a breakdown of memory usage per tag/category is displayed in a hierarchical tree structure.|$|R
40|$|In Indonesia {{it is easy}} to {{tell who}} works for an {{international}} NGO for they stand out with their organisational <b>tags</b> and <b>memory</b> sticks. Many Indonesians crave jobs with international NGOs (INGO s) but do these organisations transfer knowledge and skills to local NGOs? Or do they simply poach their staff and undermine voluntarism...|$|R
