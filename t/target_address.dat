121|1139|Public
25|$|NTP {{has been}} used in {{distributed}} denial of service (DDoS) attacks. A small query is sent to an NTP server with the return address spoofed to be the <b>target</b> <b>address.</b> Similar to the DNS amplification attack, the server responds with a much larger reply that allows an attacker to substantially increase the amount of data being sent to the target. To avoid participating in an attack, servers can be configured to ignore external queries, or they can be upgraded to version 4.2.7p26 or later.|$|E
25|$|Finding {{the nearest}} branch of an {{organisation}} {{to a given}} address. A computer program uses the postal codes of the <b>target</b> <b>address</b> and the branches to list the closest branches in order of distance {{as the crow flies}} (or, if used in conjunction with streetmap software, road distance). This can be used by companies to inform potential customers where to go, by job centres to find jobs for job-seekers, to alert people of town planning applications in their area, and a great many other applications.|$|E
2500|$|A PCI bus {{transaction}} {{begins with}} an address phase. [...] The initiator, seeing that it has GNT# and the bus is idle, drives the <b>target</b> <b>address</b> onto the AD lines, the associated command (e.g. memory read, or I/O write) on the C/BE# lines, and pulls FRAME# low.|$|E
50|$|BCJ - Converter for 32-bit x86 executables. Normalise <b>target</b> <b>addresses</b> of near {{jumps and}} calls from {{relative}} distances to absolute destinations.|$|R
40|$|Static {{analysis}} {{requires the}} full {{knowledge of the}} overall program structure. The structure of a program can be represented by a Control Flow Graph (CFG) where vertices are basic blocks (BB) and edges represent the control flow between the BB. To construct a full CFG, all the BB {{as well as all}} of their possible <b>targets</b> <b>addresses</b> must be found. In this paper, we present a method to resolve dynamic branches, that identifies the <b>target</b> <b>addresses</b> of BB created due to the switch-cases and calls on function pointers. We also implemented a slicing method to speed up the overall analysis which makes our approach applicable on large and realistic real-time programs...|$|R
5000|$|The Sargent patent {{describes}} the <b>target</b> <b>addresses</b> of other pages as being {{stored in a}} second sub-block attached to the content for display. The court {{found no evidence that}} the Internet functions like this. For example, it analysed the following example of HTML code: ...|$|R
5000|$|... relationship, {{description}} of the <b>target</b> <b>address</b> in an anchor-element (...) ...|$|E
5000|$|If the <b>target</b> <b>address</b> {{is in the}} bitmap, return {{without an}} error.|$|E
5000|$|If the <b>target</b> <b>address</b> {{is not in}} the bitmap, {{terminate}} the program.|$|E
50|$|As the {{predictor}} RAM can be 5-10% {{of the size}} of the instruction cache, the fetch happens much faster than the instruction cache fetch, and so this recurrence is much faster. If it were not fast enough, it could be parallelized, by predicting <b>target</b> <b>addresses</b> of <b>target</b> branches.|$|R
40|$|Constructing the control-flow graph (CFG) {{of machine}} code is made {{difficult}} by dynamic transfers of control (DTC), where {{the address of}} the next instruction is computed at run-time. Switchcase statements make compilers generate a large variety of machine-code forms with DTC. Two analysis approaches are commonly used: pattern-matching methods identify predefined instruction patterns to extract the <b>target</b> <b>addresses,</b> while analytical methods try to compute the set of <b>target</b> <b>addresses</b> using a general value-analysis. We tested the abstract execution method of the SWEET tool as a value analysis for switch-case code. SWEET is here used as a plugin to the Bound-T tool: thus our work can also be seen as an experiment in modular tool design, where a general value-analysis tool is used to aid the CFG construction in a WCET analysis tool. We find that the abstract-execution analysis works at least as well as the switch-case analyses in Bound-T itself, which are mostly based on pattern-matching. However, there are still some weaknesses: the abstract domains available in SWEET are not well suited to representing sets of DTC <b>target</b> <b>addresses,</b> which are small but sparse and irregular. Also, in some cases the abstract-execution analysis fails because the used domain is not relational, that is, does not model arithmetic relationships between the values of different variables. Future work will be directed towards the design of abstract domains eliminating these weaknesses...|$|R
5000|$|<b>Target</b> {{protocol}} <b>address</b> (TPA): Internetwork {{address of}} the intended receiver.|$|R
5000|$|Convert the <b>target</b> <b>address</b> to an offset and bit {{number in}} the bitmap.|$|E
5000|$|To {{set a new}} jump {{target for}} VVBLKD (Deferred) set the Y {{register}} to the low byte of the <b>target</b> <b>address,</b> the X register to the high byte of the <b>target</b> <b>address,</b> and the Accumulator to 7, then JSR SETVBV.. The user code called through VVBLKD must exit by jumping to the OS Vertical Blank exit routine with a JMP XITVBV ($E462hex/58466dec).|$|E
5000|$|To {{set a new}} jump {{target for}} VVBLKI (Immediate) set the Y {{register}} to the low byte of the <b>target</b> <b>address,</b> the X register to the high byte of the <b>target</b> <b>address,</b> and the Accumulator to 6, then JSR SETVBV. The user code called through VVBLKI simply needs to exit by jumping to the OS Vertical Blank with a JMP SYSVBV ($E45Fhex/58463dec).|$|E
40|$|Abstract One of the {{fundamental}} problems with the analy-sis of binary (executable) code is that of recognizing, in a machine-independent way, the <b>target</b> <b>addresses</b> ofn-conditional branches implemented via a jump table. Without these addresses, the decoding of the machineinstructions for a given procedure is incomplete, {{as well as any}} analysis on that procedure. In this paper we present a technique for recover-ing jump tables and their <b>target</b> <b>addresses</b> in a machine and compiler independent way. The technique isbased on slicing and expression substitution. The assembly code of a procedure that contains an indexedjump is transformed into a normal form which allows us to determine where the jump table is located andwhat information it contains (e. g. offsets from the table or absolute addresses). The presented technique has been tested on SPARCand Pentium code generated by C, C++, Fortran an...|$|R
2500|$|<b>Target</b> 8B: <b>Address</b> the Special Needs of the Least Developed Countries (LDCs) ...|$|R
50|$|KWP2000 can be {{implemented}} on CAN using just the service layer and session layer (no header specifying length, source and <b>target</b> <b>addresses</b> is used and no checksum is used); or using all layers (header and checksum are encapsulated within a CAN frame). However using all layers is overkill, as ISO 15765 provides its own Transport/Network layers.|$|R
5000|$|... op | <b>target</b> <b>address</b> [...] 2 1024 decimal 000010 00000 00000 00000 10000 000000 binary ...|$|E
50|$|The PA-8000 has a two-cycle bubble for {{correctly}} predicted branches, as the <b>target</b> <b>address</b> of {{the branch}} must be calculated before it {{is sent to the}} instruction cache. To reduce the occurrence of this bubble, the PA-8000 uses a 32-entry fully associative BTAC. The BTAC caches a branch's <b>target</b> <b>address.</b> When the same branch is encountered, and is predicted as taken, the address is sent to the instruction cache immediately, allowing the fetch to begin without delay.|$|E
5000|$|... 6 5 5 5 5 6 bits op | rs | rt | rd |shamt| funct R-type op | rs | rt | address/immediate I-type op | <b>target</b> <b>address</b> [...] J-type ...|$|E
50|$|The {{limited range}} of the branch {{instructions}} meant that, as code grew, the <b>target</b> <b>addresses</b> of some branches would become unreachable. The programmer would change the one-word BR to the two-word JMP instruction from the next group. As JMP has no conditional forms, the programmer would change BEQ to a BNE that branched around a JMP.|$|R
50|$|G.hn {{supports}} {{the concept of}} relays, in which one device can receive a message from one node and deliver it to another node farther away in the same domain. Relaying provides for utilizability of multiple transport media and complex network topologies. While a relay can read the source and <b>target</b> <b>addresses,</b> it cannot read the message's content due to its body being end-to-end-encrypted.|$|R
40|$|This paper {{discusses}} {{the effects of}} using a trace cache on the indirect branch prediction in ILP processors. The main contribution of the paper is {{an exploration of the}} fact that the trace cache captures context information about the recent control flow of the program, which can improve the accuracy of predictors that do not themselves explicitly use such information. We analyze and experiment with various trace cache configurations and strategies to measure their effects on indirect branch prediction accuracy. We show that updating indirect branch <b>target</b> <b>addresses</b> in the trace cache improves indirect branch prediction accuracy. Then, we incrementally vary the trace cache configuration such as applying trace packing, adding 2 -bit update counters per trace cache line, varying trace cache set associativity, cache size and cache line size in order to observe the impact of each configuration on the indirect branch prediction. We simulate a wide variety of designs using benchmarks with higher than average numbers of indirect branches. Our experimental results show that the harmnonic mean indirect branch prediction accuracy for a processor model with a trace cache that updates indirect branch <b>target</b> <b>addresses</b> is 42. 04 %, compared to 28. 82 % for a model with a trace cache that does not update indirect branch <b>target</b> <b>addresses,</b> and 10. 85 % for a model with a branch target buffer on our benchmarks. Our results have implications for any hardware predictor which stores entries corresponding to (possibly replicated) instructions in the trace cache rather than original instructions in main memory. 1...|$|R
50|$|Email bombing is the {{intentional}} sending of {{large volumes of}} messages to a <b>target</b> <b>address.</b> The overloading of the target email address can render it unusable and can even cause the mail server to crash.|$|E
5000|$|Writing to the {{instruction}} pointer is simple — a [...] instruction sets {{the instruction}} pointer to the <b>target</b> <b>address,</b> so, for example, a sequence like the following will put the contents of [...] into : ...|$|E
5000|$|In {{computer}} programming, a wild {{branch is}} a GOTO instruction where the <b>target</b> <b>address</b> is indeterminate, random or otherwise unintended. It {{is usually the}} result of a software bug causing the accidental corruption of a pointer or array index. It is [...] "wild" [...] {{in the sense that it}} cannot be predicted to behave consistently. Detection of wild branches is frequently difficult; they are normally identified by erroneous results (where the unintended <b>target</b> <b>address</b> is nevertheless a valid instruction enabling the program to continue despite the error) or a hardware interrupt, which may change depending upon register contents. Debuggers and monitor programs such as Instruction set simulators can sometimes be used to determine the location of the original wild branch.|$|E
2500|$|<b>Target</b> 8C: <b>Address</b> {{the special}} needs of {{landlocked}} developing countries and small island developing States ...|$|R
40|$|In this paper, {{we present}} a Branch Target Buffer (BTB) design for energy savings in set-associative {{instruction}} caches. We extend the functionality of a BTB by caching way predictions in addition to branch <b>target</b> <b>addresses.</b> Way prediction and branch target prediction are done in parallel. Instruction cache energy savings are achieved by accessing one cache way if the way prediction for a fetch is available...|$|R
40|$|One of the {{fundamental}} problems with the analysis of binary (executable) code is that of recognizing, in a machine-independent way, the <b>target</b> <b>addresses</b> of n-conditional branches implemented via a jump table. Without these addresses, the decoding of the machine instructions for a given procedure is incomplete, {{as well as any}} analysis on that procedure. In this paper we present a technique for recovering jump tables and their <b>target</b> <b>addresses</b> in a machine and compiler independent way. The technique is based on slicing and expression substitution. The assembly code of a procedure that contains an indexed jump is transformed into a normal form which allows us to determine where the jump table is located and what information it contains (e. g. offsets from the table or absolute addresses). The presented technique has been tested on SPARC and Pentium code generated by C, C++, Fortran and Pascal compilers. Our tests show that up to 90 % more of the code in a text segment can be found by usin [...] ...|$|R
50|$|A PCI bus {{transaction}} {{begins with}} an address phase. The initiator, seeing that it has GNT# and the bus is idle, drives the <b>target</b> <b>address</b> onto the AD31:0 lines, the associated command (e.g. memory read, or I/O write) on the C/BE3:0# lines, and pulls FRAME# low.|$|E
50|$|The node {{joins the}} solicited-node {{multicast}} address for the tentative address (if not already done so) and sends neighbor solicitations, with the tentative address as <b>target</b> <b>address</b> and the unspecified address (::/128) as source address. The node also joins the all-hosts multicast address ff02::1, {{so it will}} be able to receive Neighbor Advertisements.|$|E
5000|$|Simulation {{is the use}} of a {{monitoring}} program to interpret the machine code instructions of some computer architectures. Such an instruction set simulator can provide memory protection by using a segmentation-like scheme and validating the <b>target</b> <b>address</b> and length of each instruction in real time before actually executing them. The simulator must calculate the <b>target</b> <b>address</b> and length and compare this against a list of valid address ranges that it holds concerning the thread's environment, such as any dynamic memory blocks acquired since the thread's inception, plus any valid shared static memory slots. The meaning of [...] "valid" [...] may change throughout the thread's life depending upon context. It may sometimes be allowed to alter a static block of storage, and sometimes not, depending upon the current mode of execution, {{which may or may not}} depend on a storage key or supervisor state.|$|E
40|$|High-performance byte copying is {{important}} for many operating systems {{because it is the}} principle method used for transferring data between kernel and user protection domains. For example, byte copying is commonly used for transferring data from kernel bu ers to user bu ers during le system read and IPC recv calls and to kernel bu ers from user bu ers during write and send calls. Because of its impact on overall system performance, commercial operating systems tend to employ many specialized byte copy routines, each one optimized for a di erent circumstance. This paper revisits the opportunities for optimizing byte copy performance by discussing a series of experiments run under HP-UX 9. 03 on a range of Hewlett-Packard PA-RISC processors. First, we compare the performance improvements that result from several existing byte copy optimizations. Then we showthatbyte copy performance is dominated by cache e ects that arise when source and <b>target</b> <b>addresses</b> overlap. Finally, we discuss the opportunities and di culties associated with choosing appropriate source and <b>target</b> <b>addresses</b> to optimize byte copy performance. ...|$|R
40|$|Modern {{high-performance}} processors {{access the}} branch target buffer (BTB) every cycle to speculate branch <b>target</b> <b>addresses.</b> This aggressive approach improves performance as {{it results in}} early identification of <b>target</b> <b>addresses.</b> However, unfortunately, such accesses, quite often, are unnecessary {{as there is no}} control flow instruction among those fetched. In this work we introduce Speculative BTB Access (SABA) to address this design inefficiency. SABA relies on a simple power efficient structure, referred to as the SABAfilter, to identify cycles where there is no control flow instruction among those fetched, at least one cycle in advance. By identifying such cycles and eliminating unnecessary BTB accesses we reduce BTB’s power dissipation (and therefore power density). SABA comes with zero timing overhead as it makes decisions regarding future cycles and therefore does not impact critical path delay. Our study shows that, by using SABA, it is possible to eliminate {{more than half of the}} unnecessary BTB accesses while paying a very low performance cost (average: 0. 7 %). We also study how variations in SABA-filter configuration, branch predictor configuration and processor execution bandwidth impact power savings and performance slowdown for a SABAenhanced processor. ...|$|R
50|$|Address space {{randomization}} hinders {{some types}} of security attacks by {{making it more difficult}} for an attacker to predict <b>target</b> <b>addresses.</b> For example, attackers trying to execute return-to-libc attacks must locate the code to be executed, while other attackers trying to execute shellcode injected on the stack have to find the stack first. In both cases, the system obscures related memory-addresses from the attackers. These values have to be guessed, and a mistaken guess is not usually recoverable due to the application crashing.|$|R
