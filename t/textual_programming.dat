103|75|Public
50|$|However, {{criticisms of}} the limit include {{that it is not}} clear whether a similar limit also exists in <b>textual</b> <b>programming</b> languages; and that the limit could be {{overcome}} by applying modularity to visual programming as is commonly done in <b>textual</b> <b>programming.</b>|$|E
50|$|When {{events were}} added to classes it enabled rapid {{application}} development, especially the visual development of graphic user interface. But event handling is still expressed via <b>textual</b> <b>programming</b> languages.|$|E
5000|$|Part 3 of IEC 61131 {{deals with}} basic {{software}} architecture and programming languages {{of the control}} program within PLC. It defines two graphical and two <b>textual</b> <b>programming</b> language standards: ...|$|E
40|$|Hyper-{{programming}} is a {{style of}} programming applicable to strongly typed persistent systems [ABC+ 83], in which a source program may contain direct links to language values as well as <b>textual</b> <b>program</b> constructs. It represents a form of hyper-media [EE 68, YMV 85, Bro 86, Big 88, Shn 89, DMD 92] applied to the program development process, in which th...|$|R
40|$|This paper {{describes}} the design, implementation and first {{application of a}} new haptic programming language design paradigm currently being developed at the School of Design of the Hong Kong Polytechnic University. This abstract toolkit provides means for flexible translations of tangible models into <b>textual</b> <b>programs.</b> It is most useful for learning environments (“microworlds”) with tangible outputs...|$|R
40|$|This paper {{describes}} a thesis project {{in which a}} visually-oriented design utility is constructed in Interlisp-D for the Xerox 1108 Artificial Intelligence Workstation. This utility aids {{in the design of}} Regular Expression Parsers by visually simulating the operation of a parser. A <b>textual</b> <b>program,</b> suitable for utilization in the construction of a compiler scanner or other similar processor may be produced by the utility...|$|R
5000|$|The idea of Limnor codeless {{programming}} {{is to add}} [...] "Actions" [...] to classes. Adding actions to classes eliminates the need of <b>textual</b> <b>programming</b> languages, making codeless visual general purpose programming possible without sacrificing programming power.|$|E
50|$|Flowcode is a Microsoft Windows-based {{development}} environment commercially produced by MatrixTSL for programming embedded {{devices such as}} PIC, AVR (including Arduino) and ARM using flowcharts instead of a <b>textual</b> <b>programming</b> language. It is currently in its seventh revision.|$|E
5000|$|G {{language}} being non-textual, {{software tools}} such as versioning, side-by-side (or diff) comparison, and version code change tracking cannot be applied {{in the same manner}} as for <b>textual</b> <b>programming</b> languages. There is some additional tool to make comparison and merge of code with source code control (versionning) like subversion, CVS, Perforce.|$|E
5000|$|... #Caption: Example of a <b>textual</b> {{analysis}} <b>program</b> {{being used}} to study a novel, with Jane Austen's Pride and Prejudice in Voyant Tools ...|$|R
25|$|As {{a common}} feature, Islamic {{architecture}} {{makes use of}} specific ornamental forms, including mathematically complicated, elaborate geometric and interlace patterns, floral motifs like the arabesque, and elaborate calligraphic inscriptions, which serve to decorate a building, specify {{the intention of the}} building by the selection of the <b>textual</b> <b>program</b> of the inscriptions. For example, the calligraphic inscriptions adorning the Dome of the Rock include quotations from the Quran (e.g., Quran 19:33–35) which reference the miracle of Jesus and his human nature.|$|R
40|$|This {{thesis is}} centred around the {{question}} of how dynamic pictures can be created and manipulated directly, analogous to drawing images, in an attempt to overcome traditional abstract <b>textual</b> <b>program</b> representations and interfaces (coding). To explore new ideas, Vogo 1 is presented, an experimental, spatially-oriented, direct manipulation, live programming environment for Logo Turtle Graphics. It allows complex abstract shapes to be created entirely on a canvas. The interplay of several interface design principles is demonstrated to encourage exploration, curiosity and serendipitous discoveries. By reaching out to new programmers, this thesis seeks to question established programmin...|$|R
50|$|Many {{graphing}} {{and scientific}} calculators will tokenize the program text, replacing <b>textual</b> <b>programming</b> elements with short numerical tokens. Many graphical calculators work much like computers and use versions of 7-bit, 8-bit or 9-bit ASCII-derived character sets or even UTF-8 and Unicode. Many {{of them have}} a tool similar to the character map on Windows.|$|E
5000|$|The syntax of <b>textual</b> <b>programming</b> {{languages}} {{is usually}} defined {{using a combination}} of regular expressions (for lexical structure) and Backus-Naur form (for grammatical structure) to inductively specify syntactic categories (nonterminals) and terminal symbols. Syntactic categories are defined by rules called productions, which specify the values that belong to a particular syntactic category. Terminal symbols are the concrete characters or strings of characters (for example keywords such as define, if, let, or void) from which syntactically valid programs are constructed.|$|E
50|$|PLCopen {{was founded}} in 1992 just after the world wide {{programming}} standard IEC 61131-3 was published. The controls market {{at that time was}} a very heterogeneous market with different types of programming methods for many different PLCs. The IEC 61131-3 is a standard defining the programming languages for PLCs, embedded controls, and industrial PCs, harmonizing applications independent from specific dialects, but still based on known methods such as the <b>textual</b> <b>programming</b> languages Instruction List, and Structured Text, the graphical programming languages Function Block Diagram and Ladder Diagram (a.k.a. Ladder logic), and the structuring tool Sequential Function Chart.|$|E
40|$|It {{is often}} the case that systems are "nearly symmetric"; they exhibit {{symmetry}} in a part of their description but are, nevertheless, globally asymmetric. We formalize several notions of near symmetry and show how to obtain the benefits of symmetry reduction when applied to asymmetric systems which are nearly symmetric. We show that for some nearly symmetric systems it is possible to perform symmetry reduction and obtain a bisimilar (up to permutation) symmetry reduced system. Using a more general notion of "sub-symmetry" we show how to generate a reduced structure that is simulated (up to permutation) by the original asymmetric program. In the symbolic model checking paradigm, representing the symmetry reduced quotient structure entails representing the BDD for the orbit relation. Unfortunately, for many important symmetry groups, including the full symmetry group, this BDD is provably always intractably large, of size exponential in the number of bits in the state space. In contrast, under the assumption of full symmetry, we show {{that it is possible to}} reduce a <b>textual</b> <b>program</b> description of a symmetric system to a <b>textual</b> <b>program</b> description of the symmetry reduced system. This obviates the need for building the BDD representation of the orbit relation on the program states under the symmetry group. We establish that the BDD representing the reduced program is provably small, essentially polynomial in the number of bits in the state space of the original program. ...|$|R
40|$|Abstract. Constraint Handling Rules (CHR) is a concurrent, committed-choice, {{rule-based}} language. Recently it {{was shown}} that programs for standard (operational) semantics can be interpreted in a parallel computation model. As case study, the classical, imperative, parallel, and non-confluent preflow-push algorithm is implemented in CHR for refined and for standard semantics. 1 Introduction Constraint Handling Rules (CHR) [5] is a concurrent, committed-choice, rule-based language whichwas originally developed for rapid prototyping and for writing constraint solvers. The operational semantics of a CHR program is given by a state transition system and comes in different flavours. In refined (operational) semantics, the constraints in a state are evaluated from left-to-rightand rules are tried in <b>textual</b> <b>program</b> order. Concrete implementations, like SICStus Prolog wit...|$|R
40|$|In this paper, {{we propose}} the GRIX system, {{which is a}} visual {{programming}} system specified for interprocessor communications in parallel computing. We will outline the system and explain its Graphical User Interface (GUI) based operations. GUI-based operations enable users to input the structure of interprocessor communications with intuitive images. Using this system to generate code eliminates user tasks of translation from images produced by users into <b>textual</b> <b>program</b> codes. Moreover, most programmers construct the pictorial images of communications' behavior on paper or in their minds, when faced with interprocessor communications during parallel programming. By adopting the GUI interaction {{with the sense of}} the programmers' pictorial tracing, this system can provide an e#ective programming environment for most programmers...|$|R
50|$|In {{the image}} above we see three {{free-floating}} parameters that are {{hooked up to}} a subtraction component. The two yellow boxes on the left both define a set of numeric constants. The top-most panel contains four integers (6, 7, 8 and 12) while the bottom-most panel contains only a single value. These floating parameters supply the subtraction component with input data, which results in four output values (6-5=1, 7-5=2, 8-5=3 and 12-5=7). The same result can be achieved using textual expressions and an evaluator component. In this fashion Grasshopper allows users to combine both visual and <b>textual</b> <b>programming</b> within the same environment.|$|E
5000|$|The next era began {{about the}} time of the {{publication}} of [...] "Introduction to VLSI Systems" [...] by Carver Mead and Lynn Conway in 1980. This ground breaking text advocated chip design with programming languages that compiled to silicon. The immediate result was a considerable increase in the complexity of the chips that could be designed, with improved access to design verification tools that used logic simulation. Often the chips were easier to lay out and more likely to function correctly, since their designs could be simulated more thoroughly prior to construction. Although the languages and tools have evolved, this general approach of specifying the desired behavior in a <b>textual</b> <b>programming</b> language and letting the tools derive the detailed physical design remains the basis of digital IC design today.|$|E
40|$|In {{this paper}} we compare visual and <b>textual</b> <b>programming</b> {{languages}} for generative design. We argue that, in the past, this comparison has been flawed {{and that it}} is now time to reconsider the potential of the <b>textual</b> <b>programming</b> paradigm but using modern programming languages and development environments specifically targeted to the generative design domain. We present VisualScheme as a prime example of such language and we compare it with the most used visual programming language in the generative design field...|$|E
40|$|The {{problem of}} forward {{abstract}} interpretation of normal logic programs {{has not been}} formally addressed in the literature although negation as failure is dealt with through the built-in predicate ! {{in the way it}} is implemented in Prolog. This paper proposes a solution to this problem by deriving two generic fixed-point abstract semantics F^b and F^ for forward abstract interpretation of normal logic programs. F^b is intended for inferring data descriptions for edges in the program graph where an edge denotes the possibility that the control of execution transfers from its source program point to its destination program point. F^ is derived from F^b and is intended for inferring data descriptions for <b>textual</b> <b>program</b> points. Comment: 39 page...|$|R
40|$|Typical text editors allow "Free Typing" (syntax/semantics-free editing) to {{construct}} and maintain <b>textual</b> <b>programs</b> rapidly and easily by expert programmers, but this style does not support novice programmers learning the syntax and semantics of a language. On the other hand, visual editors enforce correct construction of programs using syntax-directed editing. Additionally, they clearly represent the program flow in a visual way. Both textual and visual editors have pros and cons for learners and experts. This paper argues that an editor that offers both a visual and a textual representation {{of the program in}} tandem has advantages to offer both learner and expert programmers. It describes the editor, HASKEU, which embodies this principle by providing visual and textual support for editing Haskell functional programs...|$|R
40|$|The {{ability to}} report {{syntactic}} errors and {{to recover from}} them are basic requirements for any programming environment where programs are parsed before execution. Advanced error handling techniques are standard tools when processing <b>textual</b> <b>programs,</b> whereas {{in the context of}} visual languages the problem is factually unexplored. In this work, we develop an error recovery strategy for the parsing algorithm for atomic relational grammars originally developed by K. Wittenburg. We present a definition of parser defined syntax errors for Wittenburg's parser by analyzing the possible parsing action failures and by showing how an explicit parse trace can be constructed to locate the errors. Then, we present two error recovery techniques, describe how they are integrated to the parser, and discuss further directions...|$|R
40|$|Novices face many {{barriers}} when {{learning to}} program a computer, including {{the need to}} learn both a new syntax and a model of computation. By constraining syntax and providing concrete visual representations on which to operate, direct manipulation programming environments can potentially lower these barriers. However, what if the ultimate learning goal of the novice {{is to be able}} to program in conventional textual languages, as is the case for introductory computer science students? Can direct manipulation programming environments lower the initial barriers to programming, and, at the same time, facilitate positive transfer to <b>textual</b> <b>programming?</b> To address this question, we designed a new direct manipulation programming interface for novices, and conducted an experimental study to compare the programming processes and outcomes promoted by the direct manipulation interface against those promoted by a <b>textual</b> <b>programming</b> interface. We found that the direct manipulation interface promoted significantly better initial programming outcomes, positive transfer to the textual interface, and significant differences in programming processes. Our results show that direct manipulation interfaces can provide novices with a “way in ” to traditional <b>textual</b> <b>programming...</b>|$|E
40|$|Evolutionary {{developmental}} design (Evo-Devo-Design) is {{a design}} method that combines complex developmental techniques with an evolutionary optimisation techniques. In order {{to use such}} methods, the problem specific developmental and evaluation procedures typically need to be define using some kind of <b>textual</b> <b>programming</b> language. This paper reports on an alternative approach, in which designers can use Visual Dataflow Modelling (VDM) instead of <b>textual</b> <b>programming.</b> This research described how Evo-Devo-Design problems can defined using the VDM approach, {{and how they can}} subsequently be run using a Distributed Execution Environment (called Dexen) on multiple computers in parallel. A case study is presented, where the Evo-Devo-Design method is used to evolve designs for a house, optimised for daylight, energy consumption, and privacy...|$|E
40|$|Software for {{designing}} structured {{objects such as}} machinery and buildings originated from drawing or drafting, and has evolved into suites of applications for different aspects of design. Modern CAD software usually consists of sophisticated tools for graphically building multidimensional models, together with <b>textual</b> <b>programming</b> languages for dealing with tasks such as specifying parametrised constructs or complex relationships between components. This dichotomy between design with graphics and programming with text divides the users of such systems into two groups with quite different skills. Programming languages, on the other hand, have evolved in the opposite direction, from purely textual descriptions of algorithms and data, to formalisms that rely primarily on graphics. This {{has led to the}} conjecture that the usability of design software might be improved by replacing their <b>textual</b> <b>programming</b> facilities by visual programming. Previously we presented a preliminary pro [...] ...|$|E
40|$|Research {{into the}} {{psychology}} of programming has been mostly related to <b>textual</b> <b>programs.</b> The application {{of the theory of}} programming to visual programs could be further supported by empirical evidence. Graphical readership, a skill that cannot be ignored in visual programming, has been little explored; similarly the case with regard to the effect of paradigm shift on novice programmers. Our research addresses some of these issues. This paper presents empirical evidence drawn from our experiments of first year students interacting with graphical programs. Results of these experiments provide support for the match-mismatch hypothesis, a control flow bias among novice programmers, and the possibility that prior experience with construction toys such as Lego is one of the determinants for graphical readership...|$|R
40|$|Inverse {{computation}} {{has many}} {{applications such as}} serialization/deserialization, providing support for undo, and test-case generation for software testing. In this paper, we propose an inverse computation method that always terminates for a class of functions known as parameter-linear macro tree transducers, which involve multiple data traversals {{and the use of}} accumulations. The key to our method is the observation that a function in the class can be regarded as a non-accumulative context-generating transformation without multiple data traversals. Accordingly, we demonstrate that it is easy to achieve terminating inverse computation for the class by context-wise memoization of the inverse computation results. We also show that when we use a tree automaton to express the inverse computation results, the inverse computation runs in time polynomial {{to the size of the}} original output and the <b>textual</b> <b>program</b> size...|$|R
5000|$|Subtext {{programs}} are declared and manipulated (or mutated) by adding and linking elements {{of various types}} to a syntax tree, and entering in values or names as necessary, as opposed to typing out <b>textual</b> <b>programs.</b> Due {{to the design of}} the Subtext language and environment, there is no distinction between a program's representation and its execution. Like spreadsheets, Subtext {{programs are}} live executions within an environment and runtime, and programming is direct manipulation of these executions via a graphical environment. Unlike typical functional programming languages, Subtext has simple semantics and is easily applicable to reactive systems that require mutable state, I/O, and concurrency, under a model known as [...] "Reactive Programming". Console input ("invocations") can be utilized via data flow within a Subtext program, allowing users to manipulate values interactively.|$|R
40|$|An {{optimizing}} compiler {{consists of}} a front end parsing a <b>textual</b> <b>programming</b> language into an inter-mediate representation (IR), a middle end performing optimizations on the IR, and a back end lowering the IR to a target representation (TR) built of operations supported by the target hardware. In mod-ern compiler construction graph-based IRs are employed. Optimization and lowering tasks can then b...|$|E
40|$|The {{design of}} digital {{circuits}} has {{much in common}} withthe design of software structures. Like programming language systems, digital design systems must have expressivepower sufficient for representing any circuit. Since specifying complex circuits requires repetitive and conditionalstructures analogous to iteration, recursion and conditionals in programs, languages for designing complex devicesare usually based on <b>textual</b> <b>programming</b> languages, as with the hardware description languag...|$|E
40|$|Modelica is an a-causal, {{equation}} based, {{object oriented}} modeling language for modeling and efficient simulation of large and complex multi domain systems. The Modelica language, with its strong software component model, {{makes it possible}} to use visual component programming, where large complex physical systems can be modeled and composed in a graphical way. One tool with support for both graphical modeling, <b>textual</b> <b>programming</b> and simulation is MathModelica...|$|E
40|$|Electronic Program Guides (EPGs) are {{systems that}} allow users of media applications, such as web TVs, to {{navigate}} scheduling information about current and upcoming programming. Personalized EPGs help users to overcome information overload in this domain, by exploiting recommender systems that automatically compile lists of novel and diverse video assets, based on implicitly or explicitly defined user preferences. In this paper we introduce {{the concept of}} personal channel, on which Personalized EPGs are grounded, that provides users with potentially interesting programs and videos, by exploiting program genres (documentary, sports, â 8 ̆ 0 ¦) and short <b>textual</b> descriptions of <b>programs</b> to find and categorize them. We investigate the problem of adopting appropriate algorithms for TV-program classification and retrieval, {{in the context of}} building personal channels, which is harder than a classical retrieval or classification task because of the short text available. The approach proposed to overcome this problem is the adoption of a new feature generation technique that enriches the <b>textual</b> <b>program</b> descriptions with additional features extracted from Wikipedia. Results of the experiments show that our approach actually improves the retrieval performance, while a limited positive effect is observed on classification accuracy...|$|R
40|$|We {{introduce}} a new visual programming system PrologSpace. The system addresses classic issues of visual interfaces: layout, shape, colour, and iconography; and those of particular concern to visual programming: multiple views (visual abstractions), synchronised views, integration of visual and textual dimensions, visual debugging, cognitive dimensions, and the problems of scale. We briefly describe the system and how it provides synchronised multiple views. KEYWORDS Visual programming, multiple views, Prolog. INTRODUCTION PrologSpace {{is an extension of}} a Prolog language implementation ([Hut 90]) and a visual environment for application programmers. We have added to Prolog's standard system commands to provide: ffl support for X windows, ffl widget creation and management ([Fou 91]), ffl 3 -D graphics and animation ([Gra 94]), ffl audio. These extra language features are made available to the programmer in the conventional <b>textual</b> <b>program</b> development environment of Prolog (which usua [...] ...|$|R
40|$|Introduction Algorithm {{animation}} {{helps the}} end user to understand algorithms by following visually their stepby -step execution, a complex task if {{relying on the}} <b>textual</b> <b>program</b> alone. There is a strong educational component associated with algorithm animation {{that can be used}} by students individually or in class demonstrations [6, 8]. Algorithm animation is also a powerful software tool that can assist the algorithm designer in code debugging and in demonstrating a complex algorithm to a larger audience than merely specialists in the particular area of the algorithm. We propose a new model, called Mocha, for providing algorithm animation over the WorldWide Web. Mocha is a distributed model with a client-server architecture that optimally partitions the software components of a typical algorithm animation system and leverages the power of the Java language, an emerging standard for distributing interactive platform-independent multimedia applications across th...|$|R
