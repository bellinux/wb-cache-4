2|4|Public
40|$|The C {{programming}} language was devised {{in the early}} 1970 s as a system implementation language for the nascent Unix operating system. Derived from the <b>typeless</b> <b>language</b> BCPL, it evolved a type structure; created on a tiny machine {{as a tool to}} improve a meager programming environment, it {{has become one of the}} dominant languages of today. This paper studies its evolution...|$|E
40|$|Abstract: This paper {{introduces}} and {{characterizes the}} dynamic languages REXX and Object Rexx {{in such a}} way that many of their notable concepts get described and demonstrated with short nutshell examples. This way these concepts are made available for reflection and can be discussed in depth at the workshop. 1 Resurrecting REXX This section introduces the programming language REXX ' history and briefly its main concepts. 1. 1 A Brief History of REXX In 1979 IBM introduced the "Restructured Extended Executor " (REXX) language interpreter, which was deliberately created by the English IBM employee Mike F. Cowlishaw as a "human centric language " to replace eventually the then already awkward EXEC II batch language for IBM mainframes. As such this <b>typeless</b> <b>language</b> to this very day plays an incredible important role in controlling the operation and maintenance of IBM mainframes. Over the course of time REXX became the standard scripting language of operating systems like the Amiga OS o...|$|E
50|$|BLISS is a <b>typeless</b> block-structured <b>language</b> {{based on}} {{expressions}} rather than statements, and includes constructs for exception handling, coroutines, and macros. It {{does not include}} a goto statement.|$|R
40|$|J. Backus, in CACM 21 / 8, {{defined a}} class of ap-plicative prograrrunin g systems called FP /functional prograrmcing / systems in which a user has: l. objects built recursively frcxn atcms, UU /an {{undefined}} ele-ment / and objects by a strict /i. e. a UU-preserving/ "list " operator, 2. elementary functions over obje-cts, 3. tools for building functions out of already defined functions. One {{can think of a}} machine support while work-ing with FP systems and proving facts about FP sys-tems as well as facts concerning the functions be-ing defined. The choice of EDINBURGH KF is rather natural because it is an interactive ccmputer sys-tem /implemented in LISP / for reasoning about fun-ctions /see &I/. It consists of two parts. The first part is a family of calculi each of which is characterized by four factors: 1. type operators /representing domains in the sense of Scott's theo-ry; see m/, 2. constants /representing continuo-us functions/, 3. axicms, 4. inference rules. One of them, PPLAMBDA, is given as the "initial " calcu-lus, and other calculi may be built by users as e. x-tensions of existing calculi. The second part is a high level prograrmxin g language ML which is fully higher order and is strongly typed. Its polymorphic types make it as convenient as <b>typeless</b> <b>languages.</b> This paper is a short report on the application of EDINBUZH LCF to proving the laws of the algebra of FP systems listed by Backus in [ll. Actualiy, we generalized FP-systems and the laws are formula-ted in stronger fonn than it was done by Backus. We briefly describe /sec. II / the style of proving with the system, then /sec. III / ccxtnnent he strtegies u-sed in the proofs giving only their specifications. The summing up remarks will be given in sec. IV...|$|R
40|$|Adaptive data is characterised by {{its ability}} to react {{to changes in the}} environment. Such data {{frequently}} occurs in Artificial Intelligence applications where the knowledge base may alter dynamically to adapt to new stimuli. Such systems are usually written in <b>typeless,</b> dynamically bound <b>languages.</b> Here we describe the concept of persistence and show how it may also be used in conjunction with a strong type system employing flexible binding mechanisms to construct adaptive systems. This has the advantage of greater static checking with all of its attendant benefits, without losing flexibility. Keywords and phrases: persistence, strong typing, dynamic binding, production systems, adaptive systems. 1. Introduction A popular topic for speculation in recent times is how Artificial Intelligence (A. I.) techniques may be used in the management of large software projects [7]. For example, the searching of component libraries in version control and configuration management systems [...] ...|$|R
40|$|Abstract. Many {{low-level}} runtime {{engines and}} virtual machines are stack based- instructions take parameters from the stack and leave their {{results on the}} stack. Stack language is a common name for several languages used to program stack based (virtual) machines- like CLR, JVM, Forth, Postscript, etc. We chose the Forth language as an example to represent the class of stack languages, partially because this <b>language</b> is <b>typeless,</b> partially because there exists a big amount of industrial legacy Forth code {{that needs to be}} validated. Usually applications that take advantage of stack machines are minimalistic and designed to run on restricted environments like electronic devices, smartcards, embedded systems, etc. Sometimes these components are used to build safety critical systems where software errors are inadmissible. Type checking allows to locate possible errors of stack usage that most often occur in stack language programs. Limited resources give preference to a static solution- run-time type information is expensive to manage and quite useless in turnkey applications. Static type checking is based on a type system that is introduced here for originally <b>typeless</b> stack <b>languages.</b> This external type system is flexible enough to perform several tasks. Static program analysis can be used both for finding errors and performing useful transformations on programs (optimization, parallelization, etc.). In this paper a type system to perform the so called must-analysis is described that allows to locate the stack language code where the strong stack discipline is violated. Experimental implementation of the analysis framework is written in Java...|$|R

