26|363|Public
25|$|Joseph Whitworth was an {{engineer}} and inventor who hailed from Stockport, Cheshire (now Greater Manchester). A talented mechanic amongst various other engineering roles, {{for long periods of}} his life, he worked in factories in Manchester. Whitworth would ultimately devise a standard screw <b>thread</b> <b>system,</b> {{the first of its kind}} in the world. The system he created in 1841 would become known as the British Standard Whitworth.|$|E
5000|$|M8, a {{standard}} {{bolt and nut}} size in the ISO metric screw <b>thread</b> <b>system</b> ...|$|E
50|$|All Sigg bottles use {{the same}} {{diameter}} head and <b>thread</b> <b>system,</b> which results in interchangeability of bottles and caps. Different cap styles exist, such as a normal screw on cap with loop, caps with glow-in-the-dark markers, sports-bottle caps and caps with added protection from dust.|$|E
40|$|We {{describe}} the Distributed Object-Oriented <b>Threads</b> <b>System</b> (DOTS), a programming environment designed to support object-oriented fork/join parallel programming in a heterogeneous distributed environment. A mixed network of Windows NT PC’s and UNIX workstations is transformed by DOTS into a homogeneous pool of anonymous compute servers forming together a multicomputer. DOTS {{is a complete}} redesign of the Distributed <b>Threads</b> <b>System</b> (DTS) using the object-oriented paradigm both in its internal implementation and in the programming paradigm it supports. It {{has been used for}} the parallelization of applications in the field of computer algebra and in the field of computer graphics. We also give a brief account of applications in the domain of symbolic computation that were developed using DTS. Key words: distributed <b>threads</b> <b>system,</b> heterogeneous networks, Windows N...|$|R
5000|$|... coThreads, a {{concurrent}} programming library of OCaml, offers STM (originally STMLib) as a module. Just {{like any other}} components in this library, the STM module can be used uniformly with VM-level <b>threads,</b> <b>system</b> <b>threads</b> and processes.|$|R
50|$|Because Yaws uses Erlang's {{lightweight}} <b>threading</b> <b>system,</b> it performs {{well under}} high concurrency. A load test conducted in 2002 comparing Yaws and Apache found {{that with the}} hardware tested, Apache 2.0.39 with the worker MPM failed at 4,000 concurrent connections, while Yaws continued functioning with over 80,000 concurrent connections.|$|R
50|$|Joseph Whitworth was an {{engineer}} and inventor who hailed from Stockport, Cheshire (now Greater Manchester). A talented mechanic amongst various other engineering roles, {{for long periods of}} his life, he worked in factories in Manchester. Whitworth would ultimately devise a standard screw <b>thread</b> <b>system,</b> {{the first of its kind}} in the world. The system he created in 1841 would become known as the British Standard Whitworth.|$|E
5000|$|The Whitworth <b>thread</b> <b>system</b> {{was later}} {{to be adopted}} as a British Standard to become British Standard Whitworth (BSW). An example {{of the use of}} the Whitworth thread are the Royal Navy's Crimean War gunboats. These are the first {{instance}} of mass-production techniques being applied to marine engineering, as the following quotation from the obituary from The Times of 24 January 1887 to Sir Joseph Whitworth (1803-1887) shows: ...|$|E
5000|$|Torx head {{sizes are}} {{described}} using the capital letter [...] "T" [...] {{followed by a}} number ranging from T1 to T100. [...] A smaller number corresponds to a smaller point-to-point dimension of the screw head (diameter of circle circumscribed on the cross-section of {{the tip of the}} screw driver). Common sizes include T10, T15, and T25, while T5.5, T35, and T47 tend to see specialized use. Only the proper driver can drive a specific head size without risk of damaging the driver or screw. The same series of Torx drivers is used to drive SAE, metric and other <b>thread</b> <b>system</b> fasteners, reducing the number of bit sizes required.|$|E
40|$|We {{present the}} design and {{implementation}} of Arachne, a <b>threads</b> <b>system</b> that can be interfaced with a communications library for multi-threaded distributed computations. In particular, Arachne supports thread migration between heterogeneous platforms, with dynamic stack size management and recursive thread functions. Arachne is efficient, flexible and portable [...] - it is based entirely on C and C++. To facilitate heterogeneous thread operations, we have added three keywords to the C++ language. The Arachne preprocessor takes as input code written in that language, and outputs C++ code, suitable for compilation with a conventional C++ compiler. The Arachne runtime <b>system</b> manages all <b>threads</b> during program execution. We present some performance measurements on the costs of basic thread operations and thread migration in Arachne, and compare these to costs in other <b>threads</b> <b>systems.</b> Keywords: heterogeneous <b>thread</b> migration, user-level threads, compile-time code transformations, C++ Supporte [...] ...|$|R
40|$|Abstract. We {{describe}} {{the design and}} implementation of the Distributed Object-Oriented <b>Threads</b> <b>System</b> (DOTS). This system is a complete redesign of the Distributed <b>Threads</b> <b>System</b> (DTS) using the object-oriented paradigm both in its internal implementation and in the programming paradigm it supports. DOTS extends the support for fork/join parallel programming from shared memory threads to a distributed environment. It is currently implemented on top of the Adaptive Communication Environment (ACE). A heterogeneous network of Windows NT PC’s and of UNIX workstations is transformed by DOTS into a homogeneous pool of anonymous compute servers. DOTS has been used recently in applications from computer graphics and computational number theory. We also discuss the performance characteristics of DOTS for a workstation cluster running under Solaris and a PC network using Windows NT, as they were obtained from a prototypical example. ...|$|R
500|$|... iOS 10 also changes how email {{threading}} works, {{by placing}} the oldest email at the top by default. An option in Settings lets users revert to the previous <b>threading</b> <b>system</b> with the most recent message on top. Additionally, the new threaded conversations allow users to tap a message to see a scrollable stream of messages inside the thread.|$|R
5000|$|The Unified Thread Standard (UTS) is most {{commonly}} used in the United States, but is also extensively used in Canada and occasionally in other countries. The size of a UTS screw is described using the following format: X-Y, where X is the nominal size (the hole or slot size in standard manufacturing practice through which the shank of the screw can easily be pushed) and Y is the threads per inch (TPI). For sizes [...] inch and larger the size is given as a fraction; for sizes less than this an integer is used, ranging from 0 to 16. The integer sizes {{can be converted to}} the actual diameter by using the formula 0.060 + 0.013 &times; number. For example, a #4 screw is 0.060 + 0.013 &times; 4 = 0.112 inches in diameter. There are also screw sizes smaller than [...] "0" [...] (zero or ought). The sizes are 00, 000, 0000 which are usually referred to as two ought, three ought, and four ought. Most eyeglasses have the bows screwed to the frame with 00-72 (pronounced double ought - seventy two) size screws. To calculate the major diameter of [...] "ought" [...] size screws count the number of 0's and multiply this number by [...]013 and subtract from [...]060. For example, the major diameter of a 000-72 screw thread is [...]060 - (3 x [...]013) = [...]060-.039 = [...]021 inches. For most size screws there are multiple TPI available, with the most common being designated a Unified Coarse Thread (UNC or UN) and Unified Fine Thread (UNF or UF). Note: In countries other than the United States and Canada, the ISO Metric Screw <b>Thread</b> <b>System</b> is primarily used today. Unlike most other countries the United States and Canada still use the Unified (Inch) <b>Thread</b> <b>System.</b> However, both are moving over to the ISO Metric System. It is estimated that approximately 60% of screw threads in use in the United States are still inch based.67 ...|$|E
5000|$|Stitch-Bonding is {{a special}} form of warp {{knitting}} [...] and is commonly used {{for the production of}} composite materials and technical textiles. As a method of production, stitch-bonding is efficient, {{and is one of the}} most modern ways to create reinforced textiles and composite materials [...] for industrial use. The advantages of the stitch-bonding process includes its high productivity rate and the scope it offers for functional design of textiles, such as fiber-reinforced plastics. [...] Stitch-bonding involves layers of threads and fabric being joined together with a knitting thread, which creates a layered structure called a multi-ply. [...] This is created through a warp-knitting <b>thread</b> <b>system,</b> which is fixed on the reverse side of the fabric with a sinker loop, and a weft thread layer. [...] A needle with the warp thread passes through the material, which requires the warp and knitting threads to be moving both parallel and perpendicular to the vertical/warp direction of the stitch-bonding machine. [...] Stitch-bonded fabrics are currently being used in such fields as wind energy generation and aviation. [...] Research is currently being conducted into the usage and benefits of stitch-bonded fabrics as a way to reinforce concrete. Fabrics produced with this process offer the potential of using “sensitive fiber materials such as glass and carbon with only little damage, non-crimp fiber orientation and variable distance between threads”.|$|E
5000|$|Development of the Thury thread {{began in}} 1876, when the Horological Section of Geneva Society of Arts {{appointed}} {{a committee to}} look into the requirements for a uniform thread standard for use in Horological arts in Switzerland. Professor Thury began his studies by collecting and measuring samples of screws made by nine independent screw and screw tackle manufacturers in Switzerland. The Thury thread form was developed in 1878, thirty-seven years after the British Standard Whitworth thread form was designed in England and fourteen years after the United States Standard thread was presented in the United States. However, unlike these two predecessors, the Thury thread was designed for small-diameter screws which were then produced with screw plates. This production technique mandated that the Thury thread form have rounded crests and roots. Thread forms with rounded or [...] "radiused" [...] crests and roots like the Thury and Whitworth thread generate smaller stress risers than those forms like the American National or ISO metric which have truncated roots and crests; in modern engineering this is particularly important factor when tapping holes in acrylic plastic, where a larger stress riser can lead to an earlier onset of crack formation. The Thury thread is unusual in having a comparatively small 47.5° thread flank angle, which was chosen to make fabrication easier and to achieve greater holding capacity than screws with larger flank angles. Screws in the Thury <b>thread</b> <b>system</b> are given nominal sizes, with the base size [...] "0" [...] being six millimeters in diameter and having a thread pitch of one millimeter. Sizes are proportional, so a size [...] "1" [...] is ten percent smaller in diameter that a size [...] "0", while a size -1 is ten percent larger than a size [...] "0". The Thury thread was {{believed to be the first}} thread form to solve the problem of creating a single system of screw dimensions applicable to all sizes. The relationship between the pitch P of a Thury screw and its diameter D is expressed by the equation D=6P5/6. Another variable Thury standardized is the thread depth, which had until then been variable when cutting threads in different materials. The proliferation of the Thury standard was hindered when in 1882, the British Science Association produced a committee report on the consideration of a standard screw gauge, where they declined to accept the Thury thread but instead chose to use the Whitworth thread standard previously designed by committee member Joseph Whitworth, in part because the Whitworth form was historically successful and because the committee did not believe England was prepared to use a metric thread as its standard. However, the committee recognized the validity of many of the design aspects of the Thury thread, and a mere two years later published their specifications for the British Association (BA) thread. The BA committee made only slight modifications to the rounding radii of Thury thread and gave specifications rounded to the nearest mil.|$|E
50|$|Although the {{emergence}} of widely available public internet services has made private BBS systems obsolete {{in most of the}} developed free world, a dedicated core of enthusiasts continue to tinker with vintage computers and keep software like DS2 running, despite the quaint limitations of the simple linear message <b>threading</b> <b>system</b> and the primitive keyboard-based, non-graphical games.|$|R
5000|$|... iOS 10 also changes how email {{threading}} works, {{by placing}} the oldest email at the top by default. An option in Settings lets users revert to the previous <b>threading</b> <b>system</b> with the most recent message on top. Additionally, the new threaded conversations allow users to tap a message to see a scrollable stream of messages inside the thread.|$|R
5000|$|Some of {{the common}} {{features}} of Dextra's parallel <b>threaded</b> splicing <b>systems</b> are as follows: ...|$|R
40|$|Measuring and {{evaluating}} the runtime of parallel programs {{is a difficult}} task. In this paper we present tools for performance evaluation and visualization in the distributed <b>thread</b> <b>system</b> (DTS), a programming environment for portable parallel applications. We describe the visualization of a parallel trace log as an execution graph using a novel layout algorithm which has been tailored to expose the structure of multithreaded applications...|$|E
40|$|The {{new version}} of scsh enables {{concurrent}} system programming with portable user-level threads. In scsh, threads behave like processes in many ways. Each thread receives {{its own set of}} process resources. Like Unix processes, forked threads can inherit resources from the parent thread. To store these resources scsh uses preserved thread fluids, a special kind of fluid variables. The paper gives a detailed description of an efficient implementation for thread-local process resources. Scsh also provides an interface to the fork system calls which avoids common pitfalls which arise with a userlevel <b>thread</b> <b>system.</b> Scsh contains a binding for fork that forks "only the current thread. "...|$|E
40|$|We {{believe that}} the {{engineering}} of mobile or persistent processes is hindered in many systems {{by the amount of}} coupling between user-level and the kernel. This coupling usually takes the form of user level data structures containing opaque references to kernel data structures. In this paper we show how self-managing protection domains may be constructed that support a modern object-oriented application environment that is not closely coupled with the kernel. This is achieved through the introduction of a software artefact called the Umbrella that abstracts over the low-level aspects of self-management and present a clean object-oriented management interface to the upper layers of software. We show how the Umbrella is engineered and {{some of the problems that}} must be overcome in order to achieve isolation from the kernel. We conclude by showing how a <b>thread</b> <b>system</b> may be constructed above the Umbrella. ...|$|E
50|$|The Lasso Server {{application}} server runs {{as a system}} service and receives requests from the web server through FastCGI. It then hands the request off to the appropriate Lasso Instance, which formulates the response. Multiple individual instances are supported, allowing one server to handle multiple sites, each as separate processes. The server uses a high performance IO-based green <b>threading</b> <b>system</b> designed for multi-core systems.|$|R
40|$|Abstract. This paper {{deals with}} the design of an API for {{building}} distributed parallel applications in C++ which embody strict multithreaded computations. The API is enhanced with mechanisms to deal with highly irregular non-deterministic computations often occurring {{in the field of}} parallel symbolic computation. The API is part of the Distributed Object-Oriented <b>Threads</b> <b>System</b> DOTS. The DOTS environment provides support for strict multithreaded computations on highly heterogeneous networks of workstations. ...|$|R
40|$|Previous {{research}} efforts for building <b>thread</b> migration <b>systems</b> {{have concentrated on}} the development of frameworks dealing with a small local environment controlled by a single user. Computational Grids provide the opportunity to utilize a large-scale environment controlled over different organizational boundaries. Using this class of large-scale computational resources as part of a <b>thread</b> migration <b>system</b> provides a significant challenge previously not addressed by this community. In this paper the authors present a framework that integrates Grid services to enhance the functionality of a <b>thread</b> migration <b>system.</b> To accommodate future Grid services, the design of the framework is both flexible and extensible. Currently, the <b>thread</b> migration <b>system</b> contains Grid services for authentication, registration, lookup, and automatic software installation. In the context of distributed applications executed on a Grid-based infrastructure, the asynchronous migration of an execution context can help solve problems such as remote execution, load balancing, and the development of mobile agents. The prototype is based on the migration of Java threads, allowing asynchronous and heterogeneous migration of the execution context of the running code...|$|R
40|$|Multipol is {{a library}} of {{distributed}} data structures designed for irregular applications, including those with asynchronous communication patterns. In this paper, we describe the Multipol runtime layer, which provides an efficient and portable abstraction underlying the data structures. It contains a <b>thread</b> <b>system</b> to express computations {{with varying degrees of}} parallelism and to support multiple threads per processor for hiding communication latency. To simplify programming in a multithreaded environment, Multipol threads are small, finite-length computations that are executed atomically. Rather than enforcing a single scheduling policy on threads, users may write their own schedulers or choose one of the schedulers provided by Multipol. The system is designed for distributed memory architectures and performs communication optimizations such as message aggregation to improve efficiency on machines with high communication startup overhead. The runtime system currently runs on the Think [...] ...|$|E
40|$|Abstract. Multi-instrument {{observations}} of NOAA AR 10938 on Jan. 14 - 18, 2007, are utilized {{to study the}} evolution of a magnetic <b>thread</b> <b>system</b> with multiple crossings suggestive of a twisted coronal flux rope. A C-class flare recorded by GOES on Jan. 16, at approximately 2 : 35 UT led to the brightening of the structure, that is seen in Hinode/EIS data at 2 : 46 UT, Hinode/XRT after 2 : 50 UT, and STEREO/SECCHI/EUVI images at 3 : 30 UT. 304 ˚A images revealed the presence of rapidly evolving, dark fibrils along the bright structure before and after the flare. A denser structure formed a few hours later and lasted for several days forming a segment of an inverse S-shaped filament. The present set of data is highly suggestive of the presence of a twisted flux rope prior to the formation of the filament segment at the same location. 1...|$|E
40|$|Thread {{migration}} is {{established as a}} mechanism for achieving dynamic load sharing and data locality. However, migration has not been used with fine-grained parallelism due to the relatively high overheads associated with thread and messaging packages. This paper describes a high performance thread migration system for fine-grained parallelism, implemented with user level threads and user level messages. The <b>thread</b> <b>system</b> supports an extensible event mechanism which permits an efficient interface between the thread and messaging systems without compromising the modularity of either. Migration is supported by user level primitives; applications may implement different migration policies {{on top of the}} migration interface provided. The system is portable and can be used directly by application and library writers or serve as a compilation target for parallel programming languages. Detailed performance metrics are presented to evaluate the system. The system runs on a cluster of S [...] ...|$|E
5000|$|Implementing mutexes and {{condition}} variables requires {{some kind of}} synchronization primitive provided by hardware support that provides atomicity. Locks {{and condition}} variables are higher-level abstractions over these synchronization primitives. On a uniprocessor, disabling and enabling interrupts {{is a way to}} implement monitors by preventing context switches during the critical sections of the locks and condition variables, but this is not enough on a multiprocessor. On a multiprocessor, usually special atomic read-modify-write instructions on the memory such as test-and-set, compare-and-swap, etc. are used, depending on what the ISA provides. These usually require deferring to spin-locking for the internal lock state itself, but this locking is very brief. Depending on the implementation, the atomic read-modify-write instructions may lock the bus from other cores' accesses and/or prevent re-ordering of instructions in the CPU. Here is an example pseudocode implementation of parts of a <b>threading</b> <b>system</b> and mutexes and Mesa-style condition variables, using test-and-set and a first-come, first-served policy. This glosses over most of how a <b>threading</b> <b>system</b> works, but shows the parts relevant to mutexes and condition variables: ...|$|R
5000|$|ASME/ANSI B1.3-2007 Screw <b>Thread</b> Gauging <b>Systems</b> for Acceptability: Inch and Metric Screw Threads (UN, UNR, UNJ, M, and MJ) ...|$|R
5000|$|Intel Advisor - {{specialized}} performance profiler {{to optimize}} vectorization and a <b>thread</b> prototyping <b>system</b> for adding / improving threading.|$|R
40|$|Multi-instrument {{observations}} of NOAA AR 10938 on Jan. 14 - 18, 2007, are utilized {{to study the}} evolution of a magnetic <b>thread</b> <b>system</b> with multiple crossings suggestive of a twisted coronal flux rope. A C-class flare recorded by GOES on Jan. 16, at approximately 2 : 35 UT led to the brightening of the structure, that is seen in Hinode/EIS data at 2 : 46 UT, Hinode/XRT after 2 : 50 UT, and STEREO/SECCHI/EUVI images at 3 : 30 UT. 304 Å images revealed the presence of rapidly evolving, dark fibrils along the bright structure before and after the flare. A denser structure formed a few hours later and lasted for several days forming a segment of an inverse S-shaped filament. The present set of data is highly suggestive of the presence of a twisted flux rope prior to the formation of the filament segment at the same location. Comment: 4 pages, 4 figure, Proceedings of the Hinode 2 meetin...|$|E
40|$|The {{implementation}} of rst-class continuations in a Scheme system that interfaces to a stack-based language such as C is dicult when Scheme and C frames can be interleaved (i. e. Scheme and C can nest calls {{to each other}} arbitrarily). Such a situation occurs when {{using a combination of}} callbacks, higher-order functions, exception processing, and a Scheme level <b>thread</b> <b>system</b> built on top of rst-class continuations. We show that in this context the use of C threads to implement rst-class continuations allows unrestricted interoperability with C. 1 Introduction Scheme systems that allow linking with C code (and more generally any stack-based language) whether they generate native code or C code, require special treatment of continuations when Scheme continuation frames and C frames can be interleaved. In our examples we will denote continuations with a string of letters; C frames are in upper-case, Scheme frames are in lower-case, and the last frame added to the continuation is on the [...] ...|$|E
40|$|The main aim of {{this study}} is to promote the {{efficiency}} of a control system using a multithread digital control design. In this system, the management of a computer`s input and output information is handled appropriately by the program language. The multithread digital control design is used in the robotic arm`s tracking system. The advantage of this multithread digital control design is to activate each procedure running simultaneously when the transient overload of the information`s input and output in the control system occurs. Therefore, the time run in the multithread system will be shorter than that run in a traditional single <b>thread</b> <b>system</b> in which each procedure is lined up for running. In this study, case studies of multithread application used in image tracking and robot control are introduced. The results reveal that the speed of the tracking system can be improved by using the multithread technique under an immediate procedure plan...|$|E
40|$|International audienceWith the {{introduction}} of Intel’s restricted hardware transactional memory (HTM) in commodity hardware, the transactional memory abstraction has finally become practical to use. Transactional memory allows a programmer to easily implement safe concurrent code by specifying that certain blocks of code should be executed atomically. However, Intel’s HTM implementation does not offer any progress guarantees. Even in a single <b>threaded</b> <b>system,</b> a transaction can repeatedly fail for complex (and often undocumented) reasons...|$|R
40|$|We {{present a}} novel method for {{distributed}} parallel au-tomatic theorem proving. Our approach uses a dynam-ically learning parallel SAT checker incorporating dis-tributed multi-threading and mobile agents. Individual threads process dynamically created subproblems, while agents collect and distribute new knowledge {{created by the}} learning process. As parallelization platform we use the Distributed Object-Oriented <b>Threads</b> <b>System</b> (DOTS) that provides support for both distributed threads and mo-bile agents. We present experiments indicating the useful-ness of the presented approach for different application do-mains...|$|R
40|$|An {{efficient}} evaluation {{technique is}} examined for lazy functional programs based on combinator graph reduction. Graph reduction {{is widely believed}} to be slow and inefficient, but an abstract machine called the Threaded Interpretive Graph Reduction Engine (TIGRE) achieves a substantial speedup over previous reduction techniques. The runtime system of TIGRE is a <b>threaded</b> <b>system</b> that permits self-modifying program execution with compiler-guaranteed safety. This paper describes an implementation of TIGRE in Forth for the Harris RTX 2000 stack processor...|$|R
