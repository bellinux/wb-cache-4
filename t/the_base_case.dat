1922|10000|Public
25|$|For <b>the</b> <b>base</b> <b>case,</b> {{note that}} 2 is prime.|$|E
25|$|Whether n=0 or n=1 {{depends on}} the {{definition}} of the natural numbers. If 0 is considered a natural number, as is common in the fields of combinatorics and mathematical logic, <b>the</b> <b>base</b> <b>case</b> is given by n=0. If, on the other hand, 1 is taken as the first natural number, then <b>the</b> <b>base</b> <b>case</b> is given by n=1.|$|E
25|$|<b>The</b> <b>base</b> <b>case</b> of the {{recursion}} is {{arrays of}} size zero or one, {{which are in}} order by definition, so they never need to be sorted.|$|E
30|$|By {{induction}} on {{the definition}} of dec(p, I) and then by induction on the proof of t. <b>The</b> <b>base</b> <b>cases</b> are empty. <b>The</b> first <b>base</b> <b>case</b> is dec(0, I) = ∅ and so no transition t is enabled. Similarly, <b>the</b> second <b>base</b> <b>case</b> is p = A, with A ∈ I (hence, dec(A, I) = ∅). The other cases follow.|$|R
2500|$|... {{defined by}} the {{recurrence}} relations fusc(2n)=fusc(n) and fusc(2n+1)=fusc(n)+fusc(n+1), with <b>the</b> <b>base</b> <b>cases</b> fusc(0)=0 and fusc(1)=1.|$|R
25|$|In any {{recursive}} algorithm, {{there is}} considerable freedom {{in the choice of}} <b>the</b> <b>base</b> <b>cases,</b> <b>the</b> small subproblems that are solved directly in order to terminate the recursion.|$|R
25|$|Numbers {{represent}} {{the number of}} free moves, or the move advantage of a particular player. By convention positive numbers represent an advantage for Left, while negative numbers represent an advantage for Right. They are defined recursively with 0 being <b>the</b> <b>base</b> <b>case.</b>|$|E
25|$|Proof. For <b>the</b> <b>base</b> <b>case</b> of induction, {{consider}} i=0 and {{the moment}} before for loop is executed for the first time. Then, for the source vertex, source.distance = 0, which is correct. For other vertices u, u.distance = infinity, which is also correct {{because there is no}} path from source to u with 0 edges.|$|E
25|$|Note {{also that}} the {{anonymous}} function is named Smaller in the parameter list of the second definition of qsort {{so that it can}} be referenced by that name within that function. It is not named in the first definition of qsort, which deals with <b>the</b> <b>base</b> <b>case</b> of an empty list and thus has no need of this function, let alone a name for it.|$|E
50|$|Check for <b>the</b> above <b>base</b> <b>cases.</b>|$|R
30|$|By {{induction}} on {{the proof}} of wf(p, I). <b>The</b> first <b>base</b> <b>case</b> is p = 0, and the thesis trivially holds. <b>The</b> second <b>base</b> <b>case</b> is when p = A and A ∈ I; in such a case, wf(A, I) holds and dom(dec(A, I)) = ∅, hence the thesis trivially holds.|$|R
30|$|From {{time history}} analysis, it is {{observed}} that for all hazard levels, base shear is lower for <b>the</b> nonlinear <b>base</b> <b>case</b> than <b>the</b> elastic <b>base</b> <b>case.</b> <b>The</b> trend is opposite for drift ratio, i.e., drift ratio is higher for nonlinear <b>base</b> <b>case</b> in comparison to <b>the</b> linear <b>base</b> <b>case.</b> Also, this ratio of nonlinear to linear responses (of base shear and drift) reduces with an increase in height of water in the channels. This is because, for varying water levels, these responses are least affected in nonlinear <b>base</b> <b>case</b> and get altered only in <b>case</b> of elastic <b>base.</b> In general, for a given hazard level (say 10  % in 50 years), <b>the</b> <b>base</b> shear demand of empty aqueduct is maximum for elastic <b>base</b> <b>case,</b> followed by fixed base and nonlinear <b>base</b> <b>cases.</b>|$|R
25|$|On {{the other}} hand, {{efficiency}} often improves if the recursion is stopped at relatively large base cases, {{and these are}} solved non-recursively, resulting in a hybrid algorithm. This strategy avoids the overhead of recursive calls that do little or no work, and may also allow the use of specialized non-recursive algorithms that, for those base cases, are more efficient than explicit recursion. A general procedure for a simple hybrid recursive algorithm is short-circuiting <b>the</b> <b>base</b> <b>case,</b> also known as arm's-length recursion. In this case whether the next step will result in <b>the</b> <b>base</b> <b>case</b> is checked before the function call, avoiding an unnecessary function call. For example, in a tree, rather than recursing to a child node and then checking if it is null, checking null before recursing; this avoids half the function calls in some algorithms on binary trees. Since a D algorithm eventually reduces each problem or sub-problem instance to {{a large number of}} base instances, these often dominate the overall cost of the algorithm, especially when the splitting/joining overhead is low. Note that these considerations do not depend on whether recursion is implemented by the compiler or by an explicit stack.|$|E
25|$|Mathematical {{induction}} {{is a form}} {{of direct}} proof, usually done in two steps. When trying to prove a given statement for a set of natural numbers, the first step, known as <b>the</b> <b>base</b> <b>case,</b> is to prove the given statement for the first natural number. The second step, known as the inductive step, is to prove that, if the statement is assumed to be true for any one natural number, then it must be true for the next natural number as well. Having proved these two steps, the rule of inference establishes the statement to be true for all natural numbers. In common terminology, using the stated approach is referred to as using the Principle of mathematical induction.|$|E
25|$|This axiomatization is complete, {{meaning that}} every Boolean law s= t is provable in this system. One first shows by {{induction}} on {{the height of}} s that every Boolean law for which t is atomic is provable, using R1 for <b>the</b> <b>base</b> <b>case</b> (since distinct atoms are never equal) and A1 and R3 for the induction step (s an application). This proof strategy amounts to a recursive procedure for evaluating s to yield an atom. Then to prove s= t in the general case when t may be an application, use {{the fact that if}} s= t is an identity then s and t must evaluate to the same atom, call it u. So first prove s= u and t= u as above, that is, evaluate s and t using A1, R1, and R3, and then invoke R2 to infer s= t.|$|E
50|$|Thus, for example, many library {{implementations}} of quicksort will {{switch to}} a simple loop-based insertion sort (or similar) algorithm once {{the number of items}} to be sorted is sufficiently small. Note that, if the empty list were <b>the</b> only <b>base</b> <b>case,</b> sorting a list with n entries would entail maximally n quicksort calls that would do nothing but return immediately. Increasing <b>the</b> <b>base</b> <b>cases</b> to lists of size 2 or less will eliminate most of those do-nothing calls, and more generally a <b>base</b> <b>case</b> larger than 2 is typically used to reduce the fraction of time spent in function-call overhead or stack manipulation.|$|R
3000|$|By {{induction}} on {{the definition}} of sub(p, ∅ [...]). <b>The</b> <b>base</b> <b>cases</b> are sub(0, I) and sub(A, I) when A ∈ I. Note that induction will end eventually because the constants that a finite-net multi-CCS process may use are finitely many.|$|R
5000|$|This {{decomposition}} {{is performed}} recursively when N {{is a power}} of two. <b>The</b> <b>base</b> <b>cases</b> of <b>the</b> recursion are N=1, where the DFT is just a copy , and N=2, where the DFT is an addition [...] and a subtraction [...]|$|R
500|$|An {{alternative}} {{proof of}} sufficiency {{can be used}} to show that there are many different flat foldings. Consider the smallest angle [...] and the two creases on either side of it. Mountain-fold one of these two creases and valley-fold the other, choosing arbitrarily which fold to use for which crease. Then, glue the resulting flap of paper onto the remaining part of the crease pattern. The result of this gluing will be a crease pattern with two fewer creases, on a conical sheet of paper, that still satisfies Kawasaki's condition. Therefore, by mathematical induction, repeating this process will eventually lead to a flat folding. <b>The</b> <b>base</b> <b>case</b> of the induction is a cone with only two creases and two equal-angle wedges, which can obviously be flat-folded by using a mountain fold for both creases. There are two ways to choose which folds to use in each step of this method, and each step eliminates two creases. Therefore, any crease pattern with [...] creases that satisfies Kawasaki's condition has at least [...] different choices of mountain and valley folds that all lead to valid flat foldings.|$|E
2500|$|Although {{the form}} just {{described}} requires one to prove <b>the</b> <b>base</b> <b>case,</b> ...|$|E
2500|$|In {{this form}} <b>the</b> <b>base</b> <b>case</b> is subsumed {{by the case}} , where P(0) is proved with no other P(n) assumed; ...|$|E
50|$|We prove {{commutativity}} (a + b = b + a) {{by applying}} induction {{on the natural}} number b. First we prove <b>the</b> <b>base</b> <b>cases</b> b = 0 and b = S(0) = 1 (i.e. we prove that 0 and 1 commute with everything).|$|R
40|$|Knowledge {{containers}} {{represent the}} structural {{elements of a}} <b>case</b> [...] <b>based</b> reasoning system, namely the vocabulary,thesimilarity measures,theso- lution transformations (adaptation knowledge), and <b>the</b> <b>case</b> <b>base.</b> Every knowledge container can be maintained separately, however, recent work {{in the area of}} <b>case</b> [...] <b>based</b> reasoning system maintenance concentrates on maintaining <b>the</b> <b>case</b> <b>base.</b> Based on this, four hypotheses are formulated: there is no maintenance without regarding <b>the</b> <b>case</b> <b>base,</b> <b>cases</b> are natural crystallization points for the knowledge in <b>case</b> [...] <b>based</b> reasoning systems, <b>the</b> <b>case</b> <b>base</b> triggers maintenance operations, and <b>the</b> <b>case</b> <b>base</b> contains knowledge for preventive maintenance. Furthermore, these hypotheses will be considered by measures, methods, and a framework for maintenance of <b>case</b> [...] <b>based</b> reasoning systems. 1 Introduction The notion of knowledge containers [10] became the standard paradigm for the representation of structural elements in <b>case</b> [...] <b>based</b> reasoning [...] ...|$|R
2500|$|Thus, for example, many library {{implementations}} of quicksort will {{switch to}} a simple loop-based insertion sort (or similar) algorithm once {{the number of items}} to be sorted is sufficiently small. [...] Note that, if the empty list were <b>the</b> only <b>base</b> <b>case,</b> sorting a list with n entries would entail maximally n quicksort calls that would do nothing but return immediately. [...] Increasing <b>the</b> <b>base</b> <b>cases</b> to lists of size 2 or less will eliminate most of those do-nothing calls, and more generally a <b>base</b> <b>case</b> larger than 2 is typically used to reduce the fraction of time spent in function-call overhead or stack manipulation.|$|R
2500|$|If [...] is {{the weight}} of the edge between {{vertices}} [...] and , we can define [...] in terms of the following recursive formula: <b>the</b> <b>base</b> <b>case</b> is ...|$|E
2500|$|In {{this form}} of {{complete}} induction one still has to prove <b>the</b> <b>base</b> <b>case,</b> P(0), and {{it may even be}} necessary to prove extra base cases such as P(1) ...|$|E
2500|$|... 1. The Base Case: MTDB {{described}} <b>the</b> <b>base</b> <b>case</b> as {{a modified}} bus network that retained {{the same number}} of total vehicles as the present San Diego Transit system.|$|E
2500|$|... with <b>the</b> <b>base</b> <b>cases</b> [...] Using {{this formula}} {{to compute the}} values of all {{binomial}} coefficients generates an infinite array called Pascal's triangle. The same values can also be computed directly by a different formula {{that is not a}} recurrence, but that requires multiplication and not just addition to compute: ...|$|R
25|$|For example, if (a) <b>the</b> <b>base</b> <b>cases</b> have constant-bounded size, {{the work}} of {{splitting}} the problem and combining the partial solutions {{is proportional to the}} problem's size n, and (b) there is a bounded number p of subproblems of size ~ n/p at each stage, then the cost of the divide-and-conquer algorithm will be O(n logp'n).|$|R
30|$|Step 1 : Model <b>the</b> {{distribution}} network <b>base</b> <b>case.</b>|$|R
2500|$|The {{generalized}} {{version of}} this idea is known as recursion [...] "unrolling" [...] or [...] "coarsening" [...] and various techniques have been proposed for automating the procedure of enlarging <b>the</b> <b>base</b> <b>case.</b>|$|E
2500|$|Now suppose [...] Then, [...] We {{show that}} [...] is {{divisible}} by [...] by induction on [...] <b>The</b> <b>base</b> <b>case</b> [...] follows. Therefore, assume [...] We know that [...] divides both (since it has period [...] ) ...|$|E
2500|$|This {{algorithm}} {{will produce}} [...] "tables" [...] m and s {{that will have}} entries for all possible values of i and j. The final solution for the entire chain is m, with corresponding split at s. Unraveling the solution will be recursive, starting from the top and continuing until we reach <b>the</b> <b>base</b> <b>case,</b> i.e. multiplication of single matrices.|$|E
2500|$|The same {{technique}} {{can be used}} to give an inductive {{proof of}} the volume formula. <b>The</b> <b>base</b> <b>cases</b> of <b>the</b> induction are the 0-ball and the 1-ball, which can be checked directly using the facts [...] and [...] The inductive step is similar to the above, but instead of applying proportionality to the volumes of the -balls, the inductive assumption is applied instead.|$|R
30|$|<b>The</b> first <b>base</b> <b>case</b> is when p = 0; {{in such a}} case sub(0, I) = { 0 }; as dec(0, I) = ∅, {{the thesis}} follows trivially. <b>The</b> second <b>base</b> <b>case</b> is when p = A and A ∈ I; {{in such a case}}, sub(A, I) = ∅; as dec(A, I) = ∅, the thesis follows trivially. The other simple case is when p is {{sequential}} (and not 0); in such a case, dec(p, I) = {p} and the thesis follows trivially.|$|R
2500|$|Alternatively, one can employ large <b>base</b> <b>cases</b> {{that still}} use a divide-and-conquer algorithm, but {{implement}} the algorithm for predetermined set of fixed sizes where the algorithm can be completely unrolled into code {{that has no}} recursion, loops, or conditionals (related to the technique of partial evaluation). [...] For example, this approach is used in some efficient FFT implementations, where <b>the</b> <b>base</b> <b>cases</b> are unrolled implementations of divide-and-conquer FFT algorithms {{for a set of}} fixed sizes. [...] Source code generation methods may be used to produce the large number of separate <b>base</b> <b>cases</b> desirable to implement this strategy efficiently.|$|R
