3|17|Public
5000|$|Lotus Expeditor Server {{is used to}} deploy, {{configure}} {{and maintain}} applications running on Lotus Expeditor Clients. It runs {{on top of the}} IBM DB2 database management system and the Java EE-based IBM WebSphere Application Server. Expeditor Server is not necessary for Expeditor Client applications to run. Client applications can run standalone, and optionally exploit the services of the Lotus Expeditor Server for data synchronization, <b>transactional</b> <b>messaging</b> and automated, remote, application management.|$|E
5000|$|Transactional emails {{are usually}} {{triggered}} {{based on a}} customer's action with a company. To be qualified as transactional or relationship messages, these communications' primary purpose must be [...] "to facilitate, complete, or confirm a commercial transaction that the recipient has previously agreed to enter into with the sender" [...] {{along with a few}} other narrow definitions of <b>transactional</b> <b>messaging.</b> Triggered transactional messages include dropped basket messages, password reset emails, purchase or order confirmation emails, order status emails, reorder emails, and email receipts.|$|E
5000|$|In 2007, mobileStorm {{announced}} an angel round of funding with eonBusiness and opened additional offices in San Francisco and Orange County. The San Francisco branch {{will focus on}} new accounts, sales, and customer service. In 2008, mobileStorm was named the email service provider of FreemantleEnterprises, which manages shows like American Idol and The Price Is Right. mobileStorm’s former products include Stun!, which allowed small to medium-sized businesses to build a database of customers and market to them via text messaging, email, voice and fax, and Bolt, a hosted service designed for large enterprises that deployed marketing, customer service, and <b>transactional</b> <b>messaging</b> programs. The two platforms are currently integrated into [...] "mobileStorm for Marketing." ...|$|E
50|$|Ready {{to support}} <b>transactional</b> <b>messages</b> processing.|$|R
5000|$|Cost efficiency. <b>Transactional</b> email <b>messaging</b> {{eliminates}} the need for costly traditional paper inserts.|$|R
50|$|Enduro/X {{provides}} a queuing subsystem called TMQ (<b>Transactional</b> <b>Message</b> Queue). This facility provides persistent queues that allows applications to explicitly enqueue and dequeue messages from named queues. Queues {{can be ordered}} by message en-queue time in LIFO or FIFO order. Queues are managed by an XA compliant resource manager allowing queue operations to participate in distributed transactions. An automated queue forwarding feature is provided that will remove entries from a queue and invoke an associated Enduro/X ATMI services, placing the reply message on an associated reply queue and failed messages to failure queue.|$|R
50|$|Critics {{argue that}} typical users of C/R systems {{still need to}} review their {{challenged}} mail regularly, looking for non-bulk mail or solicited bulk email for which the sender has not responded to the challenge. This issue is particularly notable with newsletters, <b>transactional</b> <b>messages,</b> and other solicited bulk email, as such senders do not usually check for challenges to their mail. However, if the bulk email in question was solicited, then the C/R user {{could be expected to}} have added it to the whitelist. If the bulk email was not solicited, then by definition it is spam, and will be properly filtered by the C/R system.|$|R
40|$|Concordia {{provides}} a robust and highly reliable {{framework for the}} development and execution of secure, mobile agent applications. Concordia incorporates many advanced security and reliability features beyond the basic functionality found in other mobile agent systems. Concordia {{provides a}} rich security model {{that can be used}} to allow or deny access to system resources down to a very fine level of granularity and that protects agents and the information they carry from tampering or unauthorized access. The system utilizes <b>transactional</b> <b>message</b> queuing to provide reliable network transmissions. Further, Concordia uses proxy objects and a persistent object store to insulate applications from system or network failures. This paper discusses the design and implementation of these features. 1...|$|R
5000|$|The term 'nibble' {{originates}} {{from its}} representing 'half a byte', with 'byte' a homophone of the English word 'bite'.In 2014, David B. Benson, {{a professor emeritus}} at Washington State University, remembered that he playfully used (and may have possibly coined) the term nibble as [...] "half a byte" [...] and unit of storage required to hold a binary-coded decimal (BCD) decimal digit around 1958, when talking to a programmer of Los Alamos Scientific Laboratory.The alternative spelling 'nybble' reflects the spelling of 'byte', as noted in editorials of Kilobaud and Byte in the early 1980s.Another early recorded {{use of the term}} 'nybble' was in 1977 within the consumer-banking technology group at Citibank. It created a pre-ISO 8583 standard for <b>transactional</b> <b>messages</b> between cash machines and Citibank's data centers that used the basic informational unit 'NABBLE'.|$|R
5000|$|Many email {{newsletter}} software vendors offer transactional email support, {{which gives}} companies {{the ability to}} include promotional messages within the body of transactional emails. There are also software vendors that offer specialized transactional email marketing services, which include providing targeted and personalized <b>transactional</b> email <b>messages</b> and running specific marketing campaigns (such as customer referral programs).|$|R
40|$|This paper {{gives an}} {{overview}} of Demaq, an XML message processing system operating on the foundation of <b>transactional</b> XML <b>message</b> queues. We focus on the syntax and semantics of its fully declarative, rule-based application language and demonstrate our message-based programming paradigm {{in the context of}} a case study. Further, we discuss optimization opportunities for executing Demaq programs. 1...|$|R
5000|$|New {{features}} include: Subqueues, improved {{support for}} [...] "poison messages" [...] (messages which continually fail {{to be processed}} correctly by the receiver), and support for <b>transactional</b> receives of <b>messages</b> from a remote queue.|$|R
25|$|Windows Vista also {{incorporates}} Microsoft Message Queuing 4.0 (MSMQ) {{that supports}} subqueues, poison messages (messages which continually fail {{to be processed}} correctly by the receiver), and <b>transactional</b> receives of <b>messages</b> from a remote queue.|$|R
40|$|This paper {{gives an}} {{overview}} of Demaq, an XML message processing system operating on the foundation of <b>transactional</b> XML <b>message</b> queues. We focus on the syntax and semantics of its fully declarative, rule-based application language and demonstrate our message-based programming paradigm {{in the context of}} a case study. Further, we discuss optimization opportunities for executing Demaq programs. Comment: This article is published under a Creative Commons License Agreement ([URL] You may copy, distribute, display, and perform the work, make derivative works and make commercial use of the work, but, you must attribute the work to the author and CIDR 2007. 3 rd Biennial Conference on Innovative Data Systems Research (CIDR) January 710, 2007, Asilomar, California, US...|$|R
50|$|Each {{object is}} aware of, and in direct control, of its {{behavior}} in time. Open Cobalt also directly supports replication of computation, allowing computation {{to be moved}} close {{to the point of}} interaction on demand, while maintaining a consistent view of behaviors that can scale to include thousands of nodes. It does this by using a combination of object semantics along with a modified version of David P. Reed's TeaTime peer-based messaging protocol as a distributed <b>message</b> <b>transactional</b> system enabling replicated computation (synchronization) across multiple peers. This makes replicated computation as easily as replicating data - and makes synchronization of all events across multiple peers a fundamental property of the system.|$|R
40|$|Many {{concurrent}} programming models enable both <b>transactional</b> memory and <b>message</b> passing. For such models, researchers have built increasingly efficient implementations and defined reasonable correctness criteria, while it {{remains an open}} problem to obtain {{the best of both}} worlds. We present a programming model that is the first to have opaque transactions, safe asynchronous message passing, and an efficient implementation. Our semantics uses tentative message passing and keeps track of dependencies to enable undo of message passing in case a transaction aborts. We can program communication idioms such as barrier and rendezvous that do not deadlock when used in an atomic block. Our experiments show that our model adds little overhead to pure transactions, and that it is significantly more efficient than Transactional Events. We use a novel definition of safe message passing that may be of independent interest...|$|R
50|$|PostgreSQL {{provides}} an asynchronous messaging {{system that is}} accessed through the NOTIFY, LISTEN and UNLISTEN commands. A session can issue a NOTIFY command, along with the user-specified channel and an optional payload, to mark a particular event occurring. Other sessions are able to detect these events by issuing a LISTEN command, which can listen to a particular channel. This functionality {{can be used for}} a wide variety of purposes, such as letting other sessions know when a table has updated or for separate applications to detect when a particular action has been performed. Such a system prevents the need for continuous polling by applications to see if anything has yet changed, and reducing unnecessary overhead. Notifications are fully <b>transactional,</b> in that <b>messages</b> are not sent until the transaction they were sent from is committed. This eliminates the problem of messages being sent for an action being performed which is then rolled back.|$|R
40|$|Abstract. The actor {{model has}} been {{successfully}} used for scalable com-puting in distributed systems. Actors are objects with a local state, {{which can only be}} modified by the exchange of messages. One of the fundamen-tal principles of actor models is to guarantee sequential message process-ing, which avoids typical concurrency hazards, but limits the achievable message throughput. Preserving the sequential semantics of the actor model is, however, necessary for program correctness. In this paper, we propose to add support for speculative concurrent ex-ecution in actors using transactional memory (TM). Our approach is designed to operate with message passing and shared memory, and can thus take advantage of parallelism available on distributed and multi-core systems. The processing of each message is wrapped in a transaction exe-cuted atomically and in isolation, but concurrently with other messages. This allows us (1) to scale while keeping the dependability guarantees ensured by sequential message processing, and (2) to further increase robustness of the actor model against threats due to the rollback ability that comes for free with <b>transactional</b> processing of <b>messages.</b> We vali-date our design within the Scala programming language and the Akka framework. We show that the overhead of using transactions is hidden by the improved message processing throughput, thus leading to an overall performance gain...|$|R
40|$|Abstract — The {{popularity}} of Web-based transactions {{and the need}} for more sophisticated content distribution methods has helped to fuel the rapid growth of Web Service adoption, specifically, HTTP-bound Web Services. Secure and efficient content delivery has long been a requirement of traditional Web-based distribution schemes, and existing the Web infrastructure provides numerous options for securing and optimizing HTTP. Two exemplary technologies are SSL/TLS and HTTP compression. While efforts to solidify the more granular WS-Security standards are ongoing, and methods for XML message compression schemes continue to be investigated, HTTP provides an interim solution, supporting <b>transactional</b> security and <b>message</b> compression. The SSL/TLS and HTTP compression technologies have become commoditized and pervasive. And with the trend in content delivery toward hardware offload for these functions, modern data centers have begun to raise the bar for performance. In this paper, we examine three different paradigms for implementing SSL/TLS and HTTP compression: softwarebased functionality, server-resident hardware accelerators, and centralized network-resident hardware accelerators. We discuss the trade-offs between the two different offload techniques (i. e., PCI accelerator vs. network proxy) and explore their relationship to the current performance activities, in the field of Web Services. In analyzing the results for SSL/TLS offload, and the effects of compression, in conjunction with SSL/TLS, we draw parallels with the efforts of WS-Security and XML message compression. Although optimizations for software-based cryptography will continue to advance, the potential for hardware-based acceleration should not be overlooked. We discuss our results and address deployment scenarios for optimizing Web-based transactions, and the future optimization of Web Service transactions. I...|$|R

