203|1955|Public
25|$|Consider {{the natural}} {{logarithm}} function mapping the real numbers to themselves. The logarithm of a non-positive real {{is not a}} real number, so the natural logarithm function doesn't associate any real number in the codomain with any non-positive real number in the domain. Therefore, the natural logarithm function is not a <b>total</b> <b>function</b> when viewed as a function from the reals to themselves, {{but it is a}} partial function. If the domain is restricted to only include the positive reals (that is, if the natural logarithm function is viewed as a function from the positive reals to the reals), then the natural logarithm is a <b>total</b> <b>function.</b>|$|E
25|$|An {{injective}} {{partial function}} may be inverted to an injective partial function, and a partial function {{which is both}} injective and surjective has an injective function as inverse. Furthermore, a <b>total</b> <b>function</b> which is injective may be inverted to an injective partial function.|$|E
25|$|In a {{sound proof}} system, every provably <b>total</b> <b>function</b> is indeed total, but the {{converse}} is not true: in every first-order proof {{system that is}} strong enough and sound (including Peano arithmetic), one can prove (in another proof system) the existence of total functions that cannot be proven total in the proof system.|$|E
25|$|The set of provably <b>total</b> <b>functions</b> is recursively enumerable: one can enumerate all the provably <b>total</b> <b>functions</b> by {{enumerating}} {{all their}} corresponding proofs, that prove their computability. This {{can be done}} by enumerating all the proofs of the proof system and ignore irrelevant ones.|$|R
5000|$|... #Subtitle level 3: <b>Total</b> <b>functions</b> {{that are}} not provably total ...|$|R
40|$|Abstract- This paper {{investigates the}} use of partial {{functions}} and fitness sharing in genetic programming. Fitness sharing is applied to populations of either partial or <b>total</b> <b>functions</b> and the results compared. Applications to two classes of problem are investigated: learning multiplexer definitions, and learning (recursive) list membership functions. In both cases, fitness sharing approaches outperform {{the use of}} raw fitness, by generating more accurate solutions with the same population parameters. On the list membership problem, variants using fitness sharing on populations of partial functions outperform variants using <b>total</b> <b>functions,</b> whereas populations of <b>total</b> <b>functions</b> give better performance on some variants of multiplexer problems. ...|$|R
25|$|A {{function}} {{problem is}} a computational problem where a single output (of a <b>total</b> <b>function)</b> is expected for every input, but the output {{is more complex than}} that of a decision problem, that is, it isn't just yes or no. Notable examples include the traveling salesman problem and the integer factorization problem.|$|E
25|$|The {{converse}} is not true, as {{not every}} provably <b>total</b> <b>function</b> is primitive recursive. Indeed, one can enumerate all the primitive recursive functions and define a function en such {{that for all}} n, m: en(n,m) = f'n(m), where f'n is the n-th primitive recursive function (for k-ary functions, this will be set to f'n(m,m...m)). Now, g(n) = en(n,n)+1 is provably total but not primitive recursive, by a diagonalization argument: had there been a j such that g = f'j, we would have got g(j) = en(j,j)+1 = f'j (j)+1= g(j)+1, a contradiction. (It {{should be noted that}} the Gödel numbers of all primitive recursive functions can be enumerated by a primitive recursive function, though the primitive recursive functions' values cannot).|$|E
2500|$|The first diagram above {{represents}} a partial function {{that is not}} a <b>total</b> <b>function</b> since the element 1 in the left-hand set is not associated with anything in the right-hand set. [...] Whereas, the second diagram {{represents a}} <b>total</b> <b>function</b> since every element on the left-hand set is associated with exactly one element in the right hand set.|$|E
5000|$|The second {{question}} asks, in essence, {{whether there is}} another reasonable model of computation which computes only <b>total</b> <b>functions</b> and computes all the <b>total</b> computable <b>functions.</b> Informally, if such a model existed then each of its computers could be simulated by a Turing machine. Thus if this new model of computation consisted of a sequence [...] of machines, {{there would be a}} recursively enumerable sequence [...] of Turing machines that compute <b>total</b> <b>functions</b> and so that every <b>total</b> computable <b>function</b> is computable by one of the machines Ti. This is impossible, because a machine [...] could be constructed such that on input i the machine T returns [...] This machine cannot be equivalent to any machine T on the list: suppose it were on the list at index j. Then , which does not return an integer result. Therefore, it can't be <b>total,</b> but the <b>function</b> by construction must be <b>total</b> (if <b>total</b> <b>functions</b> are recursively enumerable, then this function can be constructed), so we have a contradiction. This shows that the {{second question}} has a negative answer.|$|R
30|$|To {{determine}} the optimal ordering quantities from <b>total</b> cost <b>function.</b> In {{the next section}} we will graphically show that the <b>total</b> cost <b>function</b> is a strictly convex function and using this property of <b>total</b> cost <b>function,</b> next we provide an algorithm to obtain the optimal ordering quantities.|$|R
40|$|Abstract- This paper {{investigates the}} use of partial {{functions}} in genetic programming. Previous work {{has shown that the}} convergent behaviour of populations of partial functions is very similar to that of populations of <b>total</b> <b>functions.</b> However the convergence rates of populations of partial functions have been slower. The results presented here demonstrate a significant improvement in the rate of convergence of populations of partial functions, and indicate that partial functions represent a realistic alternative to <b>total</b> <b>functions</b> for a range of problems...|$|R
2500|$|For a given R(y) the {{unbounded}} mu operator μyR(y) (note no {{requirement for}} [...] "(Ey)" [...] ) is a partial function. Kleene makes it as a <b>total</b> <b>function</b> instead (cf. p.317): ...|$|E
2500|$|A partial {{function}} {{is said to}} be injective or surjective when the <b>total</b> <b>function</b> given by the restriction of the {{partial function}} to its domain of definition is. [...] A partial function may be both injective and surjective.|$|E
2500|$|A set [...] {{of natural}} numbers is called computable (synonyms: recursive, decidable) {{if there is}} a computable, <b>total</b> <b>function</b> [...] such that for any natural number , [...] if [...] is in [...] and [...] if [...] is not in [...]|$|E
40|$|In {{this paper}} we present an {{algebraic}} construction of monotonic predicate transformers, using a categorical construction {{which is similar}} to the algebraic construction of the integers from the natural numbers. When applied to the category of sets and <b>total</b> <b>functions</b> once, it yields a category isomorphic to the category of sets and relations; a second application yields a category isomorphic to the category of monotonic predicate transformers. This hierarchy cannot be extended further: the category of <b>total</b> <b>functions</b> is not itself an instance of the categorical construction, and can only be extended by it twice. 1 Introduction Predicate transformers were introduced originally by Dijkstra [8] in order to provide an elegant semantics for his programming language. Their strength {{lies in the fact that}} they can be used to model non-deterministic and non-terminating behaviour in terms of <b>total</b> <b>functions,</b> rather than relations. Not all monotonic predicate transformers represent programs in [...] ...|$|R
40|$|AbstractIn {{this paper}} we present an {{algebraic}} construction of monotonic predicate transformers, using a categorical construction {{which is similar}} to the algebraic construction of the integers from the natural numbers. When applied to the category of sets and <b>total</b> <b>functions</b> once, it yields a category isomorphic to the category of sets and relations; a second application yields a category isomorphic to the category of monotonic predicate transformers. This hierarchy cannot be extended further: the category of <b>total</b> <b>functions</b> is not itself an instance of the categorical construction, and can be extended by it only twice...|$|R
40|$|The {{need to use}} partial {{functions}} arises {{frequently in}} formal descriptions of computer systems. However, most proof assistants are based on logics of <b>total</b> <b>functions.</b> One way to address this mismatch is to invent and mechanize a new logic. Another is to develop practical workarounds in existing settings. In this paper we take the latter course: we survey and compare methods used to support partiality in a mechanization {{of a higher order}} logic featuring only <b>total</b> <b>functions.</b> The techniques we discuss are generally applicable and are illustrated by relatively large examples...|$|R
2500|$|Kleene also admits a third {{situation}} (c) {{that does}} not require the demonstration of [...] "for all x a y exists such that ψ(x, y)." [...] He uses this in his proof that more total recursive functions exist than can be enumerated; cf footnote <b>Total</b> <b>function</b> demonstration.|$|E
2500|$|In fact, [...] is a <b>total</b> <b>function.</b> Given , let [...] Then [...] is dense. (Given any , if [...] {{is not in}} ’s domain, adjoin a {{value for}} [...] — the result is in [...]) A {{condition}} [...] has [...] in its domain, and since , we find that [...] is defined.|$|E
2500|$|What is {{mandatory}} if the {{function is to}} be a <b>total</b> <b>function</b> is a demonstration by some other method (e.g. induction) that for each and every combination of values of its parameters xi some natural number y will satisfy the μ-operator so that the algorithm that represents the calculation can terminate: ...|$|E
30|$|Rule 6 : Fuzzy {{values of}} each element in P, Y and hedges δ are {{translated}} to <b>total</b> <b>functions</b> deg_P: P →N, deg_Y: Y →N, and deg_H: H →N respectively.|$|R
50|$|The axiom of {{fullness}} implies CST's axiom of exponentiation: {{given two}} sets, {{the collection of}} all <b>total</b> <b>functions</b> {{from one to the}} other is also in fact a set.|$|R
2500|$|... {{then the}} five {{primitive}} recursive operators plus the unbounded-but-total μ-operator {{give rise to}} what Kleene called the [...] "general" [...] recursive <b>functions</b> (i.e. <b>total</b> <b>functions</b> defined by the six recursion operators).|$|R
2500|$|In Category theory, when {{considering}} the operation of morphism composition in Concrete Categories, the composition operation [...] is a <b>total</b> <b>function</b> {{if and only if}} [...] has one element. The {{reason for this is that}} two morphisms [...] and [...] can only be composed as [...] if , that is, the codomain of [...] must equal the domain of [...]|$|E
2500|$|DNR (short for [...] "diagonally non-recursive") adds to RCA0 an axiom asserting the {{existence}} of a diagonally non-recursive function relative to every set. That is, DNR states that, for any set A, there exists a <b>total</b> <b>function</b> f such that for all e the eth partial recursive function with oracle A is not equal to f. DNR is strictly weaker than WWKL (Lempp et al., 2004).|$|E
2500|$|... "Total function" [...] is {{a synonym}} for function. The use of the {{adjective}} [...] "total" [...] is {{to suggest that it}} is a special case of a partial function (specifically, a <b>total</b> <b>function</b> with domain X is a special case of a partial function over X). [...] The adjective will typically be used for clarity in contexts where partial functions are common, for example in computability theory.|$|E
40|$|AbstractObjectiveTo link {{pediatric}} health-related {{quality of}} life (HRQOL) and health conditions by establishing clinically meaningful cutoff scores for an HRQOL instrument, the Pediatric Quality of Life Inventory (PedsQL). MethodsWe conducted telephone interviews with 1745 parents whose children were between 2 and 18 years old and enrolled in the Florida KidCare program and Children's Medical Services Network in 2006. Two anchors, the Children with Special Health Care Needs (CSHCN) Screener and the Clinical Risk Groups (CRGs), were used to identify children with special health-care needs or chronic conditions. We established cutoff scores for the PedsQL's physical, emotional, social, school, and <b>total</b> <b>functioning</b> using the areas under the curves (AUCs) to determine the discriminative property of the PedsQL referring to the anchors. ResultsThe discriminative property of the PedsQL was superior, especially in <b>total</b> <b>functioning</b> (AUC > 0. 7), between children with special health-care needs (based on the CSHCN Screener) and with moderate and major chronic conditions (based on the CRGs) as compared to healthy children. For children < 8 years, the recommended cutoff scores for using <b>total</b> <b>functioning</b> to identify CSHCN were 83, 79 for moderate, and 77 for major chronic conditions. For children ≥ 8 years, the cutoff scores were 78, 76, and 70, respectively. ConclusionsPediatric HRQOL varied with health conditions. Establishing cutoff scores for the PedsQL's <b>total</b> <b>functioning</b> is a valid and convenient means to potentially identify children with special health-care needs or chronic conditions. The cutoff scores can help clinicians to conduct further in-depth clinical assessments...|$|R
40|$|AbstractLet G=(V,E) be a graph. A {{function}} f:V→{− 1,+ 1 } defined on the vertices of G is {{a signed}} <b>total</b> dominating <b>function</b> if {{the sum of}} its function values over any open neighborhood is at least one. A signed <b>total</b> dominating <b>function</b> f is minimal if there does not exist a signed <b>total</b> dominating <b>function</b> g, f≠g, for which g(v) ≤f(v) for every v∈V. The weight of a signed <b>total</b> dominating <b>function</b> is {{the sum of its}} function values over all vertices of G. The upper signed total domination number of G is the maximum weight of a minimal signed <b>total</b> dominating <b>function</b> on G. In this paper we present a sharp upper bound on the upper signed total domination number of an arbitrary graph. This result generalizes previous results for regular graphs and nearly regular graphs...|$|R
40|$|Summary. In {{the article}} we define partial functions. We also define the {{following}} notions related to partial functions and functions themselves: the empty function, the restriction of a function to a partial function from a set into a set, {{the set of}} all partial functions from a set into a set, the <b>total</b> <b>functions,</b> the relation of tolerance of two functions and the set of all <b>total</b> <b>functions</b> which are tolerated by a partial function. Some simple propositions related to the introduced notions are proved. In {{the beginning of this}} article we prove some auxiliary theorems and schemas related to the articles: [1] and [2]...|$|R
2500|$|An ongoing area of {{research}} in recursion theory studies reducibility relations other than Turing reducibility. Post (1944) introduced several strong reducibilities, so named because they imply truth-table reducibility. A Turing machine implementing a strong reducibility will compute a <b>total</b> <b>function</b> regardless of which oracle it is presented with. [...] Weak reducibilities are those where a reduction process may not terminate for all oracles; Turing reducibility is one example.|$|E
2500|$|In mathematics, {{a partial}} {{function}} from X to Y (written as [...] ) {{is a function}} , for some subset X ′ ofX. It generalizes {{the concept of a}} function [...] by not forcing f to map every element of X to an element of Y (only some subset X ′ of X). If , then f is called a <b>total</b> <b>function</b> and is equivalent to a function. Partial functions are often used when the exact domain, X, is not known (e.g. many functions in computability theory).|$|E
2500|$|Intuitionistic logic was {{developed}} by Heyting to study Brouwer's program of intuitionism, in which Brouwer himself avoided formalization. Intuitionistic logic specifically {{does not include the}} law of the excluded middle, which states that each sentence is either true or its negation is true. [...] Kleene's work with the proof theory of intuitionistic logic showed that constructive information can be recovered from intuitionistic proofs. For example, any provably <b>total</b> <b>function</b> in intuitionistic arithmetic is computable; this is not true in classical theories of arithmetic such as Peano arithmetic.|$|E
50|$|A set is {{recursive}} if {{and only}} if it is either the range of a nondecreasing <b>total</b> computable <b>function</b> or the empty set. The image of a computable set under a nondecreasing <b>total</b> computable <b>function</b> is computable.|$|R
40|$|Let G=(V,E) be a graph. A {{function}} f:V→{− 1,+ 1 } defined on the vertices of G is {{a signed}} <b>total</b> dominating <b>function</b> if {{the sum of}} its function values over any open neighborhood is at least one. A signed <b>total</b> dominating <b>function</b> f is minimal if there does not exist a signed <b>total</b> dominating <b>function</b> g, f≠g, for which g(v) ≤f(v) for every v∈V. The weight of a signed <b>total</b> dominating <b>function</b> is {{the sum of its}} function values over all vertices of G. The upper signed total domination number of G is the maximum weight of a minimal signed <b>total</b> dominating <b>function</b> on G. In this paper we present a sharp upper bound on the upper signed total domination number of an arbitrary graph. This result generalizes previous results for regular graphs and nearly regular graphs. Department of Logistics and Maritime Studie...|$|R
50|$|Let L be an ordered set, {{called a}} {{concrete}} set and let L&prime; be another ordered set, called an abstract set. These two sets {{are related to}} each other by defining <b>total</b> <b>functions</b> that map elements from one to the other.|$|R
