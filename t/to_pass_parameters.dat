21|10000|Public
25|$|As with {{directly}} recursive functions, a wrapper function may be useful, {{with the}} mutually recursive functions defined as nested functions within its scope {{if this is}} supported. This is particularly useful for sharing state across a set of functions without having <b>to</b> <b>pass</b> <b>parameters</b> between them.|$|E
500|$|COBOL code {{could only}} be modularized through procedures, which {{were found to be}} {{inadequate}} for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify [...] data item. Furthermore, there was no way <b>to</b> <b>pass</b> <b>parameters</b> to a procedure, an omission Jean Sammet regarded as the committee's biggest mistake.|$|E
50|$|Pointers {{are used}} <b>to</b> <b>pass</b> <b>parameters</b> by reference. This is useful if the {{programmer}} wants a function's modifications to a parameter {{to be visible}} to the function's caller. This is also useful for returning multiple values from a function.|$|E
5000|$|It is {{possible}} <b>to</b> <b>pass</b> initialization <b>parameters</b> <b>to</b> the servlet {{so that it}} may configure itself.|$|R
5000|$|The q-component {{was added}} <b>to</b> enable <b>passing</b> of <b>parameters</b> <b>to</b> named resources.|$|R
5000|$|... An Object or Array {{of values}} <b>to</b> be <b>passed</b> as <b>parameters</b> <b>to</b> the defined method.|$|R
50|$|As with {{directly}} recursive functions, a wrapper function may be useful, {{with the}} mutually recursive functions defined as nested functions within its scope {{if this is}} supported. This is particularly useful for sharing state across a set of functions without having <b>to</b> <b>pass</b> <b>parameters</b> between them.|$|E
50|$|The key {{component}} of dynamic memory is the last in, first out (LIFO) stack as this makes using the various functions much easier. A MULTOS chip is a stack machine, which makes use of this dynamic memory <b>to</b> <b>pass</b> <b>parameters</b> and perform calculations. In addition, the Input/output buffer resides in another dynamic memory segment.|$|E
5000|$|The x86 {{architecture}} has hardware {{support for}} an execution stack mechanism. Instructions such as , , [...] and [...] are used with the properly set up stack <b>to</b> <b>pass</b> <b>parameters,</b> to allocate space for local data, and to save and restore call-return points. The [...] size instruction is very useful for implementing space efficient (and fast) calling conventions where the callee is responsible for reclaiming stack space occupied by parameters.|$|E
50|$|Proponents of modular {{programming}} (modularizing code) advocate that each subroutine should have minimal dependency on {{other pieces of}} code. For example, the use of global variables is generally deemed unwise by advocates for this perspective, because it adds tight coupling between the subroutine and these global variables. If such coupling is not necessary, their advice is to refactor subroutines <b>to</b> accept <b>passed</b> <b>parameters</b> instead. However, {{increasing the number of}} <b>parameters</b> <b>passed</b> <b>to</b> subroutines can affect code readability.|$|R
2500|$|Optional {{parameters}} make interoperating with COM easier. Previously, C# had <b>to</b> <b>pass</b> {{in every}} <b>parameter</b> in {{the method of}} the COM component, even those that are optional. For example: ...|$|R
40|$|The {{last chapter}} {{described}} how <b>to</b> create procedures, <b>pass</b> <b>parameters,</b> and allocate and access local variables. This chapter picks up where that one left off and describes how to access non-local variables in other procedures, <b>pass</b> procedures as <b>parameters,</b> and implement some user-defined control structures...|$|R
50|$|Uniface accesses {{the many}} {{databases}} and file systems it supports {{by means of}} database connectors (or drivers). DBMS connectors map and convert Uniface data types to the most suitable format of the particular storage medium. At runtime, it is possible <b>to</b> <b>pass</b> <b>parameters</b> to invoke (or disable) database-specific extensions. Provided the database connector is licensed, {{it is possible to}} convert between different data sources. Uniface also provides an API, the Database Connector Interface, which can be used to create proprietary connectors for any SQL-based database.|$|E
5000|$|The calling {{convention}} for C code {{in particular was}} <b>to</b> <b>pass</b> <b>parameters</b> in [...] "reverse order" [...] on the stack and return values on the stack {{rather than in a}} processor register. There were other programming rules to make all the languages work together, but this particular rule persisted through the cross language development that continued throughout Windows 16 and 32 bit versions and in the development of programs for OS/2, and which persists to this day. It is known as the Pascal {{calling convention}}.|$|E
50|$|In {{computer}} science, {{computer engineering}} and programming language implementations, a stack machine {{is a type}} of computer. In some cases, the term refers to a software scheme that simulates a stack machine. The main difference from other computers is that most of its instructions operate on a pushdown stack of numbers rather than numbers in registers. A stack computer is programmed with a reverse Polish notation instruction set. Most computer systems implement a stack in some form <b>to</b> <b>pass</b> <b>parameters</b> and link to subroutines. This does not make these computers stack machines.|$|E
5000|$|The r-component {{was added}} <b>to</b> enable <b>passing</b> of <b>parameters</b> <b>to</b> resolvers. However, the updated {{specification}} {{notes that the}} r-component {{should not be used}} until its semantics are defined via further standardization.|$|R
50|$|Direct Naming Reference: All {{internal}} controls {{can be accessed}} directly and <b>passed</b> as <b>parameters</b> <b>to</b> subroutines by specifying their name expressed as a string. This lets the programmer the ability <b>to</b> <b>pass</b> controls as <b>parameters</b> without knowing in advance the control that is <b>to</b> be <b>passed,</b> and without {{having to deal with}} either pointers nor with object oriented programming.|$|R
50|$|Parameter style - {{defines the}} {{conventions}} {{that are used}} <b>to</b> <b>pass</b> the function <b>parameters</b> and results between {{the implementation of the}} function and the database system (only applicable if language is not SQL).|$|R
5000|$|COBOL {{programs}} were infamous for being monolithic and lacking modularization.COBOL code {{could only be}} modularized through procedures, which {{were found to be}} inadequate for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify [...] data item. Furthermore, there was no way <b>to</b> <b>pass</b> <b>parameters</b> to a procedure, an omission Jean Sammet regarded as the committee's biggest mistake.Another complication stemmed from the ability to [...] a specified sequence of procedures. This meant that control could jump to and return from any procedure, creating convoluted control flow and permitting a programmer to break the single-entry single-exit rule.|$|E
5000|$|Most {{programming}} environments with recursive subroutines use a stack {{for control}} flow. This structure typically also stores local variables, including subroutine parameters (in {{call by value}} system such as C). Forth often does not have local variables, however, nor is it call-by-value. Instead, intermediate values are kept in another stack, {{different from the one}} it uses for return addresses, loop counters, etc. Words operate directly on the topmost values in the first of these two stacks. It may therefore be called the [...] "parameter" [...] or [...] "data" [...] stack, but most often simply [...] "the" [...] stack. The second, function-call stack is then called the [...] "linkage" [...] or [...] "return" [...] stack, abbreviated rstack. Special rstack manipulation functions provided by the kernel allow it to be used for temporary storage within a word, and it is often used by counted loops, but otherwise it cannot be used <b>to</b> <b>pass</b> <b>parameters</b> or manipulate data.|$|E
40|$|Each {{subroutine}} {{operates in}} {{in its own}} local environment plus surrounding environments defined by the language’s scope rules. When a subroutine is invoked, it is necessary <b>to</b> <b>pass</b> <b>parameters</b> from the caller to the callee. A basic question concerning parameter passing is: For each parameter, what exactly is passed from the caller to the callee — the parameter’s address (l-value) ? its content (r-value) ? or something else? Answers to this question define parameter passing methods...|$|E
5000|$|... hwinfo is the {{hardware}} detection tool used in SuSE Linux {{and in some}} other GNU/Linux distributions. To use hwinfo to get the actual mode number that you need <b>to</b> <b>pass</b> as a <b>parameter</b> <b>to</b> the kernel: ...|$|R
5000|$|Whilst {{many people}} {{understood}} how Copylock worked, very few had bothered {{to take the}} time to work out how to actually decode one, because they previously didn't need to bother. But now, Rob Northen was adding extra stuff <b>to</b> Copylock. <b>Passing</b> <b>parameters</b> <b>to</b> Copylock before it executed meant that Copylock could now write more than just the Serial Key, it could write specific game related values into the contents of registers <b>passed</b> <b>to</b> Copylock, or simply write values to a list of pre-known address values which would make the game operate correctly.|$|R
40|$|WSDL web {{services}} are {{built around the}} request-reply framework, requiring service invocation to be bundled together with all relevant data in a single message. Inefficiency becomes evident as web service providers begin to offer more robust services that require massive datasets (e. g., multimedia and scientific data). Under the WSDL standards, these hefty datasets must be ported to an appropriate message format and transferred in their entirety upon each service invocation or response. Significant gains in service flexibility and performance can be made simply by separating invocation messages from their datasets. Such a separation ultimately grants service consumers the ability <b>to</b> <b>pass</b> <b>parameter</b> datasets from third party hosts, to maintain dataset parameters on the service provider host for use with future service invocations, and to provide datasets {{in a variety of}} different formats. In this paper, we develop a service invocation mechanism, called WSDL-D, to support this separation of service invocation from parameter datasets. 1...|$|R
40|$|This paper {{focuses on}} the fact that a {{developer}} should not be concerned whether his application will be distributed or not. Because the current remoting infrastructures use serialisation <b>to</b> <b>pass</b> <b>parameters,</b> synchronisation problems exist. We will elaborate on a transparent framework to pass mutable objects to remote operations, {{in the same way as}} they are passed to local operations. A number of solutions will be proposed to provide this transparency. Finally, a solution based on a caching mechanism will be implemented using annotations. status: publishe...|$|E
40|$|The {{general design}} and {{analysis}} {{functions of the}} NASA Regional Planetary Image Facility (RPIF) image workstation prototype are described. The main functions of the MicroVAX II based workstation will be database searching, digital image retrieval, and image processing and display. The uses of the Transportable Applications Executive (TAE) in the system are described. File access and image processing programs use TAE tutor screens to receive parameters from the user and TAE subroutines are used <b>to</b> <b>pass</b> <b>parameters</b> to applications programs. Interface menus are also provided by TAE...|$|E
40|$|In this pauper, {{we present}} two new pointcuts and two new {{primitives}} to Aspect-Oriented Programming (AOP) languages {{that are needed}} for systematic hardening of security concerns. The two proposed pointcuts allow to identify particular join points in a progiam's control flow graph (CFG). The first one is the GAFlow, the Closest Guaranteed Ancestor, which returns the closest ancestor join point to the pointcuts of interest that is on all their runtime paths. The second one is the GDFlow, the Closest Guaranteed Descendant, which returns the closest child join point that {{can be reached by}} all paths starting from the pointculs of interest. The two proposed primitives are called ExportParameter and ImportParameter and are used <b>to</b> <b>pass</b> <b>parameters</b> between two pointcuts. PublishedN/...|$|E
50|$|In {{mathematics}} a variable's value may not change. This {{is fundamental}} to the mathematical approach. Functional languages based on lambda calculus allow this mathematical approach to programming. Functional languages developed by implementing lazy evaluation, and allowing functions <b>to</b> be <b>passed</b> as <b>parameters.</b>|$|R
50|$|Hard coding {{is often}} required, {{but can also}} be {{considered}} an anti-pattern. Programmers may not have a dynamic user interface solution for the end user worked out but must still deliver the feature or release the program. This is usually temporary but does resolve, in a short term sense, the pressure to deliver the code. Later, softcoding is done to allow a user <b>to</b> <b>pass</b> on <b>parameters</b> that give the end user a way to modify the results or outcome.|$|R
40|$|The paper {{considers}} {{the problems and}} the solutions that {{are concerned with the}} extension of Java with Higher Order (HO) mechanisms. These mechanisms are typical of functional languages and include higher order abstraction, that makes a Java method parametric with respect to other methods that can be <b>passed</b> as <b>parameters,</b> and code as first class value, that can be assigned <b>to</b> variables, <b>passed</b> as <b>parameter,</b> returned by method invocations...|$|R
40|$|Procedural {{geometry}} paradigms {{are analyzed}} and classified as either "data amplifier" or "lazy evaluation. " Lazy evaluation reduces {{the size of}} the geometric representation passed to renderers and increases the flexibility of procedural experimentation. Several existing procedural geometry systems are compared in this light, and a new one is proposed, called procedural geometric instancing. Inspired by shading languages, procedural geometric instancing is a modeling language that embeds functional calls in the geometric representation which are evaluated on demand during rendering. Procedural geometric instancing enables articulation of highly detailed models with the ability to inductively specify billions of objects with a few lines of code, and <b>to</b> <b>pass</b> <b>parameters,</b> facilitating more complex relationships between parent and child geometries. Furthermore, it defines functions for local access to the world coordinate system which supports global effects such as tropism. The hierarchical [...] ...|$|E
40|$|Inter-procedural {{register}} allocation can {{minimize the}} register usage penalty at procedure calls {{by reducing the}} saving and restoring of registers at procedure boun-daries. A one-pass inter-procedural register allocation scheme based on processing the procedures in a depth-first traversal of the calI graph is presented. This scheme can be overlayed on top of intra-procedural register allocation via a simple extension to the priority-based coloring algorithm. Using two different usage conventions for the registers, the scheme can dis-tribute register saves/restores throughout the call graph even {{in the presence of}} recursion, indirect calls or separate compilation. A natural and efficient way <b>to</b> <b>pass</b> <b>parameters</b> emerges from this scheme. A separate technique uses data flow analysis to optimize the place-ment of the save/restore code for registers within indivi-dual procedures. The techniques described have been implemented in a production compiler suite. Measure-ments of the effects of these techniques on a set of practical programs are presented and the results analysed. 1...|$|E
40|$|In this paper, {{we present}} new pointcuts and {{primitives}} to Aspect-Oriented Programming (AOP) languages {{that are needed}} for systematic hardening of security concerns. The two proposed pointcuts allow to identify particular join points in a program's control-flow graph (CFG). The first one is the GAFlow, Closest Guaranteed Ancestor, which returns the closest ancestor join point to the pointcuts of interest that is on all their runtime paths. The second one is the GDFlow, Closest Guaranteed Descendant, which returns the closest child join point that {{can be reached by}} all paths starting from the pointcut of interest. The two proposed primitives are called ExportParameter and ImportParameter and are used <b>to</b> <b>pass</b> <b>parameters</b> between two pointcuts. They allow to analyze a program's call graph in order to determine how to change function signatures for passing the parameters associated with a given security hardening. We find these pointcuts and primitives to be necessary because they are needed to perform many security hardening practices and, {{to the best of our}} knowledge, none of the existing ones can provide their functionalities. Moreover, we show the viability and correctness of the proposed pointcuts and primitives by elaborating and implementing their algorithms and presenting the result of explanatory case studies. PublishedN/...|$|E
40|$|Calling {{conventions}} are {{so difficult}} to implement and maintain that people rarely experiment with alternatives. The primary sources of difficulty appear <b>to</b> be <b>parameter</b> <b>passing</b> and stack-frame layout. <b>To</b> implement <b>parameter</b> <b>passing,</b> we use the automata developed by Bailey and Davidson, but we have developed a new specification language that is implementable directly in the compiler. To implement stack-frame layout, we have developed an applicative, composable abstraction that cleanly decouples {{the layout of the}} stack frame from the order in which compiler phases execute. We hope these abstractions will so simplify the implementation problem that compiler writers will routinely customize calling conventions to improve performance. ...|$|R
40|$|One of Pascal's virtues is that {{it permits}} the {{creation}} of modular programs by using logically independent procedures. However this advantage of Pascal is utilized only when students learn to handle procedures and <b>to</b> manage <b>parameter</b> <b>passing</b> well enough <b>to</b> harness Pascal's power. This study examined student knowledge relating <b>to</b> <b>parameter</b> <b>passing</b> in Pascal. During interviews, {{students were asked to}} predict which programs from a collection of similar programs would work according to specification and which would not work due to variable access errors or <b>parameter</b> <b>passing</b> errors. This paper will discuss these interviews. In particular it will examine the most pervasive false assumptions or "student-constructed rules" exposed by the interviews. It will also discuss hints provided by the interviews regarding instructional methods to emphasize and instructional methods to avoid...|$|R
5000|$|Postback: With the {{advancement}} in the system, it's a {{need of the}} software which is integrable with other affiliate software. With Postback one can do third party integration. In server to server / Postback tracking, {{there is no need}} to resort to last touch attribution because every time a user views your ads we generate a unique Click ID which we <b>pass</b> <b>to</b> you as a parameter.You will take care <b>to</b> <b>pass</b> this <b>parameter</b> back <b>to</b> us when the conversion happens and have the possibility to add a dynamic conversion value to the server to server operation if needed.|$|R
