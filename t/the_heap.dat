2215|3326|Public
5|$|The plot of {{the first}} book, {{entitled}} Magyk (published in March 2005), revolves around the pauper Heap family: Silas, Sarah and their seven children. The story begins when Silas finds Jenna in the snow. Septimus is born on the same day, but is declared dead by the midwife, who steals the baby and brings him to DomDaniel, an evil wizard. However, he is confused with the midwife's own son and {{is sent to the}} Supreme Custodian to help start a boy army. On her tenth birthday, Jenna learns from ExtraOrdinary Wizard Marcia Overstrand that she is a princess, but that she—and <b>the</b> <b>Heap</b> family—are in danger. Jenna and Nicko Heap escape to their Aunt Zelda's cottage. They are accompanied {{by a member of the}} Young Army called Boy 412, who discovers his magic powers and a legendary ring while at Zelda's. Marcia is imprisoned in DomDaniel´s boat, Vengeance, and nearly dies, but is rescued by Boy 412, Jenna and Nicko after they find a flying Dragon Boat in a secret cavern by Zelda´s cottage. At the end of the novel, Boy 412 is revealed to be Septimus, and his family hears of his past.|$|E
25|$|In {{the second}} step, a sorted array {{is created by}} {{repeatedly}} removing the largest element from <b>the</b> <b>heap</b> (the root of <b>the</b> <b>heap),</b> and inserting it into the array. <b>The</b> <b>heap</b> is updated after each removal to maintain <b>the</b> <b>heap</b> property. Once all objects {{have been removed from}} <b>the</b> <b>heap,</b> the result is a sorted array.|$|E
25|$|Both the insert {{and remove}} {{operations}} modify <b>the</b> <b>heap</b> {{to conform to}} the shape property first, by adding or removing from the end of <b>the</b> <b>heap.</b> Then <b>the</b> <b>heap</b> property is restored by traversing up or down <b>the</b> <b>heap.</b> Both operations take O(log n) time.|$|E
40|$|Heaps of fire cracked stones is an {{apparent}} {{feature of the}} Scandinavian Bronze Age. <b>The</b> <b>heaps</b> are built of stones cracked by fire and then placed in different constructions. <b>The</b> <b>heaps</b> are placed in different contexts in the Bronze Age landscape {{and for a long}} time, research neglected this site category owing to that <b>the</b> <b>heaps</b> were not considered important enough to dig. During the 1980 s- 90 s the interest for <b>the</b> <b>heaps</b> of fire cracked stones increased and it became a wellresearched although debated site category. Earlier research has interpreted <b>the</b> <b>heaps</b> to be on the hillslopes in the landscape. This study’s research aims to understand the relation between shorelines and the placement of fire cracked stone heaps. This will be done through a landscape study of Uppland. The study indicates that the pattern in <b>the</b> distribution of <b>heaps</b> of fire cracked stones creates a correlation with the shoreline of <b>the</b> time <b>the</b> <b>heaps</b> were built, through their placement in the landscape. By creating a dynamic shoreline displacement, the essay will {{be able to look at}} the landscape in a more detailed way and will be able to investigate the relation between <b>the</b> <b>heaps</b> and <b>the</b> water edge. Through excluding <b>the</b> <b>heaps</b> that are under the waterline it is possible to in general determine the earliest possible production date. The fire cracked stone heaps have earlier been categorised to the Scandinavian Bronze Age but this research argues that some of <b>the</b> <b>heaps</b> should belong to the Neolithic Age as well...|$|R
40|$|The {{periodicity}} of {{the genus}} sequences of <b>the</b> <b>heaps</b> of finite quaternary games are examined. While the truncated genus sequence of <b>the</b> <b>heaps</b> of finite quaternary games becomes periodic, {{this is not true}} for the genus sequence in general. This contrasts with the known result that the genus sequence of <b>the</b> <b>heaps</b> of all finite subtraction games, a subset of finite quaternary games, becomes periodic. 1...|$|R
5000|$|Bouton's {{analysis}} {{carries over}} easily {{to the general}} multiple-heap version of this game. The {{only difference is that}} as a first step, before computing the Nim-sums, we must reduce the sizes of <b>the</b> <b>heaps</b> modulo k + 1. If this makes all <b>the</b> <b>heaps</b> of size zero (in misère play), the winning move is to take k objects from one of <b>the</b> <b>heaps.</b> In particular, in ideal play from a single heap of n objects, the second player can win if and only if ...|$|R
25|$|Ordinary {{heapsort}} extracts {{the top of}} <b>the</b> <b>heap,</b> , {{and fills}} the gap it leaves with , then sifts this latter element down the heap; but this element comes from {{the lowest level of}} <b>the</b> <b>heap,</b> meaning {{it is one of the}} smallest elements in <b>the</b> <b>heap,</b> so the sift-down will likely take many steps to move it back down. Each step of the sift-down requires two comparisons, to find the minimum of the new node and its two children.|$|E
25|$|Add {{the element}} {{to the bottom}} level of <b>the</b> <b>heap.</b>|$|E
25|$|Only index i = b−1 can violate <b>the</b> <b>heap</b> property.|$|E
5000|$|Possibly {{the easiest}} {{operation}} for <b>the</b> randomized meldable <b>heap,</b> FindMin (...) simply returns the element currently stored in <b>the</b> <b>heap's</b> root node.|$|R
5000|$|Removing the max element: Perform removemax (...) on <b>the</b> max <b>heap</b> and remove(node value) on <b>the</b> min <b>heap,</b> where node {{value is}} the value in the {{corresponding}} node in <b>the</b> min <b>heap.</b>|$|R
50|$|If {{only one}} of <b>the</b> <b>heaps</b> {{contains}} a tree of order j, this tree is moved to <b>the</b> merged <b>heap.</b> If both heaps contain a tree of order j, the two trees are merged to one tree of order j+1 so that the minimum-heap property is satisfied. Note that it may later be necessary to merge this tree with some other tree of order j+1 present in one of <b>the</b> <b>heaps.</b> In <b>the</b> course of the algorithm, we need to examine at most three trees of any order (two from <b>the</b> two <b>heaps</b> we merge and one composed of two smaller trees).|$|R
25|$|Since the {{ordering}} of siblings {{in a heap}} is not specified by <b>the</b> <b>heap</b> property, a single node's two children can be freely interchanged unless doing so violates the shape property (compare with treap). Note, however, that in the common array-based heap, simply swapping the children might also necessitate moving the children's sub-tree nodes to retain <b>the</b> <b>heap</b> property.|$|E
25|$|By {{swapping}} {{the values}} a and a <b>the</b> <b>heap</b> property for position i is established.|$|E
25|$|Replace {{the root}} of <b>the</b> <b>heap</b> with the last element on the last level.|$|E
5000|$|This {{operation}} can {{be performed}} on the implicit tree structure because <b>the</b> <b>heaps</b> being merged are never arbitrary. Rather, <b>the</b> two <b>heaps</b> are formed as part of sifting a node up the multi-way tree: ...|$|R
50|$|As a {{particular}} simple case, {{if there are}} only two <b>heaps</b> left, <b>the</b> strategy is {{to reduce the number of}} objects in <b>the</b> bigger <b>heap</b> to make <b>the</b> <b>heaps</b> equal. After that, no matter what move your opponent makes, you can make the same move on <b>the</b> other <b>heap,</b> guaranteeing that you take the last object.|$|R
50|$|With the meld {{operation}} complete, inserting into <b>the</b> meldable <b>heap</b> is easy. First, a new node, u, {{is created}} containing the value x. This new node is then simply melded with <b>the</b> <b>heaps</b> root node.|$|R
25|$|The {{heapsort}} algorithm involves {{preparing the}} list by first {{turning it into}} a max heap. The algorithm then repeatedly swaps the first value of the list with the last value, decreasing the range of values considered in <b>the</b> <b>heap</b> operation by one, and sifting the new first value into its position in <b>the</b> <b>heap.</b> This repeats until the range of considered values is one value in length.|$|E
25|$|The sift-down {{function}} is applied tail-recursively to index j until <b>the</b> <b>heap</b> property is established for all elements.|$|E
25|$|At this point, {{the only}} problem is that <b>the</b> <b>heap</b> {{property}} might not hold for index j.|$|E
5000|$|For {{they told}} about <b>the</b> <b>heaps</b> {{of dust and}} lumps so mighty big, ...|$|R
2500|$|... (The root {{holds the}} largest element. Since we assume <b>the</b> <b>heaps</b> rooted at <b>the</b> ...|$|R
25|$|<b>The</b> binary <b>heap</b> is {{a special}} case of <b>the</b> d-ary <b>heap</b> in which d = 2.|$|R
25|$|Windows Vista {{automatically}} tunes up <b>the</b> <b>heap</b> layout {{for improved}} fragmentation management. The Low Fragmentation Heap (LFH) is enabled by default.|$|E
25|$|The {{techniques}} to exploit a buffer overflow vulnerability vary by architecture, by operating system and by memory region. For example, exploitation on <b>the</b> <b>heap</b> (used for dynamically allocated memory), differs markedly from exploitation on the call stack.|$|E
25|$|Merge sort on arrays has {{considerably}} better data cache performance, often outperforming heapsort {{on modern}} desktop computers because merge sort frequently accesses contiguous memory locations (good locality of reference); heapsort references are spread throughout <b>the</b> <b>heap.</b>|$|E
60|$|Captain Whalley {{laid the}} coat down, and {{stumbled}} amongst <b>the</b> <b>heaps</b> of wreckage to the side.|$|R
40|$|We propose <b>the</b> post-order <b>heap,</b> a {{new data}} {{structure}} for implementing priority queues. Our structure {{is a simple}} variant of <b>the</b> binary <b>heap</b> that requires only Θ(1) amortized time for Insert operations and O(log n) time in the worst case for Delete-Min operations. Like <b>the</b> binary <b>heap,</b> <b>the</b> post-order <b>heap</b> is an implicit data structure, meaning that a structure containing n elements can be stored using only the first n locations of an array and Θ(1) additional words of storage. 1...|$|R
60|$|Meanwhile the Asika had glided {{on to the}} end of {{the hall}} behind <b>the</b> <b>heaps</b> of treasure.|$|R
25|$|By 1918, {{the team}} found {{itself at the}} top of <b>the</b> <b>heap</b> again, led by Ruth to another Series {{championship}} over the Chicago Cubs. The 1918 victory for Boston was provided by the pitching of Ruth and submarine pitcher Carl Mays.|$|E
25|$|The {{number of}} {{operations}} required depends only {{on the number of}} levels the new element must rise to satisfy <b>the</b> <b>heap</b> property, thus the insertion operation has a worst-case time complexity of O(log n) but an average-case complexity of O(1).|$|E
25|$|Since the zygote is genetically {{identical}} to the embryo, the fully formed fetus, and the baby, questioning the beginning of personhood could lead to an instance of the Sorites paradox, {{also known as the}} paradox of <b>the</b> <b>heap.</b>|$|E
50|$|Nim is {{a special}} case of a poset game where the poset {{consists}} of disjoint chains (<b>the</b> <b>heaps).</b>|$|R
50|$|Jenna Heap: She is the Princess, but {{was raised}} by <b>the</b> <b>Heaps</b> who were for several years unaware.|$|R
60|$|It {{was growing}} darker and darker; {{the night was}} coming. I stole a glance round the shanty, still all the same! The bloody axe in <b>the</b> corner, <b>the</b> <b>heaps</b> of filth, and the eyes on <b>the</b> bone <b>heaps</b> and in <b>the</b> crannies of the floor.|$|R
