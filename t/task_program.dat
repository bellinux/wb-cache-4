24|2126|Public
50|$|The z/OS {{operating}} system allows started tasks {{to be modified}} by an operator command. That allows {{the behavior of the}} started task to be dynamically altered. The degree of modification permitted {{is a function of the}} started <b>task</b> <b>program</b> and the limits of the environment.|$|E
30|$|When the Schedule module {{receives}} the task, {{according to the}} content of the <b>task</b> (<b>program</b> ID, program location), it downloads the procedures to be tested from a specified location to the local and hands the program over to TaintChaser for analysis.|$|E
40|$|The paper {{describes}} the silicon material {{task of the}} low-cost solar array project, which has the objective of establishing a silicon production capability equivalent to 500 mW per year at a price less than 10 dollars/kg (1975 dollars) in 1986. The <b>task</b> <b>program</b> is divided into four phases: technical feasibility, scale-up studies (the present phase), experimental process system development units, and implementation of large-scale production plants, and it involves the development of processes for two groups of materials, that is, semiconductor grade and solar cell grade. In addition, the effects of impurities on solar cell performance are being investigated. Attention is given to problem areas of the <b>task</b> <b>program,</b> such as environmental protection, material compatibility between the reacting chemicals and materials of construction of the equipment, and waste disposal...|$|E
40|$|Abstract — Researchers and {{engineers}} have used primitive actions to facilitate <b>programming</b> of <b>tasks</b> {{since the days}} of Shakey [1]. Task-level programming, which requires the user to specify only subgoals of a task to be accomplished, depends on such a set of primitive <b>task</b> <b>programs</b> to perform these subgoals. Past research in this area has used the commands from robot programming languages as the vocabulary of primitive tasks for robotic manipulators. We propose drawing from work measurement systems to construct the vocabulary of primitive <b>task</b> <b>programs.</b> We describe one such work measurement system, present several primitive <b>task</b> <b>programs</b> for humanoid robots inspired from this system, and show how these primitive programs can be used to construct complex behaviors. Index Terms — robot programming, task-level programming, humanoid robots I...|$|R
40|$|Abstract A new {{correctness}} concept, called partial-order preserving property, for event-driven execution {{monitoring of}} Ada <b>tasking</b> <b>programs</b> is presented. By using this concept, we can describe {{whether or not}} the tasking behavior of monitored Ada programs refrains from interference by monitoring actions of an event-driven execution monitor. In this paper, we define the equivalence of dynamic concurrent structures with respect to Ada program transformation, and propose this equivalence as a partial-order preserving criterion of the $pro$gram transformation used in a preprocessor of an event-driven execution monitor of Ada <b>tasking</b> <b>programs.</b> The equivalence is formally based on the lattice of dynamic concurrent structure of Ada programs which provides an abstraction of the <b>tasking</b> behavior ofAda <b>programs</b> in terms of task interactions. 1...|$|R
40|$|Graduation date: 1990 The Control-Oriented Local Area Network (COLAN) is a {{distributed}} control system {{for a series of}} networked microcontrollers, which has been under development at Oregon State University since 1986. A reliable master controller, functioning both as a task scheduler and as a network controller, is required to allow users to perform <b>task</b> <b>programming,</b> the transmission and reception of commands and data packets, and network status monitoring. The Task Master Controller (TMC) has been designed and developed to provide these capabilities. The TMC provides an integrated environment to aid in the editing of <b>task</b> <b>programs,</b> the execution of <b>task</b> <b>programs,</b> the interpretation of program statements, the manipulation of files, the maintenance of a communication protocol between the host computer and remote microcontrollers, the maintenance of a device and task library, and the display of network status. The TMC provides two different modes of operation, a user mode and a command mode, to allow both the novice user and the experienced system developer to use the system. The TMC language also includes such basic programming language elements as conditional statements, repetitive statements, and block statements. It also includes such built-in functions as time delay, print message, reception of data, and save response. These elements provide the skilled system developer with a powerful tool to <b>program</b> <b>tasks</b> in any desired sequence. It provides the novice user with a friendly user interface to schedule tasks by selecting from a menu of high level commands included in the system library...|$|R
30|$|Participants {{were asked}} to press the space button as quickly as {{possible}} every time the red ‘dot’ was presented on the monitor in 121 trials for the PPVT (PEBL Perceptual Vigilance <b>Task)</b> <b>program</b> of PEBL. The stimuli were presented with an inter-stimulus interval that varied randomly between 1 and 3.5  seconds. Reaction Times (RTs) were recorded in milliseconds.|$|E
40|$|Any {{object or}} thing in {{computer}} {{has its own}} “Monitor ” So at a time only one <b>task</b> (<b>program,</b> process, or thread) can enter into monitor. So point to discuss is, at the depth or by looking from monitors view Where is the Multitasking (Multiprogramming, Multiprocessing, Multithreading) ????? Even though there are DUAL Core Processors. So this paper discusses how we can achieve a real Multitasking, Multiprocessing & Multithreading by creating and maintaining number of monitors...|$|E
40|$|Purpose: Stroke {{caregivers}} often {{express the}} need for information about stroke and assistance with stroke-related care in the early discharge period. The Telephone Assessment and Skill-Building Kit (TASK) is an 8 -week program that addresses caregiver needs. This study explored {{the efficacy of the}} <b>TASK</b> <b>program</b> in improving stroke caregiver outcomes. Method: Guided by a conceptual model, 6 outcomes (optimism, task difficulty, threat appraisal, depressive symptoms, life changes, general health perceptions) were measured in 40 caregivers randomized to the TASK (n = 21) or an attention control group (n = 19). Data were analyzed using analysis of covariance (ANCOVA), controlling for baseline scores and minutes spent with the nurse. Results: Significant increases in optimism at 4 weeks, 8 weeks, and 12 weeks were found, with medium effect sizes for the TASK group relative to the control group (p <. 05). Significant improvements in task difficulty at 4 weeks, and threat appraisal at both 8 weeks and 12 weeks were also found (p <. 05). Conclusion: Caregivers receiving the TASK intervention improved in optimism, task difficulty, and threat appraisal. Further testing of an enhanced version of the <b>TASK</b> <b>program</b> is warranted, with attention directed toward more distal stroke caregiver outcomes...|$|E
50|$|The game {{features}} hacker-themed puzzles {{where the}} stylus is used for, among other <b>tasks,</b> <b>program</b> repair and password cracking. Project Hacker plays like a first person point and click adventure game outside of these puzzles, {{similar to the}} Ace Attorney series (also known as the Phoenix Wright series).|$|R
5000|$|Parallel {{programming}} is also supported through the [...] functional programming operators in the F# standard library, direct {{use of the}} [...] <b>task</b> <b>programming</b> model, the direct use of [...]NET thread pool and [...]NET threads and through dynamic translation of F# code to alternative parallel execution engines such as GPU code.|$|R
40|$|The {{applications}} for which Ada was developed require distributed implementations {{of the language}} and extensive use of tasking facilities. Debugging and testing technology {{as it applies to}} parallel features of languages currently falls short of needs. Thus, the development of embedded systems using Ada pose special challenges to the software engineer. Techniques for distributing Ada programs, support for simulating distributed target machines, testing facilities for <b>tasked</b> <b>programs,</b> and debugging support applicable to simulated and to real targets all need to be addressed. A technique is presented for debugging Ada <b>programs</b> that use <b>tasking</b> and it describes a debugger, called AdaTAD, to support the technique. The debugging technique is presented together with the use interface to AdaTAD. The component of AdaTAD that monitors and controls communication among tasks was designed in Ada and is presented through an example with a simple <b>tasked</b> <b>program...</b>|$|R
40|$|Understanding and {{maintenance}} of complex information spaces is often supported through visual interfaces. These interfaces must be highly flexible in order to adapt to both the user’s role and their current <b>task.</b> <b>Program</b> comprehension tools are one class of tools that make heavy use of information visualization techniques, and Software Engineers use these tools to help understand and maintain software systems. This paper presents a model-driven approach to address the customization requirements of visual user interfaces, and does so {{in the domain of}} program comprehension. 1...|$|E
40|$|Abstract. In {{order to}} {{accomplish}} the real-time simulation application of embedded Ethernet parallel system, the DSP boot mode and the loading process are researched according {{to the analysis of}} the parallel simulation system structure and the basic characteristic of BF 548 loader file structure. It has proposed a multiple-load method which is a kind of download method based on initialization code. <b>Task</b> <b>program</b> can automatic download after DSP launched in this way, and the problem of complex download procedure of DSP parallel system is solved. Through the actual test, the feasibility and validity of the download method have been verified, that provide a convenient and flexible experimental method and implementation technique of parallel simulation...|$|E
40|$|The {{results of}} the last three decades of {{research}} into computer-systems-performance measurement are combined into a unified body of knowledge: theory and practice. Unification is based upon a formulation of performance measurement. A computer system is a mathematical object, which can be measured. Performance measurement entails ascertaining the extent of this object during execution. An object (computer system, <b>task,</b> <b>program,</b> procedure) is defined recursively in terms of lower level objects. A set of measures, which apply at every level of the hierarchy, has been defined mathematically. This set of equations is a formulation of performance measurement. A number of graphical representations of these equations, for use in evaluating the measured data, are demonstrated...|$|E
40|$|The Java {{language}} {{enables the}} development of concurrent and distributed software through the concepts of thread and remote method invocation (RMI). It is known that developing concurrent and distributed software is a challenging task, mainly because of potential concurrency errors such as deadlocks and livelocks. One promising way to help the designer bl this task is providing static analysis tools that can detect such errors in the source code, as documented in the rich literature on static analysis of Ada <b>tasking</b> <b>programs.</b> This paper extends the approach followed for Ada <b>tasking</b> <b>programs</b> to the new Java language, providing formal models for the main thread synchronization primitives offered by the language. The formalism used is Promela, the input language of the model checker SPIN, {{which is based on}} extended communicating finite state machines and provides an efficient analysis algorith...|$|R
40|$|Static {{analysis}} of Ada <b>tasking</b> <b>programs</b> has been hindered by the well known state explosion problem that arises in the verification of concurrent systems. Many different techniques {{have been proposed}} to combat this state explosion. All proposed methods excel on certain kinds of systems, {{but there is little}} empirical data comparing the performance of the methods. In this paper, we select one representative from each of three very different approaches to the state explosion problem: partial-orders (representing state-space reductions), symbolic model checking (representing OBDD-based approaches), and inequality necessary conditions (representing integer programming-based approaches). We apply the methods to several scalable concurrency examples from the literature and to one real Ada <b>tasking</b> <b>program.</b> The results of these experiments are presented and their significance is discussed. 1 Introduction Ada tasks arm software developers with the power, and dangers, of concurrency. With this p [...] ...|$|R
40|$|In {{this paper}} I present an {{automatic}} technique for transforming a program {{by changing the}} data types in that program to ones which are more appropriate for the <b>task.</b> <b>Programs</b> are synthesised by proving modified synthesis theorems in the proofs-as-programs paradigm. The transformation can be verified in the logic of type theory. Transformations are motivated by [...] ...|$|R
40|$|Mixed-waste sites {{make up the}} {{majority}} of contaminated sites, yet remediation techniques used at such sites often target only the most prevalent contaminant. A better understanding of site situation (i. e., most common types of contamination), current remediation techniques, and combinations of techniques would provide insight into areas in which further research should be performed. The first half of this <b>task</b> <b>program</b> year consisted of a survey of common types of mixed-wastes sites and a detailed literature search of the remediation techniques and combinations of techniques that were currently available. From this information, an assessment of each of the techniques was made and combined into various ways appropriate to mixed-waste protocol. This activity provided insight into areas in which further research should be performed...|$|E
40|$|A two <b>task</b> <b>program</b> was {{initiated}} to develop advanced fuel cell components {{which could be}} assembled into an alkaline power section for the Space Station Prototype (SSP) fuel cell subsystem. The first task was to establish a preliminary SSP power section design to {{be representative of the}} 200 cell Space Station power section. The second task was to conduct tooling and fabrication trials and fabrication of selected cell stack components. A lightweight, reliable cell stack design suitable for the SSP regenerative fuel cell power plant was completed. The design meets NASA's preliminary requirements for future multikilowatt Space Station missions. Cell stack component fabrication and tooling trials demonstrated cell components of the SSP stack design of the 1. 0 sq ft area can be manufactured using techniques and methods previously evaluated and developed...|$|E
40|$|In the {{arc welding}} works, it is wellknown that {{desirable}} welding performances {{can be achieved}} by the coordinated motion. Coordinated motions of arc welding systems are often realized by a pair of robots. Generally teaching task of coordinated motions needs some skill and spends relativery long time. In this paper, we present one arc weiding robot system that realizes coordinated motion. One feature of our robot system is that teaching tasks of coordinated motions are simplified drastically by employing a three-dimensional vision sensor. The conventional industrial robots have mechanical errors. Therefor, the three-dimensional vision sensor to detect the shape of the target welding groove in order to compensate the effect of mechanical errors is introduced. And the <b>task</b> <b>program</b> that consists of compensated tool position and workpiece attitude is created precisely...|$|E
40|$|Abstract. Programming {{education}} and contests have introduced software to help evaluation by executing submitted taskwork. We present {{the notion of}} a task package as a unit for collecting, storing, archiving, and exchanging all information concerning a <b>programming</b> <b>task.</b> We also de-scribe a specific format for such task packages as used in our system Peach, and illustrate it with an example. Our goal is to stimulate the development of an international standard for packaging of <b>programming</b> <b>tasks.</b> Key words: <b>programming</b> education, <b>programming</b> contest, <b>programming</b> <b>task,</b> task package, grading support software, data format. 1...|$|R
5000|$|... #Caption: Skinner's {{teaching}} machine, {{a mechanical}} invention to automate the <b>task</b> of <b>programmed</b> instruction ...|$|R
5000|$|Script dynamic imaging: A shell {{script is}} used to {{automate}} repeated <b>tasks</b> in <b>programs.</b>|$|R
40|$|The Silicon Material Task of the Flat-Plate Solar Array Project was {{assigned}} {{the objective of}} developing the technology for low-cost processes for producing polysilicon suitable for terrestrial solar-cell applications. The <b>Task</b> <b>program</b> comprised sections for process developments for semiconductor-grade and solar-cell-grade products. To provide information for deciding upon process designs, extensive investigations {{of the effects of}} impurities on material properties and the performance of cells were conducted. The silane process of the Union Carbide Corporation was carried through several stages of technical and engineering development; a pilot plant was the culmination of this effort. The work to establish silane fluidized-bed technology for a low-cost process is continuing. The advantages of the use of dichlorosilane is a siemens-type were shown by Hemlock Semiconductor Corporation. The development of other processes is described...|$|E
40|$|This is {{a conference}} paper. Modular {{manufacturing}} machines characterised by their configuration flexibility and low initial investment have increasingly gained more recognition {{as one of}} the flexible and responsive manufacturing machinery in current competitive manufacturing industry. Programming of a modular machine is {{a very important part of}} an entire machine design and simulation environment. This paper focuses on the programming issue of a modular machine design and simulation environment. A programming study is made of the features of modular machines in manufacturing, and a general systematic approach towards high level utilisation and control of modular machines is outlined. A three-level machine task programming approach within the simulation environment is described and finally an example <b>task</b> <b>program</b> and its execution in simulation environment is illustrated to demonstrate the system capability...|$|E
40|$|AbstractHuman factors {{tests are}} {{important}} components of systems design. Designers need to evaluate users’ performance and workload while using a system and compare different design options {{to determine the}} optimal design choice. Currently, human factors evaluation and tests mainly rely on empirical user studies, which add a heavy cost to the design process. In addition, {{it is difficult to}} conduct comprehensive user tests at early design stages when no physical interfaces have been implemented. To address these issues, I develop computational human performance modeling techniques that can simulate users’ interaction with machine systems. This method uses a general cognitive architecture to computationally represent human cognitive capabilities and constraints. Task-specific models can be built with the specifications of user knowledge, user strategies, and user group differences. The simulation results include performance measures such as task completion time and error rate as well as workload measures. Completed studies have modeled multitasking scenarios {{in a wide range of}} domains, including transportation, healthcare, and human-computer interaction. The success of these studies demonstrated the modeling capabilities of this method. Cognitive-architecture-based models are useful, but building a cognitive model itself can be difficult to learn and master. It usually requires at least medium-level programming skills to understand and use the language and syntaxes that specify the task. For example, to build a model that simulates a driving task, a modeler needs to build a driving simulation environment so that the model can interact with the simulated vehicle. In order to simply this process, I have conducted preliminary programming work that directly connects the mental model to existing task environment simulation programs. The model will be able to directly obtain perceptual information from the <b>task</b> <b>program</b> and send control commands to the <b>task</b> <b>program.</b> With cognitive model-based tools, designers will be able to see the model performing the tasks in real-time and obtain a report of the evaluation. Automated human factors evaluation methods have tremendous value to support systems design and evaluation...|$|E
40|$|MBASIC is high-level, {{interactive}} {{computer language}} that reduces time of computer <b>task</b> <b>programming.</b> Outstanding features of MBASIC include: multiple assignments or statements in single instruction; conditional, assignment, and repetitive statement modifiers; and excellent string-handling capabilities. Two machine versions are available: UNIVAC (written in reentrant Assembler code for execution under EXEC 8) AND DEC- 10 (written in Assembler code for execution under TOPS- 10) ...|$|R
40|$|We {{introduce}} here {{a software}} architecture {{for the control}} of a sensor based manufacturing system consisting {{of a number of}} machines and peripheral equipment. The architecture divides the programming effort into two levels, <b>task</b> level <b>programming</b> and control level <b>programming.</b> The <b>task</b> level <b>programming</b> is based on the programming of a discrete model of the world, the World Model (WM). The WM provides a symbolic representation of the world state and isolates the <b>task</b> <b>programs</b> from the control level algorithms. Programming the control level amounts to modelling the manufacturing equipment as components with `behaviour' using object oriented techniques. Each component specifies how it should react to changes in the WM, i. e. selection and specification of the control algorithms to be executed. Programming at both levels can be done incrementally and control algorithms may be changed dynamically in the real-time kernel. INTRODUCTION This report presents a model for the execution of task le [...] ...|$|R
40|$|This article {{introduces}} a task-oriented system for off-line programming of welding robots. The programming approach {{is based on}} models of the workpiece and welding system. The integration of task- specific models and the access to a technology data base with tested welding parameters enable the generation of robot <b>task</b> <b>programs</b> for direct on site execution. Required program adaptions are considered by off-line planning of sensor integration...|$|R
40|$|Task Requirements {{input output}} Reconfigurable Modular Manipulator Systems Reconfigurable Modular Manipulator System? Is <b>Task</b> <b>Program</b> {{executable}} by - VAL II - C code - [...] - D-H parameters - Material specifications - Motor speicifications - Module specifications - positions/orientations - force application - accuracy - dexterity - obstacles - [...] Figure 1 : Definition {{of a general}} purpose manipulator. also {{the notion of the}} user writing device (or manipulator) independent code. The RMMS raises several theoretical issues and it is our aim to address one of these in this paper. Specifically, we describe a design methodology that accepts a task specification as its input, determines a kinematic configuration of the desired manipulator and selects the modules to create this manipulator. In order to support the current practice of picking the best configuration amongst available robots, several expert systems have been built to aid the user or the applications development engineer [15]. A s [...] ...|$|E
40|$|Abstract: An action-selection-mechanism (ASM) {{has been}} {{proposed}} {{to work as a}} fully connected finite state machine to deal with sequential behaviors as well as to allow a state in the <b>task</b> <b>program</b> to migrate to any state in the task, in which a primitive node in association with a state and its transitional conditions can be easily inserted/deleted. Also, such a primitive node can be learned by a shortest path-finding-based reinforcement learning technique. Specifically, we define a behavioral motivation as having state-dependent value as a primitive node for action selection, and then sequentially construct a network of behavioral motivations {{in such a way that}} the value of a parent node is allowed to flow into a child node by a releasing mechanism. A vertical path in a network represents a behavioral sequence. Here, such a tree for our proposed ASM can be newly generated and/or updated whenever a new behavior sequence is learned. To show the validity of our proposed ASM, experimental results of a mobile robot performing the task of pushing-a-box-into-a-goal (PBIG) will be illustrated...|$|E
40|$|Cao, S. (2015). Progress towards Automated Human Factors Evaluation. 6 th International Conference on Applied Human Factors and Ergonomics (AHFE 2015) and the Affiliated Conferences, AHFE 2015, 3, 4266 – 4272. [URL] This work is made {{available}} through a CC-BY-NC-ND 4. 0 license. The licensor is not represented as endorsing the use made of this work. [URL] factors tests are important components of systems design. Designers need to evaluate users’ performance and workload while using a system and compare different design options {{to determine the}} optimal design choice. Currently, human factors evaluation and tests mainly rely on empirical user studies, which add a heavy cost to the design process. In addition, {{it is difficult to}} conduct comprehensive user tests at early design stages when no physical interfaces have been implemented. To address these issues, I develop computational human performance modeling techniques that can simulate users’ interaction with machine systems. This method uses a general cognitive architecture to computationally represent human cognitive capabilities and constraints. Task-specific models can be built with the specifications of user knowledge, user strategies, and user group differences. The simulation results include performance measures such as task completion time and error rate as well as workload measures. Completed studies have modeled multitasking scenarios {{in a wide range of}} domains, including transportation, healthcare, and human-computer interaction. The success of these studies demonstrated the modeling capabilities of this method. Cognitive-architecture-based models are useful, but building a cognitive model itself can be difficult to learn and master. It usually requires at least medium-level programming skills to understand and use the language and syntaxes that specify the task. For example, to build a model that simulates a driving task, a modeler needs to build a driving simulation environment so that the model can interact with the simulated vehicle. In order to simply this process, I have conducted preliminary programming work that directly connects the mental model to existing task environment simulation programs. The model will be able to directly obtain perceptual information from the <b>task</b> <b>program</b> and send control commands to the <b>task</b> <b>program.</b> With cognitive model-based tools, designers will be able to see the model performing the tasks in real-time and obtain a report of the evaluation. Automated human factors evaluation methods have tremendous value to support systems design and evaluatio...|$|E
40|$|Programming takes {{designers}} {{away from}} typical domain- and task-based interfaces such as three-dimensional modellers. It thus imposes additional cognitive {{load on the}} already challenging design <b>task.</b> <b>Programming</b> in the model is a system design strategy that embeds the act of programming in a 3 D CAD model. This paper presents the argument for programming in the model and two user interface constructs that support such programming...|$|R
40|$|This {{case study}} {{describes}} {{the implementation of}} the Participative Ergonomics for Manual <b>tasks</b> <b>program</b> (PErforM) at 12 surface and underground coal mines. More than 400 miners have been trained in manual tasks risk assessment and control. This paper describes the project outcomes, presents examples of the risk assessments undertaken and resulting control suggestions; and discusses the lessons learned about the implementation of participative ergonomics programs in coal mining...|$|R
40|$|The present work {{studies the}} <b>task</b> <b>programming</b> {{problem in the}} garment {{industry}} and uses the Job Shop method to solve the problem. A representation is proposed for the numerical solution of the problem based on a heuristic optimization methods known as Simulated Annealing. Although the algorithm is capable of identifying the ideal solution in some cases, at times solution are proposed that deviate up to 10 % from the optimum...|$|R
