1051|1695|Public
5|$|When he proves {{unable to}} defeat Data-Sora himself, Pete infects Data-Riku's code with bugs and forces him to fight, putting the datascape {{in danger of}} being totally corrupted. Seeing no alternative, Data-Sora chooses <b>to</b> <b>debug</b> Data-Riku from inside, an act which will cause the datascape to reset if he succeeds, wiping his memories. The {{debugging}} process also activates the bug responsible for the data's corruption, which takes the form of Sora's Heartless. Data-Sora destroys the bug while Mickey and the others are returned to their world by Data-Riku before the reset occurs. In a scene exclusive to HD 2.5 ReMix, after Maleficent and Pete take their leave, Maleficent speaks with Pete about the Book of Prophecies, an ancient artifact capable of transcribing events that have yet to take place and even conjuring them, including entire worlds; she resolves to find it, believing it may hold a connection with the datascape and the journal.|$|E
5|$|In January 2013, a {{privilege}} escalation exploit {{was discovered in}} the Windows kernel that can allow unsigned code to run under Windows RT; the exploit involved {{the use of a}} remote debugging tool (provided by Microsoft <b>to</b> <b>debug</b> WinRT apps on Windows RT devices) to execute code which changes the signing level stored in RAM to allow unsigned code to execute (by default, it is set to a level that only allows code signed by Microsoft to execute). Alongside his explanation of the exploit, the developer also included a personal appeal to Microsoft urging them to remove the restrictions on Windows RT devices, contending that their decision was not for technical reasons, and that the devices would be more valuable if this functionality were available. In a statement, a Microsoft spokesperson applauded the effort, indicating that the exploit does not pose a security threat because it requires administrative access to the device, advanced techniques, and would still require programs to be re-compiled for ARM. However, Microsoft has still indicated that the exploit would be patched in a future update.|$|E
25|$|Cosmos {{offers several}} options {{as to how}} to deploy the {{resulting}} OS and how <b>to</b> <b>debug</b> the output.|$|E
50|$|In {{addition}} <b>to</b> <b>debugging</b> web pages, Firebug {{was used}} for web security testing and web page performance analysis.|$|R
50|$|In {{some games}} {{a player who}} has access <b>to</b> <b>debugging</b> or {{administrative}} tools can spawn entities or pickups with said tools.|$|R
50|$|Some {{types of}} {{instrumentation}} may cause {{a dramatic increase}} in execution time. This may limit the application of instrumentation <b>to</b> <b>debugging</b> contexts.|$|R
25|$|Agostino Russo and Ecology2007 later {{redesigned}} and rewrote {{the current}} Windows front-end. Hampus Wessman contributed the new downloader and the translation scripts. Bean123 and Tinybit also helped <b>to</b> <b>debug</b> and fix bootloader issues. Lubi and LVPM were subsequently created by Geza Kovacs.|$|E
25|$|In his online postings, Titor {{claimed to}} be an American soldier from 2036, based in Tampa, Florida. He was {{assigned}} to a governmental time-travel project, and sent back to 1975 to retrieve an IBM 5100 computer which he said was needed <b>to</b> <b>debug</b> various legacy computer programs in 2036; a possible reference to the UNIX year 2038 problem. The IBM 5100 runs the APL and BASIC programming languages.|$|E
25|$|After the bug is reproduced, {{the input}} of the program {{may need to be}} {{simplified}} to make it easier <b>to</b> <b>debug.</b> For example, a bug in a compiler can make it crash when parsing some large source file. However, after simplification of the test case, only few lines from the original source file can be sufficient to reproduce the same crash. Such simplification can be made manually, using a divide-and-conquer approach. The programmer will try to remove some parts of original test case and check if the problem still exists. When debugging the problem in a GUI, the programmer can try to skip some user interaction from the original problem description and check if remaining actions are sufficient for bugs to appear.|$|E
5000|$|... gdbserver is a {{computer}} program {{that makes it possible}} <b>to</b> remotely <b>debug</b> other programs. Running on the same system as the program <b>to</b> be <b>debugged,</b> it allows the GNU Debugger to connect from another system; that is, only the executable <b>to</b> be <b>debugged</b> needs <b>to</b> be resident on the target system ("target"), while the source code and a copy of the binary file <b>to</b> be <b>debugged</b> reside on the developer’s local computer ("host"). The connection can be either TCP or a serial line.|$|R
25|$|Since the 1990s, {{particularly}} {{following the}} Ariane 5 Flight 501 disaster, interest in automated aids <b>to</b> <b>debugging</b> rose, such as static code analysis by abstract interpretation.|$|R
50|$|In other words, the {{increasing}} complexity of today’s {{software and hardware}} designs is leading to some fresh approaches <b>to</b> <b>debugging.</b> Silicon manufacturers offer more and more on-chip debugging features for emulation of new processors.|$|R
25|$|The {{debugger}} allows setting breakpoints (which allow execution to {{be stopped}} temporarily at a certain position) and watches (which monitor the values of variables as the execution progresses). Breakpoints can be conditional, meaning they get triggered when the condition is met. Code can be stepped over, i.e., run one line (of source code) at a time. It can either step into functions <b>to</b> <b>debug</b> inside it, or step over it, i.e., {{the execution of the}} function body isn't available for manual inspection. The debugger supports Edit and Continue, i.e., it allows code to be edited as it is being debugged. When debugging, if the mouse pointer hovers over any variable, its current value is displayed in a tooltip ("data tooltips"), where it can also be modified if desired. During coding, the Visual Studio debugger lets certain functions be invoked manually from the Immediate tool window. The parameters to the method are supplied at the Immediate window.|$|E
25|$|Most micro kernels use {{a message}} passing system {{of some sort}} to handle {{requests}} from one server to another. The message passing system generally operates on a port basis with the microkernel. As an example, if a request for more memory is sent, a port is opened with the microkernel and the request sent through. Once within the microkernel, the steps are similar to system calls. The rationale {{was that it would}} bring modularity in the system architecture, which would entail a cleaner system, easier <b>to</b> <b>debug</b> or dynamically modify, customizable to users' needs, and more performing. They are part of the operating systems like AIX, BeOS, Hurd, Mach, macOS, MINIX, QNX. Etc. Although micro kernels are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic kernels. Advocates of monolithic kernels also point out that the two-tiered structure of microkernel systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of kernels normally provide only the minimal services such as defining memory address spaces, Inter-process communication (IPC) and the process management. The other functions such as running the hardware processes are not handled directly by micro kernels. Proponents of micro kernels point out those monolithic kernels have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a microkernel, if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error.|$|E
500|$|Compared {{with its}} predecessor, {{the game was}} more {{advanced}} in nearly all technological aspects. Koichi Nakamura programmed with several students, but since {{it was his first}} time working with a team, he didn't know how to delegate work or communicate his goals. Since the students were unfamiliar with the coding process, they did not know how <b>to</b> <b>debug</b> or to keep track of whose code it came from, so Nakamura had to do it himself, which caused delays. In programming, they did the maps first. Then they worked on characters, including numbered characters in maps for assigned lines, and designed the NPC's moving route. The next step was programming the items, while the final step was setting the monsters data and converting Toriyama's artwork. [...] This work was completed by the end of October.|$|E
40|$|This thesis investigates event-based {{behavioural}} model debugging in Linda. A {{study is}} presented of the Linda parallel programming paradigm, its amenability <b>to</b> <b>debugging,</b> {{and a model}} for debugging Linda programs using Milner's CCS. In support {{of the construction of}} expected behaviour models, a Linda program specification language is proposed. A behaviour recognition engine that is based on such specifications is also discussed. It is shown that Linda's distinctive characteristics make it amenable <b>to</b> <b>debugging</b> without the usual problems associated with paraUel debuggers. Furthermore, it is shown that a behavioural model debugger, based on the proposed specification language, effectively exploits the debugging opportunity. The ideas developed in the thesis are demonstrated in an experimental Modula- 2 Linda system. ...|$|R
50|$|In {{addition}} <b>to</b> <b>debugging</b> Lua applications, ZeroBrane Studio {{also supports}} live coding, which allows making {{changes to the}} application code while the application is running and seeing {{the results of the}} changes in the application.The live coding is supported for Lua interpreters and several other environments.|$|R
40|$|A {{collection}} of powerful ideas??cription, plans, linearity, insertions, global knowledge and imperative semantics?? explored which are fundamental <b>to</b> <b>debugging</b> skill. <b>To</b> make these concepts precise, a computer monitor called MYCROFT is described that can debug elementary programs for drawing pictures. The programs are those written for LOGO turtles...|$|R
500|$|Originally, Rare {{planned to}} include an {{additional}} mode, called Bottles' Revenge, where a second player could play as an undead version of Bottles and take control of enemy characters to hinder Banjo in his quest, with the players swapping roles if the enemy character managed to defeat Banjo. The idea was ultimately scrapped because the developers ran out of time <b>to</b> <b>debug</b> it, despite admitting that [...] "it did work rather well". However, it would later serve as the inspiration behind the [...] "Counter Operative" [...] multiplayer mode in Perfect Dark. Bosses were originally {{to be able to}} be controllable by the second player as well, but the only boss that the developers had working when they dropped the mode was the third boss, 'Old King Coal'. The developers also planned to implement a feature, called [...] "Stop 'N' Swop", that would have allowed data to be transferred from Banjo-Kazooie to Banjo-Tooie so that players could unlock additional bonuses in Banjo-Tooie. However, due to hardware limitations of the Nintendo 64 system, the feature was ultimately dropped. Despite this, Rare decided to include at least some of the additional bonuses within the game. The Stop 'N' Swop feature was later implemented in the Xbox Live re-release.|$|E
2500|$|The {{machine was}} still {{essentially}} a prototype, {{and the company}} was using the installation <b>to</b> <b>debug</b> the design. By this time a number of massively parallel machines were coming into the market at price/performance ratios the Cray-3 could not touch. Cray responded through [...] "brute force", starting design of the Cray-4 which would run at 1GHz and outpower these machines, regardless of price.|$|E
2500|$|Debugging ranges in {{complexity}} from fixing simple errors to performing {{lengthy and}} tiresome tasks of data collection, analysis, and scheduling updates. [...] The debugging {{skill of the}} programmer can be {{a major factor in}} the ability <b>to</b> <b>debug</b> a problem, but the difficulty of software debugging varies greatly with the complexity of the system, and also depends, to some extent, on the programming language(s) used and the available tools, such as debuggers. Debuggers are software tools which enable the programmer to monitor the execution of a program, stop it, restart it, set breakpoints, and change values in memory. The term debugger can also refer to the person who is doing the debugging.|$|E
2500|$|<b>Debug</b> {{abilities}} <b>to</b> receive <b>debugging</b> messages during {{application development}} ...|$|R
40|$|Existing {{approaches}} <b>to</b> <b>debugging</b> {{distributed systems}} involve {{a cycle of}} passive observation followed by computation replaying. We propose predicate control as an active approach <b>to</b> <b>debugging</b> such systems. The predicate control approach involves a cycle of observation followed by controlled replaying of computations, based on observation. We formalize the predicate control problem for both offline and on-line scenarios. We prove that off-line predicate control for general boolean predicates is NP-hard. However, we provide an efficient solution for off-line predicate control for the class of disjunctive predicates. We further solve on-line predicate control for disjunctive predicates under certain restrictions on the system. Lastly, we demonstrate how both off-line and on-line predicate control facilitate distributed debugging by allowing the programmer to control computations to maintain global safety properties. 1. Introduction In distributed systems, a cycle of observation follow [...] ...|$|R
40|$|We {{present a}} new, unified {{approach}} <b>to</b> <b>debugging</b> graphics software. We propose {{a representation of}} all graphics state {{over the course of}} program execution as a relational database, and produce a query-based framework for extracting, manipulating, and visualizing data from all stages of the graphics pipeline. Using an SQLbased query language, the programmer can establish functional relationships among all the data, linking OpenGL state to primitives to vertices to fragments to pixels. Based on the Chromium library, our approach requires no modification to or recompilation of the program <b>to</b> be <b>debugged,</b> and forms a superset of many existing techniques for debugging graphics software...|$|R
2500|$|The Space Shuttle vehicle {{hardware}} and related GSE hardware is simulated by mathematical models (written in Shuttle Ground Operations Simulator (SGOS) modeling language [...] ) that behave and react like real hardware. [...] During the Shuttle Final Countdown Phase Simulation, engineers {{command and control}} hardware via real application software executing in the control consoles – just {{as if they were}} commanding real vehicle hardware. [...] However, these real software applications do not interface with real Shuttle hardware during simulations. [...] Instead, the applications interface with mathematical model representations of the vehicle and GSE hardware. [...] Consequently, the simulations bypass sensitive and even dangerous mechanisms while providing engineering measurements detailing how the hardware would have reacted. [...] Since these math models interact with the command and control application software, models and simulations are also used <b>to</b> <b>debug</b> and verify the functionality of application software.|$|E
2500|$|Less theoretically, an {{interesting}} application of computer simulation is to simulate computers using computers. In computer architecture, {{a type of}} simulator, typically called an emulator, {{is often used to}} execute a program that has to run on some inconvenient type of computer (for example, a newly designed computer that has not yet been built or an obsolete computer that is no longer available), or in a tightly controlled testing environment (see Computer architecture simulator and Platform virtualization). [...] For example, simulators have been used <b>to</b> <b>debug</b> a microprogram or sometimes commercial application programs, before the program is downloaded to the target machine. Since the operation of the computer is simulated, all of the information about the computer's operation is directly available to the programmer, and the speed and execution of the simulation can be varied at will.|$|E
2500|$|Despite the team's {{efforts to}} make The Settlers II {{as good as they}} {{possibly}} could, however, speaking in 2006, Häuser comments that, as with the original game, there were elements with which he was unhappy; [...] "things like the help system. There was none, to be honest. The player had to work really hard to get into the game, and there's lots of details in the game you have to learn the hard way. It would have been a great help to a new gamer if we had some put in." [...] He also agreed with many fans of the game that the shipping system didn't work very well, even after it was patched in the Gold Edition; [...] "it didn't work as we wanted it to work. I remember the ships did not transport the things you wanted to other islands, we couldn't solve this problem at the time. Because at this time, the development systems were much more difficult to use and we didn't have the ability <b>to</b> <b>debug</b> code as we do today. It was just not working as we wanted it to work." [...] When The Settlers III went into development in 1997, Blue Byte again sought feedback from fans, {{and one of the most}} requested aspects for the new game was that the shipping system from The Settlers II be reprogrammed.|$|E
40|$|Abstract—Due to the {{increasing}} design size and complexity of modern Integrated Circuits (IC) and the decreasing time-to-market, debugging {{is one of the}} major bottlenecks in the IC development cycle. This paper presents a generalized approach <b>to</b> automate <b>debugging</b> which can be used in different scenarios from design <b>debugging</b> <b>to</b> post-silicon <b>debugging.</b> The approach is based on model-based diagnosis. Diagnostic traces are proposed as an enhancement reducing debugging time and increasing di-agnosis accuracy. The experimental results show the effectiveness of the approach in post-silicon debugging. I...|$|R
40|$|Monitoring and {{debugging}} parallel {{programs is}} a difficult activity. There are many situations where the traditional "stop the world, I want to get off" approach <b>to</b> <b>debugging</b> is simply unsuitable. Frequently, nonintrusive monitoring of the program execution is more productive in locating sources of error and also in monitoring "correct" programs for such purposes as performance measurement and tuning...|$|R
5000|$|A mapping {{from the}} {{standard}} interface pins <b>to</b> the <b>debug</b> pins is specified.|$|R
2500|$|Searchmaton, [...] for short, is a bot and {{antivirus}} software deployed by the Cyberspace Administration of Daikoku. Its task is <b>to</b> <b>debug</b> {{and maintain the}} virtual side of the city. Its secondary function is to seek out and disable illegal AR devices, software, and viruses, making it a menace to the characters of the series. [...] Searchmaton can deploy up to four spherical drones to aid in its task. [...] While Searchmaton can patrol the city streets freely, it is prohibited to enter private property such as houses, and other spaces such as temple grounds and schools, because they lie outside of the responsibility of Daikoku's Cyberspace Administration. [...] The protagonists utilize this and other predictable aspects of Searchmaton's behavior to escape its grasp. [...] Searchmaton, striking terror into the hearts of children, is ironically painted with a smiley face and punctuates its violent attacks with the cute catch phrase [...] which Yasako's father had a part in developing. [...] Tamako often hijacks Searchmatons for use as her personal digital henchmen. They are later replaced by the upgraded Searchmaton 2.0 {{in the form of}} cubes which have upgraded weapons and shielding, and can combine like the Q-chan to perform wide area re-formatting. Since the 2.0s are under government jurisdiction they can enter areas inaccessible to Satchī including shrines, and also private property when authorised.|$|E
50|$|CodeXL was {{successfully}} used <b>to</b> <b>debug</b> Bullet.|$|E
5000|$|... {{capabilities}} <b>to</b> <b>debug</b> your scripts interactively with a debugger front-end.|$|E
50|$|Time {{to market}} (TTM) {{pressures}} compressing the time allocated <b>to</b> develop, <b>debug</b> and verify the tests.|$|R
25|$|By {{the late}} 1970s, it {{appeared}} {{there were no}} more technology issues to overcome and efforts turned <b>to</b> <b>debugging</b> the system and developing methods for mass production. As this process started, UTDC started its own efforts to market the design. Toronto, the inspiration for the system, was an obvious target, but the company also found interest in the system in Ottawa, Hamilton, Vancouver, Detroit and Los Angeles.|$|R
5000|$|Most modern {{microprocessors}} have {{at least}} one of these features in their CPU design <b>to</b> make <b>debugging</b> easier: ...|$|R
