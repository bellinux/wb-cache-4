6|23|Public
50|$|Powershot G series cameras have a {{standard}} <b>threaded</b> <b>socket</b> for mounting to a monopod or tripod. This {{can also be}} used for attaching the camera to various brackets or adapters.|$|E
5000|$|If the two {{ends of a}} {{coupling}} are different (e.g. one BSP threaded and one NPT threaded), then it is usually referred to as an adapter. Another variation is one plain socket and one <b>threaded</b> <b>socket.</b> Yet another variation would be 3/4" [...] NPT to 1/2" [...] NPT.|$|E
5000|$|An {{insert nut}} {{provides}} a <b>threaded</b> <b>socket</b> for a wooden workpiece, {{similar to a}} wall anchor. Insert nuts are inserted into a pre-drilled hole by one of two means: screw in and hammer in. In both cases, the external protrusions bite into the wood, preventing the nut from either turning or pulling out.|$|E
5000|$|Jawk is {{a project}} to {{implement}} AWK in Java, hosted on SourceForge. Extensions to the language are added {{to provide access to}} Java features within AWK scripts (i.e., Java <b>threads,</b> <b>sockets,</b> collections, etc.).|$|R
5000|$|... #Caption: D-sub {{connector}}s. Shown is a 9-pin male (DE-9M) connector (plug), and a 25-pin female (DB-25F) connector (socket). The hexagonal pillars (4-40 bolt) at {{both ends}} of each connector have a threaded stud fastening the connectors to the metal panel. They also have <b>threaded</b> <b>sockets</b> to receive jackscrews on the cable shell, holding the plug and socket together.|$|R
50|$|Edison screw (ES) is a {{standard}} socket for light bulbs in the United States. It was developed by Thomas Edison and was licensed in 1909 under the Mazda trademark. Normally, the bulbs have right-hand threaded metal bases (caps) which screw into matching <b>threaded</b> <b>sockets</b> (lamp holders). For bulbs powered by AC current, the thread is connected to neutral and the contact on the bottom tip of the base is connected to hot.|$|R
50|$|The {{design of}} the Type 10 grenade was almost {{identical}} to the later Type 91 with a grooved 'pineapple-shaped' segmented body designed to disperse sharp fragments when it exploded. The main difference was the Type 10's serrated top. A <b>threaded</b> <b>socket</b> {{in the bottom of}} the body allowed for the attachment of an auxiliary propellant canister for use in a grenade launcher, or a finned tail assembly for use as a rifle grenade. The fuse was a percussion-activated delay type, initiated by pulling out a safety pin and striking the top of the cap, which gave a 7-8 second delay. When used as a rifle grenade or mortar round, the fuse activated automatically, as the plunger was pushed in by the force of the launch. One issue with the design was the highly variable and inaccurate fuse timing, which resulted either in premature explosion, or such a long delay that the recipient could hurl the grenade back prior to detonation.|$|E
5000|$|The {{design of}} the Type 91 grenade was almost {{identical}} to the earlier Type 10. The main difference was the Type 91’s dome top {{as opposed to the}} Type 10's serrated top. As with the Type 10, a <b>threaded</b> <b>socket</b> {{in the bottom of the}} body allowed for the attachment of an auxiliary propellant canister for use in a Type 89 grenade discharger. The fuse was a percussion-activated delay type, initiated by pulling out a safety pin and striking the top of the cap. The grenade incorporated a 7-8 second delay before detonation. This feature was incorporated as part of the Type 91's other uses as a rifle grenade or as a shell fired from the Type 89 grenade discharger, as the long delay enabled longer time-in-flight to distant targets. [...] When used as a rifle grenade the fuse activated automatically, as the plunger was pushed in against a weak creep spring by the force of the launch. Additionally, the Type 91 could be used as a booby trap by removing the safety pin and setting under a floorboard or chair.|$|E
40|$|The {{rotatable}} socket acts positively on a {{threaded spindle}}. The threaded spindle {{is connected to}} a transport component (2) connectable to a bone segment separated from one fracture end and arranged between two bone parts. The transport component is movable along the longitudinal axis in the sleeve (1) by rotation of the rotatable socket (9). The fixture of the bone segment separated from one fracture end is by a bone screw (E) fitted in a longitudinal guide in the sleeve. The threaded spindle and a <b>threaded</b> <b>socket</b> (3) accommodated and fixed in the sleeve have different threads and are exchangeable. A tooth component (5) which has interengaging teeth (4 a, 4 b) engages on both sides on the sleeve and on a driver (6). USE/ADVANTAGE - The bone marrow nail does not influence the healing process negatively through {{the formation of a}} tissue bulge and the original length of the broken bone, with improved healing conditions, is further producible...|$|E
2500|$|... {{bottom bracket}} shell joins the chain stays, seat tube, and downtube, and {{includes}} a <b>threaded</b> cylindrical <b>socket</b> for the bottom bracket ...|$|R
50|$|A tee, {{the most}} common pipe fitting, is used to combine (or divide) fluid flow. It is {{available}} with female <b>thread</b> <b>sockets,</b> solvent-weld sockets or opposed solvent-weld sockets and a female-threaded side outlet. Tees can connect pipes of different diameters or change {{the direction of a}} pipe run, or both. Available in a variety of materials, sizes and finishes, they may also be used to transport two-fluid mixtures. Tees may be equal or unequal in size of their three connections, with equal tees {{the most common}}.|$|R
50|$|Microsoft POSIX subsystem, an {{optional}} Windows subsystem included in Windows NT-based operating systems up to Windows 2000. POSIX-1 as it stood in 1990 revision, without <b>threads</b> or <b>sockets.</b>|$|R
40|$|This paper {{describes}} MoPy, a port of the Python 1. 5. 2 interpreter to the Psion 5 /Epoc 32 {{platform and}} Koala, a CORBA-style Object Request and Event Broker implemented natively in Python. While primarily a direct POSIX-based port {{of the standard}} Python interpreter, MoPy also adds <b>thread,</b> <b>socket</b> and serial support for the Psion platform. The Koala ORB is designed particularly with MoPy in mind and aims to support interoperation of devices over the low-power Prototype Em-bedded Network. The low-power requirements of PEN impose severe bandwidth and latency penalties to which conventional RPC technologies are not typically well suited. ...|$|R
5000|$|Core, where encapsulations for <b>sockets,</b> <b>threads</b> {{and other}} {{primitives}} {{can be found}} ...|$|R
5000|$|Longscrew threads: These are {{parallel}} pipe threads used where a pressure-tight joint {{is achieved by}} the compression of a soft material (such as an o-ring seal or a washer) between the end face of the male <b>thread</b> and a <b>socket</b> or nipple face, with the tightening of a backnut.|$|R
40|$|Resource {{awareness}} {{is an important}} step towards the realization of reliable and effective communication systems, particularly in the context of mobile code. Since the amount of consumption of computing resources (file system, <b>threads,</b> <b>sockets,</b> etc.) is not monitored in most mobile execution environments such as in the Java language, some kind of change to the security model seems indispensable. It is the goal of this research to gain insight into a richer security model – one that enables monitoring of resource consumption and ensures that allowable constraints are met. Specifically, we extend an existing approach to monitoring and checking of running Java programs to the enforcement of resource-aware policies. Specifically, our work focusses on monitoring and controlling aspects of file system use. i Acknowledgments I would like to express deep appreciation to my supervisor, Prof. Juergen Dingel, for his guidance and support in this research project. I {{would also like to thank}} Prof. Oleg Sokolsky and Usa Sammapun of the University of Pennsylvania for their helpful and responsive suggestions. I am indebted to the Office of Critical Infrastructure Protection and Emergency Preparedness (OCIPEP) of the Government of Canada for their generous financial support. I am deeply grateful to my parents, Anna and Alan, and my brother Paul, for their love and support. Thank you. Finally, I would like to dedicate this thesis in memory of my Babyshka, Alexandr...|$|R
40|$|There is a {{very high}} need of High Performance Computing (HPC) in many {{applications}} like space science to Artificial Intelligence. HPC shall be attained through Parallel and Distributed Computing. In this paper, Parallel and Distributed algorithms are discussed based on Parallel and Distributed Processors to achieve HPC. The Programming concepts like <b>threads,</b> fork and <b>sockets</b> are discussed with some simple examples for HPC...|$|R
30|$|There is a {{significant}} difference in throughput ~ 14.79 × between the two systems, for almost the same latency. There are several factors contributing to making the performance for WSM better than for ATOM D 525. The first factor is that WSM has 24 <b>threads</b> (2 <b>sockets</b> * 6 cores * 2 threads/core), while ATOM has four threads. The second factor is that CPU utilization for ATOM is higher than for the WSM processor. The difference in core frequency and memory size is also a contributing factor. However, the increased performance for WSM comes at the expense of power consumption; the power for ATOM is ~ 5.9 × lower than the power consumption for WSM, and the price difference (performance-per-$) is an advantage for ATOM.|$|R
5000|$|Swaging is {{a method}} of wire rope {{termination}} that refers to the installation technique. The purpose of swaging wire rope fittings is to connect two wire rope ends together, or to otherwise terminate one end of wire rope to something else. A mechanical or hydraulic swager is used to compress and deform the fitting, creating a permanent connection. There are many types of swaged fittings. <b>Threaded</b> Studs, Ferrules, <b>Sockets,</b> and Sleeves are a few examples. [...] Swaging ropes with fibre cores is not recommended.|$|R
40|$|Abstract [...] In the {{situation}} of monitoring an experiment it is often necessary to control several independently running tasks from one Graphical User Interface (GUI). Such a GUI {{must be able to}} execute commands in the tasks even if they are busy, i. e. getting data, analyzing data or waiting for data. Moreover, the tasks, being controlled by data streams (i. e. event data samples or slow control data), must be able to send data asynchronously to the GUI for visualization. A multi-tasking package (C++ class library) that meets these demands has been developed at the GSI in the framework of a new analysis system, Go 4, which is based on the ROOT system [CERN, R. Brun et al. ]. The package provides a thread manager, a task handler, and asynchronous inter task communication between <b>threads</b> through <b>sockets.</b> Hence, objects can be sent at any time from a task to the GUI or vice versa. A...|$|R
50|$|Forge work {{depended}} on a declining {{supply of coal}} and wood which idled the plant in 1783. In 1794, Christopher Johnston purchased the property and sold the equipment from the slitting mill to George Elliott for his upstream mill in 1807. The property was auctioned on September 16, 1819, renovated by the Carroll and Oliver families and resold in 1822. A large distillery operation was put into operation by John McKim Jr. which ceased by 1833 when the Thomas Viaduct construction began. The mill continued in operation by George T Worthington until a fire in 1856. In 1868, a major flood damaged the four-story mill. The Levering family acquired the site and sold it in 1876 to the Viaduct Manufacturing Company. A street through the site is now named Levering Avenue. From 1906-1910, a 20-by-30-foot room was rented to Marion B. Davis, who manufactured brass screw <b>threads</b> and <b>socket</b> assemblies for automobiles delivered by horse and carriage. The Viaduct Company produced telegraph equipment onsite until it was abandoned in 1914.|$|R
5000|$|For the {{determined}} programmer {{the third}} option {{would probably be}} the most appropriate: to write one's own routines, using a combination of <b>threads</b> and TCP/IP <b>sockets</b> to complete the task. The threads are necessary {{in order to make the}} socket-based communication between the programs non-blocking (the communication between programs has to take place in threads, so that the main thread doesn't have to wait for the communication to end and can execute other parts of the code). This option offers the programmer complete control over the code and eliminates any overhead which might come from the use of the Cluster OpenMP or MPI libraries.|$|R
40|$|Abstract—Because of user {{demands for}} {{better quality of}} service, network-aware {{applications}} have been of increasing necessity. To enable more control, the end-host operating system (OS) is the entity responsible for providing appropriate service level and API to user applications. However, {{most of the work}} in this area remains domain-specific and without a generalizable scheme for providing network control as an OS service. In this paper, we propose an OS service, namely the virtualization of network interface, that lies between network interface and userland. The virtual network interface is hierarchically attachable to various OS-supported entity, such as <b>threads,</b> processes, and <b>sockets.</b> We argue that the mechanism provides flexible control, as well as the system protection that is required for operating system services. For a proof of the concept, we show an implementation on a PC-Unix, using the procfs file system abstraction. We also carried out a systematic evaluation. The system exhibited the expected control behavior, while keeping the performance small. I...|$|R
50|$|A helical insert is {{an insert}} made of coiled wire. The {{helically}} formed coils of diamond shaped stainless steel or phosphor bronze wire screw into a threaded hole {{to form a}} mating internal thread for a screw or stud. These inserts provide a convenient means of repairing stripped-out threads and are also used to provide stronger threads in soft materials such as aluminium, zinc die castings, wood, magnesium etc. than {{can be obtained by}} direct tapping of the base metal involved. Another common generic name is screw thread insert (STI), although many users persist in calling them all by a prominent brand name, the registered trademark Heli-Coil. Applications include engine cylinder head repair after unintentional over-torquing or cross-threading of spark plugs strips the <b>thread</b> of the <b>socket.</b> Kits with matched tap and coil exist for this. The straight radial piece in the photo is the driver tang which is used as a key to grip with pliers for driving the coil into place and is discarded after installation.|$|R
40|$|Migrating Sockets is the {{protocol}} processing component of an end system architecture designed for networking with QoS guarantees. The architecture provides (1) adaptive rate-controlled scheduling of protocol <b>threads</b> in Migrating <b>Sockets,</b> (2) rate-based flow control for reserved rate connections in future integrated services networks, and (3) a constant overhead active demultiplexing mechanism. Migrating Sockets achieves its efficiency by allowing user applications {{to manage a}} network endpoint with minimal system intervention, providing user level protocols read-only access to routing information in a "well-known" shared memory region, and integrating efficient kernel level support we previously built. It is backward compatible with Unix semantics and Berkeley sockets, and {{has been used to}} implement Internet protocols such as TCP, UDP and IP (including IP multicast). We also show that active demultiplexing supported by Migrating Sockets can be transparently enabled in wide-area TCP/IP internetworking (although it is not restricted to TCP/IP). We have an implementation of Migrating Sockets in Solaris 2. 5. We discuss our implementation experience, and present performance results of our system running on the Ultra- 1, SPARC 10 and SPARC 20 architectures...|$|R
40|$|Compute nodes with {{multiple}} sockets {{each of which}} has multiple cores are starting to dominate in the area of scientific computing clusters. Performance inconsistencies from one execution to the next makes any performance debugging or tuning difficult. The resulting performance inconsistencies are bigger for memory-bound applications but still noticeable for all but the most compute-intensive applications. Memory and <b>thread</b> placement across <b>sockets</b> has significant impact on performance of these systems. We test overall performance and performance consistency for a number of OpenMP and pthread benchmarks including Stream, pChase, the NAS Parallel Benchmarks and SPEC OMP. The tests are run on a variety of multi-socket quad-core AMD Opteron systems. We examine the benefits of explicitly pinning each thread to a different core before any data initialization, thus improving and reducing the variability of performance due to data-to-thread co-location. Execution time variability falls to less than 2 % and for one memory-bound application peak performance increases over 40 %. For applications running on hundreds or thousands of nodes, reducing variability will improve load balance and total application performance. Careful memory and thread placement is critical for the successful performance tuning of nodes on a modern scientific compute cluster...|$|R
40|$|Software {{architecture}} is {{the means to}} cope with the complexity of large software systems. Typically architecture separates different concerns: at development time modules and relationships are in the focus, at deployment time binaries and physical nodes with their hardware constraints are considered. At execution time, runtime structures like communication protocols, <b>threads,</b> processes or <b>sockets</b> are of interest. Understanding the principal units of computation and analyzing certain runtime qualities of a system (e. g., availability or security and certain aspects of efficiency) requires having a Component and Connector view. The Component and Connector view addresses the communication and distribution related concerns at architectural level. It provides abstractions like logical components and connectors, ports, roles and protocols. As a matter of fact this kind of information is frequently missing or outdated in architectural documentation, so systematic reasoning about components and connectors and hence runtime structures and their qualities, is practically impossible. To overcome this issue, a method for reconstructing Component and Connector models from static source code is presented in this thesis. The method provides {{a detailed description of the}} reconstruction process and comes along with an Eclipse based tool support. The tool guides the user through the reconstruction process and automates error-prone, time consuming and complex reconstruction steps. As a proof of concept for the method, the Component and Connector model of a system in the ambient assisted living domain was successfully reconstructed. The applicability and suitability of the CoVeR method was shown and the approach promises to deliver practical relevant reconstruction results in an effort-efficient manner...|$|R
40|$|This {{work is a}} {{continuation}} and augmentation of previous energy studies ofCompressed Sparse eXtended (CSX), a framework for efficiently executing SparseMatrix-Vector Multiplication (SpMV). CSX {{was developed by the}} CSLab at the National Technical University of Athens(NTUA), and utilizes compression to overcome a significant memory bottleneckinherent in SpMV, thus increasing performance and energy efficiency of itsexecution. SpMV is notorious within scientific computing for its low performance. However,the problem is unavoidable, as SpMV can be found within several scientificapplications. In this work, CSX is tested as the SpMV kernel in a frameworkimplementing the Conjugate Gradient Method (CG), an iterative algorithm forsolving specific linear algebra problems. CSX is also evaluated againstCompressed Sparse Row (CSR), a storage scheme widely used when executing SpMV. This work augments existing studies by evaluating properties in the formatsthemselves, in the matrices used as input and in the target platform to gainknowledge on how to maximize the benefits of CSX, as well as for what casesCSX does not prove beneficial. The work also compares the performance ofSpMV-execution on a stand-alone server known as the CARD-server to similarexecution on the Vilje supercomputer. This is done to evaluate how thedifferences between these two machines affect the results. Based on the results, it is shown that CSX should be used for matrices largerthan the Last Level Cache (LLC) of the target machine and for matrices with highdegrees of clustering in their values. The best energy efficiency trade-offs arefound at eight <b>threads</b> on dual <b>socket</b> configurations, and this is shown to berelated to the amount of physical cores per CPU. Similarly, frequencythrottling is shown to increase the energy efficiency of the execution only athigh numbers of threads and at the cost of performance. Overall, CSX is shown to obtain higher energy efficiency than CSR forSpMV-execution, given a suitable problem and run configuration. Thus, it isconfirmed that CSX can be used to decrease the energy consumption of SpMVapplications. </p...|$|R

