2|32|Public
40|$|We {{describe}} {{a system that}} supports source-level integration of ML-like functional language code with ANSI C or Ada 83 code. The system works by translating the functional code into type-correct, "vanilla" C or Ada; it offers simple, efficient, type-safe inter-operation between new functional code components and "legacy" <b>third-generation</b> <b>language</b> components. Our translator represents a novel synthesis of techniques including user-parameterized specification of primitive types and operators; removal of polymorphism by code specialization; removal of higher-order functions using closure datatypes and interpretation; and aggressive optimization of the resulting first-order code, which {{can be viewed as}} encoding the result of a closure analysis. Programs remain fully typed at every stage of the translation process, using only simple, standard type systems. Target code runs at speeds comparable to the output of current optimizing ML compilers, even though handicapped by a conservative garbage collect [...] ...|$|E
40|$|This Infostructure Associates White Paper {{summarizes}} {{the results of}} an Infostructure Associates study comparing the total cost of ownership (TCO) and return on investment (ROI) of higher-level development platforms, such as Progress OpenEdge Business Platform (the Progress 4 GL plus the Progress OpenEdge framework), to so-called <b>third-generation</b> <b>language</b> development platforms, such as those offered for the C # programming language by Microsoft in Visual Studio. NET 2003 with its. NET Framework or for Java by IBM, Sun, and Oracle. This paper particularly focuses on TCO and ROI for those SMBs (small-tomedium-sized businesses) or departments/divisions of large enterprises attempting to create or upgrade mission-critical applications for internal use. It also assesses TCO and ROI for ISVs (Independent Software Vendors) selling business applications to the SMB market. The findings of this Infostructure Associates study are: • Higher-level development platforms demonstrate a clear advantage in both TCO and ROI over 3 GL tools {{in a wide variety of}} situations. Infostructure Associates research suggests that this advantage yields a reduction in three-year TCO of approximately 35 %, on average, and an improvement in ROI of 50 %...|$|E
5000|$|The next advance was the {{development}} of procedural <b>languages.</b> These <b>third-generation</b> <b>languages</b> (the first described as high-level languages) use vocabulary related to the problem being solved. For example, ...|$|R
50|$|According to Douglas C. Schmidt, model-driven {{engineering}} technologies offer {{a promising}} approach {{to address the}} inability of <b>third-generation</b> <b>languages</b> to alleviate the complexity of platforms and express domain concepts effectively.|$|R
50|$|Most popular {{general-purpose}} languages today, such as C, C++, C#, Java, BASIC and Pascal, {{are also}} <b>third-generation</b> <b>languages,</b> although {{each of these}} languages can be further subdivided into other categories based on other contemporary traits.|$|R
5000|$|MetaCard was a cross-platform, {{commercial}} HyperCard clone. MetaCard {{included an}} IDE, a GUI toolkit and {{had its own}} language, MetaTalk. From the MetaCard Corporation website: [...] "The MetaTalk language has all the features common to <b>third-generation</b> <b>languages</b> like C/C++/Java but has a much simpler syntax." ...|$|R
50|$|The {{simplest}} {{implementation of}} a function (or subroutine) pointer is as a variable containing {{the address of the}} function within executable memory. Older <b>third-generation</b> <b>languages</b> such as PL/I and COBOL, as well as more modern languages such as Pascal and C generally implement function pointers in this manner.|$|R
50|$|The {{architecture}} of IBM mainframes has undergone several extensions over the years, including System/360, System/370, System/370 XA, ESA/370, ESA/390, and z/Architecture. Each of these architectures has retained compatibility {{with most of}} the features of its predecessor. BAL uses the native instruction set of these machines. It is thus closer to the hardware than <b>third-generation</b> <b>languages</b> such as COBOL.|$|R
50|$|A <b>third-generation</b> {{programming}} <b>language</b> (3GL) is {{a generational}} way to categorize high-level computer programming languages.|$|R
50|$|In the 1960s, programmers built {{scientific}} subroutine libraries {{that were}} reusable {{in a broad}} array of engineering and scientific applications. Though these subroutine libraries reused well-defined algorithms in an effective manner, they had a limited domain of application. Commercial sites routinely created application programs from reusable modules written in assembly language, COBOL, PL/1 and other second- and <b>third-generation</b> <b>languages</b> using both system and user application libraries.|$|R
50|$|The {{term was}} coined {{to provide a}} {{distinction}} from higher level <b>third-generation</b> programming <b>languages</b> (3GL) such as COBOL and earlier first-generation programming language (machine code languages).|$|R
5000|$|Generic Eclipse Modeling System (GEMS) is a {{configurable}} toolkit {{for creating}} domain-specific modeling and program synthesis environments for Eclipse. The project aims {{to bridge the}} gap between the communities experienced with visual metamodeling tools like those built around the Eclipse modeling technologies, such as the Eclipse Modeling Framework (EMF) and Graphical Modeling Framework (GMF). [...] GEMS helps developers rapidly create a graphical modeling tool from a visual language description or metamodel without any coding in <b>third-generation</b> <b>languages.</b> Graphical modeling tools created with GEMS automatically support complex capabilities, such as remote updating and querying, template creation, styling with Cascading Style Sheets (CSS), and model linking.|$|R
50|$|A {{function}} pointer (or subroutine pointer or procedure pointer) {{is a type}} of pointer {{supported by}} <b>third-generation</b> programming <b>languages</b> (such as PL/I, COBOL, Fortran, dBASE dBL, and C) and object-oriented programming languages (such as C++ and D).|$|R
50|$|Creative Basic (CB) is a <b>third-generation</b> {{event-driven}} programming <b>language</b> for Windows, with {{an integrated}} development environment (IDE).|$|R
50|$|The first {{high-level}} programming <b>languages,</b> or <b>third-generation</b> programming <b>languages</b> (3GL), {{were written}} in the 1950s. An early high-level programming language to be designed for a computer was Plankalkül, developed for the German Z3 by Konrad Zuse between 1943 and 1945. However, it was not implemented until 1998 and 2000.|$|R
40|$|While {{the topic}} of {{object-oriented}} databases is by now fairly mature [...] a standard for data definition and query languages has been developed [10] [...] the question of updates has largely been ignored. Updates on objectoriented databases are relegated to methods, which are written in <b>third-generation</b> <b>languages</b> such as C++ and therefore appear as "black boxes" to the query processor. This poses two problems: First, {{it is difficult to}} reason about whether an update is non-deterministic. Non-determinism arises due to iteration over sets and potential sharing between elements of the set. Second, these updates are system-specific and cannot be optimized. In this paper, we propose an optimizable language for updating object-oriented databases called OQL+. The look and feel of OQL+ is similar to OQL, with the addition of insert, update and delete primitives. OQL+ is expressive enough to capture most updates that users might want to perform on an object-oriented database while maintaining the si [...] ...|$|R
50|$|Flowcharts {{became a}} popular means for {{describing}} computer algorithms. The popularity of flowcharts decreased in the 1970s when interactive computer terminals and <b>third-generation</b> programming <b>languages</b> became common tools for computer programming. Algorithms {{can be expressed}} much more concisely as source code in such languages. Often pseudo-code is used, which uses the common idioms of such languages without strictly adhering {{to the details of}} a particular one.|$|R
5000|$|Forth is {{so named}} because in 1968 [...] "the file holding the {{interpreter}} was labeled FOURTH, for 4th (next) generation software—but the IBM 1130 operating system restricted file names to 5 characters." [...] Moore saw Forth as a successor to compile-link-go <b>third-generation</b> programming <b>languages,</b> or software for [...] "fourth generation" [...] hardware, not a fourth-generation programming language as the term {{has come to be}} used.|$|R
50|$|Executable UML is {{a higher}} level of {{abstraction}} than <b>third-generation</b> programming <b>languages.</b> This allows developers to develop at the level of abstraction of the application. The Executable UML aims for separation of concerns. This is supposed to increase ease of reuse and to lower the cost of software development. This also enables Executable UML domains to be cross-platform. That means it is not tied to any specific programming language, platform or technology.|$|R
40|$|Model-driven {{engineering}} technologies offer {{a promising}} approach {{to address the}} inability of <b>third-generation</b> <b>languages</b> to alleviate the complexity of platforms and express domain concepts effectively. Over the past five decades, software researchers and developers have been creating abstractions that help them program {{in terms of their}} design intent rather than the underlying computing environment—for example, CPU, memory, and network devices—and shield them from the complexities of these environments. From the early days of computing, these abstractions included both language and platform technologies. For example, early programming languages, such as assembly and Fortran, shielded developers from complexities of programming with machine code. Likewise, early operating system platforms, such as OS/ 360 and Unix, shielded developers from complexities of programming directly to hardware. Although these early languages and platforms raised the level of abstraction, they still had a distinct &quot;computing-oriented&quot; focus. In particular, they provided abstractions of the solution space—that is, the domain of computing technologies themselves—rather than abstractions of the problem space that express designs in terms of concepts in application domains, such as telecom, aerospace, healthcare, insurance, and biology. LESSONS FROM COMPUTER-AIDED SOFTWARE ENGINEERING Various past efforts have created technologies that further elevated the level of abstraction used to develop software...|$|R
40|$|Traditionally, {{connection}} management applications (referred to as patchbays) for high-speed audio networking, {{are predominantly}} developed using <b>third-generation</b> <b>languages</b> such as C, C# and C++. Due {{to the rapid}} increase in distributed audio/video network usage in the world today, connection management applications that control signal routing over these networks have also evolved in complexity to accommodate more functionality. As the result, high-speed audio networking application developers require a tool that {{will enable them to}} develop complex connection management applications easily and within the shortest possible time. In addition, this tool should provide them with the reliability and flexibility required to develop applications controlling signal routing in networks carrying real-time data. High-speed audio networks are used for various purposes that include audio/video production and broadcasting. This investigation evaluates the possibility of using Adobe Flash Professional 8, using ActionScript 2. 0, for developing connection management applications. Three patchbays, namely the Broadcast patchbay, the Project studio patchbay, and the Hospitality/Convention Centre patchbay were developed and tested for connection management in three sound installation networks, namely the Broadcast network, the Project studio network, and the Hospitality/Convention Centre network. Findings indicate that complex connection management applications can effectively be implemented using the Adobe Flash IDE and ActionScript 2. 0...|$|R
5000|$|Shetty's {{poetry is}} seen as being an {{integral}} part of the [...] "chronology of modern Indian English poetry," [...] with these <b>third-generation</b> English <b>language</b> poets moving [...] "away from radical modernist techniques. They are more concerned with the portrayal and assessment of their family background, their own lives and relations with others, and their immediate environment. Shetty's poetry is described as reveling in [...] "the celebration of the sombre" [...] and being filled with [...] "sepulchral images" [...] while their [...] "mood is predominantly one of helplessness and lethargy." ...|$|R
40|$|Model-driven {{development}} (MDD) {{processes are}} increasingly being used to develop component middleware and applications for distributed real-time and embedded (DRE) systems in various domains. DRE applications are often missioncritical and have stringent quality of service (QoS) requirements, such as timeliness, predictability and scalability. MDD software techniques are well suited for validating the operation of DRE applications since they offer a higher-level of abstraction than conventional <b>third-generation</b> programming <b>languages.</b> The state-of-the-art in model-driven DRE application development is still maturing, however. For example, conventional MDD development environments for DRE application do not yet provide seamless integration of development capabilities and model checking capabilities...|$|R
40|$|Model-driven {{development}} is an emerging paradigm that improves the software development life cycle, particularly for large software systems, {{by providing a}} higher level of abstraction for system design than is possible with <b>third-generation</b> programming <b>languages.</b> Historically, software development methodologies have focused more on improving tools for system development than on developing tools that assist with system composition and integration. Component-based middleware like Enterprise Java-Beans (EJB), Microsoft. NET, and the CORBA Component Model (CCM) have helped improve software reusability through component abstraction. However, as developers have adopted these commercial off-the-shelf technologies, a wide gap has emerged between the availability and sophistication of standard software developmen...|$|R
50|$|A {{fourth-generation}} {{programming language}} (4GL) {{is a computer}} programming language envisioned as a refinement of the style of <b>languages</b> classified as <b>third-generation</b> programming <b>language</b> (3GL). Each of the programming language generations aims to provide {{a higher level of}} abstraction of the internal computer hardware details, making the language more programmer-friendly, powerful and versatile. While the definition of 4GL has changed over time, it can be typified by operating more with large collections of information at once rather than focusing on just bits and bytes. Languages claimed to be 4GL may include support for database management, report generation, mathematical optimization, GUI development, or web development. Some researchers state that 4GLs are a subset of domain-specific languages.|$|R
50|$|While the {{scripting}} language in AutoIt 1 and 2 was statement-driven, designed primarily for simulating user interaction, from version 3 onwards the AutoIt syntax {{is similar to}} that found in the BASIC family of languages. In this form, AutoIt is a general-purpose, <b>third-generation</b> programming <b>language</b> with a classical data model and a variant data type that can store several types of data, including arrays. While version 1 and 2 were compatible with Windows 95, 98, ME, NT4, 2000, XP, 2003, Vista, Windows 7, support for operating systems older than Windows 2000 was discontinued with the release of v3.3.0 in December 2008. Currently AutoIt is compatibile also with Windows 2008, Windows 8, Windows 2012, Windows 10, and minimal requirement is XP+SP3.|$|R
40|$|Abstract — Model-driven {{development}} (MDD) is {{an emerging}} paradigm that improves the software development lifecycle, particularly for large software systems {{by providing a}} higherlevel of abstraction for designing and developing the system than is possible with <b>third-generation</b> programming <b>languages.</b> The MDD paradigm relies {{on the use of}} (1) Domain-Specific Modeling Languages that incorporate elements of the domain being modeled and their relationship as first-class objects, and (2) model transformations that transform the models into platformspecific artifacts, such as code. This paper illustrates several key characteristics of the MDD approach that differentiate it from traditional software development approaches. Additionally, the paper describes meta-programmable tools used to construct domain-specific tool-suites, and provides two example tool suites drawn from different domains. These tool-suites are (a) PICML, which supports the development of standards-compliant component-based applications, and (b) ECSL, which supports software development for distributed embedded controllers...|$|R
40|$|Model-driven {{development}} (MDD) {{tools and}} processes are increasingly {{used to develop}} component middleware and applications for distributed real-time and embedded (DRE) systems, which have stringent requirements for timeliness, correctness, scalability, and maintainability. MDD techniques help developers of DRE systems express application functionality and quality of service (QoS) requirements {{at a higher level}} of abstraction than is possible using <b>third-generation</b> programming <b>languages,</b> such as Visual Basic, Java, C++, or C#. The state-of-the-art in MDD for large-scale DRE systems is still maturing, however, and no single MDD environment provides the capabilities needed for effective development of large-scale DRE systems. This chapter presents three contributions to the study of integrated MDD development and model checking for large-scale DRE systems. First, we describe how our CoSMIC and Cadena MDD toolsuites have been combined to provide an integrated environment that enhances the development and validation of DRE systems. Second...|$|R
40|$|The growing {{complexity}} and criticality of distributed systems motivates software developers {{to raise the}} level of abstraction used to develop these systems. A promising approach for improving the quality and productivity of software development is to (1) assemble applications from higher-level building blocks that represent solution templates for certain application domains and (2) apply model-driven development techniques and tools to manipulate the building blocks and automate key tasks related to system specification, implementation, configuration, and deployment, rather than (re) writing the applications manually using <b>third-generation</b> programming <b>languages.</b> To simplify the manipulation of component building blocks, however, requires a well-formed set of rules and relationships. This paper contributes to the study of these topics by describing pattern feature inheritance relationships, showing how pattern feature inheritance can improve the reusability of models, and illustrating our approach with a concrete example adding the remoting aspect to a GUI application...|$|R
50|$|Visual Basic is a <b>third-generation</b> {{event-driven}} programming <b>language</b> {{and integrated}} development environment (IDE) from Microsoft for its Component Object Model (COM) programming model first released in 1991 and declared legacy during 2008. Microsoft intended Visual Basic to be relatively easy to learn and use. Visual Basic was derived from BASIC, a user-friendly programming language designed for beginners, and it enables the rapid application development (RAD) of graphical user interface (GUI) applications, access to databases using Data Access Objects, Remote Data Objects, or ActiveX Data Objects, and creation of ActiveX controls and objects.|$|R
40|$|This paper {{presents}} {{a method for}} applying the PROxy Based Estimation (PROBE) technique to Structured Query Language (SQL). Estimating program size is {{a critical component of}} successful software project effort estimation and cost estimation. The PROBE technique is a simple estimation method {{that can be used for}} estimating program size and effort. To date, PROBE has been used more often to estimate programs written in <b>third-generation</b> programming <b>languages</b> (3 GL) such as C, C++, and Java. Its application to IT development has been inhibited by the lack of demonstrated applicability to database work. For data storage, most IT departments have transitioned from file-oriented storage (accessed by traditional 3 GL languages) to relational database server software, which uses an implementation of 4 GL languages such as SQL to manipulate data. SQL 2 ̆ 7 s logic encapsulation properties differ dramatically from those of traditional 3 GL languages, so it is not clear to most developers how to effectively apply the PROBE techniques to SQL. The method presented here enables a level of estimation detail similar to the application of PROBE to traditional 3 GL languages...|$|R
40|$|Enterprise level {{software}} development using traditional software engineeringapproaches with <b>third-generation</b> programming <b>languages</b> is becoming morechallenging and cumbersome task {{with the increased}} complexity of products,shortened development cycles and heightened expectations of quality. MDD(Model Driven Development) has been counting as an exciting and magicaldevelopment approach in the software industry from several years. The ideabehind MDD is the separation of business logic of a system from its implementationdetails expressing problem domain using models. This separation andmodeling of problem domain simplify the process of system design as well asincrease the longevity of products as new technologies can be adopted easily. With appropriate tool support, MDD shortens the {{software development}} lifecycle drastically by automating {{a significant portion of}} development steps. MDA (Model Driven Architecture) is a framework launched by OMG (ObjectManagement Group) to support MDD. SPACE is an engineering methodfor rapid creation of services, developed at NTNU (Norwegian University ofScience and Technology) which follows MDA framework. Arctis and Ramsesare tool suits, also developed at NTNU to support SPACE method. Severalsolutions have been developed on Arctis tool suit covering several domainslike mobile services, embedded systems, home automation, trust managementand web services. This thesis presents a case study on the web application domain with Arctis,where the underlying technologies are AJAX (asynchronous JavaScriptand XML), GWT (Google Web Toolkit) framework and Java Servlet. Inorder to do that, this thesis contributes building up some reusable buildingblocks with Arctis tool suit. This thesis also describes a use case scenario touse those building blocks. This thesis work tries to implement the specifiedsystem and evaluates the resulting work...|$|R
40|$|The {{construction}} of libraries of reusable software components {{is the standard}} software engineering solution for improving software development productivity and quality. By encapsulating usable functionality in software components (e. g. subroutines, object classes), and then reusing those components, software of greater functionality can be developed in less time, with some assurance that the overall system is correct because it is built from trusted components. However, there are impediments {{to the use of}} software libraries. Obviously, nonprogrammers cannot use them directly. Even for programmers, there is a barrier {{in the form of the}} startup time to learn the library. The library may be inadequately documented, or, on the other hand, may be voluminously documented. Learning the conventions for using the library takes time, as well as learning which components implement the needed capabilities. Programmers who are not intimate with a particular library sometimes find it expedient to rewrite code from scratch rather than investigate thoroughly the capabilities of a given library. All of this is exacerbated because, we claim, conventional programming languages are not at a high-enough level. For example, <b>third-generation</b> and object-oriented <b>languages</b> do not allow for the specification of constraints. Components built from such programming languages will necessarily require that the user be cognizant of programming details, e. g. value-passing conventions and data representations, which are below the conceptual level of the application domain. If the language does provide a level above this, efficiency may be lost due to run-time interpretation. The goal of the Amphion project is to provide a system with the following properties...|$|R
40|$|This {{dissertation}} {{investigates the}} complexities of language shift and maintenance among four generations of Italian Canadians by examining what participants say about language {{and what they do}} with language in family interactions. Analyses of multigenerational family conversations, informal interviews, and ethnographic observation focus on the sociolinguistic means through which participants create and negotiate simultaneous pressures to shift to English monolingualism and to maintain the Italian language and notions of Italianness. Italianness is an important aspect-of-self for participants, and they (re) create it through linguistic means that do not fall under traditional notions of maintenance. An examination of what participants say about language shows that they feel that younger generations are losing the Italian <b>language.</b> <b>Third-generation</b> participants claim that they have full receptive knowledge of Italian and more productive knowledge than they often use, but that social norms for the use of Italian and English in family conversations dictate that they use only English, with the exception of occasional Italian emblematic expressions. At the same time that participants feel pressure to use only English, they want to maintain Italianness and Italian language. The examination of what participants do with language focuses on three linguistic phenomena recurrent in family interaction: interpreting, Stylized Italian English, and insertion of Italian lexical items into otherwise English utterances. These phenomena are explored as (socio) linguistic practices and resources that respond to and (re) create simultaneous pressures for language shift and maintenance and reinforce notions of Italianness. Little work has been done in sociolinguistics and language contact studies to explore the ways in which shift and maintenance are intertwined and co-occurring processes within a dynamic shift-maintenance system. Sociolinguistics has largely ignored the ways in which participants create and negotiate simultaneous pressures for shift to monolingualism in the majority language and maintenance of the heritage language. This dissertation troubles definitions of maintenance by examining some of the realities that multiple generations of an immigrant community are experiencing from an on-the-ground ethnographic perspective. Studying these participants at this time provides a real-time model of a language shift-maintenance system and the practical realities of a North American language contact situation...|$|R

