75|16|Public
50|$|A tool-chain, xTIMEcomposer, {{come with}} LLVM-based compilers for C, C++ and xC, cycle-accurate simulator, {{symbolic}} debugger, runtime instrumentation and trace libraries (xSCOPE) and a static code <b>timing</b> <b>analyzer</b> (XTA). All {{of the components}} {{are aware of the}} real-time multicore nature of the programs, giving a fully integrated approach.|$|E
40|$|A latch-based <b>timing</b> <b>analyzer</b> is an {{essential}} tool for developing high-speed pipeline designs. As process variations increasingly influence the timing characteristics of DSM designs, a <b>timing</b> <b>analyzer</b> capable of handling process-induced timing variations for latchbased pipeline designs becomes in demand. In this work, we present a static statistical <b>timing</b> <b>analyzer,</b> STAP, for latch-based pipeline designs. Our analyzer propagates statistical worst-case delays as well as critical probabilities across the pipeline stages. We present an efficient method to handle correlations due to reconvergent fanouts. We also demonstrate the impact of not including the analysis of reconvergent fanouts in latch-based pipeline designs. Comparing to a Monte-Carlo based <b>timing</b> <b>analyzer,</b> our experiments show that STAP can accurately evaluate the critical probability that a design violates the timing constraints under a given statistical timing model. The runtime comparison further demonstrates the efficiency of our STAP. 1...|$|E
40|$|International audienceThis paper {{presents}} {{the performance of}} the static <b>timing</b> <b>analyzer</b> TAS for deep sub-micronic CMOS technologies. The methodology used by TAS is given with special emphasis on its Short Channel MOS model. Results are given to show the accuracy of the static <b>timing</b> <b>analyzer</b> TAS for various CMOS circuits (including pass transistor and precharge logic) as well as for various CMOS processes ranging from 1. 2 μ to 0. 35 μ. The Short Channel MOS model of TAS appears to be relevant to the analysis of deep submicronic processes...|$|E
40|$|Existing static <b>timing</b> <b>analyzers</b> {{make several}} {{assumptions}} about circuits, implicitly trading off accuracy for speed. In this paper {{we examine the}} validity of these assumptions, notably the slope approximation to waveforms, single-input transitions, and {{the choice of a}} propagating signal based on a single voltage-time point. We provide data on static CMOS gates that show delays obtained in this way can be optimistic by more than 30 %. We propose a new approach, Waveform-based Timing Analysis that employs a state-ofthe-art circuit simulator as the underlying delay modeler. We show that such an approach can achieve more accurate delays than slope-based <b>timing</b> <b>analyzers</b> at a computation cost that still allows iterations between design modification and delay analysis. 1...|$|R
50|$|LiberateLiberate is an {{automated}} library characterization tool for standard cells and I/Os that serves existing static <b>timing</b> <b>analyzers.</b> Liberate takes in a Spice netlist and Spice subcircuits, and automatically generates a characterized cell library. It supports both Composite Current Source (CCS) model backed by Synopsys and the Effective Current Source Model (ECSM) backed by Cadence Design Systems.|$|R
40|$|Many {{existing}} <b>timing</b> <b>analyzers</b> {{require that}} user specify {{the number of}} iterations for each loop in the program [Healy 98]. The bounds of every loop must be specifically provided by the user. This can give room too many possible errors. For example, the user might have modified the code and have forgotten to modify the annotations. Errors in these annotations can drastically affect th...|$|R
40|$|The {{objective}} {{of this paper is}} to present a software tool, called retargetable <b>timing</b> <b>analyzer</b> generator (RTAG), which takes as input an architecture description and automatically generates a pipeline analyzer to resolve the portability problem. We explain our methodology for worst case execution time analysis and describe how it is reflected in the <b>timing</b> <b>analyzer</b> generator. The generator takes into account the effects of multiple execution pipelines when generating a worst case execution time(WCET) analyzer for a given machine. 1 Introduction The <b>timing</b> <b>analyzer</b> that provides guaranteed WCET estimates of programs is of utmost importance in real-time computing systems where the WCETs of tasks must be known a priori for scheduling purposes. In RISC processors, the execution time of a program construct (e. g., a statement) is affected by various factors such as cache hits/misses and pipeline hazards, and these factors impose serious problems on analyzing the WCETs of tasks. To solve thi [...] ...|$|E
40|$|We {{propose a}} {{technique}} to analyze the worst case execution times (WCETs) of optimized programs. Our work {{is based on a}} hierarchical timing analysis technique called the extended timing schema (ETS). A major hurdle in applying the ETS to optimized programs is the lack of correspondences in the control structure between the optimized machine code to be analyzed and the original source program written in a high-level programming language. We suggest a compiler-assisted approach where a <b>timing</b> <b>analyzer</b> relies on an optimizing compiler for a consistent hierarchical representation and an accurate source-level correspondence that are essential for accurate WCET analysis for optimized programs. In order to validate the proposed approach, we implemented a proof-of-concept version of a <b>timing</b> <b>analyzer</b> for a 256 -bit VLIW processor and compared the analysis results with the simulation results. The experimental results show that the proposed solution can accurately predict the WCETs of highly-optimized VLIW programs...|$|E
40|$|This work {{addresses}} {{the problem of}} analytical multiobjective optimization of combinational DCFL/SDCFL GaAs MESFETs IC. The critical path is determined {{by means of the}} GASTIM <b>timing</b> <b>analyzer.</b> The optimization strategy takes into account the slope dependency, the fan-out and the wiring capacitances. The results show that is possible to decrease the power consumption without degrading the propagation delay. We are not aware of any automatic tool able to solve the optimization task when designing circuits on GaAs material...|$|E
40|$|Current {{extended}} {{value set}} dynamic <b>timing</b> <b>analyzers</b> are not sophisticated enough {{to detect the}} subtle timing relationships upon which timing-critical systems depend, and exhaustive simulation achieves very accurate results but at tremendous computational cost. MTV is a simulator that strikes a balance between accuracy and efficiency. MTV is more accurate than other extended value set simulators because it respects the ordering of events. It is more efficient than exhaustive simulators because it efficiently simulates overlapping events and requires only a single waveform to represent a signal. Features of MTV include: elimination of common ambiguity, symbolic delays, correlated delays, and sophisticated algorithms to detect ordered events. This paper concludes with simulation results from the ISCAS 85 benchmark suite. ...|$|R
40|$|Modern {{high-performance}} asynchronous circuits {{depend on}} timing constraints for correct operation, so <b>timing</b> <b>analyzers</b> are essential asynchronous design tools. In this paper, {{we present a}} 13 -valued abstract waveform algebra and a polynomial-time min-max timing simulation algorithm for use in efficient, approximate timing analysis of asynchronous circuits with bounded component delays. Unlike several previous approaches, our algorithm computes separate propagation delay bounds from each circuit input to each internal gate. This is useful for analyzing asynchronous circuits, where the relative transition times of the inputs may not be known a priori, unlike synchronous circuits. We also describe an efficient reconvergent fanout analysis technique that helps in increasing the accuracy of simulation. We have applied our algorithm to build an efficient timing analysis tool for extended burst-mode circuits (a class of timing-dependent asynchronous circuits) implemented in the 3 D design style [...] ...|$|R
50|$|In {{static timing}} {{analysis}}, the word static {{alludes to the}} fact that this timing analysis is carried out in an input-independent manner, and purports to find the worst-case delay of the circuit over all possible input combinations. The computational efficiency (linear in the number of edges in the graph) of such an approach has resulted in its widespread use, even though it has some limitations. A method that is commonly referred to as PERT is popularly used in STA. In fact, PERT is a misnomer, and the so-called PERT method discussed in most of the literature on timing analysis refers to the critical path method (CPM) that is widely used in project management. While the CPM-based methods are the dominant ones in use today, other methods for traversing circuit graphs, such as depth-first search, have been used by various <b>timing</b> <b>analyzers.</b>|$|R
40|$|Real-time programmers have to {{deal with}} the problem of {{relating}} timing constraints associated with source code to sequences of machine instructions. This paper describes an environment to assist users in the spec-ification and analysis of timing constraints. A <b>timing</b> <b>analyzer</b> predicts the best and worst case bounds for these constrained portions of code. A user interface for this <b>timing</b> <b>analyzer</b> was developed to depict whether these constraints were violated or met. A user is allowed to specify timing constraints within the source code of a C program. The user interface also provides three different methods for interactively selecting portions of programs. After each selection the corresponding bounded times, source code lines, and machine instructions are automatically displayed. Users are pre vented from only selecting portions of the program for which timing bounds cannot be obtained. In addition, a technique is presented that allows the timing analysis to scale efficiently with complex functions and loops. The result is a user-friendly envi-ronment that supports the user specification and analysis of timing constraints at a high (source code) level and retains the accuracy of low (machine code) level analysis. 1...|$|E
40|$|This paper {{presents}} {{techniques to}} include the impact of crosstalk on timing verification of VLSI. We propose delay models for the victim driver gate, loaded through a resistive wire, when noise is injected from aggressor nets. A special care has been taken {{in order to minimize}} CPU time and data storage size. The proposed method was implemented with the hierarchical <b>timing</b> <b>analyzer</b> HiTAS and the stability analyzer STB by Avertec, a spin-off company of UPMC. Results on three real circuits are presented to illustrate the method...|$|E
40|$|KTA (KTH's <b>timing</b> <b>analyzer)</b> is a {{research}} tool for performing timing analysis of program code. The currently available toolchain can perform two different kinds of analyses: i) exhaustive fine-grained timing analysis, where timing information can be provided between arbitrary timing program points within a function, and ii) abstract search-based timing analysis, where the tool can perform optimal worst-case execution time (WCET) analysis. The latter {{is based on a}} technique that combines divide-and-conquer search and abstract interpretation. The tool is under development and currently supports a subset of the MIPS instruction set architecture...|$|E
40|$|We {{present a}} novel timing {{analysis}} mechanism {{which is based}} on identifying primitive path delay faults (primi-tive PDFs) in a circuit. We show that this approach gives the exact maximum delay of the circuit under the floating mode of operation assumption. Our timing analysis approach provides a framework where component delay correlations and signal correlations arising from fabrica-tion process, signal propagation, and signal interaction effects can be handled very accurately. Under these effects, timing analysis using previously reported floating mode <b>timing</b> <b>analyzers,</b> e. g., viability, TrueD-F etc., is very pessimistic. Our timing analysis approach based on primi-tive PDF identification is also more efficient than conven-tional floating mode path sensitization analysis mechanisms in situations where critical paths need to be re-identified due to component delay speedup (e. g., post-layout delay optimization). We demonstrate the applicabil-ity of our timing analysis approach for a variety of bench-mark circuits, and demonstrate the pessimism of conventional floating mode timing analysis approaches in accounting for signal propagation effects. 1...|$|R
40|$|Abstract: For {{improved}} efficiency, static <b>timing</b> <b>analyzers</b> {{represent the}} interconnect driving point with a reduced order model {{so that the}} gate and interconnect delays can be calculated separately. Traditionally, the pi-circuit {{has been used to}} model the driving point of RC interconnect. As process technologies have improved, it has become necessary to include on-chip inductance during the timing analysis of high performance designs. However, the pi-model breaks down for interconnect with inductance. In this paper, we discuss the behavior of RC and RLC one ports in a circuit theoretic framework and characterize when the pi-model is not synthesizable for RLC circuits. We then present a synthesis procedure for RLC circuits that guarantees a realizable reduced order circuit using the first four moments of the input admittance. We demonstrate the efficacy of the proposed model for on-chip RLC interconnect with several examples. We see the proposed model serving the same purpose for RLC circuits that the pi-model did for RC circuits. I...|$|R
40|$|Static <b>timing</b> <b>analyzers,</b> {{which are}} used to analyze {{real-time}} systems, {{need to know the}} minimum and maximum number of iterations associated with each loop in a real-time program so accurate timing predictions can be obtained. This paper describes three complementary methods to support timing analysis by bounding the number of loop iterations. First, an algorithm is presented that determines the minimum and maximum number of iterations of loops with multiple exits. Even when the number of iterations cannot be exactly determined, it is desirable to know the lower and upper iteration bounds. Second, when the number of iterations is dependent on unknown values of variables, the user is asked to provide bounds for these variables. These bounds are used to determine the minimum and maximum number of iterations. Specifying the values of variables is less error prone than specifying the number of loop iterations directly. Finally, a method is given to tightly predict the execution time of in [...] ...|$|R
40|$|Predicting the {{execution}} time of code segments in real-time systems is challenging. Most recently designed machines contain pipelines and caches. Pipeline hazards {{may result in}} multicycle delays. Instruction or data memory references may not be found in cache and these misses typically require several cycles to resolve. Whether an instruction will stall due to apipeline hazard oracache miss depends on the dynamic sequence of previous instructions executed and memory references performed. Furthermore, these penalties are not independent since delays due to pipeline stalls and cache miss penalties may overlap. This paper describes an approach for bounding the worst and best-case performance of large code segments on machines that exploit both pipelining and instruction caching. First, a method is used to analyze a program’s control flow to statically categorize the caching behavior of each instruction. Next, these categorizations {{are used in the}} pipeline analysis of sequences of instructions representing paths within the program. A <b>timing</b> <b>analyzer</b> uses the pipeline path analysis to estimate the worst and best-case execution performance of each loop and function in the program. Finally, agraphical user interface is invoked that allows a user to request timing predictions on portions of the program. The results indicate that the <b>timing</b> <b>analyzer</b> efficiently produces tight predictions of worst and best-case performance for pipelining and instruction caching. Index terms: real-time systems, worst-case execution time, best-case execution time, timing analysis, instruction cache, pipelinin...|$|E
40|$|Power gating is {{a circuit}} {{technique}} that enables high performance and low power operation. One {{of the challenges}} in power gating is sizing the sleep transistor {{which is used to}} gate the power supply. This paper presents a new methodology based on timing criticality and temporal currents to size the sleep transistor. The timing criticality information and temporal current estimation are obtained using static <b>timing</b> <b>analyzer.</b> The results obtained indicate that our proposed technique results in area reduction of sleep transistors by 80 % and 49 % compared to module based design and cluster based design respectively...|$|E
40|$|At the 250 nm {{technology}} node, interconnect delays {{account for}} over 40 % of worst delays [12]. Transition to 130 nm and below increases this figure, {{and hence the}} relative importance of timing-driven placement for VLSI. Our work introduces a novel minimization of maximal path delay that improves upon previously known algorithms for timing-driven placement. Our placement algorithms have provable properties and are fast in practice. Empirical validation is based on extending a scalable min-cut placer with proven quality in wirelength and congestion-driven placement [4]. The CPU overhead of the timingdriven capability is within 50 %. We placed industrial circuits and evaluated the resulting layouts with a commercial static <b>timing</b> <b>analyzer...</b>|$|E
40|$|Abstract — As we {{move into}} the nano era in {{integrated}} circuit fabrication tech-nologies, the performance variability due to statistical process variations and envi-ronmental fluctuations {{is becoming more and more}} significant. Considerable effort has been expended in the EDA community during the past several years in trying to cope with the so-called statistical timing problem. However, most of this effort has been aimed at generalizing the static <b>timing</b> <b>analyzers</b> to the statistical case in an EDA tool centric manner. In this paper, we take a pragmatic, design centric approach in pursuit of a simple yet powerful stochastic gate delay model that can be used to develop a very efficient timing yield estimation methodology, and that can enable tractable timing yield optimization and eventually lead to simple yet meaningful and useful design guidelines. In doing so, we first develop a generalization of the logical effort delay model for the stochastic case. In the spirit of the standard logical effort formalism, the stochastic gate delay model we propose separates the characterization of statistical variability from the gate topology, type, size and loading information. We then demonstrate why and how the simple stochastic gate delay model that fea...|$|R
40|$|Abstract — In the nano era in {{integrated}} circuit fabrication technologies, the performance variability due to statistical process and circuit parameter variations {{is becoming more}} and more significant. Considerable effort has been expended in the EDA community during the past several years in trying to cope with the so-called statistical timing problem. Most of this effort has been aimed at generalizing the static <b>timing</b> <b>analyzers</b> to the statistical case. In this paper, we take a pragmatic approach in pursuit of making the Monte Carlo method for timing yield estimation practically feasible. The Monte Carlo method is widely used as a golden reference in assessing the accuracy of other timing yield estimation techniques. However, it is generally believed that it can not be used in practice for estimating timing yield as it requires too many costly full circuit simulations for acceptable accuracy. In this paper, we present a novel approach to constructing an improved Monte Carlo estimator for timing yield which provides the same accuracy as the standard Monte Carlo estimator, but at a cost of much fewer full circuit simulations. This improved estimator is based on a novel combination of a variance reduction technique, importance sampling, and a stochastic generalization of the logical effort formalism for cheap but approximate delay estimation. The results we present demonstrate that our improved yield estimator achieves the same accuracy as the standard Monte Carlo estimator at a cost reduction reaching several orders of magnitude...|$|R
40|$|Abstract — High {{performance}} circuits {{are facing}} increasingly severe signal integrity problems due to crosstalk noise and crosstalk noise awareness {{has become an}} integral part of static timing analysis (STA). Existing crosstalk noise aware STA methods compute noise induced delay uncertainty on a net by net basis and in a pessimistic way, without considering the overlap bounds of the victim and aggressor timing windows and realistic delay impact on early and late signal arrival times. Since crosstalk induced delay on indivudial nets contribute cumulatively on data and clock paths, even small amounts of pessimism in computation can add up to produce several unrealistic timing violations. Unlike glitch noise analysis where noise often attenuates during propagation, quality of delay noise analysis is severely affected by any pessimism in noise estimation and can unnecessarily cost valuable silicon and design resources for fixing unreal violations. In this paper, we propose two temporal techniques to reduce pessimism in crosstalk noise aware STA. The first method, “effective delay noise”, is a net based method where the exact overlap points of victim and aggressor timing windows are considered to obtain the part of delay noise that actually impacts early and late signal arrival times. The second method, “path based delay noise”, is a path based method where the reduced arrival uncertainty of the nets of a given path are utilized for pessimism reduction. We also propose a novel “uncertainty propagation ” technique as part of the second method, which results in an iteration free crosstalk noise aware STA of the path with significantly reduced pessimism. The two techniques are combined in a proposed methodology that is compatible with existing industrial static <b>timing</b> <b>analyzers</b> with very little computational overhead compared to the traditional noise aware STA and a significant improvement in eliminating unreal violations. The proposed techniques resulted in 77 % reduction of worst case negative slack and 57 % reduction in the number of failing paths in the setup analysis of a 90 nm industrial design. I...|$|R
40|$|This {{research}} {{developed a}} framework which analyzes circuit-level reliability and evaluates the lifetimes of complex systems like state-of-art microprocessors. The novelty {{of the proposed}} work lies on its statistical <b>timing</b> <b>analyzer</b> {{and the ability to}} handle the combined effect of a variety of front-end-of-line (FEOL) wearout mechanisms, while including both the manufacturing process variability and the real-time uncertainties in workload and ambient conditions like operating temperature and IR drops. Overall, the proposed framework presents the correlation between circuit performance (speed) and circuit lifetime, which enables circuit designers to avoid excessive guard-banding, by using a better understood reliability budget to achieve higher performance. Ph. D...|$|E
40|$|The Office of Graduate Studies has {{verified}} {{and approved}} the above named committee members. ii ACKNOWLEDGMENTS I am deeply indebted in gratitude to my major professor, Dr. David Whalley, for his guidance, support, patience, and promptness during my research. He was always available to discuss new problems and exchange ideas. I cannot complete this dissertation without his excellent teaching and mentoring. I thank my committee members Dr. Baker, Dr. van Engelen, Dr. Gaillivan, and Dr. Srivastava for reviewing this dissertation and subsequent valuable suggestions. I also thank Prasad Kulkarni, William Kreahling, Stephen Hines, Richard Whaley, Gang-Ryung Uh and Frank Meuller for their assistance. The <b>timing</b> <b>analyzer</b> {{was developed by}} Chris Healy...|$|E
40|$|With feature-sizes below 0 � 25 µm, {{interconnect}} delays {{account for}} over 40 % of worst delays [12]. Transitions to 0 � 18 µm and 0 � 13 µm further increase this figure, {{and thus the}} relative importance of timing-driven placement for VLSI. Our work introduces a novel minimization of maximal path delay that improves upon previously known algorithms for timing-driven placement. Our placement algorithms have provable properties and are fast in practice. Our empirical validation is based on extending a scalable min-cut placer with proven empirical record in wirelength- and congestion-driven placement [4]. The overhead of timing-driven placement was within 50 % CPU time. We placed industrial circuits and evaluated the layouts with a commercial static <b>timing</b> <b>analyzer...</b>|$|E
40|$|Abstract – In {{this paper}} we discuss an {{approach}} to the design and construction of an accurate <b>timing</b> single channel <b>analyzer</b> (TSCA) for the timing of pulses over a wide dynamic range. A brief overview of the timing methods and uncertainty factors as "walk and jitter " and {{a detailed description of}} the TSCA circuit are given together with some insight into the application and reasons that led us to the design and construction of constructed TSCA. The advantages of this instrument are then highlighted and the experimental results are presented...|$|R
40|$|The tester’s {{features}} include a <b>timing</b> interval <b>analyzer</b> for {{statistical analysis of}} clock periods, synchronous generation of arbitrary waveforms with respect to master digital clocks, and a library of digital signal processing routines. These features have been applied to production measurements of key parameters like AGC loop bandwidth, phase-locked loop timing jitter, and ADC signal-to-noise ratio and distortion parameters. In recent years, there has been significant theoretical work on defining a methodology for fault detection and classification in analog circuits. 1 - 4 However, because input-output relationships are more complex for analog circuits than for digital circuits, {{the development of a}} systematic, automated approach for detecting defects in analog circuits is far behind the digital counterpart. For this reason, implementations of analog test strategies remain largely functional. 3 This is also the case in the work described here. The {{purpose of this paper is}} not to further the state of mixed-signal test theory and methodologies, but rather to share with the reader the state of mixed-signa...|$|R
40|$|Embedded/Cyber-physical systems, {{have become}} popular {{in a wide}} range of {{application}} scenarios. Such systems are called real-time systems if they underlie strict timing constraints. To verify if such systems can meet their deadlines, the knowledge of an upper bound for a program's execution time is mandatory. This upper bound is also called worst-case execution time (WCET) and is estimated by static <b>timing</b> <b>analyzers.</b> Established optimizing compilers are not aware of the WCET as objective since they focus on the minimization of the average-case execution time (ACET). To overcome this obstacle, this thesis presents memory-based optimization techniques which focus on the reduction of the WCET of programs. All presented optimizations are integrated into the WCET-aware C Compiler (WCC) framework. Since the memory interface of a system often turns out to be a bottleneck which limits the performance of a system, the presented optimizations are applied to different levels of the memory hierarchy of a system. Starting within a CPU core, the instruction fetch buffer is the most tightly coupled memory which tries to provide the next few instructions to be executed. Optimization techniques are presented improving the efficiency of this buffer w. r. t. the WCET of a system. Instruction caches placed between the CPU core and the main memory try to speed up accesses to the main memory by storing local copies in fast small cache memories. In order to improve the efficiency of this part of the memory hierarchy, a memory content selection approach is introduced which improves the WCET of a program by improving the cache performance. Due to the fact that multi-task systems are employed in almost all domains, this thesis presents elaborate extensions to a compiler supporting the compilation and WCET-aware optimization of multi-task systems. These extensions exploited to develop a number of novel optimizations for systems running multiple tasks. As first optimization, a WCET-driven software-based cache partitioning demonstrates the effectiveness of considering the WCET for the optimization of a set of tasks. Furthermore, many embedded systems integrate so-called scratchpad memories (SPM) as tightly coupled memories. An optimization approach for SPM allocation in a multi-task scenario is proposed. Besides, a holistic view of memory architecture compilation considers a number of memory-based WCET optimizations and presents approaches for a combined application. Existing compiler frameworks which are able to consider the WCET during optimization are limited to a particular hardware platform. In order to support multiple platforms, this thesis presents techniques to extend an existing WCET-aware compiler framework. Based on these extensions, a novel static cache locking optimization selects memory blocks which are statically locked into the instruction cache driven by WCET reductions. Applying these optimizations, the WCET of real-time applications can be reduced by about 35 % to 48 %. These results underline the need for specialized WCET-driven optimization techniques integrated into a sophisticated compiler framework. Otherwise, immense optimization potential would remain unused resulting in oversized and thus costly Embedded/Cyber-physical systems...|$|R
40|$|Failure of a safety-critical {{application}} on an {{embedded processor}} {{can lead to}} severe damage or even loss of life. Here we are concerned with two kinds of failure: stack overflow, which usually leads to run-time errors {{that are difficult to}} diagnose, and failure to meet deadlines, which is catastrophic for systems with hard real-time characteristics. Classical validation methods like code review and testing with repeated measurements require a lot of effort, are expensive, and do not really help in proving the absence of such errors. AbsInt’s tools StackAnalyzer and aiT (<b>timing</b> <b>analyzer)</b> provide a solution to this problem. They use abstract interpretation as a formal method that allows to obtain statements valid for all program runs with all inputs. ...|$|E
40|$|Application {{specific}} hardware implementations are {{an increasingly}} popular way of reducing execution time and power consumption in embedded systems. This application specific hardware typically consumes {{a small fraction}} of the execution time and power consumption that the equivalent software code would require. Modern electronic design automation (EDA) tools can be used to apply a variety of transformations to hardware blocks in an effort to achieve additional performance and power savings. A number of such transformations require a tool with knowledge of the designs' timing characteristics. This thesis describes a static <b>timing</b> <b>analyzer</b> and two timing analysis based design automation tools. The static <b>timing</b> <b>analyzer</b> estimates the worst-case timing characteristics of a hardware data flow graph. These hardware data flow graphs are intermediate representations generated within a C to VHDL hardware acceleration compiler. Two EDA tools were then developed which utilize static timing analysis. An automated pipelining tool was developed to increase the throughput of large blocks of combinational logic generated by the hardware acceleration compiler. Another tool was designed in an attempt to mitigate power consumption resulting from extraneous combinational switching. By inserting special signal buffers, known as delay elements, with preselected propagation delays, combinational functional units can be kept inactive until their inputs have stabilized. The hardware descriptions generated by both tools were synthesized, simulated, and power profiled using existing commercial EDA tools. The results show that pipelining leads to an average performance increase of 3. 3 x, while delay elements saved between 25 % and 33 % of the power consumption when tested on a set of signal and image processing benchmarks...|$|E
40|$|Uncertainty in circuit {{performance}} due to {{manufacturing and}} environmental variations is increasing {{with each new}} generation of technology. It is therefore important to predict {{the performance of a}} chip as a probabilistic quantity. This paper proposes three novel algorithms for statistical timing analysis and parametric yield prediction of digital integrated circuits. The methods have been implemented {{in the context of the}} - 42660 static <b>timing</b> <b>analyzer.</b> Numerical results are presented to study the strengths and weaknesses of these complementary approaches. Across-the-chip variability continues to be accommodated by 39516 's "Linear Combination of Delay (LCD) " mode. Timing analysis results in the face of statistical temperature and V dd variations are presented on an industrial ASIC part on which a bounded timing methodology leads to surprisingly wrong results...|$|E
40|$|Abstract-In this paper, {{we propose}} a new fast and {{practical}} technique to eliminate known false paths during the static timing analysis (STA). False paths are verified fast using additional information stored in arrival times, {{which is a}} pass-through history of exceptional nodes. The information can be constructed with small memory overhead hecause individual false path list is not managed in each arrival time. We adapted this method to classical arrival time computation and critical path searching algorithm The feature is w d in CubicTime, our full-chip gate level static <b>timing</b> <b>analyzer</b> supporting multiple clock domains. We describe the details of our algorithm and the experimental results compared to those of our previous method and a de-facto industry-standard STA tool. 1...|$|E
40|$|Predicting the {{worst-case}} execution time (WCET) of a real-time program isachallenging task. Though much {{progress has been}} made in obtaining tighter timing predictions by using techniques that model the architectural features of a machine, significant overestimations of WCET can still occur. Even with perfect architectural modeling, dependencies on data values can constrain the outcome of conditional branches and the corresponding set of paths that can be taken in a program. While value-dependent constraint information has been used in the past by some timing analyzers, it has typically been specified manually, which is both tedious and error prone. This paper describes efficient techniques for automatically detecting value-dependent constraints by a compiler and automatically exploiting these constraints within a <b>timing</b> <b>analyzer.</b> The result is tighter timing analysis predictions without requiring additional interaction with a user. 1...|$|E
40|$|As designs {{become more}} complex, {{advanced}} timing analysis capability requirements grow. Static timing analysis {{is a method}} of analyzing, debugging, and validating the timing performance of a design. The Quartus ® II software provides the features necessary to perform advanced timing analysis for today’s system-on-aprogrammable-chip (SOPC) designs. Synopsys PrimeTime is an industry standard sign-off tool, used to perform static timing analysis on most ASIC designs. The Quartus II software provides a path to enable you to run PrimeTime on your Quartus II software designs, and export a netlist, timing constraints, and libraries to the PrimeTime environment. This section explains {{the basic principles of}} static timing analysis, the advanced features supported by the Quartus II <b>Timing</b> <b>Analyzer,</b> and how you can use PrimeTime to analyze your Quartus II projects. This section includes the following chapters...|$|E
