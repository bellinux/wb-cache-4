8|834|Public
5000|$|This {{method of}} Dictionary-Based Machine {{translation}} exploresa different paradigm from {{systems such as}} LMT. An Example-Based machinetranslation system is supplied with only a [...] "sentence-aligned bilingual corpus".Using this data the <b>translating</b> <b>program</b> generates a [...] "word-for-word bilingualdictionary" [...] which is used for further translation.|$|E
40|$|We {{report in}} this paper on our {{experience}} {{in the design and}} implementation of a tool for migrating reFL ect code to OCaml. Migration proceeds by <b>translating</b> <b>program</b> parts to pure OCaml code, and binding the rest of the reFL ect program as OCaml primitives. Linking both reFL ect and OCaml runtime systems into a single executable allows running partially translated applications. 1...|$|E
40|$|We 2 ̆ 7 ve {{all heard}} the story, {{possibly}} apocryphal, about {{the computer program}} for language translation which renders 2 ̆ 2 The spirit is willing but the flesh is weak 2 ̆ 2 into Russian {{and then back to}} English as 2 ̆ 2 The whiskey is fine but the meat has gone bad. 2 ̆ 2 I wondered just how likely it was that such a humorous result would occur and, more importantly, just how useful is such a program for meaningful translation? Using the Lernout 2 ̆ 6 Hauspie Simply <b>Translating</b> <b>program</b> which translates English to French, German, Italian, Portuguese or Spanish and from those languages back to English, I picked six common aphorisms to test, converting each first to the foreign language and then back to English...|$|E
5000|$|Flowgorithm can interactively <b>translate</b> {{flowchart}} <b>programs</b> into {{source code}} written in other programming languages. As the user steps through their flowchart, the related code in the <b>translated</b> <b>program</b> is automatically highlighted. The following programming languages are supported: ...|$|R
40|$|In this paper, the {{application}} of a cycle accurate binary translator for rapid prototyping of SoCs will be presented. This translator gener-ates code to run on a rapid prototyping system consisting of a VLIW processor and FPGAs. The generated code is annotated with informa-tion that triggers cycle generation for the hardware in parallel to the execution of the <b>translated</b> <b>program.</b> The VLIW processor executes the <b>translated</b> <b>program</b> whereas the FPGAs contain the hardware for the parallel cycle generation and the bus interface that adapts the bus of the VLIW processor to the SoC bus of the emulated processor core. 1...|$|R
5000|$|... luit is invoked {{automatically}} by xterm {{when necessary}} to <b>translate</b> <b>program</b> output into UTF-8, for programs {{running on a}} local computer. When connecting remotely to another computer, the user must run luit directly.|$|R
40|$|Algorithm {{animation}} {{systems and}} graphical debuggers perform {{the task of}} <b>translating</b> <b>program</b> state into visual representations. While algorithm animations typically rely on user augmented source code to produce visualizations, debuggers make use of symbolic information in the target program. As a result, visualizations produced by debuggers often lack important semantic content, making them inferior to algorithm animation systems. This paper presents a method to provide higher-level, more informative visualizations in a debugger using a technique called traversal-based visualization. The debugger traverses a data structure using a set of user-supplied patterns to identify parts of the data structure to be drawn a similar way. A declarative language is used to specify the patterns and the actions to take when the patterns are encountered. Alternatively, the user can construct traversal specifications through a graphical user interface to the declarative language. Furthermore, the debugge [...] ...|$|E
40|$|High-performance dynamic {{language}} implementations make {{heavy use}} of speculative optimizations to achieve speeds close to statically compiled languages. These optimizations are typically {{performed by a}} just-in-time compiler that generates code under a set of assumptions {{about the state of}} the program and its environment. In certain cases, a program may execute code compiled under assumptions that are no longer valid. The implementation must then deoptimize the program on-the-fly; this entails finding semantically equivalent code that does not rely on invalid assumptions, <b>translating</b> <b>program</b> state to that expected by the target code, and transferring control. This paper looks at the interaction between optimization and deoptimization, and shows that reasoning about speculation is surprisingly easy when assumptions are made explicit in the program representation. This insight is demonstrated on a compiler intermediate representation, named, modeled after the high-level representation for a dynamic language. Traditional compiler optimizations such constant folding, dead code elimination, and function inlining are shown to be correct in the presence of assumptions. Furthermore, the paper establishes the correctness of compiler transformations specific to deoptimization: namely unrestricted deoptimization, predicate hoisting, and assume composition...|$|E
40|$|The {{need for}} <b>translating</b> <b>program</b> source-code between many {{different}} programming languages arises in some domains for which many such languages coexist. One such domain {{is that of}} space-mission planning, where a family of operations languages exists: different space operators use different languages to capture the operational knowledge to test and to control spacecrafts. Building a program translator from a single source to a target language already requires considerable time and effort because of the inherent complexity of every step in the process. If in addition, {{there is a big}} family of many such languages in some application domain, the cost and effort of creating program translators between any of them becomes prohibitive. In this thesis we address this translation problem by combining several techniques to generate a family of program translators: a product-line approach provides the support for a reusable translator framework; a grammar convergence reverse-engineering approach enables to extract common models from programming languages and programs, and a language-parametric grammarware approach provides the specific translation and transformation techniques. (FSA 3) [...] UCL, 201...|$|E
50|$|Because {{the object}} {{language}} of compilation has usually been machine language, the term object file {{has come to}} mean a file containing machine instructions, and sometimes the <b>translated</b> <b>program</b> itself is simply called an object.|$|R
40|$|We {{present the}} first fully {{automated}} compiler-runtime system that successfully translates and executes OpenMP shared-address-space programs on laboratory-size clusters, {{for the complete}} set of regular, repetitive applications in the NAS Parallel Benchmarks. We introduce a hybrid compiler-runtime translation scheme. Compared to previous work, this scheme features a new runtime data flow analysis and new compiler techniques for improving data affinity and reducing communication costs. We present and discuss the performance of our <b>translated</b> <b>programs,</b> and compare them {{with the performance of}} the MPI, HPF and UPC versions of the benchmarks. The results show that our <b>translated</b> <b>programs</b> achieve 75 % of the hand-coded MPI programs, on average...|$|R
40|$|Submitted {{on behalf}} of EDAA ([URL] audienceIn this paper, the {{application}} of a cycle accurate binary translator for rapid prototyping of SoCs will be presented. This translator generates code to run on a rapid prototyping system consisting of a VLIW processor and FPGAs. The generated code is annotated with information that triggers cycle generation for the hardware in parallel to the execution of the <b>translated</b> <b>program.</b> The VLIW processor executes the <b>translated</b> <b>program</b> whereas the FPGAs contain the hardware for the parallel cycle generation and the bus interface that adapts the bus of the VLIW processor to the SoC bus of the emulated processor core...|$|R
40|$|International audienceHigh-performance dynamic {{language}} implementations make {{heavy use}} of speculative optimizations to achieve speeds close to statically compiled languages. These optimizations are typically {{performed by a}} just-in-time compiler that generates code under a set of assumptions {{about the state of}} the program and its environment. In certain cases, a program may execute code compiled under assumptions that are no longer valid. The implementation must then deoptimize the program on-the-fly; this entails finding semantically equivalent code that does not rely on invalid assumptions, <b>translating</b> <b>program</b> state to that expected by the target code, and transferring control. This paper looks at the interaction between optimization and deoptimization, and shows that reasoning about speculation is surprisingly easy when assumptions are made explicit in the program representation. This insight is demonstrated on a compiler intermediate representation, named sourir, modeled after the high-level representation for a dynamic language. Traditional compiler optimizations such as constant folding, unreachable code elimination, and function inlining are shown to be correct in the presence of assumptions. Furthermore, the paper establishes the correctness of compiler transformations specific to deoptimization: namely unrestricted deoptimization, predicate hoisting, and assume composition...|$|E
40|$|Context. Variability-intensive {{programs}} (program families) {{appear in}} {{many application areas}} and for many reasons today. Different family members, called variants, are derived by switching statically configurable options (features) on and off, while reuse of the common code is maximized. Inquiry. Verification of program families is challenging since the number of variants is exponential {{in the number of}} features. Existing single-program analysis and verification tools cannot be applied directly to program families, and designing and implementing the corresponding variability-aware versions is tedious and laborious. Approach. In this work, we propose a range of variability-related transformations for <b>translating</b> <b>program</b> families into single programs by replacing compile-time variability with run-time variability (non-determinism). The obtained transformed programs can be subsequently analyzed using the conventional off- the-shelf single-program analysis tools such as type checkers, symbolic executors, model checkers, and static analyzers. Knowledge. Our variability-related transformations are outcome-preserving, which means that the relation between the outcomes in the transformed single program and the union of outcomes of all variants derived from the original program family is equality. Grounding. We show our transformation rules and their correctness with respect to a minimal core imperative language IMP. Then, we discuss our experience of implementing and using the transformations for efficient and effective analysis and verification of real-world C program families. Importance. We report some interesting variability-related bugs that we discovered using various state-of-the-art single-program C verification tools, such as Frama-C, Clang, LLBMC. Comment: The Art, Science, and Engineering of Programming, Vol. 1, Issue 1, Article...|$|E
50|$|<b>Translates</b> the <b>programming</b> {{language}} Python into JavaScript.|$|R
50|$|The current {{prevailing}} {{practice is}} for applications to place text in resource strings which are loaded during program execution as needed. These strings, stored in resource files, are {{relatively easy to}} <b>translate.</b> <b>Programs</b> are often built to reference resource libraries depending on the selected locale data.|$|R
40|$|Regular right part grammars {{extended}} by tree generator specifications are interpreted {{by a combined}} parser generator and tree generator that produces an ELL(2) parser. This parser is able to <b>translate</b> <b>programs</b> of the specified language into abstract syntax trees according to the tree specifications in the generator input...|$|R
40|$|We {{explore a}} {{transformational}} {{approach to the}} problem of verifying simple array-manipulating programs. Traditionally, verification of such programs requires intricate analysis machinery to reason with universally quantified statements about symbolic array segments, such as "every data item stored in the segment A[i] to A[j] is equal to the corresponding item stored in the segment B[i] to B[j]. " We define a simple abstract machine which allows for set-valued variables and we show how to <b>translate</b> <b>programs</b> with array operations to array-free code for this machine. For the purpose of <b>program</b> analysis, the <b>translated</b> <b>program</b> remains faithful to the semantics of array manipulation. Based on our implementation in LLVM, we evaluate the approach with respect to its ability to extract useful invariants and the cost in terms of code size...|$|R
40|$|A {{computer}} is a machine, built from digital-electronic components — the hardware — and the programs those components execute — the software. The computer system {{consists of the}} computing hardware and the system software that executes application programs. This software consists of an operating system, library software (called middleware) and compilers that <b>translate</b> <b>program...</b>|$|R
40|$|We {{present an}} {{inference}} system for <b>translating</b> <b>programs</b> in a PCF-like source language into {{a variant of}} Moggi's computational lambda calculus. This translation combines a simple strictness analysis with its associated optimising transformations into a single system. The correctness of the translation is established using a logical relation between the denotational semantics of the source and target languages...|$|R
40|$|Introduction to the Computer System A {{computer}} is a machine, built from digital-electronic components — the hardware — and the programs those components execute — the software. The computer system {{consists of the}} computing hardware and the system software that executes application programs. This software consists of an operating system, library software (called middleware) and compilers that <b>translate</b> <b>program...</b>|$|R
5000|$|The network began {{operations}} in September 2009 with 88 stations in Latin America, the Caribbean, the United States, Canada and Spain, including 18 stations in Argentina and 10 in Colombia. Whilst initially focussed on countries with Spanish-speaking populations, the network aims eventually to <b>translate</b> <b>programming</b> into French, English, Dutch and Arabic, to provide coverage for Africa.|$|R
40|$|The {{design of}} {{fault-tolerant}} distributed systems is a costly and diflicult task. Its cost and difficulty increase dramatically with {{the severity of}} failures that a system must tolerate. We seek to simplify this task by developing methods to automatically translate protocols tolerant of “benign ” failures to ones tolerant of more “severe” failures. This paper describes two new translation mechanisms for qr~hronous systems; one <b>translates</b> <b>programs</b> tolerant of crash failures into programs tolerant of general omission failures, and the other translates from gene& omiesion failures to arbitrary failures. Together these {{can be used to}} <b>translate</b> any <b>program</b> tolerant of the most benign failures to a program tolerant of the most severe. ...|$|R
40|$|This project {{involves}} {{writing a}} translator that will convert a program {{written in a}} BASIC-like language into an intermediate code form. The <b>translated</b> <b>programs</b> are to be run on an SDR 2. Programs will be developed on a micro-computer (probably an IBM PC or a compatible), and the intermediate code produced will be loaded into the SDR 2 {{where it will be}} interpreted...|$|R
5000|$|In 1958, the Back to God Hour began {{broadcasting}} in the Middle East, with Rev. Bassam Madany as Arabic minister. The Back to God Hour {{expanded in}} 1959 to Australia and New Zealand. In 1961, Rev. Juan Boonstra began <b>translating</b> <b>programming</b> into Spanish, and in 1965 {{he moved to}} Chicago to record programs for Latin American audiences as the Spanish language minister, ...|$|R
50|$|Mocha is a Java decompiler, {{which allows}} programmers to <b>translate</b> a <b>program's</b> {{bytecode}} into source code.|$|R
40|$|Introduction to the Computer Systems A {{computer}} system consists of computing hardware, system {{software and application}} programs. A CPU, main memory {{and a set of}} I/O devices (e. g., disk, network and GPU) make up the hardware. The system software includes an operating system, library software (sometimes called middleware) and compilers that <b>translate</b> <b>programs</b> from highlevel languages to machine instructions that are executed by the CPU...|$|R
40|$|In {{this paper}} {{we present a}} {{compiler}} that <b>translates</b> <b>programs</b> from an imperative higher-order language into a sequence of instructions for an abstract machine. We consider {{an extension of the}} Krivine machine for the call-by-name lambda calculus, which includes strict operators and imperative features. We show that the compiler is correct with respect to the big-step semantics of our language, both for convergent and divergent programs...|$|R
40|$|The {{purpose of}} this paper is to define a {{mathematical}} model for the study of quantitative problems about translations between universal languages and to investigate such problems. The results derived in this paper deal with the efficiency of the translated algorithms, the optimality of translations and the complexity of the translation process between different languages. Keywords: universal languages, Goedel numberings, translations, complexity of translations, optimality, length of <b>translated</b> <b>programs...</b>|$|R
5000|$|Java {{has many}} {{similarities}} with ScriptX. Like ScriptX, {{it is an}} object based language with elements of syntax {{that are similar to}} C and C++. Java classes support a limited form of multiple inheritance through interfaces, and the Java runtime environment utilizes a garbage collector for memory management with a [...] "tracing" [...] architecture similar to that of ScriptX. Both Java and ScriptX <b>translate</b> <b>programs</b> into a platform-independent bytecode.|$|R
40|$|This paper {{shows the}} {{advantages}} of amalgamating functional and logic programming languages. In comparison with pure functional languages, an amalgamated functional logic language has more expressive power. In comparison with pure logic languages, functional logic languages have a better control behaviour. The latter will be shown by presenting methods to <b>translate</b> logic <b>programs</b> into a functional logic language with a narrowing/rewriting semantics. The translated programsproduce {{the same set of}} answers and have at least the same efficiency as the original programs. But in many cases the control behaviour of the <b>translated</b> <b>programs</b> is improved. This requires the addition of further knowledge to the programs. We discuss methods for this and show the gain in efficiency by means of several examples...|$|R
40|$|Abstract. We employ automata over {{infinite}} alphabets {{to capture}} the semantics of a finitary fragment of ML with ground-type references. Our approach is founded on game semantics, which allows us to <b>translate</b> <b>programs</b> into automata {{in such a way}} that contextual equivalence is characterized by a finitary notion of bisimilarity. As a corollary, we derive a decidability result for a class of first-order programs, including open ones that contain unspecified first-order procedures. ...|$|R
5|$|In {{the late}} 1950s, {{computer}} users and manufacturers were becoming {{concerned about the}} rising cost of programming. A 1959 survey had found that in any data processing installation, the programming cost US$800,000 on average and that <b>translating</b> <b>programs</b> to run on new hardware would cost $600,000. At a time when new programming languages were proliferating at an ever-increasing rate, the same survey suggested that if a common business-oriented language were used, conversion would be far cheaper and faster.|$|R
40|$|A {{refinement}} calculus {{provides a}} method for transforming specifications to executable code, maintaining the correctness of the code with respect to its specification. In this paper we investigate the use of Mercury as the target implementation language for a refinement calculus for logic programs. We describe a prototype tool for <b>translating</b> <b>programs</b> in our specification language to Mercury code. More generally, we investigate the advantages that Mercury has over standard Prolog, with respect to developing correct programs from specifications...|$|R
50|$|At Bell Labs, Aho {{worked closely}} with Steve Johnson and Jeffrey Ullman to develop {{efficient}} algorithms for analyzing and <b>translating</b> <b>programming</b> languages. Steve Johnson used the bottom-up LALR parsing algorithms to create the syntax-analyzer generator yacc, and Michael E. Lesk and Eric Schmidt used Aho's regular-expression pattern-matching algorithms to create the lexical-analyzer generator lex. The lex and yacc tools and their derivatives {{have been used to}} develop the front ends of many of today's programming language compilers.|$|R
40|$|AbstractStable {{generated}} {{models for}} extended generalized logic programs with {{two kinds of}} negation provide a semantics for logic programming in its (up to now) most general form. We show that stable generated semantics for extended logic programs coincides with the semantics obtained by <b>translating</b> <b>programs</b> into a minimal partial temporal logic. Then we introduce several new versions of (disjunctive) default logic and show that there are strong (semantical) connections between default logic and logic programming with stable generated models...|$|R
