215|311|Public
25|$|LMDB {{may also}} be used {{concurrently}} in a multi-threaded or multi-processing environment, with read performance scaling linearly by design. LMDB databases may have only one writer at a time, however unlike many similar key-value databases, write transactions do not block readers, nor do readers block writers. LMDB is also unusual in that multiple applications on the same system may simultaneously open and use the same LMDB store, {{as a means to}} scale up performance. Also, LMDB does not require a <b>transaction</b> <b>log</b> (thereby increasing write performance by not needing to write data twice) because it maintains data integrity inherently by design.|$|E
2500|$|Microsoft SQL Server {{also allows}} {{user-defined}} composite types (UDTs) {{to be defined}} and used. It also makes server statistics available as virtual tables and views (called Dynamic Management Views or DMVs). In addition to tables, a database can also contain other objects including views, stored procedures, indexes and constraints, along with a <b>transaction</b> <b>log.</b> A SQL Server database can contain a maximum of 231 objects, and can span multiple OS-level files with a maximum file size of 260 bytes (1 exabyte). The data in the database are stored in primary data files with an extension [...]mdf. Secondary data files, identified with a [...]ndf extension, are used to allow the data of a single database to be spread across more than one file, and optionally across more than one file system. Log files are identified with the [...]ldf extension.|$|E
2500|$|The Greek {{wiretapping}} case of 2004-05, {{also referred}} to as Greek Watergate, involved the illegal telephone tapping of more than 100mobile phones on the Vodafone Greece network belonging mostly to members of the Greek government and top-ranking civil servants. The taps began sometime near the beginning of August 2004 and were removed in March 2005 without discovering the identity of the perpetrators. The intruders installed a rootkit targeting Ericsson's AXE telephone exchange. According to IEEE Spectrum, this was [...] "the first time a rootkit has been observed on a special-purpose system, in this case an Ericsson telephone switch." [...] The rootkit was designed to patch the memory of the exchange while it was running, enable wiretapping while disabling audit logs, patch the commands that list active processes and active data blocks, and modify the data block checksum verification command. A [...] "backdoor" [...] allowed an operator with sysadmin status to deactivate the exchange's <b>transaction</b> <b>log,</b> alarms and access commands related to the surveillance capability. The rootkit was discovered after the intruders installed a faulty update, which caused SMS texts to be undelivered, leading to an automated failure report being generated. Ericsson engineers were called in to investigate the fault and discovered the hidden data blocks containing the list of phone numbers being monitored, along with the rootkit and illicit monitoring software.|$|E
5000|$|<b>Transaction</b> <b>logs</b> {{are based}} on what how {{transducers}} convert phenomena into measurable signals. The basic model requires transducers to convert current or voltage into a signal. Additional systems may require resistive networks to produce a signal. When analyzing the function of <b>transaction</b> <b>logs</b> it's {{important to understand that}} signals can be measured in different methods. A complex understanding of <b>transaction</b> <b>logs</b> requires considering the given signal and its attributes. <b>Transaction</b> <b>logs</b> {{are based on}} two types of signals: digital and analog.|$|R
5000|$|Translation between {{physical}} storage formats that are {{recorded in the}} <b>transaction</b> <b>logs</b> and the logical formats typically expected by database users (e.g., some <b>transaction</b> <b>logs</b> save only minimal buffer differences that are not directly useful for change consumers).|$|R
50|$|The {{design is}} heavily {{influenced}} by <b>transaction</b> <b>logs.</b>|$|R
5000|$|... writing <b>transaction</b> <b>log</b> {{records from}} the in-memory log buffer to the <b>transaction</b> <b>log</b> files on disk ...|$|E
5000|$|On {{a heavily}} used database, the <b>transaction</b> <b>log</b> grows rapidly. <b>Transaction</b> <b>log</b> entries {{must be removed}} from the log to make room for future entries. Frequent <b>transaction</b> <b>log</b> backups are smaller, so they {{interrupt}} database activity for shorter periods of time.|$|E
50|$|All {{national}} registries {{are connected}} {{directly to the}} UNFCCC’s International <b>Transaction</b> <b>Log</b> (ITL). This <b>transaction</b> <b>log</b> is responsible for checking all transactions to ensure they adhere {{to the rules of}} international emissions trading under the Kyoto Protocol. The ITL also has a link to the EC’s Community Independent <b>Transaction</b> <b>Log</b> (CITL). This <b>transaction</b> <b>log</b> is responsible for checking all transactions to ensure that they adhere to the rules of the EU ETS.|$|E
5000|$|Other {{challenges}} in using <b>transaction</b> <b>logs</b> for change data capture include: ...|$|R
5000|$|Enable <b>transaction</b> <b>logging</b> {{and time}} {{stamping}} for tracking of transactions and centralized control ...|$|R
50|$|A major {{drawback}} with in-memory databases is that {{main memory}} is volatile and does therefore not ensure durability. The solution to this, which Starcounter utilizes, {{is to write}} <b>transaction</b> <b>logs</b> to a disk the same way it's done in traditional SQL databases. If data needs to be recovered, it's possible {{to do so by}} going back in the <b>transaction</b> <b>logs.</b>|$|R
50|$|A <b>transaction</b> <b>log</b> file records all {{transactions}} {{since the}} last checkpoint. <b>Transaction</b> <b>log</b> files may be preserved and archived for an indefinite time, providing a full, recoverable history of the database.|$|E
50|$|Most {{database}} management systems manage a <b>transaction</b> <b>log</b> that records changes {{made to the}} database contents and to metadata. By scanning and interpreting {{the contents of the}} database <b>transaction</b> <b>log</b> one can capture the changes made to the database in a non-intrusive manner.|$|E
5000|$|Reading the <b>transaction</b> <b>log</b> as, or shortly after, it is written.|$|E
25|$|<b>Transaction</b> <b>Logging</b> {{provides}} a slightly less failure protection than transaction durability, but improves overall performance.|$|R
5000|$|Dealing {{with changes}} to {{the format of the}} <b>transaction</b> <b>logs</b> between {{versions}} of the database management system.|$|R
50|$|Manual or {{automated}} system or application <b>transaction</b> <b>logs</b> should be maintained, which record all processed system commands or application transactions.|$|R
5000|$|CDC {{solutions}} {{based on}} <b>transaction</b> <b>log</b> files have distinct advantages that include: ...|$|E
5000|$|Eliminating {{uncommitted}} {{changes that}} the database {{wrote to the}} <b>transaction</b> <b>log</b> and later rolled back.|$|E
50|$|The {{rollback}} {{feature is}} usually implemented with a <b>transaction</b> <b>log,</b> {{but can also}} be implemented via multiversion concurrency control.|$|E
5000|$|<b>Transaction</b> <b>logging,</b> which records {{changes to}} the {{database}} in a journal file and facilitates automatic recovery of an in-memory database.|$|R
50|$|The product {{implements}} a fully ACID-compliant <b>transaction</b> <b>logging</b> {{system with}} automatic recovery capability. This facility {{is also used}} for asynchronous replication.|$|R
40|$|This report {{describes}} an implementation of <b>Transaction</b> <b>Logging</b> and Recovery using Unix Copy-On-Write on spawned processes. The {{purpose of the}} work is to extend WS-Iris, a research project on Object Oriented Main Memory Databases, with functionality for failure recovery. The presented work is a Master Thesis for a student of Master of Science in Computer Science and Technology. The work has been commissioned by Tore Risch, Professor of Engineering Databases at Computer Aided Engineering laboratory (CAElab), Linköping University (LiU/LiTH), Sweden. Keywords <b>Transaction</b> <b>logging,</b> logical logging, recovery, main memory database, copyon -write, process forking Jonas S Karlsson CAElab, IDA, Linköping University <b>Transaction</b> <b>Logging</b> and Recovery for a Main Memory OODB 3 CHAPTER 1 Introduction 5 1. 1 WS-Iris 5 1. 2 Reason & Goal 5 1. 3 Contents 6 CHAPTER 2 WS-Iris 7 2. 1 Internal Workings 7 2. 1. 1 The self-contained Lisp 8 2. 1. 2 Foreign functions 8 2. 2 Image 8 2. 3 Logging (Histories) 8 CH [...] ...|$|R
50|$|A <b>transaction</b> <b>log</b> is a file (i.e., log) of the {{communications}} (i.e., transactions) between a {{system and the}} users of that system, or a data collection method that automatically captures the type, content, or time of transactions made by a person from a terminal with that system. For Web searching, a <b>transaction</b> <b>log</b> is an electronic record of interactions that have occurred during a searching episode between a Web search engine and users searching for information on that Web search engine.|$|E
50|$|All TimesTen data {{exists in}} RAM, however TimesTen does utilize {{non-volatile}} storage (such as a hard disk) for database persistence and recoverability. A TimesTen database stores all transactional data modifications in an in-memory log buffer, which is eventually persisted to disk {{in the form}} of <b>transaction</b> <b>log</b> files. In addition, TimesTen also persists snapshots of the in-memory database, called checkpoint files, to disk. The combination of checkpoint files and <b>transaction</b> <b>log</b> files allow TimesTen to provide recoverability {{in the event of a}} system failure. TimesTen implements a parallel log manager in order to maximize throughput on large SMP systems.|$|E
50|$|On 6 August 2010, a major {{vulnerability}} in the bitcoin {{protocol was}} spotted. Transactions weren't properly verified {{before they were}} included in the <b>transaction</b> <b>log</b> or blockchain, which let users bypass bitcoin's economic restrictions and create an indefinite number of bitcoins. On 15 August, the vulnerability was exploited; over 184 billion bitcoins were generated in a transaction, and sent to two addresses on the network. Within hours, the transaction was spotted and erased from the <b>transaction</b> <b>log</b> after the bug was fixed and the network forked to an updated version of the bitcoin protocol. This was the only major security flaw found and exploited in bitcoin's history.|$|E
5000|$|Coordinating {{the reading}} of the <b>transaction</b> <b>logs</b> and the {{archiving}} of log files (database management software typically archives log files off-line on a regular basis).|$|R
5000|$|New data {{is written}} without {{overwriting}} or moving existing data. This results in guaranteed data integrity and reliability without requiring <b>transaction</b> <b>logs</b> or cleanup services.|$|R
40|$|The authors {{introduce}} {{a method for}} visualizing user <b>transaction</b> <b>logs</b> from a library catalog application. Simple visualization supporting intuitive or qualitative analysis to quickly make sense of complicated patterns can be a useful supplement or alternative to more common quantitative analysis. To this end, a visual flowchart is created illustrating an individual user session. This visualization {{can be used to}} qualitatively grasp user behavior within the application, possibly as an aid to identifying patterns or clusters of use. These flowcharts are created by automatically pre-processing apache <b>transaction</b> <b>logs</b> into an XML representation of meaningful user actions, which are then converted via JavaScript in a web browser to HTML table based flowcharts. The particular toolkit introduced is named Visualization for Understanding <b>Transaction</b> <b>Logs</b> (VUTL), and is available with an open source license. The toolkit has been prototyped with logs from the catalog applications of several academic and one public library...|$|R
50|$|Many DBMSs {{implement}} durability {{by writing}} transactions into a <b>transaction</b> <b>log</b> {{that can be}} reprocessed to recreate the system state right before any later failure. A transaction is deemed committed only after it is entered in the log.|$|E
50|$|TimesTen {{provides}} an event notification mechanism through the <b>transaction</b> <b>log</b> API (XLA). XLA provides functions which allow applications {{to be notified}} of data changes occurring in TimesTen tables (and also DDL occurring in the TimesTen database). XLA {{can also be used}} in conjunction with materialized views to simplify the process of monitoring changes made to rows spanning multiple tables. XLA works by mining the TimesTen <b>transaction</b> <b>log</b> stream in a similar manner to the replication agent.Database application deployments that do not include an Oracle database which want to use TimesTen as an in-memory cache database can use XLA to capture updates and, via custom application code, apply these updates to their backend database.|$|E
50|$|A {{record of}} the changes must still be {{preserved}} at commit time {{to ensure that the}} transaction is durable. This record is typically written to a sequential <b>transaction</b> <b>log,</b> with the actual changes to the database objects being changes which can be written at a later time.|$|E
50|$|SecureLog is used {{to secure}} {{different}} types of data logs like access logs, email archives or <b>transaction</b> <b>logs</b> and is primarily in use where compliance might be an issue.|$|R
50|$|The {{partitioning}} {{can be done}} {{by either}} building separate smaller databases (each with its own tables, indices, and <b>transaction</b> <b>logs),</b> or by splitting selected elements, for example just one table.|$|R
5000|$|A {{directed}} delta, {{also called}} a change, is {{a sequence of}} (elementary) change operations which, when applied to one version , yields another version [...] (note the correspondence to <b>transaction</b> <b>logs</b> in databases).|$|R
