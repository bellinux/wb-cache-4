10|274|Public
5000|$|... Embedded Trace Module (ETM), 40 bits (7 bit address, one 32-bit long data word, and a R/W bit) used {{to control}} the {{operation}} of a passive instruction and data <b>trace</b> <b>mechanism.</b> This feeds either an on-chip Embedded Trace Buffer (ETB), or an external high speed trace data collection pod. Tracing supports passive debugging (examining execution history) and profiling for performance tuning.|$|E
40|$|Risk {{management}} {{is an important}} process for public service organizations to maintain a high quality of service. However, many organizations are {{not satisfied with the}} result from risk handling. This paper proposes changes to a risk management model by integrating service level agreements into it. This makes responsibilities more clear to all parties involved in risk management. This paper also introduces a method to represent relations between risks and services and between services and activities. This method improves forward and backward traceability. It helps to assess the result of risk management by assessing the fulfillment of services. An example is given to illustrate the use of this model and the benefits from the <b>trace</b> <b>mechanism...</b>|$|E
40|$|Traditional Real-Time Operating Systems (RTOS) are not {{designed}} to accommodate application specific requirements. They address a general case and the application must co-exist with any limitations imposed by such design. For modern real-time applications this limits the quality of services offered to the end-user. Research in this field has shown {{that it is possible}} to develop dynamic systems where adaptation is the key for success. However, adaptation requires full knowledge of the system state. To overcome this we propose a framework to gather data, and interact with the operating system, extending the traditional POSIX trace model with a partial reflective model. Such combination still preserves the <b>trace</b> <b>mechanism</b> semantics while creating a powerful platform to develop new dynamic systems, with little impact in the system and avoiding complex changes in the kernel source code...|$|E
40|$|Today's most used {{electronic}} payment systems o®er no anonymity {{at all to}} their users. Electronic payment systems exist that provide unconditional anonymity. In this article {{electronic payment}} systems are described in which anonymity can be controlled. The requirements of such systems are discussed, and two types of <b>tracing</b> <b>mechanisms</b> are de¯ned. An overview of the proposed anonymity controlled systems is given. We analyze to what extent these systems o®er the de¯ned <b>tracing</b> <b>mechanisms.</b> The importance of anonymous communication is stressed...|$|R
40|$|We {{present a}} new {{anonymous}} on-line payment system that offers powerful <b>tracing</b> <b>mechanisms</b> {{in the case}} of suspected criminal misuse and does not require any trusted third party. Our approach not only reduces the infrastructure requirements, but also eliminates the risk that <b>tracing</b> <b>mechanisms</b> are misused by trusted third parties. We provide an extended audit concept that ensures detection of any illegal application of tracing. While our payment system is very efficient, we have strong guarantees for the user's privacy, as untraced coins remain unconditionally anonymous...|$|R
30|$|Finally, instrumenting TI’s SYS/BIOS micro-kernel is a {{step towards}} {{spreading}} <b>tracing</b> <b>mechanisms</b> to various platforms, {{as it can be}} used on a broad variety of TI’s products.|$|R
40|$|This paper {{provides}} {{a brief overview}} of techniques and tools being developed for monitoring and predicting the performance of Unix server congurations for given real-life workloads. We show how our system call <b>trace</b> <b>mechanism,</b> called Ultra, captures a complete trace of a process's calls to the operating system with only minimal interference to the system under study. Once captured, the traces can be used to reproduce the captured workload's behaviour in full. Rerunning such multi-process workloads from their traces is complicated because the inter-dependencies between the activities of the individual constituent processes must be reproduced correctly if the overall behaviour of the workload is to be reproduced successfully. We show how our approach can be extended to meet this requirement, and allow multi-process workloads to be traced and rerun. To illustrate the usefulness of our tools, we present a case study in which our traces are used to predict the impact of le s [...] ...|$|E
40|$|This paper {{shows how}} system call traces can be {{obtained}} with minimal interference to the system being characterized, and used as realistic, repeatable workloads for experiments to evaluate operating system and file system designs and configuration alternatives. Our system call <b>trace</b> <b>mechanism,</b> called Ultra, captures a complete trace of each Unix process's calls to the operating system. The performance impact is normally small, and it runs in user mode without special privileges. We show how the resulting traces {{can be used to}} drive full, repeatable reexecution of the captured behaviour, and present a case study which shows the usefulness and accuracy of the tool for predicting the impact of file system caching on a WWW server's performance. 1 INTRODUCTION Our aim in this work is to develop a tool for a system performance consultant to use to characterize a customer's workload. The consultant would install the trace capture tool on the customer's Unix server, enable tracing, and wou [...] ...|$|E
40|$|Relative recency {{discrimination}} task {{is typically}} {{used to assess}} the temporal organization function of the prefrontal cortex (PFC). Subjects look at a series of cards (with words or drawings on them) and on seeing a test card determine which of the two items was seen more recently. Results show that patients with damage to the prefrontal cortex are severely impaired on this task. We propose a memory trace-priming mechanism, based on automatic time-marking process hypothesis (Schacter, 1987), to offer a computational account of the results. In this model, successive words seen by subjects leave decaying memory traces in PFC, which subsequently prime the representations in higher sensory areas such as inferior temporal Cortex (IT) during discrimination judgements. The paper focuses on the evaluation of a probabilistic pre-frontal <b>trace</b> <b>mechanism</b> using a pool of clusters of neurons with self-sustained firing that ends at a random time. The results show that the probabilistic behavior of s [...] ...|$|E
30|$|A novel design named DTrace that {{incorporates}} hardware instruction <b>tracing</b> <b>mechanism</b> into data integrity protection which realizes hardware data tracing and provides fine-grained and efficient data integrity guarantee.|$|R
30|$|Third, {{the data}} access tracing is {{implemented}} by Intel instruction <b>tracing</b> <b>mechanism,</b> which {{is controlled by}} some model specific registers (MSRs) and can only be manipulated in kernel mode. Even though the user-mode application {{is controlled by the}} attacker, she is not able to disable the Intel processor <b>tracing</b> <b>mechanism</b> by updating the MSRs. We also assume that the Intel PT management code is loaded and executed properly by the loading process of kernel, which ensures that the hardware tracing feature is enabled properly before the process execution.|$|R
40|$|We {{present an}} {{electronic}} payment system offering {{a new kind of}} <b>tracing</b> <b>mechanism.</b> This mechanism is optimistic fair, as any misuse of the <b>tracing</b> <b>mechanism</b> is prevented by using an audit concept so that a violation of privacy can be detected and will be prosecuted. Thus, compared to previously proposed tracing methods our optimistic fair tracing approach offers more privacy for customers and does not need any trusted third parties, which simplifies the infrastructure of the payment system. Our payment system is able to defend against blackmailing, kidnapping, and bank robberies and {{can also be used to}} support investigations of money laundering and illegal purchases...|$|R
40|$|Bus signal tracing {{represents}} {{that the}} information which are generated from the system can be collected for later observation, debugging and analysis. Because the SoC design {{becomes more and more}} complex, an advanced system <b>trace</b> <b>mechanism</b> is needed instead of processor-based trace only. However, the generation rate and the size of real time system traces are so huge such that a mechanism for system tracing that can reduce trace size efficiently is needed. In this paper, we purpose an on-chip bus signals tracer for SoC’s. This bus tracer can perform a cycle-accurate or successive trace collection in an unlimited time and can be used in various embedded system without influencing the operation of the bus system. The trace compression approaches consists of two stages: (1) signal/timing abstraction stage and (2) trace reduction stage. Also this tracer is implemented in a SIP (Soft Intellectual Property) style. It provides four parameters for tracing configuration. The tracer has integrated into ARM EASY system (AMBA platform) and the experimental results show that this bus tracer can reach a good compression ratio of 96 %...|$|E
40|$|This paper {{shows how}} system call traces can be {{obtained}} with minimal interference to the system being characterised, and used as realistic, repeatable workloads for experiments to evaluate operating system and le system designs and conguration alternatives. Our system call <b>trace</b> <b>mechanism,</b> called Ultra, captures a complete trace of each Unix process's calls to the operating system. The performance impact is normally small, and it runs in user mode without special privileges. Traces can be rerun in two ways: the operating system activity can be reproduced by simply replaying the system calls interspersed with appropriate delays. More interestingly, we also show how the resulting traces {{can be used to}} drive full, repeatable reexecution of the captured behaviour. The paper concludes with an evaluation and comparison of the usefulness and accuracy of these techniques for predicting the performance impact of system conguration altenatives. We present two case studies, examining the eect of le system caching on a Www server's performance, and the performance benet of using a local disk instead of an NFS leserver. ...|$|E
40|$|The {{research}} that we present here {{are related to}} a study for the design and implementation of a follow-up survey of students via an interactive voice response (IVR) using VoiceXML, a W 3 C standard language. We present a corpus of questions and answers obtained in natural language, and we validate scientific hypotheses concerning the use of modes of interaction (voice versus direct manipulation). Then, we explain how we passed from a mechanism of exogenous traces (with a monitoring system performed by external tools recordings) to an endogenous mechanism (with a monitoring system made from within the IVR) to provide tools and instruments more adapted to the evaluation of multimodal applications that use speech and gesture (telephone keypad or mouse click on hyperlink). The <b>trace</b> <b>mechanism</b> for telephone interactions using VoiceXML presented here increases {{the quality of the}} evaluation of human-machine telephone interactions, because these traces are automatically recorded and reusable. Furthermore, we show {{that it is possible to}} get instant statistics (histograms and graphs made in real time, in PHP) using the method presented here. Thus, we have shown that pedagogical surveys, which traditionally are laborious, complex to implement and very time consuming can be facilitated through the methods and tools we recommend...|$|E
40|$|Understanding {{the causes}} {{underlying}} diseases affecting brain function, mental disabilities and other disorders {{is a very}} difficult task that necessitates to deeply <b>trace</b> <b>mechanisms</b> at the basis of the human brain machine, a complex circuitry that requires a network of gene products to orchestrate its self-assembly and functions, mutations of these genes often resulting in neurological and psychiatric diseases. ...|$|R
40|$|Tuning of {{parallel}} applications requires {{the use of}} effective tools for detecting performance bottlenecks. Many of the current program analysis tools provide only statistical summaries. This may hide individual situations of performance loss that occur along a parallel program execution. We believe that exhaustive and time [...] aware event collection at fine [...] grain level is essential to capture this kind of situations. This paper presents a <b>tracing</b> <b>mechanism</b> based on code interposition and a low [...] overhead tracing library implementation for the usual compiler [...] directed code injection. It also compares both of them and evaluates the overhead introduced in the execution of the application, distinguishing by the one introduced by the tracing tools and the one introduced by system mechanisms needed for some specific performance analysis (i. e. hardware counters). Both <b>tracing</b> <b>mechanisms</b> are used to collect detailed traces that feed an analysis and visualization tool (Paraver). The whole environ [...] ...|$|R
40|$|During {{the system}} development, {{developers}} often must correct wrong {{behavior in the}} software—an activity colloquially called program debugging. Debugging is a complex activity, especially in real-time embedded systems because such systems interact with the physical world and make heavy use of interrupts for timing and driving I/O devices. Debugging interrupts is difficult, because they cause non-linear control flow in programs which is hard to reproduce in software. Record/replay mechanisms have proven their use to debugging embedded systems, because they provide means to recreate control flows offline {{where they can be}} debugged. In this work, we present the data tracing part of the record/replay mechanism that is specifically targeted to record interrupt behavior. To tune our <b>tracing</b> <b>mechanism,</b> we use the observed principle of return address clustering and a formal model for quantitative reasoning about the <b>tracing</b> <b>mechanism.</b> The presented heuristic and mechanisms show surprisingly good results—up to an 800 percent speedup on the selector function and a 300 percent reduction on duplicates for non-optimal selector functions—considering the leanness of the approach...|$|R
40|$|Neurons in {{the primary}} visual cortex (V 1) of {{primates}} are selective for location, orientation, and spatial frequency. Among them, complex cells are characterized by their selectivity to orientation and spatial frequency while lacking sensitivity to position or phase tuning (dark/bright line center) within a restricted range. The development of the shift invariance property of complex cells has been successfully explained by the temporal trace learning which {{takes advantage of the}} temporal coherence of visual stimuli (P. Földiák, Neural Computation 1991; 3 : 194). We have carried out mathematical modeling of complex cell development without temporal <b>trace</b> <b>mechanism.</b> The model network consists of three layers of E, S, and C layer which model excitatory cells in LGN or V 1, and simple cells, and complex cells in V 1, respectively. Neurons in layer E have position selectivity, and neurons in layer S are line detectors for a specific position. During the learning phase, the network is exposed to randomly located short oriented bars, and neurons in layer C self-organize its selectivity to the inputs. The learning rules are Hebbian or SOM (self-organizing map) type between layers S and C, and anti-Hebbian between layers E and C by which neurons are forced to represent uncorrelated aspect of the inputs. We demonstrate that neurons in layer C learn invariance to shift in input position. Our model explains complex cell development i...|$|E
40|$|Standard <b>tracing</b> <b>mechanisms</b> {{were usually}} {{developed}} {{for use in}} a single-computer environment. Moreover, they are bound to a specific programming language. Today's highly distributed and heterogeneous computing environments require new tracing methodologies. In this paper, the author collects the requirements that a tracing architecture is supposed to fulfill, and investigates how such a tracing architecture may be implemented in a distributed, heterogeneous and object-oriented environment. As a practical contribution, a system for tracing CORBA applications is presented, based on the interceptor mechanism...|$|R
40|$|Abstract— As {{the time}} passes the {{software}} complexity isincreasing {{and due to}} this software reliability and quality will beaffected. And for measuring the software reliability and qualityvarious defect measurement and defect <b>tracing</b> <b>mechanism</b> willbe used. Software defect prevention work typically focuses onindividual inspection and testing technique. ODC is a mechanismby which we exploit software defect that occur during thesoftware development life cycle. Orthogonal defect classificationis a concept which enables developers, quality managers andproject managers {{to evaluate the effectiveness}} and correctness ofthe softwar...|$|R
40|$|The {{number of}} {{computer}} break-ins {{from the outside}} of an [...] . In this paper, we improve the <b>tracing</b> <b>mechanism</b> {{so that it can}} trace back stepping stones attack in the Internet. In our method, the information about tracing stepping stone is collected from hosts in a LAN effectively, and the information is made available at the public information server. A pursuer of stepping stone attack can trace back the intrusion based on the information available at the public information server on an intrusion route...|$|R
40|$|Abstract. We {{present the}} first Traitor Tracing scheme with {{efficient}} black-box traitor tracing {{in which the}} ratio of the ciphertext and plaintext lengths (the transmission rate) is asymptotically 1, which is optimal. Previous constructions in this setting either obtained constant (but not optimal) transmission rate [KY 02 b], or did not support black-box tracing [CPP 05]. As additional contributions, we point out and resolve an issue in the black-box traitor <b>tracing</b> <b>mechanism</b> in the scheme of [KY 02 b]; and we show that the scheme of [CPP 05], which extends [KY 02 b] and inherits its <b>tracing</b> <b>mechanism,</b> in fact does not provide black-box tracing nor (local) public traceability. In particular, whereas fixing the scheme of [KY 02 b] requires just a simple, local change to the tracing algorithm, repairing the black-box functionality and the public traceability features of [CPP 05] voids the claimed optimality of the transmission rate, and results in a new scheme with essentially the same parameters as in [KY 02 b]. Our construction is based on the Decisional Bilinear Diffie-Hellman (DBDH) assumption, and attains the same features of public traceability as (a repaired variant of) [CPP 05], which is less efficient and requires non-standard assumptions for bilinear groups...|$|R
30|$|To help users achieve higher {{efficiency}} and more secure data sharing in mobile PHR system, {{based on previous}} works, we study the traitor <b>tracing</b> <b>mechanism</b> in attribute based cryptosystem and propose a high efficient attribute based encryption with user accountability in mobile PHR system. If a malicious PHR user exposes his private key for illegal data sharing, his identity can be accurately pinpointed by the system manager. During {{the whole process of}} data sharing, no bilinear pairing operations are needed, hence this will the mobile terminal devices from heavy computation burden.|$|R
40|$|Abstract — As {{the time}} passes the {{software}} complexity is increasing {{and due to}} this software reliability and quality will be affected. And for measuring the software reliability and quality various defect measurement and defect <b>tracing</b> <b>mechanism</b> will be used. Software defect prevention work typically focuses on individual inspection and testing technique. ODC is a mechanism by which we exploit software defect that occur during the software development life cycle. Orthogonal defect classification is a concept which enables developers, quality managers and project managers {{to evaluate the effectiveness}} and correctness of the softwar...|$|R
40|$|Obtaining {{detailed}} information about the internal events occurring in an operating system {{is a prerequisite for}} understanding performance, overhead, and many subtle timing- related bugs and race conditions. Barrelfish is a research operating system that is developed by ETH Zurich in collaboration with Microsoft Research. It has a simple <b>tracing</b> <b>mechanism</b> which works together with a visualization tool. The current tracing infrastructure for Barrelfish is not very sophisticated and unable to handle traces longer than a few thousand processor cycles. In this lab, we extend the tracing functionality provided in Barrelfish an...|$|R
40|$|Traditional <b>tracing</b> <b>mechanisms</b> {{were usually}} {{developed}} {{for use in}} a single-computer environment. Moreover, they are bound to a speci c programming language. Today's highly distributed and heterogeneous computing environments require new tracing methodologies. The paper addresses this problem by reviewing ways how the middleware might and should support tracing. In particular, CORBA meta-objects that can be applied for tracing, are studied. One of them, namely the interceptor concept is presented in more depth, followed by a detailed description of an interceptor-based tracing architecture for CORBA applications. Implementation details and evaluation experience is given. ...|$|R
40|$|In {{order to}} meet the demands of wider issue processors, fetch {{mechanisms}} will need to fetch multiple basic blocks per cycle. The trace cache supplies several basic blocks each cycle by storing logically contiguous instructions in physically contiguous storage. When a particular basic block is requested, the trace cache can potentially respond with the requested block along with several blocks that followed it when the block was last encountered. In this technical report, we examine some critical features of a <b>trace</b> cache <b>mechanism</b> designed for a 16 -wide issue processor and evaluate their effects on performance. We examine features such as cache associativity, storage partitioning, branch predictor design, instruction cache design, and fill unit design. We compare the performance of our <b>trace</b> cache <b>mechanism</b> with that of the design presented by Rotenberg et al [19] and show a 23 % improvement in performance. In our final analysis, we compare our <b>trace</b> cache <b>mechanism</b> with an aggressive s [...] ...|$|R
40|$|Parallel {{computers}} with SMP nodes provide both multithreading and message passing as their modes of parallel execution. This thesis addresses {{the complexity of}} the performance problems that can arise in these systems by formally characterizing the problems in terms of execution patterns that represent situations of inefficient behavior. These patterns are specified as compound events which are input for an automatic analysis process that recognizes and quantifies the inefficient behavior in event <b>traces.</b> <b>Mechanisms</b> that hide the complex relationships within compound-event specifications allow a simple description of complex inefficient behavior on a high level of abstraction...|$|R
40|$|Abstract—Ambient Intelligence systems use many {{sensors and}} actuators, with a {{diversity}} of networks, protocols and technologies which {{makes it impossible to}} access the devices in a common manner. This paper presents the HomePort software, which provides an open source RESTful interface to heterogeneous sensor networks, allowing a simple unified access to virtually any kind of protocol using well known standards. HomePort includes means to provide event notification, as well as a <b>tracing</b> <b>mechanism.</b> The software is implemented and we report on initial experiments and provide an evaluation that shows the feasibility and scalability of the approach...|$|R
40|$|Volumetric {{change within}} the {{external}} audi-tory meatus {{was found to}} be a linear func-tion of human jaw position in the vertical and horizontal planes of space. A technic for recording the change eliminated the need for the insertion of foreign objects into the mouth for the study of dynamic jaw function. Current clinical methods for the determina-tion of human jaw movements fall into two broad classifications: (I) For extraoral tracings, a device is fastened to the maxil-lary and mandibular teeth so that, by a series of rods, the movement is amplified to an external <b>tracing</b> <b>mechanism.</b> (2) Fo...|$|R
50|$|In late 1960, Skipjack {{entered the}} mouth of a long ship channel leading from the Arctic Ocean to Murmansk in the Soviet Union. On the journey, she passed so close to the Soviet port that the {{officers}} could look through a periscope and see the port only 30 or 40 yards (27 to 37 meters) away. Upon entering the canal, crewmen saw one of Skipjacks officers turn off a <b>tracing</b> <b>mechanism</b> so {{that there would be no}} written record of the action. Upon returning from this mission, Skipjack spent the remainder of 1960 in a restricted yard availability and upkeep.|$|R
40|$|Abstract. Tracing {{information}} {{is an essential}} part of the ATLAS Transformation Language (ATL). It is used to support interaction between transformation rules, where each rule can use the output of other rules by means of the implicit <b>tracing</b> <b>mechanism.</b> However, <b>tracing</b> {{information is}} often useful outside the scope of the transformation execution as well. Currently, ATL offers limited access to the implicit tracing information via the resolveTemp() method. In addition, the tracing information is always discarded after the transformation execution. We propose a method that allows richer runtime access to the tracing information, as well a method for efficiently storing the tracing information in a separate model. ...|$|R
40|$|Establishment of pig-breeding {{record is}} {{fundamental}} to enforce the source supervision of pork production and construct the <b>tracing</b> <b>mechanism</b> of pork quality safety. Based on the result of 327 questionnaires, Logit Binary Choice Model is used in this paper to quantitatively analyze the factors influencing the willingness of pigbreeding farms and farmers to establish breeding record. It shows that six factors, which are education level, specialized level, participation in pig-breeding cooperative organization, recognition of breeding record, government’s propaganda and supervision, have significant and {{positive impact on the}} willingness of pigbreeding farms and farmers to build breeding record. Key words: Pig-breeding farm and farmer; Breeding record; Logit model; Influence factor...|$|R
40|$|Tracing is an {{important}} mechanism to prevent crimes in anonymous payment systems. However, {{it is also a}} threat to the customer's privacy as long as its application cannot be controlled. Relying solely on trusted third parties for tracing is inadequate, as there are no strong guarantees that deanonymizations are only applied legally. A recent tracing concept is auditable tracing, where the customer has the power to control the deanonymization. With auditable tracing no trust is required, while it offers comparable <b>tracing</b> <b>mechanisms.</b> We present the first off-line payment system with auditable tracing. Our payment system supports coin and owner tracing as well as self deanonymization in the case of blackmailing...|$|R
40|$|Abstract {{requirement}} for trace files. We {{show that the}} agent can obtain such an understanding automatically at runtime without programmer intervention or support. The remainder of the paper is structured as follows: In section 2 we describe scalability problems of <b>tracing</b> <b>mechanisms.</b> Section 3 shows {{the implementation of the}} trace-scaling agent. Section 4 describes some applications and results of scaled tracing. Section 5 contains further disussion of our approach. In section 6 we conclude the paper. Tracing and performance analysis tools are an important component in the development of high performance applications. Tracing paral'el prqgrams with current tracing tools. however. easily leads to large trace files with hundreds of lUegabytes. The s~orage...|$|R
