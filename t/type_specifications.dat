84|712|Public
25|$|In {{computer}} science, {{a library}} {{is a collection}} of non-volatile resources used by computer programs, often to develop software. These may include configuration data, documentation, help data, message templates, pre-written code and subroutines, classes, values or <b>type</b> <b>specifications.</b> In IBM's OS/360 and its successors they are referred to as partitioned data sets.|$|E
2500|$|Procedure (proc) {{declarations}} require <b>type</b> <b>specifications</b> {{for both}} the parameters and the result (void if none): ...|$|E
5000|$|RFC 6838, with John Klensin and Tony Hansen, Media <b>Type</b> <b>Specifications</b> and Registration Procedures, ...|$|E
5000|$|Technical values {{pertaining}} to various <b>types,</b> <b>specifications,</b> applications, characteristics of equipments or spares ...|$|R
40|$|Abstract—The {{process of}} marking up the {{syntactic}} {{structure of the}} sentences in a corpus is facilitated by having a graphical tree editor. A <b>type</b> <b>specification</b> constrains the nature of acceptable trees, and visual indication of non-conformities makes corrections easy. Projectivity checking {{can also be a}} useful way to notice errors, depending on the linguistic design of the tree <b>type</b> <b>specification.</b> A small test corpus has been marked up using this method. Only the English language has been investigated so far, and the tool takes no other input than the <b>type</b> <b>specification</b> and the corpus. Adding a lexical database is an obvious way to make it more generally useful. I...|$|R
25|$|January 1982 - Limited edition Chevette Silhouette three-door {{hatchback}} introduced {{with black}} paintwork, strobe stripes and ES <b>type</b> <b>specification.</b>|$|R
5000|$|Procedure (proc) {{declarations}} require <b>type</b> <b>specifications</b> {{for both}} the parameters and the result (void if none): ...|$|E
5000|$|Due to a {{reduction}} in European freight volumes, since mid-2012 a number of EMD Series 66 locomotives have been imported by UK rail freight operators and converted to UK <b>type</b> <b>specifications.</b> These have included: ...|$|E
5000|$|The actual <b>type</b> <b>specifications</b> can {{consist of}} an actual type, such as , or a general type {{variable}} that is used in parametric polymorphic functions, such as , or , or [...] So we can write something like: ...|$|E
25|$|May 1981 - Limited edition Chevette Black Pearl {{introduced}} {{with black}} paintwork, silver strobe stripes and ES <b>type</b> <b>specification.</b>|$|R
50|$|January 1982 - Limited edition Chevette Silhouette three-door {{hatchback}} introduced {{with black}} paintwork, strobe stripes and ES <b>type</b> <b>specification.</b>|$|R
5000|$|After final {{review and}} {{approval}} as Air Corps <b>Type</b> <b>Specification</b> XC-622, a further four manufacturers {{were added to the}} distribution: ...|$|R
50|$|In {{computer}} science, {{a library}} {{is a collection}} of non-volatile resources used by computer programs, often to develop software. These may include configuration data, documentation, help data, message templates, pre-written code and subroutines, classes, values or <b>type</b> <b>specifications.</b> In IBM's OS/360 and its successors they are referred to as partitioned data sets.|$|E
50|$|Casting off {{generally}} {{begins by}} counting the words or {{characters in the}} manuscript, usually using a word processor or text editor. This word count is then divided by {{an estimate of the}} number of words or characters per full page of a model book, i.e., a previously published book with approximately the same trim size and <b>type</b> <b>specifications</b> to be applied to the manuscript.|$|E
5000|$|These {{last two}} {{operations}} may be {{illustrated by the}} example of trees. First, define X to be the species [...] "singleton" [...] whose generating series is X(x) = x. Then the species Ar of rooted trees (from the French [...] "arborescence") is defined recursively by Ar = X · E(Ar). This equation says that a tree consists of a single root {{and a set of}} (sub-)trees. The recursion does not need an explicit base case: it only generates trees in the context of being applied to some finite set. One way to think about this is that the Ar functor is being applied repeatedly to a [...] "supply" [...] of elements from the set [...] - [...] each time, one element is taken by X, and the others distributed by E among the Ar subtrees, until there are no more elements to give to E. This shows that algebraic descriptions of species are quite different from <b>type</b> <b>specifications</b> in programming languages like Haskell.|$|E
40|$|In this chapter, {{we propose}} a {{framework}} for logic programming with different type systems. In this framework a typed logic program consists of a <b>type</b> <b>specification</b> and a Horn clause program which is well-typed {{with respect to the}} <b>type</b> <b>specification.</b> The <b>type</b> <b>specification</b> defines all <b>types</b> which can be used in the logic program. Relations between types are expressed by equations on the level of types. This permits the specification of many-sorted, order-sorted, polymorphic and polymorphically order-sorted type systems. We present the declarative semantics of our framework and two proof procedures (deduction and resolution) for typed logic programs. An interesting application is a type system that combines parametric polymorphism with order-sorted typing and permits higher-order logic programming. Moreover, our framework sheds some new light on the rôle of types in logic programming...|$|R
50|$|Type Description Language (TDL) is {{the name}} of a data <b>type</b> <b>specification</b> {{language}} defined in the book Implementing Typed Feature Structure Grammars.|$|R
5000|$|Fuzzino is an {{open source}} library, which {{provides}} a rich set of fuzzing heuristics that are generated from a <b>type</b> <b>specification</b> and/or valid values.|$|R
5000|$|The ATM books {{promoted}} {{a philosophy of}} telescope making that eschewed standardization and rote rule-following, emphasizing instead the importance of intellectual involvement and creativity in the solution of problems, {{as well as the}} highest standards in optical and mechanical performance. In the [...] "Preface" [...] to the 3rd edition (1932) of Volume 1, Ingalls wroteTelescope making is a scientific hobby and it appeals doubtless because it exacts intelligence; requires patience and sometimes dogged persistence in order to whip the knotty but fascinating problems which arise; demands hard work -- is not dead easy; and compels the exercise of a fair amount of handiness -- enough to exclude the born bungler but no more than is possessed by the average man who can [...] "tinker" [...] his car or the household plumbing...The hobby also appeals because the worker derives something of a thrill while shaping the refined curve of the glass as he realizes that, with scarecly any special tools...he is able to work to within almost a millionth of an inch of absolute perfection.He continuedSome of the workers -- a very few -- have strongly urged that the amateur's telescopes be standardized on a few definite <b>type</b> <b>specifications,</b> arguing that this would save labor. Others believe that standardized hobbies connote standardized people with standardized ideas, and that the introduction of mass production and labor-saving ideas of efficiency in connection with a hobby is comparable to hiring a workman to play one's games for him. A hobby should be a way to waste time, not to count it.|$|E
40|$|AbstractWe {{compare the}} event {{calculus}} and temporal action logics (TAL), two formalisms for reasoning about action and change. We prove that, if the formalisms {{are restricted to}} integer time, inertial fluents, and relational fluents, and if TAL action <b>type</b> <b>specifications</b> are restricted to definite reassignment of a single fluent, then the formalisms are not equivalent. We argue that equivalence cannot be restored by using more general TAL action <b>type</b> <b>specifications.</b> We prove however that, if the formalisms are further restricted to single-step actions, then they are logically equivalent...|$|E
40|$|Term Rewriting Systems play an {{important}} role in various areas, such as abstract data <b>type</b> <b>specifications,</b> implementations of functional programming languages and automated deduction. In this chapter we introduce several of the basic comcepts and facts for TRS's. Specifically, we discuss Abstract Reduction System...|$|E
40|$|The paper {{presents}} {{an approach to}} diagnosis of CLP programs and a diagnoser for CHIP based on this approach. The objective is to achieve partial correctness of the program w. r. t. a <b>specification</b> of <b>type</b> terms which describe sets of calls and successes of program predicates. Parametric regular term grammars with constraints are used to define the meaning of type terms as sets. The diagnoser compares the <b>type</b> <b>specification</b> given by the user with the type information inferred from the program and localizes all fragments of the program responsible for {{the discrepancy between the}} two. No information about error symptoms is used. The <b>type</b> <b>specification</b> is not requested a priori. It is developed “by need” querying the user about the types inferred. A type error is often localized by providing {{only a small portion of}} <b>type</b> <b>specification...</b>|$|R
5000|$|Data {{manipulation}} enhancements: allocatable components (incorporating TR 15581), deferred type parameters, [...] attribute, explicit <b>type</b> <b>specification</b> {{in array}} constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures ...|$|R
40|$|In {{this paper}} {{we present a}} logical <b>specification</b> of data <b>types.</b> This <b>specification</b> is built upon a {{previously}} given specification for a data type {{that we want to}} extend by introducing new constructing objects and defined operations. The extended data type is specified by superposing a circumscription principle to some specification axioms. Circumscription formalizes in second-order logic some forms of (non-monotonic) common-sense reasoning in knowledge bases [11]. By means of circumscription we separate very clearly the first-order specification language (or axioms) from the specification mechanism. By showing the logical equivalence to Zhang's noncircumscriptive data <b>type</b> <b>specification</b> [17], we obtain the categoricity of our specification when we start from a categorical specification for the original data type. Keywords: data <b>type</b> <b>specification,</b> circumscription, first-order logic, second-order logic, knowledge bases, non-monotonic reasoning. 1. Introduction In this work we apply [...] ...|$|R
40|$|This paper {{introduces}} {{a framework of}} parametric descriptive directional types for constraint logic programming (CLP). It proposes a method for locating type errors in CLP programs and presents a prototype debugging tool. The main technique used is checking correctness of programs w. r. t. <b>type</b> <b>specifications.</b> The approach {{is based on a}} generalization of known methods for proving correctness of logic programs to the case of parametric specifications. Set-constraint techniques are used for formulating and checking verification conditions for (parametric) polymorphic <b>type</b> <b>specifications.</b> The specifications are expressed in a parametric extension of the formalism of term grammars. The soundness of the method is proved and the prototype debugging tool supporting the proposed approach is illustrated on examples. The paper i...|$|E
40|$|In {{this paper}} I will address {{what appear to}} be some {{important}} gaps in the traditional approach to nominal reference as a cohesion-creating resource: (i) ignoring of relations other than co-referentiality, such as those expressed by quantifying determiners, (ii) neglect of the contribution made by <b>type</b> <b>specifications</b> to the reference function; (iii) restriction of the <b>type</b> <b>specifications</b> to those lexically predicated by the NP itself, (iv) discounting of the cumulative build-up of information relating to referential sets and referent classification {{in the mind of the}} reader. In the first half of the article, I survey the cognitive instructions given by the main determiner types of NPs: definite versus indefinite identifiers, and relative versus absolute quantifiers. In the second half of the article I develop and illustrate an alternative analysis of discourse referents that does take into account elements (i) to (iv). status: accepte...|$|E
40|$|The paper {{links the}} goals to be {{achieved}} by a type system {{to the problem of}} partial correctness of CLP programs. Several concepts of type correctness of programs are identified by referring to various known concepts of partial correctness of programs. The <b>type</b> <b>specifications</b> considered in this paper attach a mode and a type to every predicate of CLP programs. The paper outlines a soft typing approach where optional <b>type</b> <b>specifications</b> given by the user are completed by type inference. Order-sorted languages of types are considered. This gives a natural framework for comparing prescriptive and descriptive typing approaches. We discuss how they achieve similar goals concerning program correctness with different perspectives and different methods. This opens for possible combinations. The paper illustrates the practicability and the usefulness of the soft typing for error detection and localisation by referring to a specific type inference system described in [16]. 1 Introduction Debug [...] ...|$|E
5000|$|Similar to Fortran, the <b>type</b> <b>specification</b> {{is made up}} of a type, a list of {{attributes}} for the declared variables, and {{the variable}} list. F provides all the same types as Fortran as well, with the sole exception of doubles: ...|$|R
5000|$|The S170 Crown Majesta {{was made}} the {{official}} company car for senior-level Toyota management. This model of Crown Majesta {{also had a}} 10th Anniversary special edition run which was a fully optioned C <b>type</b> <b>specification</b> model with leather and a sunroof as standard.|$|R
40|$|We {{review the}} {{anatomical}} and functional features of circumventricular organs in vertebrates and their homologous neurohemal organs in invertebrates. Focusing on cyclostomes (lamprey) and urochordates (ascidians), {{we discuss the}} evolutionary origin of these organs {{as a function of}} their cell <b>type</b> <b>specification</b> and morphogenesis...|$|R
40|$|In {{this report}} we shall present {{case studies of}} {{different}} data <b>type</b> <b>specifications</b> for natural numbers, for integers, for finite lists, for finite lists with an additional error element, for finite sets, for binary words, for commutative trees, and for arrays. Furthermore, this report contains a collection of constructive function and predicate specifications, whose recursion orderings are shown to be well-founded...|$|E
40|$|Concolic {{testing is}} a {{technique}} that combines concrete and symbolic execution in order to generate inputs that explore different execution paths leading to better testing coverage. Concolic testing tools can find runtime errors fully automatically using available <b>type</b> <b>specifications.</b> The <b>type</b> <b>specifications</b> in a function define the type of each input. However, most specification languages are never expressive enough, {{which can lead to}} runtime errors caused by malformed inputs (i. e. irrelevant errors). Moreover, logic errors causing a program to operate incorrectly without crashing cannot be reported automatically. A universal methodology for any programming language is proposed. Preconditions force the concolic execution to generate well formed inputs before testing a function. On the other hand, postconditions lead to a runtime error when a program operates incorrectly, helping to find logic errors. The results obtained using the concolic testing tool CutEr, in the functional programming language Erlang, show how a program is only tested using well formed inputs specially generated to try to violate the defined postconditions...|$|E
40|$|In {{this paper}} we {{describe}} the construction in hol of the inductive type of arbitrarily branching labeled trees. Such a type is characterized by an initiality theorem similar to that for finitely branching labeled trees. We discuss how to use this type to extend the system of simple recursive <b>type</b> <b>specifications</b> automatically definable in hol to ones including a limited class of functional arguments. The work discussed here {{is a part of}} a larger project to expand the recursive types package of hol which is nearing completion. All work described in this paper has been completed. 1 A Broader Class of Recursive Type Definitions The work described in this paper forms the foundation of a project to expand the class of recursive <b>type</b> <b>specifications</b> for which hol is capable of automatically defining the types specified and proving the initiality theorem, which acts as an axiomatization for the defined types. The full class of specifications the project aims to handle are those BNF- [...] ...|$|E
40|$|Abstract: This {{paper is}} about the design of data types in {{creating}} a software system. The major point is to explore a means for specifying a data type which is independent of its eventual implementation. The particular style of specification, caged algebraic axioms, is exhibited by axiomatizing many commonly used data types. As such, these examples reveal {{a great deal about}} the intricacies of data <b>type</b> <b>specification</b> via algebraic axioms, and, in addition, provide a standard to which alternative forms may be compared. Further uses of this specification technique are in proving the correctness of implementations and in interpretively executing a large system design before actual implementation commences. Indez terms: data <b>type,</b> <b>specification,</b> algebraic axioms, software design, recursive programming, program correctness. 1...|$|R
40|$|The PROSPER {{functional}} specification language supports a "specification by prototyping" paradigm and {{relies on a}} unique and powerful <b>type</b> <b>specification</b> facility. Executable polymorphic specifications can be built from a small set of primitives. Types and functions are treated as values and can be the arguments and results of functions...|$|R
50|$|The {{operator}} {{is written}} preceding its operand, {{and may be}} applied either to a variable or any data <b>type</b> <b>specification,</b> including primitive <b>types</b> such as integer and floating-point types, pointer types, or compound datatypes (unions, structs, or C++ classes). When applied to a data type the type must be enclosed in parenthesis.|$|R
