1244|92|Public
5|$|In all {{of these}} <b>transitive</b> <b>closure</b> algorithms, it is {{possible}} to distinguish pairs of vertices that are reachable by at least one path of length two or more from pairs that can only be connected by a length-one path. The transitive reduction consists of the edges that form length-one paths that are the only paths connecting their endpoints. Therefore, the transitive reduction can be constructed in the same asymptotic time bounds as the <b>transitive</b> <b>closure.</b>|$|E
5|$|Like the <b>{{transitive}}</b> <b>closure,</b> the transitive {{reduction is}} uniquely defined for DAGs. In contrast, for a directed graph {{that is not}} acyclic, there can {{be more than one}} minimal subgraph with the same reachability relation.|$|E
5|$|Important {{polynomial}} time computational problems on DAGs include topological sorting (finding a topological ordering), {{construction of the}} <b>transitive</b> <b>closure</b> and transitive reduction (the largest and smallest DAGs with the same reachability relation, respectively), and the closure problem, in which {{the goal is to}} find a minimum-weight subset of vertices with no edges connecting them {{to the rest of the}} graph. Transforming a directed graph with cycles into a DAG by deleting as few vertices or edges as possible (the feedback vertex set and feedback edge set problem, respectively) is NP-hard, but any directed graph can be made into a DAG (its condensation) by contracting each strongly connected component into a single supervertex. The problems of finding shortest paths and longest paths can be solved on DAGs in linear time, in contrast to arbitrary graphs for which shortest path algorithms are slower and longest path problems are NP-hard.|$|E
5000|$|... {{defining}} <b>transitive</b> <b>closures</b> through circular constraints (implemented by mixed top-down/memoisation and bottom-up strategy).|$|R
50|$|It also {{includes}} an ILP solver based on generalized basis reduction, <b>transitive</b> <b>closures</b> on maps (which may encode infinite graphs), dependence analysis and bounds on piecewise step-polynomials.|$|R
50|$|A {{hierarchical}} query {{is a type}} of SQL query {{that handles}} hierarchical model data. They are special cases of more general recursive fixpoint queries, which compute <b>transitive</b> <b>closures.</b>|$|R
25|$|However, the <b>transitive</b> <b>closure</b> of a {{restriction}} is {{a subset}} of the restriction of the <b>transitive</b> <b>closure,</b> i.e., in general not equal.|$|E
25|$|PSPACE is {{the set of}} {{languages}} definable by second-order formulas with an added <b>transitive</b> <b>closure</b> operator.|$|E
25|$|L0(A) = the {{smallest}} transitive set containing A as an element, i.e. the <b>transitive</b> <b>closure</b> of {A}.|$|E
40|$|International audienceComputing <b>transitive</b> <b>closures</b> of integer {{relations}} {{is the key}} to finding precise invariants of integer programs. In this paper, we describe an efficient algorithm for computing the <b>transitive</b> <b>closures</b> of difference bounds, octagonal and finite monoid affine relations. On the theoretical side, this framework provides a common solution to the acceleration problem, for all these three classes of relations. In practice, according to our experiments, the new method performs up to four orders of magnitude better than the previous ones, making it a promising approach for the verification of integer programs...|$|R
50|$|When {{measured}} both {{in terms}} of the number n of vertices and the number m of edges in a directed acyclic graph, transitive reductions can also be found in time O(nm), a bound that may be faster than the matrix multiplication methods for sparse graphs. To do so, collect edges (u,v) such that the longest-path distance from u to v is one, calculating those distances by linear-time search from each possible starting vertex, u. This O(nm) time bound matches the complexity of constructing <b>transitive</b> <b>closures</b> by using depth first search or breadth first search to find the vertices reachable from every choice of starting vertex, so again with these assumptions <b>transitive</b> <b>closures</b> and <b>transitive</b> reductions can be found in the same amount of time.|$|R
40|$|AbstractThis paper surveys several {{alternative}} data {{structures and}} algorithms for multiplying sparse upper-triangular matrices over closed semirings, and evaluates their efficiency in computing <b>transitive</b> <b>closures</b> of matrices over the Boolean semiring. Two new variants are introduced that outperform previously known methods on {{a collection of}} large data-sets drawn from linguistic applications...|$|R
25|$|If L(A) {{contains}} a well-ordering of the <b>transitive</b> <b>closure</b> of {A}, then {{this can be}} extended to a well-ordering of L(A). Otherwise, the axiom of choice will fail in L(A).|$|E
25|$|Versions of the {{algorithm}} {{can also be}} used for finding the <b>transitive</b> <b>closure</b> of a relation , or (in connection with the Schulze voting system) widest paths between all pairs of vertices in a weighted graph.|$|E
25|$|Relationships {{among these}} classes {{directly}} impact the relative expressiveness of the logics over finite structures; for example, if PHnbsp&=nbsp&PSPACE, then adding a <b>transitive</b> <b>closure</b> operator to second-order logic {{would not make}} it any more expressive over finite structures.|$|E
3000|$|The best {{sequential}} algorithms that {{solve this}} problem have O(mn) time complexity, where m and n are, respectively, the number of edges and vertices of the digraph (Simon [19] and Habib et al. [9]). It should be mentioned that the computation of <b>transitive</b> <b>closures</b> can be done asymptotically faster by matrix multiplication techniques [...]...|$|R
40|$|AbstractThe {{number of}} {{different}} sets that can be generated from a given set by applications of complement and closure operators is finite and small (e. g., 14). This fact, stated originally in [4] for topological closures, and the later in [2] for <b>transitive</b> <b>closures</b> of binary relations, is generalized to other closure operators, and several examples are given...|$|R
40|$|Abstract Recursive {{queries are}} {{required}} for many tasks of database applications. Among them we can mention Bill-Of-Material (BOM), various kinds of networks (transportation, telecommunication, etc.), processing semi-structured data (XML, RDF), and so on. The support for recursive queries in current query languages is limited and lacks of theoretical foundations. In particular, this concerns corresponding extensions of SQL in Oracle and DB 2 systems. In this report we present recursive query processing capabilities for the object-oriented Stack-Based Query Language (SBQL) and compare them with similar capabilities in variants of SQL. SBQL offers very powerful and flexible recursive querying capabilities {{due to the fact}} that recursive processing operators are fully orthogonal to other features of this language. This report specifies corresponding SBQL constructs, such as <b>transitive</b> <b>closures</b> and fixed point equations. We compare them to other query languages, in particular to Datalog. We also present briefly optimization possibilities for recursive queries. Keywords: Stack-Based Approach (SBA), query languages, SBQL, objectorientedness, <b>transitive</b> <b>closures,</b> fixed-point equations, deductive rules, recursiv...|$|R
25|$|<b>Transitive</b> <b>closure</b> of {{directed}} graphs (Warshall's algorithm). In Warshall's original {{formulation of}} the algorithm, the graph is unweighted and represented by a Boolean adjacency matrix. Then the addition operation is replaced by logical conjunction (AND) and the minimum operation by logical disjunction (OR).|$|E
25|$|Permutation {{methods can}} be used to create from any model of NFU a model in which every {{strongly}} cantorian isomorphism type of set pictures is actually realized as the restriction of the true membership relation to the <b>transitive</b> <b>closure</b> of a set.|$|E
25|$|The graphs {{that can}} be built from a single vertex by pendant {{vertices}} and true twins, without any false twin operations, are special cases of the Ptolemaic graphs and include the block graphs. The graphs {{that can be}} built from a single vertex by false twin and true twin operations, without any pendant vertices, are the cographs, which are therefore distance-hereditary; the cographs are exactly the disjoint unions of diameter-2 distance-hereditary graphs. The neighborhood of any vertex in a distance-hereditary graph is a cograph. The <b>transitive</b> <b>closure</b> of the directed graph formed by choosing any set of orientations for the edges of any tree is distance-hereditary; the special {{case in which the}} tree is oriented consistently away from some vertex forms a subclass of distance-hereditary graphs known as the trivially perfect graphs, which are also called chordal cographs.|$|E
40|$|We present new {{deterministic}} algorithms {{for several}} {{cases of the}} maximum rank matrix completion problem (for short matrix completion), i. e., the problem of assigning values to the variables in a given symbolic matrix to maximize the resulting matrix rank. Matrix completion {{is one of the}} fundamental problems in computational complexity. It has numerous important algorithmic applications, among others, in computing dynamic <b>transitive</b> <b>closures</b> or multicast networ...|$|R
40|$|Abstract. A {{computer}} {{implementation of}} Gödel’s algorithm for class formation in Mathematica TM {{was used to}} formulate definitions and theorems about iteration in Gödel’s class theory. The intent is to use this approach for automated reasoning about a variety of applications of iteration using Mc-Cune’s automated reasoning program Otter. The applications include the theory of <b>transitive</b> <b>closures</b> of relations, the arithmetic of natural numbers, construction of invariant subsets, and the Schröder-Bernstein theorem. ...|$|R
40|$|AbstractIn this paper, {{we study}} finite orders whose {{comparability}} graphs are split graphs. We introduce a normalized representation of these orders using {{a family of}} open real intervals. Its repercussions are both structural and algorithmic. We show that the dimension of split orders is at most three, and we give a simple characterization of those of dimension two. We present a linear time recognition algorithm for directed graphs whose <b>transitive</b> <b>closures</b> are split orders...|$|R
500|$|The <b>transitive</b> <b>closure</b> {{of a given}} DAG, with [...] {{vertices}} and [...] edges, may {{be constructed}} in time [...] by using either breadth-first search or depth-first search to test reachability from each vertex. Alternatively, it can be solved in time [...] where [...] is the exponent for fast matrix multiplication algorithms; this is a theoretical improvement over the [...] bound for dense graphs.|$|E
500|$|In {{terms of}} the {{implication}} graph of the 2-satisfiability instance, Krom's inference rule {{can be interpreted as}} constructing the <b>transitive</b> <b>closure</b> of the graph. As [...] observes, it can also be seen as an instance of the Davis–Putnam algorithm for solving satisfiability problems using the principle of resolution. Its correctness follows from the more general correctness of the Davis–Putnam algorithm. Its polynomial time bound follows from the fact that each resolution step increases the number of clauses in the instance, which is upper bounded by a quadratic function of the number of variables.|$|E
500|$|... 2-satisfiability is NL-complete, {{meaning that}} {{it is one of}} the [...] "hardest" [...] or [...] "most expressive" [...] {{problems}} in the complexity class NL of problems solvable nondeterministically in logarithmic space. Completeness here means that a deterministic Turing machine using only logarithmic space can transform any other problem in NL into an equivalent 2-satisfiability problem. [...] Analogously to similar results for the more well-known complexity class NP, this transformation together with the Immerman–Szelepcsényi theorem allow any problem in NL to be represented as a second order logic formula with a single existentially quantified predicate with clauses limited to length 2. Such formulae are known as SO-Krom. [...] Similarly, the implicative normal form can be expressed in first order logic with the addition of an operator for <b>transitive</b> <b>closure.</b>|$|E
40|$|Abstract. Leftist grammars [Motwani et al., STOC 2000] {{are special}} semi-Thue systems where symbols can only insert or erase to their left. We develop {{a theory of}} leftist grammars seen as word {{transformers}} as a tool toward rigorous analyses of their computational power. Our main contributions in this first paper are (1) constructions proving that leftist transformations are closed under compositions and <b>transitive</b> <b>closures,</b> and (2) a proof that bounded reachability isNP-complete even for leftist grammars with acyclic rules. ...|$|R
40|$|Abstract. Muscholl and Petersen showed that, in {{the case}} of <b>transitive</b> dependencies, <b>closures</b> of star-free lexicographic {{languages}} are star-free or non-regular. It implies that, in the same case of <b>transitive</b> dependencies, <b>closures</b> of star-free lexicographic languages are star-free. In this paper, it is shown to be true also {{in the case}} of transitive independencies. Main result is even more general, but the general question, if closures of star-free lexicographic languages are star-free in any case, remains open. ...|$|R
40|$|This paper {{presents}} {{an approach to}} region-based hierarchical image matching, where, given two images, {{the goal is to}} identify the largest part in image 1 and its match in image 2 having the maximum similarity measure defined in terms of geometric and photometric properties of regions (e. g., area, boundary shape, and color), as well as region topology (e. g., recursive embedding of regions). To this end, each image is represented by a tree of recursively embedded regions, obtained by a multiscale segmentation algorithm. This allows us to pose image matching as the tree matching problem. To overcome imaging noise, one-to-one, many-to-one, and many-to-many node correspondences are allowed. The trees are first augmented with new nodes generated by merging adjacent sibling nodes, which produces directed acyclic graphs (DAGs). Then, <b>transitive</b> <b>closures</b> of the DAGs are constructed, and the tree matching problem reformulated as finding a bijection between the two <b>transitive</b> <b>closures</b> on DAGs, while preserving the connectivity and ancestor-descendant relationships of the original trees. The proposed approach is validated on real images showing similar objects, captured under different types of noise, including differences in lighting conditions, scales, or viewpoints, amidst limited occlusion and clutter. I...|$|R
500|$|If [...] is a DAG, its <b>transitive</b> <b>closure</b> is {{the graph}} {{with the most}} edges that {{represents}} the same reachability relation. It has an edge [...] whenever [...] can reach [...] That is, it has an edge for every related pair [...] of distinct elements in the reachability relation of , and may therefore {{be thought of as}} a direct translation of the reachability relation [...] into graph-theoretic terms. The same method of translating partial orders into DAGs works more generally: for every finite partially ordered set , the graph that has a vertex for each member of [...] and an edge for each pair of elements related by [...] is automatically a transitively closed DAG, and has [...] as its reachability relation. In this way, every finite partially ordered set can be represented as the reachability relation of a DAG.|$|E
2500|$|For any strings [...] we say [...] yields , {{written as}} [...] (or [...] in some textbooks), if [...] such that [...] In this case, if [...] (i.e., [...] ), the {{relation}} [...] holds. In other words, [...] and [...] are the reflexive <b>transitive</b> <b>closure</b> (allowing {{a word to}} yield itself) and the <b>transitive</b> <b>closure</b> (requiring at least one step) of , respectively.|$|E
2500|$|For example, {{restricting the}} {{relation}} [...] "x is parent of y" [...] to females yields the relation [...] "x is {{mother of the}} woman y"; its <b>transitive</b> <b>closure</b> doesn't relate a woman with her paternal grandmother. On the other hand, the <b>transitive</b> <b>closure</b> of [...] "is parent of" [...] is [...] "is ancestor of"; its restriction to females does relate a woman with her paternal grandmother.|$|E
40|$|Abstract. <b>Transitive</b> <b>closures</b> of the {{covering}} relation in semilattices are investigated. Vyˇsetˇrují se tranzitivní uzávěry pokr´yvací relace v polosvazech. This {{very short}} note is an immediate continuation of [1]. We therefore refer to [1] as for terminology, notation, various remarks, further references, etc. 1. The covering relation in semilattices Throughout the note, let S = S(+) be a semilattice (i. e., a commutative idempotent semigroup). Define a relation α on S by (a, b) ∈ α if {{and only if}} a + b = b...|$|R
40|$|Leftist grammars [Motwani et al., STOC 2000] {{are special}} semi-Thue systems where symbols can only insert or erase to their left. We develop {{a theory of}} leftist grammars seen as word {{transformers}} as a tool toward rigorous analyses of their computational power. Our main contributions in this first paper are (1) constructions proving that leftist transformations are closed under compositions and <b>transitive</b> <b>closures,</b> and (2) a proof that bounded reachability is NP-complete even for leftist grammars with acyclic rules. Comment: Full version of the FOSSACS 2010 pape...|$|R
40|$|AbstractIn {{this paper}} we {{consider}} the closure UCI(Rel) {{of the class of}} relabeling tree transformations, under U=union, C=composition and I=iteration. We give a characterization of UCI(Rel) in terms of a short expression built up from Rel with composition and iteration. We also give a characterization of UCI(Rel) in terms of one-step rewrite relations of very simple term rewrite systems. We give a similar characterization of UC(FRel+), where FRel+ is the class consisting of the <b>transitive</b> <b>closures</b> of all functional relabeling tree transformations. Finally we show that UCI(Rel) =UCI(FRel) ...|$|R
