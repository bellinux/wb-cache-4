96|7459|Public
25|$|In other words, <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> is a {{combination}} of hardware, software, and controls that work together to form a trusted base to enforce your security policy.|$|E
25|$|The <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> of a {{computer}} system is the set of all hardware, firmware, and/or software components that are critical to its security, {{in the sense that}} bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system. By contrast, parts of {{a computer}} system outside the TCB must not be able to misbehave {{in a way that would}} leak any more privileges than are granted to them in accordance to the security policy.|$|E
5000|$|... a small <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> {{results in}} a high {{security}} system ...|$|E
40|$|The <b>trusted</b> <b>computing</b> <b>bases</b> (<b>TCBs)</b> of {{applications}} running on today’s commodity operating systems have become extremely large. This paper presents an architecture that allows to build applications {{with a much}} smaller <b>TCB.</b> It is <b>based</b> on a kernelized architecture and on the reuse of legacy software using trusted wrappers. We discuss the design principles, the architecture and some components, {{and a number of}} usage examples. ...|$|R
40|$|As {{the demand}} for system {{virtualization}} grows, so does the need to securely virtualize {{a wider range of}} underlying physical resources which can be shared among multiple guest OSs. Recently, virtualization technology with hardware support has become available on commodity processors and can be utilized {{to reduce the size of}} the <b>Trusting</b> <b>Computing</b> <b>Base</b> (<b>TCB).</b> The design of a secure system requires architects to develop a system architecture that satisfies security policies. In this paper we propose an approach for specifying and verifying a layered assurance scheme for multi-core architectures. ...|$|R
40|$|Web sites fail in {{the worst}} ways. They can reveal private data {{that can never be}} {{retracted}} [60, 72, 78, 79]. Or they can succumb to vandalism, and subsequently show corrupt data to users [27]. Blame can fall on the off-the-shelf software that runs the site (e. g., the operating system, the application libraries, the Web server, etc.), but more frequently (as in the above references), the custom application code is the guilty party. Unfortunately, the custom code behind many Web sites is difficult to secure and audit, due to large and rapidly-changing <b>trusted</b> <b>computing</b> <b>bases</b> (<b>TCBs).</b> A promising approach to reducing TCBs for Web sites is decentralized information flo...|$|R
5000|$|... #Subtitle level 3: Mimic defense doesn’t have {{credibility}} {{problems of}} the <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB)</b> ...|$|E
5000|$|Designing with a <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB)</b> {{architecture}} ensures {{a highly}} secure & reliable system environment ...|$|E
5000|$|System Architecture {{demonstrates}} that the requirements of self-protection and completeness for reference monitors have been implemented in the <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB).</b>|$|E
30|$|Ker-ONE is a {{lightweight}} micro-kernel that provides para-virtualization on ARM embedded systems. In this work, {{it is seen}} as a simple kernel that may implement several isolated tasks at user level. Since Ker-ONE is very simple, it only provides fundamental functions such as round-robin scheduling, inter-process communication (IPC), and memory management. It ends up with a small <b>trust</b> <b>computing</b> <b>base</b> (<b>TCB)</b> as described in [1]. In the proposed system, multiple adaptive processes run concurrently {{on the top of the}} kernel. Each task may access the DevCfg in order to reconfigure specific hardware blocks in the PL region of the FPGA. Note that all the mechanisms that deal with reconfiguration management are implemented in different isolated tasks: the configuration controller, parameters provider, and hardware updater.|$|R
5000|$|In 2010, she and Rafal Wojtczuk {{began working}} on the Qubes OS security-oriented desktop Xen distribution, which {{utilizes}} Fedora Linux. The initial release of Qubes 1.0 was completed by September 3rd, 2012 and is available as a free download. [...] Its main concept is [...] "security by compartmentalization", using domains implemented as lightweight Xen virtual machines to isolate various subsystems. Each compartment {{is referred to as}} a Qube, which operates as a separate hardware level virtual machine. The project refers to itself as [...] "a reasonably secure operating system" [...] and has received endorsements by numerous privacy and security experts. It is fairly unique in its capabilities, having a design informed by research on proven vulnerabilities in the <b>trusted</b> <b>compute</b> <b>base</b> (<b>TCB),</b> that are unaddressed in most common desktop operating systems.|$|R
40|$|Abstract. The {{desires for}} robust digital rights {{management}} (DRM) systems are not new to the commercial world. Indeed, industrial research, development and deployment of systems with DRM aspects (most notably crude copy-control schemes) have a long history. Yet to date the industry has not seen much commercial success from shipping these systems on top of platforms that support general-purpose computing. There are many factors contributing to this lack of acceptance of current DRM systems, but I see three specific areas of work that are key adoption blockers today and ripe for further academic and commercial research. The lack of a general-purpose rights expression/authorization language, robust trust management engines and attestable <b>trusted</b> <b>computing</b> <b>bases</b> (<b>TCBs)</b> all hamper industrial development and deployment of DRM systems for digital content. In this paper I briefly describe each of these challenges, provide examples of how the industry is approaching each problem, and discuss how the solutions to {{each one of them}} are dependent on the others. ...|$|R
50|$|In other words, <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> is a {{combination}} of hardware, software, and controls that work together to form a trusted base to enforce your security policy.|$|E
50|$|The Trusted Computer System Evaluation Criteria (TCSEC) {{concept of}} <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> {{minimization}} {{is a far}} more stringent requirement that is only applicable to the functionally strongest assurance classes, viz., B3 and A1 (which are evidentiarily different but functionally identical).|$|E
5000|$|The {{measurements}} of the ACM and BIOS code modules are extended to PCR0, which is said to hold the static core root of trust measurement (CRTM) {{as well as the}} measurement of the BIOS <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB).</b> The BIOS measures additional components into PCRs as follows: ...|$|E
40|$|Desktop {{and mobile}} {{computing}} devices increasingly store critical data, {{both personal and}} professional in nature. Yet, the enormous code bases of their monolithic operating systems (hundreds of thousands to millions of lines of code) are likely to contain exploitable weaknesses that jeopardize the security of this data in the file system. Using a highly componentized system architecture based on a microkernel (or a very small hypervisor) can significantly improve security. The individual operating system components have smaller code bases running in isolated address spaces so as to provide better fault containment. Their isolation also allows for smaller <b>trusted</b> <b>computing</b> <b>bases</b> (<b>TCBs)</b> of applications that comprise only a subset of all components. In my thesis, I built VPFS, a virtual private file system that is designed for such a componentized system architecture. It aims at {{reducing the amount of}} code and complexity that a file system implementation adds to the TCB of an application. The basic idea behind VPFS {{is similar to that of}} a VPN, which securely reuses an untrusted network: The core component of VPFS implements all functionality and cryptographic algorithms that an application needs to rely upon for confidentiality and integrity of file system contents. These security-critical cores reuse a much more complex and therefore untrusted file system stack for non-critical functionality and access to the storage device. Additional trusted components ensure recoverability...|$|R
40|$|Cloud is {{becoming}} the most popular computing infrastructure because it can attract more and more traditional companies due to flexibility and cost-effectiveness. However, privacy concern is the major issue that prevents users from deploying on public clouds. My research focuses on protecting user 2 ̆ 7 s privacy in cloud computing. I will present a hardware-based and a migration-based approach to protect user 2 ̆ 7 s privacy. The root cause of the privacy problem is current cloud privilege design gives too much power to cloud providers. Once the control virtual machine (installed by cloud providers) is compromised, external adversaries will breach users’ privacy. Malicious cloud administrators are also possible to disclose user’s privacy by abusing the privilege of cloud providers. Thus, I develop two cloud architectures – MyCloud and MyCloud SEP to protect user’s privacy based on hardware virtualization technology. I eliminate the privilege of cloud providers by moving the control virtual machine (control VM) to the processor’s non-root mode and only keep the privacy protection and performance crucial components in the <b>Trust</b> <b>Computing</b> <b>Base</b> (<b>TCB).</b> In addition, the new cloud platform can provide rich functionalities on resource management and allocation without greatly increasing the TCB size. Besides the attacks to control VM, many external adversaries will compromise one guest VM or directly install a malicious guest VM, then target other legitimate guest VMs based on the connections. Thus, collocating with vulnerable virtual machines, or ”bad neighbors” on the same physical server introduces additional security risks. I develop a migration-based scenario that quantifies the security risk of each VM and generates virtual machine placement to minimize the security risks considering the connections among virtual machines. According to the experiment, our approach can improve the survivability of most VMs...|$|R
40|$|Sometimes Web sites fail in {{the worst}} ways. They can reveal private data {{that can never be}} {{retracted}} [60, 72, 78, 79]. Or they can succumb to vandalism, and subsequently show corrupt data to users [27]. Blame can fall on the off-the-shelf software that runs the site (e. g., the operating system, the application libraries, the Web server, etc.), but more frequently (as in the above references), the custom application code is the guilty party. Unfortunately, the custom code behind many Web sites is difficult to secure and audit, due to large and rapidly-changing <b>trusted</b> <b>computing</b> <b>bases</b> (<b>TCBs).</b> A promising approach to reducing TCBs for Web sites is decentralized information flow control (DIFC) [21, 69, 113]. DIFC allows the split of a Web application into two types of components: those inside the TCB (trusted), and those without (untrusted). The untrusted components are large, change frequently, and do most of the computation. Even if buggy, they cannot move data contrary to security policy. Trusted components are much smaller, and configure the Web site's security policies. They need only change when the policy changes, and not when new features are introduced. Bugs in the trusted code can lead to compromise, but the trusted code is smaller and therefore easier to audit. The drawback of DIFC, up to now, is that the approach requires a major shift in how programmers develop applications and thus remains inaccessible to programmers using today's proven programming abstractions. This thesis proposes a new DIFC system, Flume, that brings DIFC controls to the operating systems and programming languages in wide use today. Its key contributions are: (1) a simplified DIFC model with provable security guarantees; (2) a new primitive called endpoints that bridges the gap between the Flume DIFC model and standard operating systems interfaces; (3) an implementation at user-level on Linux; and (4) success in securing a popular preexisting Web application (MoinMoin Wiki). by Maxwell Norman Krohn. Thesis (Ph. D.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2008. Includes bibliographical references (leaves 117 - 125) ...|$|R
50|$|Key to the {{provision}} of {{the highest levels of}} assurance (B3 and A1) is the dedication of significant system engineering toward minimization of the complexity (not size, as often cited) of the <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB),</b> defined as that combination of hardware, software, and firmware that is responsible for enforcing the system's security policy.|$|E
50|$|Type 1 hypervisors manage {{key system}} {{resources}} {{required to maintain}} control over the virtual machines, and facilitate a minimal <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB).</b> Type 2 hypervisors typically run as an application within a more general purpose operating system, relying on services of the OS to manage system resources. Nowadays kernel extensions are often loaded {{to take advantage of}} hardware with virtualization support.|$|E
50|$|The <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> of a {{computer}} system is the set of all hardware, firmware, and/or software components that are critical to its security, {{in the sense that}} bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system. By contrast, parts of {{a computer}} system outside the TCB must not be able to misbehave {{in a way that would}} leak any more privileges than are granted to them in accordance to the security policy.|$|E
40|$|Real-time {{behavior}} is materialized by timeliness specifications, which in essence call for synchronous system models. However, systems many often rely on large-scale, unpredictable and unreliable infrastructures, that suggest {{the use of}} asynchronous models. Several models in between have addressed these antagonistic aims, each in its own way. We propose an architectural construct that addresses the problem in a generic way. We assume {{the existence of a}} component that is capable of executing timely functions, however asynchronous the rest of the system may be. This component can be used by other components to execute timely services. There is a certain analogy to the <b>trusted</b> <b>computing</b> <b>base</b> principle used in security. We call it the Timely <b>Computing</b> <b>Base,</b> <b>TCB.</b> In this paper, we show that a TCB can be used to build dependable and timely applications exhibiting varying degrees of timing fault tolerance, under several synchrony model...|$|R
2500|$|... he {{ability of}} a <b>trusted</b> <b>computing</b> <b>base</b> to enforce {{correctly}} a unified security policy depends on the correctness of the mechanisms within the <b>trusted</b> <b>computing</b> <b>base,</b> the protection of those mechanisms to ensure their correctness, and the correct input of parameters related to the security policy.|$|R
50|$|Currently the reincarnation server, {{the process}} server, and the {{microkernel}} {{are part of}} the <b>trusted</b> <b>computing</b> <b>base.</b> If any of them fail, the system crashes. Nevertheless, reducing the <b>trusted</b> <b>computing</b> <b>base</b> from 3-5 million lines of code, as in Linux and Windows systems, to about 20,000 lines greatly enhances system reliability.|$|R
50|$|The {{security}} benefits of microkernels have been frequently discussed. In {{the context of}} security the minimality principle of microkernels is, some have argued, {{a direct consequence of}} the principle of least privilege, according to which all code should have only the privileges needed to provide required functionality. Minimality requires that a system's <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> should be kept minimal. As the kernel (the code that executes in the privileged mode of the hardware) has unvetted access to any data and can thus violate its integrity or confidentiality, the kernel is always part of the TCB. Minimizing it is natural in a security-driven design.|$|E
50|$|JET Blue first {{shipped in}} 1994 as an ISAM for WINS, DHCP, and the now defunct RPL {{services}} in Windows NT 3.5. It shipped {{again as the}} storage engine for Microsoft Exchange in 1996. Additional Windows services chose JET Blue as their storage technology and by 2000 every version of Windows began to ship with JET Blue. JET Blue was used by Active Directory and became part of a special set of Windows code called the <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB).</b> The number of Microsoft applications using JET Blue continues to grow and the JET Blue API was published in 2005 to facilitate usage by an ever-increasing number of applications and services both within and beyond Windows.|$|E
30|$|Controller Module: This resides on {{a secure}} VM. Whenever introspection is required, a command is given through this module. It is {{responsible}} for sending requests to a hypervisor-based module. As this module {{is part of a}} secure VM, {{it is part of a}} <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> and thus is secure.|$|E
25|$|AIX materializes the <b>trusted</b> <b>computing</b> <b>base</b> as an {{optional}} component in its install-time package management system.|$|R
5000|$|Hardware, firmware, and {{software}} {{elements of a}} <b>trusted</b> <b>computing</b> <b>base</b> that implement the reference monitor concept.|$|R
40|$|Current web browsers are complex, have {{enormous}} <b>trusted</b> <b>computing</b> <b>bases,</b> and provide attackers {{with easy access}} to modern computer systems. In this paper we introduce the Illinois Browser Operating System (IBOS), a new operating system and a new browser that reduces the <b>trusted</b> <b>computing</b> <b>base</b> for web browsers. In our architecture we expose browser-level abstractions at the lowest software layer, enabling us to remove almost all traditional OS components and services from our <b>trusted</b> <b>computing</b> <b>base</b> by mapping browser abstractions to hardware abstractions directly. We show that this architecture is flexible enough to enable new browser security policies, can still support traditional applications, and adds little overhead to the overall browsing experience. ...|$|R
40|$|This is {{the second}} paper {{of a series of}} three related papers that examine {{contemporary}} information technology concepts. The first paper examined how the security community developed the accepted concepts and criteria, looked at changes currently ongoing, and provided insight into the driving forces and probable directions. This paper presents contemporary thinking about object management and summarizes vertical and horizontal extensions to the <b>Trusted</b> <b>Computing</b> <b>Base</b> (<b>TCB)</b> concept. ...|$|E
40|$|Identifying and {{protecting}} the <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> of a system is an important task to provide highassurance services since a set of trusted subjects should be legitimately articulated for target applications. In this paper, we present a formal policy analysis framework to identify TCB with the consideration of specific security goals. We also attempt to model information flows between domains in SELinux policies and detect security violations among information flows using Colored Petri Nets. ...|$|E
40|$|Abstract — We propose an {{approach}} to secure MANETs by employing low-complexity low-cost trustworthy MANET mod-ules (TMM), which perform some trivial hard-wired functions involving simple logical operations and block-cipher operations. We describe the functionality of such TMMs to offer a sound <b>trusted</b> <b>computing</b> <b>base</b> (<b>TCB)</b> for securing MANETs. We compare the performance of simulated MANET subnets which include non-cooperative nodes, employing the ad hoc on demand distance vector (AODV) protocol, to evaluate {{the efficacy of the}} proposed approach...|$|E
25|$|As stated above, {{trust in}} the <b>trusted</b> <b>computing</b> <b>base</b> is {{required}} to make any progress in ascertaining {{the security of the}} computer system. In other words, the <b>trusted</b> <b>computing</b> <b>base</b> is “trusted” first and foremost {{in the sense that it}} has to be trusted, and not necessarily that it is trustworthy. Real-world operating systems routinely have security-critical bugs discovered in them, which attests of the practical limits of such trust.|$|R
40|$|Future mobile {{applications}} with real-time requirements {{will demand}} solutions that traditional real-time approaches {{might not be}} able to fulfill. The emergence of new partial synchrony models, such as the Timely <b>Computing</b> <b>Base</b> (<b>TCB)</b> model, may provide the answers we are looking for. More than a framework to build applications, the Timely <b>Computing</b> <b>Base</b> is an adequate model to reason about timeliness issues when designing applications for mobile environments. In this paper we overview the current state of the art with respect to the TCB and we discuss some future trends of the Timely <b>Computing</b> <b>Base</b> towards its implementation in mobile computing. ...|$|R
25|$|As {{outlined}} by the aforementioned Orange Book, software portions of the <b>trusted</b> <b>computing</b> <b>base</b> need to protect themselves against tampering to be of any effect. This {{is due to the}} von Neumann architecture implemented by virtually all modern computers: since machine code can be processed as just another kind of data, it can be read and overwritten by any program barring special memory management provisions that subsequently have to be treated as part of the <b>TCB.</b> Specifically, the <b>trusted</b> <b>computing</b> <b>base</b> must at least prevent its own software from being written to.|$|R
