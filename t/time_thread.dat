7|258|Public
25|$|AT and N. W. Ayer were {{apparently}} somewhat {{dissatisfied with the}} first two Warner films, and unsuccessfully approached Capra about bidding on production of Thread of Life and About <b>Time.</b> <b>Thread</b> of Life is about heredity, DNA and how it works. The screenplay was by Rowland Barber, a writer {{perhaps best known for}} the 1960 novel The Night They Raided Minsky's. Owen Crump directed; Robert McKimson directed the animation.|$|E
5000|$|TTCC is {{a message}} format used by log4j. [...] TTCC is an acronym for <b>Time</b> <b>Thread</b> Category Component. It uses the {{following}} pattern: ...|$|E
5000|$|Harry Dunning: A janitor at Lisbon Falls High School {{and student}} in Jake's evening GED class. His {{submission}} {{of a paper}} about the night his father murdered his mother and siblings with a hammer, provides Jake with motivation and a test case to see if history can be changed. In Jake's second <b>time</b> <b>thread,</b> most of his family members are saved, but Harry serves in the Vietnam War and is killed in the Tet Offensive. In Jake's third <b>time</b> <b>thread,</b> Harry survives Vietnam, but is wheelchair-bound and living alone in a ruined Lisbon Falls.|$|E
5000|$|Intel Parallel Inspector {{performs}} run <b>time</b> <b>threading</b> {{and memory}} error analysis in Windows.|$|R
50|$|The {{real time}} {{priority}} applies {{to an individual}} activity (thread) so a program may have both real time and non-real <b>time</b> <b>threads</b> executing at the same time.|$|R
5000|$|XMOS {{produces}} a multi-core multi-threaded line of processor {{well suited to}} DSP operations, They come in various speeds ranging from 400 to 1600 MIPS. The processors have a multi-threaded architecture that allows up to 8 real-time threads per core, meaning that a 4 core device would support up to 32 real <b>time</b> <b>threads.</b> Threads communicate between each other with buffered channels {{that are capable of}} up to 80 Mbit/s. The devices are easily programmable in C and aim at bridging the gap between conventional micro-controllers and FPGAs ...|$|R
50|$|AT&T and N. W. Ayer were {{apparently}} somewhat {{dissatisfied with the}} first two Warner films, and unsuccessfully approached Capra about bidding on production of Thread of Life and About <b>Time.</b> <b>Thread</b> of Life is about heredity, DNA and how it works. The screenplay was by Rowland Barber, a writer {{perhaps best known for}} the 1960 novel The Night They Raided Minsky's. Owen Crump directed; Robert McKimson directed the animation.|$|E
5000|$|Ten {{thousand}} {{years in the}} future, Jenkins is provided with a new body so he can better serve the few remaining [...] "websters". By then, the dog civilization has spread all around the Earth, including {{the rest of the}} animals whom, little by little, the dogs introduce to their civilization. All of them are significantly intelligent, and Simak appears to mean that they were so all the while even though humans were not able to notice it. This civilization is a pacifist and vegetarian one. The dogs intervene in nature and distribute food to wild animals, managing to virtually end all predation. Besides, they also look for doors between dimensions through which some beings from different worlds are able to pass. At this point, a wraithlike creature called a [...] "cobbly" [...] appears, having traveled from another world on the <b>time</b> <b>thread.</b> Before it is driven away, Jenkins's new telepathic sense enables him to read the creature's mind to discover how it moves from world to world. Realizing that humanity cannot peacefully coexist with the Dogs and the other animals, Jenkins uses the knowledge to take his human charges to one of the other worlds. Eventually, the human race dies out on the new world.|$|E
40|$|Solaris threads and the {{real-time}} facilities of the OS are {{a powerful}} combination for solving concurrency problems whose correctness depends on timeliness of execution. Unfortunately the RT facilities and Solaris threads cannot be easily combined by application programmers. Furthermore, the constraints on {{access to the}} RT facilities limits the potential user base of applications that make use of RT threads. The Real <b>Time</b> <b>Thread</b> Package (RTTP) is a C++ framework, that extends the Brown Thread Package (BTP), and provides a simple mechanism for writing applications that use real-time threads. This paper describes in detail the design and implementation providing both motivation and justification. The paper also discusses an application that used the RTTP {{in conjunction with a}} C++ framework for writing Producer-Consumer style programs. 1 Introduction 1. 1 Operational Overview The purpose of the Real <b>Time</b> <b>Thread</b> Package (RTTP) is {{to make it easier for}} application developers using C++ and a [...] ...|$|E
50|$|In threading, a thin (cotton or polyester) thread is doubled, then twisted. It is {{then rolled}} over areas of {{unwanted}} hair, plucking the {{hair at the}} follicle level. Unlike tweezing, where single hairs are pulled out one at a <b>time,</b> <b>threading</b> can remove short rows of hair.|$|R
40|$|The article {{examines}} Sándor Ferenczi’s ideas about time and psychoanalytic technique. It proposes three metaphors for {{making sense of}} Ferenczi’s times: originary time (the tangent-out), organic time (segments), and pulsating time (the meandering line). For Ferenczi, a differentiated mental process of the analyst characterizes each of these modes of being in time. A clinical vignette explores the workings of these different <b>time</b> <b>threads</b> during an analytic session...|$|R
5000|$|The most {{powerful}} use model of Big.Little architecture is heterogeneous multi-processing (HMP), which enables {{the use of}} all physical cores at the same <b>time.</b> <b>Threads</b> with high priority or computational intensity can in this case be allocated to the [...] "Big" [...] cores while threads with less priority or less computational intensity, such as background tasks, can be performed by the [...] "Little" [...] cores.|$|R
40|$|Polyolefins, {{semicrystalline}} polymers {{also known}} as thermoplastics, are highly desirable because of their material properties, low cost, and ease in processing. The flow and thermal history experienced during processing are known to affect dramatic changes in crystalline kinetics and morphology, dictating the final material properties of solidified products. However, the underlying physics that control crystalline orientation and kinetics is not well understood. To optimize processing conditions and maximize material performance, it is desirable {{to understand how the}} interplay of molecular character and flow conditions shape crystalline microstructure. In the last decade, advances in catalyst technology have produced well defined materials enabling the systematic study of molecular influences on flow-induced crystallization. We investigate bimodal blends of polypropylenes (PP) in which we vary the molecular character (concentration, molecular weight, regularity) of the high molecular weight mode. We apply a number of in situ characterization tools (rheo-optics, rheo-WAXD) to the development of transient structure and interpret our findings in light of ex situ examination (polarized light microscopy, TEM) of the final morphology. Blending a well-characterized high molecular weight isotactic polypropylene into a "base iPP" at various concentrations (c), we determined that blends with less than 1 % of chains with Mw five times larger than the Mw of the base resin profoundly affected the crystallization kinetics and crystalline morphology of a sheared melt. Beyond unambiguously demonstrating the important role of long chains in the formation of anisotropic crystallization under flow, this approach allowed us to be specific about the length that is meant by "long chains" and the concentration of these chains in the melt. Varying the concentration from below to above c* revealed that the effect of the long chains involves cooperative interactions, evident in the non-linear relationship of the long chain concentration, particularly as c approaches the long chain-long chain overlap concentration. The long chains greatly enhance the formation of threadlike precursors but only mildly enhance the formation of pointlike precursors. In studying a series of blends in which the Mw of the long chain mode was varied, we found that increasing the Mw of the long chain portion of a bimodal blend increased the tendency to form threadlike precursors to oriented crystallization. This was highlighted by a marked decrease in the threshold stress necessary to induce oriented crystalline growth and is related to the separation in time scales between the slowest relaxing chains and the average. Thus, the propagation of shish varies strongly with the separation in time scales between the slowest relaxing chains and the average. Below a threshold ratio of relaxation times (tau_L/tau_S ~ 100) addition of long chains did not change the behavior from that of Base-PP itself. Our analysis of real-time rheo-optical and rheo-WAXD experiments combined with depth dependent information from a novel "depth sectioning" analysis technique uncovers several keys to understanding how anisotropic crystallization is induced by flow. Threads first form near the channel wall, where stress is highest, and grow in length with prolonged flow. After sufficient <b>time,</b> <b>thread</b> length per unit volume saturates, perhaps due to collisions with other threads or crystalline overgrowth from those threads. Prior to saturation, when crystalline overgrowth is negligible, the thread propagation appears to be linear with shearing time. The propagation of threads varies in a nonlinear manner with stress. Finally, we identify a promising set of conditions {{that can be used to}} measure the thread propagation velocity for this material if the appropriate length scale can be assigned by microscopy. We examined the effects of long chain regularity on the formation of threadlike precursors, showing that addition of molecular level defects to the high end of the molecular weight distribution effectively raises the threshold stress and mitigates the formation of oriented precursors induced by flow. Our study included a model bimodal blend of isotactic and atactic polypropylene as well as large scale bimodal blends of isotactic polypropylene and a propylene-ethylene copolymer fit for pilot-scale production of nonwoven fabrics. It is noteworthy that the qualitative behavior observed in the melt-spinning process accords well with the trends evident in isothermal shear-induced crystallization. This has value in two respects. Scientifically, it is significant that idealized flow and thermal conditions may well reveal the physics relevant to polymer processing, which involves mixed shear and extension under non-isothermal conditions. Technologically, the ability to screen different resin compositions on a small scale can be used to optimize flow-induced crystallization characteristics prior to scale up...|$|E
40|$|We {{consider}} {{the problem of}} scheduling distributable real-time threads under run-time uncertainties including those on <b>thread</b> execution <b>times,</b> <b>thread</b> arrivals, node failures, and message losses. We present a distributed scheduling algorithm called ACUA that is designed under a partially synchronous model, allowing for probabilistically-described message delays. We show that ACUA satisfies <b>thread</b> <b>time</b> constraints {{in the presence of}} crash failures and message losses, is early-deciding, and has an efficient message and time complexity. The algorithm has also better “best-effort” real-time property than past thread scheduling algorithms. Categories and Subject Descriptors C. 3 [Special-purpose and application-based systems]: Real-time and embedded system...|$|R
3000|$|NVIDIA’s CUDA {{architecture}} {{indicates that}} kernels are executed concurrently by thread blocks. Each block {{is divided into}} warps that consist of 32 threads. Threads inside a warp perform the same branch of the algorithm at the same <b>time.</b> <b>Threads</b> that belong to a warp but do not execute the same branch of the algorithm are executed sequentially. That being said, loops and conditional statements should be avoided when possible; [...]...|$|R
40|$|The Real-Time {{system for}} {{the control of the}} {{magnetohydrodynamics}} instabilities in FTU tokamak is presented. It is based on both a-priori information derived from statistical treatment of a database and Real-Time elaboration of live diagnostics data. The analysis codes are executed in different <b>time</b> <b>threads</b> based on multi-processors machines. The actuator is the 2 × 0. 4 MW 140 GHz ECRH system equipped with the new fast quasi-optical steerable launcher...|$|R
60|$|Doctor Dulcifer, when I {{last heard}} of him, was editing a {{newspaper}} in America. Old File, who shared his flight, still shares his fortunes, being publisher of his newspaper. Young File resumed coining operations in London; and, having braved his fate a second <b>time,</b> <b>threaded</b> his way, in due course, up to {{the steps of the}} scaffold. Screw carries on the profitable trade of informer, in London. The dismal disappearance of Mill I have already recorded.|$|R
5000|$|... {{methods for}} <b>time</b> management: timers, <b>thread</b> sleeping, timeouts, ...|$|R
40|$|In {{the era of}} Internet and Web 2. 0, {{web servers}} have the impor-tant role to serve {{information}} as quickly as possible. In the Web 1. 0 era, web contents were mainly static and rarely modified; AJAX web sites now introduce many additional requests for web contents to be updated dynamically. In this scenario there is need for web servers able to serve many clients at the same <b>time.</b> <b>Threads</b> are the ideal choice to handle many requests: they don’t need much resources and share the same memory among them. ...|$|R
5000|$|The {{implementation}} given here is incorrect. If {{a thread}} calls wait (...) after signal (...) {{has been called}} it may be stuck indefinitely, since signal (...) increments the semaphore only enough <b>times</b> for <b>threads</b> already waiting.|$|R
5000|$|Context switch <b>times</b> {{and other}} <b>thread</b> {{operations}} {{are free and}} have {{no impact on the}} model ...|$|R
40|$|Abstract—The {{validation}} of system models at the transaction-level typically relies on discrete event simulation. In {{order to reduce}} simulation time, parallel discrete event simulation (PDES) {{can be used by}} utilizing multiple cores available on today’s host PCs. However, the total order of time imposed by regular discrete event simulators becomes a bottleneck that severely limits the benefits of parallel simulation. In this article, we present a new out-of-order PDES technique for simulating transaction-level models on multi-core hosts. By localizing the simulation <b>time</b> to individual <b>threads</b> and carefully handling events at different times, a system model can be simulated following a partial order of time without loss of accuracy. Subject to advanced static analysis at compile time and table-based decisions at run <b>time,</b> <b>threads</b> can be issued early, reducing the idle time of available cores. Our proposed out-of-order PDES technique shows high performance gains in simulation speed with only a small increase in compile time. Using six embedded application examples, we also show the speed trade-off for multi-core PDES based on different multi-threading libraries. I...|$|R
40|$|SMT {{processors}} increase {{performance by}} executing instructions from several threads simultaneously. These threads use {{the resources of}} the processor better by sharing them but, at the same <b>time,</b> <b>threads</b> are competing for these resources. The way critical resources are distributed among threads determines the final performance. Currently, processor resources are distributed among threads as determined by the fetch policy that decides which threads enter the processor to compete for resources. However, current fetch policies only use indirect indicators of resource usage in their decision, which can lead to resource monopolization by a single thread or to resource waste when no thread can use them. Both situations can harm performance and happen, for example, after an L 2 cache miss. In this pape...|$|R
5000|$|Concurrent execution: in {{multiprocessor}} computers, {{a thread}} may be run {{at exactly the}} same <b>time</b> as another <b>thread</b> on a different CPU.|$|R
40|$|Abstract. We {{consider}} {{the problem of}} scheduling distributable real-time threads in networked embedded systems that operate under run-time uncertainties including those on <b>thread</b> execution <b>times,</b> <b>thread</b> arrivals, and node failure occurrences. We present a distributed scheduling algorithm called CUA. We show that CUA satisfies <b>thread</b> <b>time</b> constraints {{in the presence of}} crash failures, is early-deciding, has an efficient message complexity of O(fn) (where f is the number of crashes that actually occur and n is the number of nodes), and is time-optimal with a time lower bound of O(D + fd + nk) (where D is the message delay upper bound, d is the failure detection bound, and k is the maximum number of threads). In crash-free runs, the algorithm constructs schedules within O(D + nk), and yields optimal total utility if nodes are also not overloaded. The algorithm is also “best-effort ” in that a high importance thread that may arrive at any time has a very high likelihood for feasible completion (in contrast to classical admission control algorithms which favor feasible completion of admitted threads over admitting new ones, irrespective of thread importance). ...|$|R
40|$|Although {{for some}} people, faith or {{membership}} in a faith community is a life-long, unwavering endeavor, for others, such as this author, initial belief systems can crack and crumble into dust, leaving behind complicated memories that are overlaid with what feel like clearer and more real, contemporary understandings, although at <b>times</b> <b>threaded</b> with sorrow at loss of affiliation (Smith, 2011). This shift from believer to non-believer is nuanced and disquieting, and in many settings, may leave the new non-believer in a dangerous or vulnerable position (Berger, 2013) as an apostate. Informed by an unintentional, un-sought-after outsider, non-believer status, this autoethnographic article highlights the gradual process of falling-away, drawing from critical frameworks (Solórzano 2 ̆ 6 Yosso) intended to both problematize the author’s (my) positionality (Duffy, Weltsek, 2 ̆ 6 Marin, 2013) and speak {{to the idea of}} performed identity (Derrida, 2002) ...|$|R
50|$|Where Wbarrier is {{the wait}} <b>time</b> for a <b>thread,</b> Tbarrier {{is the number}} of threads has arrived, and Rthread is the arrival rate of threads.|$|R
5000|$|No {{matter what}} the {{intentions}} of the writing staff of General Hospital were at the <b>time,</b> the <b>thread</b> of Cole (and possibly Hope) being alive will not be picked up by the new online reboot of One Life to Live. Executive producer Jennifer Pepperman had the following to say when discussing the opportunity to bring back the characters: ...|$|R
50|$|One of {{the more}} {{controversial}} topics about asynchronous conferencing is that the discussion thread might get deleted. This can happen either due to technical failure or from avoidance and loss of interest from the participants. As most threads are managed according to their access <b>time,</b> those <b>threads</b> with older access time might be replaced by ones with new access time.|$|R
40|$|Communicated by Editor’s name The Real Time Specification for Java (RTSJ) is an {{augmentation}} of Java {{for real}} time applications of {{various degrees of}} hardness. The central features of RTSJ are real time threads; user defined schedulers; asynchronous events, handlers, and control transfers; a priority inheritance based default scheduler; non-heap memory areas such as immortal and scoped, and non-heap real <b>time</b> <b>threads</b> whose execution is not impeded by garbage collection. The Robust Software Systems group at NASA Ames Research Center has Java PathFinder (JPF) under development, a Java model checker. JPF at its core is a state exploring Java virtual machine (JVM) which can examine alternative paths in a Java program (e. g., via backtracking) by trying all nondeterministic choices, including thread scheduling order. This paper describes our implementation of an RTSJ profile (subset) in JPF, including requirements, design decisions, and current implementation status. Two examples are analyzed: jobs on a multiprogramming operating system, and a complex resource contention example involving autonomous vehicles crossing a...|$|R
30|$|The {{main issue}} with {{multithreading}} in real-time systems arises when the execution <b>time</b> of one <b>thread</b> {{depends on the}} state of a different thread. The main source of timing interactions in a CMP comes from shared caches and shared main memory. In the worst case, all latency hiding has to be ignored by the analysis and the sum of the execution <b>times</b> of several <b>threads</b> {{is the same as the}} serial execution on a single-threaded CPU. In addition, multithreaded processors usually share the level 1 caches. Therefore, each thread invalidates the abstract cache state of the other threads.|$|R
40|$|This paper {{explores the}} {{critical}} role of conversational threads in facilitating the ongoing, distributed work of one virtual organization. In studying the electronic mail exchanges of organizational members during one year, we found that they engaged {{in a range of}} threading activity to establish and maintain continuity, coherence, and coordination in their collaborative work over time. In particular, we found that organizational members relied on simple threads to focus their attention and action on a particular topic over a short period of <b>time,</b> concurrent <b>threads</b> to enable their participation in multiple topics at the same <b>time,</b> and compound <b>threads</b> to allow provisional settlement of key issues that were subsequently revisited over extended periods of time. We conclude by discussing the implications of conversational threads for research and practice of virtual organizin...|$|R
50|$|A lock convoy {{occurs when}} {{multiple}} threads of equal priority contend repeatedly {{for the same}} lock. Unlike deadlock and livelock situations, the threads in a lock convoy do progress; however, each <b>time</b> a <b>thread</b> attempts to acquire the lock and fails, it relinquishes the remainder of its scheduling quantum and forces a context switch. The overhead of repeated context switches and underutilization of scheduling quanta degrade overall performance.|$|R
50|$|Reorderings {{can come}} into play in {{incorrectly}} synchronized multithreaded programs, where one thread is able to observe the effects of other threads, and {{may be able to}} detect that variable accesses become visible to other threads in a different order than executed or specified in the program.Most of the <b>time,</b> one <b>thread</b> doesn't care what the other is doing. But when it does, that's what synchronization is for.|$|R
40|$|Abstract. The Real Time Specification for Java (RTSJ) is an {{augmentation}} of Java {{for real}} time applications of {{various degrees of}} hardness. The central features of RTSJ are real time threads; user defined schedulers; asynchronous events, handlers, and control transfers; a priority inheritance based default scheduler; non-heap memory areas such as immortal and scoped, and non-heap real <b>time</b> <b>threads</b> whose execution is not impeded by garbage collection. The Robust Software Systems group at NASA Ames Research Center has Java PathFinder (JPF) under development, a Java model checker. JPF at its core is a state exploring JVM which can examine alternative paths in a Java program (e. g., via backtracking) by trying all nondeterministic choices, including thread scheduling order. This paper describes our implementation of an RTSJ profile (subset) in JPF, including requirements, design decisions, and current implementation status. Two examples are analyzed: jobs on a multiprogramming operating system, and a complex resource contention example involving autonomous vehicles crossing an intersection. The utility of JPF in finding logic and timing errors is illustrated, and the remaining challenges in supporting all of RTSJ are assessed. ...|$|R
40|$|In {{previous}} work we defined a language (CCSL) made to express real-time temporal scheduling constraints. It uses {{the notion of}} partially independent logical clocks (or <b>time</b> <b>threads),</b> of which seemingly physical discrete time is a special case, hence the name Clock Constraint Specification Language. Constraints can represent (asynchronous) causality and precedence relations, or (synchronous) simultaneity ones. A solution {{to a set of}} such constraints is called a schedule, as it brings back all the clocks down to a single, totally ordered discrete time (and thus allows to timing events a schedule slot). In the current paper we study the formal semantics of CCSL, by translation into specific automata recognizing infinite sequences of clock steps. We consider the appropriate acceptance criteria for omega-languages (transition-based generalized Buchi), and motivate this choice. We also study how the automata can be minimized, by removing useless states (which is more than the usual check for emptiness of the whole language in classical model-checking approaches). We feel our work builds a definite link between the scheduling and the formal semantic model-checking communities...|$|R
