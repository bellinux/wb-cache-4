128|721|Public
500|$|These {{technical}} limitations forced Cerny {{to simplify}} the overall designs. Inspired by M. C. Escher, he designed abstract landscapes for the courses. In retrospect, Cerny partly attributed the designs to his limited artistic skills. He was {{a fan of the}} 3D graphics used in Battlezone and I, Robot, but felt that the visuals lacked definition and wanted to create a game with [...] "solid and clean" [...] 3D graphics. Unlike most other arcade games of the time, the course images were not drawn on the pixel level. Instead, Cerny defined the elevation of every point in the course, and stored this information in a heightmap array. The course graphics were then created by a ray <b>tracing</b> <b>program</b> that traced the path of light rays, using the heightmap to determine the appearance of the course on screen. This format also allowed Cerny to create shadows and use spatial anti-aliasing, a technique that provided the graphics with a smoother appearance. Cerny's course generator allowed him more time to experiment with the level designs. When deciding what elements to include in a course, practicality was a big factor; elements that would not work or would not appear as intended were omitted, such as an elastic barricade or a teeter-totter scale. Other ideas dropped from the designs were breakable glass supports, black hole traps, and bumps and obstacles built into the course that chased the marble.|$|E
5000|$|Kerkythea - free ray <b>tracing</b> <b>program</b> with {{enhanced}} Sketchup compatibility ...|$|E
5000|$|YafaRay is a free, {{open source}} ray <b>tracing</b> <b>program</b> that uses an XML scene {{description}} language. It has an addon for the 2.78 {{version of the}} 3D modelling software Blender.|$|E
50|$|The Leave No <b>Trace</b> State Advocate <b>Program</b> assists {{interested}} Leave No Trace {{educators and}} volunteers with their local {{effort to promote}} and teach minimum impact outdoor ethics. These active State Advocate volunteers are {{a key part of}} the Leave No <b>Trace</b> <b>program</b> because they coordinate outreach, education and training in their respective states. The State Advocates support volunteers with Leave No Trace training, increase on-the-ground awareness and attend events to further the Leave No <b>Trace</b> <b>program</b> and mission. The State Advocates have been instrumental in building communities of volunteers and educators, state-by-state.|$|R
40|$|Light can be coupled {{out of a}} {{waveguide}} to {{a focused}} point by a focusing grating coupler and has possible applications in optical data storage. The grating can be fabricated with either e-beam techniques or holographic techniques. Two design methods are demonstrated that model the focusing grating coupler with holographic optical elements. Both methods take a geometrical optics approach to designing the holographic optical elements and both methods make use of commercially available ray <b>trace</b> <b>programs.</b> The first method uses complicated non-rotationally symmetric construction optics and requires either a modified ray <b>trace</b> <b>program</b> or special user defined surfaces. The second method involves a much simpler approach which did not require any changes to an existing ray <b>trace</b> <b>program</b> and requires only rotationally symmetric elements to correct the aberrations...|$|R
50|$|RMI is {{a partner}} of the Leave No <b>Trace</b> <b>program</b> of the Center for Outdoor Ethics. Leave No Trace {{partners}} raise awareness of outdoor ethics.|$|R
5000|$|... ktrace is {{somewhat}} similar to Linux's strace, except for being much faster with strace, every system call {{executed by the}} traced program requires context switch to the <b>tracing</b> <b>program</b> and back, while the tracing with ktrace is actually performed by the kernel, so no additional context switches are required.|$|E
5000|$|The Persistence of Vision Ray Tracer, or POV-Ray, is a ray <b>tracing</b> <b>program</b> which generates {{images from}} a text-based scene description, and is {{available}} {{for a variety of}} computer platforms. It was originally based on DKBTrace, written by David Kirk Buck and Aaron A. Collins for the Amiga computers. There are also influences from the earlier Polyray raytracer contributed by its author Alexander Enzmann. POV-Ray is free and open-source software with the source code available under the AGPLv3.|$|E
50|$|This is {{essentially}} the same distribution that a path-tracing program would sample in tracing back one diffuse reflection step; or that a bidirectional ray <b>tracing</b> <b>program</b> would sample to achieve one forward diffuse reflection step when light source mapping forwards. The sampling approach therefore to some extent represents a convergence between the two techniques, the key difference remaining that the radiosity technique aims to build up a sufficiently accurate map of the radiance of all the surfaces in the scene, rather than just a representation of the current view.|$|E
30|$|Novice {{learners}} {{often fail}} to <b>trace</b> <b>programs</b> step by step because of insufficient understandings of statement sequencing and insufficient ability {{to keep track of}} program state.|$|R
40|$|A {{systematic}} {{performance analysis}} of aplanatic Cassegrainian telescopes {{has been accomplished}} {{by means of a}} ray <b>trace</b> <b>program.</b> The results indicate that the available field angle for a given geometric spot size is, to a very close approximation, a function of the relative back focal distance only. Image curvatures, as computed by third-order theory and by the ray <b>trace</b> <b>program,</b> were found to be in very close agreement. Image curvature is plotted {{as a function of the}} ray height ratio for a wide range of secondary magnification...|$|R
5000|$|March 21, 2010: Financial Industry Regulatory Authority (FINRA). BBGIDs {{accepted}} to uniquely identify securities reported to its U.S. Securities and Exchange Commission (SEC) mandated Trade Reporting And Compliance Engine (<b>TRACE)</b> <b>program.</b>|$|R
5000|$|Imagine was {{the name}} of a {{cutting-edge}} 3D modeling and ray <b>tracing</b> <b>program,</b> originally for the Amiga computer and later also for MS-DOS and Microsoft Windows. It was created by Impulse, Inc. It used the [...]iob extension for its objects. Imagine was a derivative of the software TurboSilver, which was also for the Amiga and written by Impulse. CAD-Technologies continued the distribution of the Amiga version. Starting with version 5.1, new updates were available for free for current customers as part of the Amiga Constant Upgrade Program (ACUP) up until presumed Imagine 6.0 release.|$|E
50|$|LuxRender {{is based}} on PBRT, a {{physically}} based ray <b>tracing</b> <b>program.</b> Although very capable and well structured, PBRT focuses on academic use and is not easily usable by digital artists. As PBRT is licensed under the BSD License, {{it was possible to}} start a new program based on PBRT's source code. With the blessings of the original authors, a small group of programmers took this step in September 2007. The new program was named LuxRender and was to focus on artistic use. Since its initial stage, the program has attracted a small handful of various programmers around the world.|$|E
5000|$|Adobe Streamline is a {{discontinued}} line <b>tracing</b> <b>program</b> {{developed and}} published by Adobe Systems. Its primary purpose is to convert scanned bitmaps into vector artwork. Streamline is similar in function to competitors, such as Corel Trace, but was advertised as a standalone rather than an additional utility within a full drawing suite. Streamline was discontinued after Adobe Illustrator CS2 introduced a new tracing tool entitled Live Trace, which provides fast tracing, fine control, {{as well as a}} [...] "live link" [...] to the bitmap being traced. A test of the native Illustrator 9 auto-trace function by Creative Pro in 2002 concluded: [...] "The premier tracing utility is StreamLine, which is infinitely controllable and very accurate." ...|$|E
40|$|Abstract—To improve {{software}} dependability, a {{large number}} of software engineering tools have been developed over years. Many of them are difficult to apply in practice because their system and library requirements are incompatible with those of the subject software. We propose a technique called platform independent executable trace. Our technique traces and virtualizes a regular program execution that is platform dependent, and generates a stand-alone <b>program</b> called the <b>trace</b> <b>program.</b> Run-ning the <b>trace</b> <b>program</b> re-generates the original execution. More importantly, <b>trace</b> <b>program</b> execution is completely independent of the underlying operating system and libraries such that it can be compiled and executed on arbitrary platforms. As such, it can be analyzed by a third party tool on a platform preferred by the tool. We have implemented the technique on x 86 and sensor platforms. We show that buggy executions of 10 real-world Windows and sensor applications can be traced and virtualized, and later analyzed by existing Linux tools. We also demonstrate how the technique can be used in cross-platform malware analysis. I...|$|R
40|$|This report {{describes}} {{the design and}} implementation {{of a set of}} tools for capturing and analysing <b>program</b> <b>traces</b> called Logrind 2. The tools are implemented as add-ons to the popular Valgrind and GDB debugging tools. <b>Program</b> <b>traces</b> are captured using dynamic instrumentation and stored in a relational database. Logrind 2 provides support for pretty-printing these traces in a clear and understandable format. The toolset also includes an extended SQL query language that ranges over <b>program</b> <b>traces.</b> Other tools may interface with Logrind 2 using this query language. The <b>program</b> <b>trace</b> schema supports multiple sources and can be used to compare runs of a program. Logrind 2 supports random access navigation of <b>program</b> <b>traces</b> using the concept of a <b>program</b> <b>trace</b> ’cursor’. Users may use this feature to examine the historical state of a process. <b>Program</b> <b>trace</b> capture using Logrind 2 was benchmarked using the BYTEmark benchmark program and the results are described in this report. The report also evaluates the <b>program</b> <b>trace</b> query language with a discussion of possible optimisations. ...|$|R
5000|$|<b>Program</b> <b>trace</b> ... Branch <b>tracing</b> {{compresses}} <b>program</b> execution data, by emitting messages at branch or exception instructions only. Trace analysis reconstructs {{the program}} flow using a local image of code memory contents.|$|R
5000|$|These {{technical}} limitations forced Cerny {{to simplify}} the overall designs. Inspired by M. C. Escher, he designed abstract landscapes for the courses. In retrospect, Cerny partly attributed the designs to his limited artistic skills. He was {{a fan of the}} 3D graphics used in Battlezone and I, Robot, but felt that the visuals lacked definition and wanted to create a game with [...] "solid and clean" [...] 3D graphics. Unlike most other arcade games of the time, the course images were not drawn on the pixel level. Instead, Cerny defined the elevation of every point in the course, and stored this information in a heightmap array. The course graphics were then created by a ray <b>tracing</b> <b>program</b> that traced the path of light rays, using the heightmap to determine the appearance of the course on screen. This format also allowed Cerny to create shadows and use spatial anti-aliasing, a technique that provided the graphics with a smoother appearance. Cerny's course generator allowed him more time to experiment with the level designs. When deciding what elements to include in a course, practicality was a big factor; elements that would not work or would not appear as intended were omitted, such as an elastic barricade or a teeter-totter scale. Other ideas dropped from the designs were breakable glass supports, black hole traps, and bumps and obstacles built into the course that chased the marble.|$|E
5000|$|One {{feature of}} most escape time fractal {{programs}} or algebraic-based fractals is a maximum iteration setting. Increasing the iteration count is required if {{the image is}} magnified so that fine detail is not lost. Limiting the maximum iterations is important when a device's processing power is low. Coloring options often allow colors to be randomised. Options for color density are common because some gradients output hugely variable magnitudes resulting in heavy repetitive banding or {{large areas of the}} same color. Because of the convenient ability to add post-processing effects layering and alpha compositing features found in other graphics software have been included. Both 2D and 3D rendering effects such as plasma effect and lighting may be included. Many packages also allow the user to input their own formula, to allow for greater control of the fractals, as well as a choice of color rendering, along with the use of filters and other image manipulation techniques. Some fractal software packages allow for the creation of movies from a sequence of fractal images. Others display render time and allow some form of color cycling and color palette creation tools.Standard graphics software (such as GIMP) contains filters or plug-ins which can be used for fractal generation. Blender contains a fractal (or random) modifier. Many stand-alone fractal-generating programs can be used in conjunction with other graphics programs (such as Photoshop) to create more complex images. POV-Ray is a ray <b>tracing</b> <b>program</b> which generates images from a text-based scene description that can generate fractals. Scripts on 3ds Max and Autodesk Maya can be used. A number of web-based interfaces for the fractal generation are freely available including Turtle Graphics Renderer. Fractal Lab can generate both 2D and 3D fractals and is available over the web using WebGL. JWildfire is a java-based, open-source fractal flame generator. [...] Mandelbrot Fractal is a fractal explorer written in Javascript. [...] Fractal Grower is software written in Java for generating Lindenmayer Substitution Fractals (L-systems).|$|E
40|$|NASA's current {{predictive}} capabilities {{using the}} ray <b>tracing</b> <b>program</b> (RTP) are validated using helicopter noise data taken at Eglin Air Force Base in 2007. By including refractive propagation effects due to wind and temperature, the ray tracing code {{is able to}} explain large variations in the data observed during the flight test...|$|E
40|$|We {{present an}} {{effective}} dynamic analysis for finding a broad class of deadlocks, including the well-studied lock-only deadlocks {{as well as}} the less-studied, but no less widespread or insidious, deadlocks involving condition variables. Our analysis consists of two stages. In the first stage, our analysis observes a multi-threaded program execution and generates a simple multi-threaded <b>program,</b> called a <b>trace</b> <b>program,</b> that only records operations observed during the execution that are deemed relevant to finding deadlocks. Such operations include lock acquire and release, wait and notify, thread start and join, and change of values of user-identified synchronization predicates associated with condition variables. In the second stage, our analysis uses an off-the-shelf model checker to explore all possible thread interleavings of the <b>trace</b> <b>program</b> and check if any of them deadlocks. A key advantage of our technique is that it discards most of the program logic which usually causes state-space explosion in model checking, and retains only the relevant synchronization logic in the <b>trace</b> <b>program,</b> which is sufficient for finding deadlocks. We have implemented our analysis for Java, and have applied it to twelve real-world multi-threaded Java programs. Our analysis is effective in practice, finding thirteen previously known as well as four new deadlocks...|$|R
30|$|As {{configured}} by the Driver, Intel PT notifies the Driver via a Performance Monitoring Interrupt (PMI) {{when the}} Trace Buffer becomes overloaded (Step 6 a). The processor pauses the <b>traced</b> <b>program</b> execution and switches to the PMI handler. The PMI handler invokes the Trace Analyzer (Step 6 b).|$|R
40|$|In many {{introductory}} programming courses, {{students are}} urged to <b>trace</b> <b>programs</b> in a textbook {{to see if they}} understand how the programs work. In addition, students may have to <b>trace</b> simple <b>programs</b> on a test (a typical question calls for a display of a program 2 ̆ 7 s output). As a student confronts more and more complex language features, and as examples become more lengthy, the tracing idea seems to fall by the wayside. We expect a student to understand complex programs, but we don 2 ̆ 7 t seem to offer any practical guidance about how this understanding may be achieved...|$|R
40|$|Abstract—we {{reported}} here tasks we accomplished {{to improve the}} 2 D curve tracing algorithm: 1) Optimized individual steps in the <b>tracing</b> <b>program</b> with tools {{from the field of}} digital image processing; 2) Implemented training sets and evaluation conditions that teach the program to look for parameters that fit a wide variety of data quality...|$|E
40|$|The Alpha Magnetic Spectrometer detects a {{large amount}} of {{particles}} below rigidity cutoff. Those high energy particles create questions related to radiation belts and atmospheric neutrinos. To understand the origin of these particles, we use a trajectory <b>tracing</b> <b>program</b> to simulate particle trajectories in realistic geomagnetic field. The complex behaviors and large e + /e − are explained here. ...|$|E
40|$|We {{study the}} {{relation}} between antenna spacing and capacity of MIMO channels for indoor environments using a ray <b>tracing</b> <b>program.</b> It has been confirmed also by measurements that in rich scattering environments an antenna spacing below 0. 5 lambda is sufficient to reach nearly the full capacity predicted for multiple-antenna arrays in ideal and uncorrelated Rayleigh fading channels...|$|E
5000|$|Class 2 adds {{ownership}} <b>trace</b> and <b>program</b> <b>trace</b> {{and allows}} the auxiliary debugging port to be shared with [...] "slow" [...] I/O port pins. Ownership trace allows current task or current process trace for systems based on real-time kernels or operating-systems.|$|R
50|$|<b>Program</b> <b>Trace</b> Query Language (PTQL) is a {{language}} based on relational queries over <b>program</b> <b>traces,</b> in which programmers can write expressive, declarative queries about program behavior.|$|R
50|$|REFUNITE {{was founded}} in 2008 by two Danish brothers, David and Christopher Mikkelsen, after their {{personal}} journey trying to reconnect a young, Afghan refugee with his family. In their search, the two brothers discovered that existing family <b>tracing</b> <b>programs</b> lacked cross-border, collaborative technology {{and the process of}} family tracing was also often tied to cumbersome procedures and paperwork.|$|R
40|$|This report {{describes}} {{the generation of}} synthetic stereo image pairs and a cyclopean depth map using the ray <b>tracing</b> <b>program</b> PoVRay. A ray <b>tracing</b> <b>program</b> produces simulated snapshots of a 3 D model, one pixel at a time, by tracing rays backwards from the viewpoint through the image and into the scene. If a ray strikes an object in the scene, the image pixel through which it passed is painted with the colour of that object; otherwise, the image pixel is painted with the colour of the background. By offsetting the viewpoint {{to the left and}} right of a central position, it’s possible to generate stereo image pairs. These can be combined with a central depth view, in which pixel intensity is proportional to distance from the viewpoint, by adding fog to the environment. Since the three views are rendered with the same perspective projection, they are in perfect correspondence...|$|E
40|$|In this work, we {{have created}} a {{realistic}} model of a solar tracker using Mayavi: 3 D scientific data visualization and plotting in Python, Enthought Canopy:a comprehensive Python analysis environment and Persistence of Vision Ray Tracer, or POV-Ray, a ray <b>tracing</b> <b>program</b> which generates photo-realistic images from a text-based scene description, {{a model of the}} solar tracker was also 3 D printed...|$|E
40|$|We {{designed}} and implemented a traffic accident analysis system (TAAS) in the paper. TAAS {{is the system}} faced traffic accident analysis, which uses the traffic rules (law) as knowledge sources to judge if the driver is responsible for a traffic accident. TAAS has characteristics of separating knowledge base and inference engine, using production rule and backward chaining. Besides, TAAS used predefined text and <b>tracing</b> <b>program</b> to realize explanation mechanism. <br /...|$|E
40|$|A {{system is}} {{presented}} for ray tracing trimmed NURBS surfaces. While approaches to components are drawn largely from existing literature, their combination {{within a single}} framework is novel. This paper also differs from prior work in that the details of an efficient implementation are fleshed out. Throughout, {{emphasis is placed on}} practical methods suitable to implementation in general ray <b>tracing</b> <b>programs.</b> 1 Introduction The modeling community has embraced trimmed NURBS as a primitive of choice. The result has been a rapid proliferation in the number of models utilizing this representation. At the same time, ray tracing has become a popular method for generating computer graphics images of geometric models. Surprisingly, most ray <b>tracing</b> <b>programs</b> do not support the direct use of untessellated trimmed NURBS surfaces. The direct use of untessellated NURBS is desirable because tessellated models increase memory use which can be detrimental to runtime efficiency on modern architectures. [...] ...|$|R
40|$|A {{system is}} {{presented}} for ray tracing trimmed NURBS surfaces. While approaches to components are drawn largely from existing literature, their combination {{within a single}} framework is novel. This paper also differs from prior work in that the details of an efficient implementation are fleshed out. Throughout, {{emphasis is placed on}} practical methods suitable to implementation in general ray <b>tracing</b> <b>programs.</b> ...|$|R
30|$|A 1. The student {{consumed}} {{sufficient time}} (more than 3  min) <b>tracing</b> the <b>program</b> (Ex 1).|$|R
