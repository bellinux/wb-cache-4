5|10000|Public
40|$|An {{enhanced}} document {{responds to}} its reader in non-traditional ways: a button press may scroll the document, play music, [...] .. Although such operations may be implemented as objects embedded in text, full generality requires that {{a programming language}} {{be available to the}} author of a document. This paper sketches the problems of embedding programs in documents and reviews the solutions adopted in the Ness component of the Andrew ToolKit. A key question is the connection from user actions <b>to</b> <b>program</b> <b>functions.</b> Other questions include the appropriate level of programming language, its string processing capabilities, and security...|$|E
40|$|Supporting the {{programming}} of stateful packet forwarding functions in hardware has recently attracted {{the interest of}} the research community. When designing such switching chips, the challenge is to guarantee the ability <b>to</b> <b>program</b> <b>functions</b> that can read and modify data plane's state, while keeping line rate performance and state consistency. Current state-of-the-art designs are based on a very conservative all-or-nothing model: programmability is limited only to those functions that are guaranteed to sustain line rate, with any traffic workload. In effect, this limits the maximum time to execute state update operations. In this paper, we explore possible options to relax these constraints by using simulations on real traffic traces. We then propose a model in which functions can be executed in a larger but bounded time, while preventing data hazards with memory locking. We present results showing that such flexibility can be supported with little or no throughput degradation. Comment: 6 page...|$|E
40|$|Abstract: An {{enhanced}} document {{responds to}} its reader in non-traditional ways: a button press may scroll the document, play music [...] . Although such operations may be implemented as objects embedded in text, full generality requires that {{a programming language}} {{be available to the}} author of a document. This paper sketches the problems of embedding programs in documents and reviews the solutions adopted in the Ness component of the Andrew ToolKit. A key question is the connection from user actions <b>to</b> <b>program</b> <b>functions.</b> Other questions include the appropriate level of programming language, its string processing capabilities, and security. Traditionally a computer document is an emulation of a paper one; it sits there for the reader to explore at will. This present paper is no different because even though I am writing it on a computer I expect most readers will view it on paper. But suppose you were reading it at a computer; how much more could it do? Simulations, calculations, interactive examples, waving flags, music, fireworks? The report below describes a system in which it is possible to write documents that have most of these behaviors. In order to provide the most general environment, the system incorporates a programming language, Ness, the design of which has been kept simple so as to reach a broad range of authors. The underlying system is the Andrew ToolKit (ATK). Typical applications of such a system includ...|$|E
5000|$|... 9 Lens presets per {{user profile}} <b>to</b> improve <b>program</b> <b>functions</b> for non-CPU lenses and to include Exif {{information}} ...|$|R
5000|$|In {{addition}} to graphics and sound commands, Graphics BASIC also provides various other useful commands such as [...] {{to list the}} file directory of a device, [...] to return {{the position of a}} joystick, [...] <b>to</b> <b>program</b> <b>function</b> keys, [...] <b>to</b> renumber the current program line numbers. Graphics BASIC also added an [...] command to perform error capturing, a [...] command that allowed variables to be passed to subroutines, and added [...] to the [...] command.|$|R
2500|$|The {{primary test}} {{utilized}} in comparing computer programs, the [...] "abstraction-filtration-comparison test" [...] is also called more simply the [...] "filtration test". The test, which was devised by the U.S. Court of Appeals for the Second Circuit for Computer Associates International, Inc. v. Altai, Inc., compares {{the elements of}} software at increasing levels of abstraction, from machine instructions <b>to</b> <b>program</b> <b>function,</b> excluding those elements not copyrightable, such as those approaches dictated by efficiency or the fundamental operation of computers, to evaluate similarity.|$|R
40|$|Application {{programming}} {{is important and}} the ability to program and troubleshoot programs, generally in “C” {{is an essential part of}} many positions for engineers, technologists, and technicians. Instruction in programming microcontrollers (uC) and Digital Signal Processors (DSP) are needed in a baccalaureate EET/CPET program, but fitting an appropriate mix into a curriculum is difficult when limited to 120 credit hours by state mandate. A solution is to use a progression of courses to cover a variety of uCs and a DSP chip and their associated “C” programming. These courses are not new, but have been gradually upgraded so there is an increasingly more complex sequence of uC’s and modern measurement/control methods. The initial, required 8 -bit uC course introduces students to assembly language programming but primarily provides a fundamental ability to write and debug “C” programs used for interfacing. Common input/output devices such as LED’s, multiple 7 -segment displays, a keypad, an LCD, and a serial/USB interface are covered and used in the labs. The second course provides an introduction to control systems and uses 8 and 16 -bit uCs to interface with transducers. The third course is an elective that uses a 32 -bit, ARM, M 4 uC to interface with devices including a nocontact temperature sensor, an infrared light sensor, a color graphic LCD, a touch sensor, and an 8 x 8 LED array. The fourth course uses a 16 -bit, fixed-point, DSP board <b>to</b> <b>program</b> <b>functions</b> including filtering of audio input from a student’s cellphone with the resulting output, to earbuds...|$|E
40|$|NASA Engineering's Orion Script Generator (OSG) is {{a program}} {{designed}} to run on Exploration Flight Test One Software. The script generator creates a SuperScript file that, when run, accepts the filename for a listing of Compact Unique Identifiers (CUIs). These CUIs will correspond to different variables on the Orion spacecraft, such as the temperature of a component X, the active or inactive status of another component Y, and so on. OSG will use a linked database to retrieve the value for each CUI, such as " 100 05," "True," and so on. Finally, OSG writes SuperScript code to display each of these variables before outputting the ssi file that allows recipients to view a graphical representation of Orion Flight Test One's status through these variables. This project's main challenge was creating flexible software that accepts and transfers many types of data, from Boolean (true or false) values to "Unsigned Long Long'' values (any number from 0 to 18, 446, 744, 073, 709, 551, 615). We also needed to allow bit manipulation for each variable, requiring us <b>to</b> <b>program</b> <b>functions</b> that could convert any of the multiple types of data into binary code. Throughout the project, we explored different methods to optimize the speed of working with the CUI database and long binary numbers. For example, the program handled extended binary numbers much more efficiently when we stored them as collections of Boolean values (true or false representing 1 or 0) instead of as collections of character strings or numbers. We also strove to make OSG as user-friendly and accommodating of different needs as possible its default behavior is to display a current CUI's maximum value and minimum value with three to five intermediate values in between, all in descending order. Fortunately, users can also add other input on the same lines as each CUI name to request different high values, low values, display options (ascending, sine, and so on), and interval sizes for generating intermediate values. Developing input validation took up quite a bit of time, but OSG's flexibility in the end was worth it...|$|E
50|$|The PLI {{provides}} a programmer with {{a mechanism to}} transfer control from Verilog <b>to</b> a <b>program</b> <b>function</b> written in C language. It is officially deprecated by IEEE Std 1364-2005 {{in favor of the}} newer Verilog Procedural Interface, which completely replaces the PLI.|$|R
50|$|Apex is a {{proprietary}} programming language {{provided by the}} Force.com platform to developers similar to Java and C#. It is a strongly typed, object-oriented, case-insensitive programming language, following a dot-notation and curly-brackets syntax. Apex can be used <b>to</b> execute <b>programmed</b> <b>functions</b> during most processes on the Force.com platform including custom buttons and links, event handlers on record insertion, update, or deletion, via scheduling, or via the custom controllers of Visualforce pages.|$|R
50|$|In {{the late}} 1960s, {{high-level}} languages such as PL/S, BLISS, BCPL, extended ALGOL (for Burroughs large systems) and C included {{some degree of}} access <b>to</b> low-level <b>programming</b> <b>functions.</b> One method for this is Inline assembly, in which assembly code is embedded in a high-level language that supports this feature. Some of these languages also allow architecture-dependent compiler optimization directives to adjust the way a compiler uses the target processor architecture.|$|R
25|$|A {{computer}} {{program is a}} collection of instructions that performs a specific task when executed by a computer. A computer requires <b>programs</b> <b>to</b> <b>function</b> and typically executes the program's instructions in a central processing unit.|$|R
40|$|The {{problem of}} multiprogram {{scheduling}} {{on a single}} processor is studied {{from the viewpoint of}} the characteristics peculiar <b>to</b> the <b>program</b> <b>functions</b> that need guaranteed service. It is shown that an optimum fixed priority scheduler possesses an upper bound to processor utilization which may be as low as 70 percent for large task sets. It is also shown that full processor utilization can be achieved by dynamically assigning priorities {{on the basis of their}} current deadlines. A combination of these two scheduling techniques is also discussed...|$|R
50|$|ASOCS Ltd. is {{a privately}} held company, {{develops}} and markets multi-core processors that enable software <b>to</b> <b>program</b> physical layer <b>functions</b> and algorithms. ASOCS is headquartered in Rosh Ha'ayin, Israel. The company provides solutions for C-RAN, multi-communication mobile devices, {{machine to machine}} (M2M) communication and the first responders homeland security markets.|$|R
40|$|Testimony {{issued by}} the General Accounting Office with an {{abstract}} that begins "Pursuant to a congressional request, GAO discussed the readiness of Social Security Administration's (SSA) computer systems that support key benefits <b>programs</b> <b>to</b> <b>function</b> reliably in the next century, focusing on GAO's previous report and recommendations. ...|$|R
30|$|In 1992, John Koza used genetic {{algorithms}} (GA) <b>to</b> automatically generate <b>programs</b> for accomplishing specific tasks, such as solving mathematical expressions. The author baptized the method as Genetic Programming (GP). In GP, syntax trees contain function or terminal nodes <b>to</b> represent the <b>programs.</b> <b>Functions</b> can be arithmetic, Boolean, conditional, iteration-related, recursion-related, {{in addition to}} domain-specific functions for the problem in question. Terminals are variables or constants. Therefore, GP is a GA specialization {{in the domain of}} manipulating computer programs.|$|R
50|$|RFC-supported and GUI-supported {{interfaces}} {{can be used}} {{by external}} <b>programs</b> <b>to</b> call <b>function</b> modules in SAP systems, and execute them in these systems. Likewise, ABAP programs can also use these interfaces to use functions supplied by external programs.|$|R
40|$|Abstract. Being able <b>to</b> analyze <b>programs</b> <b>function</b> by function, or module by module {{is a key}} {{ingredient}} to scalable static analyses. The main difficulty for modular static analysis {{is to be able}} to do so while not losing too much precision. In this paper, we present a new summarybased approach that builds on previous work of the authors, a zonotopic functional abstraction, that is economical both in space and time complexity. This approach has been implemented, and experiments on numerical programs, reported here, show that this approach is very efficient, and that we still obtain precise analyses in realistic cases. ...|$|R
40|$|In {{this paper}} we {{describe}} a modelling project to improve a nuclear waste management program {{in charge of}} {{the creation of a new}} system for the permanent disposal of nuclear waste. SADT (Structured Analysis and Design Technique) is used in order to provide a work-flow description of the functions to be performed by the waste management program. This description is then translated into a number of Coloured Petri Nets (CPN or CP-nets) corresponding <b>to</b> different <b>program</b> <b>functions</b> where additional behavioural inscriptions provide basis for simulation. Each of these CP-nets is simulated to produce timed event charts that are useful for understanding the behaviour of the <b>program</b> <b>functions</b> under different scenarios. Then all the CPN models are linked together to form a single stand-alone application that is useful for validating the interaction and cooperation between the different <b>program</b> <b>functions.</b> A technique for linking executable CPN models is developed for supporting large modelling pro [...] ...|$|R
40|$|HP Labs has {{developed}} a software platform, called MUMS, for moderating economics games between human and/or robot participants. The primary feature of this platform is a flexible scripting language that allows a researcher to implement any economics games in a relative short time. This scripting language eliminates the need <b>to</b> <b>program</b> low-level <b>functions</b> such as networking, databases and interface components. The scripts are description of games including definitions of roles, timing rules, the game tree (in a stage format), input and output (with respect to a role, not client software) ...|$|R
50|$|Vuze is {{categorized}} as adware by Softpedia, {{due to its}} inclusion of a Vuze Toolbar for web browsers. Vuze changes or offers to change home page and search and to install a promotional component not necessary for the <b>program</b> <b>to</b> <b>function.</b> In February 2010, What.CD and Waffles.fm, two large music sharing sites at the time, decided to ban the use of Vuze.|$|R
5000|$|The Java {{platform}} {{was developed}} at Sun {{in the early}} 1990s {{with the objective of}} allowing <b>programs</b> <b>to</b> <b>function</b> regardless of the device they were used on, sparking the slogan [...] "Write once, run anywhere" [...] (WORA). While this objective was not entirely achieved (prompting the riposte [...] "Write once, debug everywhere"), Java is regarded as being largely hardware- and operating system-independent.|$|R
5000|$|Schools for Schools {{is one of}} {{the first}} {{fundraising}} <b>programs</b> <b>to</b> <b>function</b> using an alive interactive website.When a school in the West registers on the site, it is assigned to one of 10 [...] "clusters," [...] each of which is partnered with a specific school in northern Uganda. The goal of each school cluster is to raise as much money as possible for its partner Ugandan school.|$|R
50|$|A buffer {{overflow}} {{occurring in the}} heap data area {{is referred to as}} a heap overflow and is exploitable in a manner different from that of stack-based overflows. Memory on the heap is dynamically allocated by the application at run-time and typically contains program data. Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers. The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as malloc meta data) and uses the resulting pointer exchange <b>to</b> overwrite a <b>program</b> <b>function</b> pointer.|$|R
40|$|Main {{elements}} of a computer system for analysis of X-ray images of wheat grains are outlined in the paper. In particular a specially developed software package (named GRAINS) for visualisation of grain images and for aiding kernel quality assessment analyses is presented. The package works in Windows 95 programming environment and has a menu driven user interface so enabling quick and easy access <b>to</b> all <b>program</b> <b>functions.</b> The <b>program</b> workplace enables simultaneous display of va- rious objects processed in the package, i. e., images, graphics, text documents, and spreadsheets. Main program capabilities include: loading and displaying X-ray grain images, measurements of main geometrical features and statistical parameters of grain images, quantitative assessment {{of the quality of}} grain kernels by calculating positional damage indices, and generation of binary and text report files...|$|R
2500|$|In Microsoft Windows, $ is {{appended}} to {{the share}} name {{to hide a}} shared folder or resource. For example, [...] "\\server\share" [...] will be visible to other computers on a network, while [...] "\\server\share$" [...] will be accessible only by explicit reference. Hiding a shared folder or resource will not alter its access permissions but may render it unaccessible <b>to</b> <b>programs</b> or other <b>functions</b> which rely on its visibility. Most administrative shares are hidden in this way.|$|R
2500|$|A buffer {{overflow}} {{occurring in the}} heap data area {{is referred to as}} a heap overflow and is exploitable in a manner different from that of stack-based overflows. [...] Memory on the heap is dynamically allocated by the application at run-time and typically contains program data. [...] Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers. [...] The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as malloc meta data) and uses the resulting pointer exchange <b>to</b> overwrite a <b>program</b> <b>function</b> pointer.|$|R
40|$|This paper {{describes}} a quantum programming environment, named Q|SI〉. It is a platform embedded in the. Net language that supports quantum programming using a quantum {{extension of the}} while-language. The framework of the platform includes a compiler of the quantum while-language and a suite of tools for simulating quantum computation, optimizing quantum circuits, and analyzing and verifying quantum programs. Throughout the paper, using Q|SI〉 to simulate quantum behaviors on classical platforms {{with a combination of}} components is demonstrated. The scalable framework allows the user <b>to</b> <b>program</b> customized <b>functions</b> on the platform. The compiler works as the core of Q|SI〉 bridging the gap from quantum hardware to quantum software. The built-in decomposition algorithms enable the universal quantum computation on the present quantum hardware. Comment: 30 pages, software available at [URL]...|$|R
40|$|Abstract. We use ℓinSolos (i. e. a typed process {{calculus}} {{based on}} the calculus of solos) in order to express computational processes generated by SℓPCF −, namely a simple programming language conceived in order <b>to</b> <b>program</b> only linear <b>functions.</b> We define a faithful translation of SℓPCF − on ℓinSolos which make us able to process redexes of SℓPCF − in a parallel way. Afterward, we prove that a suitable observational equivalence between processes is correct w. r. t the operational semantics of SℓPCF −, via our interpretation...|$|R
40|$|Abstract. We {{present an}} {{approach}} <b>to</b> <b>program</b> repair and its applica-tion <b>to</b> <b>programs</b> with recursive <b>functions</b> over unbounded data types. Our approach formulates program repair {{in the framework}} of deductive synthesis that uses existing program structure as a hint to guide synthe-sis. We introduce a new specification construct for symbolic tests. We rely on such user-specified tests as well as automatically generated ones to localize the fault and speed up synthesis. Our implementation is able to eliminate errors within seconds from a variety of functional programs, including symbolic computation code and implementations of functional data structures. The resulting programs are formally verified by the Leon system. ...|$|R
40|$|Ensemble ReST is a {{software}} system that eases the development, deployment, {{and maintenance of}} server-side application <b>programs</b> <b>to</b> perform <b>functions</b> {{that would otherwise be}} performed by client software. Ensemble ReST takes advantage of the proven disciplines of ReST (Representational State Transfer. ReST leverages the standardized HTTP protocol to enable developers to offer services to a diverse variety of clients: from shell scripts to sophisticated Java application suite...|$|R
40|$|The informational {{program which}} is {{presented}} in this work {{has the advantage of}} choosing the raw materials that compound the blend, function of the compounds' cost, but it is taking also into account the basic laws of the blending (the relation between the diameters and the average lengths of the compounds). All these will have as a result the reducing of the raw materials consume and also it drops the waste percentage from the technological processes. In order <b>to</b> verify the <b>program's</b> <b>functioning,</b> the quality characteristics of the raw materials and their cost had been taken from the analyses bulletins and from bills and introduced in the tables which are the program's database...|$|R
40|$|The {{template}} of primitive-recursion (PR) {{is powerful}} enough <b>to</b> <b>program</b> all <b>functions</b> of interest, {{but very few}} natural algorithms. Indeed, PR is justified by induction on a single argument, whereas most algorithms are seen to terminate by induction on measures which are rarely as trivial as the size of one particular input value. We explore here a framework for crafting terminating functional programs, that extends primitive-recursion while preserving its methodological benefits. In particular, we allow inductive measures, dubbed scales, that may involve several arguments, and may be different for each function. In addition, to permit such measures to refer to previously defined functions, we associate with each function an index, which carries a rough bound on the function’s size-changing behavior. As a functional program is incrementally developed, scales are used to guarantee termination (given previous indices), and new indices are computed from previous ones, for future use...|$|R
50|$|Link time connects {{all of the}} {{necessary}} machine code components of a program, including externals. It is very common for <b>programs</b> <b>to</b> use <b>functions</b> implemented by external libraries, all of which must be properly linked together. There {{are two types of}} linking. Static linking is when the connection is made by the compiler, which is always prior to execution. Dynamic linking, however, is performed by the OS just before, or even during, execution.|$|R
40|$|Within {{the setting}} of the {{categorical}} approach <b>to</b> <b>programming</b> with total <b>functions,</b> a "many-in-one" recursion scheme is introduced that neatly unifies a variety of recursion schemes looking as diverging generalizations of the basic recursion scheme of iteration. The scheme is doubly generic: in addition to behaving uniformly with respect to a functor determining an inductive type, it is also uniform in a comonad and a distributive law which together determine a particular recursion scheme for this inductive type. By way of examples, it is shown to subsume iteration, a scheme subsuming primitive recursion, and a scheme subsuming course-of-value iteration...|$|R
50|$|An {{aspect of}} a program is a feature linked to {{many other parts of}} the program, but which is not related <b>to</b> the <b>program's</b> primary <b>function.</b> An aspect crosscuts the program's core concerns, {{therefore}} violating its separation of concerns that tries to encapsulate unrelated functions. For example, logging code can crosscut many modules, yet the aspect of logging should be separate from the functional concerns of the module it cross-cuts. Isolating such aspects as logging and persistence from business logic is the aim of aspect-oriented software development (AOSD), of which the aspect-oriented programming (AOP) paradigm is the most widely employed.|$|R
