0|503|Public
40|$|A coupled CFD/rotor {{dynamics}} modeling {{approach is}} presented {{for the analysis}} of realistic transient behavior of a height-normalized, three-straight-bladed VAWT subject to inertial effects of the rotor and generator load which is manipulated by a feedback control under standardized wind gusts. The model employs the k-ε turbulence model to approximate unsteady Reynolds-averaged Navier-Stokes equations and is validated with data from field measurements. As distinct from related studies, here, the angular velocity is calculated from the rotor's equation of motion; thus, the dynamic response of the rotor is taken into account. Results include the following: First, the rotor's inertia filters large amplitude oscillations in the wind torque owing to the first-order dynamics. Second, the generator and wind torques differ especially during wind transients subject to the conservation of angular momentum of the rotor. Third, oscillations of the power coefficient exceed the Betz limit temporarily due to the energy storage in the rotor, which acts as a <b>temporary</b> <b>buffer</b> that <b>stores</b> the kinetic energy like a flywheel in short durations. Last, average of transient power coefficients peaks at a smaller tip-speed ratio for wind gusts than steady winds...|$|R
40|$|We often meet {{temporary}} storage of semi-product {{in the production}} <b>buffer</b> <b>stores</b> in industrial companies. These <b>buffer</b> <b>stores</b> are located either directly in production halls or near them. One {{of the questions that}} resonate in practice is size-capacity of storage places and dimensions of <b>buffer</b> <b>stores.</b> Here is presented the simulation model in the paper, which simulates the number of incoming and outgoing semi-products in the production <b>buffer</b> <b>store,</b> by which we can determine the number of stored semi-product in a certain period of time. The simulation model is created for four types of semi-products, which have fixed times of storage that resulting from technological process of the production. The simulation model was created by using EXTEND program. The outputs of the model are presented in the paper. The simulation results {{can be used as a}} supporting tool at determining the storage capacity, and at optimizing storage locations...|$|R
30|$|During the {{execution}} of the parallel part, the nodes compute the image parts in parallel by using POV-Ray. The size S_B of the <b>temporary</b> <b>buffer</b> of POV-Ray is calculated by Eq. (1) for a specific XY resolution.|$|R
30|$|For {{resolution}} 400 × 300, the <b>temporary</b> <b>buffer</b> of POV-Ray is 4, 800, 000  Bytes in size. Due to {{the small}} problem size, using eight nodes instead of four nodes does not reduce, but increase the required runtime.|$|R
50|$|Because of the {{cassette}} system's flexibility and high payload capacity, it's possible to achieve relatively large material flow across process points and warehouses. Bulk material producers (steel industry etc.) are {{also able to}} use cassettes as a <b>temporary</b> <b>buffer</b> for warehouses.|$|R
50|$|During World War II, when Romania, {{aided by}} Nazi Germany, {{for the first}} time in history took control of Transnistria, it made no {{attempts}} to annex the occupied territory and considered it a <b>temporary</b> <b>buffer</b> zone between Greater Romania and the Soviet front line.|$|R
5000|$|Strong {{exception}} safety: Can {{be implemented}} fairly easily by doing any allocation {{first and then}} copying into a <b>temporary</b> <b>buffer</b> that is eventually swapped if no errors are encountered. In this case, insertion of [...] into [...] will either succeed, or [...] will remain unchanged.|$|R
50|$|Linear feeders: Horizontal {{conveying}} of components. Used {{to handle}} irregular supplies of parts from upstream equipment, creating a <b>buffer</b> <b>store</b> and smooth flow for further processes. Special application: Multi-track design.|$|R
3000|$|The “feedback-full" [...] {{algorithms}} {{also differ}} {{with respect to}} the way the feedback must be presented to them: the input data items must be supplied sequentially or in batch (see Fig. 2). In the second case, the raw data that is collected is <b>temporary</b> <b>buffered</b> and is supplied to the change detection algorithm only after the buffer is full.|$|R
3000|$|..., and {{normalized}} {{subcarrier spacing}} Q) just by using simple {{digital signal processing}} blocks such as up/down-sampling converters, filters, and sample delays. As already mentioned, no complicated circular shifts, <b>temporary</b> <b>buffers,</b> or memory swapping operations are required, which means a considerable simplification of those FBMC implementations where Q is rational, which have been commonly ignored by the research community.|$|R
2500|$|Batch: The {{recordset}} {{is locked}} using adLockBatchOptimistic {{and each time}} Update is called the data are updated in a <b>temporary</b> <b>buffer.</b> Finally, when UpdateBatch is called the data are completely updated back at the data source. This {{has the advantage of}} it all being done in memory, and if a problem occurs then UpdateCancel is called and the updates are not sent to the data source ...|$|R
30|$|A buffer {{family is}} a {{collection}} of circular <b>buffers</b> which <b>store</b> time series data for a single variable. The variable can either be {{in the form of a}} floating point value or a string. The former is used for performance data, resource usage and statistics while the latter is use for representing service check results, logs, events and other non numeric data. In both cases the buffer family consists of a series of buffers appropriate to that data type. The first buffer within the family is the receiving <b>buffer,</b> which <b>stores</b> metrics as they are received from monitored hosts. Subsequent buffers in the family are aggregate <b>buffers,</b> these <b>buffers</b> <b>store</b> aggregated metrics representing the value over a given time period. Each aggregate <b>buffer</b> <b>stores</b> data for a given interval with each additional <b>buffer</b> <b>storing</b> aggregate for a greater time period than the previous. The user can provide intervals, via the configuration service, for aggregate buffers on a per metric basis or provide a single default set of intervals. A typical scheme might be as follows, the receiving buffer followed by aggregate buffers with a 60 s, 5 min, 10 min, 30 min and hour long periods. Values are aggregated from one buffer to another when either a buffer is full or when by a scheduled task running which runs at the frequency of the subsequent buffer. In the eventuality that a buffer has reached its capacity but the time range of data within that buffer does not extend to the interval of the subsequent buffer an interim buffer is created with an intermediate interval. This interim buffer persists until data can be directly aggregated from one buffer to the next.|$|R
40|$|Implementation of {{development}} Hydroelectric Power Plant (HEPP) Write a dam will be constructed of concrete type dam times Write Banjarnegara district. Water from the dam Write dams planned for suplesi plan Maung, {{by creating a}} tunnel from the dam Write Merawu towards Kali. Water from the tunnel entrance on the upstream dam plan Maung. Before the water reached the Kali Merawu, formerly used as power plant turbines. So the head race tunnel tunnel work. Making the tunnel is strongly influenced by the mass of rock above the tunnel or overburden. Modeling research purposes pit tunnel condition before reinstalling the system <b>buffer</b> and <b>temporary</b> <b>buffer</b> on the tunnel design using Phase 2 software {{so that it can}} determine the type most suitable buffer while the tunnel chainage chainage 306 m and 347 m The method used in this study with experimental methods. Using the help of Phase 2 software to help model some <b>temporary</b> <b>buffer</b> to buffer variations in the form of bolts while concrete and benton shoot. Determining whether or not the buffer is safe while the results of the use value of the total displacement, and finite element. From the use of one of these parameters the total displacement (total collapse), there is a scale from chainage 306 m and 347 m chainage have total displacement 0. 0222129 and 0. 0165611 m m. Of the total displacement that there are more than 0. 005 m, then at chainage 306 m and 347 m chainage unsafe and finite element number is less than 4 then the class of models Masaa rocks found on the chainage is less than 4 including unsafe. Type of buffer used in the form of concrete shot but shows the total value of less than 0. 005 m dispalcement then coupled with the type of buffer while steel. Modeling is done in class IIIa and IIIb rock mass unsafe. It is necessary to increase the zone of concrete screws are indicated collapse. Zones are shown by the broken keterdapatan finite element. Keywords: Tunnel, planning <b>temporary</b> <b>buffer,</b> buffer system simulation, total displacement, finite element...|$|R
50|$|While a {{standard}} library package featuring {{most of the}} classical concurrency control structures (mutex locks, etc.) is available, idiomatic concurrent programs instead prefer channels, which provide send messages between goroutines. Optional <b>buffers</b> <b>store</b> messages in FIFO order and allow sending goroutines to proceed before their messages are received.|$|R
50|$|A direct {{consequence}} of the <b>store</b> <b>buffer's</b> existence is that when a CPU commits a write, that write is not immediately written in the cache. Therefore, whenever a CPU needs to read a cache line, it first has to scan its own <b>store</b> <b>buffer</b> {{for the existence of}} the same line, as {{there is a possibility that}} the same line was written by the same CPU before but hasn't yet been written in the cache (the preceding write is still waiting in the <b>store</b> <b>buffer).</b> Note that while a CPU can read its own previous writes in its <b>store</b> <b>buffer,</b> other CPUs cannot see those writes before they are flushed from the <b>store</b> <b>buffer</b> to the cache - a CPU cannot scan the <b>store</b> <b>buffer</b> of other CPUs.|$|R
50|$|In a Flexible Rake Receiver, signal {{reception}} {{is performed}} {{with a single}} correlator engine and a stream <b>buffer</b> <b>storing</b> the entire delay spread of baseband input/output (I/O) samples. The primary advantage of the proposed approach is flexible multipath allocation supporting enhanced modularity of the receiver and resource sharing among multiple channel decoders.|$|R
30|$|In {{multimedia}} {{and graphics}} applications, data samples of nonprimitive type require {{significant amount of}} buffer memory. This paper addresses the problem of minimizing the buffer memory requirement for such applications in embedded software synthesis from graphical dataflow programs based on the synchronous dataflow (SDF) model with the given execution order of nodes. We propose a memory minimization technique that separates global memory buffers from local pointer buffers: the global <b>buffers</b> <b>store</b> live data samples and the local <b>buffers</b> <b>store</b> the pointers to the global buffer entries. The proposed algorithm reduces 67 % memory for a JPEG encoder, 40 % for an H. 263 encoder compared with unshared versions, and 22 % compared with the previous sharing algorithm for the H. 263 encoder. Through extensive buffer sharing optimization, we believe that automatic software synthesis from dataflow program graphs achieves the comparable code quality with the manually optimized code in terms of memory requirement.|$|R
40|$|Abstract — In this paper, the VLSI {{implementation}} of a realtime EZW video coder is presented. The proposed architecture adopts a modified 2 -D DWT subband decomposition scheme, {{with the purpose of}} reducing the transposition memory requirements of 2 -D DWT. In addition, {{through the use of a}} parallelized partial zerotree EZW scheme, <b>temporary</b> <b>buffer</b> requirements between the DWT and EZW modules are also reduced. The video encoder is integrated in a 0. 35 um 3 LM chip by using 341 K transistors on a 4. 93 × 4. 93 mm 2 die. I...|$|R
50|$|In this case, the Copyright Board {{held that}} while <b>temporary</b> <b>buffer</b> copies do qualify as copies, the {{duration}} and {{form of the}} copies was such {{that they did not}} constitute a substantial part of the works in question and therefore did not attract liability. In reaching this conclusion, the court adopted the proposition set out in Canadian Admiral which held that for a work to be protected by the Act, it must be expressed in some material form capable of identification and having a more or less permanent endurance.|$|R
50|$|Linux OpenGL {{drivers are}} split in two: a kernel-driver and a user-space driver. The user-space driver {{does all the}} {{translation}} of OpenGL commands into machine code to be submitted to the GPU. To {{reduce the number of}} system calls, the user-space driver implements marshalling. If the GPU's command buffer is full of rendering data, the API could simply store the requested rendering call in a <b>temporary</b> <b>buffer</b> and, when the command buffer is close to being empty, it can perform a switch to kernel-mode and add a number of stored commands all at once.|$|R
40|$|This paper {{presents}} the Finished <b>Store</b> <b>Buffer</b> (or FSB), an alternative and position-insensitive approach {{for building a}} scalable <b>store</b> <b>buffer</b> for an out-of-order processor. Exploiting {{the fact that only}} a small portion of in-flight stores are done executing (i. e. finished) and waiting for retirement, we are able to build a much smaller and more scalable <b>store</b> <b>buffer.</b> Our study shows that we only need at most half of the number of entries in a conventional store queue if we <b>buffer</b> only the <b>stores</b> that have finished execution. Entries in the <b>store</b> <b>buffer</b> are allocated at issue and disallocated on retirement. A clever encoder circuit is used to provide positional searches without an explicitly positional queue structure. While reducing the access latency and power consumption significantly, our technique has virtually no detrimental effect on per-cycle performance (IPC). 1...|$|R
40|$|International audienceIn {{this paper}} we shortly survey some loop {{transformation}} techniques which break anti or output dependences, or artificial cycles involving such 'false' dependences. These false dependences are removed through {{the introduction of}} <b>temporary</b> <b>buffer</b> arrays. Next we show how to plug these techniques into loop parallelization algorithms (such as Allen and Kennedy's algorithm). The goal is to extract as many parallel loops as the intrinsic degree of parallelism of the nest authorizes, while avoiding a full memory expansion. We try {{to reduce the number}} of temporary arrays that we introduce, as well as their dimension...|$|R
40|$|A {{technique}} for adding {{a form of}} <b>buffer</b> <b>store</b> to an image dissector is described that increases markedly the photoelectron-detecting ability of the image dissector. The buffer-store function is accomplished in the phosphor screen of an image intensifier tube by the metastable electronic excitation states resulting in the phosphor screen from high-energy photoelectron bombardment. The addition of this image intensifier to an image dissector is shown to cause no nonlinearity in the input/output characteristics of the image dissector...|$|R
50|$|Real-time applications, such as video games, usually {{implement}} per-pixel lighting {{through the}} use of pixel shaders, allowing the GPU hardware to process the effect. The scene to be rendered is first rasterized onto a number of <b>buffers</b> <b>storing</b> different types of data to be used in rendering the scene, such as depth, normal direction, and diffuse color. Then, the data is passed into a shader and used to compute the final appearance of the scene, pixel-by-pixel.|$|R
40|$|The article {{highlights}} {{the problem of}} mathematical modelling and subsequent simulation of the highly complex synthetic environment illustrating the real production system consisting of parallel manufacturing plants equipped with interoperation <b>buffer</b> <b>stores.</b> The system can be arranged optionally {{by means of the}} simulator which was created {{on the basis of the}} presented assumptions in the C# programming language. The discussed system realizes orders set by defined customers. Production control is based on heuristic algorithms which choose an order to be realized and a manufacturing plant in which the production process is carried out. The criterion is to minimize the total time of realizing orders however, as seen in the case study, also either the remaining capacity of tools after realizing all orders or the total tool replacement time can be taken into account while dealing with the problem. The modelling and projecting stages are followed by the simulation study. This simulation study is realized for the specific list of orders. It all leads to the thorough analysis of the obtained results which are later compared with the results obtained for the system without interoperation <b>buffer</b> <b>stores.</b> © Springer International Publishing Switzerland 2013...|$|R
50|$|SIM.JS {{supports}} entities, resources (Facility, <b>Buffers</b> and <b>Stores),</b> communication (via Timers, Events and Messages) {{and statistics}} (with Data Series, Time Series and Population statistics).|$|R
5000|$|In {{order to}} {{transport}} multiple data streams {{from one place}} to another over a common transmission medium, they are multiplexed in groups of four. Because each of the four data streams is not necessarily running at the same rate, some compensation has to be introduced. Typically the multiplexer takes the data from the 4 incoming 2.048 Mbit/s data streams and feeds each into a 2.112 Mbit/s stream via a <b>buffer</b> <b>store</b> leaving a series of fixed gaps in each frame.|$|R
3000|$|K finite-capacity <b>buffers</b> to <b>store</b> {{incoming}} {{data from the}} source nodes. Since the relaying operation is decode-and-forward, the relay has to decode all L [...]...|$|R
50|$|Finally, the {{environmental}} impact is small. The waste handling facility at the wellhead, plus a <b>temporary</b> security <b>buffer</b> zone, would require about one square kilometer. When the borehole is filled and sealed, the land can be returned to a pristine condition.|$|R
50|$|The Far Eastern Republic {{was formed}} {{two months after}} Kolchak's death with the tacit support of the {{government}} of Soviet Russia, which saw it as a <b>temporary</b> <b>buffer</b> state between the RSFSR and the territories occupied by Japan. Many members of the Russian Communist Party had disagreed with the decision to allow a new government in the region, believing that their approximately 4,000 members were capable of seizing power in their own right. However, Vladimir Lenin and other party leaders in Moscow felt that the approximately 70,000 Japanese and 12,000 American troops might regard such an action as a provocation, which might spur a further attack that the Soviet Republic could ill afford.|$|R
50|$|This is {{an issue}} because calling kernel-mode {{operations}} from user-mode requires performing a system call (i.e., making the CPU switch to kernel mode). This is a slow operation, taking {{on the order of}} microseconds to complete. During this time, the CPU can perform no operations. As such, minimizing the number of times this switching operation occurs would improve performance. For example, if the GPU's command buffer is full of rendering data, the API could simply store the requested rendering call in a <b>temporary</b> <b>buffer</b> and, when the command buffer is nearly empty, it can perform a switch to kernel-mode and add a set of stored commands in a batch. This is termed marshalling.|$|R
40|$|An {{evaluation}} of a charge-coupled device (CCD) image sensors for use in spacecraft-borne imaging systems was conducted. The study resulted in design recommendations for two sensors, an approximately 500 times 500 element imaging device and a 1 times 190 element linear imaging device with a 190 times 121 <b>buffer</b> <b>store.</b> Emphasis {{was placed on the}} higher resolution, area-imaging sensor. The objectives of the proposed sensors are listed, results of the experiments are analyzed, and estimates of the device performance are presented. A summary of the major technical recommendations is included...|$|R
40|$|In this paper, {{we discuss}} the {{verification}} of a microprocessor involving a reorder <b>buffer,</b> a <b>store</b> <b>buffer,</b> speculative execution and exceptions at the microarchitectural level. We extend the earlier proposed Completion Functions Approach [HSG 98] {{in a uniform manner}} to handle the verification of such microarchitectures. The key extension to our previous work was in systematically extending the abstraction map to accommodate the possibility of all the pending instructions being squashed. An interesting detail that arises in doing so is how the commutativity obligation for the program counter is proved despite the program counter being updated by both the instruction fetch stage (when a speculative branch may be entertained) and the retirement stage (when the speculation may be discovered to be incorrect). Another interesting detail pertains to how <b>store</b> <b>buffers</b> are handled. We highlight a new type of invariant in this work - one which keeps correspondence between <b>store</b> <b>buffer</b> poi [...] ...|$|R
40|$|Abstract. This paper {{addresses}} {{the problem of}} verifying programs for the relaxed memory models implemented in modern processors. Specifically, it considers the TSO (Total Store Order) relaxation, which corresponds {{to the use of}} <b>store</b> <b>buffers.</b> The proposed approach proceeds by using finite automata to symbolically represent the possible contents of the <b>store</b> <b>buffers.</b> <b>Store,</b> load and commit operations then correspond to operations on these finite automata. The advantage of this approach is that it operates on (potentially infinite) sets of buffer contents, rather than on individual buffer configurations. This provides a way to tame the explosion of the number of possible buffer configurations, while preserving the full generality of the analysis. It is thus possible to check even designs that exploit the relaxed memory model in unusual ways. An experimental implementation has been used to validate the feasibility of the approach. ...|$|R
30|$|The {{participants}} {{described the}} network of activity systems {{they are involved in}} as more complex than ‘Home’ and ‘Work’ (a distinction that was investigated by Nippert-Eng [22]) and with more or less flexible boundaries. All participants used both integrating as well as segmentation strategies to mutually adjust their involvement in multiple activity systems. Stationary artifacts played an equally important role to portable ones. This becomes even obvious in Ben’s description of his transition from a PDA to a smartphone. Although he started to use paper notes as <b>temporary</b> <b>buffers</b> for appointments (a strategy that was described in [23]) he also sees advantages in this lack of usability of his smartphone because it supports his effort not to check his work calendar during weekends.|$|R
50|$|A {{text editor}} written or {{customized}} {{for a specific}} use can determine what the user is editing and assist the user, often by completing programming terms and showing tooltips with relevant documentation. Many text editors for software developers include source code syntax highlighting and automatic indentation to make programs easier to read and write. Programming editors often let the user select {{the name of an}} include file, function or variable, then jump to its definition. Some also allow for easy navigation back to the original section of code by storing the initial cursor location or by displaying the requested definition in a popup window or <b>temporary</b> <b>buffer.</b> Some editors implement this ability themselves, but often an auxiliary utility like ctags is used to locate the definitions.|$|R
