53|4978|Public
5|$|Python uses duck typing and has <b>typed</b> <b>objects</b> but untyped {{variable}} names. Type constraints are {{not checked}} at compile time; rather, operations on an object may fail, signifying that the given object {{is not of}} a suitable type. Despite being dynamically typed, Python is strongly typed, forbidding operations that are not well-defined (for example, adding a number to a string) rather than silently attempting {{to make sense of}} them.|$|E
2500|$|XML {{data binding}} is the binding of XML {{documents}} to {{a hierarchy of}} custom and strongly <b>typed</b> <b>objects,</b> {{in contrast to the}} generic objects created by a DOM parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. It is suitable for applications where the document structure is known and fixed at the time the application is written. Example data binding systems include the Java Architecture for XML Binding (JAXB), XML Serialization in [...]NET Framework. and XML serialization in gSOAP.|$|E
5000|$|Interoperability with dynamic languages: The dynamic type {{comes with}} a {{hub-and-spoke}} support for implementing dynamically <b>typed</b> <b>objects</b> and common runtime infrastructure for efficient member lookup.|$|E
5000|$|The model must {{permit a}} {{description}} of the composition of a <b>type</b> <b>object</b> in terms of other <b>type</b> <b>objects.</b> Such concepts include tables of organizations, equipment, or personnel.|$|R
30|$|The {{traditional}} {{method of}} object detection based on feature matching can only detect and recognize one <b>type</b> <b>object</b> by a given template, but cannot model and classify multi <b>type</b> <b>objects</b> {{at the same}} time.|$|R
40|$|By {{giving a}} {{translation}} from <b>typed</b> <b>object</b> calculus into Plotkin’s FPC, we demonstrate that every computationally sound and adequate model of FPC (with eager operational semantics), {{is also a}} sound and adequate model of <b>typed</b> <b>object</b> calculus. This establishes that denotational equality is contained in operational equivalence, i. e. that for any such model of <b>typed</b> <b>object</b> calculus, if two terms have equal denotations, then no program (or rather program context) can distinguish between those two terms. Hence we show that FPC models {{can be used in}} the study of program transformations (program algebra) for <b>typed</b> <b>object</b> calculus. Our treatment is based on self-application interpretation and subtyping is not considered. The <b>typed</b> <b>object</b> calculus under consideration is a variation of Abadi and Cardelli’s first-order calculus with sum and product types, recursive types, and the usual method update and method invocation in a form where the <b>object</b> <b>types</b> have assimilated the recursive types. As an additional result, we prove subject reduction for this calculus...|$|R
5000|$|As Realm is {{an object}} store, its typed language-specific APIs map <b>typed</b> <b>objects</b> {{directly}} into the Realm file - therefore classes are used as the schema definition.|$|E
50|$|Python uses duck typing and has <b>typed</b> <b>objects</b> but untyped {{variable}} names. Type constraints are {{not checked}} at compile time; rather, operations on an object may fail, signifying that the given object {{is not of}} a suitable type. Despite being dynamically typed, Python is strongly typed, forbidding operations that are not well-defined (for example, adding a number to a string) rather than silently attempting {{to make sense of}} them.|$|E
5000|$|XML {{data binding}} is the binding of XML {{documents}} to {{a hierarchy of}} custom and strongly <b>typed</b> <b>objects,</b> {{in contrast to the}} generic objects created by a DOM parser. This approach simplifies code development, and in many cases allows problems to be identified at compile time rather than run-time. Example data binding systems include the Java Architecture for XML Binding (JAXB), XML Serialization in [...]NET Framework. and XML serialization in gSOAP.|$|E
5000|$|<b>Typed</b> <b>Object</b> - 0x10 (16-bit integer name length with UTF-8 name, {{followed}} by entries) ...|$|R
5000|$|Recognition, the <b>type</b> <b>object</b> can be discerned, {{a person}} versus a car (4 +/− 0.8 line pairs) ...|$|R
5000|$|In {{languages}} with {{a structural}} type system, the top type is the empty structure. For example, objects in OCaml are structurally typed; the empty <b>object</b> <b>type</b> (the <b>type</b> of <b>objects</b> with no methods), , {{is the top}} <b>type</b> of <b>object</b> <b>types.</b> Any OCaml <b>object</b> can be explicitly upcasted to this type, although {{the result would be}} of no use. Go also uses structural typing; and all types implement the empty interface: [...]|$|R
50|$|In {{class-based}} languages, a new instance {{is constructed}} through a class's constructor function, a special function that reserves {{a block of}} memory for the object's members (properties and methods) and returns a reference to that block. An optional set of constructor arguments can be passed to the function and are usually held in properties. The resulting instance will inherit all the methods and properties that were defined in the class, which acts {{as a kind of}} template from which similar <b>typed</b> <b>objects</b> can be constructed.|$|E
5000|$|Slazure is a Dynamic Data Mapper {{that do not}} use {{any kind}} of {{serialization}} or internal schema because its database systems have no schema of their own; they are [...] "schema free" [...] (or [...] "schema-less") databases. Developers access a database system using dynamically <b>typed</b> <b>objects</b> {{that do not require}} any form of schema definitions. Slazure's combination of schema-free databases and dynamically typed entities enable programmers to make object and database changes without affecting one another; plainly said, the data model updates automatically. Slazure is optimized for use with [...]NET 4.5 or higher.|$|E
50|$|Dynamic Windows uses <b>typed</b> <b>objects</b> for all {{output to}} the screen. All {{displayed}} information keeps its {{connection to the}} objects displayed (output recording). This works for both textual and graphical output. At runtime the applicable operations to these objects are computed based on the class hierarchy and the available operations (commands). Commands are organized in hierarchical command tables with typed parameters. Commands can be entered with the mouse (making extensive use of mouse chording), keystrokes and with a command line interface. All applications share one command line interpreter implementation, which adapts to various types of usage. The graphical capabilities of the window system {{are based on the}} PostScript graphics model.|$|E
5000|$|A [...] object {{contains}} properties {{unique to}} the <b>type</b> of the <b>object</b> as well as static methods that implement the services offered by the object. Objects managed by Object Manager must at least provide a predefined set of services: [...] (which closes a handle to an object), [...] (create another handle to the object with which another process can gain shared access to the object), [...] (gather information about its attributes and properties), [...] (get the security descriptor of the object), [...] (change the security access), and [...] (to synchronize {{with one or more}} objects via certain events). <b>Type</b> <b>objects</b> also have some common attributes, including the type name, whether they are to be allocated in non-paged memory, access rights, and synchronization information. All instances of the same type share the same <b>type</b> <b>object,</b> and the <b>type</b> <b>object</b> is instantiated only once. A new <b>object</b> <b>type</b> can be created by endowing an object with Properties to expose its state and methods to expose the services it offers.|$|R
2500|$|The {{superscript}} [...] in {{the symbols}} , , and [...] indicates the <b>type</b> of the <b>objects</b> being quantified over. [...] <b>Type</b> 0 <b>objects</b> are natural numbers, and <b>objects</b> of <b>type</b> [...] are functions that map {{the set of}} <b>objects</b> of [...] <b>type</b> [...] to the natural numbers. Quantification over higher <b>type</b> <b>objects,</b> such as functions from natural numbers to natural numbers, is described by a superscript greater than 0, as in the analytical hierarchy. The superscript 0 indicates quantifiers over numbers, the superscript 1 would indicate quantification over functions from numbers to numbers (<b>type</b> 1 <b>objects),</b> the superscript 2 would correspond to quantification over functions that take a <b>type</b> 1 <b>object</b> and return a number, and so on.|$|R
50|$|System: Defines the Object class {{which all}} {{reference}} <b>type</b> <b>objects</b> derive from (including value-type objects) and the ValueType class which all value <b>type</b> <b>objects</b> derive from. It also defines the base data types like integers, floating point numbers, character, strings, Boolean, enumeration and more. Support {{for the environment}} and platform and a command-line interface is provided along with base classes for exceptions and attributes. It defines arrays and delegates, mathematical functions and many other types.|$|R
40|$|JavaScript’s typed arrays {{have proven}} to be a crucial API for many JS applications, {{particularly}} those working with large amounts of data or emulating other languages. Unfortunately, the current typed array API offers no means of abstraction. Programmers are sup-plied with a simple byte buffer that can be viewed as an array of integers or floats, but nothing more. This paper presents a generalization of the typed arrays API entitled <b>typed</b> <b>objects.</b> The <b>typed</b> <b>objects</b> API is slated for inclusion in the upcoming ES 7 standard. The API gives users the ability to define named types, making typed arrays much easier to work with. In particular, it is often trivial to replace uses of existing JavaScript objects with <b>typed</b> <b>objects,</b> resulting in better memory consumption and more predictable performance. The advantages of the typed object specification go beyond convenience, however. By supporting opacity—that is, the ability to deny access to the raw bytes of a typed object—the new typed object specification makes it possible to store objects as well as scalar data and also enables more optimization by JIT compilers. Categories and Subject Descriptors CR-number [subcategory]: third-leve...|$|E
40|$|This is {{the sixteenth}} article {{in a regular}} series on {{object-oriented}} type theory for nonspecialists. Earlier articles have built up λ-calculus models of objects [1], classes [2], inheritance [3, 4] and generic template types [5]. Classification describes {{the way in which}} <b>typed</b> <b>objects</b> fit into a hierarchy of classes, which nest inside each other [3]...|$|E
40|$|We {{present a}} new method to compute normal forms, {{applied to the}} germs of {{reversible}} mappings. We translate the classification problem of these germs {{to the theory of}} ideals in the space of the coefficients of their jets. Integral factorization coupled with Gr¨obner basis construction is the key factor that makes the process efficient. We also show that a language with <b>typed</b> <b>objects</b> like AXIOM is very convenient to solve these kinds of problems. We present a new method to compute normal forms, applied to the germs of reversible mappings. We translate the classification problem of these germs to the theory of ideals in the space of the coefficients of their jets. Integral factorization coupled with Gr¨obner basis construction is the key factor that makes the process efficient. We also show that a language with <b>typed</b> <b>objects</b> like AXIOM is very convenient to solve these kinds of problems...|$|E
40|$|We {{develop an}} {{imperative}} calculus of <b>objects.</b> Its main <b>type</b> constructor {{is the one}} for <b>object</b> <b>types,</b> which incorporate variance annotations and Self types. A subtyping relation between <b>object</b> <b>types</b> supports <b>object</b> subsumption. The <b>type</b> system for <b>objects</b> relies on unusual but beneficial assumptions about the possible subtypes of an <b>object</b> <b>type.</b> With the addition of polymorphism, the calculus can express classes and inheritance...|$|R
40|$|The wide {{practice}} of object-oriented programming in current software construction is evident. Despite extensive studies on <b>typing</b> programming <b>objects,</b> {{it is still}} undeniably a challenging research task to design a type system for objectoriented programming that is both e#ective in capturing program errors and unobtrusive to program construction. In this paper, we present a novel approach to <b>typing</b> <b>objects</b> that makes use of a recently invented notion of guarded dependent datatypes. We show that our approach can address various di#cult issues (e. g., handling "self " type, typing binary methods, etc.) in a simple and natural type-theoretical manner, remedying the deficiencies in many existing approaches to <b>typing</b> <b>objects...</b>|$|R
50|$|Primitive LPC types (int, string, status, float, etc.) {{are passed}} by value. Data {{structure}} <b>types</b> (<b>object,</b> array, mapping, class, struct) are passed by reference.|$|R
40|$|Colloque sans acte à {{diffusion}} restreinte. internationale. International audienceTransformational {{approach requires}} to write transformation functions that ensure properties C 1 and C 2. Proving these conditions on complex <b>typed</b> <b>objects</b> {{is a serious}} bottleneck {{for the application of}} this approach. We propose to use a theorem prover to assist the development of safe transformation functions. In this paper, we present how we have designed in that way a set of safe transformation functions for an XML typed object...|$|E
40|$|We {{present an}} {{internal}} formalisation {{of a type}} heory with dependent types in Type Theory using a special case of higher inductive types from Homotopy Type Theory which we call quotient inductive types (QITs). Our formalisation of type theory avoids referring to preterms or a typability relation but defines directly well <b>typed</b> <b>objects</b> by an inductive definition. We use the elimination principle to define the set-theoretic and logical predicate interpretation. The work has been formalized using the Agda system extended with QITs using postulates...|$|E
40|$|The FMathL type {{system is}} a common {{generalization}} of context-free grammars and algebraic data types in programming languages, and consists {{of a system of}} declared categories and types. The type declarations themselves are represented via <b>typed</b> <b>objects,</b> making the whole typing self-consistent. Correctness of types can be checked in linear time. The type system is defined within a framework for representing semantic content, specially designed to naturally represent arbitrary mathematics. Information is represented via semantic units (sems) relating objects, an undefined notion that may be interpreted as elements of the domain of a semantic mapping. Meaning is conveyed by means of typ...|$|E
40|$|AbstractIn current {{class-based}} Object-Oriented Programming Languages (OOPLs), <b>object</b> <b>types</b> {{include only}} static features. How to add object dynamic behaviors modeled by Harel's statecharts into <b>object</b> <b>types</b> is a challenging task. We propose adding states and state transitions, which are largely unstated in <b>object</b> <b>type</b> theory, into <b>object</b> <b>type</b> definitions and typing rules. We argue that dynamic behaviors of objects {{should be part}} of <b>object</b> <b>type</b> definitions. We propose our type theory, the τ-calculus, which refines Abadi and Cardelli's ζ-calculus, in modeling objects with their dynamic behaviors. In our proposed type theory, we also explain that a subtyping relation between <b>object</b> <b>types</b> should imply the inclusion of their dynamic behaviors. By adding states and state transitions into <b>object</b> <b>types,</b> we propose modifying programming language constructs for state tracking...|$|R
50|$|There are a {{very wide}} range of <b>types</b> of <b>object</b> {{manipulation}}. Each <b>type</b> of <b>object</b> manipulation has often been grouped together in a category of object manipulation skills. These categories are shown below. However many <b>types</b> of <b>object</b> manipulation do not fit these common categories while others {{can be seen to}} belong to more than one category.|$|R
40|$|The fi rst part of {{this thesis}} {{consists}} of two research papers and concerns the fi eld of denotational semantics of <b>typed</b> <b>object</b> calculus, i. e., a formalism for object-based programming. It provides a category-theoretic semantics based on partial maps subject to an algebraic compactness assumption. This semantics interprets types as mixed-variant functors (so-called difunctors) and is therefore termed difunctorial. In addition, we prove computational soundness and adequacy results for <b>typed</b> <b>object</b> calculus via Plotkin’s FPC, thus providing a class of computationally adequate models for an extended fi rst-order <b>typed</b> <b>object</b> calculus (with recursive objects supporting method update, but not subtyping). Taken together, this provides a mathematical foundation for studying program algebras for object-based programming languages. The second part (which appeared at CALCO 2007, Springer-Verlag) deals with recursion principles on datatypes, including the untyped lambda calculus as a special case. Freyd showed that, in certain domai...|$|R
40|$|International audienceSOS (SOMIW Operating System) is {{the result}} of a {{four-year}} effort at INRIA to define an object-oriented operating system. SOS provides support for arbitrary, user-defined, <b>typed</b> <b>objects.</b> The system implements object migration; this mechanism is generic, but can be tailored to specific object semantics thanks to the prerequisite and upcall concepts. SOS also supports Fragmented Objects (FOs), i. e. objects the representation of which spreads across multiple address spaces. Fragments of a single FO are objects that enjoy mutual communication privileges. A fragment acts as a proxy, i. e. a local interface to the FO...|$|E
40|$|International audienceThis paper investigates an anti-realist {{theory of}} meaning {{suitable}} for both logical and proper axioms. Unlike other anti-realist accounts such as Dummett–Prawitz verificationism, the standard framework of classical logic is not called into question. This account also admits semantic features beyond the inferential ones: computational aspects play {{an essential role}} in the determination of meaning. To deal with these computational aspects, a relaxation of syntax is necessary. This leads to a general kind of proof theory, where the objects of study are not <b>typed</b> <b>objects</b> like deductions, but rather untyped ones, in which formulas are replaced by geometrical configurations...|$|E
40|$|In {{response}} {{to the challenge of}} open hypertext systems allowing access to heterogeneous information resources in the world-wide commercial and scientific information market, we propose a hypertext system model and architecture based on <b>typed</b> <b>objects</b> and links making possible semantically controlled access to information units within the hypertext, {{as well as to the}} outside information systems world. We concentrate particularly on a common interaction platform by describing the different browser types of the Constance Hypertext System (KHS), and describe in more detail various different navigation techniques and term-based retrieval methods- thus furthering a productive partnership between information retrieval and hypertext. ...|$|E
40|$|We {{extend the}} Abadi-Cardelli {{calculus}} of primitive objects with object extension. We enrich <b>object</b> <b>types</b> {{with a more}} precise, uniform, and exible type structure. This enables to <b>type</b> <b>object</b> extension under both width and depth subtyping. Objects may also have extend-only or virtual contra-variant methods and read-only co-variant methods. The resulting subtyping relation is richer, and <b>types</b> of <b>objects</b> can be weaken progressively from a class level to a more traditional object level along the subtype relationship. ...|$|R
50|$|Icy moons {{warmed by}} tides {{may be the}} most common <b>type</b> of <b>object</b> to have liquid water, and thus the <b>type</b> of <b>object</b> most likely to have {{water-based}} life.|$|R
40|$|<b>Object</b> <b>type</b> constructors {{have been}} {{introduced}} as an approach to adding container <b>object</b> <b>types</b> to a language with type inference. Useful subtyping for <b>object</b> <b>type</b> constructors requires a flexible subtype rule for type constructors that is not simply the pointwise extension of subtyping for types. At the same time, subtyping should avoid requiring run-time type checks, as in the Java subtype rule for arrays. An extension of <b>object</b> <b>type</b> constructors is considered to allow this subtyping, extending the kinds of <b>object</b> <b>type</b> constructors with polarities that allow this subtyping without jeopardizing soundness. 1 Introduction Recent years have seen much attention paid to the foundations of <b>typed</b> <b>object</b> oriented programming languages. Less {{attention has been paid}} to the <b>types</b> of container <b>objects</b> (for example, vectors, lists and arrays). Such objects provides interfaces that are parameterized by one or more type variables (representing the element type, in the aforesaid examples). A formal ca [...] ...|$|R
