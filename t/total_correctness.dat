252|12|Public
50|$|A {{distinction}} is made between <b>total</b> <b>correctness,</b> which additionally {{requires that the}} algorithm terminates, and partial correctness, which simply requires that if an answer is returned it will be correct. Since there is no general solution to the halting problem, a <b>total</b> <b>correctness</b> assertion may lie much deeper. A termination proof {{is a type of}} mathematical proof that plays a critical role in formal verification because <b>total</b> <b>correctness</b> of an algorithm depends on termination.|$|E
50|$|<b>Total</b> <b>correctness</b> {{can also}} be proven with an {{extended}} version of the While rule.|$|E
50|$|It {{seems that}} naming this {{property}} non-aborting {{would be more}} appropriate: in <b>total</b> <b>correctness,</b> non-termination is abortion, whereas in partial correctness, it is not.|$|E
40|$|We study {{commutation}} and termination {{properties in}} Cohen's w-algebra; an idempotent semiring with operations for finite and infinite iteration. We provide particularly simple calculational proofs of certain additivity and transformation theorems for termination {{that depend on}} commutation, cooperation or simulation properties. We also show that this algebraic approach provides a natural semantics to many standard diagrammatic arguments {{and that it is}} especially suited for mechanization in a formal method. Applications are <b>total</b> program <b>correctness,</b> abstract rewriting and concurrency control...|$|R
40|$|AbstractThe {{theory of}} {{relative}} program correctness and its preservation allows for elaborate and practically adequate definitions of correct implementation notions {{as they are}} established by transformations implemented in a compiler. It generalizes Hoare's and Floyd's partial and <b>total</b> program <b>correctness</b> and correctness preservation by classifying finite and infinite errors to be either acceptable (unavoidable) or unacceptable (chaotic, to be avoided). We will define correct implementation by particular compositional diagram commutativities, and we will further extend this theory also to express correctness of compiling specifications and of compiler programs and their implementations in the same uniform relational setting. Unacceptable error outcomes can semantically model pre-conditions such as well-formedness conditions for compilers or optimization pre-conditions for user programs. Our theory allows to distinguish between different correct implementation requirements, for instance (horizontally) for user programs or (vertically) for the compiler implementation, just as if we would {{switch on and off}} compiler options and tune one compiler to appropriately preserve correctness in different application domains...|$|R
40|$|Pancreatic {{cancer is}} a very {{aggressive}} malignancy that is often diagnosed in the advanced stages, with the implication that long-term survivors are extremely rare. Thus, developing new methods for the early detection of pancreatic {{cancer is a}}n urgent task for current research. To date, nanotechnology offers unprecedented opportunities for cancer therapeutics and diagnosis. The {{aim of this study}} is {{the development of a new}} pancreatic cancer diagnostic technology based on the exploitation of the nano-bio-interactions between nanoparticles and blood samples. In this study, blood samples from 20 pancreatic cancer patients and 5 patients without malignancy were allowed to interact with designed lipid nano-particles, leading to the formation of a hard "protein corona" at the nanoparticle surface. After isolation, the protein patterns were characterized by sodium dodecyl sulphate polyacrylamide gel electrophoresis (SDS PAGE). We found that the protein corona of pancreatic cancer patients was much more enriched than that of healthy individuals. Statistical analysis of SDS-PAGE results allowed us to discriminate between healthy and pancreatic cancer patients with a <b>total</b> discriminate <b>correctness</b> rate of 88 %...|$|R
50|$|A {{termination}} {{proof is}} a type of mathematical proof that plays a critical role in formal verification because <b>total</b> <b>correctness</b> of an algorithm depends on termination.|$|E
5000|$|... {{the while}} rule for <b>total</b> <b>correctness</b> {{can be applied}} with e.g. D being the non-negative {{integers}} with the usual order, and the expression t being 10 - x, which then in turn requires to prove ...|$|E
5000|$|More formally, let us use {{variable}} x {{to denote}} abusively the tuple of variables involved in statement S. Then, a given Hoare triple [...] is provable in Hoare logic for <b>total</b> <b>correctness</b> if {{and only if}} the first-order predicate below holds: ...|$|E
40|$|AbstractNetwork {{planning}} {{technology could}} be used to represent project plan management, such Critical Path Method (CPM for short) and Performance Evaluation Review Technique (PERT for short) etc. Aiming at problem that how to find hypo-critical path in network planning, firstly, properties of total float. free float and safety float are analyzed, and total float theorem is deduced on the basis of above analysis; and secondly, simple algorithm of finding the hypo-critical path is designed by using these properties of float and <b>total</b> theorem, and <b>correctness</b> of the algorithm is analyzed. Proof shows that the algorithm could realize effect of whole optimization could be realized by part optimization. Finally, one illustration is given to expatiate the algorithm...|$|R
40|$|Abstract – This paper {{presents}} {{a new approach}} to formalizing the general rules of the Hoare logic. Our way is based on formulas of the first-order predicate logic defined over the abstract state space of a virtual machine, i. e. so-called S-formulas. S-formulas are general tool for analyzing program semantics inasmuch as Hoare triples of <b>total</b> and partial <b>correctness</b> are not more than two S-formulas. The general rules of Hoare logic, such as the laws of consequence, conjunction, disjunction and negation can be derived using axioms and theorems of first-order predicate logic. Every proof is based on deriving the validity of some S-formula, so the procedure may be automated using automatic theorem provers. In this paper we will use Coq...|$|R
40|$|On Labor Day weekend, {{the highway}} patrol sets up spot-checks at random {{points on the}} freeways with the {{intention}} of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems {{in a wide range of}} areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, <b>total</b> orders, and <b>correctness</b> of group and field operations. All of our spotcheckers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give propert [...] ...|$|R
5000|$|To show <b>total</b> <b>correctness,</b> we {{also have}} to show that the loop terminates. For this we define a well-founded {{relation}} on the state space denoted [...] "<" [...] and called loop variant. Hence, we have:Informally, in the above conjunction of three formulas: ...|$|E
5000|$|A {{system is}} said to be {{real-time}} if the <b>total</b> <b>correctness</b> of an operation depends not only upon its logical correctness, but also upon the time in which it is performed. Real-time systems, as well as their deadlines, are classified by the consequence of missing a deadline: ...|$|E
50|$|If {{the above}} {{ordinary}} while rule {{is replaced by}} the following one, the Hoare calculus {{can also be used}} to prove <b>total</b> <b>correctness,</b> i.e. termination as well as partial correctness. Commonly, square brackets are used here instead of curly braces to indicate the different notion of program correctness.|$|E
40|$|AbstractOn Labor Day weekend, {{the highway}} patrol sets up spot-checks at random {{points on the}} freeways with the {{intention}} of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems {{in a wide range of}} areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, <b>total</b> orders, and <b>correctness</b> of group and field operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give property tests as defined by Rubinfeld and Sudan (1996, SIAM J. Comput. 25, 252 – 271), Rubinfeld (1994, “Proc. 35 th Foundations of Computer Science,” pp. 288 – 299), and Goldreich et al. (1998, J. Assoc. Comput. Mach. 45, 653 – 750) ...|$|R
40|$|This paper {{presents}} a special {{subset of the}} first-order predicate logic named S-program calculus (briefly S-calculus). The S-calculus is a calculus consisting of so-called S-formulas that are defined over the abstract state space of a virtual machine. We show that S-formulas are a highly general tool for analyzing program semantics inasmuch as Hoare triplets of <b>total</b> and partial <b>correctness</b> are not more than two S-formulas. Moreover, all the rules of Hoare logic can be derived using S-formulas and axioms/theorems of first-order predicate calculus. The S-calculus is a powerful mechanism for proving program correctness {{as well as for}} building additional proving tools using theorems of the predicate logic. Every proof is based on deriving the validity of some S-formula, so the procedure may be automated using automatic theorem provers (we will use Coq in this paper). As an example of the use of S-calculus, we will prove the four basic properties of Dijsktra's operator wp. The proofs given by Dijkstra are not completely formalized and we will show that a full formalization can be achieved using S-calculus. Finally, we add one more theorem to the above-mentioned four, namely the law of negation. Comment: 24 pages, 2 figure...|$|R
40|$|With {{increasing}} design complexity, verification {{becomes a}} {{more and more}} {{important aspect of the}} design flow: modern circuits contain up to several million transistors, causing verification to be the major bottleneck and the most expensive stage. This {{is one of the reasons}} why Formal Verification techniques are gaining large attention, since they allow to prove correctness of a circuit (ensuring a <b>total</b> functional <b>correctness)</b> compared to classical simulation, which cannot guarantee sufficient coverage of the design, due to its intrinsic not complete nature. Being Formal Verification a complete technique, its natural application can be found in all those critical systems where the absence of bugs is mandatory. In particular, hardware design can be considered as one of the most critical areas, due to the difficulties (and costs) involved in solving a fault introduced at the design stage, but exposed only after its manufacturing. On the other hand, generally speaking, a software system could be patched easily, just releasing a newer version of the software itself. Nevertheless recently also software applications are becoming a relevant area of application for Formal Verification techniques, especially concerning safety critical applications, software security aspects and firmware of embedded systems. Nowadays the most widely used approach to Formal Verification is Model Checking, which consists of a systematically exhaustive exploration of the mathematical model of the system under analysis. The great advantage of Model Checking is that, provided the model of the system and the property to check, it is fully automatic; while its primary disadvantage relies on the difficulty to scale to large systems. The main goal of this Ph. D. dissertation is to present improvements to Model Checking algorithms for hardware design, focused on scalability and efficiency aspects. Every contribution is provided with exhaustive experimental data, performed on industrial test-cases. This dissertation studies also a recent but equally relevant (and critical) area of application for Model Checking algorithms: the verification of security properties in embedded systems. In this context, due to the novelty of this topic, efforts were oriented to study the applicability of the Model Checking approach, leaving the scalability aspects to further work...|$|R
5000|$|Given {{the loop}} {{invariant}} P, the condition B must imply that t {{is not a}} minimal element of D, for otherwise the body S could not decrease t any further, i.e. {{the premise of the}} rule would be false. (This is one of various notations for <b>total</b> <b>correctness.)</b> ...|$|E
50|$|In {{order to}} {{formally}} state {{the rule of}} inference for the termination of a while loop we have demonstrated above, recall that in Floyd-Hoare logic, the rule for expressing the partial correctness of a while loop is:where I is the invariant, C is the condition, and S is {{the body of the}} loop. To express <b>total</b> <b>correctness,</b> we write instead:where, in addition, V is the variant, and by convention the unbound symbol z is taken to be universally quantified.|$|E
5000|$|The {{existence}} of a variant implies that a while loop terminates. It may seem surprising, but the converse is true, as well, {{as long as we}} assume the axiom of choice: every while loop that terminates (given its invariant) has a variant. To prove this, assume that the loopterminates given the invariant I where we have the <b>total</b> <b>correctness</b> assertionConsider the [...] "successor" [...] relation on the state space [...] induced by the execution of the statement S from a state satisfying both the invariant I and the condition C. That is, we say that a state [...] is a [...] "successor" [...] of [...] if and only if ...|$|E
40|$|Most of today's {{software}} users {{interact with}} the software through a graphical user interface (GUI), which constitutes as much as 45 - 60 % of the <b>total</b> code. The <b>correctness</b> of the GUI is necessary to ensure the correctness of the overall software. Although GUIs have become ubiquitous, testing GUIs for functional correctness has remained a neglected research area. Existing GUI testing techniques are extremely resource intensive primarily because GUIs have very large input spaces and evolve frequently. This dissertation overcomes the limitations of existing techniques by developing a process with supporting models, techniques, and tools for continuous integration testing of evolving GUI-based applications. The key idea {{of this process is}} to create three concentric testing loops, each with specific GUI testing goals, resource usage, and targeted feedback. The innermost fully automatic loop called crash testing operates on each code change of the GUI software. The second semi-automated loop called smoke testing operates on each day's GUI build. The outermost loop called comprehensive GUI testing is executed after a major version of the GUI is available. The primary enablers of this process, also developed in this dissertation, include an abstract model of the GUI and a set of model-based techniques for test-case generation, test oracle creation, and continuous GUI testing. The model and techniques were obtained by studying GUI faults, interactions between GUI events, and why certain event interactions lead to faults. The continuous testing process and associated techniques are shown to be useful, via several large experiments involving millions of test cases, on both in-house and open-source GUI applications...|$|R
40|$|On Labor Day Weekend, {{the highway}} patrol sets up spot-checks at random {{points on the}} freeways with the {{intention}} of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems {{in a wide range of}} areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, <b>total</b> orders, and <b>correctness</b> of group operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give property tests as defined by [RS 96, Rub 94, GGR 96]. Our sorting spot-checker runs in O(log n) time to check the correctness of the output produced by a sorting algorithm on an input consisting of n numbers. The convex hull spot checker, given a sequence of k points with the claim that they form the convex hull of the input set of n points, checks in O(n log k) time whether this sequence is close to the actual convex hull of the input set. We also show that there is an O(1) spot-checker to check a program that determines whether a given relation is close to a total order. We present a technique for testing in almost linear time whether a given operation is close to an associative cancellative operation. In this extended abstract we show the checker under the assumption that the input operation is cancellative and leave the general case for the full version of the paper. In contrast, [RaS 96] show that quadratic time is necessary and sufficient to test that a given cancellative operation is associative. This method yields a very efficient tester (over small domains) for all functions satisfying associative functional equations [Acz 66]. We also extend this result to test in almost linear time whether the given operation is close to a group operation...|$|R
40|$|These therories {{describe}} Hoare logics for {{a number}} of imperative language constructs, from while-loops to mutually recursive procedures. Both partial and <b>total</b> <b>correctness</b> are treated. In particular a proof system for <b>total</b> <b>correctness</b> of recursive procedures in the presence of unbounded nondeterminism is presented...|$|E
40|$|This paper {{describes}} Hoare logics for {{a number}} of imperative language constructs, from while-loops via exceptions to mutually recursive procedures. Both partial and <b>total</b> <b>correctness</b> are treated. In particular a proof system for <b>total</b> <b>correctness</b> of recursive procedures in the presence of unbounded nondeterminism is presented. All systems are formalized and shown to be sound and complete in the theorem prover Isabelle/HOL...|$|E
40|$|This paper {{presents}} {{sound and}} complete Hoare logics for partial and <b>total</b> <b>correctness</b> of recursive parameterless {{procedures in the}} context of unbounded nondeterminism. For <b>total</b> <b>correctness,</b> the literature so far has either restricted recursive procedures to be deterministic or has studied unbounded nondeterminism only in conjunction with loops rather than procedures. We consider both single procedures and systems of mutually recursive procedures. All proofs have been checked with the theorem prover Isabelle/HOL...|$|E
40|$|The {{best known}} {{approach}} to program transformation is the unfold/fold methodology of Burstall and Darlington: a simple, intuitive, and expressive approach {{which serves as}} the basis of many automatic program transformation algorithms (such as partial evaluation and deforestation). Unfortunately unfold/fold does not preserve <b>total</b> <b>correctness</b> and requires maintaining a transformation history of the program. Scherlis invented a similar approach, expression procedures, which solved these two problems: expression procedures preserve <b>total</b> <b>correctness</b> and require no transformation history. Motivate...|$|E
40|$|Recent work in {{sequential}} program semantics {{has produced}} both an operational [4] and an axiomatic [13, 17] treatment of <b>total</b> <b>correctness</b> for probabilistic demonic programs, extending Kozen's original work [9, 10] {{that did not}} include demonic nondeterminism. For practical applications however (eg. combining loop invariants with termination constraints) {{it is important to}} retain the traditional distinction between partial and <b>total</b> <b>correctness.</b> Jones [6] defines probabilistic partial correctness for probabilistic, but again not demonic programs. In this paper we combine all the above, giving an operational and axiomatic framework for both partial and <b>total</b> <b>correctness</b> of probabilistic and demonic sequential programs; among other things that provides the theory to support practical reasoning about probabilistic demonic loops [11]. 1 Introduction Deterministic computation over a state space S can be modelled as functions of type S ! S, from initial to final states. A `powerdomain' constr [...] ...|$|E
40|$|Algebras of {{imperative}} programming languages {{have been}} successful in reasoning about programs. In general an algebra of programs is an algebraic structure with programs as elements and with program compositions (sequential composition, choice, skip) as algebra operations. Various versions of these algebras were introduced to model partial correctness, <b>total</b> <b>correctness,</b> refinement, demonic choice, and other aspects. We formalize here an algebra which can be used to model <b>total</b> <b>correctness,</b> refinement, demonic and angelic choice. The basic model of this algebra are monotonic Boolean transformers (monotoni...|$|E
40|$|We {{introduce}} {{a number of}} techniques for establishing the deadlock freedom of concurrent systems. Our methods {{are based on the}} local analysis (or at worst a directed global analysis) of networks. We identify the relationships between these techniques and the range of their application within a framework of deadlock freedom types that we have defined. We also show that the problem of proving <b>total</b> <b>correctness</b> may be translated to one of proving deadlock freedom, with the consequence that our techniques for proving deadlock freedom may be utilised to effect a <b>total</b> <b>correctness</b> proof. </p...|$|E
40|$|Abstract. Hoare {{logic is}} widely used for {{software}} specification and verification. Frequently we need to prove the <b>total</b> <b>correctness</b> of a program: {{to prove that the}} program not only satisfies its pre- and post-conditions but also terminates. We have implemented a termination checker for Isabelle’s Hoare logic. The tool can be used as an oracle, where Isabelle accepts its claim of termination. The tool can also be used as an Isabelle method for proving the entire <b>total</b> <b>correctness</b> specification. For many loop structures, verifying the tool’s termination claim within Isabelle is essentially automatic. ...|$|E
40|$|We report work in {{progress}} concerning the theoretical basis and the implementation in the Theorema system of a methodology for the generation of verification conditions for recursive procedures, {{with the aim of}} practical verification of recursive programs. Proving <b>total</b> <b>correctness</b> is achieved by proving separately partial correctness and then termination. We develop a pattern for proving partial correctness properties of programs which have simple functional recursive definitions, and we discuss how this can be extended to recursive programs having multiple recursive calls. The method for proving partial correctness is based on Scott Induction, from which we extract the essential features. Furthermore we develop a pattern for proving termination of simple recursive functional programs, uder the assumption that <b>total</b> <b>correctness</b> of all the auxiliary functions used in the program definition is provided. Combining the verification conditions from the two parts (partial correctness and termination) we construct verification conditions for proving <b>total</b> <b>correctness.</b> While proving [partial] correctness of non-recursive procedural programs is quite well understood, for instance by using Hoare Logic [3], [5], there are relatively few approaches to recursive procedures (see e. g. [7...|$|E
40|$|We present Total-TaDA, {{a program}} logic for verifying the <b>total</b> <b>correctness</b> of {{concurrent}} programs: that such programs both terminate and produce the correct result. With Total-TaDA, we can specify constraints on a thread’s concurrent environment {{that are necessary}} to guarantee termination. This allows us to verify <b>total</b> <b>correctness</b> for non-blocking algorithms, e. g. a counter and a stack. Our specifications can express lock- and wait-freedom. More generally, they can express that one operation cannot impede the progress of another, a new non-blocking property we call non-impedance. Moreover, our approach is modular. We can verify the operations of a module independently, and build up modules on top of each other...|$|E
40|$|Procedure {{summaries}} are an {{approximation of}} the effect of a procedure call. They have been used to prove partial correctness and safety properties. In this paper, we introduce a generalized notion of procedure summaries and present a framework to verify <b>total</b> <b>correctness</b> and liveness properties of a general class of while programs with recursion. We provide a fixpoint system for computing summaries, and a proof rule for <b>total</b> <b>correctness</b> of a program given a summary. With suitable abstraction methods and algorithms for efficient summary computation, the results presented here can be used for the automatic verification of termination and liveness properties for while programs with recursion...|$|E
40|$|GP 2 is an {{experimental}} nondeterministic programming language based on graph transformation rules, allowing for visual programming and the solving of graph problems at a high-level of abstraction. In previous work we demonstrated how to verify graph programs using a Hoare-style proof calculus, but only partial correctness was considered. In this paper, we add new proof rules and termination functions, which allow for proofs to additionally guarantee that program executions always terminate (weak <b>total</b> <b>correctness),</b> or that programs always terminate {{and do so}} without failure (<b>total</b> <b>correctness).</b> We show that the new proof rules are sound {{with respect to the}} operational semantics of GP 2, complete for termination, and demonstrate their use on some example programs...|$|E
40|$|Springer-Verlag Berlin Heidelberg 2016. We present Total-TaDA, {{a program}} logic for verifying the <b>total</b> <b>correctness</b> of {{concurrent}} programs: that such programs both terminate and produce the correct result. With Total-TaDA, we can specify constraints on a thread’s concurrent environment {{that are necessary}} to guarantee termination. This allows us to verify <b>total</b> <b>correctness</b> for nonblocking algorithms, e. g. a counter and a stack. Our specifications can express lock- and wait-freedom. More generally, they can express that one operation cannot impede the progress of another, a new non-blocking property we call non-impedance. Moreover, our approach is modular. We can verify the operations of a module independently, and build up modules on top of each other...|$|E
