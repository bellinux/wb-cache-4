23|23|Public
2500|$|The actual {{vulnerability}} {{was related}} to DNS only having 65,536 possible transaction IDs, a number small enough to simply guess given enough opportunities. [...] Dan Bernstein, author of djbdns, had reported this as early as 1999. djbdns dealt with the issue using Source Port Randomization, in which the UDP port {{was used as a}} second <b>transaction</b> <b>identifier,</b> thus raising the possible ID count into the billions. Other more popular name server implementations left the issue unresolved due to concerns about performance and stability, as many operating system kernels simply weren't designed to cycle through thousands of network sockets a second. [...] Instead, other implementers assumed that DNS's time to live (TTL) field would limit a guesser to only a few attempts a day.|$|E
50|$|Either a <b>transaction</b> <b>identifier,</b> or a skip {{indicator}} {{depending on}} the level 3 protocol. The <b>transaction</b> <b>identifier</b> contains the transaction value and flag which identifies who allocated the TI.|$|E
5000|$|Performance and {{reliability}} {{improvements to the}} global <b>transaction</b> <b>identifier</b> (GTID) feature of MySQL 5.6 ...|$|E
5000|$|... 61 through 72 {{are special}} purpose routing numbers {{designated}} {{for use by}} non-bank payment processors and clearinghouses and are termed Electronic <b>Transaction</b> <b>Identifiers</b> (ETIs), and correspond to the normal routing number, plus 60.|$|R
50|$|Multiple user {{identifiers}} - Employees can {{be recorded}} in an ECRS {{so that they}} may have an unlimited number of identifiers that are used with third-party systems to associate them with transactions and/or types of <b>transactions.</b> <b>Identifiers</b> may include telephone extensions, photocopy IDs, cell phone numbers, calling card codes, service account codes, login IDs, and credit card numbers.|$|R
40|$|In {{this paper}} {{we present a}} Design-for-Debug (DFD) {{reconfigurable}} infrastructure for SoCs to support at-speed in-system functional debug. A distributed reconfigurable fabric inserted at RTL provides a debug platform that can be configured and operated post-silicon via the JTAG port. The platform can be repeatedly reused to configure many debug structures such as assertions checkers, <b>transaction</b> <b>identifiers,</b> triggers, and event counters...|$|R
50|$|The second {{component}} of the UTI is the code value, sometimes called the <b>Transaction</b> <b>Identifier</b> part. The CFTC defines the <b>transaction</b> <b>identifier</b> part as an alphanumeric code of variable length, up {{to a maximum of}} 32 characters. In addition to alphanumerioc characters, certain special characters are permissible as internal delimiters: colon, hyphen, period, and underscore. These special characters may not start or end the code, nor may they be used consecutively.|$|E
50|$|Each FASTER {{program was}} {{initiated}} using a <b>transaction</b> <b>identifier.</b> FASTER screens were sent as native 2260 datastreams to the terminal.|$|E
5000|$|Digital Wallets {{can also}} {{increase}} {{the security of the}} transaction since the wallet typically does not pass payment card details to the website (a unique <b>transaction</b> <b>identifier</b> or token is shared instead). Increasingly this approach is a feature of online payment gateways, especially if the payment gateway offers a [...] "hosted payment page" [...] integration approach.|$|E
30|$|The FiDoop [10] method uses three Map-Reduce phases to {{generate}} frequent itemsets. FiDoop claims to support automatic parallelization, load balancing, data distribution, and fault tolerance. ScaDiBino [11] extracts rules with the maximum length and one target field. This method omits iterations. In Yu et al. [12], the Distributed Parallel Apriori (DPA) {{algorithm is proposed}} and metadata are stored {{in the form of}} <b>Transaction</b> <b>Identifiers</b> (TIDs). In this method, a single scan of the database is required and a balanced workload among nodes is created.|$|R
40|$|Abstract Recent {{advances}} in miniaturization and low-cost, low-power design {{have led to}} active research in large-scale, highly distributed systems of small, wireless, low-power, unattended sensors and actuators. We explore the use of Random, Ephemeral <b>TRansaction</b> <b>Identifiers</b> (RETRI) in such systems, and contrast it with the typical design philosophy of using static identifiers in roles such as node addressing or efficient data naming. Instead of using statically assigned identifiers that are guaranteed to be unique, nodes randomly select probabilistically unique identifiers for each new transaction...|$|R
50|$|The {{call control}} (CC) {{protocol}} {{is one of}} the protocols of the Connection Management (CM) sublayer. Every mobile station must support the call control protocol. If a mobile station does not support any bearer capability at all then it must respond to a SETUP message with a RELEASE COMPLETE message. In the call control protocol, more than one CC entity are defined. Each CC entity is independent from each other and communicates with the correspondent peer entity using its own MM connection. Different CC entities use different <b>transaction</b> <b>identifiers.</b>|$|R
50|$|The {{reporting}} of wholesale energy market transactions is mandatory {{for both parties}} to the transaction, seller and buyer. The resulting records can be linked by ACER using the Unique <b>Transaction</b> <b>Identifier</b> (UTI), which is a field in the report being unique {{in the market and}} identical for both sides of the report. In practice, this requirement is difficult to fulfill for purely bilateral transactions.|$|E
50|$|The message {{sequence}} of command (or request) and its response {{is known as}} a transaction, which is identified by the numerical <b>Transaction</b> <b>Identifier</b> exchanged in each transaction. The protocol specification defines nine standard commands that are distinguished by a four-letter command verb: AUEP, AUCX, CRCX, DLCX, EPCF, MDCX, NTFY, RQNT, and RSIP. Responses begin with a three-digit numerical response code that identifies the outcome or result of the transaction.|$|E
50|$|TI {{values are}} {{assigned}} {{by the side of}} the interface initiating a transaction. At the beginning of a transaction, a free TI value is chosen and assigned to this transaction. It then remains fixed for the lifetime of the transaction. After a transaction ends, the associated TI value is free and may be reassigned to a later transaction. Two identical <b>transaction</b> <b>identifier</b> values may be used when each value pertains to a transaction originated at opposite ends of the interface.|$|E
40|$|Recent {{advances}} in miniaturization and low-cost, lowpower design {{have led to}} active research in large-scale, highly distributed systems of small, wireless, low-power, unattended sensors and actuators. We explore the use of Random, Ephemeral <b>TRansaction</b> <b>Identifiers</b> (RETRI) in such systems, and contrast it with the typical design philosophy of using static identifiers in roles such as node addressing or efficient data naming. Instead of using statically assigned identifiers that are guaranteed to be unique, nodes randomly select probabilistically unique identifiers for each new transaction. We show how this randomized scheme can significantly improve the system's energy efficiency in contexts where that efficiency is paramount, such as energy-constrained wireless sensor networks. Benefits are realized if the typical data size is small compared {{to the size of}} an identifier, and the number of transactions seen by an individual node is small compared to the number of nodes that exist in th [...] ...|$|R
40|$|Discovery of {{association}} rules {{is an important}} problem in Data Mining. The classical approach is to generate all itemsets that have support (i. e., the fraction of transactions containing the itemset) above a user given threshold. Most existing algorithms aim at {{reducing the number of}} scans over the transaction database, i. e., the I/O overhead. We consider {{the problem of how to}} calculate efficiently the support, i. e., we try to optimize both I/O and CPU time. A straightforward way is to maintain, for each itemset, the relevant <b>transaction</b> <b>identifiers</b> directly into a list and use a sort-merge algorithm to do the intersection of two itemsets. Instead, we propose bitmap based algorithms. The basic idea is that every couple is represented by a bit in an index bitmap, and the logical operation AND is used in place of the sort-merge algorithm. We propose two variations of the bitmap based algorithm : the naïve bitmap algorithm (N-BM) and the hierarchical bitmap algorith [...] ...|$|R
40|$|Since <b>transaction</b> <b>identifiers</b> (ids) {{are unique}} {{and would not}} usually be {{frequent}}, mining frequent patterns with transaction ids, showing records they occurred in, provides {{an efficient way to}} mine frequent patterns in many types of databases including multiple tabled and distributed databases. Existing work have not focused on mining frequent patterns with the transaction ids they occurred in. Many applications require finding strong associations between transaction id (e. g., certain drug) and the itemsets (e. g., certain adverse effects) to help deduce some pertinent lacking information (like how many people use this product in total) and information (like how many people have the adverse effects). This paper proposes a set of algorithms TidFPs, for mining frequent patterns with their transaction ids in a single transaction database, in a multiple tabled database, and in a distributed database. The proposed technique scans the database records only once even with level-wise Apriori-based mining techniques, stores frequent 1 -items with their transaction id bitmap, outperforms traditional approaches and is extendible to other tree-based mining techniques as well as sequential mining...|$|R
50|$|Each CICS {{program is}} {{initiated}} using a <b>transaction</b> <b>identifier.</b> CICS screens are usually sent as a construct called a map, a module created with Basic Mapping Support (BMS) assembler macros or third-party tools. CICS screens may contain text that is highlighted, has different colors, and/or blinks {{depending on the}} terminal type used. An example of how a map can be sent through COBOL is given below. The end user inputs data, which is made accessible to the program by receiving a map from CICS.|$|E
50|$|EMIR {{requires}} that all entities entering into derivative contracts must submit reports to their corresponding trade repositories, outlining each over-the-counter trade. These mandatory reports must {{also include a}} Unique <b>Transaction</b> <b>Identifier</b> (UTI), legal entity identifier (LEI), information on the trading capacity of the counterparty, and the marked-to-market valuation of the position. The counterparty data in a report includes 26 fields for data and the common data includes 59 fields of data. These fields include an LEI, or a unique 20 digit alphanumeric code {{that may be used}} for eight of the 26 counterparty data fields, and the unique trade identifier, which are generated based on the report's LEI.|$|E
50|$|A Unique <b>Transaction</b> <b>Identifier</b> (Acronym: UTI), {{alternatively}} called Unique Swap Identifier (Acronym: USI) is a globally {{unique identifier}} for individual transactions in financial markets. USIs {{were introduced in}} late 2012 in the U.S. {{in the context of}} Dodd-Frank regulation, were reporting of transactions to Trade Repositories first became mandatory. European financial market regulations followed suit, with reporting to Trade Repositories under EMIR requiring UTIs from February 2014 on. The use of the UTI is also mandatory for regulatory reporting under REMIT. Strictly speaking, the term USI is specific to the U.S. regulation, while UTI is specific to EU regulations. In practice, both terms are used interchangeable, in particular within large trading firms reporting under both regimes.|$|E
40|$|This paper {{presents}} a twin-page storage method, {{which is an}} alternative to the TWIST (twin slot) approach by Reuter, for rapid transaction-undo recovery. In contrast to TWIST, our twin-page approach allows dirty pages in the buffer to be written at any instant onto disk without the requirement of undo logging, and, when a transaction is aborted, no explicit undo is required. As a result, all locks accumulated by the aborted transaction can be released earlier, allowing other transactions waiting for the locks to proceed. Through maintenance of aborted <b>transaction</b> <b>identifiers,</b> invalid pages written by the aborted transaction coexist with other valid pages and are guaranteed not be accessed by subsequent transactions. Instead of an explicit undo, most of the invalid pages are overwritten by subsequent normal updates. Performance in terms of disk I/O and CPU overhead for transaction-undo recovery is analyzed and compared with TWIST. It is shown that our scheme is particularly suited for applications where there are a large number of updates written onto disk when transactions are aborted, and there are frequent aborts. The approach, however, is not as applicable to environments where transactions are typically short or rarely aborted, or most updates are not written onto disk before a commitment...|$|R
25|$|Health Insurance Portability and Accountability Act (HIPAA) of 1996 {{requires}} {{the adoption of}} national standards for electronic health care <b>transactions</b> and national <b>identifiers</b> for providers, health insurance plans, and employers. And, it requires health care providers, insurance providers and employers to safeguard the security and privacy of health data.|$|R
40|$|The {{problem of}} optimal {{allocation}} of monitoring resources for tracking transactions progressing through a distributed system, modeled as a queueing network, is considered. Two forms of monitoring information are considered, viz., locally unique <b>transaction</b> <b>identifiers,</b> and arrival and departure timestamps of transactions at each processing queue. The timestamps are assumed available {{at all the}} queues but {{in the absence of}} identifiers, only enable imprecise tracking since parallel processing can result in out-of-order departures. On the other hand, identifiers enable precise tracking but are not available without proper instrumentation. Given an instrumentation budget, only a subset of queues can be selected for production of identifiers, while the remaining queues have to resort to imprecise tracking using timestamps. The goal is then to optimally allocate the instrumentation budget to maximize the overall tracking accuracy. The challenge is that the optimal allocation strategy depends on accuracies of timestamp-based tracking at different queues, which has complex dependencies on the arrival and service processes, and the queueing discipline. We propose two simple heuristics for allocation by predicting the order of timestamp-based tracking accuracies of different queues. We derive sufficient conditions for these heuristics to achieve optimality through the notion of stochastic comparison of queues. Simulations show that our heuristics are close to optimality, even when the parameters deviate from these conditions. Comment: Accepted to Elsevier Performance Evaluatio...|$|R
50|$|The actual {{vulnerability}} {{was related}} to DNS only having 65,536 possible transaction IDs, a number small enough to simply guess given enough opportunities. Dan Bernstein, author of djbdns, had reported this as early as 1999. djbdns dealt with the issue using Source Port Randomization, in which the UDP port {{was used as a}} second <b>transaction</b> <b>identifier,</b> thus raising the possible ID count into the billions. Other more popular name server implementations left the issue unresolved due to concerns about performance and stability, as many operating system kernels simply weren't designed to cycle through thousands of network sockets a second. Instead, other implementers assumed that DNS's time to live (TTL) field would limit a guesser to only a few attempts a day.|$|E
50|$|MSRP {{has similar}} syntax as other IETF text based {{protocol}} such as SIP, HTTP and RTSP. Each message {{is either a}} request or a response, uses URIs, a message contains headers and a body that can carry any type of data, including binary information. Unlike SIP, MSRP is much simpler. The first 2 headers must be To-Path and From-Path and the last must be Content-Type, this significantly reduces the complexity of parsers. Messages must also end with 7 dash ('-') characters, followed by a <b>transaction</b> <b>identifier</b> which appears in the first line, these are followed by a continuation flag, which is a single character and end of line (CRLF). This last line {{at the end of}} messages makes it rather simple to find and detect the message boundaries. MSRP is not defined for connection-less protocols, such as UDP, thus one be certain that a response to a request would arrive on the same connection. MSRP also relies on a reliable transport layer, that is, guarantees delivery and maintains the order of the messages, which further simplifies the protocol design.|$|E
30|$|<b>Transaction</b> <b>Identifier</b> - Incrementing ID for {{synchronization}} of messages.|$|E
5000|$|Health Insurance Portability and Accountability Act (HIPAA) - Enacted by the United States Congress {{and signed}} by President Bill Clinton in 1996. Title II of HIPAA, known as the Administrative Simplification (AS) provisions, {{requires}} the establishment of national standards for electronic health care <b>transactions</b> and national <b>identifiers</b> for providers, health insurance plans, and employers.|$|R
40|$|The {{objective}} of this project {{is to find the}} associations among different web pages in a web log file of a website, and then divide the page of each user accessed, who is likely to visit the Web site more than once and create individual sessions. This can be done by computing the association rules in relation to the web pages by using the information from the web log file maintained by its web server. Such information containing association rules gives a broad view of user sequences. It can be extended to any field of activity that involves large bulks of data. This paper is concerned with web usage mining of web mining. The server maintains the information of usage data sequences done by different users. The web log file has the information about the different pages that have been accessed by the users and the secondary information about each URL. Considering that information, in order to perform an association rule analysis, which is also known as market basket analysis, there’s the need to define the basket; in the web environment this is not as clear as in a real supermarket. A phase of <b>transaction</b> <b>identifiers</b> is needed. Finally, after the application of one of these methods, the transaction file is created, the basket entities are defined and the discovery process of association rules can go on with the application of an Association Rule algorithm such as the Apriori one. To find the confidence among the web pages accessed, the user gives a user specified threshold value such as minimum support and minimum confidence values, which determines the probability of accessing a web page when a set of web pages are accessed...|$|R
30|$|Researchers in {{watermarking}} domain {{have focused}} their works on two fundamental issues: watermark detection and watermark decoding (extraction). In the latter, usually {{referred to as}} multibit watermarking, a full decoding is carried out to extract the hidden message, which can be an ownership <b>identifiers,</b> <b>transaction</b> dates, a serial numbers, and so forth. Such a watermarking {{can be found in}} fingerprinting, steganography, and the protection of intellectual property rights. In multibit watermarking, errors may occur when extracting the hidden message. Error probability {{can be used as a}} measure of the watermarking system performance.|$|R
3000|$|<b>Transaction</b> <b>identifier</b> {{is matched}} against the Java process identifier. When tweet {{processing}} has been completed, the Spark Streaming process (based on the Java process identifier) will be stopped [...]...|$|E
3000|$|When all tweets {{have been}} streamed, tweet {{extractor}} informs upper layer (QualityEvaluationService in the Back-end node) about completion (by providing a <b>transaction</b> <b>identifier).</b> The indication will be utilized for stopping {{of the data}} evaluation process (step 24 in Fig.  10) [...]...|$|E
30|$|Some of {{the known}} attacks {{exploited}} known vulnerabilities, such as (1) buffer overflow, which allows an attacker to obtain unauthorised access to the system and execution of arbitrary code, (2) inproper handling of input values, e.g., one attack exploited vulnerable error handling routine that would crash on invalid DNS <b>transaction</b> <b>identifier</b> values, (3) improper check of memory copy, e.g., would crashed the server allowing an attacker to gain root privileges on name server, and many others.|$|E
5000|$|The AAPS was {{involved}} in litigation against Health Insurance Portability and Accountability Act (HIPAA), arguing that it violates the Fourth Amendment to the United States Constitution by allowing government access to certain medical data without a warrant. [...] (Title II of HIPAA, known as the Administrative Simplification (AS) provisions, requires the establishment of national standards for electronic health care <b>transactions</b> and national <b>identifiers</b> for providers, health insurance plans, and employers, and is intended to improve the efficiency and effectiveness of the US's health care system by encouraging {{the widespread use of}} electronic data interchange in the health care system.) ...|$|R
2500|$|The Health Insurance Portability and Accountability Act of 1996 (HIPAA; [...] ) {{was enacted}} by the United States Congress and signed by President Bill Clinton in 1996. It has been known as the Kennedy–Kassebaum Act or Kassebaum–Kennedy Act after two of its leading sponsors. The Act {{consists}} of five Titles. [...] Title I of HIPAA protects health insurance coverage for workers and their families when they change or lose their jobs. Title II of HIPAA, known as the Administrative Simplification (AS) provisions, requires the establishment of national standards for electronic health care <b>transactions</b> and national <b>identifiers</b> for providers, health insurance plans, and employers. Title III sets guidelines for pre-tax medical spending accounts, Title IV sets guidelines for group health plans, and Title V governs company-owned life insurance policies.|$|R
40|$|The Internet {{protocol}} stack as currently designed makes no serious attempt to prevent user tracking. Rather, identifiers {{are assigned to}} users and their associated network elements all throughout the {{protocol stack}}. For instance, in a typical Web (HTTP[FGM + 99]) <b>transaction,</b> the following <b>identifiers</b> are transmitted on the wire (or broadcast over a wireless interface) : 1. An Ethernet MAC address unique to the piece of hardware and more or less stable {{for the life of}} the device, and—because MACs are assigned in manufacturer and product ranges—implicitly identifies the type of device 2. An IP[Pos 81] address which, if not permanent, is stable for hours and reveals the user’s location with a reasonable amount of precision (often down to the street address) 3. One or more HTTP cookies [KM 00], the lifetime of which is controlled by the Web server (although in principle the user can delete these or prevent their storage.) Flash may also have its own cookies. The above list only includes explicit identifying information in the protocols. In addition, there are a large number of implicit or semi-channels that allow the device fingerprinting and hence various degrees of user tracking. Canonical examples include browser version and the set of plugins installed, browser history sniffing, clock skew [KBC 05], and various computer parameters which are readable from JavaScript...|$|R
