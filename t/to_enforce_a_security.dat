23|10000|Public
50|$|Enterprise search systems index {{data and}} {{documents}} {{from a variety}} of sources such as: file systems, intranets, document management systems, e-mail, and databases. Many enterprise search systems integrate structured and unstructured data in their collections. Enterprise search systems also use access controls <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy on their users.|$|E
5000|$|Sun's Trusted Solaris uses a {{mandatory}} and system-enforced {{access control mechanism}} (MAC), where clearances and labels are used <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. However note that the capability to manage labels does not imply the kernel strength to operate in Multi-Level Security mode. Access to the labels and control mechanisms are not robustly protected from corruption in protected domain maintained by a kernel. The applications a user runs are combined with the security label at which the user works in the session. Access to information, programs and devices are only weakly controlled.|$|E
40|$|Our Application Security Monitor (ASM) is a {{run-time}} {{monitor that}} dynamically collects execution-related data. ASM {{is part of}} a security framework {{that will allow us to}} explore different security policies aimed at identifying malicious behavior such as Trojan horses and backdoors. In this paper, we show what type of data ASM can collect and illustrate how this data can be used <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. Using ASM we are able to explore different tradeoffs between security and performance. ...|$|E
5000|$|Marking - Systems {{designed}} <b>to</b> <b>enforce</b> <b>a</b> mandatory <b>security</b> {{policy must}} store {{and preserve the}} integrity of access control labels and retain the labels if the object is exported.|$|R
50|$|In the {{security}} engineering subspecialty of computer science, a trusted {{system is a}} system that is relied upon to <b>a</b> specified extent <b>to</b> <b>enforce</b> <b>a</b> specified <b>security</b> policy. This is equivalent to saying that a trusted system is one whose failure would break <b>a</b> <b>security</b> policy (if <b>a</b> policy exists that the trusted system is trusted <b>to</b> <b>enforce).</b>|$|R
40|$|AbstractThis paper {{introduces}} a formal and modular technique allowing <b>to</b> automatically <b>enforce</b> <b>a</b> <b>security</b> policy on <b>a</b> given concurrent system. Given a concurrent program P and <b>a</b> <b>security</b> policy ϕ, we automatically generate another program P′ that satisfies ϕ and behaves like P, {{except that it}} stops when P tries to violate the security policy ϕ. We use extended version of process algebra ACP (Algebra of Communicating Process) and BPA (Basic Process Algebra) as formal languages to specify both concurrent system and security policy...|$|R
40|$|We present program shepherding, {{a method}} for {{monitoring}} control flow transfers during program execution in order <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. Program shepherding provides three basic techniques as building blocks for security policies. First, program shepherding can restrict execution privileges {{on the basis of}} code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict control transfers based on instruction type, source, and target. Finally, shepherding guarantees that sandboxing checks around any program operation will never be bypassed...|$|E
40|$|International audienceOver time, {{hardware}} designs have constantly {{grown in}} complexity and modern platforms involve multiple interconnected hardware components. During the last decade, several vulnerability disclosures have proven that trust in hardware can be misplaced. In this article, we give a formal definition of Hardware-based Security Enforcement (HSE) mechanisms, {{a class of}} security enforcement mechanisms such that a software component relies on the underlying hardware platform <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. We then model a subset of a x 86 -based hardware platform specifications and we prove the soundness of a realistic HSE mechanism within this model using Coq, a proof assistant system...|$|E
40|$|In runtime {{enforcement}} of security policies, the classic requirements on monitors in order <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy are soundness and transparency. However, {{there are many}} monitors that successfully pass this specification but they differ in complexity of both their implementation and the output they produce. In order to distinguish and compare these monitors we propose to associate cost with enforcement. We present a framework where the cost of {{enforcement of}} a trace {{is determined by the}} cost of operations the monitor uses to edit the trace. We explore cost-based order relations on sound monitors. We investigate cost-optimality of monitors which allows considering the most cost-efficient monitors that soundly enforce a property...|$|E
5|$|The {{enterprise}} {{version of}} Windows 10 offers additional security features; administrators {{can set up}} policies for the automatic encryption of sensitive data, selectively block applications from accessing encrypted data, and enable Device Guarda system which allows administrators <b>to</b> <b>enforce</b> <b>a</b> high <b>security</b> environment by blocking the execution of software that is not digitally signed by a trusted vendor or Microsoft. Device Guard is designed to protect against zero-day exploits, and runs inside a hypervisor so that its operation remains separated from the operating system itself.|$|R
2500|$|... he {{ability of}} a trusted {{computing}} base <b>to</b> <b>enforce</b> correctly <b>a</b> unified <b>security</b> policy depends on the correctness of the mechanisms within the trusted computing base, the protection of those mechanisms to ensure their correctness, and the correct input of parameters related to the security policy.|$|R
40|$|We {{present in}} this paper the {{security}} features of Think, an ob ject-oriented architecture dedicated to build customized operating system kernels. The Think architecture is composed of an object- oriented software framework including a trader, and a library of system abstractions programmed as components. We show how to use this architecture to build secure and eﬃcient kernels. Policy-neutral security is achieved by providing elementary tools {{that can be used}} by the system programmer to build a system resistant to <b>security</b> hazards, and <b>a</b> <b>security</b> manager that uses these tools <b>to</b> <b>enforce</b> <b>a</b> given <b>security</b> policy. An example of such a secure system is given by detailing how to ensure component isolation with a elementary software-based memory isolation tool...|$|R
40|$|Software-based fault {{isolation}} (SFI), {{as used in}} Google’s Native Client (NaCl), relies upon a conceptually simple machine-code analysis <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. But for complicated architectures such as the x 86, it is {{all too easy to}} get the details of the analysis wrong. We have built a new checker that is smaller, faster, and has a much reduced trusted computing base when compared to Google’s original analysis. The key to our approach is automatically generating the bulk of the analysis from a declarative description which we relate to a formal model of a subset of the x 86 instruction set architecture. The x 86 model, developed in Coq, is of independent interest and should be usable {{for a wide range of}} machine-level verification tasks...|$|E
40|$|Security is {{a problem}} of trust. Having a system that offers {{services}} to Internet and that can be trusted is very hard to achieve. Classical security models focus on the physical limit of the machine. We will see that it can be interesting to move the trust limit between user space and kernel space and that it is still possible <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy from this trusted place. We will see some practical ways to have that work done in a modern monolithic kernel (Linux), with some small code examples. We will also see some other practical aspects with a review of some implementations that exist for Linux kernels, with a focus on the Linux Security Modules (LSM) framework...|$|E
40|$|Database {{systems for}} {{real-time}} applications must satisfy timing constraints associated with transactions, {{in addition to}} maintaining data consistency. Multilevel security requirements introduce {{a new dimension to}} transaction processing in real-time database systems. In this paper, we propose a novel concurrency control protocol that can meet the real-time, security, and serializability conditions using a primary copy and a secondary copy for each data object. First, we discuss the conflicting nature of the requirements and then present our protocol. We state and prove the properties characterizing our protocol. The implementation details of the data object representation and the additional processing overhead are also discussed. Finally, opportunities for tuning the protocol to suit different application domains are presented. 1 INTRODUCTION Database security is concerned with the ability of a database management system <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy governing the disclosure, modificat [...] ...|$|E
40|$|In complex networks, filters may {{be applied}} at {{different}} nodes to control how packets flow. In this paper, we study how to locate filtering functionality within a network. We show how <b>to</b> <b>enforce</b> <b>a</b> set of <b>security</b> goals while allowing maximal service {{subject to the}} security constraints. Our contributions include a way to specify security goals for how packets traverse the network and an algorithm to distribute filtering functionality to different nodes in the network <b>to</b> <b>enforce</b> <b>a</b> given set of security goals...|$|R
40|$|The {{security}} threats to networked systems have increased. The demand for accessing hosts remotely in a secure manner is therefore also increasing. In {{order to meet}} this demand, many users and network administrators use the Secure Shell (SSH) service. However, the SSH system may be configured with insecure defaults. A proxy in-between an SSH server and its clients is one possible way <b>to</b> <b>enforce</b> <b>an</b> organisation's <b>security</b> policy while allowing such users and network administrators to continue to use the service. The proxy presented here has been developed from the SSH version 1 (SSH- 1) source code and it helps network managers <b>to</b> <b>enforce</b> <b>a</b> desirable policy, such as allowing the use of strong authentication methods and avoiding security flaws in the server configuration. Keywords [...] Authentication, firewall, proxy, security, SSH I...|$|R
40|$|The recent {{trend towards}} {{dynamically}} extensible systems holds {{the promise of}} more powerful and flexible systems. At the same time, the impact of extensibility on overall system security and, specifically, access control is still ill understood, and protection mechanisms in these extensible systems are rudimentary at best. In this paper, we identify the structure of extensible systems {{as it relates to}} system <b>security,</b> and present <b>an</b> access control mechanism that is user-friendly and complete. The mechanism, by using ideas first introduced by the security community, offers mandatory access control which can be used <b>to</b> <b>enforce</b> <b>a</b> given <b>security</b> policy. Additional discretionary access control allows users to express their own fine-grained access constraints. We introduce a new access mode, called the extend access mode, in addition to the familiar execute access mode, to reflect how extensions interact. Furthermore, in a departure from work in the security community, we treat both extensio [...] ...|$|R
40|$|Database {{systems for}} {{real-time}} applications must satisfy timing constraints associated with transactions, while maintaining data consistency. In addition to real-time requirements, security is usually required in many applications. Multilevel security requirements {{introduce a new}} dimension to transaction processing in real-time database systems. In this paper, we argue that because of the complexities involved, trade-offs need to be made between security and timeliness. We briefly present the secure twophase locking protocol and discuss an adaptive method to support trading off security for timeliness, depending on {{the current state of the}} system. The performance of the adaptive secure two-phase locking protocol shows improved timeliness. We also discuss future research direction to improve timeliness of secure database systems. 1. Introduction Database security is concerned with the ability of a database management system <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy governing the disclosure, modif [...] ...|$|E
40|$|International audienceIn {{the area}} of networks, a common method <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy {{expressed}} in a high-level language {{is based on an}} ad-hoc and manual rewriting process. We argue {{that it is possible to}} build a formal link between concrete and abstract terms, which can be dynamically computed from the environment data. In order to progressively introduce configuration data and then simplify the proof obligations, we use the B refinement process. We present a case study modeling a network monitor. This program, described by refinement following the layers of the TCP/IP suite protocol, has to warn for all observed events which do not respect the security policy. To design this model, we use the event-B method because it is suitable for modeling network concepts. This work has been done within the framework of the POTESTAT project, based on the research of network testing methods from a high-level security policy...|$|E
40|$|Abstract — This paper {{introduces}} an algebraic {{approach that}} aims <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy {{on a given}} computer network. More precisely, given a network and a security policy, we want to automatically generate the necessary monitors (a single fire-wall or many ones where each of them controls {{a part of the}} networks) that force the network to be secure according to the security policy definition. In this approach, the network is formalized as a process P, the security policy is formally specified as a formula Φ and the problem is to find a process M (monitor) such that P M | = Φ. Once this step is completed, some results about equivalence between processes can be used to distribute the monitor over the network. In other words, the equivalence results aims to break the monitor M into small slices that will be distributed so that each slice controls {{only a small part of}} the network. I...|$|E
40|$|This paper {{presents}} SELinks, {{an extension}} of the Links web programming language, that allows a database and web server <b>to</b> collaboratively <b>enforce</b> <b>a</b> <b>security</b> policy with high assurance. Our approach has a number of benefits. First, the relationship between data and its security label is made explicit by the SELinks type system, which allows the compiler to ensure that a policy is always correctly enforced. Next, application-specific logic is communicated seamlessly to the database by compiling SELinks code and values to user-defined functions and custom datatypes, respectively, to be stored in the database. As <b>a</b> result, application-specific <b>security</b> policies can be enforced at the database while processing queries, improving both the overall efficiency of the application, as well as ensuring that sensitive data never leaves the database needlessly. Our experience with two sizeable web applications indicates that cross-tier policy enforcement in SELinks is flexible, relatively easy to use and improves efficiency, in terms of increased throughput, by as much as an order of magnitude. 1...|$|R
50|$|It was {{reported}} on March 14, 2013, {{that a federal}} grand jury in Miami was investigating Menendez regarding his role in advocating for the business interests of ophthalmologist Salomon Melgen, one of his major donors. Menendez's efforts to push U.S. government officials <b>to</b> <b>enforce</b> <b>a</b> lucrative port <b>security</b> contract would have benefitted Melgen, as well as Pedro Pablo Permuy, <b>a</b> former national <b>security</b> adviser and senior legislative aide to Mr. Menendez. In 2012, Melgen's business had donated over $700,000 to Majority PAC, a political action committee supporting Democratic candidates; the PAC spent more than $582,000 on Menendez's behalf.|$|R
50|$|Funk Software was a {{provider}} of network access security solutions for networks of any size, from enterprise to operator, wired or wireless. The company's products were security related and they were grouped as a family of RADIUS/AAA and WLAN security products. These types of network <b>security</b> products allow <b>an</b> organization <b>to</b> <b>enforce</b> <b>a</b> uniform <b>security</b> policy across all network access methods, including WLAN, remote/VPN, dial, and identity-based (wired 802.1X - {{also referred to as}} a supplicant based authentication system) - with the performance and reliability to handle any traffic load, and with full support for any network infrastructure. Funk Software's customers included many of the world's largest corporations, institutions, telecommunications carriers, and internet service providers (ISPs); its products are licensed or resold by numerous leading manufacturers of Internet hardware and software. One of the leading products was OAC - Odyssey Access Client, which is still used today, branded as a Juniper Networks Product UAC - User Access Client.|$|R
40|$|We {{introduce}} program shepherding, {{a method}} for monitoring control flow transfers during program execution <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. Program shepherding provides three techniques as building blocks for security policies. First, shepherding can restrict execution privileges {{on the basis of}} code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict control transfers based on instruction class, source, and target. For example, shepherding can forbid execution of shared library code except through declared entry points, and can ensure that a return instruction only targets the instruction after a call. Finally, shepherding guarantees that sandboxing checks placed around any type of program operation will never be bypassed. We have implemented these capabilities efficiently in a runtime system with minimal or no performance penalties. This system operates on unmodified native binaries, requires no special hardware or operating system support, and runs on existing IA- 32 machines under both Linux and Windows. ...|$|E
40|$|Abstract—In this paper, {{we propose}} and analyze an in-packet Bloom-filter-based source-routing {{architecture}} resistant to Dis-tributed Denial-of-Service attacks. The approach {{is based on}} for-warding identifiers that act simultaneously as path designators, i. e. define which path the packet should take, and as capabilities, i. e. effectively allowing the forwarding nodes along the path <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy where only explicitly authorized packets are forwarded. The compact representation {{is based on a}} small Bloom filter whose candidate elements (i. e. link names) are dynamically computed at packet forwarding time using a loosely synchonized time-based shared secret and additional in-packet flow information (e. g., invariant packet contents). The capabilities are thus expirable and flow-dependent, but do not require any per-flow network state or memory look-ups, which have been traded-off for additional, though amenable, per-packet computation. Our preliminary security analysis suggests that the self-routing capabilities can be an effective building block towards DDoS-resistant network architectures. I...|$|E
40|$|The {{security}} of the standard TCG architecture depends on whether the values in the PCRs match the actual platform configuration. However, this design admits potential for time-of-check time-of-use vulnerabilities: a PCR reflects the state of code and data when it was measured, not when the TPM uses a credential or signs an attestation based on that measurement. We demonstrate how an attacker with sufficient privileges can compromise the integrity of a TPM-protected system by modifying critical loaded code and static data after measurement has taken place. To solve this problem, we explore using the MMU and the TPM in concert to provide a memory event trapping framework, inwhich trap handlers perform TPM operations <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. Our framework proposal includes modifying the MMU to support selective memory immutability and generate higher granularity memory access traps. To substantiate our ideas, we designed and implemented a software prototype system employing the monitoring capabilities of the Xen virtual machine monitor...|$|E
40|$|Abstract: Ensuring the {{security}} of the information systems in an university is not simple. When this university is scattered over about fifteen different sites, {{the security}} measures become very complex. Moreover, when you consider this university {{is one of the oldest}} in France, it is easy to understand that the habits acquired, either through the user-friendly access to the system or through ignorance, can imperil {{the security of}} the information systems. Within four years, we have tried to raise the security level so that the risks incurred would become acceptable without, as yet, plunging into an ocean of debt or destroying all attempts at innovation as far as research or pedagogy goes. Indeed the world of education presents the special characteristic of leaving a large freedom of action to the personnel, that is to say limiting restrictions and constraints, and, on the other hand, of having <b>to</b> <b>enforce</b> <b>a</b> large <b>security</b> <b>to</b> protect our patrimony. We will develop the following points: the organization and the administrative measures that have been taken, the objectives and the technica...|$|R
40|$|Configuring <b>security</b> {{mechanisms}} <b>to</b> <b>enforce</b> <b>a</b> high-level <b>security</b> {{policy is}} currently a manual, ad-hoc and error-prone process. When access control mechanisms such as firewalls, web servers, databases, file systems, etc. are inconsistently configured, significant security vulnerabilities may result. The problem is especially severe in coalition environments with cross-organizational resource sharing, limited trust and a broad user base. We describe the SPiCE translation system, which simplifies the process of generating configurations for access policy enforcers by providing two tools: (1) a policy editor for writing and refining enterprise-level access control policies for resource sharing in coalition environments; and (2) a multi-target compiler for translating these abstract access control policies into configurations for heterogeneous access policy enforcers. We define the formal semantics of the source and target access control systems and prove the safety and completeness of our translation algorithms. Our results document the characteristics of access control systems that can be modeled in our semantic framework and for which our translation approach is applicable. These results ensure that our work is applicable beyond the access control systems implemented in our prototype policy translation system...|$|R
40|$|The {{fast growing}} {{rate of the}} IoT systems with strong {{pressure}} to put devices on the market {{as soon as possible}} makes these systems vulnerable targets for cyber criminals, as recently seen in the Mirai botnet DDOS attack. A way to mitigate these threats is <b>to</b> <b>enforce</b> <b>a</b> comprehensive <b>security</b> certification process of IoT devices based on common standards. In this paper, we present an approach to improve certification of IoT devices using a combination of model-based testing and policy-based management in order to detect post certification vulnerabilities and act on them by introducing runtime policy enforcement capabilities. More precisely, we address these attacks using policy enforcement in order to correct vulnerable IoT device behavior and protect users even if security and privacy were not properly addressed by the device manufactures. We describe the details of our approach and, focusing on authorization vulnerabilities, we present a case study for the oneM 2 M standard showing how our solution can be applied in practice. JRC. E. 3 -Cyber and Digital Citizens' Securit...|$|R
40|$|We present program shepherding, {{a method}} for {{monitoring}} control flow transfers dur-ing program execution in order <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. Program shepherding provides three basic techniques as building blocks for security policies. First, pro-gram shepherding can restrict execution privileges {{on the basis of}} code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict control transfers based on instruction type, source, and target. Finally, shepherding guaran-tees that sandboxing checks around any program operation will never be bypassed. Security attacks use inevitable bugs in trusted binaries to coerce a program into performing actions that it was never intended to perform. We use static and dynamic analyses to automatically build a custom security policy for a target program, which specifies the program's execution model. An accurate execution model restricts control flow transfers only to the intended ones and can thwart attacker attempts to alter program execution. For example, shepherding will allow execution of shared librar...|$|E
40|$|The Industry 4. 0 {{paradigm}} aims {{to introduce}} smart factories which employ {{a high degree}} of automation and interconnectivity of the elements of their production networks. These factories are composed of autonomous production machines which can predict breakdowns or failures, and are capable of decision making. Human supervision is minimized, but in some cases, a human expert might be needed. To reduce the costs of travel, it is desirable to employ a remote maintenance procedure. As this opens up possible security breaches, a security policy must be designed and enforced in the remote maintenance system. This thesis proposes a Software Defined Networking (SDN) based solution <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy in the remote maintenance scenario. This solution is implemented as an application module for the Open Network Operating System (ONOS) SDN controller interacting with the policy management tool AuthZForce. The security requirements have been gathered from industry standards such as ISO 27033, and the recommendations of the German Federal Office of Information Security (BSI) for remote maintenance. The derived security policy rules are represented in the eXtensible Access Control Markup Language (XACML). The designed security policy module is tested in a virtual testbed, to show that an extensible ONOS application can serve as a policy enforcement tool in the remote maintenance scenario...|$|E
40|$|Nearly all {{security}} {{attacks have}} one thing in common: they coerce the target program into performing actions that it was never intended to perform. In short, they violate the program’s execution model. The execution model encompasses the Application Binary Interface (ABI), higher-level specifications from the program’s source programming language, and components specific to the program — for example, which values a particular function pointer may take. If this execution model were enforced, and only program actions that the programmer intended were allowed, a majority of current security holes would be closed. In this paper, we employ program shepherding [26] to enforce a program’s execution model. Program shepherding monitors control flow in order <b>to</b> <b>enforce</b> <b>a</b> <b>security</b> policy. We use static and dynamic analyses to automatically build a custom security policy for a target program which specifies the program’s execution model. We have implemented our analyses in the DynamoRIO [4, 5] runtime code modification system. The resulting system imposes minimal or no performance overhead, operates on unmodified native binaries, and requires no special hardware or operating system support. Our static analyses require source code access but not recompilation. The analysis process requires no user interaction, but is able to build a strict enough policy to prevent all deviations from the program’s control flow graph and nearly all violations of the calling convention, greatly reducing the possibility of an unintended program action. 1...|$|E
40|$|Abstract — Information hiding {{technique}} {{is a new}} kind of secret communication technology. Steganography has been proposed as a new alternative technique <b>to</b> <b>enforce</b> data <b>security.</b> <b>A</b> perfect audio Steganographic technique aim at embedding data in an imperceptible, robust and secure way and then extracting it by authorized people. Hence, up to date the main challenge in digital audio steganography is to obtain robust high capacity steganographic systems. Leaning towards designing a system that ensures high capacity or robustness and security of embedded data has led to great diversity in the existing steganographic techniques. In this paper, we present a current state of art literature on audio steganographic techniques and how it’s performed by different methods...|$|R
40|$|The {{widespread}} use of smart phones and apps with extensive access rights has left businesses vulnerable {{to a whole new}} range of attacks. Seemingly legit apps can activate the microphone or camera and during meetings or situations where sensitive information is discussed. Both users and businesses are left with few tools to ensure that no such recording can take place. This assignment will develop an anti-surveillance app to let users and businesses control access to audio and video recordings at any given point. That is, to allow users to have a range of applications on the device {{but at the same time}} be able review and/or stop apps with audio/video recording whenever that is necessary (e. g. while discussing sensitive information in a meeting). To this end the app will be able to 1. List all currently running apps that have access to audio/video recording (i. e. that potentially could be running surveillance). 2. Warn the user whenever background services are actively recording audio/video. 3. At the user discretion, close applications that either potentially can record or are actively recording audio/video. Different avenues of automation shall also be explored, so as to relieve the user of the effort in monitoring running applications and provide organisations the ability <b>to</b> remotely <b>enforce</b> <b>a</b> <b>security</b> policy. </p...|$|R
40|$|In complex networks, filters may {{be applied}} at {{different}} nodes to control how packets flow. In this paper, we study how to locate filtering functionality within a network. We show how <b>to</b> <b>enforce</b> <b>a</b> set of <b>security</b> goals while allowing maximal service {{subject to the}} security constraints. To implement our results we present a tool that given a network specification {{and a set of}} control rules automatically localizes the filters and generates configurations for all the firewalls in the network. These configurations are implemented using an extension of Mignis - an open source tool to generate firewalls from declarative, semantically explicit configurations. Our contributions include a way to specify security goals for how packets traverse the network, an algorithm to distribute filtering functionality to different nodes in the network <b>to</b> <b>enforce</b> <b>a</b> given set of <b>security</b> goals, and <b>a</b> proof that the results are compatible with a Mignis-based semantics for network behavior...|$|R
