5|10000|Public
5000|$|... "Catherine Gladstone", wrote Masterman, [...] "was one {{of those}} {{informal}} geniuses who conduct life, and with complete success, on what the poverty of language compels me <b>to</b> <b>call</b> <b>a</b> <b>method</b> of their own." ...|$|E
5000|$|<b>To</b> <b>call</b> <b>a</b> <b>method</b> with a {{delegate}} successfully, the method signature has {{to match the}} [...] with {{the same number of}} parameters of the same kind ( [...] , , [...] ) with the same type (including return type).|$|E
50|$|In {{this case}} a {{language}} that runs in a VM can use an object created in different language in the same VM.The VM operates the required abstraction of the object representation that permits <b>to</b> <b>call</b> <b>a</b> <b>method</b> of a class defined in the second language.|$|E
5000|$|Call super: Requiring subclasses <b>to</b> <b>call</b> <b>a</b> superclass's {{overridden}} <b>method</b> ...|$|R
50|$|Basili et al. {{published}} {{experimental results}} in 1996 {{suggesting that a}} lower Response For a Class (RFC, the number of methods potentially invoked in response <b>to</b> <b>calling</b> <b>a</b> <b>method</b> of that class) can reduce the probability of software bugs. Following the Law of Demeter {{can result in a}} lower RFC. However, the results also suggest that an increase in Weighted Methods per Class (WMC, the number of methods defined in each class) can increase the probability of software bugs. Following the Law of Demeter can also result in a higher WMC; see Disadvantages.|$|R
50|$|In {{the theory}} of {{object-oriented}} programming an object {{is said to have}} an internal state and is capable of receiving messages, responding to them, sending messages to other objects and changing the internal state during message handling. In more practical terminology, <b>to</b> <b>call</b> <b>an</b> object's <b>method</b> is considered the same as {{to send a message to}} the object.|$|R
5000|$|ImmutablePoint2D point = new Point2D(0,0); // a {{concrete}} instance of Point2D is referenced by the immutable interfaceint x = point.getX (...) // valid method callpoint.setX(42); // compile error: the method setX (...) {{does not exist}} on type ImmutablePoint2DBy referencing only the immutable interface, it is not valid <b>to</b> <b>call</b> <b>a</b> <b>method</b> which mutates {{the state of the}} concrete object.|$|E
5000|$|Forwarding {{is often}} {{confused}} with delegation; formally, they are complementary concepts. In both cases, {{there are two}} objects, and the first (sending, wrapper) object uses the second (receiving, wrappee) object, for example <b>to</b> <b>call</b> <b>a</b> <b>method.</b> They differ in what [...] refers to on the receiving object (formally, in the evaluation environment of the method on the receiving object): in delegation {{it refers to the}} sending object, while in forwarding it refers to the receiving object. Note that [...] is often used implicitly as part of dynamic dispatch (method resolution: which function a method name refers to).|$|E
5000|$|JSON-RPC {{works by}} sending a request to a server {{implementing}} this protocol. The client in that case is typically software intending <b>to</b> <b>call</b> <b>a</b> single <b>method</b> of <b>a</b> remote system. Multiple input parameters can be passed to the remote <b>method</b> as <b>an</b> array or object, whereas the method itself can return multiple output data as well. (This depends on the implemented version.) ...|$|R
5000|$|All {{transfer}} {{types are}} single objects, serialized using JSON. A request is <b>a</b> <b>call</b> <b>to</b> <b>a</b> specific <b>method</b> provided by <b>a</b> remote system. It must contain three certain properties: ...|$|R
2500|$|A {{feature of}} C# {{is the ability}} <b>to</b> <b>call</b> native code. <b>A</b> <b>method</b> {{signature}} is simply declared without a body and is marked as [...] The [...] attribute {{also needs to be}} added to reference the desired DLL file.|$|R
50|$|In {{object-oriented}} programming languages that support virtual methods, the compiler will automatically create a dispatch table for each object {{of a class}} containing virtual methods. This table is <b>called</b> <b>a</b> virtual <b>method</b> table or vtable, and every <b>call</b> <b>to</b> <b>a</b> virtual <b>method</b> is dispatched through the vtable.|$|R
50|$|XML-RPC {{works by}} sending an HTTP request to a server {{implementing}} the protocol. The client {{in that case}} is typically software wanting <b>to</b> <b>call</b> <b>a</b> single <b>method</b> of <b>a</b> remote system. Multiple input parameters can be passed to the remote method, one return value is returned. The parameter types allow nesting of parameters into maps and lists, thus larger structures can be transported. Therefore, XML-RPC {{can be used to}} transport objects or structures both as input and as output parameters.|$|R
5000|$|A {{feature of}} C# {{is the ability}} <b>to</b> <b>call</b> native code. <b>A</b> <b>method</b> {{signature}} is simply declared without a body and is marked as [...] The [...] attribute {{also needs to be}} added to reference the desired DLL file.DllImport("win32.dll")static extern double Pow(double a, double b); ...|$|R
3000|$|Task # 3 In the {{extracted}} OG, {{the existence}} of an object of the class ApplyAttributeAction has initially attracted our attention (node 0, Fig.  13). After discovering this object, we carefully inspected its outgoing edges and we were attracted by an edge to an object of the class RectangleFigure (node 6), since in our example we were applying the selected attributes to an rectangle. Finally, by inspecting the <b>calls</b> responsible <b>to</b> this edge—listed in a lower panel in the OG tool window—we discovered <b>a</b> <b>call</b> <b>to</b> <b>a</b> <b>method</b> named setAttribute (...) [...]. In fact, by retrieving JHotDraw’s code where this bug has been fixed, it was possible to assert that the method ApplyAttributeAction.applyAttributes (...) was the source of the reported bug. More specifically, in this <b>method,</b> <b>a</b> <b>call</b> <b>to</b> <b>a</b> Figure.changed (...) <b>method</b> was missing after calling setAttribute (...) [...].|$|R
40|$|This code {{is for the}} {{solution}} of multipoint boundary value problems in ordinary differential equations. The solution process is often <b>called</b> <b>a</b> "shooting method" but we prefer <b>to</b> <b>call</b> it <b>a</b> "superposition <b>method.</b> " Nonlinear problems are solved through a Newton-like linearization. The method of integration {{is based upon the}} Frobenius method for determining the Taylor series coefficients...|$|R
5000|$|A user of {{a website}} {{clicking}} on a [...] "keep me informed of future updates" [...] box may trigger <b>a</b> <b>call</b> <b>to</b> <b>an</b> asynchronous <b>method</b> {{of the session}} bean to add the user to a list in the company's database (this call is asynchronous because the user {{does not need to}} wait to be informed of its success or failure).|$|R
40|$|During {{electromagnetic}} forming, excessive bending of {{the specimen}} takes place {{due to high}} velocities and inertia. We show that the excessive bending can be prevented by optimizing the coil geometry in case of uniaxial tension. The process is simulated with various coil geometries, and the resulting amount of bending is compared {{to the case of}} standard Nakajima Test. The comparison shows that the bending can be minimised to acceptable levels to be able <b>to</b> <b>call</b> the <b>method</b> <b>a</b> decent way of determining forming limits. The results should be verified experimentally...|$|R
40|$|A fully {{automatic}} procedure is proposed to rapidly compute the permeability of porous materials from their binarized microstructure. The discretization is a simplified version of Peskin’s Immersed Boundary Method, where the forces are applied at the no-slip grid points. As {{needed for the}} computation of permeability, steady flows at zero Reynolds number are considered. Short run-times are achieved by eliminating the pressure and velocity variables using an Fast Fourier Transform-based and 4 Poisson problembased fast inversion approach on rectangular parallelepipeds with periodic boundary conditions. In reference <b>to</b> <b>calling</b> it <b>a</b> fast <b>method</b> using fictitious or artificial forces, the implementation is called FFF-Stokes. Large scale computations on 3 d images are quickly and automatically performed to estimate the permeability of some sample materials. A matlab implementation is provided to allow readers to experience the automation and speed of the method for realistic three-dimensional models...|$|R
40|$|Abstract—A {{distributed}} {{service-oriented architecture}} com-prises interconnected machines that together support a num-ber of services. Concurrent service requests made {{to an individual}} machine are supported with shared, and limited, resources associated with that machine. <b>A</b> <b>call</b> <b>to</b> <b>a</b> service <b>method</b> may in turn invoke methods from other services, resulting in a nesting of service calls that is represented by <b>a</b> <b>call</b> tree. Deadlock occurs when a circular dependence {{is formed as a}} result of requests (calls) waiting for machine resources to be released by other requests. A deadlock avoidance technique is derived from Dijkstra’s Banker’s Algorithm that accepts or denies preferred scheduling and method-to-machine assignments proposed by underlying policies. Assumed to be known and available are estimates for the resource requirements of methods and the structures of the call trees. Simulation studies are conducted that demonstrate the effectiveness of the approach in avoiding deadlock, while not degrading (and in most cases improving) the performance of the underlying policies...|$|R
40|$|This paper {{describes}} costa, a {{cost and}} termination analyzer for Java bytecode. The system receives as input a bytecode {{program and a}} selection of a resources of interest, and tries to bound the resource consumption of the program with respect to such a cost model. costa provides several non-trivial notions of resource, as the consumption of the heap, the number of bytecode instructions executed, the number of <b>calls</b> <b>to</b> <b>a</b> specific <b>method</b> (e. g., the library method for sending text messages in mobile phones), etc. The system uses the same machinery to infer upper bounds on cost, and for proving termination (which also implies the boundedness of any resource consumption). The demo will describe the architecture of costa and show it {{on a series of}} programs for which interesting bounds w. r. t. the above notions of resource can be obtained. Also, examples for which the system cannot obtain upper bounds, but can prove termination, will be presented. Keywords...|$|R
40|$|It will be {{difficult}} to ever know what calling strategy works best for telephone surveys. The variety of populations and topics, varying lengths of calling periods, differences in training and experience of the interviewing staff, and independent decisions made for specific surveys make this goal problematic. However, given the increasing effort required to conduct telephone surveys, it is fruitful <b>to</b> create <b>a</b> <b>calling</b> <b>method</b> that addresses <b>call</b> patterns with <b>a</b> very low probability of making contact and/or being a valid sample unit. Reducing the number of <b>calls</b> made <b>to</b> those cases and increasing the effort for more viable call patterns for making contact and completing an interview is a useful endeavor. Current calling methods are based on calling strategy research with the focus on establishing eligibility and completing interviews within the first few call attempts. Research has not really focused on {{what to do about the}} sample beyond the first few calls. The goal of this study is to focus on the total call history rather than the first few attempts. Proportional hazards modeling will be used to assess the ability to contact residences and complete interviews. The first model addresses the ability to contact and determine eligibility and the second model addresses the likelihood for interviews and refusals...|$|R
40|$|An {{organizational}} {{model of}} family problem solving interaction is described. A {{report of the}} analysis that initiated the process of testing the logic and coherence of the model follows the model 2 ̆ 7 s introduction;The organizational model is presented as <b>an</b> answer <b>to</b> the <b>call</b> for <b>a</b> <b>method</b> of integrating and managing the increasingly complex and far ranging interests of family scholars and practitioners (Klein and Tholin, 1990; Nye, 1988; Sprey, 1988, 1990). This model can pull a variety of information and perspectives together, organize them into a 2 ̆ 2 map 2 ̆ 2 of family interaction, and give a much needed, fuller picture of family behavior. The model description also contains {{a review of the}} literature that proved instrumental in determining the model 2 ̆ 7 s factors and linkages;The testing of this model commenced in a study considering the interrelationships between several of the family problem solving interaction variables as they influence family problem solving effectiveness. Theoretical predictions for each variable 2 ̆ 7 s influence on the family problem solving process were developed. The results indicate each variable plays some role in determining family problem solving effectiveness, although not necessarily the theoretically predicted role. The findings also attest to the intricacies of family interaction and underscore the importance of considering several variables simultaneously when analyzing family problem solving behavior...|$|R
40|$|Present {{distributed}} systems consist of loosely coupled fully autonomous databases on which only distributed search and {{retrieval of data}} is possible. This may develop into distributed database systems: a set of databases on multiple computers that appear to applications as one single database. An application may simultaneously access and modify the data in several databases in the network. Architectures for {{distributed systems}} in biodiversity are implemented or developed in the GBIF network, BioCASE, MaNIS, OBIS, and BioMOBY. All current systems consider {{the autonomy of the}} data sources vitally important, but the autonomy of data receivers (end users) has lower priority. Data receivers have different information needs and domains of interest. For them a ¿one integrated schema fits all¿ is not satisfactory. End users often have little need for `raw data¿ but need interpretations from calculated results based on raw data. Most current networks use a common schema like ABCD or Darwin Core. Less often implemented is standardization of data itself, and duplicate elimination and missing value substitution. This leaves us with data heterogeneity and thus interoperability problems. Therefore, in biodiversity development is towards webservices. Webservices seem a good solution to achieve interoperability. Being application-centric, webservices are: scalable, language and system independent, and easier to establish than for instance a GRID network. A new level of interoperability will provide seamless and automatic connections between applications. SOAP, WSDL, and UDDI protocols define a self-describing way <b>to</b> discover and <b>call</b> <b>a</b> <b>method</b> in <b>a</b> software application ¿ regardless of location or platform...|$|R
40|$|Every large program {{contains}} {{a small fraction}} of functionality that resists proper encapsulation. Code for debugging, logging, or locking is hard to conceal using object-oriented mechanisms alone. As a result, this code ends up scattered across many classes, which makes it a maintenance problem. At the same time, this code is largely orthogonal to surrounding (or mainline) code as it rarely impacts control or data flow. This observation gave rise to aspect-oriented programming (AOP) as a solution: Functionality is encapsulated in so-called aspects that are woven into mainline code during compilation. For existing projects to benefit from AOP, the cross-cutting concerns must be identified first; this task is called aspect mining. In this paper we address it based on the hypothesis that a typical cross-cutting concerns is added to a project within a short amount of development time: We mine CVS archives for sets of methods that got added together in various unrelated locations. To compute these efficiently, we apply formal concept analysis [3]—an algebraic theory. In this paper, we describe the basic idea and report on results from an initial evaluation of our technique. 2 Mining Cross-Cutting Concerns In our approach we first collect the data that represents the history of a project, namely all transactions to the CVS archive of the project. In a second step, we use formal concept analysis to mine aspect candidates from each transaction. 2. 1 Version Archives and Transactions The history of a project is characterised by a sequence of CVS transaction. Each transaction represents the changes, i. e. addition and deletions, between the previous and the current version. Motivated by our previous dynamic aspect mining approaches that analysed program traces [1, 2], we are only interested in changes that insert (or delete) <b>calls</b> <b>to</b> <b>methods.</b> <b>As</b> we are interested in the introduction of cross-cutting concerns (due to our hypothesis that aspects emerge over time) we omit deletions of method calls and concentrate exclusively on additions of <b>method</b> <b>calls.</b> <b>A</b> <b>method</b> <b>call</b> is characterised by two components: a location l ∈ L where the call originates (in the body of <b>a</b> <b>method)</b> and the method m ∈ M being called...|$|R
5000|$|Function <b>calls</b> <b>to</b> JNI {{methods are}} expensive, {{especially}} when <b>calling</b> <b>a</b> <b>method</b> repeatedly.|$|R
50|$|<b>A</b> one-act opera <b>called</b> <b>A</b> <b>Method</b> for Madness (1999), {{composed}} by David S. Bernstein to a libretto by Charles Kondek.|$|R
5000|$|In {{object-oriented}} computer programming, <b>an</b> extension <b>method</b> [...] is <b>a</b> <b>method</b> {{added to}} <b>an</b> object {{after the original}} object was compiled. The modified object is often a class, a prototype or <b>a</b> type. Extension <b>methods</b> are features of some object-oriented programming languages. There is no syntactic difference between <b>calling</b> <b>an</b> extension <b>method</b> and <b>calling</b> <b>a</b> <b>method</b> declared in the type definition.|$|R
50|$|In {{object-oriented}} programming, the dispose {{pattern is}} a design pattern for resource management. In this pattern, a resource {{is held by}} an object, and released by <b>calling</b> <b>a</b> <b>method</b> - usually <b>called</b> , , , , or similar - which releases any resources the object is holding onto. Many languages offer language constructs to avoid having <b>to</b> <b>call</b> the dispose method explicitly in common situations.|$|R
5000|$|For remote method {{invocation}} - can <b>call</b> <b>a</b> <b>method</b> on <b>a</b> remote object {{running on}} a web server, an alternative to Java RMI that does not need a stub compiler such as rmic ...|$|R
5000|$|The code excerpt below {{highlights}} {{the notion of}} future objects. Suppose <b>a</b> user <b>calls</b> <b>a</b> <b>method</b> foo and <b>a</b> <b>method</b> bar from <b>an</b> active object a; the foo method returns void and the bar <b>method</b> returns <b>an</b> object of class V: ...|$|R
25|$|Like in C and C++ {{there are}} {{functions}} that group reusable code. The main {{difference is that}} functions, just like in Java, have to reside inside of a class. A function is therefore <b>called</b> <b>a</b> <b>method.</b> <b>A</b> <b>method</b> has <b>a</b> return value, a name and usually some parameters initialized when it is called with some arguments. It can either belong to an instance of a class or be a static member.|$|R
50|$|The session decided <b>to</b> <b>call</b> <b>a</b> referendum, {{determine}} {{the date and}} content of the question put forward at the referendum. Announcement <b>to</b> <b>call</b> <b>a</b> referendum, its subject and date was published in the local media.|$|R
25|$|In duck typing, <b>a</b> {{statement}} <b>calling</b> <b>a</b> <b>method</b> m on <b>an</b> object {{does not}} rely on the declared type of the object; only that the object, of whatever type, must supply an implementation of the method called, when called, at run-time.|$|R
5000|$|For these reasons, for C++ code <b>to</b> <b>call</b> <b>a</b> C {{function}} , the C++ code must prototype [...] with [...] Likewise, for C code <b>to</b> <b>call</b> <b>a</b> C++ function , the C++ {{code for}} [...] must be declared with [...]|$|R
50|$|Please {{note that}} it is always {{preferable}} <b>to</b> <b>call</b> the local ANAC; only if the local ANAC number can not be called is it advisable <b>to</b> <b>call</b> <b>a</b> toll-free ANAC number. It is also preferable <b>to</b> <b>call</b> <b>an</b> open ANAC rather than the password-protected one given below.|$|R
