18|58|Public
25|$|The Burroughs 5000 offered {{hardware}} {{support for}} executable-space protection on its introduction in 1961; that capability remained in its successors {{until at least}} 2006. In its implementation of <b>tagged</b> <b>architecture,</b> each word of memory had an associated, hidden tag bit designating it code or data. Thus user programs cannot write or even read a program word, and data words cannot be executed.|$|E
50|$|Bob Barton {{was also}} very {{influential}} on Alan Kay. Kay was also impressed by the data-driven <b>tagged</b> <b>architecture</b> of the B5000 and this influenced his thinking in his developments in object-oriented programming and Smalltalk.|$|E
50|$|In a <b>tagged</b> <b>architecture,</b> {{a number}} of bits in every word of memory are {{reserved}} {{to act as a}} tag. Tagged architectures, such as the Lisp machines, often have hardware support for interpreting and processing tagged pointers.|$|E
50|$|In the Soviet Union, the Elbrus {{series of}} {{supercomputers}} pioneered {{the use of}} <b>tagged</b> <b>architectures</b> in 1973.|$|R
5000|$|Two notable {{series of}} American <b>tagged</b> <b>architectures</b> were the Lisp machines, which had tagged pointer support at the {{hardware}} and opcode level, and the Burroughs large systems, {{which had a}} data-driven <b>tagged</b> and descriptor-based <b>architecture.</b> Another [...] "exemplary" [...] instance was {{the architecture of the}} Rice Computer. Both the Burroughs and Lisp machine were examples of high-level language computer <b>architectures,</b> where the <b>tagging</b> was used to support types from a high-level language at the hardware level.|$|R
50|$|HLLCA are {{frequently}} implemented via a stack machine (as in the Burroughs Large Systems and Intel 432), and implemented the HLL via microcode in the processor (as in Burroughs Small Systems and Pascal MicroEngine). <b>Tagged</b> <b>architectures</b> {{are frequently}} {{used to support}} types (as in the Burroughs Large Systems and Lisp machines). More radical examples use a non-von Neumann architecture, though these are typically only hypothetical proposals, not actual implementations.|$|R
50|$|In {{languages}} with a <b>tagged</b> <b>architecture,</b> a possibly {{null pointer}} {{can be replaced}} with a tagged union which enforces explicit handling of the exceptional case; in fact, a possibly null pointer {{can be seen as}} a tagged pointer with a computed tag.|$|E
50|$|The Burroughs 5000 offered {{hardware}} {{support for}} executable-space protection on its introduction in 1961; that capability remained in its successors {{until at least}} 2006. In its implementation of <b>tagged</b> <b>architecture,</b> each word of memory had an associated, hidden tag bit designating it code or data. Thus user programs cannot write or even read a program word, and data words cannot be executed.|$|E
50|$|In {{computer}} science, a <b>tagged</b> <b>architecture</b> is {{a particular}} type of computer architecture where every word of memory constitutes a tagged union, being divided into a number of bits of data, and a tag section that describes the type of the data: how it is to be interpreted, and, if it is a reference, the type of the object that it points to.|$|E
30|$|We {{consider}} a hybrid UWB/UHF <b>tag</b> <b>architecture,</b> where an UWB module helps the UHF-CS procedure for tag identification {{by reducing the}} time required for tag identification and by decreasing {{the complexity of the}} UHF-CS scheme. In particular, the tags are divided in groups, and both tags and groups are associated with codes for their identification. Specifically, group codes are communicated from tags to the reader in the UWB domain, while tag codes are sent in the UHF domain.|$|R
40|$|We {{present a}} novel {{radio-frequency}} identification (RFID) system with capability of localization and tracking of passive or semi-passive tags. Localization and tracking features are enabled by backscatter modulation on ultra-wide bandwidth tag’s antenna. A ultra-high frequency signal allows the wake- {{up of the}} tags enabling the reduction of energy consumption and ensuring compatibility with existing RFID systems. The overall system {{as well as the}} reader and <b>tag</b> <b>architectures</b> are introduced. The localization and tracking performance evaluation is presented in some reference scenarios...|$|R
30|$|However, the {{possible}} integration of a UWB module {{with the existing}} UHF RFID standard technology has not been investigated yet {{and is one of}} the targets of the Green Tags (GRETA) project [8]. A few alternatives of hybrid UWB/UHF <b>tag</b> <b>architectures</b> have been investigated [8, 9] with UHF only used for energy transfer or with the UHF section providing also the communication capability. We here consider a UHF module for energy transfer and communication for tags identification, while an UWB module is used to assist and improve such tag identification process.|$|R
50|$|Tagging is a compiler-based or {{hardware-based}} (requiring a <b>tagged</b> <b>architecture)</b> {{technique for}} tagging {{the type of}} a piece of data in memory, used mainly for type checking. By marking certain areas of memory as non-executable, it effectively prevents memory allocated to store data from containing executable code. Also, certain areas of memory can be marked as non-allocated, preventing buffer overflows.|$|E
50|$|OpenLisp uses <b>tagged</b> <b>architecture</b> (4 bits tag on 32bit, 5 bits tag on 64bit) {{for fast}} type {{checking}} (small integer, float, symbol, cons, string, vector). Small integers (28 bits on 32bit, 59 bits on 64bit) are unboxed, large (32bit/64bit) integers are boxed. As required by ISLISP, bignums are also implemented. Characters (hence strings) are either 8bit (ANSI, EBCDIC) or 16/32bit if Unicode support is enabled.|$|E
50|$|Since the 1980s {{the focus}} of {{research}} and implementation in general-purpose computer architectures has primarily been in RISC-like architectures, typically internally register-rich load/store architectures, with rather stable, non-language-specific ISAs, featuring multiple registers, pipelining, and more recently multicore systems, rather than language-specific ISAs. Language support has focused on compilers and their runtimes, and interpreters and their virtual machines (particularly JIT'ing ones), with little direct hardware support. For example, the current Objective-C runtime for iOS implements tagged pointers, which it uses for type-checking and garbage collection, despite the hardware not being a <b>tagged</b> <b>architecture.</b>|$|E
40|$|International audienceRFID ICs such as EPC Class 1 GEN 2 tag are {{low cost}} tags {{which are in}} some cases used for {{critical}} or secure applications. Increasing their robustness is not trivial due to {{the wide range of}} error sinks (EM perturbations, attacks [...] .). Moreover increasing the robustness must have a minimum impact on the die area but also must fit with a standardized protocol. In this work we propose a design methodology in order to develop hardened digital <b>tag</b> <b>architecture</b> with a dedicated verification environment taking into account all RFID system parameter...|$|R
40|$|Tech ReportRecent work in {{extensible}} programming {{languages and}} operating systems by Redell, Lampson, Hewitt, and others coupled with developments in distributed computer systems motivates {{a study in}} models of the implementation of protection on <b>tagged</b> <b>architectures.</b> {{an extension of the}} notions of message and actor as discussed in previous work provides and abstract framework which may lead {{to the development of a}} suitable virtual machine. We wish to show that such a system provides a good framework for representation and protection of types, data, and procedures. National Science FoundationNational Science Foundatio...|$|R
5000|$|Members of Traditional <b>Architecture</b> Group (<b>TAG)</b> at ADAM <b>Architecture</b> include: ...|$|R
50|$|The Rice Institute Computer, {{also known}} as the Rice Computer or R1, was a 54-bit <b>tagged</b> <b>architecture</b> digital {{computer}} built during 1958-1961 (partially operational beginning in 1959) on the campus of Rice University, Houston, Texas, United States. Operating as Rice's primary computer until the middle 1960s, the Rice Institute Computer was decommissioned in 1971. The system initially used vacuum tubes and semiconductor diodes for its logic circuits; some later peripherals were built in solid-state emitter-coupled logic. It was designed by Martin H. Graham.A copy of the machine called OSAGE was built and operated at the University of Oklahoma.|$|E
50|$|Type {{checking}} {{was further}} improved and automated when the conventional byte word of 32-bits was lengthened to 36-bits for Symbolics 3600-model Lisp machines {{and eventually to}} 40-bits or more (usually, the excess bits not {{accounted for by the}} following were used for error-correcting codes). The first group of extra bits were used to hold type data, making the machine a <b>tagged</b> <b>architecture,</b> and the remaining bits were used to implement CDR coding (wherein the usual linked list elements are compressed to occupy roughly half the space), aiding garbage collection by reportedly an order of magnitude. A further improvement was two microcode instructions which specifically supported Lisp functions, reducing the cost of calling a function to as little as 20 clock cycles, in some Symbolics implementations.|$|E
50|$|In 1973, Richard Greenblatt and Thomas Knight, programmers at Massachusetts Institute of Technology (MIT) Artificial Intelligence Laboratory (AI Lab), began {{what would}} become the MIT Lisp Machine Project when they first began {{building}} a computer hardwired to run certain basic Lisp operations, rather than run them in software, in a 24-bit <b>tagged</b> <b>architecture.</b> The machine also did incremental (or Arena) garbage collection. More specifically, since Lisp variables are typed at runtime rather than compile time, a simple addition of two variables could take five times as long on conventional hardware, due to test and branch instructions. Lisp Machines ran the tests in parallel with the more conventional single instruction additions. If the simultaneous tests failed, then the result was discarded and recomputed; this meant in many cases a speed increase by several factors. This simultaneous checking approach was used as well in testing the bounds of arrays when referenced, and other memory management necessities (not merely garbage collection or arrays).|$|E
30|$|Thanks {{to their}} low power consumption, IR-UWB {{transmitters}} can be adopted successfully for both active and passive tags. UWB {{has been proposed}} to realize low consumption and low complexity active radio-frequency (RF) tags for precision asset location systems [17]. Recently, some commercial proprietary real time locating systems (RTLSs) have been introduced based on tags emitting UWB pulses with extremely low duty cycles to ensure high battery duration. Another example of low complexity <b>tag</b> <b>architecture</b> is given in [18] where {{the concept of a}} UWB-based pseudo-random active reflector, which does not require the presence in the tag of a modulator and demodulator, is introduced.|$|R
5000|$|This editor {{was meant}} to be a Potlatch 2 {{architecture}} reimplementation in JavaScript with redesigned user interface. The only big internal change was departure from XML <b>tagging</b> preset <b>architecture</b> to a JSON-based one.|$|R
40|$|Today, {{the most}} common avenue for {{exploitation}} of computer systems is a control-flow attack in which the attacker gains direct or indirect control of the instruction pointer. In order to gain remote code execution, attackers then exploit legitimate fragments of code in the executable via techniques such as return-oriented-programming or virtual table overwrites. This project aims to answer fundamental questions about the efficacy of control-flow-integrity (CFI), a defensive technique which attempts to prevent such attacks by ensuring that every control flow transfer corresponds to the original intent of the program author. Although this problem is in general undecidable, most programs running on modern operating systems adhere to standard conventions which allow inferences from static analysis to set a specification for allowable runtime behavior. 1. By examining extremely large, complex real-world programs such as web browsers, this project will characterize the fundamental limits of CFI techniques. We find {{that it is possible}} for a program in which CFI is perfectly enforced to be exploited via a novel control flow attacks. 2. We examine the potential for hardware support for CFI and other techniques via generalized <b>tagged</b> <b>architectures,</b> and explore the tradeoff between the compatibility, performance, and security guarantees of hardware-assisted policies on <b>tagged</b> <b>architectures.</b> by Isaac Noah Evans. Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2015. This electronic version was submitted by the student author. The certified thesis is available in the Institute Archives and Special Collections. Cataloged from student-submitted PDF version of thesis. Includes bibliographical references (pages 73 - 77) ...|$|R
40|$|Abstract — Much {{research}} has been done on tagged architectures but most of it took place over 10 years ago and did not provide quantitative evidence. In this paper, we propose a tagged MIPS architecture and employ SimpleScalar simulator to make a quantitative analysis on the performance impact of <b>tagged</b> <b>architecture.</b> With SPEC 95 benchmarks we evaluate the performance loss in terms of CPU execution time and L 2 cache misses. Since the tagged machine uses more registers than nontagged ones, we also measure the performance after reserving about half of registers for tags. The experiment result shows that 1) a major bottleneck to implement a high performance tagged machine is tagged penalty; 2) there is only little performance loss in terms of L 2 cache misses; 3) reserving 12 out of 32 registers does not result a great performance decrease. We believe the insights from our analysis are helpful for guiding the future high performance <b>tagged</b> <b>architecture</b> design. I...|$|E
40|$|A <b>tagged</b> <b>architecture</b> is {{a system}} that applies tags on data, {{recently}} used in the field of information security. / The previous studies using <b>tagged</b> <b>architecture</b> mostly focused on how to utilize tags, not how the tags are implemented. A naive implementation of tags simply adds a tag field to every byte of the cache and the memory. Such technique, however, results in a huge hardware overhead and performance degradation, as well as is unable to support variable-length tags. / This thesis proposes a low-overhead security-tagged architecture that supports variable-length tags. We achieve our goal by separating tag and data completely. The proposal technique is composed of two parts, separation in storage and separation in execution. / First, in the separation of storage, we exploiting some properties of tag, the non-uniformity and the locality of reference. Our design includes a use of uniquely designed multi-level table and various cache-like structures, all contributing to exploit these properties. / Second, in the separation of execution, we suggest to propagate tags after the completion of execution of data. This allows to have dedicated tag register file and L 1 tag cache, so that prevent to increase in the access latency for register and cache. Under simulation, our method was able to reduce the memory overhead to 3. 48 % of the naive implementation, and 4. 96 % of IPC degradation compared with conventional computer system, in addition to supporting variable-length tag. 報告番号:; 学位授与年月日: 2009 - 03 - 23; 学位の種別: 修士; 学位の種類: 修士(情報理工学); 学位記番号:; 研究科・専攻: 情報理工学系研究科電子情報学専...|$|E
40|$|In this thesis, {{we argue}} that {{software-based}} defenses to code reuse attacks are fundamentally flawed. With code pointer integrity as a case study, we show that a secure and efficient software-based defense to code reuse attacks is impossible and thus motivate the case for hardware approaches. We then propose our <b>tagged</b> <b>architecture</b> system Taxi (Tagged C) as a practical defense against code reuse attacks which minimally modifies existing hardware components. We also propose strong defense policies which aim to guarantee security while minimizing tag memory usage. Our Taxi prototype, a modified RISC-V ISA simulator, demonstrates that we can defeat code reuse attacks with high compatibility and low memory overhead. by Samuel Fingeret. Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2015. This electronic version was submitted by the student author. The certified thesis {{is available in the}} Institute Archives and Special Collections. Cataloged from student-submitted PDF version of thesis. Includes bibliographical references (pages 93 - 97) ...|$|E
40|$|In {{this paper}} {{we present a}} novel active radio {{frequency}} identification system consisting of transponders with low complexity, low power consumption, and long system circuit integration area indicate that the production cost {{is comparable to the}} one of a passive tag. The hardware keystone is -up transceiver, which is a single oscillator with very low power consumption. The communication protocol, based on frequency signalling binary tree, contributes to the low complexity of the <b>tag</b> <b>architecture.</b> More than 1500 tags can be read per second. The average transponder ID read-out delay is 319 ms when there are 1000 transponders within reach of the interrogator. The calculated expected life time for a transponder is estimated to be almost three years...|$|R
40|$|This paper {{proposes a}} {{flexible}} and unified <b>tagging</b> <b>architecture</b> {{that could be}} incorporated {{into a number of}} applications like information extraction, cross-language information retrieval, term extraction, or summarization, while providing an essential component for subsequent syntactic processing or lexicographical work. A feature-based multi-tiered approach (FBT tagger) is introduced to part-of-speech tagging. FBT is a variant of the well-known transformation based learning paradigm aiming at improving the quality of tagging highly inflective languages such as Greek. Additionally, a large experiment concerning the Greek language is conducted and results are presented for a variety of text genres, including financial reports, newswires, press releases and technical manuals. Finally, the adopted evaluation methodology is discussed. 1...|$|R
50|$|Hardware {{architectures}} for dataflow {{was a major}} {{topic in}} computer architecture research in the 1970s and early 1980s. Jack Dennis of MIT pioneered the field of static dataflow architectures while the Manchester Dataflow Machine and MIT <b>Tagged</b> Token <b>architecture</b> were major projects in dynamic dataflow.|$|R
40|$|Buffer {{overflow}} is {{a well-known}} problem that remains a threat to software security. With the advancement of code-reuse attacks and return-oriented programming (ROP), it becomes problematic to protect a program from being compromised. Several defenses have been developed {{in an attempt to}} defeat code-reuse attacks. However, there is still no solution that provides complete protection with low overhead. In this thesis, we improved TAXI, a ROP defense technique that utilizes a <b>tagged</b> <b>architecture</b> to prevent memory violations. Inspired by Programmable Unit for Metadata Processing (PUMP), we modified TAXI so that enforcement policies can be programmed by user-level code and called it P-TAXI (Programmable TAXI). We demonstrated that, by using P-TAXI, we were able to enforce memory safety policies, including return address protection, stack garbage collection, and memory compartmentalization. In addition, we showed that P-TAXI can be used for debugging and taint tracking. by Witchakorn Kamolpornwijit. Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2016. This electronic version was submitted by the student author. The certified thesis is available in the Institute Archives and Special Collections. Cataloged from student-submitted PDF version of thesis. Includes bibliographical references (pages 104 - 112) ...|$|E
40|$|This thesis {{describes}} Optimist, an optimizing compiler for the Concurrent Smalltalk language {{developed by}} the Concurrent VLSI Architecture Group. Optimist compiles Concurrent Smalltalk to the assembly language of the Message-Driven Processor (MDP). The compiler includes numerous optimization techniques such as dead code elimination, dataflow analysis, constant folding, move elimination, concurrency analysis, duplicate code merging, tail forwarding, use of register variables, as well as various MDP-specific optimizations in the code generator. The MDP presents some unique challenges and opportunities for compilation. Due to the MDP's small memory size, {{it is critical that}} the size of the generated code be as small as possible. The MDP is an inherently concurrent processor with efficient mechanisms for sending and receiving messages; the compiler takes advantage of these mechanisms. The MDP's <b>tagged</b> <b>architecture</b> allows very efficient support of object-oriented languages such as Concurrent Smalltalk. The initial goals for the MDP were to have the MDP execute about twenty instructions per method and contain 4096 words of memory. This compiler shows that these goals are too optimistic [...] most methods are longer, both in terms of code size and running time. Thus, the memory size of the MDP should be increased...|$|E
40|$|This paper {{discusses}} {{garbage collection}} techniques {{used in a}} high-performance Lisp implementation with a large virtual memory, the Symbolics 3600. Particular {{attention is paid to}} practical issues and experience. In a large system problems of scale appear and the most straightforward garbage-collection techniques do not work well. Many of these problems involve the interaction of the garbage collector with demand-paged virtual memory. Some of the solutions adopted in the 3600 are presented, including incremental copying garbage collection, approximately depth-first copying, ephemeral objects, <b>tagged</b> <b>architecture,</b> and hardware assists. We discuss techniques for improving the efficiency of garbage collection by recognizing that objects in the Lisp world have a variety of lifetimes. The importance of designing the architecture and the hardware to facilitate garbage collection is stressed. Automatic Storage Management Storage management is the part of a Lisp implementation that controls the use of memory to contain representations of objects. When a new object is created, memory must be allocated to contain its representation. When an object is no longer in use, the memory occupied by its representation can be reused for other purposes. Storage management can {{have a major impact on}} the efficiency and usability of a Lisp system. Automatic storage management allows the user to think entirely in terms of objects while the system takes care of the memory behind the scenes. Its most important aspect is automatic storage reclamation: the system finds all the objects that can be proved to be no longer in use and Permission to copy without fee all oz &quot; part of this material is granted provided that the copies arc not made or distributed for direct commercial advantagc, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is b...|$|E
30|$|The {{main task}} of the {{receiver}} section of the reader is to detect the useful backscattered signal component (i.e., the antenna mode scattering dependent on antenna load changes) from the signals backscattered by the antenna structural mode and other scatterers (clutter), which are, in general, dominant. To this purpose, a quite general backscatter modulator architecture has been proposed in [24], allowing for different signaling schemes, such as pulse amplitude modulation (PAM), pulse position modulation (PPM), and ON-OFF keying. In this study, {{the performance of a}} simplified version of the <b>tag</b> <b>architecture</b> in [24] by considering the 2 -PAM signaling is analyzed. In this case, the backscatter modulator reduces to a simple switch as shown in Figure 4. The analysis can be easily extended to other signaling schemes.|$|R
40|$|Abstract — Most {{traditional}} {{requirements engineering}} and elicitation techniques {{assume that the}} requirements being developed are high-level requirements for a new, “green-field” system. However, {{this is not always}} the case. In established domains, systems are often developed as new members of existing product lines. In these cases, architectural design knowledge already exists within the product line, and the need is for detailed engineering requirements rather than high-level requirements. To address this situation, we propose the Co-Evolving Traceable Requirements and Architecture Network (COTRAN) technique, a novel collaborative requirements engineering technique that elicits detailed engineering requirements for new product line members through <b>tagging</b> <b>architecture</b> artifacts. We then discuss improvements in requirements generated using COTRAN on an industrial aerospace project. Index Terms—Requirements engineering, software <b>architecture,</b> aerospace, <b>tagging.</b> I...|$|R
40|$|Abstract—This paper {{presents}} a novel method for incorporating a capacitive touch interface into existing passive RFID <b>tag</b> <b>architectures</b> without additional parts or {{changes to the}} manufacturing process. Our approach employs the tag’s antenna as a dual function element in which the antenna simultaneously acts as both a low-frequency capacitive fringing electric field sensor and also as an RF antenna. To demonstrate the feasibility of our approach, we have prototyped a passive UHF tag with capacitive sensing capability integrated into the antenna port using the WISP tag. Finally, we describe how this technology {{can be used for}} touch interfaces as well as other applications {{with the addition of a}} LED for user feedback. Index Terms—Passive RFID, touch interface, capacitive sensor, transponde...|$|R
