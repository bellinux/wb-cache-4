3|13|Public
5000|$|Robert-Houdin {{even made}} the test difficult. He placed {{a glass of}} water into his son's hands, and Emile {{proceeded}} to drink from it. He was able to perceive the taste of the liquids that spectators from the audience merely thought of. [...] Even then, the audiences were not entirely convinced, they tried to trip up Emile by bringing in books written in Greek, or odd tools such as a <b>thread</b> <b>counter.</b>|$|E
50|$|The {{simplest}} hardware implementation uses dedicated {{wires to}} transmit signal to implement barrier. This dedicated wire performs OR/AND operation {{to act as}} the pass/block flags and <b>thread</b> <b>counter.</b> For small systems, such a model works and communication speed {{is not a major}} concern. In large multiprocessor systems this hardware design can make barrier implementation have high latency. The network connection among processors is one implementation to lower the latency, which is analogous to Combining Tree Barrier.|$|E
40|$|This {{research}} project {{was conducted to}} increase weld gap tolerance in Friction Stir Welding (FSW) of 8 mm thick aluminum alloy 6082 – T 6. Investigation was done on I-STIR PDS platform and a Johnford milling machine. The {{research project}} involved tool-pin design with varying re-entrant features and varying parameters {{as a method of}} weld gap closing to produce successful welds. Direction of spindle rotation and dwell time were established as part of a preliminary study. Clockwise spindle rotation with 20 seconds dwell time allows sufficient plasticity and improved material flow which assisted in achieving welds with prior 30 percent weld gap of the plate thickness. Final welds were made using three rotational speeds and feed rates with sufficient plunging to prevent root defects. Analysis of the results were detailed which include vickers microhardness test, tensile test and metallographic observation to access the suitability of the weld structure. From the set of tool-pins designed, the flare tool-pin gave a well-defined weld nugget with improved stirring at the weld root. Also, with a concave shoulder, right hand threaded tool-pin and counterclockwise flutes undergoing a clockwise spindle rotation, plasticized material flow was upward which was beneficial in reducing the amount of plate thinning. The right hand <b>thread</b> <b>counter</b> clockwise flute with a flute machined in the foot exhibited superior tensile strength for welds containing 30 percent weld gap...|$|E
40|$|Abstract. We present Boom, a {{comprehensive}} analysis tool for Bool-ean programs. We focus {{in this paper}} on model-checking non-recursive concurrent programs. Boom implements a recent variant of <b>counter</b> ab-straction, where <b>thread</b> <b>counters</b> are used in a program-context aware way. While designed for bounded counters, this method also integrates well with the Karp-Miller tree construction for vector addition systems, resulting in a reachability engine for programs with unbounded thread cre-ation. The concurrent version of Boom is implemented using BDDs and includes partial order reduction methods. Boom is intended for model checking system-level code via predicate abstraction. We present exper-imental results for the verification of Boolean device driver models. ...|$|R
40|$|Abstract. The {{trend towards}} {{multi-core}} computing has made concurrent software an important target of computer-aided verification. Unfortunately, Model Checkers for such software suffer tremendously from combinatorial state space explosion. We show {{how to apply}} counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by a}} vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward implementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. Our experiments are carried out on Boolean programs, an abstraction promoted by the Slam project. To our knowledge, this marks the first application of counter abstraction to programs with non-trivial local state spaces, and results in the first scalable Model Checker for concurrent Boolean programs. ...|$|R
50|$|Performance Analyzer is {{available}} {{as part of}} Oracle Developer Studio. It has visualization capabilities, can read out hardware performance <b>counters,</b> <b>thread</b> synchronization, memory allocations and I/O, and specifically supports Java, OpenMP, MPI, and the Solaris kernel.|$|R
40|$|Abstract The {{trend towards}} {{multi-core}} computing has made concurrent software an im-portant target of computer-aided verification. Unfortunately, Model Checkers for such soft-ware suffer tremendously from combinatorial state space explosion. We show how to ap-ply counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by}} a vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward im-plementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. We have carried out experiments on Boolean programs, an abstraction promoted by the success of the SLAM project. The ex-periments give evidence of the applicability of our method to realistic programs, and of the often huge savings obtained in comparison to plain symbolic state space exploration, and to exploration optimized by partial-order methods. To our knowledge, our tool marks the first implementation of counter abstraction to programs with non-trivial local state spaces, resulting in a Model Checker for concurrent Boolean programs that promises true scalability...|$|R
40|$|The {{trend towards}} {{multi-core}} computing has made concurrent software an important target of computer-aided verification. Unfortunately, Model Checkers for such software suffer tremendously from combinatorial state space explosion. We show {{how to apply}} counter abstraction to real-world concurrent programs to factor out redundancy due to thread replication. The traditional global state representation as a vector of local states {{is replaced by a}} vector of <b>thread</b> <b>counters,</b> one per local state. In practice, straightforward implementations of this idea are unfavorably sensitive to the number of local states. We present a novel symbolic exploration algorithm that avoids this problem by carefully scheduling which counters to track at any moment during the search. We have carried out experiments on Boolean programs, an abstraction promoted by the success of the Slam project. The experiments give evidence of the applicability of our method to realistic programs, and of the often huge savings obtained in comparison to plain symbolic state space exploration, and to exploration optimized by partial-order methods. To our knowledge, our tool marks the first implementation of counter abstraction to programs with non-trivial local state spaces, resulting in a Model Checker for concurrent Boolean programs that promises true scalability. © 2010 Springer Science+Business Media, LLC...|$|R
50|$|In some games, {{miniature}} {{figures are}} used to determine line of sight. Many wargames use counters to represent units and determine line of sight. A common technique is to hold a length of <b>thread</b> between two <b>counters.</b> If the <b>thread,</b> held straight, doesn't encounter any obstacles, the line of sight is valid.|$|R
40|$|Abstract. As known, {{satellite}} systems {{operate in a}} harsh environment. Nowa-days {{one of the main}} topics is space debris driven by different incidents. The Chinese ASAT-test in 2007 with the FENGYUN- 1 C weather satellite or the collision of the COSMO 2251 and an IRIDIUM 33 satellite in 2009 are exam-ples of those incidents. But space debris is only one color of the huge spectrum of possible threats for spaceborne systems. If we want to protect our systems, {{we have to look at}} the big picture and try to determine the major impacts to tweak the most important <b>threads</b> with <b>counter</b> measurements and so to increase the protection level of spaceborne systems...|$|R
40|$|This thesis {{presents}} {{the design of}} the Configuration and Diagnostic units of the MAP chip. The MAP chip is a new microprocessor being developed for the M-Machine project. The Configuration units allow for the storage and access to various <b>counters,</b> <b>thread</b> state, and cluster data needed for thread swap. The diagnostics unit is responsible for booting the processor and is used as the interface between the external pins and the DIP and SCAN chains...|$|R
40|$|Multiple <b>threads</b> (program <b>counters</b> {{executing}} in {{the same}} address space) {{make it easier to}} write programs that deal with related asynchronous activities and that execute faster on shared-memory multiprocessors. Supporting multiple threads places new constraints on the design of operating system interfaces. Part I of this report presents guidelines for designing (or redesigning) interfaces for multithreaded clients. We show how these guidelines were used to design an interface to UNIX 1 -compatible file and process management facilities in the Topaz operating system. Two implementations of this interface are in everyday use: a native one for the Firefly multiprocessor, and a layered one running within a UNIX process. Part II is the actual programmer's manual for the interface discussed in Part I. Paul R. McJones and Garret F. Swart Capsule review Unix was designed to support client address spaces containing exactly one program counter. This assumption about a Unix process has had a r [...] ...|$|R
40|$|Synchronization {{is the use}} of {{language}} or library mechanisms to constrain the ordering (interleaving) of instructions performed by separate threads, to preclude orderings that lead to incorrect or undesired results. Discussion In a parallel program, the instructions of any given thread appear to occur in sequential order (at least from that thread’s point of view), but if the threads run independently, their sequences of instructions may interleave arbitrarily, and many of the possible interleavings may produce incorrect results. As a trivial example, consider a global counter incremented by multiple threads. Each <b>thread</b> loads the <b>counter</b> into a register, increments the register, and writes the updated value back to memory. If two threads load the same value before either stores it back, updates may be lost: c = = 0 Thread 1 : Thread 2 : r 1 : = c r 1 : =...|$|R
40|$|As {{the push}} for {{parallelism}} continues {{to increase the number}} of cores on a chip, and add to the complexity of system design, the task of optimizing performance at the application level becomes nearly impossible for the programmer. Much effort has been spent on developing techniques for optimizing performance at runtime, but many techniques for modern processors employ the use of speculative <b>threads</b> or performance <b>counters.</b> These approaches result in stolen cycles, or the use of an extra core, and such expensive penalties put demanding constraints on the gains provided by such methods. While processors have grown in power and complexity, the technology for small, efficient cores has emerged. We introduce the concept of Partner Cores for maximizing hardware power efficiency; these are low-area, low-power cores situated on-die, tightly coupled to each main processor core. We demonstrate that such cores enable performance improvement without incurring expensive penalties, and carry out potential applications that are impossible on a traditional chip multiprocessor...|$|R
40|$|As {{the push}} for {{parallelism}} continues {{to increase the number}} of cores on a chip, system design has become incredibly complex; optimizing for performance and power efficiency is now nearly impossible for the appli-cation programmer. To assist the programmer, a variety of techniques for optimizing performance and power at runtime have been developed, but many employ the use of speculative <b>threads</b> or performance <b>counters.</b> These approaches result in stolen cycles, or the use of an extra core, and such expensive penalties can greatly reduce the potential gains. At the same time that general purpose processors have grown larger and more complex, technologies for smaller embedded processors have pushed towards energy effi-ciency. In this paper, we combine the two and introduce the concept of Partner Cores: low-area, low-power cores paired with larger, faster compute cores. A partner core is tightly coupled to each main processing core, allow-ing it to perform various optimizations and functions that are impossible on a traditional chip multiprocessor. This paper demonstrates that optimization code running on a partner core can increase performance and provide a net improvement in power efficiency. ...|$|R
40|$|Although chip-multiprocessors {{have become}} the {{industry}} standard, developing parallel applications that target them remains a daunting task. Non-determinism, inherent in threaded applications, causes significant challenges for par-allel programmers by hindering their ability to create parallel applications with repeatable results. As a consequence, par-allel applications are significantly harder to debug, test, and maintain than sequential programs. This paper introduces Kendo: a new software-only sys-tem that provides deterministic multithreading of parallel applications. Kendo enforces a deterministic interleaving of lock acquisitions and specially declared non-protected reads through a novel dynamically load-balanced deterministic scheduling algorithm. The algorithm tracks the progress of each <b>thread</b> using performance <b>counters</b> to construct a deterministic logical time {{that is used to}} compute an inter-leaving of shared data accesses that is both deterministic and provides good load balancing. Kendo can run on to-day’s commodity hardware while incurring only a modest performance cost. Experimental results on the SPLASH- 2 applications yield a geometric mean overhead of only 16 % when running on 4 processors. This low overhead makes it possible to benefit from Kendo even after an application is deployed. Programmers can start using Kendo today to pro-gram parallel applications that are easier to develop, debug, and test...|$|R

