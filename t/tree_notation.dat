30|27|Public
5000|$|For a {{complete}} reference to behavior <b>tree</b> <b>notation,</b> version 1.0, see: Behavior <b>Tree</b> <b>Notation</b> v1.0 (2007) ...|$|E
50|$|A {{behavior}} tree is used {{to formally}} represent the fragment of behavior in each individual requirement. Behavior for a large-scale system in general, where concurrency is admitted, appears abstractly {{as a set of}} communicating sequential processes. The behavior <b>tree</b> <b>notation</b> captures these composed component-states in a simple tree-like form.|$|E
50|$|The {{behavior}} tree representation, (with {{the help}} of the composition tree representation that resolves alias and other vocabulary problems with large sets of requirements) allows people to avoid short-term memory overload and produce a deep, accurate, holistic representation of system needs that can be understood by all stakeholders because it strictly uses the vocabulary of the original requirements. Because the behavior <b>tree</b> <b>notation</b> uses a formal semantics, for any given example, it already is, or can be made executable.|$|E
40|$|Abstract: In this paper, we are {{exploring}} {{the roles of}} patterns in model-based design. In particular, we discuss the fundamental concepts underlying a generic notation for task patterns. Different views of patterns are suggested using UML and Concurrent Task <b>Tree</b> <b>notations.</b> A first classification of patterns according to models is also suggested...|$|R
50|$|Because {{behavior}} trees describe complex behavior, {{they can}} be used for describing a range of systems not limited to those that arecomputer-based. In a biological context, BTs can be used to piece together a procedural interpretation of biological functionsdescribed in research papers, treating the papers as the requirements documents as described above. This can help to construct a more concrete description of the process than is possible from reading only, and can also be used as the basis for comparing competing theories in alternative papers. In ongoing research, the behavior <b>trees</b> <b>notation</b> is being used to develop models of the brain function in rats under fear conditioning.|$|R
40|$|Abstract: Starting {{from some}} general considerations, we will outline {{different}} kinds of patterns that can impact {{the creation of the}} task model. We will then introduce a 4 -part “strategy ” about the process of pattern application followed by an analysis about what a formal notation for patterns for the task model should encapsulate. In particular, we discuss the fundamental concepts underlying a generic notation for patterns. By using task patterns, different views of patterns are suggested using UML and Concurrent Task <b>Tree</b> <b>notations.</b> A first classification of patterns according to models is also drawn. Finally, we will introduce a tool that acts as a wizard and guides pattern users throughout the process of pattern application...|$|R
50|$|Since the {{behavior}} <b>tree</b> <b>notation</b> was originally conceived {{a number of}} people from the DCCS (Dependable Complex Computer-based Systems Group - a joint University of Queensland, Griffith University research group) have made important contributions to the evolution and refinement of the notation and to the use of behavior trees. Members of this group include: David Carrington, Rob Colvin, Geoff Dromey, Lars Grunske, Ian Hayes, Diana Kirk, Peter Lindsay, Toby Myers, Dan Powell, John Seagrott, Cameron Smith, Larry Wen, Nisansala Yatapanage, Kirsten Winter, Saad Zafar, Forest Zheng.|$|E
50|$|Traceability tags (see Section 1.2 of {{behavior}} <b>tree</b> <b>notation)</b> in behavior tree nodes link the formal representation to the corresponding natural language requirement. Behavior trees accurately capture behavior {{expressed in the}} natural language representation of functional requirements. Requirements behavior trees strictly use the vocabulary of the natural language requirements but employ graphical forms for behavior composition in order to eliminate risk of ambiguity. By doing this they provide a direct and clearly traceable relationship between what is expressed in the natural language representation and its formal specification.|$|E
50|$|To ensure correct {{implementation}} of complex access control requirements, {{it is important}} that the validated and verified requirements are effectively integrated with the rest of the system. It is also important that the system can be validated and verified early in the development process. An integrated, role-based access control model has been developed. The model is based on the graphical behavior <b>tree</b> <b>notation,</b> and can be validated by simulation, as well as verified using a model checker. Using this model, access control requirements can be integrated with the rest of the system from the outset, because: a single notation is used to express both access control and functional requirements; a systematic and incremental approach to constructing a formal behavior tree specification can be adopted; and the specification can be simulated and model checked. The effectiveness of the model has been evaluated using a case study with distributed access control requirements.|$|E
40|$|Abstract — Recursive auto-associative memory (RAAM) net-works are neural {{networks}} {{that can be}} trained to represent structured information. After training, this information can be retrieved following its inner structure. By now, RAAM networks were applied only to syntactical expressions like parse trees of natural language sentences or logical terms. In this paper it is shown {{how they can be}} used for representing vector graphics that are given in <b>tree</b> like <b>notation.</b> For this purpose we developed Named RAAM networks which are more suitable for the training of complex information than normal RAAMs. I...|$|R
40|$|We {{describe}} {{a component of}} a document analysis system for constructing ontologies for domain-specific web tables imported into Excel. This component automates extraction of the Wang Notation for the column header of a table. Using column-header specific rules for XY cutting we convert the geometric structure of the column header to a linear string denoting cell attributes and directions of cuts. The string representation is parsed by a contextfree grammar and the parse tree is further processed to produce an abstract data-type representation (the Wang <b>notation</b> <b>tree)</b> of each column category. Experiments were carried out to evaluate this scheme on the original and edited column headers of Excel tables drawn from a collection of 200 used in our earlier work. The transformed headers were obtained by editing the original column headers {{to conform to the}} format targeted by our grammar. Fortyfour original headers and their reformatted versions were submitted as input to our software system. Our grammar was able to parse and the extract Wang <b>notation</b> <b>tree</b> for all the edited headers, but for only four of the original headers. We suggest extensions to our table grammar that would enable processing a larger fraction of headers without manual editing...|$|R
40|$|Abstract. For complex {{engineered}} systems, it {{is important}} to conduct technical risk assessment early in the system development life-cycle, in order to identify critical system requirements, such as safety requirements, that should be included in design. This paper proposes a model-based approach to such assessment, which can be applied from the system requirements analysis stage onwards. The approach starts with the application of the Behaviour <b>Trees</b> modelling <b>notation</b> to natural language functional requirements. The BT model is then extended to include the events and conditions that might contribute to hazards, and automated model checking is used to identify the mechanisms by which component or subsystem failures can lead to hazardous system failures. The approach is intended to be used iteratively in design and analysis, to assist system designers in assessing the effectiveness of system safety requirements. A hypothetical bushfire-fighting management system is used to illustrate the approach. Overview and Scope 1...|$|R
40|$|This paper {{presents}} <b>Tree</b> <b>Notation,</b> a new simple, universal syntax. Language designers can invent new programming languages, called Tree Languages, {{on top of}} <b>Tree</b> <b>Notation.</b> Tree Languages have {{a number}} of advantages over traditional programming languages. We include a Visual Abstract to succinctly display the problem and discovery. Then we describe the problem [...] the BNF to abstract syntax tree (AST) parse step [...] and introduce the novel solution we discovered: a new family of 2 D programming languages that are written directly as geometric trees...|$|E
40|$|Property {{specifications}} concisely {{describe what}} {{a system is}} supposed to do. No matter what notation is used to describe them, however, {{it is difficult to}} represent these properties correctly, since there are often subtle, but important, details that need to be considered. Propel aims to guide users through the process of creating properties that are both accessible and mathematically precise, by providing templates for commonly-occurring property patterns. These templates explicitly represent these subtle details as options. In this paper, we present a new representation of these templates, a Question <b>Tree</b> <b>notation</b> that asks users a hierarchical sequence of questions about their intended properties. The Question <b>Tree</b> <b>notation</b> is particularly useful for helping to select the appropriate template, but it also complements the finite-state automaton and disciplined natural language representations provided by Propel. We also report on some case studies that are using Propel and on an experimental evaluation of the understandability of the disciplined natural language representation...|$|E
40|$|The Behavior <b>Tree</b> <b>notation</b> {{has been}} {{developed}} as a method for systematically and traceably capturing user requirements. In this paper we extend the notation with probabilistic behaviour, so that reliability, performance, and other dependability properties can be expressed. The semantics of probabilistic timed Behavior Trees is given by mapping them to probabilistic timed automata. We gain advantages for requirements capture using Behavior Trees by incorporating into the notation an existing elegant specification formalism (probabilistic timed automata) which has tool support for formal analysis of probabilistic user requirements...|$|E
40|$|For complex {{engineered}} systems, it {{is important}} to conduct technical risk assessment early in the system development life-cycle, in order to identify critical system requirements, such as safety requirements, that should be included in design. This paper proposes a model-based approach to such assessment, which can be applied from the system requirements analysis stage onwards. The approach starts with the application of the Behaviour <b>Trees</b> modelling <b>notation</b> to natural language functional requirements. The BT model is then extended to include the events and conditions that might contribute to hazards, and automated model checking is used to identify the mechanisms by which component or subsystem failures can lead to hazardous system failures. The approach is intended to be used iteratively in design and analysis, to assist system designers in assessing the effectiveness of system safety requirements. A hypothetical bushfire-fighting management system is used to illustrate the approach...|$|R
40|$|Abstract. String suffix automata accept all suffixes {{of a given}} {{string and}} belong to the {{fundamental}} stringology principles. Extending their transitions by specific pushdown operations results in new subtree pushdown automata, which accept all subtrees of a given subject <b>tree</b> in prefix <b>notation</b> and are analogous to the suffix automata in their properties. The deterministic subtree pushdown automaton accepts an input subtree in time linear {{to the number of}} nodes of the subtree and its total size is linear to the number of nodes of the given subject tree...|$|R
40|$|This paper {{describes}} a ''textual <b>tree</b> trace'' (TTT) <b>notation</b> for representing {{the execution of}} Prolog programs. Compact, textual and non-linear, it provides detailed information about variable binding and execution history, and distinguishes several modes of goal failure. The revised form given here, yet to be empirically tested, is partly informed by Paul Mulholland's empirical comparisons of Prolog trace notations, in which {{an earlier version of}} the TTT notation was amongst those studied and criticised. The work presented here is an updated version of a previous workshop paper (Taylor, du Boulay, & Patel, 1994) ...|$|R
40|$|Abstract. Behaviour Trees {{is a novel}} {{approach}} for requirements engineering. It advocates a graphical <b>tree</b> <b>notation</b> that is {{easy to use and}} to understand. Individual requirements are modelled as single trees which later on are integrated into a model of the system as a whole. We develop a formal semantics for a subset of Behaviour Trees using CSP. This work, on one hand, provides tool support for Behaviour Trees. On the other hand, it builds a front-end to a subset of the CSP notation and gives CSP users a new modelling strategy which is well suited to the challenges of requirements engineering...|$|E
40|$|The Behavior <b>Tree</b> <b>notation</b> {{is used as}} part of a {{framework}} for developing complex computer systems. The framework is designed to simplify the process of constructing a formal specification of a system from its informal functional requirements. To give a meaning to Behavior Trees, this paper describes a lower-level language called Behavior Tree Process Algebra (BTPA) and its operational semantics, and defines a mechanical translation of Behaviour Trees into BTPA. The process algebra provides several methods by which processes may communicate with each other and interact with the environment: CSPlike synchronisation; send/receive message passing; and shared variables. The meaning of a BTPA process is defined with respect to {{the current state of the}} system (value of the components) and the active processes. ...|$|E
40|$|Parse <b>Tree</b> <b>Notation</b> (PTN) {{facilitates}} the encoding of language translators which transform programs written {{in high level}} languages with extensions (e. g. a logic language with object oriented features) into equivalent programs in the original unextended languages (e. g. Prolog). PTN does this by offering a small set of operations and built-in predicates for manipulating program parse trees. More complicated actions can be readily coded by combining PTN with Prolog predicates. The main PTN operation augments unification with pattern matching capabilities based on the Definite Clause Grammar (DCG) for {{the language of the}} program being manipulated. This allows parse tree searches to be specified, based on the terminal and nonterminal types of the language, without the programmer having to augment the DCG or to write specialised tree manipulation predicates...|$|E
5000|$|A tree-structured graph, {{where each}} node is {{a subset of}} variables, each pair of neighbors has {{non-empty}} intersection, and the intersection of two distinct nodes is contained in every node on the path connecting the two distinct nodes. Such a graph is also sometimes called a join <b>tree.</b> In mathematical <b>notations,</b> a Markov <b>tree</b> is a graph [...] that satisfies the following: (1) [...] is a hypergraph; (2) if , then and (3) if [...] and [...] are distinct vertices of , and , then [...] is in every vertex on the path from [...] to [...]|$|R
40|$|Most modern {{embedded}} systems are now required to satisfy seemingly divergent critical properties like safety and security. It is therefore becoming increasingly important that any systems development methodology employed should support modeling of system requirements {{in a manner}} that it facilitates validation and verification of such critical properties. In the paper we present the result of applying the genetic software engineering (GSE) method to design an ambulatory infusion pump (AIP) which must satisfy a number of safety and security properties. The safety and security requirements are integrated {{with the rest of the}} systems requirements in the form of integrated behavior tree (IBT), which is systematically refined into a design behavior tree (DBT). The integrated behavioral view of the requirements provides a platform for requirements conflict resolution, defect detection and requirements validation. The formal semantics of the behavior <b>tree</b> (BT) <b>notation,</b> used to specify the requirements, makes formal verification of critical properties in the final design possible. Full Tex...|$|R
40|$|This paper {{describes}} a specification language for pretty-printers that {{is able to}} cope well with both conventional computer languages and logical formalisms. The pretty-printer generator will form part of a system for formal reasoning about hardware description languages. The important feature is a notation for matching repetitive nested structures in the abstract syntax <b>trees.</b> This <b>notation</b> may be of use in other areas besides pretty-printing. 1. MOTIVATION A compiler for a computer language takes a source text in the language and generates compiled code in the object language (e. g., assembly code or C). The source text is written by the programmer and is formatted {{to allow it to}} be easily read and modified. The object code, on the other hand, is normally unformatted, since it will not be read by a human. Instead it is used as the input to an assembler or to another compiler. However, there are circumstances in which the internal representation of a language text (the abstract syn [...] ...|$|R
40|$|AbstractIn {{this paper}} we give a formal {{definition}} of the requirements translation language Behavior Trees. This language has been used with success in industry to systematically translate large, complex, and often erroneous requirements documents into a structured model of the system. It contains a mixture of state-based manipulations, synchronisation, message passing, and parallel, conditional, and iterative control structures. The formal semantics of a Behavior Tree is given via a translation to a version of Hoare’s process algebra CSP, extended with state-based constructs such as guards and updates, and a message passing facility {{similar to that used}} in publish/subscribe protocols. We first provide the extension of CSP and its operational semantics, which preserves the meaning of the original CSP operators, and then the Behavior <b>Tree</b> <b>notation</b> and its translation into the extended version of CSP...|$|E
40|$|AbstractTask {{trees are}} common notations used to {{describe}} the interaction between a user and an interactive application. They contain valuable information about the expected user behaviour as well on the expected software reactions and, thus, they can be used to support model-based testing. In this paper, a method for automatically generating test data from task trees is introduced. The task <b>tree</b> <b>notation</b> is extended to support operational profile specification. The user behaviour is automatically extracted from such extended trees as a probabilistic finite input–output state machine, thanks to formal semantics defined for this purpose for the task tree operators. The resulting probabilistic machine can then be used to generate test data simulating the user behaviour. This simulation can be performed using Lutess, a testing environment developed for synchronous software. The translation of the user interaction model into a Lutess description is explained and experimental results are reported...|$|E
40|$|Abstract. Event {{trees are}} a popular {{technique}} for modelling accidents in system safety analyses. Bayesian networks are a probabilistic modelling technique representing influences between uncertain variables. Although popular in expert systems, Bayesian networks {{are not used}} widely for safety. Using a train derailment case study, we show how an event tree {{can be viewed as}} a Bayesian network, making it clearer when one event affects a later one. Since this effect needs to be understood to construct an event tree correctly, we argue that the two notations should be used together. We then show how the Bayesian Network enables the factors that influence the outcome of events to be represented explicitly. In the case study, this allowed the train derailment model to be generalised and applied in more circumstances. Although the resulting model is no longer just an event tree, the familiar event <b>tree</b> <b>notation</b> remains useful. ...|$|E
40|$|In the {{previous}} lecture we discussed self-organizing list data structures, static optimality, and the move-to-front (MTF) and frequency-count (FC) algorithms for maintaining a list order which enables relatively fast searches. The lecture culminated with the claims: cost(MTF) ≤ 2 cost(static OPT) (with proof) cost(FC) ≤ 2 cost(static OPT) where cost measures {{the number of}} comparisons done by these algorithms. In the algorithms considered so far, we have only one mutable pointer, which may point to any list element. This (vaguely) models caches and the least-recently-used algorithm for cache upkeep; however, cache hardware is generally much more sophisticated. More importantly, we are discussing self-organizing lists {{as a prelude to}} our forthcoming treatment of self-organizing <b>tree</b> structures. <b>Notation</b> from previous lecture which is carried over to this lecture is as follows: • m: number of requests in a sequence • n: number of distinct elements (i. e., list length) In this lecture we define the notion of dynamic optimality and show the dynamic optimality of move-to-front in the Sleator & Tarjan cost model. We continue by introducing the Munro model...|$|R
40|$|The {{modeling}} of parallel activities requires a notation which can represent the temporal dependencies {{as well as}} variations of the execution order of the activities. This paper introduces ART (Activity Relation <b>Trees),</b> a <b>notation</b> to describe temporal dependencies between activities. ART is based on ConcurTaskTrees (CTT) that are extended with the means to describe temporal relationships. Furthermore, we present an algorithm that allows to automatically generate ART models from observed examples. Because former approaches for automatic model acquisition were restricted to strictly sequential data and cannot be applied {{in the case of}} parallel activities, we developed a method to reduce the problem of automatic {{modeling of}} parallel activities to the simpler task of modeling sequential data. By grouping activities and distinguishing different phases we are able to form general descriptions of a scenario that include variations in the execution order. The paper defines all necessary concepts and describes the algorithm in detail. The evaluation of the algorithm shows that precise models can be generated by using only few examples...|$|R
40|$|In {{this paper}} we {{introduce}} a syntax and semantics for capturing complex relational behaviour {{commonly found in}} natural language system requirements. The syntax {{is an extension of}} Behaviour <b>Trees,</b> a modelling <b>notation</b> used for capturing user requirements from natural language in a structured way. The underlying semantics of the extended notation is based on that of relational databases, thereby allowing the expressive power of database queries to be combined with the event- and state-based dynamic behaviour of Behavior Trees. To be a practical method for developing large-scale complex systems, the language is formal and hence supported by simulation and model checking tools. Full Tex...|$|R
40|$|AbstractBeing able to {{systematically}} change the original architecture of a component-based {{system to a}} desired target architecture without changing the set of functional requirements {{of the system is}} a useful capability. It opens up the possibility of making the architecture of any system conform to a particular form or shape of our choosing. The Behavior <b>Tree</b> <b>notation</b> makes it possible to realize this capability by inserting action-inert bridge component-state. For example, we can convert typical network component architectures into normalized tree-like architectures which have significant advantages. We can also use this “architecture change” capability to keep the architecture of a system stable when changes are made in the functional requirements. The results in this paper build on earlier work for formalizing the process of building a system out of its requirements and formalizing the impact of requirements change on the design of a system...|$|E
40|$|The International Standards Organization (ISO) {{has defined}} a {{protocol}} test language called TTCN (Tree and Tabular Combined Notation) to specify abstract test suites for Open Systems Interconnection (OSI) protocols. TTCN combines a <b>tree</b> <b>notation</b> for dynamic behaviour description with a tabular representation of various language constructs. TTCN allows tabular constraints to enforce values on the Abstract Service Primitive (ASP) or Protocol Data Unit (PDU) parameters. For application layer protocols, Abstract Syntax Notation One (ASN. 1) constraints are used. Dynamic behaviour description in TTCN {{is shown to}} address many important aspects of conformance testing such as modularity support in terms of test cases, steps and default behaviour tables and sophisticated timer management. TTCN has a machine processable form called TTCN-MP that defines all the TTCN syntax using BNF. Semantics of the tests specified in TTCN is operationally defined rendering TTCN almost a formal notation. © 1992...|$|E
40|$|Being able to {{systematically}} change the original architecture of a component-based {{system to a}} desired target architecture without changing the set of functional requirements {{of the system is}} a useful capability. It opens up the possibility of making the architecture of any system conform to a particular form or shape of our choosing. The Behavior <b>Tree</b> <b>notation</b> makes it possible to realize this capability by inserting action-inert bridge component-state. For example, we can convert typical network component architectures into normalized tree-like architectures which have significant advantages. We can also use this "architecture change" capability to keep the architecture of a system stable when changes are made in the functional requirements. The results in this paper build on earlier work for formalizing the process of building a system out of its requirements and formalizing the impact of requirements change on the design of a system. Griffith Sciences, School of Information and Communication TechnologyNo Full Tex...|$|E
40|$|Abstract—Subtree {{matching}} is {{an important}} problem in Computer Science on which a number of tasks, such as mechanical theorem proving, term-rewriting, symbolic computation and nonprocedural programming languages are based on. A systematic approach {{to the construction of}} subtree pattern matchers by deterministic pushdown automata, which read subject <b>trees</b> in prefix <b>notation,</b> is presented. The method is analogous to the construction of string pattern matchers: for a given pattern, a nondeterministic pushdown automaton is created and then it is determinised. In addition, it is shown that the size of the resulting deterministic pushdown automata directly corresponds {{to the size of the}} existing string pattern matchers based on finite automata. I...|$|R
40|$|Tree pattern {{matching}} {{is an important}} operation in Computer Science on which a number of tasks such as mechanical theorem proving, term-rewriting, symbolic computation and non-procedural programming languages are based on. Work has begun on a systematic approach {{to the construction of}} tree pattern matchers by deterministic pushdown automata which read subject <b>trees</b> in prefix <b>notation.</b> The method is analogous to the construction of string pattern matchers: for given patterns, a non-deterministic pushdown automaton is created and then it is determinised. In this first paper, we present the proposed non-deterministic pushdown automaton which will serve as a basis for the determinisation process, and prove its correctness. ...|$|R
40|$|This paper {{describes}} {{a draft of}} visual notation for meta-programming. The main suggestions of this work include specialized data structures (lists, tuples, trees), data item associations that provide for creation of arbitrary graphs, visualization of data structures and data flows, graphical notation for pattern matching (list, tuple, and <b>tree</b> patterns, graphical <b>notation</b> for context free grammars, streams), encapsulation means for hierarchical rules design, two-dimensional data-flow diagrams for rules, visual control constructs for conditionals and iteration, default mapping rules to reduce real-estate requirements for diagrams, and dynamic data attributes. Two-dimensional data flow diagrams improve readability of a meta-program. The abstract syntax type definitions for common programming languages and related default mappings (parsing and de-parsing) provide for a practically feasible reuse of those components. 1 Introduction an...|$|R
