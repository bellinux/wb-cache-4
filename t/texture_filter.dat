38|286|Public
5000|$|The {{anisotropic}} filtering method {{most commonly}} implemented on graphics hardware is {{the composition of}} the filtered pixel values from only one line of MIP map samples. In general the method of building a <b>texture</b> <b>filter</b> result from multiple probes filling a projected pixel sampling into texture space is referred to as [...] "footprint assembly", even where implementation details vary.|$|E
50|$|However, if {{the window}} manager is {{also able to}} supply an {{application}} with an updated image of what the screen looked like before the foreground window was drawn but after all other windows were already drawn more possibilities open up. This would allow the one window in the foreground to appear semi-transparent, by using the before image as a <b>texture</b> <b>filter</b> on the final output. This was possible in Windows XP with software included with many NVidia GeForce video cards {{as well as from}} third party sources, using a hardware texture overlay.|$|E
50|$|Under X, how {{video is}} finally drawn {{depends largely on}} the X window manager in use. With {{properly}} installed drivers, and GPU hardware such as supported Intel, ATI, and nVidia chip sets, some window managers, called compositing window managers, allow windows to be separately processed and then rendered (or composited). This involves all windows being rendered to separate output buffers in memory first, and later combined to form a complete graphical interface. While in (video) memory, individual windows can be transformed separately, and accelerated video may be added at this stage using a <b>texture</b> <b>filter,</b> before the window is composited and drawn. XVideo {{can also be used}} to accelerate video playback during the drawing of windows using an OpenGL Framebuffer Object or pbuffer.|$|E
5000|$|... 3 Each SM in the GF100 {{contains}} 4 <b>texture</b> <b>filtering</b> {{units for}} every texture address unit. The complete GF100 die contains 64 texture address units and 256 <b>texture</b> <b>filtering</b> units Each SM in the GF104/106/108 architecture contains 8 <b>texture</b> <b>filtering</b> units for every texture address unit. The complete GF104 die contains 64 texture address units and 512 <b>texture</b> <b>filtering</b> units, the complete GF106 die contains 32 texture address units and 256 <b>texture</b> <b>filtering</b> units and the complete GF108 die contains 16 texture address units and 128 <b>texture</b> <b>filtering</b> units.|$|R
5000|$|... 3 Each SM in the GF110 {{contains}} 4 <b>texture</b> <b>filtering</b> {{units for}} every texture address unit. The complete GF110 die contains 64 texture address units and 256 <b>texture</b> <b>filtering</b> units. Each SM in the GF114/116/118 architecture contains 8 <b>texture</b> <b>filtering</b> units for every texture address unit but has doubled both addressing and filtering units.|$|R
5000|$|... #Caption: An {{illustration}} of <b>texture</b> <b>filtering</b> methods showing a trilinear mipmapped texture {{on the left}} and the same texture enhanced with anisotropic <b>texture</b> <b>filtering</b> on the right.|$|R
50|$|One compute unit {{combines}} 64 shader processors with 4 TMUs. The compute unit {{is separate}} from, but feed into, the Render output units (ROPs). Each Compute Unit {{consists of a}} CU Scheduler, a Branch & Message Unit, 4 SIMD Vector Units (each 16-lane wide), 4 64KiB VGPR files, 1 scalar unit, a 4 KiB GPR file, a local data share of 64 KiB, 4 <b>Texture</b> <b>Filter</b> Units, 16 Texture Fetch Load/Store Units and a 16 KiB L1 Cache. Four Compute units are wired to share an Instruction Cache 16 KiB in size and a scalar data cache 32KiB in size. These are backed by the L2 cache. A SIMD-VU operates on 16 elements at a time (per cycle), while a SU can operate on one a time (one/cycle). In addition the SU handles some other operations like branching.|$|E
50|$|This port was of {{excellent}} quality and looked {{much better than}} PlayStation racing games of the same era. It ran in smooth 30 frames per second (25 frames in Europe due to the PAL system) and looked {{very much like the}} arcade original. Exceptions are non-transparent windows, since SEGA's Saturn could not generate transparencies in 3D graphics, as well as the draw distance, which was shorter than in the arcade game. Also, the screen resolution had to be cut in half, and the 3D models were scaled down. A PC port based on the Saturn version followed about one year later. It looked exactly like the Saturn version until SEGA released a patch for Microsofts DirectX 5 renderer. This patch modernised the graphics heavily. However, it made the PC version look far less related to the original arcade game, since it used a smoothing <b>texture</b> <b>filter</b> and brighter textures. The biggest difference between the original and its home versions is the option to drive three laps on each of the four implemented tracks instead of only one lap. Good players could also unlock an extra car: the Lancia Stratos. In the arcades there were only a Toyota Celica and a Lancia Delta to choose from.|$|E
5000|$|Depth based Shadow mapping can use an {{interesting}} Percentage Closer Filter (PCF) with depth mapped textures that broadens ones {{perception of the}} kinds of texture filters that might be applied. In PCF a depth map of the scene is rendered from the light source. During the subsequent rendering of the scene this depth map is then projected back into the scene from the position of the light and a comparison is performed between the projective depth coordinate and the fetched texture sample depth. The projective coordinate will be the scene pixels depth from the light but the fetched depth from the depth map will represent the depth of the scene along that projected direction. In this way a determination of visibility to the light and therefore illumination by the light can be made for the rendered pixel. So this texturing operation is a boolean test of whether the pixel is lit, however multiple samples can be tested for a given pixel and the boolean results summed and averaged. In this way in combination with varying parameters like sampled texel location and even jittered depth map projection location a post-depth-comparison average or percentage of samples closer and therefore illuminated can be computed for a pixel. Critically, the summation of boolean results and generation of a percentage value must be performed after the depth comparison of projective depth and sample fetch, so this depth comparison becomes {{an integral part of the}} <b>texture</b> <b>filter.</b> This percentage can then be used to weight an illumination calculation and provide not just a boolean illumination or shadow value but a soft shadow penumbra result. A version of this is supported in modern hardware where a comparison is performed and a post boolean comparison bilinear filter by distance is applied ...|$|E
25|$|Only {{bilinear}} <b>texture</b> <b>filtering</b> is supported; mipmapped <b>textures</b> and anisotropic <b>filtering</b> are not supported.|$|R
50|$|GeForce 8 {{performs}} {{significantly better}} <b>texture</b> <b>filtering</b> than its predecessors that used various optimizations and visual tricks {{to speed up}} rendering without impairing filtering quality. The GeForce 8 line correctly renders an angle-independent anisotropic filtering algorithm along with full trilinear <b>texture</b> <b>filtering.</b> G80, though not its smaller brethren, is equipped with much more <b>texture</b> <b>filtering</b> arithmetic ability than the GeForce 7 series. This allows high-quality filtering with a much smaller performance hit than previously.|$|R
5000|$|Single clock {{bilinear}} and trilinear <b>texture</b> <b>filtering</b> and <b>texture</b> compositing ...|$|R
40|$|Among various skin {{detection}} methods, Skin Probability Map (SPM) {{method is}} an effective one. Though SPM method possesses high true acceptance rate (TAR), its false acceptance rate (FAR) is unacceptable in some cases. The reason is that SPM method only use pixel-level color information. This paper proposes an improved skin detection method that integrates color, texture and space information. After color filter, a <b>texture</b> <b>filter</b> is constructed based on texture features extracted form Gabor wavelet transform. <b>Texture</b> <b>filter</b> will further filter non-skin pixels, meanwhile, it may also filter some skin pixel. To compensate the loss, after <b>texture</b> <b>filter,</b> a marker driven watershed transform is then used to grow already obtained skin regions. Experimental {{results show that the}} proposed method can achieve better performance than that of SPM. 1...|$|E
30|$|An {{approach}} {{that has been}} used in recent publications is the application of a Laplacian of Gaussian (LoG) bandpass filter to highlight and enhance different spatial scales between fine and coarse <b>texture</b> (<b>filter</b> value[*]=[*] 1.0 to 2.5) [1].|$|E
40|$|Graphical Processing Units (GPUs) {{have become}} an {{integral}} part of today’s mainstream computing systems. They are also being used as reprogrammable General Purpose GPUs (GP-GPUs) to perform complex scientific computations. Reconfigurability is an attractive approach to embedded systems allowing hardware level modification.   Hence, there is a high demand for GPU designs based on reconfigurable hardware. The <b>texture</b> <b>filter</b> unit is designed to process geometric data like vertices and convert these into pixels on the screen. This process involves number of operations, like circle and cube generation, rotator, and scaling. The <b>texture</b> <b>filter</b> unit is designed with all necessary hardware to deal with all the different filtering operations. The designed texture filtering units are modelled in Verilog on Altera Quartus II and simulated using ModelSim tools. The functionality of the modelled blocks is verified using test inputs in the simulator. Circle and cube coordinates are generated for circle and cube generation. The work can form the basis for designing a complete reconfigurable GPU...|$|E
50|$|Bilinear and trilinear <b>texture</b> <b>filtering,</b> MIP Mapping, alpha blending, {{and video}} <b>texture</b> mapping. Trilinear <b>filtering</b> is full-speed on ViRGE/DX and later, termed 'SmartFilter' technology.|$|R
40|$|Current GPUs offer {{specialized}} graphics hardware {{in addition}} to generic floating-point processing units. We propose a method which reuses specialized <b>texture</b> <b>filtering</b> units to perform piecewise polynomial evaluations, which helps accelerate LNS computations {{and can be used}} in combination with hardware-based transcendental functions. Index Terms — GPU, LNS, <b>texture</b> <b>filtering,</b> polynomial approximatio...|$|R
50|$|<b>Texture</b> <b>filtering</b> like Point, Linear, Bilinear, Trilinear, Anisotropic {{and custom}} algorithms.|$|R
40|$|A novel {{approach}} to image retrieval using color, texture and spatial information is proposed. The color information {{of an image}} {{is represented by the}} proposed color hologram, which takes into account both the occurrence of colors of pixels and the colors of their neighboring pixels. The proposed Fuzzy Color homogeneity, encoded by fuzzy sets, is incorporated in the color hologram computation. The texture information is described by the mean, variance and energy of wavelet decomposition coefficients in all sub bands. The spatial information is characterized by the class parameters obtained automatically from a unique unsupervised segmentation algorithm in combination with wavelet decomposition. Multi-stage filtering is applied to query processing to reduce the search range to speed up the query. Color homogram filter, wavelet <b>texture</b> <b>filter,</b> and spatial filter are used in sequence to eliminate images that are dissimilar to a query image in color, texture, and spatial information from the search ranges respectively. The proposed texture distance measure used in the wavelet <b>texture</b> <b>filter</b> considers the relationship between the coefficient value ranges and the decomposition levels, thus improving the retrieval performance...|$|E
40|$|An {{efficient}} multi-filter retrieval {{framework for}} image retrieval in large image databases is proposed. Multiple filters {{are used to}} reduce the search ranges at different stages and thus save the time spent on unnecessary similarity comparison. First, a color label histogram filter uses a color label histogram with only thirteen bins to eliminate those images in the image database that are dissimilar to a query image in colors. Next, a wavelet <b>texture</b> <b>filter</b> discards the images that are dissimilar to the query image in texture from the query results of the color filter. A texture distance measure that considers {{the relationship between the}} coefficient value ranges and the decomposition levels is proposed. Finally, a spatial segmentation filter removes images dissimilar to the query image in spatial information from the query results of the <b>texture</b> <b>filter.</b> A unique unsupervised segmentation algorithm together with the wavelet technique produces the spatial features of an image automatically. All images passing the three filters are ranked based on the total normalized distance in color, texture, and spatial information. The top N images are displayed in the user interface. The experimental results demonstrate that the proposed framework dramatically reduces the search range...|$|E
40|$|Medical image {{segmentation}} {{is a frequent}} processing step in image understanding and computer aided diagnosis. In this paper, we propose medical image texture segmentation using <b>texture</b> <b>filter.</b> Three different image enhancement technique s are utilized to remove strong speckle noise as well enhance the weak boundaries of medical images. We propose to exploit the concept of range filtering to extract the texture content of medical image. Experiment is conducted on ImageCLEF 2010 database. Results show the efficacy of our proposed medical image texture segmentation...|$|E
5000|$|... 16 <b>texture</b> <b>filtering</b> units (TF) and 16 texture {{addressing}} units (TA) ...|$|R
5000|$|... 3D {{graphical}} capabilities such as lighting, Gouraud shading, anti-aliasing and <b>texture</b> <b>filtering</b> ...|$|R
50|$|Textures {{need to be}} {{addressed}} and filtered. This job is done by TMUs that work in conjunction with pixel and vertex shader units. It is the TMU's job to apply texture operations to pixels. The number of texture units in a graphics processor is used when comparing two different cards for texturing performance. It is reasonable to assume that the card with more TMUs will be faster at processing texture information.In modern GPUs TMUs contain Texture Address Units(TA) and <b>Texture</b> <b>Filtering</b> Units(TF). <b>Texture</b> Address Units map texels to pixels and can perform texture addressing modes. <b>Texture</b> <b>Filtering</b> Units optionally perform hardware based <b>texture</b> <b>filtering.</b>|$|R
40|$|Abstract — Medical Image {{processing}} {{is one of}} {{the most}} challenging topics in research field. In medical field, CT (Computed Tomography) scan imaging and MRI (magnetic resonance imaging) are the most important for image based visual diagnostics, but applying segmentation to these images is very tedious and requires an adjusting approach. The main objective of medical image segmentation is to extract and characterize anatomical structures with respect to some input features or expert knowledge. In this paper we have formulated a simple, general, fast, and user-friendly approach to the problem of medical image segmentation based on <b>texture</b> <b>filter.</b> In this method, the experimental results show that the segmentation results are visually satisfactory of medical image texture segmentation...|$|E
40|$|Texture is an {{important}} visual attribute used to describe images. There are many methods available for texture analysis. However, most of these methods are object to variant rotation and changing scale of the images. Hence, this study presents a novel approach for texture analysis. The approach applies the Particle Swarm Optimization Algorithm in learning the texture filters for texture classifications. In this approach, the <b>texture</b> <b>filter</b> {{is regarded as the}} particle; the population of particle is iteratively evaluated according to a statistical performance index corresponding to object classification ability and evolves into the optimal filter using the evolution principles of Particle Swarm Optimization Algorithm. The method has been validated on aerial images and results indicate that proposed method is feasible for texture analysis...|$|E
40|$|Nowadays obesity {{has become}} one of the most common dis-eases in many countries. To face it, obese people should {{constantly}} monitor their daily meals both for self-limitation and to provide useful statistics for their dietitians. This has led to the recent rise in popularity of food diary applications on mobile devices, where the users can manually annotate their food intake. To overcome the tediousness of such a process, several works on automatic image food recognition have been proposed, typically based on texture features ex-traction and classification. In this work, we analyze different <b>texture</b> <b>filter</b> banks to evaluate their performances and pro-pose a method to automatically aggregate the best features for food classification purposes. Particular emphasis is put in the computational burden of the system to match the limited capabilities of mobile devices. 1...|$|E
50|$|This section {{lists the}} most common <b>texture</b> <b>filtering</b> methods, in {{increasing}} order of computational cost and image quality.|$|R
50|$|Trilinear {{filtering}} is {{an extension}} of the bilinear <b>texture</b> <b>filtering</b> method, which also performs linear interpolation between mipmaps.|$|R
50|$|There {{are many}} methods of <b>texture</b> <b>filtering,</b> which make {{different}} trade-offs between computational complexity, memory bandwidth and image quality.|$|R
40|$|Osteoarthritis (OA) is {{commonly}} seen among older {{people and it}} is arthritic type disease. It is a degenerative joint disease where cartilage slowly degenerates. Cartilage that shelters the bone ensures the smooth crusade of the joints. In knee OA, exaggerated bones come into contact due to degradation of cartilage, causing swell, discomfort and defeat of motion. Due to stress, knee joints can be frequently incapacitated and broken. The early detection of KOA could alert people {{to slow down the}} progression of the illness. Encouraged by this, the paper presents an automatic method to diagnose the Osteoarthritis disease. The cartilage of knee joint is segmented with pixel based segmentation method. For segmentation the <b>texture</b> <b>filter</b> method is applied. From segmented image cartilage area is calculated and depending on its estimated value image is classified into normal and OA affected...|$|E
40|$|The compass {{operator}} {{has proven}} to be a useful tool for the detection of color edges in real images. Its fundamental contribution is the comparison of oriented distributions of image features over a local area at each pixel. This paper presents extensions and modifications to the operator to make it applicable to texture edge detection in high dimensional images whose dimensions represent the output of a <b>texture</b> <b>filter</b> bank. The results show that the extended compass operator can robustly locate edges in natural scenes with complex textures. In addition, the use of a dynamic time warping distribution matching metric and jittered application of the operator improves the computational running time by a factor of over 50 while still producing comparable results. This large-scale speedup makes application of the algorithm to an entire image database computationally feasible. ...|$|E
40|$|Abstract:- Currently, {{kidney stone}} and tumor removal {{can be done}} without surgery. For this purpose, it is {{required}} imaging modalities that able to visualize kidney accurately. In order to improve the accuracy of kidney visualization in a short time, an automatic kidney centroid detection is required. This project developed a software to automatically detect the centroid of human kidney. The software was developed using MATLAB with smoothing filter, <b>texture</b> <b>filter</b> and morphological operators. They were used for image segmentation in order to extract important features. Test result shows the software achieve until 96. 43 % of accuracy in detecting the centroid. The detected centroid {{can be used as}} initial point to create ellipse model, which can be used to detect kidney’s contour in further research. This software can be implemented in the most US machine that will be used as segmentation tool to reduce human errors and time...|$|E
50|$|Bilinear <b>filtering</b> is a <b>texture</b> <b>filtering</b> {{method used}} to smooth textures when {{displayed}} larger or smaller {{than they actually}} are.|$|R
50|$|Other features: Support for Bilinear, trilinear, anisotropic, {{quincunx}} <b>texture</b> <b>filtering,</b> quincunx antialiasing, up to 4xMSAA, SSAA, Alpha to Coverage and Alphakill.|$|R
50|$|In {{computer}} graphics, <b>texture</b> <b>filtering</b> or <b>texture</b> smoothing is {{the method}} {{used to determine the}} texture color for a texture mapped pixel, using the colors of nearby texels (pixels of the texture). There are two main categories of <b>texture</b> <b>filtering,</b> magnification filtering and minification filtering. Depending on the situation <b>texture</b> <b>filtering</b> is either a type of reconstruction filter where sparse data is interpolated to fill gaps (magnification), or a type of anti-aliasing (AA), where texture samples exist at a higher frequency than required for the sample frequency needed for texture fill (minification). Put simply, filtering describes how a texture is applied at many different shapes, size, angles and scales. Depending on the chosen filter algorithm the result will show varying degrees of blurriness, detail, spatial aliasing, temporal aliasing and blocking. Depending on the circumstances filtering can be performed in software (such as a software rendering package) or in hardware for real time or GPU accelerated rendering or in a mixture of both. For most common interactive graphical applications modern <b>texture</b> <b>filtering</b> is performed by dedicated hardware which optimizes memory access through memory cacheing and pre-fetch and implements a selection of algorithms available to the user and developer.|$|R
