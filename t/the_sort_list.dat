1|10000|Public
5000|$|Test for Z overlap; {{implied in}} the {{selection}} of the face Q from <b>the</b> <b>sort</b> <b>list</b> ...|$|E
50|$|The value 2 is {{repopulated}} by {{the next}} value in <b>the</b> <b>sorted</b> <b>list,</b> 19. <b>The</b> comparisons end with 5 being the smallest value, and thus the next value to be popped off. This continues until all of <b>the</b> <b>sorted</b> <b>lists</b> are empty.|$|R
25|$|Sorting is {{typically}} done in-place, by iterating up the array, growing <b>the</b> <b>sorted</b> <b>list</b> behind it. At each array-position, it checks the value there against the largest value in <b>the</b> <b>sorted</b> <b>list</b> (which {{happens to be}} next to it, in the previous array-position checked). If larger, it leaves the element in place {{and moves to the}} next. If smaller, it finds the correct position within <b>the</b> <b>sorted</b> <b>list,</b> shifts all <b>the</b> larger values up to make a space, and inserts into that correct position.|$|R
50|$|If {{the items}} {{are stored in}} a linked list, then <b>the</b> <b>list</b> can be <b>sorted</b> with O(1) {{additional}} space. The algorithm starts with an initially empty (and therefore trivially <b>sorted)</b> <b>list.</b> <b>The</b> input items are taken off the list one at a time, and then inserted in the proper place in <b>the</b> <b>sorted</b> <b>list.</b> When <b>the</b> input <b>list</b> is empty, <b>the</b> <b>sorted</b> <b>list</b> has <b>the</b> desired result.|$|R
5000|$|A Gibbs sampler with ordered overrelaxation samples a given {{odd number}} of {{candidate}} values for [...] {{at any given}} step and sorts them, along with the single value for [...] according to some well-defined ordering. If [...] is the sth smallest in <b>the</b> <b>sorted</b> <b>list</b> then <b>the</b> [...] is selected as the sth largest in <b>the</b> <b>sorted</b> <b>list.</b> For more information, see Neal (1995).|$|R
5000|$|... struct LIST * SortList1(struct LIST * pList) { // zero or {{one element}} in list if(pList == NULL || pList->pNext == NULL) return pList; // head {{is the first}} element of {{resulting}} <b>sorted</b> <b>list</b> struct LIST * head = NULL; while(pList != NULL) { struct LIST * current = pList; pList = pList->pNext; if(head == NULL || current->iValue < head->iValue) { // insert into the head of <b>the</b> <b>sorted</b> <b>list</b> // or as the first element into an empty <b>sorted</b> <b>list</b> current->pNext = head; head = current; } else { // insert current element into proper position in non-empty <b>sorted</b> <b>list</b> struct LIST * p = head; while(p != NULL) { if(p->pNext == NULL || // last element of <b>the</b> <b>sorted</b> <b>list</b> current->iValue < p->pNext->iValue) // middle of the list { // insert into middle of <b>the</b> <b>sorted</b> <b>list</b> or as <b>the</b> last element current->pNext = p->pNext; p->pNext = current; break; // done } p = p->pNext; } } } return head;} ...|$|R
50|$|Repeatedly merge sublists {{to produce}} new sorted sublists {{until there is}} only 1 sublist remaining. This will be <b>the</b> <b>sorted</b> <b>list.</b>|$|R
5000|$|Rank(x) - {{find the}} rank of element x in the tree, i.e. its index in <b>the</b> <b>sorted</b> <b>list</b> of {{elements}} of the tree ...|$|R
5000|$|Repeatedly merge sublists {{to create}} a new <b>sorted</b> sublist until <b>the</b> single list {{contains}} all elements. The single <b>list</b> is <b>the</b> <b>sorted</b> <b>list.</b>|$|R
5000|$|The above assumes {{there are}} no duplicates in the , , and [...] sequences. So [...] is unique, and its rank is [...] in <b>the</b> <b>sorted</b> <b>list</b> [...] If there are duplicates, and [...] through [...] are a run of {{identical}} values in <b>the</b> <b>sorted</b> <b>list,</b> then one common approach is the midrank method: assign each duplicate a [...] "rank" [...] of [...] In the above equations, in the expressions [...] and , duplicates can modify all four variables , [...] , [...] , and [...]|$|R
50|$|It is {{possible}} that both a ≤ b and b ≤ a; in this case either may come first in <b>the</b> <b>sorted</b> <b>list.</b> In a stable <b>sort,</b> <b>the</b> input order determines <b>the</b> <b>sorted</b> order in this case.|$|R
25|$|The {{algorithm}} below uses a trailing pointer for {{the insertion}} into <b>the</b> <b>sorted</b> <b>list.</b> A simpler recursive method rebuilds the list each time (rather than splicing) and can use O(n) stack space.|$|R
50|$|Scanline {{rendering}} (also {{scan line}} rendering and scan-line rendering) is an algorithm for visible surface determination, in 3D computer graphics,that {{works on a}} row-by-row basis rather than a polygon-by-polygon or pixel-by-pixel basis. All of the polygons to be rendered are first <b>sorted</b> by <b>the</b> top y coordinate at which they first appear, then each row or scan line of the image is computed using the intersection of a scanline with the polygons {{on the front of}} <b>the</b> <b>sorted</b> <b>list,</b> while <b>the</b> <b>sorted</b> <b>list</b> is updated to discard no-longer-visible polygons as the active scan line is advanced down the picture.|$|R
40|$|Internal sorting is {{a problem}} of finding the {{permutation}} from a list of numbers so that the applied permutation <b>list</b> is <b>sorted.</b> Many sorting algorithms make use of various techniques to accomplish <b>the</b> <b>sorting</b> task. Moreover distinct characteristics of a finite list are extensively studied to find <b>the</b> practical <b>sorting</b> algorithm. This paper exhibits the unknown characteristic called the successive difference that can be computed during <b>the</b> <b>sorting</b> process. This number uncovers the extreme value of <b>the</b> <b>sorted</b> <b>list</b> in <b>the</b> permutation space. <b>The</b> <b>sorted</b> <b>list</b> attains <b>the</b> minimum value for both ascending and descending sorting. Moreover, it can be shown that the minimum successive difference can be computed using the maximum and minimum...|$|R
5000|$|We {{define a}} class [...] and {{a method for}} {{displaying}} the name and age of a person.Next we define a group of persons as a list of [...] objects.Then we iterate over <b>the</b> <b>sorted</b> <b>list.</b>|$|R
5000|$|Certificate {{failures}} {{can occur}} in the priority queues and <b>the</b> <b>sorted</b> <b>lists.</b> Swaps in <b>the</b> ordering of the points will cause changes to T (which will take O (...) time), and may cause insertions/deletions in the priority queues.|$|R
25|$|Insertion sort iterates, {{consuming}} one input element each repetition, {{and growing}} a <b>sorted</b> output <b>list.</b> At each iteration, insertion sort removes one element from the input data, finds the location it belongs within <b>the</b> <b>sorted</b> <b>list,</b> and inserts it there. It repeats until no input elements remain.|$|R
40|$|Consider the {{following}} scheme to solve <b>the</b> <b>sorting</b> problem: given n numbers to be <b>sorted,</b> after <b>the</b> ith of n (1 ≤ i ≤ n), {{we will make}} sure that we have i of input numbers in a <b>sorted</b> <b>list.</b> Clearly these i sorted numbers will partition the ranks of the remaining n − i unsorted numbers into i + 1 intervals. The (i + 1) th step consists of choosing one of the n − i unsorted numbers uniformly at random, and inserting it into <b>the</b> <b>sorted</b> <b>list.</b> After n such insertion steps, we are left with {{a list of all the}} input numbers, in sorted order. This algorithm can be viewed as a variant of quicksort algorithm [2]. To perform the insertion step, throughout the algorithm we maintain a pointer for each number yet to be inserted into <b>the</b> <b>sorted</b> <b>list.</b> After <b>the</b> ith step, the pointer for each uninserted number specifies which of the i + 1 intervals in <b>the</b> <b>sorted</b> <b>list</b> it would be inserted into, if it were the next to be inserted. The pointers are bidirectional, so that given an interval we can determine the numbers whose pointers point to it. Suppose we insert a number x whose pointers point to interval I, thus the work required to update the pointers is proportional to the number of pointers point to I. Consider the work done in the ith step when the objects in the input are considered in a random order. While we could directly analyze this random variable, we introduce a useful tool: backwards analysis. By using backwards analysis, we imagine that the algorithm is running backwards starting from <b>the</b> <b>sorted</b> <b>list</b> we have a...|$|R
3000|$|... (i), {{corresponds}} to i th user in <b>the</b> <b>sorted</b> <b>list.</b> This user selection {{has been studied}} in [27 – 29] {{is an extension of}} single-user selection from [30] to MU scenarios and is reminiscent of selection diversity based processing [31].|$|R
5000|$|To {{illustrate}} {{the idea of}} cycle <b>sort,</b> consider a <b>list</b> with distinct elements. Given an element , we can find the index at which it will occur in <b>the</b> <b>sorted</b> <b>list</b> by simply {{counting the number of}} elements in the entire list that are smaller than [...] Now ...|$|R
5000|$|...; <b>Sorts</b> <b>the</b> <b>list</b> {{using the}} > and < {{function}} as <b>the</b> relational operator. (<b>sort</b> (<b>list</b> 5 2 6 3 1 4) #'>) Returns (6 5 4 3 2 1) (<b>sort</b> (<b>list</b> 5 2 6 3 1 4) #'<) Returns (1 2 3 4 5 6); <b>Sorts</b> <b>the</b> <b>list</b> {{according to the}} first element of each sub-list. (<b>sort</b> (<b>list</b> '(9 A) '(3 B) '(4 C)) #'< :key #'first) Returns ((3 B) (4 C) (9 A)) ...|$|R
5000|$|Compactness: {{compactness}} {{follows from}} the compactness of <b>the</b> kinetic <b>sorted</b> <b>lists</b> and kinetic priority queues ...|$|R
5000|$|In the {{generalized}} data structure, the points are partitioned arbitrarily into m subsets of size , and kinetic <b>sorted</b> <b>lists</b> are maintained on <b>the</b> subsets. Each <b>sorted</b> sublist needs to process [...] events (certificate failures) maximum, {{since there are}} [...] swaps {{of each of the}} [...] pairs of elements. Thus the total time required to maintain the data structure is [...] Requests for <b>the</b> <b>sorted</b> <b>list</b> can then be answered in [...] by merging <b>the</b> <b>sorted</b> sublists with mergesort.|$|R
50|$|To {{be able to}} {{maintain}} <b>the</b> <b>sorted</b> <b>lists</b> for each node, linked lists are used. Cross-pointers are kept for each list to the others to be able to retrieve a point in constant time. In the algorithm above, in each iteration of the loop, a call to the recursion is done. In reality, to be able to reconstruct the list without the overhead of resorting the points, it is necessary to rebuild <b>the</b> <b>sorted</b> <b>lists</b> once all points have been assigned to their nodes. To do the rebuilding, walk along each list for each dimension, add each point to the corresponding list of its nodes, and add cross-pointers in the original list to be able to add the cross-pointers for the new lists. Finally, call the recursion on each node and his set.|$|R
5000|$|Efficient: every swap in <b>the</b> <b>sorted</b> <b>lists</b> {{causes a}} {{constant}} number of insertions and deletions in the kinetic priority queues. Assuming {{the motion of}} the points is pseudo-algebraic, there are a polynomial number of swaps, and hence a polynomial number of events are processed by this KDS, making it efficient ...|$|R
50|$|Sweep and prune {{exploits}} {{temporal coherence}} {{as it is}} likely that solids do not move significantly between two simulation steps. Because of that, at each step, <b>the</b> <b>sorted</b> <b>lists</b> of bounding volume starts and ends can be updated with relatively few computational operations. Sorting algorithms which are fast at <b>sorting</b> almost-sorted <b>lists,</b> such as insertion sort, are particularly good for this purpose.|$|R
3000|$|In {{the first}} phase, {{distributed}} bin generation, the Map-Reduce implementation of PFV scans the training set to generate at most V · L bin boundaries. Each Map task loads a chunk v of data and, for each continuous input variable X_f, sorts its values and computes L equi-frequency bin boundaries, including {{the left and}} and right extremes of the X_f domain in the chunk. Let BB_v,f = {b^(1)_v,f, [...]..., b^L_v,f} be <b>the</b> <b>sorted</b> <b>list</b> of bin boundaries. The output of the Map task is a key-value pair 〈 key = f, value = BB_v,f〉, where f is the index of the input variable X_f and BB_v,f is <b>the</b> <b>sorted</b> <b>list</b> of bin boundaries. Afterwards, each Reduce task is fed by V lists of bin boundaries for the same input variable X_f, and outputs a key-value pair 〈 key = f, value = BB_f〉, where BB_f is <b>the</b> <b>sorted</b> <b>list</b> of <b>the</b> bin boundaries for that variable X_f (obtained by joining all the bin boundaries of each BB_v,f). If the number of bins {{is equal to the}} number of values in the interval (one value per bin), it is equivalent to PFV. On the other side, the lower the value of L is, the coarser the approximation in determining the fuzzy partition is. We choose L equal to the percentage γ _disc of the chunk size.|$|R
30|$|The {{random numbers}} {{generated}} by the chaotic generators are sorted in ascending order, and the corresponding indexes are taken from <b>the</b> <b>sorted</b> <b>list.</b> Based on <b>the</b> indexes of the random numbers, the sampled values of speech signals are permuted. The permuted parameters are substituted with the random numbers generated by corresponding chaotic generator.|$|R
25|$|This {{technique}} involves {{solving a}} difficult problem by transforming {{it into a}} better known problem for which we have (hopefully) asymptotically optimal algorithms. The goal {{is to find a}} reducing algorithm whose complexity is not dominated by the resulting reduced algorithm's. For example, one selection algorithm for finding the median in an unsorted <b>list</b> involves first <b>sorting</b> <b>the</b> <b>list</b> (the expensive portion) and then pulling out the middle element in <b>the</b> <b>sorted</b> <b>list</b> (<b>the</b> cheap portion). This technique is also known as transform and conquer.|$|R
40|$|Abstract. <b>The</b> <b>sort</b> {{transform}} (ST) is {{a modification}} of the Burrows-Wheeler transform (BWT). Both transformations map an arbitrary word of length n to a pair consisting of a word of length n and an index between 1 and n. <b>The</b> BWT <b>sorts</b> all rotation conjugates of the input word, whereas the ST of order k only uses the first k letters for sorting all such conjugates. If two conjugates start with the same prefix of length k, then the indices of the rotations are used for tie-breaking. Both transforms output the sequence of the last letters of <b>the</b> <b>sorted</b> <b>list</b> and <b>the</b> index of the input within <b>the</b> <b>sorted</b> <b>list.</b> In this paper, we discuss a bijective variant of the BWT (due to Scott), proving its correctness and relations to other results due to Gessel and Reutenauer (1993) and Crochemore, Désarménien, and Perrin (2005). Further, we present a novel bijective variant of the ST. ...|$|R
40|$|<b>The</b> <b>sort</b> {{transform}} (ST) is {{a modification}} of the Burrows-Wheeler transform (BWT). Both transformations map an arbitrary word of length n to a pair consisting of a word of length n and an index between 1 and n. <b>The</b> BWT <b>sorts</b> all rotation conjugates of the input word, whereas the ST of order k only uses the first k letters for sorting all such conjugates. If two conjugates start with the same prefix of length k, then the indices of the rotations are used for tie-breaking. Both transforms output the sequence of the last letters of <b>the</b> <b>sorted</b> <b>list</b> and <b>the</b> index of the input within <b>the</b> <b>sorted</b> <b>list.</b> In this paper, we discuss a bijective variant of the BWT (due to Scott), proving its correctness and relations to other results due to Gessel and Reutenauer (1993) and Crochemore, Desarmenien, and Perrin (2005). Further, we present a novel bijective variant of the ST. Comment: 15 pages, presented at the Prague Stringology Conference 2009 (PSC 2009...|$|R
30|$|After all {{triggering}} of rule-sets within Drools has subsided {{the tree}} of data within Java is totalled by key-value, sorted and presented to the application. The application selects sufficient service providers from <b>the</b> <b>sorted</b> <b>list</b> to meet <b>the</b> target number of copies of data previously decided and returns a total cost to the user.|$|R
3000|$|... and denote <b>the</b> <b>sorted</b> {{neighbor}} <b>list</b> by N^'(s). Such a sorting procedure takes O(|N(s)|· |N(s)|) time.|$|R
5000|$|Tarjan's {{strongly}} connected components algorithm, an algorithm {{that gives}} <b>the</b> topologically <b>sorted</b> <b>list</b> of strongly connected components in a graph ...|$|R
5000|$|Roussopoulos and Leifker {{proposed}} {{a method for}} building a packed R-tree that achieves almost 100% space utilization. The idea is to <b>sort</b> <b>the</b> data on the x or y coordinate {{of one of the}} corners of <b>the</b> rectangles. <b>Sorting</b> on any of the four coordinates gives similar results. In this discussion points or rectangles are <b>sorted</b> on <b>the</b> x coordinate of the lower left corner of the rectangle, referred to as a [...] "lowx packed R-tree." [...] <b>The</b> <b>sorted</b> <b>list</b> of rectangles is scanned; successive rectangles are assigned to the same R-tree leaf node until that node is full; a new leaf node is then created, and the scanning of <b>the</b> <b>sorted</b> <b>list</b> continues. Thus, <b>the</b> nodes of the resulting R-tree will be fully packed, {{with the possible exception of}} the last node at each level. This leads to space utilization ≈100%. Higher levels of the tree are created in a similar way.|$|R
50|$|This data {{structure}} maintains {{a list of}} <b>the</b> elements in <b>sorted</b> order, with <b>the</b> certificates enforcing the order between adjacent elements. When a certificate fails, the concerned elements are swapped. Then at most three certificates must be updated, the certificate of the swapped pair, and the two certificates involving the swapped elements and the elements of <b>the</b> <b>sorted</b> <b>list</b> which directly precede and follow the swapped pair.|$|R
