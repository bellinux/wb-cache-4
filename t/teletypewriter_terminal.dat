1|5|Public
40|$|This {{study is}} {{concerned}} with the effectiveness of individual user performance for an extended sev-tutoring task in a time-shared computing facility. The investigation is an experimental case history of one individual (the author) following the TINT self-tutoring user manual from beginning to end in the SDC Q- 32 Time-sharing System at a Teletype console. (TINTis a user-oriented dialect of JO VIAL, an interpretive language adapted to time-sharing with many self-teaching features.) The methodology featured measurement of natural user behavior in which the user sewed as his own control in succes-sive console sessions. The sample included 1. 861 user input commands collected over I 8 hours at the <b>teletypewriter</b> <b>terminal.</b> The quantitative results revealed some evidence for systematic learning and reinforcement effects; there were progressive tendencies toward higher productivity and lower error rates with increasing TINT experience. The qualitative findings revealed that the numerous and diversified exercises facili-tated familiarity with the elementsand the varied services of the TINT system. The chief drawback was exclusive reliance of the tutoring method on literal reproduction of the text by the user at his console. The paper concludes with recommendations for more genuine interactive involvement between the user, the central system. and self-tutoring aids...|$|E
5000|$|The {{programmatic}} interface for querying and modifying all {{of these}} modes and control characters was the [...] system call. (This replaced the [...] and [...] system calls of Sixth Edition Unix.) Although the [...] "erase" [...] and [...] "kill" [...] characters were modifiable from their defaults of [...] and , for many years they were the pre-set defaults in the terminal device drivers, and on many Unix systems, which only altered terminal device settings {{as part of the}} login process, in system login scripts that ran after the user had entered username and password, any mistakes at the login and password prompts had to be corrected using the historical editing key characters inherited from <b>teletypewriter</b> <b>terminals.</b>|$|R
5000|$|The {{programmatic}} interface for querying and modifying all {{of these}} modes and control characters was the [...] system call. (This replaced the [...] and [...] system calls of Sixth Edition Unix.) Although the [...] "erase" [...] and [...] "kill" [...] characters were modifiable from their defaults of [...] and , for many years after Seventh Edition development inertia meant {{that they were the}} pre-set defaults in the terminal device drivers, and on many Unix systems, which only altered terminal device settings as part of the login process, in system login scripts that ran after the user had entered username and password, any mistakes at the login and password prompts had to be corrected using the historical editing key characters inherited from <b>teletypewriter</b> <b>terminals.</b>|$|R
50|$|QTAM was {{announced}} by IBM in 1965 {{as part of}} OS/360 and DOS/360 aimed at inquiry and data collection. As announced it also supported remote job entry (RJE) applications, called job processing, which was dropped by 1968. Originally QTAM supported the IBM 1030 Data Collection System, IBM 1050 Data Communications System, the IBM 1060 Data Communications System, AT&T 83B2 Selective Calling Stations, Western Union Plan 115A Outstations, and AT&T Teletype Model 33 or 35 <b>Teletypewriters.</b> By 1968 <b>terminal</b> support had expanded to include the IBM 2260 display complex, and the IBM 2740 communications terminal.|$|R
5000|$|The {{terminal}} interface provided by Seventh Edition Unix and UNIX/32V, and also presented by BSD version 4 {{as the old}} terminal driver, was a simple one, largely geared towards <b>teletypewriters</b> as <b>terminals.</b> Input was entered a line at a time, with the terminal driver in the operating system (and not the terminals themselves) providing simple line editing capabilities. A buffer was maintained by the kernel in which editing took place. Applications reading terminal input would receive {{the contents of the}} buffer only when the [...] key was pressed on the terminal to end line editing. The [...] key sent from the terminal to the system would erase ("kill") the entire current contents of the editing buffer, and would be normally displayed as an '@' symbol followed by a newline sequence to move the print position to a fresh blank line. The [...] key sent from the terminal to the system would erase the last character {{from the end of the}} editing buffer, and would be normally displayed as an '#' symbol, which users would have to recognize as denoting a [...] "rubout" [...] of the preceding character (teletypewriters not being physically capable of erasing characters once they have been printed on the paper).|$|R

