258|9494|Public
25|$|On Greek IRC {{channels}} and IM applications, {{most of the}} time only Greeklish is used because it is simpler to type and <b>typing</b> <b>errors</b> are more easily excused. However, Greeklish has been criticised because the user's text bypasses spellcheck, resulting in lowering their ability to write native Greek correctly.|$|E
25|$|Despite many rules inconsistencies, {{inadequate}} roleplaying rules, <b>typing</b> <b>errors</b> {{and poor}} presentation, the battle system {{was thought to}} be excellent and exceptionally simple and playable in comparison to other miniatures games of the time. The psychology rules - for determining how classic fantasy racial types behave towards each other - and the fumbling of magic were well regarded and thought to enhance the fantasy feel of the game and provide entertainment.|$|E
25|$|Real-time {{translation}} subtitling, {{usually involves}} an interpreter and a stenographer working concurrently, whereby the former quickly translates to the dialog {{while the latter}} types; this form of subtitling is rare. The unavoidable delay, <b>typing</b> <b>errors,</b> lack of editing, and high cost mean that real-time translation subtitling is in low demand. Allowing the interpreter to directly speak to the viewers is usually both cheaper and quicker; however, the translation is not accessible {{to people who are}} deaf and hard–of–hearing.|$|E
40|$|AbstractPrevious {{methods have}} {{generally}} identified {{the location of}} a <b>type</b> <b>error</b> as a particular program point or the program subtree rooted at that point. We present a new approach that identifies {{the location of a}} <b>type</b> <b>error</b> as a set of program points (a slice) all of which are necessary for the <b>type</b> <b>error.</b> We identify the criteria of completeness and minimality for <b>type</b> <b>error</b> slices. We discuss the advantages of complete and minimal <b>type</b> <b>error</b> slices over previous methods of presenting <b>type</b> <b>errors.</b> We present and prove the correctness of algorithms for finding complete and minimal <b>type</b> <b>error</b> slices for implicitly typed higher-order languages like Standard ML...|$|R
40|$|SML (a higher-order function-oriented {{imperative}} programming language) {{depends on}} automated inference of sophisticated type information. Existing implementations have confusing <b>type</b> <b>error</b> messages. <b>Type</b> <b>error</b> slicing gives the programmer more helpful <b>type</b> <b>error</b> information: (1) It identifies all program points {{that contribute to}} a <b>type</b> <b>error</b> rather than blaming just one point. (2) It exhibits {{a slice of the}} original program’s syntax instead of showing an internal representation of some program subtree which may have been substantially transformed. (3) It avoids showing internal details of inferred types which were not written by the programmer. A <b>type</b> <b>error</b> slice contains all information needed to understand the error, and avoids irrelevant information. Similar to other previous work for better handling of <b>type</b> <b>errors,</b> <b>type</b> <b>error</b> slicing was initially developed for a very tiny to...|$|R
40|$|Previous {{methods have}} {{generally}} identified {{the location of}} a <b>type</b> <b>error</b> as a particular program point or the program subtree rooted at that point. We present a new approach that identifies {{the location of a}} <b>type</b> <b>error</b> as a set of program points (a slice) all of which are necessary for the <b>type</b> <b>error.</b> We describe algorithms for finding minimal <b>type</b> <b>error</b> slices for implicitly typed higher-order languages like Standard ML...|$|R
25|$|With {{the release}} of Word 6.0 in 1993, Microsoft again {{attempted}} to synchronize the version numbers and coordinate product naming across platforms, this time across DOS, Mac OS, and Windows (this was the last version of Word for DOS). It introduced AutoCorrect, which automatically fixed certain <b>typing</b> <b>errors,</b> and AutoFormat, which could reformat many parts of a document at once. While the Windows version received favorable reviews (e.g., from InfoWorld), the Mac OS version was widely derided. Many accused it of being slow, clumsy and memory intensive, and its user interface differed significantly from Word 5.1. In response to user requests, Microsoft offered Word 5 again, after it had been discontinued. Subsequent versions of Word for macOS are no longer direct ports of Word for Windows, instead featuring a mixture of ported code and native code.|$|E
2500|$|Check digits (or characters) are a 'checksum' on {{a number}} to help prevent manual <b>typing</b> <b>errors.</b> in PHP ...|$|E
2500|$|Many words {{originally}} {{derived from}} leet slang {{have now become}} part of the modern Internet slang, such as [...] "pwned". The original driving forces of new vocabulary in leet were common misspellings and <b>typing</b> <b>errors</b> such as [...] "teh" [...] (generally considered lolspeak), and intentional misspellings, especially the [...] "z" [...] at the end of words ("skillz"). Another prominent example of a surviving leet expression is w00t, an exclamation of joy. w00t is sometimes used as a backronym for [...] "We owned the other team." ...|$|E
40|$|The <b>type</b> <b>error</b> {{message of}} a {{standard}} type checker for a functional language gives only a single location as potential cause of the <b>type</b> <b>error.</b> If that location is not the cause, which often is the case, then the <b>type</b> <b>error</b> message hardly helps in locating the real cause. Here we present a method that uses a standard type checker to enumerate locations that potentially cause the <b>type</b> <b>error,</b> each with an actual and a counter-factual type for the given location. Adding our method to existing compilers requires only limited effort but improves <b>type</b> <b>error</b> debugging substantially...|$|R
40|$|Abstract. Previous {{methods have}} {{generally}} identified {{the location of}} a <b>type</b> <b>error</b> as a particular program point or the program subtree rooted at that point. We present a new approach that identifies {{the location of a}} <b>type</b> <b>error</b> as a set of program points (a slice) all of which are necessary for the <b>type</b> <b>error.</b> We describe algorithms for finding minimal <b>type</b> <b>error</b> slices for implicitly typed higher-order languages like Standard ML...|$|R
40|$|AbstractCompilers for {{languages}} {{with type}} inference algorithms produce confusing <b>type</b> <b>error</b> messages {{and give a}} single error location which is often {{far away from the}} real location of the <b>type</b> <b>error.</b> Attempts at solving this problem 1) fail to include the multiple program points which make up the <b>type</b> <b>error,</b> 2) often report tree fragments which do not correspond to any place in the user program, and 3) give incorrect type information/diagnosis which can be highly confusing. We present Skalpel, a <b>type</b> <b>error</b> slicing tool which solves these problems by giving the programmer all and only the information involved with a <b>type</b> <b>error</b> to significantly aid in diagnosis and repair of <b>type</b> <b>errors.</b> Skalpel consists of a sophisticated new constraint generator which is linear in size and a new constraint solver which is terminating...|$|R
2500|$|Before the {{computer}} mass storage era, most RTTY stations stored text on paper tape using paper tape punchers and readers. The operator would type the {{message on the}} TTY keyboard and punch the code onto the tape. The tape could then be transmitted at a steady, high rate, without <b>typing</b> <b>errors.</b> A tape could be reused, {{and in some cases}} - especially for use with ASCII on NC Machines - [...] might be made of plastic or even very thin metal material in order to be reused many times.|$|E
2500|$|Along {{with his}} {{undergraduate}} student Jonathan (Jon) Collins, Raskin developed the Flow Programming Language {{for use in}} teaching programming to the art and humanities students. [...] The language was first used at the Humanities Summer Training Institute held in 1970 at the University of Kansas in Lawrence, Kansas. The language has only 6 instructions (get it, print it, print [...] "text", jump to, if it is ' ' then, and stop) and can not manipulate numbers. The language utilizes [...] "typing amplification" [...] in which only the first letter is typed and the computer provides {{the balance of the}} instruction eliminating <b>typing</b> <b>errors.</b> It was also the basis for programming classes taught by Raskin and Collins in the UCSD Visual Arts Department.|$|E
2500|$|Leet {{has its own}} colloquialisms, many {{of which}} {{originated}} as jokes based on common <b>typing</b> <b>errors,</b> habits of new computer users, or knowledge of cyberculture and history. Leet is not solely based upon one language or character set. Greek, Russian, and other languages have leet forms, and leet in one language may use characters from another where they are available. As such, {{while it may be}} referred to as a [...] "cipher", a [...] "dialect", or a [...] "language", leet does not fit squarely into any of these categories. The term leet itself is often written 31337, or 1337, and many other variations. After the meaning of these became widely familiar, 10100111001 came to be used in its place, because it is the binary form of 1337 decimal, making it more of a puzzle to interpret. An increasingly common characteristic of leet is the changing of grammatical usage so as to be deliberately incorrect. The widespread popularity of deliberate misspelling is similar to the cult following of the [...] "All your base are belong to us" [...] phrase. Indeed, the online and computer communities have been international from their inception, so spellings and phrases typical of non-native speakers are quite common.|$|E
40|$|<b>Type</b> <b>error</b> reports provide programmers with a {{description}} of <b>type</b> <b>errors</b> which exist in their code. Such descriptions are frequently of poor quality, as they often present just one point in the program, rather than all locations in the code which contribute to that <b>type</b> <b>error.</b> Skalpel is a <b>type</b> <b>error</b> report system for the Standard ML language which tackles this problem, by presenting all and only the locations in the program which contribute to the <b>type</b> <b>error.</b> While the original Skalpel gives substantially better error reports than comparable systems, it has a number of limitations such as a lack of support for language features and poor efficiency. In this research we have made a number of contributions, including a full critique of both the Skalpel core theoretical system and its extensions, support for the remaining features of Standard ML, an analysis and improvements to the efficiency, and an investigation {{for the first time on}} Skalpel’s theoretical properties...|$|R
30|$|Considering an α <b>type</b> <b>error</b> of 0.05, a β <b>type</b> <b>error</b> of 0.10 and a {{difference}} of SR changes between arms of 10 % of the primary endpoint (SR change) as clinically meaningful, 50 patients should have been enrolled in each arm.|$|R
30|$|According to the {{empirical}} results (Tables  6, 7, 8), the prediction {{accuracy of the}} LASSO–NN model is 88.96  % (<b>Type</b> I <b>error</b> rate is 12.22  %; <b>Type</b> II <b>error</b> rate is 7.50  %), the prediction accuracy of the LASSO–CART model is 88.75  % (<b>Type</b> I <b>error</b> rate is 13.61  %; <b>Type</b> II <b>error</b> rate is 14.17  %), and the prediction accuracy of the LASSO–SVM model is 89.79  % (<b>Type</b> I <b>error</b> rate is 10.00  %; <b>Type</b> II <b>error</b> rate is 15.83  %). Our comparison follows that of Kirkos et al. (2007 a, b), Tasi and Huang (2010) and Chen et al. (2014). We not only focus on the hit ratio of the models, but also consider the <b>Type</b> I <b>error</b> and <b>Type</b> II <b>error</b> rates.|$|R
60|$|Walter was not {{in sight}} when she entered the offices, and she was {{instantly}} swept into the routine. Not clasping hands beguiled her, but lists to copy, <b>typing</b> <b>errors</b> to erase, and the irritating adjustment of a shift-key which fiendishly kept falling. For two hours {{she did not see}} him.|$|E
5000|$|InstaFinder (hijacker): Redirects your URL <b>typing</b> <b>errors</b> to InstaFinder's {{web page}} {{instead of the}} {{standard}} search page.|$|E
5000|$|The album {{includes}} lyrics {{printed in}} the sleeve notes, however {{they appear to have}} quite severe <b>typing</b> <b>errors.</b>|$|E
40|$|Polymorphic type {{checking}} algorithm efficiently locate <b>type</b> <b>errors</b> in programs, but users find error {{reporting from}} such algorithms hard to comprehend. We {{are investigating the}} development of a new polymorphic type checker that reports <b>type</b> <b>errors</b> in a more understandable form. Here we present the results of an experiment into human checking of incorrectly-typed polymorphic programs. We hope to identify the sequences of techniques people use to explain different categories of error. An outline of a <b>type</b> <b>error</b> explanation system incorporating our heuristics is given...|$|R
40|$|We have {{constructed}} {{an explanation}} system for polymorphic types, motivated by analysis of human type explanations. Qualitative and quantitative comparison of human expert and our computer generated explanations of polymorphic <b>type</b> <b>errors</b> {{suggests that they}} are very similar. Keywords Polymorphic types; <b>type</b> <b>error</b> explanation; mechanical explanation. 1...|$|R
30|$|<b>Type</b> I <b>errors</b> may {{not have}} serious {{consequences}} when compared to <b>Type</b> II <b>errors.</b> If the auditor wrongly classifies a GC firm as healthy, then he/she can be sued. If an auditor issues a wrong audit report due to his/her misjudgment, then this will affect not only the enterprise and stakeholders, but also many investors. Moreover, the CPA may be sued. The costs for <b>Type</b> II <b>errors</b> are thus rather severe. We have developed three GCD prediction models. In the LASSO–NN model, the <b>Type</b> I <b>error</b> rate is 12.22  % and the <b>Type</b> II <b>error</b> rate is 7.50  %; in the LASSO–CART model, the <b>Type</b> I <b>error</b> rate is 13.61  % and the <b>Type</b> II <b>error</b> rate is 14.17  %; and in the LASSO–SVM model, the <b>Type</b> I <b>error</b> rate is 10.00  % and the <b>Type</b> II <b>error</b> rate is 15.83  %. These error rates are all lower than 20  %, especially in the LASSO–NN model where the <b>Type</b> II <b>error</b> rate is only 7.50  %. This is a key contribution of this paper.|$|R
5000|$|It is long (which is a {{considerable}} virtue in theory) and requires a good typist as <b>typing</b> <b>errors</b> {{are much more likely}} for extended phrases.|$|E
50|$|The {{cancelled}} leaf may {{be rejected}} {{on account of}} spelling or <b>typing</b> <b>errors,</b> a wording change or addition, or need to suppress libellous or otherwise offensive text.|$|E
5000|$|J. Li, K. Ouazzane, H. Kazemian, Y. Jing, R. Boyd (2011) ‘ A neural Network Based Solution for Automatic <b>Typing</b> <b>Errors</b> Correction’, Journal of Neural Computing Applications; DOI: 10.1007/s00521-010-0492-3 ...|$|E
40|$|Typically a <b>type</b> <b>error</b> is {{reported}} when unication fails, {{even though the}} programmer 's actual error may have occurred much earlier in the program. The W and M inference algorithms report the site where a type conict is detected. The error message is isolated information: {{it is not clear}} from the error information the relationship between the site and {{the context in which the}} subexpression was typed. As a result, the error message may give little help to locate the source of the error. This report investigates better methods of explaining type conicts. We are trying to nd a method that may be eective even when the user has little knowledge about type checking. We have implemented an improved <b>type</b> <b>error</b> explanation system and have proposed and implemented a hybrid algorithm. 1 Introduction It is known that the place where a <b>type</b> <b>error</b> was detected may not be the place where the <b>type</b> <b>error</b> actually originated. The source of a <b>type</b> <b>error</b> may be far from where it is detected. This is b [...] ...|$|R
40|$|Producing {{precise and}} helpful <b>error</b> {{messages}} for <b>type</b> inference {{is still a}} challenge for implementations of functional languages. Current approaches often lack precision in terms of locating the origins of <b>type</b> <b>errors.</b> Moreover, suggestions for how to fix <b>type</b> <b>errors</b> that are offered by some tools are also often vague or incorrect. To address this problem we have developed {{a new approach to}} identifying <b>type</b> <b>errors</b> that is based on delaying typing decisions and systematically gathering context information to support the delayed decision making. Our technique, which we call lazy typing, is based on explicitly representing conflicting <b>types</b> and <b>type</b> <b>errors</b> in choice <b>types</b> that will be accumulated during the typing process. The structure of these types is then analyzed to produce error messages and, in many cases, also type-change suggestions. We will demonstrate that lazy typing is often more precise in locating <b>type</b> <b>errors</b> than existing tools and that it can also produce good type-change suggestions. We do not consider lazy typing as a replacement for other techniques, but rather as an addition that could help improve other approaches...|$|R
40|$|One of the {{features}} of functional languages, such as Haskell and SML, is that the data types of the variables and functions can be inferred from their usage. Unfortunately when an error occurs from this type inference, it may be difficult for a novice programmer to trace the error's source. We introduce two categories of <b>type</b> <b>errors.</b> Explicit <b>type</b> <b>errors</b> are caused by the user attempting to use incompatible types together. Attributed <b>type</b> <b>errors</b> are the result of editing or syntactical mistakes that are not detected until type checking occurs. The programmer requires differing forms of error messages to debug each category of <b>type</b> <b>error</b> more effectively. We present these display systems and determine that to implement them, the type of each sub-expression in the code must be inferred. This can be implemented using an algorithm given by Beaven and Stansifer...|$|R
50|$|As {{mentioned}} in the passage regarding the Loebnizer prize competition, the computer was able to trick judges by introducing deliberate <b>typing</b> <b>errors.</b> The Economist argues that nobody would want a computer that couldn't type properly.|$|E
50|$|QOF version 10 was {{introduced}} in July/August 2007, with mainly {{minor changes to the}} system, removing, adding or changing codes in the clinical areas to bring them in line with current guidance or to fix <b>typing</b> <b>errors.</b>|$|E
50|$|On Greek IRC {{channels}} and IM applications, {{most of the}} time only Greeklish is used because it is simpler to type and <b>typing</b> <b>errors</b> are more easily excused. However, Greeklish has been criticised because the user's text bypasses spellcheck, resulting in lowering their ability to write native Greek correctly.|$|E
40|$|This paper {{presents}} {{a method that}} has enabled us to make a selection of <b>error</b> <b>types</b> and <b>error</b> production mechanisms relevant to the HUMAN European project, and discusses the reasons underlying those choices. We claim that this method has the advantage {{that it is very}} exhaustive in determining the relevant <b>error</b> <b>types</b> and <b>error</b> production mechanisms, and that the final objects are selected according to explicit requirements, without missing relevant <b>error</b> <b>types</b> and <b>error</b> production mechanisms...|$|R
40|$|Existing compilers {{for many}} {{languages}} have confusing <b>type</b> <b>error</b> messages. <b>Type</b> <b>error</b> slicing (TES) helps the programmer by isolating {{the part of}} a program contributing to a <b>type</b> <b>error,</b> but unfortunately TES was initially done for a tiny toy language. Extending TES to a full programming language is extremely challenging, and for SML we needed a number of innovations and generalisations. Some issues would be faced for any language, and some are SMLspecific but representative of the complexity of language-specific issues likely to be faced for other languages. We solve both kinds of issues and present a simple, general constraint system for providing <b>type</b> <b>error</b> slices for ill-typed programs. Our constraint system elegantly and efficiently handles features like the intricate open SML feature. We show how the simple clarity of <b>type</b> <b>error</b> slices can demystify language features known to confuse users. We also provide in an appendix a case study on how to use our TES to help modifying user data types, and extend the core language presented in the main body of this report to handle more of the implementation of our system. These extensions allow handling local declarations, type declarations and some uses of signatures. 1...|$|R
5000|$|KINK_KRB_ERROR: a payload that relays Kerberos <b>type</b> <b>errors</b> {{back to the}} {{initiator}} ...|$|R
