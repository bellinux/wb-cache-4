0|10000|Public
40|$|Agent-oriented {{models are}} {{frequently}} used in disciplines such as agent-oriented requirements engineering, requirements engineering and organizational process modelling. i* is currently {{one of the}} most widespread notations used for this purpose. Due to both its dissemination and its highly strategic nature, instead of a single definition, several groups have formulated different variants, which define in a slightly different way the basic concepts of the language, as well as propose particular constructs that fit into the particular interests of these groups. In this chapter we first review these proposals and then we present a reference model that establishes the concepts and relationships that are fundamental in i*. The reference model is expressed as a UML <b>class</b> <b>diagram</b> (with OCL constraints) together with a vocabulary of the presented terms. Most of the included concepts are common to the seminal i* proposal, the GRL and the diverse variations used {{in the context of the}} Tropos methodology. For those concepts that are not shared by these analysed variants, the reference model tries to reconcile the different views whenever possible. The reference model allows determining the differences of any existing i* variant with respect to the model, and also to know how much different a new variant would be from the core of i*. The variants can be expressed by applying some refactoring operations on <b>the</b> UML <b>class</b> <b>diagram.</b> We <b>illustrate</b> this situation by applying refactoring to some of the analysed proposals. Postprint (published version...|$|R
40|$|The UML {{has grown}} in {{popularity}} as the standard modeling language for describing software applications. However, UML lacks the formalism of a rigid semantics, {{which can lead to}} ambiguities in understanding the specifications. We propose a grammar-based approach to validating <b>class</b> <b>diagrams</b> and <b>illustrate</b> this technique using a simple case-study. Our technique involves converting UML representations into an equivalent grammar form, and then using existing language transformation and development tools to assist in the validation process. A string comparison metric is also used which provides feedback, allowing the user to modify <b>the</b> original <b>class</b> <b>diagram</b> according to <b>the</b> functionality desired...|$|R
5000|$|<b>The</b> <b>class</b> <b>diagram</b> defines <b>the</b> <b>classes</b> and <b>class</b> {{associations}} for <b>the</b> domain.|$|R
40|$|AbstractAutomatic {{debugging}} of UML <b>class</b> <b>diagrams</b> {{helps in}} <b>the</b> visual specification of software systems because users cannot detect errors in logical consistency easily. This study {{focuses on the}} tractable consistency checking of UML <b>class</b> <b>diagrams.</b> We accurately identify inconsistencies in these diagrams by translating them into first-order predicate logic that is generalized by counting quantifiers and classify their expressivities by eliminating certain components. We introduce optimized algorithms that compute the respective consistencies of <b>class</b> <b>diagrams</b> of different expressive powers in P, NP, PSPACE, or EXPTIME {{with respect to the}} size of <b>the</b> <b>class</b> <b>diagrams.</b> In particular, owing to the restrictions imposed on attribute value types, the complexities of consistency checking of <b>class</b> <b>diagrams</b> decrease from EXPTIME to P and PSPACE in two cases: (i) when <b>the</b> <b>class</b> <b>diagrams</b> contain disjointness constraints and overwriting/multiple inheritances and (ii) when <b>the</b> <b>class</b> <b>diagrams</b> contain both these components along with completeness constraints. Additionally, we confirm the existence of a restriction of <b>class</b> <b>diagrams</b> that prevents any logical inconsistency...|$|R
40|$|UML is an {{industrial}} standard for object-oriented software specification {{which offers a}} notation for class modeling during object oriented software development. Since <b>the</b> UML <b>class</b> <b>diagram</b> is a so-called “bridge” between software specification at the user side and software realization at the developer side, it requires strong guidelines for identification of <b>class</b> objects from <b>the</b> problem domain and notational conventions for modeling of <b>the</b> <b>class</b> <b>diagram</b> for its further usage in system coding. This paper presents a discussion on problematic stages and possible element transformations into software components. Several conclusions are drawn on potential usage of <b>the</b> <b>class</b> <b>diagram</b> in industr...|$|R
50|$|Constraints on <b>the</b> <b>class</b> <b>diagram</b> can {{be written}} in both Action Language and Object Constraint Language (OCL).|$|R
50|$|An Executable UML <b>class</b> <b>diagram</b> {{is meant}} to expose {{information}} about the domain. Too much complexity in the statechart diagrams is a good indicator that <b>the</b> <b>class</b> <b>diagram</b> should be reworked.|$|R
5000|$|<b>The</b> <b>class</b> <b>diagram</b> is <b>the</b> main {{building}} block of object-oriented modelling. It is used both for general conceptual modelling of the systematics of the application, and for detailed modelling translating the models into programming code. <b>Class</b> <b>diagrams</b> {{can also be}} used for data modeling. <b>The</b> <b>classes</b> in a <b>class</b> <b>diagram</b> represent both <b>the</b> main elements, interactions in the application, and <b>the</b> <b>classes</b> to be programmed.In <b>the</b> <b>diagram,</b> <b>classes</b> are represented with boxes that contain three compartments: ...|$|R
5000|$|<b>Class</b> <b>diagram</b> derivation: Now it {{is fairly}} {{straightforward}} to derive a <b>class</b> <b>diagram</b> from <b>the</b> object diagrams used in <b>the</b> storyboards.Note, <b>the</b> <b>class</b> <b>diagram</b> {{serves as a}} common reference for all object diagrams. This ensures that overall the same types and attributes are used. Using a UML tool, you may generate a first implementation from this <b>class</b> <b>diagram.</b>|$|R
40|$|Formally {{specified}} invariants on UML models greatly {{enhance the}} correctness {{of the model}} by restricting the state space such that invalid scenarios that are admitted by <b>the</b> <b>class</b> <b>diagram</b> can be forbidden. Identification of these invariants in the situations where objects {{may or may not}} be shared is critical to the development of the model. Simple patterns based upon “shapes ” or patterns that exist in <b>the</b> <b>class</b> <b>diagram</b> can be applied to assist the developer in finding suitable places for these invariants and thus improving the preciseness or rigor of the models and the correctness of the system under development...|$|R
40|$|<b>The</b> {{object-oriented}} <b>class</b> is, in general, {{the most}} utilized element in programming and modeling. It is employed throughout the software development process, from early domain analysis phases to later maintenance phases. A <b>class</b> <b>diagram</b> typically uses elements of graph theory, e. g., boxes, ovals, lines. Many researchers have examined <b>the</b> <b>class</b> <b>diagram</b> layout from different perspectives, including visibility, juxtaposability, and aesthetics. While software {{systems can be}} incredibly complex, <b>class</b> <b>diagrams</b> represent a very broad picture of {{the system as a}} whole. The key to understanding of such complexity is use of tools such as diagrams at various levels of representation. This paper develops a more elaborate diagrammatic description of <b>the</b> <b>class</b> <b>diagram</b> that includes flows of attributes, thus providing a basic representation for specifying behavior and control instead of merely listing methods. Comment: 12 page...|$|R
40|$|International audienceWe use {{standard}} OMG metamodels (UML metamodel and CWM) {{to transform}} <b>the</b> domain model <b>class</b> <b>diagram</b> into relational database schema with integrity constraints deduced from {{the structure of}} <b>the</b> <b>class</b> <b>diagram</b> (primary keys and foreigne keys) and also integrity constraints deduced from the objects 'lifecycle. These allow a more reliable handling of null values thanks to database triggers which are also automatically generated. A prototype demonstrates the feasibility of our approach...|$|R
5000|$|In the Unified Modeling Language (UML) all {{structure}} diagrams can {{be considered}} cluster diagrams. These structure diagrams emphasize what things {{must be in the}} system being modeled. UML encounters here <b>the</b> <b>Class</b> <b>diagram,</b> Component diagram, Composite structure diagram, Deployment diagram, Object diagram, and the Package diagram.|$|R
40|$|The {{traditional}} Software Development Life Cycle (SDLC) often {{includes four}} phases: analysis, design, implementation, and testing. Reverse engineering {{is the process}} of moving back those phases by analyzing the software system and then representing it at the higher levels of abstractions. The reverse engineering software process generates high level information from the implementation phase. This information includes generating several diagrams and specification documents that describe the implemented software. <b>The</b> UML <b>class</b> <b>diagram</b> represent a valuable source of information even after the delivery of <b>the</b> software. <b>Class</b> <b>diagram</b> extraction can be done either from software’s source code, or from the executable file. In the case of source code, a review of the current tools shows that many researchers have been extracting <b>the</b> UML <b>class</b> <b>diagram</b> from an object-oriented source code based on the sequential processing approach. In this research, a proposed approach for extracting a <b>class</b> <b>diagram</b> from <b>the</b> source code is presented. The proposed approach relies on multi-threading technique in <b>the</b> <b>class</b> <b>diagram</b> extraction which is representing the parallel processing. The motivation behind using multi-threading technique is that, it gives an advantage of faster processing to any software because the threads of the program naturally lend themselves to truly concurrent execution. In this research, a <b>class</b> <b>diagram</b> extraction using multi-threading technique is designed and implemented using the C# programming language. The implemented approach is tested on three case studies that contain several types of entities and relationships between them. Testing results show that the time needed to extract <b>class</b> <b>diagram</b> using multi-threading technique for the tested three cases is less than the time needed in extracting <b>the</b> same <b>class</b> <b>diagram</b> without using multi-threading technique...|$|R
40|$|Abstract. Enterprise {{information}} {{systems can be}} developed following a model-driven paradigm. This way, models that represent the organisational work practice are used to produce models that represent the information system. Current software development methods are starting to provide guidelines {{for the construction of}} conceptual models, taking as input requirements models. This paper proposes the integration of two methods: Communication Analysis (a communication-oriented requirements engineering method [1]) and the OO-Method (a model-driven object-oriented software development method [2]). For this purpose, a systematic technique for deriving <b>class</b> <b>diagrams</b> from business process models is proposed. The business process specifications (which include message structures) are processed in order to obtain <b>class</b> <b>diagram</b> views, which are integrated to create <b>the</b> <b>class</b> <b>diagram</b> incrementally. Then, using the OLIVANOVA framework, software source code can be generated automatically. The paper also discusses the advantages and current limitations of the technique. Results show that, although there is room for improvement, the technique is feasible and it does facilitate the creation of <b>the</b> <b>class</b> <b>diagram...</b>|$|R
40|$|<b>Class</b> <b>diagrams</b> must be complemented {{with a set}} {{of system}} {{operations}} that describes how users can modify and evolve the system state. To be useful, such a set must be complete (i. e. through these operations, users should be able to modify the population of all elements in <b>the</b> <b>class</b> <b>diagram)</b> and executable (i. e. for each operation, there must exist a system state over which the operation can be successfully applied). Manual specification of these operations is an error-prone and time-consuming activity. Therefore, the goal {{of this paper is to}} automatically provide a basic set of system operations that verify these two properties. Operations are drawn from <b>the</b> elements (<b>classes,</b> attributes, etc) of <b>the</b> <b>class</b> <b>diagram</b> and take into account the possible dependencies between the different change events (i. e. inserts/updates/deletes) that may be applied to them. Afterwards, the designer could reuse our proposal to build up more complex operations...|$|R
40|$|Abstract: UML <b>class</b> <b>diagrams</b> play {{a central}} role in {{modeling}} activities. Given the difficulty in producing high quality models, modelers must be equipped with an awareness of model design problems and the ability to identify and correct such models. In this paper we observe <b>the</b> role of <b>class</b> <b>diagram</b> correctness patterns as an educational instrument for improving <b>class</b> <b>diagram</b> modeling. We describe a catalog of correctness and quality design (anti) -patterns for <b>class</b> <b>diagrams.</b> <b>The</b> patterns characterize problems, analyze their causes and provide repairing advice. Pattern specification requires an enhancement of <b>the</b> <b>class</b> <b>diagram</b> meta-model. <b>The</b> pattern classification has a major role in clarifying design problems. Finally, we describe an actual experiment of using the catalog for teaching modeling...|$|R
40|$|UML is {{now widely}} {{accepted}} {{as the standard}} modeling language for software construction. <b>The</b> <b>Class</b> <b>Diagram</b> model is its core view, providing the backbone for any modeling effort and having well formed semantics. <b>Class</b> <b>diagrams</b> are widely used for purposes such as software and language specification, database and ontology engineering, and model transformation. The central role played by <b>class</b> <b>diagrams</b> emphasizes <b>the</b> need for strengthening Computer Aided Software Engineering (CASE) tools with features {{at the level of}} modern integrated development environments. Such tools need to detect errors in models, identify the source of errors, reveal redundancies, and possibly suggest design improvements. These tasks require reasoning capabilities since they depend on the meaning of the constraints that occur in a diagram. This paper characterizes four essential reasoning problems in <b>class</b> <b>diagram</b> design, and surveys methods for their solution. The contribution of this paper lies in classifying reasoning problems in <b>the</b> <b>class</b> <b>diagram</b> model, presenting <b>the</b> state of the art results for these problems, and enlightening key issues for future research...|$|R
40|$|UML diagrams, and in {{particular}} the most frequently used one, <b>the</b> <b>class</b> <b>diagram,</b> represent a valuable source of information even after the delivery of the system, when it enters the maintenance phase. Several tools provide a reverse engineering engine to recover it from the code. In this paper, an algorithm is proposed for the improvement of the accuracy of <b>the</b> UML <b>class</b> <b>diagram</b> extracted from <b>the</b> code. Specifically, important information about inter-class relations may be missed in a reverse engineered <b>class</b> <b>diagram,</b> when weakly typed containers, i. e., containers collecting objects whose type is the top of the inheritance hierarchy, are employed. In fact, <b>the</b> <b>class</b> of <b>the</b> contained objects is not directly known, and therefore no relation with it is apparent from the container declaration. The proposed approach was applied to several software components developed at CERN. Experimental results highlight that a substantial improvement is achieved when the container type information is refined with the inferred data. The number of relations otherwise missed is relevant and the connectivity of <b>the</b> associated <b>class</b> <b>diagrams</b> is radically different when containers are considered. 14 Refs...|$|R
40|$|Abstract. <b>Class</b> <b>diagrams</b> must be complemented {{with a set}} {{of system}} {{operations}} that describes how users can modify and evolve the system state. To be useful, such a set must be complete (i. e. through these operations, users should be able to modify the population of all elements in <b>the</b> <b>class</b> <b>diagram)</b> and executable (i. e. for each operation, there must exist a system state over which the operation can be successfully applied). Manual specification of these operations is an error-prone and time-consuming activity. Therefore, the goal {{of this paper is to}} automatically provide a basic set of system operations that verify these two properties. Operations are drawn from <b>the</b> elements (<b>classes,</b> attributes, etc) of <b>the</b> <b>class</b> <b>diagram</b> and take into account the possible dependencies between the different change events (i. e. inserts/updates/deletes) that may be applied to them. Afterwards, the designer could reuse our proposal to build up more complex operations. ...|$|R
40|$|Abstract. The use of {{spreadsheets}} {{to capture}} information is widespread in industry. Spreadsheets {{can thus be}} a wealthy source of domain information. We propose to automatically extract this information and transform it into <b>class</b> <b>diagrams.</b> <b>The</b> resulting <b>class</b> <b>diagram</b> {{can be used by}} software engineers to understand, refine, or re-implement the spreadsheet’s functionality. To enable <b>the</b> transformation into <b>class</b> <b>diagrams</b> we create a library of common spreadsheet usage patterns. These patterns are localized in the spreadsheet using a two- dimensional parsing algorithm. The resulting parse tree is transformed and enriched with information from the library. We evaluate our approach on the spreadsheets from the Euses Spreadsheet Corpus by comparing a subset of <b>the</b> generated <b>class</b> <b>diagrams</b> with reference <b>class</b> <b>diagrams</b> created manually. ...|$|R
50|$|Structure: A {{graphical}} representation of <b>the</b> pattern. <b>Class</b> <b>diagrams</b> and Interaction diagrams {{may be used}} for this purpose.|$|R
40|$|It {{is widely}} {{acknowledged}} that in software engineering, {{the usage of}} metrics at the initial phases of the object oriented software can help designers to make better decisions. <b>The</b> quality of <b>class</b> <b>diagrams</b> could be a major determinant {{for the quality of}} the software product that is finally delivered. Quantitative measurements are useful to assess <b>class</b> <b>diagram</b> quality. Following this innovative thinking, two UML <b>class</b> <b>diagrams</b> are taken to measure the complexity and size. A set of metrics of complexity measures are used to measure <b>the</b> <b>class</b> <b>diagrams.</b> Seven known complexity measures are evaluated and compared for inheritance and interface usage in object oriented programming. Two UML <b>class</b> <b>diagrams</b> are introduced with possible interfaces and measured the complexity metrics and a comparison has been made between <b>the</b> <b>class</b> inheritance and class interface usage through complexity measurements...|$|R
40|$|JSON (JavaScript Object Notation) is a {{lightweight}} data-interchange format for the Internet. JSON {{is built on}} two structures: (1) a collection of name/value pairs and (2) an ordered list of values ([URL] Because of this simple approach, JSON is {{easy to use and}} {{it has the potential to}} be the data interchange format of choice for the Internet. Similar to XML, JSON schemas allow nested structures to model hierarchical data. As data interchange over the Internet increases exponentially due to cloud computing or otherwise, redundancy free JSON data are an attractive form of communication because they improve the quality of data communication through eliminating update anomaly. Nested Normal Form, a normal form for hierarchical data, is a precise characterization of redundancy. A nested table, or a hierarchical schema, is in Nested Normal Form if and only if it is free of redundancy caused by multivalued and functional dependencies. Using Nested Normal Form as a guide, this paper introduces a JSON schema design methodology that begins with UML use case diagrams, communication <b>diagrams</b> and <b>class</b> <b>diagrams</b> that model a system under study. Based on the use cases’ execution frequencies and the data passed between involved parties in the communication diagrams, the proposed methodology selects <b>classes</b> from <b>the</b> <b>class</b> <b>diagrams</b> to be <b>the</b> roots of JSON scheme trees and repeatedly adds <b>classes</b> from <b>the</b> <b>class</b> <b>diagram</b> to <b>the</b> scheme trees as long as the schemas satisfy Nested Normal Form. This process continues until all of <b>the</b> <b>classes</b> in <b>the</b> <b>class</b> <b>diagram</b> have been added to some JSON scheme trees...|$|R
40|$|Abstract: This paper formalizes UML <b>class</b> <b>diagrams</b> and {{structural}} patterns as mathematical objects {{and provides a}} precise notion of conformance of a structural model specified as a <b>class</b> <b>diagram</b> to a structural pattern. We also present a conformance verification method which represents a <b>class</b> <b>diagram</b> as a logic program and a structural pattern as a query. The conformance of <b>the</b> <b>class</b> <b>diagram</b> to <b>the</b> structural pattern is verified by computing all {{the answers to the}} query by the logic program and checking the satisfaction of realization multiplicity constraints imposed by the pattern...|$|R
40|$|Geographic {{information}} systems (GIS) {{focus on the}} management and mapping of outdoor information, their data structures are object oriented. CAFM systems manage and map indoor information. The concepts of information management and data structures in CAFM are quite similar to the concepts used in GIS. For {{the introduction of a}} CAFM system a data model is developed through the modelling language UML. The overall aim was to develop a general information model for CAFM at Stuttgart University. The development of UML is described and a short introduction in <b>the</b> UML <b>class</b> <b>diagram</b> is given. For the data model we use <b>the</b> <b>class</b> <b>diagram</b> for visualization purposes. ...|$|R
40|$|Abstract: To {{describe}} {{the structure of}} a system, <b>the</b> UML <b>Class</b> <b>Diagram</b> yields <b>the</b> means-of-choice. Therefor, <b>the</b> <b>Class</b> <b>Diagram</b> provides concepts like class, at-tribute, operation, association, generalization, aggregation, enumeration, etc. When students are introduced to this diagram, they often have to solve exercises where texts in natural language are given and they have to model the described systems. When analyzing such exercises, it becomes evident that certain kinds of phrases de-scribing a particular concept appear again and again contextualized to the described domain. In this paper, we present an approach which allows the automatic generation of tex-tual specifications from a given <b>Class</b> <b>Diagram</b> based on standard phrases in natural language. Besides supporting teachers in preparing exercises, such an approach is also valuable for various e-learning scenarios...|$|R
50|$|<b>The</b> <b>class</b> <b>diagram</b> notations Umple {{supports}} includes classes, interfaces, attributes, associations, generalizations and operations. The code Umple generates for attributes include code in the constructor, 'get' {{methods and}} 'set' methods. The generated code differs considerably {{depending on whether}} the attribute has properties such as immutability, has a default value, or is part of a key.|$|R
40|$|An {{extension}} of the object constraint language OCL by a mechanism permit-ting specification of methods updating the object state is described and investi-gated in the paper. An original version of transition rules of Abstract State Ma-chines is proposed as such a mechanism. The new language facilities are investi-gated by specification of <b>the</b> <b>class</b> <b>diagram</b> of a representative example...|$|R
40|$|Today, the N-tiers {{applications}} {{have become}} the norm for building enterprise software. In this paper {{we are going to}} present a model-driven approach to the development of N-tiers web applications based on <b>the</b> UML <b>class</b> <b>diagram.</b> <b>The</b> transformation language is the MOF 2. 0 QVT (Meta-Object Facility 2. 0 Query-View-Transformation) standard which defines the meta-model for the development of model transformation. The transformation rules defined in this paper can generate, from <b>the</b> <b>class</b> <b>diagram,</b> an XML file containing the layers of N-tiers web application respecting a MVC 2 (Model-View-Controller), DI (Dependency Injection) and DAO (Data Access Object) patterns. This file can be used to generate the end-to-end necessary code of a web applicatio...|$|R
40|$|We {{propose a}} new {{approach}} to check whether a given UML <b>class</b> <b>diagram</b> with its OCL integrity constraints satisfies a set of desirable properties such as schema satisfiability, class liveliness, redundancy of integrity constraints or reachability of partially specified states. Our approach is based on translating both <b>the</b> <b>class</b> <b>diagram</b> and <b>the</b> OCL constraints into a logic representation. Then, we use the CQC Method to verify whether these properties hold for the given diagram and constraints. Postprint (published version...|$|R
40|$|International audienceData {{warehouses}} {{are based}} on multidimensional modeling. Using On-Line Analytical Processing (OLAP) tools, decision makers navigate through and analyze multidimensional data. Typically, users need to analyze data at different aggregation levels (using roll-up and drill-down functions). Therefore, aggregation knowledge should be adequately represented in conceptual multidimensional models, and mapped in subsequent logical and physical models. However, current conceptual multidimensional models poorly represent aggregation knowledge, which (1) has a complex structure and dynamics and (2) is highly contextual. In order {{to account for the}} characteristics of this knowledge, we propose to represent it with objects (UML <b>class</b> <b>diagrams)</b> and rules in the Production Rule Representation language (PRR). Static aggregation knowledge is represented in <b>the</b> <b>class</b> <b>diagrams,</b> while rules represent the dynamics (i. e. how aggregation may be performed depending on context). We present <b>the</b> <b>class</b> <b>diagrams,</b> and a typology and examples of associated rules. We argue that this representation of aggregation knowledge enables an early modeling of user requirements in a data warehouse project. A prototype has been developed based on the Java Expert System Shell (Jess) ...|$|R
40|$|International audienceIn this {{demonstration}} we present an Eclipse plugin that implements a lightweight method for verifying ﬁne-grained operations at design time. This tool suﬃces {{to check that}} {{the execution of the}} operations (speciﬁed in Alf Action Language) is consistent with the integrity constraints deﬁned in <b>the</b> <b>class</b> <b>diagram</b> (speciﬁed in UML) and returns a meaningful feedback that helps correcting them otherwise...|$|R
50|$|The goal of LLD or a {{low-level}} design document (LLDD) {{is to give}} the internal logical design of the actual program code. High-level design is created based on the low-level design. LLD describes <b>the</b> <b>class</b> <b>diagrams</b> with <b>the</b> methods and relations between classes and program specs. It describes the modules so that the programmer can directly code the program from the document.|$|R
5000|$|The {{source code}} for <b>the</b> <b>class</b> <b>diagram</b> shown on <b>the</b> right is as follows:skinparam style strictumlclass Façade { doSomething (...) }Façade [...]> package1.Class1Façade [...]> package2.Class2Façade [...]> package3.Class3Client1 [...]> Façade : doSomething (...) Client2 [...]> Façade : doSomething (...) note as N2doSomething (...) { Class1 c1 = newClass1 (...) Class2 c2 = newClass2 (...) Class3 c3 = newClass3 (...) c1.doStuff(c2) c3.setX(c1.getX (...) [...] ); return c3.getY (...)}end noteFaçade [...]. N2 ...|$|R
50|$|This enables {{to write}} subclasses {{to change the}} way an object is created (to redefine which class to instantiate).See also <b>the</b> UML <b>class</b> <b>diagram</b> below.|$|R
