40|48|Public
50|$|More-sophisticated timers {{may have}} {{comparison}} logic {{to compare the}} <b>timer</b> <b>value</b> against a specific value, set by software, that triggers some action when the <b>timer</b> <b>value</b> matches the preset value. This might be used, for example, to measure events or generate pulse width modulated waveforms to control the speed of motors (using a class D digital electronic amplifier).|$|E
5000|$|If it uses {{external}} state {{other than}} the input, such as user input, a global variable, a hardware <b>timer</b> <b>value,</b> a random value, or stored disk data.|$|E
50|$|The 8061 had an 8-channel event-capture {{system for}} {{measuring}} and timing pulsed inputs. A 16-bit <b>timer</b> <b>value</b> {{was captured in}} a FIFO along with the new state of all 8 pins whenever a transition was detected on an enabled pin. The FIFO was implemented in a small dynamic RAM.|$|E
40|$|Temporal event {{correlation}} {{is essential}} to managing quality of service in distributed systems, especially corre-lating events from multiple components to detect problems with availability, performance, and denial of service attacks. Two challenges in temporal event correlation are: (1) handling lost events and (2) dealing with inaccurate clocks. We show that both challenges are related to event propagation skew, {{the difference in the}} time required for events to propagate from the event source to the management station at which correlation takes place (e. g., as a result of variations in resource utilizations). We develop an approach to adjusting the <b>timer</b> <b>values</b> of event correlation rules based on propagation skew in order to reduce missed alarms and false alarms. Our approach has three parts: an infrastructure for real-time measurement of propagation skew, a statistical approach to estimating propagation skew, and a controller that uses estimates of propagation skew to update <b>timer</b> <b>values</b> in temporal rules. Our approach eliminates the need for manual adjustments of <b>timer</b> <b>values.</b> Further, studies of a prototype implementation suggest that our approach produces results that are at least as good as an optimal fixed adjustment in <b>timer</b> <b>values.</b> 1 1...|$|R
30|$|Our <b>timer’s</b> <b>value</b> is {{affected}} by user mobility and surrounding objects while the <b>value</b> of their <b>timer</b> {{is affected}} only by user mobility.|$|R
50|$|Timeout {{values and}} {{validity}} information is {{contained within the}} messages conveying information allowing for differing <b>timer</b> <b>values</b> to be used at differing nodes.|$|R
50|$|Sicher uses {{asymmetric}} point-to-point RSA cryptosystem with 2048 bit long key. All {{data exchange}} between mobile apps and Sicher servers is protected using SSL. Company claims that encrypted messages are deleted from servers {{as soon as}} they have been delivered to recipient. Lifetime of encrypted data (pictures, voice messages, files) is defined by message self-destruction <b>timer</b> <b>value</b> which has a maximum of 14 days, however the chat participant may choose to manually purge messages. On mobile devices all messages, received files and metadata are encrypted before saving them to internal storage, where application passcode is used as a key to symmetric encryption.|$|E
5000|$|Whenever {{a packet}} is sent, the sender sets a timer {{that is a}} {{conservative}} estimate of when that packet will be acked. If the sender does not receive an ack by then, it transmits that packet again. The timer is reset every time the sender receives an acknowledgement. This means that the retransmit timer fires only when the sender has received no acknowledgement for a long time. Typically the <b>timer</b> <b>value</b> is set to [...] where [...] is the clock granularity. Further, in case a retransmit timer has fired and still no acknowledgement is received, the next timer is set to twice the previous value (up to a certain threshold). Among other things, this helps defend against a man-in-the-middle denial of service attack that tries to fool the sender into making so many retransmissions that the receiver is overwhelmed.|$|E
5000|$|HPET is a {{continuously}} running timer {{that counts}} upward, not a one-shot device that counts down to zero, causes one interrupt and then stops. Since HPET compares the actual <b>timer</b> <b>value</b> and the programmed target value on equality rather than [...] "greater or equal", interrupts can be missed {{if the target}} time has already passed when the comparator value is written into the chip's register. In such a case, {{not only is the}} intended interrupt missed, but actually set far into the future (about 232 or 264 counts). In the presence of non-maskable interrupts (such as a System Management Interrupt (SMI)) that do not have a hard upper bound on their execution time, this race condition requires time-consuming re-checks of the timer after setup and is hard to avoid completely. The difficulties are exacerbated if the comparator value is not synchronized with the timer immediately, but delayed by one or two ticks, as some chipsets do.|$|E
40|$|Event {{correlation}} {{is essential}} to realizing self-managing distributed systems. For example, distributed systems often require that events be correlated from multiple systems using temporal patterns to detect denial of service attacks and to warn of problems with business critical applications that run on multiple servers. This paper addresses how to specify <b>timer</b> <b>values</b> for temporal patterns so as to manage the trade-off between false alarms and undetected alarms. A central concern is addressing the variability of event propagation delays due to factors such as contention for network and server resources. To this end, we develop an architecture and an adaptive control algorithm that dynamically compensate for variations in propagation delays. Our approach makes Management Stations more autonomic by avoiding the need for manual adjustments of <b>timer</b> <b>values</b> in temporal rules. Further, studies we conducted of a testbed system suggest that our approach produces results that {{are at least as}} good as an optimal fixed setting of <b>timer</b> <b>values.</b> 1...|$|R
40|$|Temporal event {{correlation}} {{is essential}} to realizing self-managing distributed systems. Autonomic controllers often require that events be correlated across multiple components using rule patterns with timer-based transitions, e. g., to detect denial of service attacks and to warn of staging problems with business critical applications. This short paper discusses automatic adjustment of <b>timer</b> <b>values</b> for event correlation rules, in particular compensating for the variability of event propagation delays due to factors such as contention for network and server resources. We describe a corresponding Management Station architecture and present experimental studies on a testbed system that suggest that this approach can produce results at least as good as an optimal fixed setting of <b>timer</b> <b>values.</b> 1...|$|R
40|$|In sensor network, energy {{conservation}} {{is one of}} the most critical issues since sensor nodes should perform a sensing task for a long time (e. g., lasting a few years) but the battery of them cannot be replaced in most practical situations. For this purpose, numerous {{energy conservation}} schemes have been proposed and duty cycling scheme is considered the most suitable power conservation technique, where sensor nodes alternate between states having different levels of power consumption. In order to analyze the energy consumption of energy conservation scheme based on duty cycling, it is essential to obtain the probability of each state. In this paper, we analytically derive steady state probability of sensor node states, i. e., sleep, listen, and active states, based on traffic characteristics and <b>timer</b> <b>values,</b> i. e., sleep timer, listen timer, and active timer. The effect of traffic characteristics and <b>timer</b> <b>values</b> on the steady state probability and energy consumption is analyzed in detail. Our work can provide sensor network operators guideline for selecting appropriate <b>timer</b> <b>values</b> for efficient energy conservation. The analytical methodology developed in this paper can be extended to other energy conservation schemes based on duty cycling with different sensor node states, without much difficulty...|$|R
30|$|Selective {{retransmission}} {{requested by}} receiver for lost packets: When the retransmission <b>timer</b> <b>value</b> for the buffered packets {{at the source}} and along {{the path to the}} PN expires, it is adjusted to be double its current value. The lost packets are not retransmitted until the adjusted <b>timer</b> <b>value</b> expires. To handle the packet loss along the path from the source to the PN, an indication is made to the source so that it can retransmit the lost packets selectively before their timeout value expires.|$|E
30|$|Our timer’s {{value is}} {{influenced}} by the rate of blocking and recovery of VLC link while their <b>timer</b> <b>value</b> {{is influenced by}} the frequency of crossing VLC/WLAN boundary.|$|E
30|$|In UDP, {{a packet}} {{lost in the}} {{internal}} queues of the JSLEE application server will always be retransmitted with increased <b>timer</b> <b>value.</b> Thus, overall throughput is much lower, but the decrease is smoother.|$|E
30|$|The {{deactivation}} command {{from the}} donor eNB to the RN can contain parameters needed for future reactivation of the RN. This can include <b>timer</b> <b>values</b> {{such as a}} sleep interval during which the RN completely shuts down its transceiver, and also on-duration periods during which the RN will listen on a common control channel such as a paging channel {{to determine if the}} donor eNB is trying to reactivate it. This procedure can be done in a way similar to the Discontinuous Reception (DRX) procedure of LTE [9].|$|R
40|$|Radio Link Control (RLC) is {{the layer}} two {{protocol}} used in 3 G UMTS cellular systems for flow control and error recovery. Due {{to the complexity}} of the protocol and the multitude of parameter configurations available, it is extremely difficult to model RLC analytically. Therefore we present a simulation model to study RLC performance in UMTS systems. We focus on the impacts of the poll prohibit timer and the poll timer on RLC throughput, goodput and delay. Our simulation results provide some insight into the optimization of these two <b>timer</b> <b>values...</b>|$|R
3000|$|Similarly, Fig. 12 {{compares the}} {{simulation}} {{results of the}} mean E 2 E delay for the given <b>timer</b> expiry <b>values.</b> As discussed in the beginning, the larger values of waiting time, T [...]...|$|R
30|$|A distance-based message {{dissemination}} {{approach is}} utilized which introduces forwarding delay for each node {{based on their}} distance from the previous node. The delay heuristic is implemented {{with the help of}} a simple timer (see Lines 19 - 26, Algorithm 2) and it works in two ways. First, the TC message is flooded in a controlled manner, i.e., it ensures that each node disseminates the TC message only once. Up on receiving the first TC message each node set the <b>timer</b> <b>value</b> based on the parameter Td,fwd, given at line 20. The <b>timer</b> <b>value</b> is set proportional to the distance between the receiving node and the previous node. Once set, the <b>timer</b> <b>value</b> cannot be re-initiated by overhearing of any subsequent TC message. Second, the coloring of the nodes and the increment in hop count value require a proper forwarding sequence, i.e., a node that is at n th hops distance from the previous node forwards the TC message before a node n + 1 th hops away. Thus, the cumulative effect is to give higher priority to the nodes that are closer to the pervious node.|$|E
30|$|We {{conducted}} {{four different}} sets of experiments. During the first experiment, the effect of various context attributes on the routing performance was studied. In the second experiment, the effect of variation in <b>timer</b> <b>value</b> was studied. In the third experiment, the effect of number of mobile nodes on routing performance of CONCOR was compared with DSG and CAR.|$|E
40|$|Abstract—OBS {{networks}} offer {{a highly}} efficient transport infrastructure for bursty data traffic. Video streaming content distribution networks are a clear candidate {{to use this}} promising technology. Traffic injected into an OBS network is a burst arrival process whose characteristics depend not only on input traffic parameters but also on design parameters of the OBS network. The properties of this traffic will dictate how it is affected by transmision over the OBS core and thus the user-perceived quality of the video stream that is delivered {{at the edge of}} the network. This paper evaluates different parameters in the ingress node that affect the losses suffered by the input traffic. Rules for the optimum selection of these parameters are presented: number of wavelengths, buffer size, <b>timer</b> <b>value.</b> The results show the strong dependence of losses on the <b>timer</b> <b>value</b> selected at the burst creation node. I...|$|E
40|$|AAL 2 {{has been}} adopted in ITU-T and ATM Forum to reduce the packing delay for voice trunking. A {{parameter}} called "Timer_CU" is used in AAL 2 to avoid prolonged delay for any packet. However, the AAL 2 documents do not discuss how to set the Timer_CU value. In this paper, we establish a Markov chain model to analyze the AAL 2 packing process. We find that the packing density and link efficiency depend significantly on the <b>Timer</b> CU <b>value.</b> The analysis of this paper gives an algorithm to calculate a reference <b>Timer</b> CU <b>value</b> to achieve desired link efficiency. Simulation results that verify the analysis are also presented...|$|R
40|$|Industrial-size specifications/models (whose {{state space}} is often infinite) {{can not be}} model checked in a direct way— a {{verification}} model of a system is model checked instead. Program transformation {{is a way to}} build a finite-state verification model that can be submitted to a model checker. Abstraction is another technique {{that can be used for}} the same purpose. This paper presents a transformation of SDL timers aimed at the reduction of the infinite domain of <b>timer</b> <b>values</b> to a finite one with preserving the behaviour of a system. A timer abstraction is proposed to further reduce the state space. We discuss the ideas behind these transformations and argue their correctness...|$|R
40|$|Modelling {{distributed}} systems requires notions as locations, communication among the distributed processes, and resource access. To express time constraints for such systems, we have introduced timed distributed π-calculus called tDπ {{as an extension}} of the π-calculus with locations, types and timers. Timers define both timeouts for communication channels and timeouts for resources. We define the operational semantics of tDπ by using a reduction relation. We introduce and study several timed barbed bisimulations in the framework of tDπ. The bisimulations are compared with respect to their distinguishing power over timed located processes. The paper also emphasises the diversity of observational choices in tDπ (communication channel names, locations, types and <b>timer</b> <b>values).</b> ...|$|R
3000|$|... {{stands for}} the backoff <b>timer</b> <b>value.</b> In {{addition}} to normal state diagram we also add 2 extra states to model the nonsaturation traffic condition. A node may now wait in the idle state for a packet from upper layers before going into backoff procedure. This corresponds to a delay in the idle state and it is represented by upper left two sates in the Figure 3. The delay in the idle state is modeled geometric with parameter [...]...|$|E
3000|$|... as its {{internal}} <b>timer</b> <b>value.</b> A relay node whose internal timer expires first broadcasts {{a signal to}} neighbor relays to stop their transmission to reserve the channel, which is a first-come-first-serve policy. The sink nodes that successfully overhear the network-coded packets decode the packets using theirs own stored data and update their decoding results. After that, the sink nodes transmit report packets again. Until {{there are no more}} packets to be delivered from the relay nodes to the sink nodes, the procedure is repeated.|$|E
40|$|International audienceIn {{a typical}} slotted bus-based optical {{metropolitan}} network, {{the position of}} access node on the networkpsilas bus have a large impact on the network performance. We refer to this problem in data transmission as the unfairness property. In fact, the first nodes on the bus have priority over downstream nodes. Another factor which has {{a significant impact on}} the network performance is the choice of <b>Timer</b> <b>value,</b> which is used to create the fixed-size optical packet. An unsuitable choice of Timer values may lead to wasted network bandwidth. Indeed, small Timer values generate optical packets with very low filling ratios; while a very big <b>Timer</b> <b>value</b> leads to excessive packet creation delays (and therefore high access delays) when the arrival rate of electronic client packets becomes low. In this paper, we investigate the impact of Timer values on the network performance by simulating the slotted bus-based network that supports multi-service. In this context, we are interested in two study cases: with and without quality of service (QoS) Upgrade mechanism. Additionally, we will show that the slotted bus-based network with QoS Upgrade can improve the network performance, in terms of mean access delay and loss ratio of electronics packets clients, compared with unslotted bus-based network that supports variable-size optical packet...|$|E
40|$|Abstract Modelling {{distributed}} systems requires notions as lo-cations, communication among the distributed processes, and resource access. To express time constraints for suchsystems, we have introduced timed distributed ss-calculuscalled tDss {{as an extension}} of the ss-calculus with locations,types and timers. Timers define both timeouts for communication channels and timeouts for resources. We define theoperational semantics of tDss by using a reduction relation. We introduce and study several timed barbed bisimulations in the framework of tDss. The bisimulations are comparedwith respect to their distinguishing power over timed located processes. The paper also emphasises the diversityof observational choices in tDss (communication channelnames, locations, types and <b>timer</b> <b>values)</b> ...|$|R
50|$|The {{new digital}} delay box timers used decimal or {{binary coded decimal}} {{thumbwheel}} switches to set countdown <b>timer</b> <b>values</b> in digital logic. The thumbwheels also fed back a visual numerical value that the race car driver could use to help him calculate proper settings. A popular early digital unit of this type was designed and produced by Robert Furrow (B. F. Electronics of Weatherford, Oklahoma). Robert Furrow's delay box utilized a quartz crystal for timing accuracy and Transistor-transistor logic (TTL) integrated circuits. Furrow's digital delay box was a substantial improvement in accuracy and ergonomics but suffered in reliability. In the United States many B.F. Electronics delay timers were sold Nationwide.|$|R
40|$|Abstract — Traditional {{reliable}} link layer protocols set their fixed retransmission timers {{under the assumption}} that they operate in isolation over the link. Emerging wireless networks however allow multiple link layer sessions to dynamically share the link. To assess the impact of this development, we examine the performance of Web Browsing over a Selective Repeat protocol with fixed retransmission timers, showing that the optimal retransmission <b>timer</b> <b>values</b> depend on the level of contention. We therefore propose an adaptive Selective Repeat protocol that modifies its retransmission timers based on prevailing conditions. Our measurements show that this adaptive scheme provides excellent Web Browsing performance regardless of the level of contention, under two very different wireless error models. I...|$|R
40|$|Abstract—In {{a mobile}} {{database}} environment, multiple mobile hosts may access the shared data item {{at the same}} time. This may lead to inconsistency of data items. The traditional pessimistic protocols are not suitable in mobile environments because of disconnections of mobile hosts for invariant time. The timeout based protocols solves the problem of starvation of resources, but {{with an increase in}} number of rollback operations. The Analytical approach is a variation of Timeout based commit protocols where a transaction is executed only if the expected time for execution is within the current <b>timer</b> <b>value.</b> Experimental results show better throughput, and less waiting time for individual transaction...|$|E
30|$|The global IPDS {{maintains}} a node profile which consist {{of the following}} information namely the client node's IP address, the client node's MAC address, the client node's <b>timer</b> <b>value,</b> the client node's location proof information [30], the client node's allotted bandwidth and the TTL value. The global IPDS also {{maintains a}} local profile which consists of the IP address of the local IPDS, {{the total number of}} client nodes connected to it and its neighboring local IPDS. The local IPDS maintains a profile which consists of the timer values of each client node, the number of flows within each client node, its corresponding port number and the corresponding client node to which the flow is being transmitted or received.|$|E
30|$|Registration overhead: The {{number of}} {{communications}} {{and the number}} of computations required by a client node during the registration process determines the registration overhead (Figure 12). A single client node communicates four messages to complete the registration process. But each node requires X-OR computations for a single <b>timer</b> <b>value</b> to complete the registration process, which is reasonable. The computations are required in all phases to continually monitor the registration of client nodes, to allocate bandwidth as well as to analyze traffic and to effectively mitigate spoof-based collaborative flooding attacks. The computation overhead can be balanced by placing reasonable number of local IPDs in the network. As the number of local IPDS increases in the network, the computation overhead is tolerated to 60 %.|$|E
50|$|Commodore {{embedded}} reduced (just 4 registers) CIA-like logic for {{the cost}} reduced Commodore 1571 inside the C128DCR (See Commodore 128) in a gate array called 5710 which also contains other functions.The 5710 CIA has the serial clock for the fast serial interface hardwired to a CIA6526 equivalent <b>Timer</b> A <b>value</b> of 5, leading to a per-bit time of 5µs on transmission. This is different from {{what used to be}} a <b>Timer</b> A <b>value</b> of 6 in the 6526 CIA in the original Commodore 1571. The 5710 CIA does not contain timer or timer control registers. It only contains two port registers and the register to control the serial shifter and its event.|$|R
40|$|Many {{networked}} {{applications that}} {{run in the}} background on a mobile device incur significant energy drains when using the cellular radiointerfaceforcommunication. Thisismainlydue totheradiotail, where the cellular radio remains in a high energy state for up to 20 saftereachcommunicationspurt. Inordertocutdownenergy consumption, manyrecentdevicesemployfastdormancy,afeature that forces the client radioto quickly go intoalow energy state after a fixed short idle period. However, aggressive idle <b>timer</b> <b>values</b> for fast dormancy can increase signaling overhead due to frequent state transitions, which negatively impacts the network. In this work, we have designed and implemented RadioJockey, a system that uses program execution traces to predict the end of communication spurts,thereby accuratelyinvoking fastdormancy without increasing network signaling load. We evaluate RadioJockey on...|$|R
40|$|Abstract:- This paper proposes and simulates a new ad hoc {{multicasting}} {{routing protocol}} called Modified On-Demand Multicast Routing Protocol (MODMRP). The MODMRP {{is based on}} On-Demand Multicasting Routing Protocol (ODMRP). MODMRP suggests two approaches aimed to reduce the service traffic; the local detection of routes and the information usage on the channels condition during the route information update <b>timer</b> <b>values.</b> The goal of MODMRP is to improve packet delivery efficiency. Through a course of simulation experiments, the MODMRP is compared to the ODMRP in reference to number factors such as Ratio of Packets Delivery and transmission delays. The Simulation results show {{an increase in the}} percentage of delivered multicast datagram on an average of 2 % and a routing overhead costs decreased on average of 20. 5 % when compared to ODMRP...|$|R
